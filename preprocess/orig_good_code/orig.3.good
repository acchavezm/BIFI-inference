n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = l [ 0 ] , sum ( l [ 1 : ] ) <NEWLINE> m = abs ( a - b ) <NEWLINE> for v in l [ 1 : - 1 ] : <NEWLINE> <INDENT> a += v <NEWLINE> b -= v <NEWLINE> m = min ( m , abs ( a - b ) ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> sw = True <NEWLINE> b = sorted ( a , reverse = True ) <NEWLINE> <NL> if b [ 0 ] > b [ 1 ] : <NEWLINE> <INDENT> max2 = b [ 1 ] <NEWLINE> max1 = b [ 0 ] <NEWLINE> sw = False <NEWLINE> <NL> <DEDENT> if sw == True : <NEWLINE> <INDENT> max1 = b [ 0 ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if a [ k ] == max1 : <NEWLINE> <INDENT> print ( max2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> s = [ [ a % 10 , a // 10 * 10 + 10 , a ] , [ b % 10 , b // 10 * 10 + 10 , b ] , [ c % 10 , c // 10 * 10 + 10 , c ] , [ d % 10 , d // 10 * 10 + 10 , d ] , [ e % 10 , e // 10 * 10 + 10 , e ] ] <NEWLINE> s . sort ( ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if s [ 0 ] [ 0 ] == 0 : <NEWLINE> <INDENT> s [ 0 ] [ 1 ] -= 10 <NEWLINE> s . append ( s . pop ( 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> s = np . array ( s ) <NEWLINE> ans = s [ 0 ] [ 2 ] + sum ( s [ 1 : , 1 ] ) <NEWLINE> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x % y == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> cnt = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if ( x * cnt ) % y != 0 : <NEWLINE> <INDENT> ans = x * cnt <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <NL> H = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( int ( math . log2 ( H ) ) + 1 ) : <NEWLINE> <INDENT> cnt += 2 ** i <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> L = len ( bin ( H ) ) - 2 <NEWLINE> ans = 0 <NEWLINE> for j in range ( L ) : <NEWLINE> <INDENT> ans += 2 ** j <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> max_cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for div in range ( 0 , 7 ) : <NEWLINE> <INDENT> if n % 2 ** div == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt > max_cnt : <NEWLINE> <INDENT> max_cnt = cnt <NEWLINE> ans = n <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> a . remove ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( a [ 0 ] if len ( a ) != 0 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lucas = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> lucas . append ( lucas [ i - 1 ] + lucas [ i - 2 ] ) <NEWLINE> <NL> <DEDENT> print ( lucas [ N ] ) <NEWLINE>
flag = [ False ] * 100001 <NEWLINE> c = [ 0 ] * 100002 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 2 , 100000 ) : <NEWLINE> <INDENT> if ( not ( flag [ i ] ) ) : <NEWLINE> <INDENT> for j in range ( i + i , 100000 , i ) : <NEWLINE> <INDENT> flag [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 , 100000 , 2 ) : <NEWLINE> <INDENT> if ( not ( flag [ i ] ) and not ( flag [ ( i + 1 ) // 2 ] ) ) : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 , 100000 ) : <NEWLINE> <INDENT> c [ i ] += c [ i - 1 ] <NEWLINE> <NL> <DEDENT> while ( n ) : <NEWLINE> <INDENT> n -= 1 <NEWLINE> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( c [ r ] - c [ l - 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def dfs ( prev , u ) : <NEWLINE> <INDENT> if visited [ u ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ u ] += cnt [ prev ] <NEWLINE> visited [ u ] = True <NEWLINE> for nu in graph [ u ] : <NEWLINE> <INDENT> if visited [ nu ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( u , nu ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p ] += x <NEWLINE> <NL> <DEDENT> visited = [ True ] + [ False ] * n <NEWLINE> <NL> dfs ( 0 , 1 ) <NEWLINE> <NL> print ( * cnt [ 1 : ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> dp = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> P = int ( input ( ) ) <NEWLINE> dp_p = list ( map ( lambda x : x + P , dp ) ) <NEWLINE> dp = list ( set ( dp + dp_p ) ) <NEWLINE> <NL> <DEDENT> P_List = [ 0 ] + [ i for i in dp if i % 10 != 0 ] <NEWLINE> print ( max ( P_List ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> tens = [ ] <NEWLINE> others = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> if s % 10 == 0 : <NEWLINE> <INDENT> tens . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> others . append ( s ) <NEWLINE> <DEDENT> <DEDENT> tens . sort ( reverse = True ) <NEWLINE> others . sort ( reverse = True ) <NEWLINE> <NL> score = sum ( tens ) + sum ( others ) <NEWLINE> if score % 10 == 0 : <NEWLINE> <INDENT> if len ( others ) != 0 : <NEWLINE> <INDENT> print ( score - min ( others ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( score ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = ( ans * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> X = [ 0 for _ in range ( N ) ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) [ : : - 1 ] : <NEWLINE> <INDENT> v = 0 <NEWLINE> for j in range ( i , N , i + 1 ) : <NEWLINE> <INDENT> v += X [ j ] <NEWLINE> <DEDENT> if v % 2 != A [ i ] : <NEWLINE> <INDENT> X [ i ] = 1 <NEWLINE> ans . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> if 2 not in a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <NL> <INDENT> x = a [ x - 1 ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <NL> if x == 2 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 1 <NEWLINE> min_P = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ i ] < min_P : <NEWLINE> <INDENT> min_P = P [ i ] <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> path = [ [ False ] * n for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> path [ a ] [ b ] = True <NEWLINE> path [ b ] [ a ] = True <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in itertools . permutations ( range ( n ) , n ) : <COMMENT> <NEWLINE> <INDENT> if i [ 0 ] == 0 : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j == n - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> if not path [ i [ j ] ] [ i [ j + 1 ] ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] <NEWLINE> <NL> if A [ 0 ] != 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev_min , prev_max = 2 , 3 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if a > prev_max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if prev_min % a == 0 : <NEWLINE> <INDENT> now_min = prev_min <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now_min = ( prev_min // a + 1 ) * a <NEWLINE> <DEDENT> if now_min > prev_max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> diff = prev_max - now_min <NEWLINE> now_max = now_min + ( diff // a + 1 ) * a - 1 <NEWLINE> prev_min , prev_max = now_min , now_max <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( prev_min , prev_max ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> log = [ ] <NEWLINE> button = 1 <NEWLINE> count = 0 <NEWLINE> while button != 2 : <NEWLINE> <INDENT> button = a [ button - 1 ] <NEWLINE> count += 1 <NEWLINE> log . append ( button ) <NEWLINE> if count == N + 1 : <NEWLINE> <INDENT> count = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> minimun = max ( l ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] <= minimun : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> minimun = l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> answer = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> answer = answer * i % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
s = [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> <NL> if sum ( s ) % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . sort ( ) <NEWLINE> for i , x in enumerate ( s ) : <NEWLINE> <INDENT> if x % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( s ) - x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> V = <STRING> <NEWLINE> Lavida = [ 1 ] * 26 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> Lavida [ V . index ( S [ i ] ) ] += 1 <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> count *= Lavida [ i ] <NEWLINE> count = count % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ( count - 1 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
R , G , B , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for r in range ( n // R + 1 ) : <NEWLINE> <INDENT> if R * r > n : break <NEWLINE> for g in range ( n // G + 1 ) : <NEWLINE> <INDENT> ball = R * r + G * g <NEWLINE> if ball > n : break <NEWLINE> if ( n - ball ) % B == 0 : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> button = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> button [ i ] = int ( input ( ) ) - 1 <NEWLINE> <DEDENT> count , now = 0 , 0 <NEWLINE> <NL> while count <= N : <NEWLINE> <INDENT> now = button [ now ] <NEWLINE> count += 1 <NEWLINE> if now == 1 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> li = l [ i - 1 ] + l [ i - 2 ] <NEWLINE> l . append ( li ) <NEWLINE> <DEDENT> print ( l [ len ( l ) - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) ; a = len ( s ) <NEWLINE> t = input ( ) ; b = len ( t ) <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : return a <NEWLINE> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <DEDENT> L = lcm ( len ( s ) , len ( t ) ) <NEWLINE> <NL> d = { } <NEWLINE> now = 0 <NEWLINE> for i in range ( 0 , L , L // a ) : <NEWLINE> <INDENT> d [ i ] = s [ now ] <NEWLINE> now += 1 <NEWLINE> <DEDENT> now = 0 <NEWLINE> for j in range ( 0 , L , L // b ) : <NEWLINE> <INDENT> if d . get ( j , t [ now ] ) != t [ now ] : <NEWLINE> <INDENT> print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> now += 1 <NEWLINE> <DEDENT> print ( L ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 2020 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ( i * j ) % 2019 , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> <NL> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> x = int ( s [ 2 ] ) <NEWLINE> <NL> def bet_ween ( p , q ) : <NEWLINE> <INDENT> if p < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( p // q ) + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> fa = bet_ween ( a - 1 , x ) <NEWLINE> fb = bet_ween ( b , x ) <NEWLINE> answer = fb - fa <NEWLINE> print ( int ( answer ) ) <NEWLINE>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Price_List = list ( map ( lambda x : x * ( - 1 ) , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> heapq . heapify ( Price_List ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> val = heapq . heappop ( Price_List ) * - 1 // 2 * - 1 <NEWLINE> heapq . heappush ( Price_List , val ) <NEWLINE> <DEDENT> print ( - sum ( Price_List ) ) <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> c_lists = [ ] <NEWLINE> t_lists = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c_i , t_i = map ( int , input ( ) . split ( ) ) <NEWLINE> c_lists . append ( c_i ) <NEWLINE> t_lists . append ( t_i ) <NEWLINE> <NL> <DEDENT> costs = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if t_lists [ j ] <= t : <NEWLINE> <INDENT> costs . append ( c_lists [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if not costs : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> costs . sort ( ) <NEWLINE> ans = costs [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> c = [ 0 ] * 1001 <NEWLINE> for i in L : c [ i ] += 1 <NEWLINE> for i in range ( 1000 ) : c [ i + 1 ] = c [ i ] + c [ i + 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> l , r = abs ( L [ i ] - L [ j ] ) , min ( L [ i ] + L [ j ] - 1 , 1000 ) <NEWLINE> ans += c [ r ] - c [ l ] <NEWLINE> if l < L [ i ] and L [ i ] <= r : ans -= 1 <NEWLINE> if l < L [ j ] and L [ j ] <= r : ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 3 ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> H = [ int ( s ) for s in str ( input ( ) ) . split ( ) ] <NEWLINE> dp = np . full ( 10 ** 5 + 10 , np . inf ) <NEWLINE> <NL> def rec ( i ) : <NEWLINE> <INDENT> if dp [ i ] < np . inf : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> res = np . inf <NEWLINE> res = min ( res , rec ( i - 1 ) + abs ( H [ i ] - H [ i - 1 ] ) ) <NEWLINE> if i > 1 : <NEWLINE> <INDENT> res = min ( res , rec ( i - 2 ) + abs ( H [ i ] - H [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> dp [ i ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> def main3 ( ) : <NEWLINE> <INDENT> print ( int ( rec ( N - 1 ) ) ) <NEWLINE> <NL> <DEDENT> def main2 ( ) : <NEWLINE> <INDENT> dp = np . full ( 10 ** 5 + 10 , np . inf ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if i + 1 < N : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ i ] + abs ( H [ i ] - H [ i + 1 ] ) ) <NEWLINE> <DEDENT> if i + 2 < N : <NEWLINE> <INDENT> dp [ i + 2 ] = min ( dp [ i + 2 ] , dp [ i ] + abs ( H [ i ] - H [ i + 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( dp [ N - 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> r , s , p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> win_point = { <NEWLINE> <INDENT> <STRING> : r , <NEWLINE> <STRING> : s , <NEWLINE> <STRING> : p , <NEWLINE> <DEDENT> } <NEWLINE> <NL> next_hands = { <NEWLINE> <INDENT> <STRING> : [ <STRING> , <STRING> ] , <NEWLINE> <STRING> : [ <STRING> , <STRING> ] , <NEWLINE> <STRING> : [ <STRING> , <STRING> ] , <NEWLINE> <DEDENT> } <NEWLINE> <NL> enemy_hands = input ( ) <NEWLINE> <NL> <NL> def can_win ( enemy_hand , my_hands ) : <NEWLINE> <COMMENT> <NL> <INDENT> if enemy_hand == <STRING> and <STRING> in my_hands : <NEWLINE> <INDENT> return True , <STRING> <NEWLINE> <DEDENT> if enemy_hand == <STRING> and <STRING> in my_hands : <NEWLINE> <INDENT> return True , <STRING> <NEWLINE> <DEDENT> if enemy_hand == <STRING> and <STRING> in my_hands : <NEWLINE> <INDENT> return True , <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return False , None <NEWLINE> <NL> <NL> <DEDENT> point = 0 <NEWLINE> <NL> for index in range ( K ) : <NEWLINE> <INDENT> now_hands = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( index , N , K ) : <NEWLINE> <INDENT> win , hand = can_win ( enemy_hands [ i ] , now_hands ) <NEWLINE> <NL> if win : <NEWLINE> <INDENT> point += win_point [ hand ] <NEWLINE> now_hands = next_hands [ hand ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> now_hands = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
import sys <NEWLINE> reader = ( s . rstrip ( ) for s in sys . stdin ) <NEWLINE> input = reader . __next__ <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def solve ( stns , idx , mem ) : <NEWLINE> <NL> <INDENT> if idx >= len ( stns ) - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if idx in mem : <NEWLINE> <INDENT> return mem [ idx ] <NEWLINE> <NL> <DEDENT> if idx == len ( stns ) - 2 : <NEWLINE> <COMMENT> <NL> <INDENT> final_step = abs ( stns [ idx ] - stns [ idx + 1 ] ) <NEWLINE> mem [ idx ] = final_step <NEWLINE> return final_step <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> step1 = solve ( stns , idx + 1 , mem ) + abs ( stns [ idx ] - stns [ idx + 1 ] ) <NEWLINE> <COMMENT> <NL> step2 = solve ( stns , idx + 2 , mem ) + abs ( stns [ idx ] - stns [ idx + 2 ] ) <NEWLINE> <NL> min_cost = min ( step1 , step2 ) <NEWLINE> mem [ idx ] = min_cost <NEWLINE> <NL> return min_cost <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def take_input ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> stns = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mem = { } <NEWLINE> res = solve ( stns , 0 , mem ) <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> take_input ( ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , k = MAP ( ) <NEWLINE> a = LIST ( ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> if a [ 0 ] == k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for x in a : <NEWLINE> <INDENT> m = gcd ( m , x ) <NEWLINE> <DEDENT> for x in a : <NEWLINE> <INDENT> if x - k >= 0 and ( x - k ) % m == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> A = [ 0 ] * N <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> X = [ 0 ] * M <NEWLINE> Y = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> X [ i ] , Y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ind = - 1 <NEWLINE> d_min = float ( <STRING> ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> d = abs ( A [ i ] - X [ j ] ) + abs ( B [ i ] - Y [ j ] ) <NEWLINE> if d < d_min : <NEWLINE> <INDENT> d_min = d <NEWLINE> ind = j + 1 <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = ind <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( * solve ( ) , sep = <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> flag = 1 <NEWLINE> c_count = 0 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if 2 <= i <= len ( S ) - 2 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> c_count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] . islower ( ) == False : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> if c_count == 1 and flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> maze = [ [ ] for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> maze [ i ] = np . array ( list ( input ( ) ) ) == <STRING> <NEWLINE> <DEDENT> maze = np . array ( maze ) <NEWLINE> <NL> up = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> down = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> right = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> left = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> up [ i ] = ( up [ i - 1 ] + 1 ) * maze [ i ] <NEWLINE> down [ - ( i + 1 ) ] = ( down [ - i ] + 1 ) * maze [ - ( i + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> right [ : , i ] = ( right [ : , i - 1 ] + 1 ) * maze [ : , i ] <NEWLINE> left [ : , - ( i + 1 ) ] = ( left [ : , - i ] + 1 ) * maze [ : , - ( i + 1 ) ] <NEWLINE> <NL> <DEDENT> print ( np . max ( up + down + right + left ) - 3 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ ] , [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( a ) <NEWLINE> r . append ( b ) <NEWLINE> <DEDENT> num = list ( range ( 1 , n + 1 ) ) <NEWLINE> lmax = max ( l ) <NEWLINE> rmin = min ( r ) <NEWLINE> if lmax > rmin : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gate = set ( range ( lmax , rmin + 1 ) ) <NEWLINE> ans = list ( set ( num ) & gate ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . p = [ i for i in range ( n ) ] <NEWLINE> self . components = n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . p [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ x ] = self . root ( self . p [ x ] ) <NEWLINE> return self . p [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . root ( x ) , self . root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . p [ x ] = y <NEWLINE> self . components -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return ( self . root ( x ) == self . root ( y ) ) <NEWLINE> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> UF = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> X , Y , Z = map ( int , input ( ) . split ( ) ) <NEWLINE> X , Y = X - 1 , Y - 1 <NEWLINE> UF . unite ( X , Y ) <NEWLINE> <NL> <DEDENT> print ( UF . components ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = sorted ( [ a [ i ] - i for i in range ( n ) ] ) <NEWLINE> print ( sum ( [ abs ( i - a [ n // 2 ] ) for i in a ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> st = [ ] <NEWLINE> pt = [ ] <NEWLINE> ch = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> st . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> pt . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for j in st : <NEWLINE> <INDENT> for k in pt : <NEWLINE> <INDENT> d = abs ( j [ 0 ] - k [ 0 ] ) + abs ( j [ 1 ] - k [ 1 ] ) <NEWLINE> ch . append ( d ) <NEWLINE> <DEDENT> print ( ch . index ( min ( ch ) ) + 1 ) <NEWLINE> ch = [ ] <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( input ( ) for i in range ( n ) ) <NEWLINE> a = collections . Counter ( l ) <NEWLINE> a = list ( a . values ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] % 2 != 0 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = int ( l [ i ] ) <NEWLINE> <NL> <DEDENT> cnt = 1 <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += l [ i ] <NEWLINE> if sum > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( int ( n * ( n - 1 ) // 2 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( y - 1 ) <NEWLINE> <DEDENT> dp = [ - 1 ] * N <NEWLINE> <NL> def calc ( x ) : <NEWLINE> <INDENT> if dp [ x ] != - 1 : <NEWLINE> <INDENT> return dp [ x ] <NEWLINE> <DEDENT> if not len ( edge [ x ] ) : <NEWLINE> <INDENT> dp [ x ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> dp [ x ] = max ( [ calc ( i ) for i in edge [ x ] ] ) + 1 <NEWLINE> return dp [ x ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ i ] != - 1 : continue <NEWLINE> ans = max ( ans , calc ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if i + j + K >= S and i + j <= S : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s . insert ( 0 , 0 ) <NEWLINE> for i in range ( a , max ( c , d ) ) : <NEWLINE> <INDENT> if <STRING> == s [ i ] and <STRING> == s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if c < d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( b - 1 , d ) : <NEWLINE> <INDENT> if <STRING> == s [ i ] and <STRING> == s [ i + 1 ] and <STRING> == s [ i + 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> D = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> times = [ 0 ] * 24 <NEWLINE> times [ 0 ] = 1 <NEWLINE> for d in D : <NEWLINE> <INDENT> times [ d ] += 1 <NEWLINE> <NL> <DEDENT> if max ( times ) > 2 or times [ 0 ] == 2 or times [ 12 ] == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 2 ** 11 ) : <NEWLINE> <INDENT> positions = [ 0 ] <NEWLINE> for j in range ( 1 , 12 ) : <NEWLINE> <INDENT> if times [ j ] == 2 : <NEWLINE> <INDENT> positions . append ( j ) <NEWLINE> positions . append ( 24 - j ) <NEWLINE> <DEDENT> elif times [ j ] == 1 : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> positions . append ( 24 - j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> positions . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if times [ 12 ] == 1 : <NEWLINE> <INDENT> positions . append ( 12 ) <NEWLINE> <DEDENT> positions . sort ( ) <NEWLINE> <COMMENT> <NL> lp = len ( positions ) <NEWLINE> d = float ( <STRING> ) <NEWLINE> for p in range ( lp ) : <NEWLINE> <COMMENT> <NL> <INDENT> if p == lp - 1 : <NEWLINE> <INDENT> diff = 24 - positions [ p ] + positions [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = positions [ p + 1 ] - positions [ p ] <NEWLINE> <DEDENT> d = min ( d , diff if diff != 24 else 0 ) <NEWLINE> <DEDENT> ans = max ( ans , d ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
s = [ * input ( ) ] <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> hugo = [ <STRING> , <STRING> ] <NEWLINE> a = [ 0 ] <NEWLINE> b = [ ] <NEWLINE> base = - 1 <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if base == - 1 : <COMMENT> <NEWLINE> <INDENT> base = hugo . index ( s [ i ] ) <NEWLINE> b = [ 0 , 1 ] <NEWLINE> <DEDENT> elif base != hugo . index ( s [ i ] ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if base == 1 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <DEDENT> max_ = max ( a [ - 1 ] , b [ 0 ] ) <NEWLINE> a . pop ( - 1 ) <NEWLINE> b [ 0 ] = max_ <NEWLINE> a . extend ( b ) <NEWLINE> <COMMENT> <NL> b = [ 0 , 1 ] <NEWLINE> base = hugo . index ( s [ i ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> b . append ( b [ - 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> if hugo . index ( s [ - 1 ] ) == base : <COMMENT> <NEWLINE> <INDENT> b . append ( b [ - 1 ] + 1 ) <NEWLINE> if base == 1 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <DEDENT> max_ = max ( a [ - 1 ] , b [ 0 ] ) <NEWLINE> b [ 0 ] = max_ <NEWLINE> a . pop ( - 1 ) <NEWLINE> a . extend ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if base == 1 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <DEDENT> max_ = max ( a [ - 1 ] , b [ 0 ] ) <NEWLINE> b [ 0 ] = max_ <NEWLINE> a . pop ( - 1 ) <NEWLINE> a . extend ( b ) <NEWLINE> <NL> <COMMENT> <NL> if hugo . index ( s [ - 1 ] ) == 1 : <NEWLINE> <INDENT> b = [ 1 , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = [ 0 , 1 ] <NEWLINE> <DEDENT> max_ = max ( a [ - 1 ] , b [ 0 ] ) <NEWLINE> b [ 0 ] = max_ <NEWLINE> a . pop ( - 1 ) <NEWLINE> a . extend ( b ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> a . sort ( ) <NEWLINE> ma = a [ 0 ] * a [ 1 ] <NEWLINE> print ( ma * ( a [ 2 ] // 2 + 1 ) - ma * ( a [ 2 ] // 2 ) ) <NEWLINE>
import itertools <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> l = [ 0 for q in range ( Q ) ] <NEWLINE> r = [ 0 for q in range ( Q ) ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> l [ q ] , r [ q ] = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> max_r = max ( r ) <NEWLINE> prime_numbers = [ True for n in range ( max_r + 1 ) ] <NEWLINE> similar_numbers = [ False for n in range ( max_r + 1 ) ] <NEWLINE> <NL> prime_numbers [ 0 ] , prime_numbers [ 1 ] = False , False <COMMENT> <NEWLINE> for divisor in range ( 2 , max_r // 2 + 1 ) : <NEWLINE> <INDENT> if prime_numbers [ divisor ] : <NEWLINE> <INDENT> for multipler in range ( 2 , max_r // divisor + 1 ) : <NEWLINE> <INDENT> prime_numbers [ divisor * multipler ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for N in range ( 1 , max_r + 1 , 2 ) : <NEWLINE> <INDENT> if prime_numbers [ N ] and prime_numbers [ ( N + 1 ) // 2 ] : <NEWLINE> <INDENT> similar_numbers [ N ] = True <NEWLINE> <DEDENT> <DEDENT> accumulate_sim_nums = list ( itertools . accumulate ( map ( int , similar_numbers ) ) ) <NEWLINE> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> print ( accumulate_sim_nums [ r [ q ] ] - accumulate_sim_nums [ l [ q ] - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> <NL> for ni in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ni * ni <= n : <NEWLINE> <INDENT> if n % ni == 0 : <NEWLINE> <INDENT> list . append ( max ( len ( str ( ni ) ) , len ( str ( n // ni ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( min ( list ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = c * d // gcd ( c , d ) <NEWLINE> x = ( b // c ) - ( ( a - 1 ) // c ) <NEWLINE> y = ( b // d ) - ( ( a - 1 ) // d ) <NEWLINE> z = ( b // n ) - ( ( a - 1 ) // n ) <NEWLINE> print ( b - a + 1 - ( x + y - z ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = [ ] <NEWLINE> def ap ( num1 ) : <NEWLINE> <INDENT> num . append ( num1 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> ap ( a ) <NEWLINE> <DEDENT> num . sort ( ) <NEWLINE> num1 = num [ 0 ] <NEWLINE> num2 = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if num [ i + 1 ] == num1 : <NEWLINE> <INDENT> num2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num1 = num [ i + 1 ] <NEWLINE> if num2 % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> num2 = 1 <NEWLINE> <DEDENT> <DEDENT> if num2 % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ra = list ( reversed ( a ) ) <NEWLINE> <NL> left = [ ] <NEWLINE> right = [ ] <NEWLINE> right . append ( ra [ 0 ] ) <NEWLINE> left . append ( a [ 0 ] ) <NEWLINE> <NL> if n > 2 : <NEWLINE> <INDENT> k = math . gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> left . append ( k ) <NEWLINE> for i in range ( 2 , n - 1 ) : <NEWLINE> <INDENT> k = math . gcd ( k , a [ i ] ) <NEWLINE> left . append ( k ) <NEWLINE> <NL> <DEDENT> k = math . gcd ( ra [ 0 ] , ra [ 1 ] ) <NEWLINE> right . append ( k ) <NEWLINE> for i in range ( 2 , n - 1 ) : <NEWLINE> <INDENT> k = math . gcd ( k , ra [ i ] ) <NEWLINE> right . append ( k ) <NEWLINE> <NL> <DEDENT> ans = [ right [ - 1 ] ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> ans . append ( math . gcd ( left [ i - 1 ] , right [ len ( right ) - i - 1 ] ) ) <NEWLINE> <DEDENT> ans . append ( left [ - 1 ] ) <NEWLINE> print ( max ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a [ 1 ] , a [ 0 ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> explored = set ( ) <NEWLINE> next = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> from collections import deque <NEWLINE> ls = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ls . append ( ( u - 1 , v - 1 , w % 2 ) ) <NEWLINE> next [ u - 1 ] . append ( ( v - 1 , w % 2 ) ) <NEWLINE> next [ v - 1 ] . append ( ( u - 1 , w % 2 ) ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * n <NEWLINE> <NL> exploring = deque ( ) <NEWLINE> next_que = deque ( [ 0 ] ) <NEWLINE> ans [ 0 ] = 0 <NEWLINE> explored . add ( 0 ) <NEWLINE> while next_que : <NEWLINE> <INDENT> i = next_que . popleft ( ) <NEWLINE> exploring . extend ( next [ i ] ) <NEWLINE> while exploring : <NEWLINE> <INDENT> a , b = exploring . popleft ( ) <NEWLINE> ans [ a ] = ( ans [ i ] + b ) % 2 <NEWLINE> list = next [ a ] <NEWLINE> if a not in explored : <NEWLINE> <INDENT> next_que . append ( a ) <NEWLINE> <DEDENT> explored . add ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a , b = rm ( ) <NEWLINE> s = rr ( ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if s [ i ] not in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> if s [ a + 1 + i ] not in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if s [ a ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
n = ( int ) ( input ( ) ) <NEWLINE> a = [ 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> temp = i ** 2 <NEWLINE> while ( temp <= n ) : <NEWLINE> <INDENT> a . append ( temp ) <NEWLINE> temp *= i <NEWLINE> <DEDENT> <DEDENT> a = sorted ( set ( a ) ) <NEWLINE> <COMMENT> <NL> print ( list ( i for i in a if i <= n ) [ - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lrd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for l , r , d in lrd : <NEWLINE> <INDENT> g [ l - 1 ] . append ( [ d , r - 1 ] ) <NEWLINE> g [ r - 1 ] . append ( [ - d , l - 1 ] ) <NEWLINE> <NL> <DEDENT> no_seen = set ( range ( n ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> dst = [ inf ] * n <NEWLINE> while no_seen : <NEWLINE> <INDENT> todo = [ [ 0 , no_seen . pop ( ) ] ] <NEWLINE> <COMMENT> <NL> while todo : <NEWLINE> <INDENT> d , t = todo . pop ( ) <NEWLINE> no_seen . discard ( t ) <NEWLINE> l = g [ t ] <NEWLINE> for di , ti in l : <NEWLINE> <INDENT> if dst [ ti ] != inf and dst [ ti ] != d + di : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif dst [ ti ] != inf and dst [ ti ] == d + di : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> todo . append ( [ d + di , ti ] ) <NEWLINE> dst [ ti ] = d + di <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 0 ] * 8 <NEWLINE> p = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < 3200 : <NEWLINE> <INDENT> t [ a [ i ] // 400 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> x = t . count ( 1 ) <NEWLINE> amax = p + x <NEWLINE> if x == 0 : <NEWLINE> <INDENT> amin = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amin = x <NEWLINE> <DEDENT> print ( amin , amax ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , int ( m ** .5 ) + 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> if m // i >= n : a += [ i ] <NEWLINE> if i >= n : a += [ m // i ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( a ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> import bisect <NEWLINE> def isin ( arr , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return arr [ min ( bisect . bisect_left ( arr , x ) , len ( arr ) - 1 ) ] == x <NEWLINE> <NL> <DEDENT> n , m = readInts ( ) <NEWLINE> ab = [ readInts ( ) for i in range ( m ) ] <NEWLINE> go1 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ab [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> go1 . append ( ab [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> go1 . sort ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if isin ( go1 , ab [ i ] [ 0 ] ) and ab [ i ] [ 1 ] == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import heapq <NEWLINE> from collections import Counter <NEWLINE> inf = 10 ** 10 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dset = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> dset [ t - 1 ] . append ( d ) <NEWLINE> <NL> <DEDENT> for dd in dset : <NEWLINE> <INDENT> if dd : dd . sort ( reverse = True ) <NEWLINE> else : dd . append ( - inf ) <NEWLINE> <NL> <DEDENT> dset . sort ( key = lambda x : - x [ 0 ] ) <NEWLINE> <NL> cur = 0 <NEWLINE> hq = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( k ) : <NEWLINE> <INDENT> cur += dset [ i ] [ 0 ] <NEWLINE> for d in dset [ i ] [ 1 : ] : heapq . heappush ( hq , - d ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for dd in dset [ k : ] : <NEWLINE> <INDENT> for d in dd : <NEWLINE> <INDENT> heapq . heappush ( hq , - d ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = cur + k * k <NEWLINE> for i in range ( k - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> v = dset [ i ] [ 0 ] <COMMENT> <NEWLINE> if hq : <NEWLINE> <INDENT> w = - heapq . heappop ( hq ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if v < w : <NEWLINE> <INDENT> cur += w - v <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( hq , - w ) <NEWLINE> <DEDENT> ans = max ( ans , cur + i * i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ 0 ] * ( N + 1 ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S [ n + 1 ] = S [ n ] + A [ n ] <NEWLINE> <DEDENT> B = { } <NEWLINE> for s in range ( len ( S ) ) : <NEWLINE> <INDENT> B [ S [ s ] ] = 0 <NEWLINE> <DEDENT> for s in range ( len ( S ) ) : <NEWLINE> <INDENT> B [ S [ s ] ] += 1 <NEWLINE> <DEDENT> res = 0 <NEWLINE> for v in B . values ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> res += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> if n % 3 != 0 : <NEWLINE> <INDENT> if all ( ( a [ i ] == 0 for i in range ( n ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a1 = a [ : n // 3 ] <NEWLINE> a2 = a [ n // 3 : n * 2 // 3 ] <NEWLINE> a3 = a [ n * 2 // 3 : ] <NEWLINE> if all ( ( a1 [ i ] == 0 for i in range ( n // 3 ) ) ) and all ( ( a2 [ i ] == a2 [ 0 ] for i in range ( n // 3 ) ) ) and all ( ( a3 [ i ] == a3 [ 0 ] for i in range ( n // 3 ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif all ( ( a1 [ i ] == a1 [ 0 ] for i in range ( n // 3 ) ) ) and all ( ( a2 [ i ] == a2 [ 0 ] for i in range ( n // 3 ) ) ) and all ( ( a3 [ i ] == a3 [ 0 ] for i in range ( n // 3 ) ) ) and a1 [ 0 ] ^ a2 [ 0 ] ^ a3 [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def bfs ( MAZE , start , seen ) : <NEWLINE> <INDENT> queue = deque ( [ start + ( 0 , ) ] ) <NEWLINE> max_count = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> y , x , count = queue . popleft ( ) <NEWLINE> max_count = max ( max_count , count ) <NEWLINE> if ( y , x ) in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen . add ( ( y , x ) ) <NEWLINE> for i , j in ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> next_y , next_x = y + i , x + j <NEWLINE> <COMMENT> <NL> if not ( next_y , next_x ) in seen and MAZE [ next_y ] [ next_x ] == <STRING> : <NEWLINE> <INDENT> queue . append ( ( next_y , next_x , count + 1 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return max_count <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> MAZE = [ <STRING> * ( W + 2 ) ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s = <STRING> + s + <STRING> <NEWLINE> MAZE . append ( s ) <NEWLINE> <DEDENT> MAZE . append ( <STRING> * ( W + 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ways = [ ] <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if MAZE [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ways . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> max_count = 0 <NEWLINE> for s_i , s_j in ways : <NEWLINE> <INDENT> seen = set ( ( s_i , s_j ) ) <NEWLINE> min_count = bfs ( MAZE , ( s_i , s_j ) , seen ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> max_count = max ( max_count , min_count ) <NEWLINE> <NL> <DEDENT> print ( max_count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> A = list ( range ( K // 2 , N + 1 , K ) ) <NEWLINE> B = list ( range ( K , N + 1 , K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = list ( range ( K , N + 1 , K ) ) <NEWLINE> B = [ ] <NEWLINE> <DEDENT> print ( len ( A ) ** 3 + len ( B ) ** 3 ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> <NL> if A % 10 == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 10 - A % 10 <NEWLINE> <NL> <DEDENT> if B % 10 == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 10 - B % 10 <NEWLINE> <NL> <DEDENT> if C % 10 == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 10 - C % 10 <NEWLINE> <NL> <DEDENT> if D % 10 == 0 : <NEWLINE> <INDENT> d = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 10 - D % 10 <NEWLINE> <NL> <DEDENT> if E % 10 == 0 : <NEWLINE> <INDENT> e = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = 10 - E % 10 <NEWLINE> <NL> <DEDENT> sum = A + B + C + D + E + a + b + c + d + e - max ( a , b , c , d , e ) <NEWLINE> <NL> print ( sum ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> H , W = MAP ( ) <NEWLINE> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> dy = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dx = [ 0 , - 1 , 0 , 1 ] <NEWLINE> check = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> for y0 in range ( H ) : <NEWLINE> <INDENT> for x0 in range ( W ) : <NEWLINE> <INDENT> if S [ y0 ] [ x0 ] == <STRING> or check [ y0 ] [ x0 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt_black = 1 <NEWLINE> cnt_white = 0 <NEWLINE> check [ y0 ] [ x0 ] = 1 <NEWLINE> q = deque ( [ ( y0 , x0 , 1 ) ] ) <NEWLINE> while q : <NEWLINE> <COMMENT> <NL> <INDENT> y , x , color = q . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = y + dy [ i ] <NEWLINE> nx = x + dx [ i ] <NEWLINE> if 0 <= ny < H and 0 <= nx < W : <NEWLINE> <INDENT> if color == 1 and S [ ny ] [ nx ] == <STRING> and check [ ny ] [ nx ] == 0 : <NEWLINE> <INDENT> check [ ny ] [ nx ] = 1 <NEWLINE> <COMMENT> <NL> cnt_white += 1 <NEWLINE> q . append ( ( ny , nx , 0 ) ) <NEWLINE> <DEDENT> if color == 0 and S [ ny ] [ nx ] == <STRING> and check [ ny ] [ nx ] == 0 : <NEWLINE> <INDENT> check [ ny ] [ nx ] = 1 <NEWLINE> cnt_black += 1 <NEWLINE> q . append ( ( ny , nx , 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans += cnt_white * cnt_black <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) + <STRING> <NEWLINE> <COMMENT> <NL> count = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count [ i + 1 ] += count [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ i + 1 ] = count [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count [ i + 1 ] = count [ i ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( count [ r - 1 ] - count [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> S = readline ( ) . rstrip ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> numlist = [ [ ] for i in range ( 10 ) ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> numlist [ int ( S [ i ] ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> import bisect <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> target = str ( i ) . zfill ( 3 ) <NEWLINE> now = 0 <NEWLINE> for j in range ( len ( target ) ) : <NEWLINE> <INDENT> tar = int ( target [ j ] ) <NEWLINE> pos = bisect . bisect_left ( numlist [ tar ] , now ) <NEWLINE> if pos >= len ( numlist [ tar ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> now = numlist [ tar ] [ pos ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( i + j ) <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ary = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> ary_2 = [ ary [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ary_2 . append ( ary [ i ] + ary_2 [ i - 1 ] ) <NEWLINE> <DEDENT> ary_2 = [ 0 ] + ary_2 <NEWLINE> <COMMENT> <NL> <NL> from collections import Counter <NEWLINE> c = Counter ( ary_2 ) <NEWLINE> v = ( c . values ( ) ) <NEWLINE> <COMMENT> <NL> <NL> from math import factorial <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in v : <NEWLINE> <INDENT> if j > 1 : <NEWLINE> <INDENT> ans += combinations_count ( j , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> mi = 10 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num += abs ( a [ i ] ) <NEWLINE> if abs ( mi ) >= abs ( a [ i ] ) : <NEWLINE> <INDENT> mi = a [ i ] <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> print ( num - 2 * abs ( mi ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A = list ( input ( ) ) <NEWLINE> n = len ( A ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> numa = A [ 0 ] == <STRING> <NEWLINE> numa_ = A [ 0 ] == <STRING> <NEWLINE> numc = A [ 2 : ] . count ( <STRING> ) <NEWLINE> numc_ = A [ 2 : ] . count ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> apro = cpro = 0 <NEWLINE> if A [ i ] == <STRING> or A [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> apro = ( ( 3 * numa + numa_ ) * pow ( 3 , ( numa_ - 1 ) , mod ) ) % mod <NEWLINE> cpro = ( ( 3 * numc + numc_ ) * pow ( 3 , ( numc_ - 1 ) , mod ) ) % mod <NEWLINE> ans += ( apro * cpro ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> numa += 1 <NEWLINE> <DEDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> numa_ += 1 <NEWLINE> <DEDENT> if A [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> numc -= 1 <NEWLINE> <DEDENT> if A [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> numc_ -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> an = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( set ( an ) ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n , 100000 ) : <NEWLINE> <INDENT> for j in str ( i ) : <NEWLINE> <INDENT> if int ( j ) in d : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> X , Y = map ( int , r ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if 2 * X - Y < 0 or ( 2 * X - Y ) % 3 != 0 or 2 * Y - X < 0 or ( 2 * Y - X ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> a = ( 2 * Y - X ) // 3 <NEWLINE> b = ( 2 * X - Y ) // 3 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def pow ( a , b ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> while b : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> ans = ( ans * a ) % MOD <NEWLINE> <DEDENT> a = ( a ** 2 ) % MOD <NEWLINE> b = b // 2 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> N = a + b <NEWLINE> K = a <NEWLINE> fac = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fac [ i ] = ( fac [ i - 1 ] * i ) % MOD <NEWLINE> <DEDENT> A = fac [ N ] <NEWLINE> B = ( fac [ N - K ] * fac [ K ] ) % MOD <NEWLINE> print ( ( A % MOD ) * pow ( B , MOD - 2 ) % MOD ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> moji = str ( input ( ) ) <NEWLINE> guall = len ( moji ) // 2 <NEWLINE> kiall = guall + len ( moji ) % 2 <NEWLINE> gucount = dict ( Counter ( moji [ 1 : : 2 ] ) ) <NEWLINE> kicount = dict ( Counter ( moji [ 0 : : 2 ] ) ) <NEWLINE> if len ( moji ) == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif max ( gucount , key = gucount . get ) != max ( kicount , key = kicount . get ) : <NEWLINE> <INDENT> ans = guall - max ( gucount . values ( ) ) + kiall - max ( kicount . values ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if kiall - max ( kicount . values ( ) ) > guall - max ( gucount . values ( ) ) : <NEWLINE> <INDENT> ans = max ( kicount . values ( ) ) + guall - max ( gucount . values ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( gucount . values ( ) ) + kiall - max ( kicount . values ( ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> test = A [ 0 ] <NEWLINE> l = 0 <NEWLINE> <NL> while test % 2 == 0 : <NEWLINE> <INDENT> test = test // 2 <NEWLINE> c *= 2 <NEWLINE> <NL> <DEDENT> for i in np . arange ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] % c != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> l = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ i + 1 ] % ( c * 2 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> l = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = A [ i + 1 ] // c <NEWLINE> test = test * k // math . gcd ( test , k ) <NEWLINE> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> k = test * c // 2 <NEWLINE> print ( M // k // 2 + M // k % 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( set ( a ) ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> L = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> L = L * a // math . gcd ( L , a ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += L * pow ( a , MOD - 2 , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] * N <NEWLINE> hmax = 0 <NEWLINE> hmin = 0 <NEWLINE> H = [ 0 ] * ( N - K + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> h [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> h . sort ( ) <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> hmin = h [ i ] <NEWLINE> hmax = h [ i + K - 1 ] <NEWLINE> H [ i ] = hmax - hmin <NEWLINE> <DEDENT> print ( min ( H ) ) <NEWLINE>
spot_num = int ( input ( ) ) <NEWLINE> spot_place = [ int ( p ) for p in input ( ) . split ( <STRING> ) ] <NEWLINE> diff_table = [ ] <NEWLINE> max_num = 0 <NEWLINE> <NL> for i in range ( spot_num ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> max_num += abs ( spot_place [ 0 ] - 0 ) <NEWLINE> diff_table . append ( abs ( spot_place [ 1 ] - 0 ) - ( abs ( spot_place [ 0 ] - 0 ) + abs ( spot_place [ 1 ] - spot_place [ 0 ] ) ) ) <NEWLINE> <DEDENT> elif i == spot_num - 1 : <NEWLINE> <INDENT> diff_table . append ( abs ( 0 - spot_place [ i - 1 ] ) - ( abs ( spot_place [ i ] - spot_place [ i - 1 ] ) + abs ( 0 - spot_place [ i ] ) ) ) <NEWLINE> max_num += abs ( spot_place [ i ] - spot_place [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff_table . append ( abs ( spot_place [ i + 1 ] - spot_place [ i - 1 ] ) - ( abs ( spot_place [ i ] - spot_place [ i - 1 ] ) + abs ( spot_place [ i + 1 ] - spot_place [ i ] ) ) ) <NEWLINE> max_num += abs ( spot_place [ i ] - spot_place [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_num += abs ( 0 - spot_place [ spot_num - 1 ] ) <NEWLINE> <NL> for i in range ( spot_num ) : <NEWLINE> <INDENT> print ( max_num + diff_table [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R = [ 0 ] <NEWLINE> sums = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> sums += i <NEWLINE> sums = sums % M <NEWLINE> R . append ( sums ) <NEWLINE> <DEDENT> c = collections . Counter ( R ) <NEWLINE> A = list ( c . values ( ) ) <NEWLINE> A = [ i * ( i - 1 ) // 2 for i in A ] <NEWLINE> print ( sum ( A ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nums = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> for i in a : nums [ i ] += 1 <NEWLINE> <NL> if len ( nums ) <= 2 : <NEWLINE> <INDENT> print ( sum ( nums ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , max ( a ) ) : <NEWLINE> <INDENT> if ans < nums [ i - 1 ] + nums [ i ] + nums [ i + 1 ] : <NEWLINE> <INDENT> ans = nums [ i - 1 ] + nums [ i ] + nums [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> cntNode = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> cntNode [ a ] += 1 <NEWLINE> cntNode [ b ] += 1 <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( cntNode [ i ] % 2 != 0 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ball = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> ans = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> p , q = ball [ i ] [ 0 ] - ball [ j ] [ 0 ] , ball [ i ] [ 1 ] - ball [ j ] [ 1 ] <NEWLINE> par = [ - 1 ] * n <NEWLINE> node = [ [ ] for i in range ( n ) ] <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> for t in range ( n ) : <NEWLINE> <INDENT> x , y = ball [ s ] [ 0 ] - ball [ t ] [ 0 ] , ball [ s ] [ 1 ] - ball [ t ] [ 1 ] <NEWLINE> if x == p and y == q : <NEWLINE> <INDENT> node [ s ] . append ( t ) <NEWLINE> node [ t ] . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> already = [ False ] * n <NEWLINE> count = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if already [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count += 1 <NEWLINE> already [ k ] = True <NEWLINE> not_yet = deque ( [ k ] ) <NEWLINE> while not_yet : <NEWLINE> <INDENT> key = not_yet . pop ( ) <NEWLINE> for v in node [ key ] : <NEWLINE> <INDENT> if already [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> already [ v ] = True <NEWLINE> not_yet . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans > count : <NEWLINE> <INDENT> ans = count <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> b = a [ n - 1 : : - 2 ] + a [ : : 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a [ n - 1 : : - 2 ] + a [ 1 : : 2 ] <NEWLINE> <NL> <DEDENT> print ( * b ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( ( b , i ) ) <NEWLINE> edges [ b ] . append ( ( a , i ) ) <NEWLINE> <NL> <DEDENT> color = [ None ] * ( N - 1 ) <NEWLINE> SIZE = 1 <NEWLINE> q = deque ( [ ( 0 , None ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> v , prev_color = q . popleft ( ) <NEWLINE> c = 1 <NEWLINE> for w , i in edges [ v ] : <NEWLINE> <INDENT> if not color [ i ] : <NEWLINE> <INDENT> if c == prev_color : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> color [ i ] = c <NEWLINE> c += 1 <NEWLINE> q . append ( ( w , color [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> SIZE = max ( SIZE , c - 1 ) <NEWLINE> <DEDENT> print ( SIZE ) <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> print ( color [ n ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> V = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( V [ i ] - C [ i ] ) > 0 : <NEWLINE> <INDENT> m = m + V [ i ] - C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> broken_list = [ ] <NEWLINE> if M > 0 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> broken_list . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> broken_set = set ( broken_list ) <NEWLINE> nums = [ 0 ] * ( N + 1 ) <NEWLINE> nums [ 0 ] = 1 <NEWLINE> <NL> if 1 not in broken_set : <NEWLINE> <INDENT> nums [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> nums [ i ] = nums [ i - 1 ] + nums [ i - 2 ] <NEWLINE> if i in broken_set : <NEWLINE> <INDENT> nums [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( nums [ N ] % 1000000007 ) <NEWLINE>
import string <NEWLINE> abc = string . ascii_lowercase <NEWLINE> s = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> index = 0 <NEWLINE> while K > 0 : <NEWLINE> <INDENT> if index == len ( s ) - 1 : <NEWLINE> <INDENT> s [ index ] = abc [ ( abc . index ( s [ index ] ) + K ) % 26 ] <NEWLINE> break <NEWLINE> <DEDENT> tmp = 26 - abc . index ( s [ index ] ) <NEWLINE> if tmp == 26 : <NEWLINE> <INDENT> index += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if K >= tmp : <NEWLINE> <INDENT> s [ index ] = <STRING> <NEWLINE> index += 1 <NEWLINE> K -= tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == a ** 2 * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if x < 1 / 2 * b * a ** 2 : <NEWLINE> <INDENT> a1 = 2 * x / ( a * b ) <NEWLINE> rad = np . arctan ( a1 / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = 2 * ( b - x / a ** 2 ) <NEWLINE> rad = np . arctan ( a / y ) <NEWLINE> <NL> <DEDENT> print ( 90 - rad * 180 / np . pi ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 1 + math . ceil ( ( B - A ) / ( A - 1 ) ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for _ in range ( M ) ] <NEWLINE> ac_count = [ 0 ] * ( N + 1 ) <NEWLINE> wa_count = defaultdict ( lambda : 0 ) <NEWLINE> ac , wa = 0 , 0 <NEWLINE> <NL> for q_no , ans in a : <NEWLINE> <INDENT> q_no = int ( q_no ) <NEWLINE> if ac_count [ q_no ] == 0 : <NEWLINE> <INDENT> if ans == <STRING> : <NEWLINE> <INDENT> ac_count [ q_no ] = 1 <NEWLINE> ac += 1 <NEWLINE> wa += wa_count . get ( q_no , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa_count [ q_no ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( N - 1 ) ] <NEWLINE> PX = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( Q ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> value = [ 0 ] * ( N + 1 ) <NEWLINE> for p , x in PX : <NEWLINE> <INDENT> value [ p ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v , parent , add ) : <NEWLINE> <INDENT> value [ v ] += add <NEWLINE> for x in graph [ v ] : <NEWLINE> <INDENT> if x == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( x , v , value [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , 0 , 0 ) <NEWLINE> <NL> answer = <STRING> . join ( map ( str , value [ 1 : ] ) ) <NEWLINE> print ( answer ) <NEWLINE>
s = [ int ( x ) for x in list ( input ( ) ) ] <NEWLINE> x = s . count ( 0 ) <NEWLINE> print ( min ( x , len ( s ) - x ) * 2 ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if k == 1 or len ( s ) == 1 : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] ] = i + 1 <NEWLINE> <DEDENT> s = [ ans [ i + 1 ] for i in range ( n ) ] <NEWLINE> print ( * s ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> li = [ abs ( hc [ i ] - hc [ j ] ) + dp [ j ] for j in range ( max ( i - K , 0 ) , i ) ] <NEWLINE> dp [ i ] = min ( li ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> if ( 0 in x ) : <NEWLINE> <INDENT> K = K - 1 <NEWLINE> x . remove ( 0 ) <NEWLINE> if ( K == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , N - K + 1 ) : <NEWLINE> <INDENT> if ( ( x [ i ] < 0 ) ) : <NEWLINE> <INDENT> if ( x [ i + K - 1 ] > 0 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( x [ i ] ) * 2 + x [ i + K - 1 ] , abs ( x [ i ] ) + x [ i + K - 1 ] * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , abs ( x [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , x [ i + K - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . root ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> <DEDENT> self . parents [ rx ] += self . parents [ ry ] <NEWLINE> self . parents [ ry ] = rx <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> return rx == ry <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . root ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bridges = [ tuple ( ( int ( i ) - 1 for i in input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> islands = UnionFind ( n ) <NEWLINE> res = [ n * ( n - 1 ) // 2 ] <NEWLINE> for a , b in bridges [ : 0 : - 1 ] : <NEWLINE> <INDENT> if islands . same ( a , b ) : <NEWLINE> <INDENT> res . append ( res [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( res [ - 1 ] - islands . size ( a ) * islands . size ( b ) ) <NEWLINE> islands . unite ( a , b ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , res [ : : - 1 ] ) ) ) <NEWLINE>
N , A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> u = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if t < A + B : <NEWLINE> <INDENT> t = t + 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if t < A + B and B > u : <NEWLINE> <INDENT> t = t + 1 <NEWLINE> u = u + 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def dfs ( v , parent , odd ) : <NEWLINE> <INDENT> hi = INF <NEWLINE> lo = - INF <NEWLINE> if fixed [ v ] != INF : <NEWLINE> <INDENT> if odd_even [ v ] != odd : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> hi = lo = fixed [ v ] <NEWLINE> <DEDENT> for u in links [ v ] : <NEWLINE> <INDENT> if u == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> chi , clo = dfs ( u , v , odd ^ 1 ) <NEWLINE> if hi < clo or chi < lo : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> hi = min ( hi , chi ) <NEWLINE> lo = max ( lo , clo ) <NEWLINE> <DEDENT> upper [ v ] = hi <NEWLINE> lower [ v ] = lo <NEWLINE> return hi + 1 , lo - 1 <NEWLINE> <NL> <NL> <DEDENT> def fill ( v , parent , pp ) : <NEWLINE> <INDENT> if pp + 1 > upper [ v ] : <NEWLINE> <INDENT> assert pp - 1 >= lower [ v ] <NEWLINE> vp = fixed [ v ] = pp - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vp = fixed [ v ] = pp + 1 <NEWLINE> <DEDENT> for u in links [ v ] : <NEWLINE> <INDENT> if u == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> fill ( u , v , vp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> inp = list ( map ( int , sys . stdin . buffer . read ( ) . split ( ) ) ) <NEWLINE> n = inp [ 0 ] <NEWLINE> links = [ set ( ) for _ in range ( n ) ] <NEWLINE> for a , b in zip ( inp [ 1 : 2 * n - 1 : 2 ] , inp [ 2 : 2 * n - 1 : 2 ] ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> links [ a ] . add ( b ) <NEWLINE> links [ b ] . add ( a ) <NEWLINE> <DEDENT> INF = 10 ** 9 <NEWLINE> k = inp [ 2 * n - 1 ] <NEWLINE> fixed = [ INF ] * n <NEWLINE> odd_even = { } <NEWLINE> fixed_v = 0 <NEWLINE> for v , p in zip ( inp [ 2 * n : : 2 ] , inp [ 2 * n + 1 : : 2 ] ) : <NEWLINE> <INDENT> v -= 1 <NEWLINE> fixed [ v ] = p <NEWLINE> odd_even [ v ] = p % 2 <NEWLINE> fixed_v = v <NEWLINE> <NL> <DEDENT> lower = [ - INF ] * n <NEWLINE> upper = [ INF ] * n <NEWLINE> dfs ( fixed_v , - 1 , odd_even [ fixed_v ] ) <NEWLINE> fill ( fixed_v , - 1 , fixed [ fixed_v ] + 1 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , fixed ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> if M > N : <NEWLINE> <INDENT> M , N = N , M <NEWLINE> S , T = T , S <NEWLINE> <NL> <DEDENT> import math <NEWLINE> G = N * M // math . gcd ( N , M ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> C = N // math . gcd ( N , M ) <NEWLINE> D = M // math . gcd ( N , M ) <NEWLINE> <NL> for i in range ( 0 , math . gcd ( N , M ) ) : <NEWLINE> <INDENT> if S [ i * C ] != T [ i * D ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( G ) <NEWLINE>
s = input ( ) <NEWLINE> l = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> l . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( l ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> x = 1 <NEWLINE> while x != 2 : <NEWLINE> <INDENT> r += 1 <NEWLINE> x = a [ x - 1 ] <NEWLINE> if x == 1 or r >= n : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> return n , a <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> nroute = [ 0 ] * ( n + 2 ) <NEWLINE> nroute [ 0 ] = 0 <NEWLINE> nroute [ 1 ] = 1 <NEWLINE> nroute [ 2 ] = 1 <NEWLINE> for i in range ( 3 , n + 2 ) : <NEWLINE> <INDENT> nroute [ i ] = ( nroute [ i - 1 ] + nroute [ i - 2 ] ) % MOD <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> subn = [ ] <NEWLINE> i = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> subn . append ( ( i , j - 1 ) ) <NEWLINE> i = j + 1 <NEWLINE> <DEDENT> subn . append ( ( i , n ) ) <NEWLINE> <COMMENT> <NL> <NL> nways = 1 <NEWLINE> for i , j in subn : <NEWLINE> <INDENT> l = j - i + 1 <NEWLINE> nways = nways * nroute [ l ] % MOD <NEWLINE> <NL> <DEDENT> return nways <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , a = readinput ( ) <NEWLINE> ans = main ( n , a ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if N % 2 != 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = int ( N / 2 ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + N ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> bo = 0 <NEWLINE> for a in range ( N + 1 ) : <NEWLINE> <INDENT> for b in range ( N - a + 1 ) : <NEWLINE> <INDENT> if a * 10000 + b * 5000 + ( N - a - b ) * 1000 == X : <NEWLINE> <INDENT> T = [ a , b , N - a - b ] <NEWLINE> bo += 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if bo == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( * T , sep = <STRING> ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( N + 1 ) : <NEWLINE> <INDENT> i = 10000 * x <NEWLINE> for y in range ( N - x + 1 ) : <NEWLINE> <INDENT> j = 5000 * y <NEWLINE> if ( ( Y - i - j ) / 1000 + x + y == N and i + j + ( N - x - y ) * 1000 == Y ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> z = N - x - y <NEWLINE> f_x = x <NEWLINE> f_y = y <NEWLINE> f_z = z <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( count == 1 ) : <NEWLINE> <INDENT> print ( str ( f_x ) + <STRING> + str ( f_y ) + <STRING> + str ( f_z ) ) <NEWLINE> <DEDENT> if ( count == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = [ - 1 ] * N <NEWLINE> s [ 0 ] = 1 <NEWLINE> s [ 1 ] = 1 <NEWLINE> <NL> for m in range ( 0 , M ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> s [ i ] = 0 <NEWLINE> <NL> <DEDENT> for n in range ( 2 , N ) : <NEWLINE> <INDENT> if s [ n ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s [ n ] = s [ n - 1 ] + s [ n - 2 ] <NEWLINE> <NL> <DEDENT> print ( ( s [ N - 1 ] + s [ N - 2 ] ) % 1000000007 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> p = str ( i ) . zfill ( 3 ) <NEWLINE> if S . find ( p [ 0 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S1 = S [ S . find ( p [ 0 ] ) + 1 : ] <NEWLINE> if S1 . find ( p [ 1 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S2 = S1 [ S1 . find ( p [ 1 ] ) + 1 : ] <NEWLINE> if S2 . find ( p [ 2 ] ) == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> if len ( s ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for ai in range ( n ) : <NEWLINE> <INDENT> for bi in range ( ai + 1 , n ) : <NEWLINE> <INDENT> ans += bisect_left ( l , l [ ai ] + l [ bi ] ) - bi - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = list ( accumulate ( P ) ) <NEWLINE> <NL> largest = A [ K - 1 ] <NEWLINE> point = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if largest < A [ i ] - A [ i - K ] : <NEWLINE> <INDENT> largest = A [ i ] - A [ i - K ] <NEWLINE> point = i <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in range ( point - K + 1 , point + 1 ) : <NEWLINE> <INDENT> p = P [ j ] <NEWLINE> ans += ( ( ( p + 1 ) * p ) / 2 ) / p <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> sl = list ( S ( ) ) <NEWLINE> ans = 0 <NEWLINE> c = 0 <NEWLINE> for i , item in enumerate ( sl ) : <NEWLINE> <INDENT> if item == <STRING> : <NEWLINE> <INDENT> ans += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = gcd ( a , b ) <NEWLINE> l = make_divisors ( x ) <NEWLINE> print ( l [ - k ] ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> rl = [ ] <NEWLINE> ll = [ ] <NEWLINE> c = 0 <NEWLINE> b = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == b : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> rl . append ( c ) <NEWLINE> b = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll . append ( c ) <NEWLINE> b = <STRING> <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> ll . append ( c ) <NEWLINE> ans = [ ] <NEWLINE> for i , j in zip ( rl , ll ) : <NEWLINE> <INDENT> ans += [ 0 ] * ( i - 1 ) + [ i - i // 2 + j // 2 ] + [ i // 2 + j - j // 2 ] + [ 0 ] * ( j - 1 ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> pos_a = s . find ( <STRING> ) <NEWLINE> pos_z = s . rfind ( <STRING> ) <NEWLINE> <NL> print ( pos_z - pos_a + 1 ) <NEWLINE>
def twos ( m ) : <NEWLINE> <INDENT> rt = 0 <NEWLINE> while m % 2 == 0 : <NEWLINE> <INDENT> m //= 2 <NEWLINE> rt += 1 <NEWLINE> <DEDENT> return rt <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> ans += twos ( j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> n = inp ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> s1 = set ( ) <NEWLINE> s2 = set ( ) <NEWLINE> s3 = set ( ) <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> for ss2 in s2 : <NEWLINE> <INDENT> s3 . add ( ss2 + s ) <NEWLINE> <DEDENT> for ss1 in s1 : <NEWLINE> <INDENT> s2 . add ( ss1 + s ) <NEWLINE> <DEDENT> s1 . add ( s ) <NEWLINE> <NL> <DEDENT> print ( len ( s3 ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l_r = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> memo = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> memo [ i + 1 ] = memo [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i + 1 ] = memo [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for l , r in l_r : <NEWLINE> <INDENT> print ( memo [ r - 1 ] - memo [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> from itertools import combinations <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> x = [ 0 ] * N <NEWLINE> y = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> vector = defaultdict ( int ) <NEWLINE> for a , b in combinations ( range ( N ) , 2 ) : <NEWLINE> <INDENT> dx = x [ a ] - x [ b ] <NEWLINE> dy = y [ a ] - y [ b ] <NEWLINE> if dx == 0 : <NEWLINE> <INDENT> vector [ ( 0 , abs ( dy ) ) ] += 1 <NEWLINE> <DEDENT> elif dx > 0 : <NEWLINE> <INDENT> vector [ ( dx , dy ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vector [ ( - dx , - dy ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = N - max ( vector . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> min_sp , cnt = p [ 0 ] , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] <= min_sp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> min_sp = p [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = n - 1 <NEWLINE> sl = sorted ( l ) <NEWLINE> <NL> dsl = [ abs ( sl [ i + 1 ] - sl [ i ] ) for i in range ( m - 1 ) ] <NEWLINE> <NL> dsl = sorted ( dsl ) <NEWLINE> print ( sum ( dsl [ 0 : len ( dsl ) - num ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> A , B = sorted ( a , reverse = True ) [ 0 : 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == A : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> t = float ( <STRING> ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if abs ( h [ i + k - 1 ] - h [ i ] ) < t : <NEWLINE> <INDENT> t = abs ( h [ i + k - 1 ] - h [ i ] ) <NEWLINE> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( h [ ans + k - 1 ] - h [ ans ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> a = p [ 0 ] <NEWLINE> for x in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ x ] <= a : <NEWLINE> <INDENT> count += 1 <NEWLINE> a = p [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> gate = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> <NL> minv = gate [ 0 ] [ 0 ] <NEWLINE> maxv = gate [ 0 ] [ 1 ] <NEWLINE> <NL> for x in gate : <NEWLINE> <INDENT> minv = max ( minv , x [ 0 ] ) <NEWLINE> maxv = min ( maxv , x [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( maxv - minv + 1 if maxv - minv + 1 >= 1 else 0 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> cum_ls = [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 : i + 1 ] == <STRING> : <NEWLINE> <INDENT> cum_ls . append ( cum_ls [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cum_ls . append ( cum_ls [ i - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cum_ls [ r - 1 ] - cum_ls [ l - 1 ] ) <NEWLINE> <DEDENT>
def calc ( s , k , n ) : <NEWLINE> <NL> <INDENT> bruh = { } <NEWLINE> for i in range ( 1 , k + 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( n - ( i - 1 ) ) : <COMMENT> <NEWLINE> <INDENT> bruh [ s [ j : j + i : ] ] = 0 <NEWLINE> <DEDENT> <DEDENT> another = bruh . keys ( ) <NEWLINE> another = sorted ( another ) <NEWLINE> print ( another [ k - 1 ] ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> calc ( s , k , n ) <NEWLINE>
from itertools import combinations <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = 1 << 62 <NEWLINE> for t in combinations ( P , min ( 4 , K ) ) : <NEWLINE> <INDENT> xs , ys = zip ( * t ) <NEWLINE> xmin = min ( xs ) <NEWLINE> xmax = max ( xs ) <NEWLINE> ymin = min ( ys ) <NEWLINE> ymax = max ( ys ) <NEWLINE> area = ( xmax - xmin ) * ( ymax - ymin ) <NEWLINE> if ans < area : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 0 <NEWLINE> for x , y in P : <NEWLINE> <INDENT> if xmin <= x <= xmax and ymin <= y <= ymax : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> if k >= K : <NEWLINE> <INDENT> ans = area <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 for _ in range ( n ) ] <NEWLINE> L [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + a [ i ] <NEWLINE> <DEDENT> delay = 0 <NEWLINE> all_over = 0 <NEWLINE> anti_delay = 0 <NEWLINE> anti_all_over = 0 <NEWLINE> if a [ 0 ] != 0 : <NEWLINE> <INDENT> antiL = L [ : ] <NEWLINE> sign = ( a [ 0 ] > 0 ) - ( a [ 0 ] < 0 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> L [ i ] += delay <NEWLINE> if L [ i ] <= 0 and sign == - 1 : <NEWLINE> <INDENT> delay += 1 - L [ i ] <NEWLINE> all_over += 1 - L [ i ] <NEWLINE> L [ i ] = 1 <NEWLINE> <DEDENT> elif L [ i ] >= 0 and sign == 1 : <NEWLINE> <INDENT> delay -= L [ i ] + 1 <NEWLINE> all_over += L [ i ] + 1 <NEWLINE> L [ i ] = - 1 <NEWLINE> <DEDENT> sign *= - 1 <NEWLINE> <DEDENT> if antiL [ 0 ] < 0 : <NEWLINE> <INDENT> sign = 1 <NEWLINE> anti_delay = 1 - antiL [ 0 ] <NEWLINE> anti_all_over = 1 - antiL [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sign = - 1 <NEWLINE> anti_delay = - ( antiL [ 0 ] + 1 ) <NEWLINE> anti_all_over = antiL [ 0 ] + 1 <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> antiL [ i ] += anti_delay <NEWLINE> if antiL [ i ] <= 0 and sign == - 1 : <NEWLINE> <INDENT> anti_delay += 1 - antiL [ i ] <NEWLINE> anti_all_over += 1 - antiL [ i ] <NEWLINE> antiL [ i ] = 1 <NEWLINE> <DEDENT> elif antiL [ i ] >= 0 and sign == 1 : <NEWLINE> <INDENT> anti_delay -= antiL [ i ] + 1 <NEWLINE> anti_all_over += antiL [ i ] + 1 <NEWLINE> antiL [ i ] = - 1 <NEWLINE> <DEDENT> sign *= - 1 <NEWLINE> <DEDENT> print ( min ( anti_all_over , all_over ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> posL = L [ : ] <NEWLINE> negL = L [ : ] <NEWLINE> pos_delay , neg_delay = 1 , - 1 <NEWLINE> pos_all_over , neg_all_over = 1 , 1 <NEWLINE> sign = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> posL [ i ] += pos_delay <NEWLINE> if posL [ i ] <= 0 and sign == - 1 : <NEWLINE> <INDENT> pos_delay += 1 - posL [ i ] <NEWLINE> pos_all_over += 1 - posL [ i ] <NEWLINE> posL [ i ] = 1 <NEWLINE> <DEDENT> elif posL [ i ] >= 0 and sign == 1 : <NEWLINE> <INDENT> pos_delay -= posL [ i ] + 1 <NEWLINE> pos_all_over += posL [ i ] + 1 <NEWLINE> posL [ i ] = - 1 <NEWLINE> <DEDENT> sign *= - 1 <NEWLINE> <DEDENT> sign = - 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> negL [ i ] += neg_delay <NEWLINE> if negL [ i ] <= 0 and sign == - 1 : <NEWLINE> <INDENT> neg_delay += 1 - negL [ i ] <NEWLINE> neg_all_over += 1 - negL [ i ] <NEWLINE> negL [ i ] = 1 <NEWLINE> <DEDENT> elif negL [ i ] >= 0 and sign == 1 : <NEWLINE> <INDENT> neg_delay -= negL [ i ] + 1 <NEWLINE> neg_all_over += negL [ i ] + 1 <NEWLINE> negL [ i ] = - 1 <NEWLINE> <DEDENT> sign *= - 1 <NEWLINE> <DEDENT> print ( min ( pos_all_over , neg_all_over ) ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> m = list ( <STRING> ) [ : : - 1 ] <NEWLINE> <NL> if len ( S ) < 26 : <NEWLINE> <INDENT> for i in m [ : : - 1 ] : <NEWLINE> <INDENT> if i not in S : <NEWLINE> <INDENT> S . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = S [ - 1 ] <NEWLINE> for i in range ( 25 ) [ : : - 1 ] : <NEWLINE> <INDENT> if x > S [ i ] : <NEWLINE> <INDENT> y = m . index ( S [ i ] ) <NEWLINE> S = S [ : i ] <NEWLINE> for j in range ( y ) [ : : - 1 ] : <NEWLINE> <INDENT> if m [ j ] not in S : <NEWLINE> <INDENT> S . append ( m [ j ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = S [ i ] <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ ] <NEWLINE> s = [ 0 ] * M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> del a [ 0 ] <NEWLINE> a . sort ( ) <NEWLINE> b . append ( a ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( len ( b [ i ] ) ) : <NEWLINE> <INDENT> s [ b [ i ] [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s . count ( N ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> flg = <STRING> <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if <STRING> in s [ 2 : len ( s ) - 1 ] : <NEWLINE> <INDENT> s . remove ( <STRING> ) <NEWLINE> s . remove ( <STRING> ) <NEWLINE> s = <STRING> . join ( s ) <NEWLINE> if s . islower ( ) == True : <NEWLINE> <INDENT> flg = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( flg ) <NEWLINE>
import bisect <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Q = [ ] <NEWLINE> P = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> Q . append ( [ p , y ] ) <NEWLINE> P [ p - 1 ] . append ( y ) <NEWLINE> <NL> <DEDENT> P_1 = [ sorted ( l ) for l in P ] <NEWLINE> <NL> for p , y in Q : <NEWLINE> <INDENT> a = str ( p ) . zfill ( 6 ) <NEWLINE> b = str ( bisect . bisect ( P_1 [ p - 1 ] , y ) ) . zfill ( 6 ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 2 ) : nums [ i - 1 ] = abs ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <NL> ans = sum ( nums ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans - nums [ i - 1 ] - nums [ i ] + abs ( a [ i + 1 ] - a [ i - 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> bits = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> if ( x >> i ) & 1 : <NEWLINE> <INDENT> bits += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ( ( bits * ( N - bits ) ) * 2 ** i ) % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> N2 = list ( map ( int , str ( N ) ) ) <NEWLINE> if not ( 1000 <= N <= 9999 ) : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if N2 [ 0 ] == N2 [ 1 ] == N2 [ 2 ] or N2 [ 1 ] == N2 [ 2 ] == N2 [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ [ ] for _ in range ( m ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= m : <NEWLINE> <INDENT> d [ a - 1 ] . append ( - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> t = [ ] <NEWLINE> heapq . heapify ( t ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for dd in d [ i ] : <NEWLINE> <INDENT> heapq . heappush ( t , dd ) <NEWLINE> <DEDENT> if t : <NEWLINE> <INDENT> ans += heapq . heappop ( t ) * ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( accumulate ( a ) ) <NEWLINE> x = 10 ** 10 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x = min ( x , abs ( l [ i ] * 2 - l [ - 1 ] ) ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> if n > 3 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> ans += <STRING> . join ( a [ : : - 2 ] ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> ans += <STRING> + <STRING> . join ( a [ 0 : : 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> + <STRING> . join ( a [ 1 : : 2 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( a [ i ] ) <NEWLINE> ans . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ int ( S [ 5 : 7 ] + S [ 8 : 10 ] ) > 430 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in s : <NEWLINE> <NL> <INDENT> if i != s [ k - 1 ] : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * [ i for i in a ] , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> A = [ ] <NEWLINE> A = list ( s ) <NEWLINE> <NL> <COMMENT> <NL> <NL> add = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> if A [ i ] == <STRING> and A [ i + 1 ] == <STRING> and A [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> add = add + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( add ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> start = a [ 0 ] [ 0 ] <NEWLINE> goal = n <NEWLINE> tmp , ans = [ ] , [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] == goal : <NEWLINE> <INDENT> tmp . append ( a [ i ] [ 0 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if a [ j ] [ 0 ] == start : <NEWLINE> <INDENT> ans . append ( a [ j ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( tmp ) & set ( ans ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( A - B ) > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( A - B ) * ( - 1 ) ** K ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lsl = [ ] <NEWLINE> lsr = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lsl . append ( l ) <NEWLINE> lsr . append ( r ) <NEWLINE> <DEDENT> lmax = max ( lsl ) <NEWLINE> rmin = min ( lsr ) <NEWLINE> <NL> if lmax > rmin : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = set ( range ( 1 , n + 1 ) ) <NEWLINE> ans2 = set ( range ( lmax , rmin + 1 ) ) <NEWLINE> ans = ans1 & ans2 <NEWLINE> print ( len ( ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i + 1 ] != S [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count + 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( reverse = True ) <NEWLINE> if k > n : <NEWLINE> <INDENT> k = n <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> h [ i ] = 0 <NEWLINE> <DEDENT> print ( sum ( h ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> ls = len ( s ) <NEWLINE> key = <STRING> <NEWLINE> if <STRING> . join ( s ) == key : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> f = False <NEWLINE> for l in range ( ls ) : <NEWLINE> <INDENT> for r in range ( l + 1 , ls ) : <NEWLINE> <INDENT> f |= <STRING> . join ( [ <STRING> . join ( s [ : l ] ) , <STRING> . join ( s [ r : ] ) ] ) == key <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if f else <STRING> ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f_dict = { <NEWLINE> <INDENT> 0 : 1 <NEWLINE> <DEDENT> } <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> if f_dict . get ( n ) : <NEWLINE> <INDENT> return f_dict . get ( n ) <NEWLINE> <DEDENT> return ( 3 + f ( n - 1 ) * 2 ) <NEWLINE> <NL> <NL> <DEDENT> patty_dict = { <NEWLINE> <INDENT> 0 : 1 <NEWLINE> <DEDENT> } <NEWLINE> def total_patty ( n ) : <NEWLINE> <INDENT> if patty_dict . get ( n ) : <NEWLINE> <INDENT> return patty_dict . get ( n ) <NEWLINE> <DEDENT> return ( 1 + 2 * total_patty ( n - 1 ) ) <NEWLINE> <NL> <DEDENT> def count_patty ( n , x ) : <NEWLINE> <INDENT> if n == 0 and x == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif 1 <= x and x <= f ( n - 1 ) + 1 : <NEWLINE> <INDENT> return count_patty ( n - 1 , x - 1 ) <NEWLINE> <DEDENT> elif x == f ( n - 1 ) + 2 : <NEWLINE> <INDENT> return total_patty ( n - 1 ) + 1 <NEWLINE> <DEDENT> elif f ( n - 1 ) + 2 <= x and x <= 2 * f ( n - 1 ) + 2 : <NEWLINE> <INDENT> return total_patty ( n - 1 ) + 1 + count_patty ( n - 1 , x - f ( n - 1 ) - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return total_patty ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count_patty ( n , x ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> L . append ( ( ord ( <STRING> ) - ord ( s [ i ] ) + 1 ) ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif k - L [ i ] >= 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> k -= L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> k = k % 26 <NEWLINE> ans = ans [ : - 1 ] + chr ( ord ( ans [ - 1 ] ) + k ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t = deque ( list ( ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) ) ) <NEWLINE> A . append ( t ) <NEWLINE> <NL> <DEDENT> que = deque ( list ( range ( n ) ) ) <NEWLINE> res = 0 <NEWLINE> emp = [ False ] * n <NEWLINE> while que : <NEWLINE> <INDENT> next_que = deque ( [ ] ) <NEWLINE> check = set ( ) <NEWLINE> while que : <NEWLINE> <INDENT> i = que . popleft ( ) <NEWLINE> if A [ i ] : <NEWLINE> <INDENT> idx = A [ i ] [ 0 ] <NEWLINE> if i not in check and idx not in check and A [ idx ] [ 0 ] == i : <NEWLINE> <INDENT> A [ i ] . popleft ( ) <NEWLINE> A [ idx ] . popleft ( ) <NEWLINE> next_que . append ( i ) <NEWLINE> next_que . append ( idx ) <NEWLINE> check . add ( i ) <NEWLINE> check . add ( idx ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> emp [ i ] = True <NEWLINE> <DEDENT> <DEDENT> que = next_que <NEWLINE> if que : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( res if all ( emp ) else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n , q = rm ( ) <NEWLINE> s = rr ( ) <NEWLINE> cnt_li = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt_li [ i + 1 ] += 1 <NEWLINE> <DEDENT> cnt_li [ i + 1 ] += cnt_li [ i ] <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = rm ( ) <NEWLINE> print ( cnt_li [ r - 1 ] - cnt_li [ l - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> from itertools import groupby , accumulate <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = na ( ) <NEWLINE> s = ns ( ) <NEWLINE> a = list ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <DEDENT> gr = groupby ( s ) <NEWLINE> for key , group in gr : <NEWLINE> <INDENT> a . append ( len ( list ( group ) ) ) <NEWLINE> <DEDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <DEDENT> acum = list ( accumulate ( a ) ) <NEWLINE> m = len ( acum ) <NEWLINE> l = 2 * k + 1 <NEWLINE> if m == 1 : <NEWLINE> <INDENT> print ( acum [ 0 ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> if l > m : <NEWLINE> <INDENT> print ( acum [ - 1 ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> ans = acum [ l - 1 ] <NEWLINE> for i in range ( 0 , m - l + 1 , 2 ) : <NEWLINE> <INDENT> ans = max ( ans , acum [ i + l - 1 ] - acum [ i - 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , q = I ( ) <NEWLINE> s = v ( ) <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = I ( ) <NEWLINE> ans . append ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import heapify , heappop <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> SS = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss = S [ i ] <NEWLINE> SS . add ( ss ) <NEWLINE> for j in range ( i + 1 , min ( n , i + k ) ) : <NEWLINE> <INDENT> ss += S [ j ] <NEWLINE> SS . add ( ss ) <NEWLINE> <NL> <DEDENT> <DEDENT> SS = list ( SS ) <NEWLINE> heapify ( SS ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> res = heappop ( SS ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z and z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import functools <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> from itertools import combinations <NEWLINE> import re <NEWLINE> <NL> def main_sum ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> P [ i ] = ( P [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> max = sum ( P [ : K ] ) <NEWLINE> add = max <NEWLINE> for i in range ( len ( P ) - K ) : <NEWLINE> <INDENT> add = add + P [ i + K ] - P [ i ] <NEWLINE> if add > max : <NEWLINE> <INDENT> max = add <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <NL> <NL> <DEDENT> main_sum ( ) <NEWLINE>
<STRING> <NEWLINE> import math <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> import bisect <NEWLINE> from collections import deque , defaultdict <NEWLINE> import heapq as hpq <NEWLINE> from sys import stdin , setrecursionlimit <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ipt = stdin . readline <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ls = len ( s ) <NEWLINE> t = input ( ) <NEWLINE> if t [ 0 ] in s : <NEWLINE> <INDENT> idx = s . find ( t [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in t [ 1 : : ] : <NEWLINE> <INDENT> nt = s . find ( i , idx % ls + 1 ) <NEWLINE> ntl = s . find ( i ) <NEWLINE> if ntl == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif nt == - 1 : <NEWLINE> <INDENT> idx = ( idx // ls ) * ls + ls + ntl <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = ( idx // ls ) * ls + nt <NEWLINE> <DEDENT> <DEDENT> print ( idx + 1 ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A , reverse = True ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == B [ 0 ] : <NEWLINE> <INDENT> print ( B [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 998244353 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> n = len ( s ) <NEWLINE> t = S ( ) <NEWLINE> n2 = len ( t ) <NEWLINE> <NL> d = { } <NEWLINE> for i , x in enumerate ( s ) : <NEWLINE> <INDENT> if x in d : <NEWLINE> <INDENT> y = d [ x ] <NEWLINE> y . append ( i ) <NEWLINE> d [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> ans = 1 <NEWLINE> while j < n2 : <NEWLINE> <INDENT> check = t [ j ] <NEWLINE> if check not in d : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> l = d [ check ] <NEWLINE> if i < l [ 0 ] : <NEWLINE> <INDENT> ans += l [ 0 ] - i + 1 <NEWLINE> i = l [ 0 ] + 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif l [ - 1 ] < i : <NEWLINE> <INDENT> ans += n - ( i + 1 ) + l [ 0 ] + 2 <NEWLINE> i = l [ 0 ] + 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == l [ 0 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif i == l [ - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( l ) <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> m = ( right + left ) // 2 <NEWLINE> if l [ m ] >= i : <NEWLINE> <INDENT> right = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = m <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans += l [ right ] - i + 1 <NEWLINE> i = l [ right ] + 1 <NEWLINE> j += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> i %= n <NEWLINE> <NL> <DEDENT> return ans - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> b1 = [ ] <NEWLINE> b2 = [ ] <NEWLINE> ans = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b1 . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b2 . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> b2 . reverse ( ) <NEWLINE> ans = b2 + b1 <NEWLINE> print ( <STRING> . join ( str ( i ) for i in ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b1 . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b2 . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> b1 . reverse ( ) <NEWLINE> ans = b1 + b2 <NEWLINE> print ( <STRING> . join ( str ( i ) for i in ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> s = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> if B in s : <NEWLINE> <INDENT> s [ B ] += A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ B ] = A <NEWLINE> <DEDENT> <DEDENT> m = sorted ( list ( set ( s ) ) ) <NEWLINE> check = 0 <NEWLINE> used = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> used += s [ i ] <NEWLINE> if used > i : <NEWLINE> <INDENT> check += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> lcnt = - 1 <NEWLINE> rcnt = - 1 <NEWLINE> <NL> rr = [ 0 ] * n <NEWLINE> ll = [ 0 ] * n <NEWLINE> sim = <STRING> <NEWLINE> for si in s : <NEWLINE> <INDENT> if si == <STRING> and sim == <STRING> : <NEWLINE> <INDENT> rr [ rcnt ] += 1 <NEWLINE> <DEDENT> elif si == <STRING> and sim != <STRING> : <NEWLINE> <INDENT> rcnt += 1 <NEWLINE> rr [ rcnt ] = 1 <NEWLINE> <DEDENT> if si == <STRING> and sim == <STRING> : <NEWLINE> <INDENT> ll [ lcnt ] += 1 <NEWLINE> <DEDENT> elif si == <STRING> and sim != <STRING> : <NEWLINE> <INDENT> lcnt += 1 <NEWLINE> ll [ lcnt ] = 1 <NEWLINE> <DEDENT> sim = si <NEWLINE> <NL> <DEDENT> ll = [ i for i in ll if i != 0 ] <NEWLINE> rr = [ i for i in rr if i != 0 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> minlen = min ( len ( ll ) , len ( rr ) ) <NEWLINE> if minlen <= k : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> ll [ i ] += rr [ i ] <NEWLINE> rr [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( len ( ll ) - 1 ) : <NEWLINE> <INDENT> if i < len ( rr ) and ll [ i ] != 0 and rr [ i ] == 0 : <NEWLINE> <INDENT> ll [ i + 1 ] += ll [ i ] <NEWLINE> ll [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> icnt = 0 <NEWLINE> for i in range ( len ( ll ) ) : <NEWLINE> <INDENT> icnt += max ( ll [ i ] - 1 , 0 ) <NEWLINE> <DEDENT> for i in range ( len ( rr ) ) : <NEWLINE> <INDENT> icnt += max ( rr [ i ] - 1 , 0 ) <NEWLINE> <NL> <DEDENT> print ( icnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H . reverse ( ) <NEWLINE> <NL> check = True <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if H [ i + 1 ] - H [ i ] > 1 : <NEWLINE> <INDENT> check = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H [ i + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for num in range ( A , min ( B + 1 , A + K ) ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> for num in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
N , M = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> edges = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def search ( lst ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( lst ) == N : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = lst [ - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> next = [ n for n in edges [ a ] if n not in lst ] <NEWLINE> <COMMENT> <NL> if len ( next ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> tot = 0 <NEWLINE> <COMMENT> <NL> for n in next : <NEWLINE> <INDENT> tot += search ( lst + [ n ] ) <NEWLINE> <NL> <DEDENT> return tot <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = search ( [ 1 ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a_index = bisect . bisect_left ( A , b ) <NEWLINE> c_index = bisect . bisect_right ( C , b ) <NEWLINE> ans += a_index * ( N - c_index ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ab_lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ba_lst = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = ab_lst [ i ] [ 0 ] <NEWLINE> b = ab_lst [ i ] [ 1 ] <NEWLINE> ba = [ b , a ] <NEWLINE> ba_lst [ i ] = ba <NEWLINE> <DEDENT> ba_lst . sort ( ) <NEWLINE> <NL> lst = [ ] <NEWLINE> b = ba_lst [ 0 ] [ 0 ] <NEWLINE> a = ba_lst [ 0 ] [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b_tmp = ba_lst [ i ] [ 0 ] <NEWLINE> a_tmp = ba_lst [ i ] [ 1 ] <NEWLINE> <NL> if b == b_tmp : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> a += a_tmp <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> lst . append ( [ b , a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( [ b , a ] ) <NEWLINE> b = b_tmp <NEWLINE> a = a_tmp <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( lst ) > 1 : <NEWLINE> <INDENT> if ba_lst [ - 1 ] [ 0 ] != ba_lst [ - 2 ] [ 0 ] : <NEWLINE> <INDENT> lst . append ( [ ba_lst [ - 1 ] [ 0 ] , ba_lst [ - 1 ] [ 1 ] ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> accumulate = 0 <NEWLINE> flag = True <NEWLINE> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> accumulate += lst [ i ] [ 1 ] <NEWLINE> if accumulate > lst [ i ] [ 0 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxim = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count > maxim : <NEWLINE> <INDENT> maxim = count <NEWLINE> <DEDENT> <DEDENT> print ( maxim ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def solve ( N , XY ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> tmp += ( abs ( x ) + abs ( y ) ) % 2 <NEWLINE> <DEDENT> if tmp % N != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> import math <NEWLINE> m = math . ceil ( math . log2 ( 2 * 10 ** 9 ) ) + 1 <NEWLINE> d = [ 2 ** ( m - i ) for i in range ( m ) ] + [ 1 ] <NEWLINE> d += [ 1 ] if tmp == 0 else [ ] <NEWLINE> m = len ( d ) <NEWLINE> w = [ ] <NEWLINE> for xi , yi in XY : <NEWLINE> <INDENT> xx = 0 <NEWLINE> yy = 0 <NEWLINE> W = <STRING> <NEWLINE> for di in d : <NEWLINE> <INDENT> if abs ( xi - xx ) >= abs ( yi - yy ) : <NEWLINE> <INDENT> if xx <= xi : <NEWLINE> <INDENT> xx += di <NEWLINE> W += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xx -= di <NEWLINE> W += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if yy <= yi : <NEWLINE> <INDENT> yy += di <NEWLINE> W += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yy -= di <NEWLINE> W += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> w . append ( W ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in d ] ) ) <NEWLINE> [ print ( wi ) for wi in w ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> XY = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> solve ( N , XY ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = Counter ( A ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> if cnt [ 0 ] == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt . most_common ( 1 ) [ 0 ] [ 1 ] == N * 2 // 3 and cnt [ 0 ] == N // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = cnt . most_common ( 3 ) <NEWLINE> if x [ 0 ] [ 1 ] == x [ 1 ] [ 1 ] == x [ 2 ] [ 1 ] == N // 3 : <NEWLINE> <INDENT> if x [ 0 ] [ 0 ] ^ x [ 1 ] [ 0 ] ^ x [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> ii = s . find ( str ( i ) ) <NEWLINE> if ii == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> jj = s [ ii + 1 : ] . find ( str ( j ) ) <NEWLINE> if jj == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> jj += ii + 1 <NEWLINE> kk = s [ jj + 1 : ] . find ( str ( k ) ) <NEWLINE> if kk == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <COMMENT> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = set ( ) <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . add ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . add ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> A . sort ( ) <NEWLINE> A = A [ : : - 1 ] <NEWLINE> <NL> <NL> p0 = make_divisors ( A [ 0 ] ) <NEWLINE> p1 = make_divisors ( A [ - 1 ] ) <NEWLINE> P = p0 | p1 <NEWLINE> <NL> for p in sorted ( P ) [ : : - 1 ] : <NEWLINE> <INDENT> c = np . count_nonzero ( A % p == 0 ) <NEWLINE> if c == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> q = np . gcd . reduce ( A ) <NEWLINE> if p > q : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> n = int ( readline ( ) ) <NEWLINE> csf = [ tuple ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> now = 0 <NEWLINE> for c , s , f in csf [ i : : ] : <NEWLINE> <INDENT> if now <= s : <NEWLINE> <INDENT> now = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now % f == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = ( now // f + 1 ) * f <NEWLINE> <DEDENT> <DEDENT> now += c <NEWLINE> <DEDENT> print ( now ) <NEWLINE> <DEDENT>
from math import factorial <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> def fac ( n , r ) : <NEWLINE> <INDENT> return factorial ( n ) // ( factorial ( max ( 0 , n - r ) ) * factorial ( r ) ) <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( ( fac ( n - k + 1 , i ) * fac ( k - 1 , i - 1 ) ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ <STRING> for _ in range ( h ) ] <NEWLINE> c = 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> a = [ 1 for _ in range ( w ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( * a ) <NEWLINE> <DEDENT> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> sh = [ ] <NEWLINE> nc = 0 <NEWLINE> if s == <STRING> * w : continue <NEWLINE> <NL> for j in range ( w ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> and nc > 0 : c += 1 <NEWLINE> elif s [ j ] == <STRING> : nc += 1 <NEWLINE> sh . append ( str ( c ) ) <NEWLINE> <DEDENT> a [ i ] = sh [ : ] <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> l = 1 <NEWLINE> while a [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> a [ 0 ] = a [ l ] <NEWLINE> <NL> <DEDENT> while <STRING> in a : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> l = i - 1 <NEWLINE> while a [ l ] == <STRING> : <NEWLINE> <INDENT> l -= 1 <NEWLINE> <DEDENT> a [ i ] = a [ l ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for m in a : <NEWLINE> <INDENT> print ( * m ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> S . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> C = [ [ 1 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> L = [ <STRING> , <STRING> ] <NEWLINE> D = { <STRING> : 0 , <STRING> : 1 } <NEWLINE> tx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> ty = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> def dfs ( x , y , c , l ) : <NEWLINE> <INDENT> C [ x ] [ y ] = 0 <NEWLINE> l [ c ] += 1 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = x + tx [ i ] <NEWLINE> ny = y + ty [ i ] <NEWLINE> if 0 <= nx < H and 0 <= ny < W and C [ nx ] [ ny ] and L [ c ] != S [ nx ] [ ny ] : <NEWLINE> <INDENT> l = dfs ( nx , ny , 1 - c , l ) <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> l = dfs ( i , j , D [ S [ i ] [ j ] ] , [ 0 , 0 ] ) <NEWLINE> ans += l [ 0 ] * l [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> buttons = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> cur = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cur = buttons [ cur - 1 ] <NEWLINE> <NL> if cur == 2 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 for _ in range ( m ) ] <NEWLINE> b = [ 0 for _ in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if m == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> to = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> to [ a [ i ] ] . append ( b [ i ] ) <NEWLINE> to [ b [ i ] ] . append ( a [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> inf = 200200 <NEWLINE> dist = [ inf for _ in range ( n + 1 ) ] <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> dist [ 1 ] = 0 <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for u in to [ v ] : <NEWLINE> <INDENT> if dist [ u ] == inf : <NEWLINE> <INDENT> dist [ u ] = dist [ v ] + 1 <NEWLINE> q . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if dist [ n ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def cal ( ) : <NEWLINE> <INDENT> d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 2 ** d ) : <NEWLINE> <INDENT> b = [ <STRING> ] * d <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> b [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> count0 , count1 = 0 , 0 <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> if b [ j ] == <STRING> : <NEWLINE> <INDENT> count0 += 100 * ( j + 1 ) * a [ j ] [ 0 ] + a [ j ] [ 1 ] <NEWLINE> count1 += a [ j ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> if count0 < g : <NEWLINE> <INDENT> for j in range ( d - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if b [ j ] == <STRING> : <NEWLINE> <INDENT> for k in range ( a [ j ] [ 0 ] ) : <NEWLINE> <INDENT> if count0 >= g : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count0 += 100 * ( j + 1 ) <NEWLINE> count1 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = min ( ans , count1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> cal ( ) <NEWLINE>
import heapq <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = defaultdict ( list ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> t = [ ] <NEWLINE> heapq . heapify ( t ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in cnt [ i ] : <NEWLINE> <INDENT> heapq . heappush ( t , - j ) <NEWLINE> <DEDENT> if t : ans -= heapq . heappop ( t ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( min ( y // 10000 + 1 , n + 1 ) ) : <NEWLINE> <INDENT> for j in range ( min ( ( y - 10000 * i ) // 5000 + 1 , n - i + 1 ) ) : <NEWLINE> <INDENT> k = n - i - j <NEWLINE> if i * 10000 + j * 5000 + k * 1000 == y and i + j + k == n : <NEWLINE> <INDENT> print ( i , j , k ) ; exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT>
def fun ( a , k , n ) : <COMMENT> <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> dp = [ 0 ] * n <NEWLINE> dp [ 1 ] = dp [ 0 ] + abs ( a [ 0 ] - a [ 1 ] ) <NEWLINE> for i in range ( 2 , len ( a ) ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> min_ = float ( <STRING> ) <NEWLINE> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if t == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> if dp [ j ] + abs ( a [ i ] - a [ j ] ) < min_ : <NEWLINE> <INDENT> min_ = dp [ j ] + abs ( a [ i ] - a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = min_ <NEWLINE> <DEDENT> return dp [ - 1 ] <NEWLINE> <DEDENT> from sys import stdin , stdout <NEWLINE> n , k = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> print ( fun ( a , k , n ) ) <NEWLINE>
x , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> a = [ input ( ) for i in range ( x ) ] <NEWLINE> c = <STRING> <NEWLINE> for i in range ( y + 2 ) : <NEWLINE> <INDENT> c = c + <STRING> <NEWLINE> <DEDENT> print ( c ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> print ( <STRING> + a [ i ] + <STRING> ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
yes = <STRING> <NEWLINE> no = <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if max ( a ) - min ( a ) > 1 : exit ( print ( no ) ) <NEWLINE> if a == [ a [ 0 ] ] * n : <NEWLINE> <INDENT> if a [ 0 ] == n - 1 : print ( yes ) <NEWLINE> elif 2 * a [ 0 ] <= n : print ( yes ) <NEWLINE> else : print ( no ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mi = a . count ( min ( a ) ) <NEWLINE> ma = n - mi <NEWLINE> if mi < max ( a ) and 2 * ( max ( a ) - mi ) <= ma : print ( yes ) <NEWLINE> else : print ( no ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> a = ( 4 * h * n ) - N * h - N * n <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = ( N * h * n ) / a <NEWLINE> if w . is_integer ( ) and 0 < w : <NEWLINE> <INDENT> print ( h , n , int ( w ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> k = S . count ( <STRING> ) <NEWLINE> l = S . count ( <STRING> ) <NEWLINE> m = S . count ( <STRING> ) <NEWLINE> <NL> if abs ( k - l ) <= 1 and abs ( l - m ) <= 1 and abs ( m - k ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> group = [ [ ] ] <NEWLINE> g = [ ] <NEWLINE> l = [ ] <NEWLINE> init = 0 <NEWLINE> indice = 0 <NEWLINE> group_num = 0 <NEWLINE> ind = [ - 1 ] * N <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if S [ k ] == <STRING> : <NEWLINE> <INDENT> group [ group_num ] . append ( k ) <NEWLINE> ind [ k ] = indice <NEWLINE> indice += 1 <NEWLINE> g . append ( group_num ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not init : <NEWLINE> <INDENT> l . append ( indice - 1 ) <NEWLINE> init = 1 <NEWLINE> <DEDENT> if k < N - 1 and S [ k + 1 ] == <STRING> : <NEWLINE> <INDENT> group [ group_num ] . append ( k ) <NEWLINE> g . append ( group_num ) <NEWLINE> group_num += 1 <NEWLINE> group . append ( [ ] ) <NEWLINE> init = 0 <NEWLINE> ind [ k ] = indice <NEWLINE> indice = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> group [ group_num ] . append ( k ) <NEWLINE> g . append ( group_num ) <NEWLINE> ind [ k ] = indice <NEWLINE> indice += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ret = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> _l = l [ g [ i ] ] <NEWLINE> indice = ind [ i ] <NEWLINE> if indice <= _l : <NEWLINE> <INDENT> tmp = group [ g [ i ] ] [ _l + ( _l - indice ) % 2 ] <NEWLINE> ret [ tmp ] += 1 <NEWLINE> <DEDENT> if indice >= _l + 1 : <NEWLINE> <INDENT> tmp = group [ g [ i ] ] [ _l + ( _l - indice ) % 2 ] <NEWLINE> ret [ tmp ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in ret ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> idx0 = S [ : N - 2 ] . find ( str ( i ) ) <NEWLINE> if idx0 != - 1 : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> idx1 = S [ idx0 + 1 : N - 1 ] . find ( str ( j ) ) <NEWLINE> if idx1 != - 1 : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> idx2 = S [ idx0 + idx1 + 2 : ] . find ( str ( k ) ) <NEWLINE> if idx2 != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v0 = v [ 0 : n - 1 : 2 ] <NEWLINE> v1 = v [ 1 : n : 2 ] <NEWLINE> from collections import Counter <NEWLINE> V0 = Counter ( v0 ) <NEWLINE> V1 = Counter ( v1 ) <NEWLINE> if V0 . most_common ( ) [ 0 ] [ 0 ] != V1 . most_common ( ) [ 0 ] [ 0 ] : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = V1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if V0 . most_common ( ) [ 0 ] [ 1 ] > V1 . most_common ( ) [ 0 ] [ 1 ] : <NEWLINE> <INDENT> if len ( V1 ) > 1 : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = V1 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = 0 <NEWLINE> <DEDENT> <DEDENT> elif V0 . most_common ( ) [ 0 ] [ 1 ] < V1 . most_common ( ) [ 0 ] [ 1 ] : <NEWLINE> <INDENT> if len ( V0 ) > 1 : <NEWLINE> <INDENT> a = V1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = V0 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = V1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( V0 ) == 1 and len ( V1 ) == 1 : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> elif len ( V0 ) == 1 : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = V1 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> elif len ( V1 ) == 1 : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> b = V1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = V0 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> b = max ( V0 . most_common ( ) [ 1 ] [ 1 ] , V1 . most_common ( ) [ 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n - a - b ) <NEWLINE>
<NL> def sign ( x ) : <NEWLINE> <INDENT> return ( x > 0 ) - ( x < 0 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> arr = [ ] <NEWLINE> state = 0 <NEWLINE> for an in a : <NEWLINE> <INDENT> if len ( arr ) < 2 : <NEWLINE> <INDENT> arr . append ( an ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state += ( arr [ - 1 ] - arr [ - 2 ] ) <NEWLINE> if state == 0 : <NEWLINE> <INDENT> arr . append ( an ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current = an - arr [ - 1 ] <NEWLINE> if current == 0 or sign ( state ) == sign ( current ) : <NEWLINE> <INDENT> arr . append ( an ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( arr ) <NEWLINE> arr = [ an ] <NEWLINE> state = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans . append ( arr ) <NEWLINE> <NL> print ( len ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 0 ] == S [ 1 ] and S [ 2 ] == S [ 3 ] and len ( set ( S ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S [ 0 ] == S [ 2 ] and S [ 1 ] == S [ 3 ] and len ( set ( S ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S [ 0 ] == S [ 3 ] and S [ 1 ] == S [ 2 ] and len ( set ( S ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> start = [ ] <NEWLINE> leave = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> start . append ( b [ i ] ) <NEWLINE> <DEDENT> elif b [ i ] == n : <NEWLINE> <INDENT> leave . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if set ( start ) & set ( leave ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n * ( 100 ** d ) if n < 100 else ( n + 1 ) * ( 100 ** d ) ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = [ x - A for x in X ] <NEWLINE> dp = { 0 : 1 } <NEWLINE> <NL> for y in Y : <NEWLINE> <INDENT> tmp = list ( dp . items ( ) ) <NEWLINE> for k , v in tmp : <NEWLINE> <INDENT> dp [ k + y ] = dp . get ( k + y , 0 ) + v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ 0 ] - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> move = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == n - 2 : <NEWLINE> <INDENT> move . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> move . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ( move ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> s = input ( ) <NEWLINE> listS = list ( s ) <NEWLINE> n = len ( listS ) <NEWLINE> <NL> aIndex = 0 <NEWLINE> zIndex = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if listS [ i ] == <STRING> : <NEWLINE> <INDENT> aIndex = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if listS [ - ( i + 1 ) ] == <STRING> : <NEWLINE> <INDENT> zIndex = n - i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = zIndex - aIndex <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
SA = input ( ) <NEWLINE> SB = input ( ) <NEWLINE> SC = input ( ) <NEWLINE> <NL> pointer = SA [ 0 ] <NEWLINE> SA = SA [ 1 : ] <NEWLINE> d = { <STRING> : SA , <STRING> : SB , <STRING> : SC } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if d [ pointer ] == <STRING> : <NEWLINE> <INDENT> ans = pointer <NEWLINE> break <NEWLINE> <DEDENT> tmp = d [ pointer ] [ 0 ] <NEWLINE> d [ pointer ] = d [ pointer ] [ 1 : ] <NEWLINE> pointer = tmp <NEWLINE> <NL> <DEDENT> print ( ans . upper ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> x = 2 * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t . startswith ( s [ i : ] ) : <NEWLINE> <INDENT> x = n + i <NEWLINE> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dic = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a in dic : <NEWLINE> <INDENT> dic [ a ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = b <NEWLINE> <DEDENT> <DEDENT> List = sorted ( dic ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while M > 0 : <NEWLINE> <INDENT> M -= dic [ List [ i ] ] <NEWLINE> ans = List [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
WORDS = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> REVERSED_WORDS = [ word [ : : - 1 ] for word in WORDS ] <NEWLINE> <NL> <NL> def main ( s ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> for word in REVERSED_WORDS : <NEWLINE> <INDENT> if s [ i : ] . startswith ( word ) : <NEWLINE> <INDENT> i += len ( word ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( input ( ) [ : : - 1 ] ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> print ( 2 ** n ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 2 ** ( n - 1 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for x in range ( 1 , 9 + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , 9 + 1 ) : <NEWLINE> <INDENT> if x * y == n : <NEWLINE> <INDENT> a = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 1 or m == 1 : <NEWLINE> <INDENT> print ( max ( n , m ) - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * m - ( n * 2 + ( m - 2 ) * 2 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from bisect import bisect_left <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> stop = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , t , x = map ( int , input ( ) . split ( ) ) <NEWLINE> stop . append ( ( s , t , x ) ) <NEWLINE> <DEDENT> stop . sort ( key = lambda x : x [ 2 ] ) <NEWLINE> d = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> R = [ - 1 ] * q <NEWLINE> ans = [ - 1 ] * q <NEWLINE> for s , t , x in stop : <NEWLINE> <COMMENT> <NL> <INDENT> l = bisect_left ( d , s - x ) <NEWLINE> r = bisect_left ( d , t - x ) <NEWLINE> while l < r : <NEWLINE> <INDENT> if R [ l ] == - 1 : <COMMENT> <NEWLINE> <INDENT> ans [ l ] = x <NEWLINE> R [ l ] = r <NEWLINE> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = R [ l ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> G = [ { } for i in range ( N + 1 ) ] <NEWLINE> colors = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] [ b ] = [ i , - 1 ] <NEWLINE> G [ b ] [ a ] = [ i , - 1 ] <NEWLINE> <NL> <DEDENT> def bfs ( s ) : <NEWLINE> <INDENT> seen = [ 0 for i in range ( N + 1 ) ] <NEWLINE> prev = [ 0 for i in range ( N + 1 ) ] <NEWLINE> todo = deque ( [ ] ) <NEWLINE> cmax = 0 <NEWLINE> now = s <NEWLINE> seen [ now ] = 1 <NEWLINE> todo . append ( now ) <NEWLINE> while 1 : <NEWLINE> <INDENT> if len ( todo ) == 0 : break <NEWLINE> a = todo . popleft ( ) <NEWLINE> if len ( G [ a ] ) < 50 : <NEWLINE> <INDENT> if prev [ a ] == 0 : <NEWLINE> <INDENT> a_color = set ( [ ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_color = set ( [ G [ a ] [ prev [ a ] ] [ 1 ] ] ) <NEWLINE> <DEDENT> for b in G [ a ] : <NEWLINE> <INDENT> if seen [ b ] == 0 : <NEWLINE> <INDENT> seen [ b ] = 1 <NEWLINE> todo . append ( b ) <NEWLINE> prev [ b ] = a <NEWLINE> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if c not in a_color : <NEWLINE> <INDENT> a_color . add ( c ) <NEWLINE> colors . append ( ( G [ a ] [ b ] [ 0 ] , c ) ) <NEWLINE> G [ a ] [ b ] [ 1 ] = G [ b ] [ a ] [ 1 ] = c <NEWLINE> if c > cmax : cmax = c <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = list ( range ( 1 , N ) ) <NEWLINE> if prev [ a ] != 0 : <NEWLINE> <INDENT> del temp [ G [ a ] [ prev [ a ] ] [ 1 ] - 1 ] <NEWLINE> <DEDENT> temp = deque ( temp ) <NEWLINE> for i , b in enumerate ( G [ a ] ) : <NEWLINE> <INDENT> if seen [ b ] == 0 : <NEWLINE> <INDENT> seen [ b ] = 1 <NEWLINE> todo . append ( b ) <NEWLINE> prev [ b ] = a <NEWLINE> c = temp . popleft ( ) <NEWLINE> colors . append ( ( G [ a ] [ b ] [ 0 ] , c ) ) <NEWLINE> G [ a ] [ b ] [ 1 ] = G [ b ] [ a ] [ 1 ] = c <NEWLINE> if c > cmax : cmax = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return colors , cmax <NEWLINE> <NL> <DEDENT> colors , cmax = bfs ( 1 ) <NEWLINE> colors = sorted ( colors ) <NEWLINE> <NL> print ( cmax ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( colors [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == W / 2 and y == H / 2 : <NEWLINE> <INDENT> print ( ( W * H ) / 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( W * H ) / 2 , 0 ) <NEWLINE> <DEDENT>
from bisect import bisect <NEWLINE> import random <NEWLINE> <NL> <NL> def binary_search ( L , n , i , j ) : <NEWLINE> <COMMENT> <NL> <INDENT> low = i <NEWLINE> high = j <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> guess = L [ mid ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if guess > n : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i , j = 0 , 0 <NEWLINE> <NL> A_ind = [ ] <NEWLINE> B_cum = [ 0 ] <NEWLINE> <NL> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> i = bisect ( B , a ) <NEWLINE> A_ind . append ( i ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for b in B : <NEWLINE> <COMMENT> <NL> <INDENT> j = i = bisect ( C , b ) <NEWLINE> s += N - j <NEWLINE> B_cum . append ( s ) <NEWLINE> <NL> <DEDENT> for a in A_ind : <NEWLINE> <INDENT> ans += B_cum [ - 1 ] - B_cum [ a ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> h . append ( tmp ) <NEWLINE> <DEDENT> h . sort ( ) <NEWLINE> <NL> ans = h [ N - 1 ] <NEWLINE> for i in range ( 0 , N - K + 1 ) : <NEWLINE> <INDENT> tmp = h [ i + K - 1 ] - h [ i ] <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d_dic = dict ( ) <NEWLINE> t_dic = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d1 = d [ i ] <NEWLINE> if d1 not in d_dic . keys ( ) : <NEWLINE> <INDENT> d_dic [ d1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d_dic [ d1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> t1 = t [ i ] <NEWLINE> if t1 in d_dic . keys ( ) : <NEWLINE> <INDENT> d_dic [ t1 ] -= 1 <NEWLINE> if d_dic [ t1 ] < 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if z >= 0 and z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> stairs = [ 1 ] * ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> stairs [ int ( input ( ) ) ] = - 1 <NEWLINE> <NL> <DEDENT> flg = False <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if stairs [ i ] == - 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif stairs [ i - 1 ] == - 1 and stairs [ i - 2 ] == - 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> elif stairs [ i - 1 ] == - 1 : <NEWLINE> <INDENT> stairs [ i ] = stairs [ i - 2 ] <NEWLINE> <DEDENT> elif stairs [ i - 2 ] == - 1 : <NEWLINE> <INDENT> stairs [ i ] = stairs [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stairs [ i ] = stairs [ i - 1 ] + stairs [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( stairs [ - 1 ] % 1000000007 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort_numbers = sorted ( numbers ) <NEWLINE> <COMMENT> <NL> left = sort_numbers [ n // 2 - 1 ] <NEWLINE> right = sort_numbers [ n // 2 ] <NEWLINE> <COMMENT> <NL> for i in numbers : <NEWLINE> <INDENT> if i > left : <NEWLINE> <INDENT> print ( left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> kt = tuple ( range ( 1 , k + 1 ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> dp = [ INF ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in kt : <NEWLINE> <INDENT> i_j = i + j <NEWLINE> if i_j < n : <NEWLINE> <INDENT> x = dp [ i ] + abs ( h [ i ] - h [ i_j ] ) <NEWLINE> if dp [ i_j ] > x : <NEWLINE> <INDENT> dp [ i_j ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> def Fib ( n ) : <NEWLINE> <INDENT> seq = [ ] <NEWLINE> a , b = 0 , 1 <NEWLINE> for i in range ( 1 , n + 10 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> seq . append ( 0 ) <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> seq . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> seq . append ( b ) <NEWLINE> <DEDENT> <DEDENT> return seq <NEWLINE> <DEDENT> table = Fib ( n ) <NEWLINE> temp = - 1 <NEWLINE> route = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dif = a - temp - 1 <NEWLINE> temp = a <NEWLINE> route = route * table [ dif ] % mod <NEWLINE> <DEDENT> print ( route * table [ n - temp ] % mod ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = np . zeros ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in A : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i in A : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <NL> <DEDENT> print ( int ( dp [ N ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> t = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs1 ( pos , before_pos ) : <NEWLINE> <INDENT> for next_pos in ab [ pos ] : <NEWLINE> <INDENT> if next_pos == before_pos : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if next_pos == u : <NEWLINE> <INDENT> return True , [ pos ] <NEWLINE> <DEDENT> tf , root = dfs1 ( next_pos , pos ) <NEWLINE> if tf : <NEWLINE> <INDENT> root . append ( pos ) <NEWLINE> return True , root <NEWLINE> <DEDENT> <DEDENT> return False , [ ] <NEWLINE> <NL> <DEDENT> root = dfs1 ( v , - 1 ) [ 1 ] <NEWLINE> root = root [ : : - 1 ] <NEWLINE> root . append ( u ) <NEWLINE> n = ( len ( root ) + 1 ) // 2 <NEWLINE> pos = root [ n ] <NEWLINE> before_pos = root [ n - 1 ] <NEWLINE> <NL> max_len = n <NEWLINE> <NL> def dfs2 ( pos , before_pos , cnt ) : <NEWLINE> <INDENT> global max_len <NEWLINE> cnt += 1 <NEWLINE> max_len = max ( max_len , cnt ) <NEWLINE> if cnt < n - 1 : <NEWLINE> <INDENT> dfs2 ( root [ cnt + 1 ] , pos , cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for next_pos in ab [ pos ] : <NEWLINE> <INDENT> if next_pos == before_pos : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs2 ( next_pos , pos , cnt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs2 ( pos , before_pos , n - 1 ) <NEWLINE> ans = max_len - 1 <NEWLINE> ans = max ( ans , 0 ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> lsx = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in lsx : <NEWLINE> <INDENT> K = K - 1 <NEWLINE> lsx . remove ( 0 ) <NEWLINE> <DEDENT> if bool ( lsx ) == False or K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> lshu = [ ] <NEWLINE> sei = len ( lsx ) <NEWLINE> for i in range ( len ( lsx ) ) : <NEWLINE> <INDENT> if lsx [ i ] < 0 : <NEWLINE> <INDENT> lshu . append ( lsx [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sei = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> lssei = lsx [ sei : ] <NEWLINE> lenhu = len ( lshu ) <NEWLINE> lensei = len ( lssei ) <NEWLINE> lshu2 = [ abs ( lshu [ i ] ) for i in range ( lenhu - 1 , - 1 , - 1 ) ] <NEWLINE> dishu = [ 0 ] + lshu2 <NEWLINE> dissei = [ 0 ] + lssei <NEWLINE> ans = 10 * 10 ** 8 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if i <= lenhu and K - i <= lensei : <NEWLINE> <INDENT> ans = min ( ans , 2 * dishu [ i ] + dissei [ K - i ] , dishu [ i ] + 2 * dissei [ K - i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> a = Counter ( input ( ) ) . most_common ( ) <NEWLINE> if len ( a ) == 2 : <NEWLINE> <INDENT> if a [ 1 ] [ 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def f ( a , b ) : <NEWLINE> <INDENT> x = int ( max ( a , b ) ) <NEWLINE> return len ( str ( x ) ) <NEWLINE> <NL> <DEDENT> results = [ ] <NEWLINE> <NL> for i in range ( 1 , int ( n ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> b = n / i <NEWLINE> <DEDENT> result = f ( a , b ) <NEWLINE> results . append ( result ) <NEWLINE> <NL> <DEDENT> print ( min ( results ) ) <NEWLINE>
import heapq <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = a [ : n ] <NEWLINE> heapq . heapify ( l ) <NEWLINE> memo_l = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> memo_l [ 0 ] = sum ( a [ : n ] ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> memo_l [ i ] = memo_l [ i - 1 ] <NEWLINE> if l [ 0 ] < a [ n + i - 1 ] : <NEWLINE> <INDENT> x = heapq . heappop ( l ) <NEWLINE> heapq . heappush ( l , a [ n + i - 1 ] ) <NEWLINE> memo_l [ i ] += a [ n + i - 1 ] - x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> r = [ - a [ - i ] for i in range ( 1 , n + 1 ) ] <NEWLINE> heapq . heapify ( r ) <NEWLINE> memo_r = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> memo_r [ 0 ] = sum ( a [ - n : ] ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> memo_r [ i ] = memo_r [ i - 1 ] <NEWLINE> if abs ( r [ 0 ] ) > a [ - n - i ] : <NEWLINE> <INDENT> x = heapq . heappop ( r ) <NEWLINE> heapq . heappush ( r , - a [ - n - i ] ) <NEWLINE> memo_r [ i ] += x + a [ - n - i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = - 10 ** 20 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , memo_l [ i ] - memo_r [ n - i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> import math <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in reversed ( range ( 1 , ( int ( math . sqrt ( N ) ) ) + 1 ) ) : <NEWLINE> <INDENT> if N % a == 0 : <NEWLINE> <INDENT> b = N / a <NEWLINE> ans = max ( len ( str ( int ( a ) ) ) , len ( str ( int ( b ) ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = 0 <NEWLINE> rmin = 1000000 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = max ( l , lmax ) <NEWLINE> rmin = min ( r , rmin ) <NEWLINE> <NL> <DEDENT> if rmin - lmax >= 0 : <NEWLINE> <INDENT> print ( rmin - lmax + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( D [ math . ceil ( ( N ) / 2 ) ] - D [ math . ceil ( ( N ) / 2 ) - 1 ] ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> def make_prime_checker ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> is_prime = [ False , True , False , False , False , True ] * ( n // 6 + 1 ) <NEWLINE> del is_prime [ n + 1 : ] <NEWLINE> is_prime [ 1 : 4 ] = False , True , True <NEWLINE> for i in range ( 5 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> is_prime [ i * i : : i ] = [ False ] * ( n // i - i + 1 ) <NEWLINE> <DEDENT> <DEDENT> return is_prime <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> Primes = [ p for p , is_p in enumerate ( make_prime_checker ( 2200 ) ) if is_p ] <NEWLINE> def decomp ( n ) : <NEWLINE> <INDENT> res1 = res2 = 1 <NEWLINE> for p in Primes : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> n //= p <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> cnt %= 3 <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> res1 *= p <NEWLINE> <DEDENT> elif cnt == 2 : <NEWLINE> <INDENT> res2 *= p <NEWLINE> <DEDENT> <DEDENT> if int ( n ** 0.5 ) ** 2 == n : <NEWLINE> <INDENT> res2 *= int ( n ** 0.5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res1 *= n <NEWLINE> <DEDENT> return res1 * res2 * res2 , res1 * res1 * res2 <NEWLINE> <NL> <DEDENT> N , * S = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> T = [ ] <NEWLINE> inv_dict = { } <NEWLINE> for s in S : <NEWLINE> <INDENT> t , t_inv = decomp ( s ) <NEWLINE> T . append ( t ) <NEWLINE> inv_dict [ t ] = t_inv <NEWLINE> <NL> <DEDENT> counter_T = Counter ( T ) <NEWLINE> ans = 0 <NEWLINE> for t , t_cnt in counter_T . items ( ) : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> t_inv = inv_dict [ t ] <NEWLINE> t_inv_cnt = counter_T [ t_inv ] <NEWLINE> if t_cnt > t_inv_cnt or ( t_cnt == t_inv_cnt and t > t_inv ) : <NEWLINE> <INDENT> ans += t_cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> t . append ( str ( i // 100 ) ) <NEWLINE> t . append ( str ( i // 10 % 10 ) ) <NEWLINE> t . append ( str ( i % 10 ) ) <NEWLINE> k = 0 <NEWLINE> p = 0 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if t [ j ] in s [ k : ] : <NEWLINE> <INDENT> p = s [ k : ] . index ( t [ j ] ) + 1 <NEWLINE> k += p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> t . clear ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import bisect <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> b = a [ : i ] <NEWLINE> c = a [ i + 1 : ] <NEWLINE> <COMMENT> <NL> for j in b : <NEWLINE> <INDENT> ans += bisect . bisect ( c , a [ i ] + j - 0.1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> wa = False <NEWLINE> <NL> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> wa = True <NEWLINE> <DEDENT> if s [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> wa = True <NEWLINE> <NL> <DEDENT> l_s = list ( s ) <NEWLINE> <NL> if <STRING> in l_s : <NEWLINE> <INDENT> del l_s [ l_s . index ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> if <STRING> in l_s : <NEWLINE> <INDENT> del l_s [ l_s . index ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> for c in l_s : <NEWLINE> <INDENT> if c != c . lower ( ) : <NEWLINE> <INDENT> wa = True <NEWLINE> <NL> <DEDENT> <DEDENT> if wa == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , f = input ( ) [ : : - 1 ] , - 1 <NEWLINE> while f < 0 : <NEWLINE> <INDENT> if s : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> <DEDENT> elif s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> <DEDENT> elif s [ : 6 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 6 : ] <NEWLINE> <DEDENT> elif s [ : 7 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 7 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ f ] ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> c = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> c . append ( count ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l == 1 : <NEWLINE> <INDENT> print ( c [ r - 2 ] - 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c [ r - 2 ] - c [ l - 2 ] ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x . sort ( ) <NEWLINE> if ( n >= m ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dist = abs ( x [ - 1 ] - x [ 0 ] ) <NEWLINE> <NL> diff = [ ] <NEWLINE> <NL> for i in range ( m - 1 ) : <NEWLINE> <INDENT> diff . append ( [ abs ( x [ i ] - x [ i + 1 ] ) , i ] ) <NEWLINE> <NL> <DEDENT> diff . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> dist -= diff [ i ] [ 0 ] <NEWLINE> <DEDENT> print ( dist ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N , Q = I ( ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = I ( ) <NEWLINE> edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> edge [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> ans = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = I ( ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <DEDENT> que = [ 0 ] <NEWLINE> visited = { 0 } <NEWLINE> while que : <NEWLINE> <INDENT> p = [ ] <NEWLINE> for i in que : <NEWLINE> <INDENT> for j in edge [ i ] : <NEWLINE> <INDENT> if j in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited . add ( j ) <NEWLINE> ans [ j ] += ans [ i ] <NEWLINE> p . append ( j ) <NEWLINE> <DEDENT> <DEDENT> que = p <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> h , w = INTM ( ) <NEWLINE> ban = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = STR ( ) <NEWLINE> for i1 in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i1 ] == <STRING> : <NEWLINE> <INDENT> ban [ i ] [ i1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> left = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> right = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> up = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> down = np . zeros ( ( h , w ) , dtype = np . int16 ) <NEWLINE> <COMMENT> <NL> for i in range ( w ) : <NEWLINE> <INDENT> i2 = w - 1 - i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> left [ : , i ] = ban [ : , i ] <NEWLINE> right [ : , i2 ] = ban [ : , i2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left [ : , i ] = ban [ : , i ] * ( left [ : , i - 1 ] + 1 ) <NEWLINE> right [ : , i2 ] = ban [ : , i2 ] * ( right [ : , i2 + 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> i2 = h - 1 - i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> up [ i , : ] = ban [ i , : ] <NEWLINE> down [ i2 , : ] = ban [ i2 , : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> up [ i , : ] = ban [ i , : ] * ( up [ i - 1 , : ] + 1 ) <NEWLINE> down [ i2 , : ] = ban [ i2 , : ] * ( down [ i2 + 1 , : ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> anslist = down + up + right + left <NEWLINE> ans = 0 <NEWLINE> for i in anslist : <NEWLINE> <INDENT> ans = max ( ans , max ( i ) ) <NEWLINE> <DEDENT> print ( ans - 3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> positive = [ ] <NEWLINE> negative = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if x [ i ] < 0 : <NEWLINE> <INDENT> negative . append ( - x [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> positive . append ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT> negative . sort ( ) <NEWLINE> n = len ( negative ) <NEWLINE> m = len ( positive ) <NEWLINE> ans = 1000000000 <NEWLINE> if n >= K : <NEWLINE> <INDENT> ans = min ( ans , negative [ K - 1 ] ) <NEWLINE> <DEDENT> if m >= K : <NEWLINE> <INDENT> ans = min ( ans , positive [ K - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> j = K - ( i + 1 ) <NEWLINE> if j > m : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = min ( ans , negative [ i ] + positive [ j - 1 ] + min ( negative [ i ] , positive [ j - 1 ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if X [ 0 ] >= 0 : <NEWLINE> <INDENT> print ( X [ k - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif X [ - 1 ] < 0 : <NEWLINE> <INDENT> print ( abs ( X [ n - k ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] >= 0 : <NEWLINE> <INDENT> ori = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = f_inf <NEWLINE> left = max ( ori - k , 0 ) <NEWLINE> right = min ( ori + k , n ) <NEWLINE> for i in range ( left , right - k + 1 ) : <NEWLINE> <INDENT> RL = abs ( X [ i + k - 1 ] - X [ i ] ) + abs ( X [ i + k - 1 ] ) <NEWLINE> LR = abs ( X [ i ] ) + abs ( X [ i + k - 1 ] - X [ i ] ) <NEWLINE> res = min ( res , min ( RL , LR ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import typing <NEWLINE> from typing import List , NamedTuple , Deque , Set , Counter <NEWLINE> <NL> class node : <NEWLINE> <INDENT> def __init__ ( self , id : int ) -> None : <NEWLINE> <INDENT> self . id : int = id <NEWLINE> self . parent : node = self <NEWLINE> self . root : node = self <NEWLINE> self . rank : int = 0 <NEWLINE> self . connection : List [ node ] = [ ] <NEWLINE> <NL> <DEDENT> def addConnection ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . connection . append ( other ) <NEWLINE> other . connection . append ( self ) <NEWLINE> <NL> <DEDENT> def delConnection ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . connection . remove ( other ) <NEWLINE> other . connection . remove ( self ) <NEWLINE> <NL> <DEDENT> def setParent ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . parent = other <NEWLINE> self . rank = other . rank + 1 <NEWLINE> <NL> <DEDENT> def setRoot ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . root = other <NEWLINE> <NL> <DEDENT> def setAsRoot ( self ) -> None : <NEWLINE> <INDENT> self . parent = self <NEWLINE> self . root = self <NEWLINE> self . rank = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def makePath ( root : node , target : node ) -> Deque [ node ] : <NEWLINE> <INDENT> path : Deque [ node ] = Deque ( ) <NEWLINE> path . append ( target ) <NEWLINE> while path [ 0 ] != root : <NEWLINE> <INDENT> path . appendleft ( path [ 0 ] . parent ) <NEWLINE> <DEDENT> return path <NEWLINE> <NL> <NL> <DEDENT> def bfs ( root : node ) : <NEWLINE> <INDENT> reserved : Deque [ node ] = Deque ( [ root ] ) <NEWLINE> seen : Set [ int ] = { root . id } <NEWLINE> while len ( reserved ) > 0 : <NEWLINE> <INDENT> current_node = reserved . popleft ( ) <NEWLINE> for next_node in current_node . connection : <NEWLINE> <INDENT> if next_node . id in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> next_node . setParent ( current_node ) <NEWLINE> next_node . setRoot ( root ) <NEWLINE> seen . add ( next_node . id ) <NEWLINE> reserved . append ( next_node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> Edge = [ map ( int , input ( ) . split ( ) ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> Node : List [ node ] = [ node ( i ) for i in range ( N ) ] <NEWLINE> for a , b in Edge : <NEWLINE> <INDENT> Node [ a - 1 ] . addConnection ( Node [ b - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> bfs ( Node [ 0 ] ) <NEWLINE> <COMMENT> <NL> between : int = Node [ N - 1 ] . rank - 1 <NEWLINE> <COMMENT> <NL> sep = ( between + 1 ) // 2 <NEWLINE> path = makePath ( Node [ 0 ] , Node [ N - 1 ] ) <NEWLINE> <COMMENT> <NL> path [ sep ] . delConnection ( path [ sep + 1 ] ) <NEWLINE> path [ sep + 1 ] . setAsRoot ( ) <NEWLINE> bfs ( path [ sep + 1 ] ) <NEWLINE> <COMMENT> <NL> fennec , snuke = Counter ( [ n . root . id for n in Node ] ) . values ( ) <NEWLINE> <COMMENT> <NL> print ( <STRING> if fennec > snuke else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> bomb_count = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> for l in range ( 3 ) : <NEWLINE> <INDENT> a = i - 1 + k <NEWLINE> b = j - 1 + l <NEWLINE> if a < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif a > h - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if b < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif b > w - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ a ] [ b ] == <STRING> : <NEWLINE> <INDENT> bomb_count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s [ i ] [ j ] = str ( bomb_count ) <NEWLINE> bomb_count = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( s [ i ] ) ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> cnt = ord ( <STRING> ) - ord ( c ) + 1 <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif K >= cnt : <NEWLINE> <INDENT> K -= cnt <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> <DEDENT> <DEDENT> K %= 26 <NEWLINE> if 122 < ord ( ans [ - 1 ] ) + K : <NEWLINE> <INDENT> ans [ - 1 ] = chr ( ord ( ans [ - 1 ] ) + K - 26 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ - 1 ] = chr ( ord ( ans [ - 1 ] ) + K ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L_lis = [ ] <NEWLINE> R_lis = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> L_lis . append ( L ) <NEWLINE> R_lis . append ( R ) <NEWLINE> <DEDENT> new_L , new_R = max ( L_lis ) , min ( R_lis ) <NEWLINE> if new_L <= new_R : <NEWLINE> <INDENT> print ( new_R - new_L + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import deque <NEWLINE> def bfs ( field , s ) : <NEWLINE> <INDENT> q = deque ( [ ( 0 , s ) ] ) <NEWLINE> MOVE = [ ( - 1 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) ] <NEWLINE> dist = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> d , i , j = - 1 , - 1 , - 1 <NEWLINE> while q : <NEWLINE> <INDENT> d , ( i , j ) = q . popleft ( ) <NEWLINE> if dist [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] [ j ] = d <NEWLINE> for di , dj in MOVE : <NEWLINE> <INDENT> ni = i + di <NEWLINE> nj = j + dj <NEWLINE> if not 0 <= ni < H or not 0 <= nj < W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist [ ni ] [ nj ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( ( d + 1 , ( ni , nj ) ) ) <NEWLINE> <DEDENT> <DEDENT> return d , i , j <NEWLINE> <DEDENT> H , W = MI ( ) <NEWLINE> field = [ input ( ) for _ in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> d , i , j = bfs ( field , ( i , j ) ) <NEWLINE> ans = max ( ans , d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = i = j = 0 <NEWLINE> <NL> import bisect <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> i = bisect . bisect_left ( A , b ) <NEWLINE> j = N - bisect . bisect_right ( C , b ) <NEWLINE> ans += i * j <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> d . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while i < n and j < m : <NEWLINE> <INDENT> if d [ i ] == t [ j ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if j == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> while s [ 0 ] != <STRING> or s [ - 1 ] != <STRING> : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . pop ( 0 ) <NEWLINE> s . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ abs ( a [ 0 ] ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d . append ( abs ( a [ i + 1 ] - a [ i ] ) ) <NEWLINE> <NL> <DEDENT> d . append ( abs ( a [ - 1 ] ) ) <NEWLINE> <NL> s = sum ( d ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t = s - d [ i ] - d [ i + 1 ] + abs ( a [ i + 1 ] ) <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> t = s - d [ i ] - d [ i + 1 ] + abs ( - a [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = s - d [ i ] - d [ i + 1 ] + abs ( a [ i + 1 ] - a [ i - 1 ] ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - ( x + y ) <NEWLINE> if 0 <= z <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> newa = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> newa [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * newa , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if flg [ x ] : <NEWLINE> <INDENT> flg [ x ] = 0 <NEWLINE> p = 0 <NEWLINE> for y in glaph [ x ] : <NEWLINE> <INDENT> p = max ( p , f ( y ) + 1 ) <NEWLINE> <DEDENT> dp [ x ] = p <NEWLINE> <DEDENT> return dp [ x ] <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> flg = [ 1 ] * ( n + 1 ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> glaph = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> glaph [ x ] . append ( y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , f ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> from scipy . special import comb <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> aa = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = sorted ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( s ) ] <NEWLINE> aa . append ( * s ) <NEWLINE> <NL> <DEDENT> cc = collections . Counter ( aa ) <NEWLINE> c = [ c [ 1 ] for c in cc . items ( ) if c [ 1 ] > 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> ans += comb ( c [ i ] , 2 , exact = True ) <NEWLINE> <NL> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> kouho = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> kouho . remove ( i ) <NEWLINE> <DEDENT> if kouho == [ ] : <NEWLINE> <INDENT> kouho . append ( s . pop ( - 1 ) ) <NEWLINE> for i in range ( 25 ) : <NEWLINE> <INDENT> dum = s . pop ( - 1 ) <NEWLINE> for j in range ( len ( kouho ) ) : <NEWLINE> <INDENT> if dum < kouho [ j ] : <NEWLINE> <INDENT> s . append ( kouho [ j ] ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> kouho . append ( dum ) <NEWLINE> kouho . sort ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( kouho [ 0 ] ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for q in range ( Q ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> flg = [ ] <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> tmp_s = S [ n : n + 2 ] <NEWLINE> if tmp_s == <STRING> : <NEWLINE> <INDENT> flg . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> flg2 = [ 0 ] + flg <NEWLINE> flg2 = list ( accumulate ( flg2 ) ) <NEWLINE> <COMMENT> <NL> <NL> for a in A : <NEWLINE> <INDENT> print ( flg2 [ a [ 1 ] - 1 ] - flg2 [ a [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import sys <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <COMMENT> <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> point = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ a - 1 ] += b <COMMENT> <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <COMMENT> <NEWLINE> <INDENT> for next in graph [ now ] : <COMMENT> <NEWLINE> <INDENT> if next == prev : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <COMMENT> <NEWLINE> dfs ( next , now ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <COMMENT> <NEWLINE> print ( * point ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b * 2 >= a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b * 2 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minlist = [ ] <NEWLINE> maxlist = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> if b - i >= a : <NEWLINE> <INDENT> minlist . append ( a + i ) <NEWLINE> <DEDENT> if b - i >= a + k : <NEWLINE> <INDENT> maxlist . insert ( 0 , b - i ) <NEWLINE> <DEDENT> <DEDENT> ans = minlist + maxlist <NEWLINE> set ( ans ) <NEWLINE> for i in range ( 0 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , 20 ) : <NEWLINE> <INDENT> p += a - 1 <NEWLINE> ans += 1 <NEWLINE> if p >= b : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX_EXP = 30 <COMMENT> <NEWLINE> pow2 = [ 1 ] * ( MAX_EXP + 1 ) <NEWLINE> for e in range ( 1 , MAX_EXP + 1 ) : <NEWLINE> <INDENT> pow2 [ e ] = 2 * pow2 [ e - 1 ] <NEWLINE> <DEDENT> counter = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> counter [ a ] += 1 <NEWLINE> <DEDENT> DISTINCT_A = list ( counter . keys ( ) ) <NEWLINE> DISTINCT_A . sort ( reverse = True ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for a in DISTINCT_A : <NEWLINE> <INDENT> b = pow2 [ a . bit_length ( ) ] - a <NEWLINE> if counter [ b ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = min ( counter [ a ] , counter [ b ] ) <NEWLINE> ans += cnt <NEWLINE> counter [ a ] -= cnt <NEWLINE> counter [ b ] -= cnt <NEWLINE> <COMMENT> <NL> <DEDENT> for e in range ( MAX_EXP + 1 ) : <NEWLINE> <INDENT> a = pow2 [ e ] <NEWLINE> ans += counter [ a ] // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def isPrime ( num ) : <NEWLINE> <INDENT> if num < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif num % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( num ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_2017 ( num ) : <NEWLINE> <INDENT> temp = ( num + 1 ) // 2 <NEWLINE> if isPrime ( num ) and isPrime ( temp ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> is_2017_list = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> if is_2017 ( i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> is_2017_list [ i ] = count <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> is_2017_list [ i ] = count <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> ans_list = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = is_2017_list [ r ] - is_2017_list [ l - 1 ] <NEWLINE> ans_list . append ( ans ) <NEWLINE> <NL> <DEDENT> for ans in ans_list : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import collections <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> . join ( [ <STRING> . join ( input ( ) . split ( ) ) for _ in range ( h ) ] ) <NEWLINE> <NL> ctr = collections . Counter ( s ) <NEWLINE> if h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> four , two = h * w // 4 , 0 <NEWLINE> <DEDENT> elif h % 2 == 0 : <NEWLINE> <INDENT> four , two = ( h * w - h ) // 4 , h // 2 <NEWLINE> <DEDENT> elif w % 2 == 0 : <NEWLINE> <INDENT> four , two = ( h * w - w ) // 4 , w // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> four , two = ( h * w - h - w + 1 ) // 4 , ( h + w - 1 ) // 2 <NEWLINE> <NL> <DEDENT> cf = sum ( [ c // 4 for c in ctr . values ( ) ] ) <NEWLINE> ct = sum ( [ ( c % 4 ) // 2 for c in ctr . values ( ) ] ) <NEWLINE> <NL> if cf >= four and ct + 2 * ( cf - four ) >= two : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def val_add ( i , con , val ) : <NEWLINE> <INDENT> if con [ i ] : <NEWLINE> <INDENT> for j in con [ i ] : <NEWLINE> <INDENT> val [ j ] += val [ i ] <NEWLINE> val_add ( j , con , val ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def tree ( i , con ) : <NEWLINE> <INDENT> if not con [ i ] : pass <NEWLINE> else : <NEWLINE> <INDENT> for j in con [ i ] : <NEWLINE> <INDENT> con [ j ] . remove ( i ) <NEWLINE> tree ( j , con ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> con = [ [ ] for _ in range ( n ) ] <NEWLINE> val = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> con [ a - 1 ] . append ( b - 1 ) <NEWLINE> con [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> tree ( 0 , con ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> val [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> val_add ( 0 , con , val ) <NEWLINE> <NL> <NL> print ( <STRING> . join ( map ( str , val ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> price = [ x * ( - 1 ) for x in p ] <NEWLINE> heapq . heapify ( price ) <NEWLINE> while m != 0 : <NEWLINE> <INDENT> max_price = heapq . heappop ( price ) * ( - 1 ) <NEWLINE> heapq . heappush ( price , ( max_price // 2 ) * ( - 1 ) ) <NEWLINE> m -= 1 <NEWLINE> <DEDENT> print ( sum ( price ) * ( - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> d = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ss = [ <STRING> for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> f = False <NEWLINE> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> f = True <NEWLINE> continue <NEWLINE> <DEDENT> for dy , dx in d : <NEWLINE> <INDENT> if 0 <= i + dy < h and 0 <= j + dx < w : <NEWLINE> <INDENT> if s [ i + dy ] [ j + dx ] == <STRING> : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not f : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> mod = 1000000007 <NEWLINE> <NL> memo = [ - 1 ] * ( n + 1 ) <NEWLINE> memo [ 0 ] = 0 <NEWLINE> <NL> for k in range ( m ) : <NEWLINE> <INDENT> memo [ a [ k ] ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if memo [ i ] != - 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i <= 2 : <NEWLINE> <INDENT> memo [ i ] = memo [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( memo [ - 1 ] % mod ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = ans * i % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> lis = [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> lis . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( lis ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> <NL> bc = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <NL> <NL> ai = N - 1 <NEWLINE> mi = M - 1 <NEWLINE> pos = 0 <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if ( A [ ai ] > bc [ mi ] [ 1 ] ) | ( mi < 0 ) : <NEWLINE> <INDENT> pos += 1 <NEWLINE> ans += A [ ai ] <NEWLINE> ai -= 1 <NEWLINE> <DEDENT> elif pos + bc [ mi ] [ 0 ] >= N : <NEWLINE> <INDENT> ans += bc [ mi ] [ 1 ] * ( N - pos ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += bc [ mi ] [ 0 ] * bc [ mi ] [ 1 ] <NEWLINE> pos += bc [ mi ] [ 0 ] <NEWLINE> mi -= 1 <NEWLINE> <DEDENT> if pos >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( H [ 1 ] - H [ 0 ] ) <NEWLINE> <NL> for n in range ( 2 , N ) : <NEWLINE> <INDENT> if n - K > 0 : <NEWLINE> <INDENT> dp [ n ] = min ( [ ( dp [ i ] + abs ( H [ n ] - H [ i ] ) ) for i in range ( n - K , n ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ n ] = min ( [ dp [ i ] + abs ( H [ n ] - H [ i ] ) for i in range ( 0 , n ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
N , M = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for c in range ( N ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for c in range ( M ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mi = 2 * 10 ** 9 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> tmp = abs ( ab [ i ] [ 0 ] - cd [ j ] [ 0 ] ) + abs ( ab [ i ] [ 1 ] - cd [ j ] [ 1 ] ) <NEWLINE> if mi > tmp : <NEWLINE> <INDENT> mi = tmp <NEWLINE> ans = j + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ [ ] for _ in range ( n ) ] ; b = [ - 1 ] * n ; b [ 0 ] = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ u - 1 ] . append ( [ v - 1 , w ] ) ; a [ v - 1 ] . append ( [ u - 1 , w ] ) <NEWLINE> <DEDENT> def dfs ( A , k ) : <NEWLINE> <INDENT> for i in A [ k ] : <NEWLINE> <INDENT> if b [ i [ 0 ] ] == - 1 : <NEWLINE> <INDENT> b [ i [ 0 ] ] = b [ k ] + i [ 1 ] <NEWLINE> dfs ( A , i [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( a , 0 ) <NEWLINE> for i in b : <NEWLINE> <INDENT> print ( 0 ) if i % 2 == 0 else print ( 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> c = Counter ( s ) <NEWLINE> ans = 1 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> ans = ( ans * ( i + 1 ) ) % 1000000007 <NEWLINE> <DEDENT> print ( ans - 1 ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in readline ( ) . split ( ) ] <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> dp = [ inf ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> leng = i + 1 if i < K else K + 1 <NEWLINE> for j in range ( leng ) : <NEWLINE> <INDENT> cal = dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) <NEWLINE> if dp [ i ] > cal : <NEWLINE> <INDENT> dp [ i ] = cal <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
b = input ( ) <NEWLINE> A = b . count ( <STRING> ) <NEWLINE> B = b . count ( <STRING> ) <NEWLINE> print ( min ( 2 * A , 2 * B ) ) <NEWLINE>
A , B , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> result_list = [ ] <NEWLINE> <NL> def divisor_list ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> array = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> array . append ( i ) <NEWLINE> array . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> array = list ( set ( array ) ) <NEWLINE> return array <NEWLINE> <NL> <DEDENT> for i in divisor_list ( A ) : <NEWLINE> <INDENT> for j in divisor_list ( B ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> result_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sorted ( result_list ) [ - K ] ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> mn = P [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if mn >= P [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> mn = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import sys , collections <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> nums = [ 0 for i in range ( n ) ] <NEWLINE> day = 0 <NEWLINE> match = 0 <NEWLINE> flag = True <NEWLINE> queue = collections . deque ( [ ] ) <NEWLINE> temp = set ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> i2 = a [ i - 1 ] [ 0 ] <NEWLINE> if a [ i2 - 1 ] [ 0 ] == i : <NEWLINE> <INDENT> if i not in temp : <NEWLINE> <INDENT> queue . append ( [ i , i2 ] ) <NEWLINE> temp . add ( i ) <NEWLINE> temp . add ( i2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not queue : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> while queue : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> while queue : <NEWLINE> <INDENT> test = queue . popleft ( ) <NEWLINE> match += 1 <NEWLINE> num1 , num2 = test [ 0 ] , test [ 1 ] <NEWLINE> nums [ num1 - 1 ] += 1 <NEWLINE> nums [ num2 - 1 ] += 1 <NEWLINE> temp . append ( num1 ) <NEWLINE> temp . append ( num2 ) <NEWLINE> <DEDENT> flag2 = False <NEWLINE> temp2 = set ( ) <NEWLINE> for i in temp : <NEWLINE> <INDENT> if nums [ i - 1 ] <= n - 2 : <NEWLINE> <INDENT> new_num = a [ i - 1 ] [ nums [ i - 1 ] ] <NEWLINE> if nums [ new_num - 1 ] <= n - 2 and a [ new_num - 1 ] [ nums [ new_num - 1 ] ] == i : <NEWLINE> <INDENT> if i not in temp2 : <NEWLINE> <INDENT> queue . append ( [ i , new_num ] ) <NEWLINE> flag2 = True <NEWLINE> temp2 . add ( i ) <NEWLINE> temp2 . add ( new_num ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag2 == False and match < n * ( n - 1 ) // 2 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> day += 1 <NEWLINE> <NL> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( day ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) <NEWLINE> write = lambda x : sys . stdout . write ( x + <STRING> ) <NEWLINE> <NL> <NL> from collections import defaultdict <NEWLINE> n , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ns = defaultdict ( list ) <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> ns [ u - 1 ] . append ( v - 1 ) <NEWLINE> ns [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> bs = { } <NEWLINE> cump0 = defaultdict ( list ) <NEWLINE> cump1 = defaultdict ( list ) <NEWLINE> def sub ( u , p ) : <NEWLINE> <INDENT> if ( p , u ) in bs : <NEWLINE> <INDENT> return bs [ p , u ] <NEWLINE> <DEDENT> b = 1 <NEWLINE> ps = [ ] <NEWLINE> for v in ns [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> bb = sub ( v , u ) <NEWLINE> b *= ( 1 + bb ) <NEWLINE> b %= M <NEWLINE> ps . append ( bb ) <NEWLINE> <DEDENT> v0 = 1 <NEWLINE> v1 = 1 <NEWLINE> l = len ( ps ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> cump0 [ u ] . append ( v0 ) <NEWLINE> cump1 [ u ] . append ( v1 ) <NEWLINE> v0 *= ps [ i ] + 1 <NEWLINE> v1 *= ps [ l - 1 - i ] + 1 <NEWLINE> v0 %= M ; v1 %= M <NEWLINE> <DEDENT> cump0 [ u ] . append ( v0 ) <NEWLINE> cump1 [ u ] . append ( v1 ) <NEWLINE> <NL> bs [ p , u ] = b % M <NEWLINE> return b <NEWLINE> <NL> <DEDENT> ans = [ None ] * n <NEWLINE> def sub2 ( u , p ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for v in ns [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b1 = bs [ p , u ] <NEWLINE> b2 = bs [ u , v ] <NEWLINE> b3 = bs [ u , p ] <NEWLINE> if p >= 0 : <NEWLINE> <INDENT> bb = ( cump0 [ u ] [ i ] * cump1 [ u ] [ - ( i + 2 ) ] * ( 1 + b3 ) ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bb = ( cump0 [ u ] [ i ] * cump1 [ u ] [ - ( i + 2 ) ] ) % M <NEWLINE> <DEDENT> bs [ v , u ] = bb <NEWLINE> ans [ v ] = bs [ u , v ] * ( 1 + bb ) % M <NEWLINE> sub2 ( v , u ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sub ( 0 , - 1 ) <NEWLINE> bs [ 0 , - 1 ] = 1 <NEWLINE> ans [ 0 ] = bs [ - 1 , 0 ] <NEWLINE> sub2 ( 0 , - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> write ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = Counter ( lis ) <NEWLINE> <NL> slis = sorted ( set ( lis ) ) <NEWLINE> <NL> t1 = 0 <NEWLINE> t2 = 0 <NEWLINE> <NL> for k , v in a . items ( ) : <NEWLINE> <INDENT> if v >= 2 and k > t1 : <NEWLINE> <INDENT> t2 = t1 <NEWLINE> t1 = k <NEWLINE> <NL> <DEDENT> <DEDENT> if a [ t1 ] >= 4 : <NEWLINE> <INDENT> print ( t1 * t1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( t1 * t2 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> s = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s_dict = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] in s_dict : <NEWLINE> <INDENT> s_dict [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_dict [ s [ i ] ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for j in s_dict . values ( ) : <NEWLINE> <INDENT> ans += j * ( j - 1 ) // 2 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( li ) <NEWLINE> a += li [ 0 ] <NEWLINE> b = max ( b , li [ 1 ] ) <NEWLINE> <NL> <DEDENT> l = sorted ( l , key = lambda x : x [ 1 ] ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count += l [ i ] [ 0 ] <NEWLINE> if count <= l [ i ] [ 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum = min ( sum * 2 , sum + k ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> dp = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i + 1 < H and maze [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] += dp [ i ] [ j ] % mod <NEWLINE> <DEDENT> if j + 1 < W and maze [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j + 1 ] += dp [ i ] [ j ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ H - 1 ] [ W - 1 ] % mod ) <NEWLINE>
import itertools as it <NEWLINE> import sys <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 or M == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> a = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( [ x , y ] ) <NEWLINE> a . append ( [ y , x ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for e in it . permutations ( range ( N ) ) : <NEWLINE> <INDENT> if e [ 0 ] != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if [ e [ j ] + 1 , e [ j + 1 ] + 1 ] in a : <NEWLINE> <INDENT> count *= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count *= 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans += count <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> road = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ x ] . append ( y ) <NEWLINE> <DEDENT> flag = [ 0 ] * ( N + 1 ) <NEWLINE> dist = [ 0 ] * ( N + 1 ) <NEWLINE> def distance ( i ) : <COMMENT> <NEWLINE> <INDENT> if flag [ i ] == 1 : <NEWLINE> <INDENT> return dist [ i ] <NEWLINE> <NL> <DEDENT> if road [ i ] == [ ] : <COMMENT> <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> long_dist = 0 <NEWLINE> tmp = 0 <NEWLINE> for dirct in road [ i ] : <NEWLINE> <INDENT> tmp = 1 + distance ( dirct ) <NEWLINE> long_dist = max ( long_dist , tmp ) <NEWLINE> <DEDENT> flag [ i ] = 1 <NEWLINE> dist [ i ] = long_dist <NEWLINE> return long_dist <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , distance ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> enemy = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> enemy . sort ( reverse = True ) <NEWLINE> <NL> if k >= n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <NL> <INDENT> for x in range ( k ) : <NEWLINE> <INDENT> enemy [ x ] = 0 <NEWLINE> <NL> <DEDENT> print ( sum ( enemy ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> nums [ 0 ] = 1 <NEWLINE> if 1 not in a : nums [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> nums [ i ] = nums [ i - 1 ] + nums [ i - 2 ] <NEWLINE> if i in a : nums [ i ] = 0 <NEWLINE> <DEDENT> print ( nums [ n ] % 1000000007 ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if k >= 0 and k <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> div = make_divisors ( N ) <NEWLINE> ans = 100 <NEWLINE> <NL> for d in div : <NEWLINE> <INDENT> a = d <NEWLINE> b = N // a <NEWLINE> ans = min ( ans , max ( len ( str ( a ) ) , len ( str ( b ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> x = P [ 0 ] <NEWLINE> <NL> <NL> for i in P : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x >= i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = i <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , list ( input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> padded = [ [ 0 for i in range ( W + 2 ) ] for j in range ( H + 2 ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> padded [ i + 1 ] [ j + 1 ] = s [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if padded [ i ] [ j ] == 1 : <NEWLINE> <INDENT> if padded [ i + 1 ] [ j ] == 0 and padded [ i - 1 ] [ j ] == 0 and padded [ i ] [ j + 1 ] == 0 and padded [ i ] [ j - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( 1 , min ( A , B ) + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( list [ len ( list ) - K ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ 0 ] * M <NEWLINE> R = [ 0 ] * M <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> l = max ( L ) <NEWLINE> r = min ( R ) <NEWLINE> <NL> print ( max ( r - l + 1 , 0 ) ) <NEWLINE>
s = input ( ) ; a = [ ] ; b = [ 0 ] * 27 ; t = <STRING> <NEWLINE> for i in range ( len ( s ) ) : a . append ( ord ( s [ i ] ) ) ; b [ a [ i ] - 97 ] = 1 <NEWLINE> if s == <STRING> : print ( - 1 ) <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( 27 ) : <NEWLINE> <INDENT> if b [ i ] == 0 : c = i ; break <NEWLINE> <DEDENT> if c != 26 : <NEWLINE> <INDENT> a . append ( c + 97 ) <NEWLINE> for i in range ( len ( a ) ) : t += chr ( a [ i ] ) <NEWLINE> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = [ ] <NEWLINE> for _ in range ( 24 ) : <NEWLINE> <INDENT> if a [ - 2 ] > a [ - 1 ] : d . append ( a . pop ( ) ) <NEWLINE> else : <NEWLINE> <INDENT> d . append ( a . pop ( ) ) ; d . sort ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : d . append ( a . pop ( ) ) ; d . sort ( ) <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if a [ - 1 ] < d [ i ] : a . pop ( ) ; a . append ( d [ i ] ) ; break <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : t += chr ( a [ i ] ) <NEWLINE> print ( t ) <NEWLINE> <DEDENT> <DEDENT>
def fennec_vs_monster ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> H . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> H = H [ K : ] <NEWLINE> <COMMENT> <NL> sum_H = sum ( H ) <NEWLINE> <COMMENT> <NL> return sum_H <NEWLINE> <NL> <DEDENT> result = fennec_vs_monster ( ) <NEWLINE> print ( result ) <NEWLINE>
splited = input ( ) . split ( <STRING> ) <NEWLINE> <NL> k = int ( splited [ 0 ] ) <NEWLINE> s = int ( splited [ 1 ] ) <NEWLINE> <NL> result = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z and z <= k : <NEWLINE> <INDENT> result = result + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( Q ) ] <NEWLINE> point = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> point [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> point [ i ] -= ( Q - K ) <NEWLINE> <DEDENT> for p in range ( N ) : <NEWLINE> <INDENT> if point [ p ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = [ int ( x ) for x in input ( ) ] <NEWLINE> op_cnt = len ( n ) - 1 <NEWLINE> out = 0 <NEWLINE> for i in range ( 2 ** op_cnt ) : <NEWLINE> <INDENT> op = [ <STRING> ] * op_cnt <NEWLINE> box = <STRING> <NEWLINE> for j in range ( op_cnt ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> op [ op_cnt - 1 - j ] = <STRING> <NEWLINE> <DEDENT> box = <STRING> <NEWLINE> <DEDENT> for a , b in zip ( n , op + [ <STRING> ] ) : <NEWLINE> <INDENT> box += ( str ( a ) + b ) <NEWLINE> <DEDENT> box = box . split ( <STRING> ) <NEWLINE> ou = 0 <NEWLINE> for k in box : <NEWLINE> <INDENT> out += int ( k ) <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> x = l [ 2 ] <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> print ( b // x - a // x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b // x - a // x ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> if A == B : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif A == B : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif A > B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B * ( N - 2 ) - A * ( N - 2 ) + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> push = 0 <NEWLINE> count = set ( ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <NL> <INDENT> if A [ push ] == 1 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif A [ push ] in count : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count . add ( push ) <NEWLINE> push = A [ push ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> s = 0 <NEWLINE> m = 10 ** 9 <NEWLINE> for ai in A : <NEWLINE> <INDENT> if ai <= 0 : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> ai *= ( - 1 ) <NEWLINE> <DEDENT> s += ai <NEWLINE> if m > ai : <NEWLINE> <INDENT> m = ai <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans = s <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = s - 2 * m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def is_able ( n , m , k ) : <NEWLINE> <INDENT> res = defaultdict ( bool ) <NEWLINE> res [ 0 ] = True <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> count += i * j <NEWLINE> count += ( n - i ) * ( m - j ) <NEWLINE> res [ count ] = True <NEWLINE> <DEDENT> <DEDENT> return res [ k ] <NEWLINE> <NL> <NL> <DEDENT> if is_able ( n , m , k ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def binary_search ( K , A , F ) : <NEWLINE> <INDENT> ng = - 1 <NEWLINE> ok = 10 ** 18 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> need_k = 0 <NEWLINE> for a , f in zip ( A , F ) : <NEWLINE> <INDENT> need_k += max ( 0 , a - mid // f ) <NEWLINE> <DEDENT> if need_k <= K : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> A = np . sort ( A ) <NEWLINE> F = np . sort ( F ) [ : : - 1 ] <NEWLINE> <NL> ans = binary_search ( K , A , F ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> rev_s = s + s [ : : - 1 ] <NEWLINE> mido = <STRING> * n <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if mido > rev_s [ i : i + n ] : <NEWLINE> <INDENT> mido = rev_s [ i : i + n ] <NEWLINE> <DEDENT> <DEDENT> ind = float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if mido [ i ] != mido [ 0 ] : <NEWLINE> <INDENT> if i < ind : <NEWLINE> <INDENT> ind = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ind * ( 2 ** min ( k - 1 , 20 ) ) <NEWLINE> print ( ( mido [ 0 ] * ans + mido [ ind : ind + n - ans ] ) [ : n ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split ( ) <NEWLINE> S = list ( S ) <NEWLINE> T = list ( T ) <NEWLINE> ans = [ ] <NEWLINE> for s , t in zip ( S , T ) : <NEWLINE> <INDENT> ans . append ( s ) <NEWLINE> ans . append ( t ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys <NEWLINE> <NL> s = sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> <NL> while l < r : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ l ] == <STRING> and s [ r ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif s [ l ] != s [ r ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ 0 ] * 10 ** 6 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> li [ A [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> li . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> print ( sum ( li [ K : ] ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = range ( a , b + 1 ) <NEWLINE> for i in sorted ( set ( n [ : k ] ) | set ( n [ - k : ] ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> dp = [ INF ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> i_j = i + j <NEWLINE> if i_j < n : <NEWLINE> <INDENT> x = dp [ i ] + abs ( h [ i ] - h [ i_j ] ) <NEWLINE> if dp [ i_j ] > x : <NEWLINE> <INDENT> dp [ i_j ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> B . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> i , j = 0 , 0 <NEWLINE> while i <= N - 1 : <NEWLINE> <INDENT> for l in range ( B [ j ] [ 0 ] ) : <NEWLINE> <INDENT> if A [ i ] >= B [ j ] [ 1 ] : <NEWLINE> <INDENT> print ( sum ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A [ i ] = B [ j ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> if i == N : <NEWLINE> <INDENT> print ( sum ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> if j == M : <NEWLINE> <INDENT> print ( sum ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> idx1 = s . find ( str ( i ) ) <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> idx2 = s . find ( str ( j ) , idx1 + 1 , n ) <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> idx3 = s . find ( str ( k ) , idx2 + 1 , n ) <NEWLINE> if idx1 == - 1 or idx2 == - 1 or idx3 == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = sorted ( x ) <NEWLINE> l = [ 0 ] * ( m - 1 ) <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> l [ i ] = x [ i + 1 ] - x [ i ] <NEWLINE> <NL> <DEDENT> l = sorted ( l ) [ : : - 1 ] <NEWLINE> dist = x [ m - 1 ] - x [ 0 ] - sum ( l [ : n - 1 ] ) <NEWLINE> print ( dist ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = s <NEWLINE> factors = { } <NEWLINE> <NL> while p > 1 : <NEWLINE> <INDENT> f = False <NEWLINE> for i in range ( 2 , int ( p ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> if i in factors : <NEWLINE> <INDENT> factors [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> factors [ i ] = 1 <NEWLINE> <NL> <DEDENT> p //= i <NEWLINE> f = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not f : <NEWLINE> <INDENT> if p in factors : <NEWLINE> <INDENT> factors [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> factors [ p ] = 1 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( factors ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> primes = list ( factors . keys ( ) ) <NEWLINE> exp = [ 0 ] * len ( primes ) <NEWLINE> upper = s / k <NEWLINE> ans = 1 <NEWLINE> <NL> while exp [ 0 ] <= factors [ primes [ 0 ] ] : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in range ( len ( primes ) ) : <NEWLINE> <INDENT> num *= pow ( primes [ i ] , exp [ i ] ) <NEWLINE> <NL> <DEDENT> if num == upper : <NEWLINE> <INDENT> ans = num <NEWLINE> break <NEWLINE> <DEDENT> elif num < upper : <NEWLINE> <INDENT> ans = max ( ans , num ) <NEWLINE> <NL> <DEDENT> index = len ( primes ) - 1 <NEWLINE> done = False <NEWLINE> while not done : <NEWLINE> <INDENT> exp [ index ] += 1 <NEWLINE> if exp [ index ] > factors [ primes [ index ] ] : <NEWLINE> <INDENT> if index == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exp [ index ] = 0 <NEWLINE> index -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> done = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> pq = { } <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> a1 , b1 = ab [ i ] <NEWLINE> a2 , b2 = ab [ j ] <NEWLINE> p = a1 - a2 <NEWLINE> q = b1 - b2 <NEWLINE> if p < 0 or p == 0 and q < 0 : <NEWLINE> <INDENT> p = - p <NEWLINE> q = - q <NEWLINE> <DEDENT> if ( p , q ) in pq : <NEWLINE> <INDENT> pq [ ( p , q ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pq [ ( p , q ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n - max ( pq . values ( ) ) ) <NEWLINE>
H , W , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in range ( B ) : <NEWLINE> <INDENT> print ( <STRING> * A + <STRING> * ( W - A ) ) <NEWLINE> <DEDENT> for _ in range ( H - B ) : <NEWLINE> <INDENT> print ( <STRING> * A + <STRING> * ( W - A ) ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> pos = 0 <NEWLINE> count = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pos += l [ i ] <NEWLINE> if pos > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n , a = input ( ) . split ( ) <NEWLINE> A . append ( int ( n ) ) <NEWLINE> B . append ( int ( a ) ) <NEWLINE> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mini = g ( x - A [ 0 ] ) + B [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sub = g ( x - A [ i ] ) + B [ i ] <NEWLINE> if sub < mini : <NEWLINE> <INDENT> mini = sub <NEWLINE> <DEDENT> <DEDENT> return mini <NEWLINE> <DEDENT> <DEDENT> def g ( x ) : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return g_list [ x ] <NEWLINE> <DEDENT> <DEDENT> g_list = [ ] <NEWLINE> g_list . append ( 0 ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> g_list . append ( f ( i ) ) <NEWLINE> <DEDENT> print ( g_list [ - 1 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> B . sort ( ) <NEWLINE> <NL> print ( sum ( B [ 0 : N - K ] ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> for k in A : <NEWLINE> <INDENT> dp [ k ] = <STRING> <NEWLINE> <DEDENT> dp [ 0 ] = 1 <NEWLINE> if dp [ 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> connect = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> connect [ a - 1 ] . add ( b - 1 ) <NEWLINE> connect [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> counter = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> def dfs ( count , v , parent ) : <NEWLINE> <INDENT> count += counter [ v ] <NEWLINE> ans [ v ] = count <NEWLINE> for child in connect [ v ] : <NEWLINE> <INDENT> if child != parent : <NEWLINE> <INDENT> dfs ( count , child , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 , - 1 ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( arr , arr [ i ] + arr [ j ] ) <NEWLINE> if k > j : <NEWLINE> <INDENT> ans += k - j - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( D ) <NEWLINE> flag = True <NEWLINE> for t in T : <NEWLINE> <INDENT> if c [ t ] > 0 : <NEWLINE> <INDENT> c [ t ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> check = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) - 1 <NEWLINE> check [ A ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> if check [ i ] > 0 else <STRING> ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A_after = 0 <NEWLINE> B_after = 0 <NEWLINE> <NL> if A - K >= 0 : <NEWLINE> <INDENT> A_after = A - K <NEWLINE> B_after = B <NEWLINE> <NL> <DEDENT> elif A + B - K >= 0 : <NEWLINE> <INDENT> B_after = B - ( K - A ) <NEWLINE> <NL> <DEDENT> print ( A_after , B_after ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> c1 = [ ] <NEWLINE> c2 = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> c1 . append ( b ) <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> c2 . append ( a ) <NEWLINE> <DEDENT> <DEDENT> c1 = set ( c1 ) <NEWLINE> c2 = set ( c2 ) <NEWLINE> if c1 & c2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( n , m , q , sss , xy ) : <NEWLINE> <INDENT> dp1 = np . zeros ( ( n + 1 , m + 1 ) , dtype = np . int64 ) <NEWLINE> dpv = np . zeros ( ( n + 1 , m + 1 ) , dtype = np . int64 ) <NEWLINE> dph = np . zeros ( ( n + 1 , m + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if sss [ i , j ] == 1 : <NEWLINE> <INDENT> dp1 [ i + 1 , j + 1 ] = 1 <NEWLINE> <NL> if i > 0 and sss [ i - 1 , j ] == 1 : <NEWLINE> <INDENT> dpv [ i + 1 , j + 1 ] = 1 <NEWLINE> <DEDENT> if j > 0 and sss [ i , j - 1 ] == 1 : <NEWLINE> <INDENT> dph [ i + 1 , j + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> dp1 [ i , j ] += dp1 [ i , j - 1 ] <NEWLINE> dpv [ i , j ] += dpv [ i , j - 1 ] <NEWLINE> dph [ i , j ] += dph [ i , j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp1 [ i , j ] += dp1 [ i - 1 , j ] <NEWLINE> dpv [ i , j ] += dpv [ i - 1 , j ] <NEWLINE> dph [ i , j ] += dph [ i - 1 , j ] <NEWLINE> <NL> <DEDENT> <DEDENT> buf = np . zeros ( q , dtype = np . int64 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x1 = xy [ i * 4 + 0 ] <NEWLINE> y1 = xy [ i * 4 + 1 ] <NEWLINE> x2 = xy [ i * 4 + 2 ] <NEWLINE> y2 = xy [ i * 4 + 3 ] <NEWLINE> cnt1 = dp1 [ x2 ] [ y2 ] - dp1 [ x1 - 1 ] [ y2 ] - dp1 [ x2 ] [ y1 - 1 ] + dp1 [ x1 - 1 ] [ y1 - 1 ] <NEWLINE> ver1 = dpv [ x2 ] [ y2 ] - dpv [ x1 ] [ y2 ] - dpv [ x2 ] [ y1 - 1 ] + dpv [ x1 ] [ y1 - 1 ] <NEWLINE> hor1 = dph [ x2 ] [ y2 ] - dph [ x1 - 1 ] [ y2 ] - dph [ x2 ] [ y1 ] + dph [ x1 - 1 ] [ y1 ] <NEWLINE> buf [ i ] = cnt1 - ver1 - hor1 <NEWLINE> <NL> <DEDENT> return buf <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> <NL> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> sss = np . array ( [ list ( map ( int , input ( ) ) ) for _ in range ( n ) ] , dtype = np . int8 ) <NEWLINE> xy = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( n , m , q , sss , xy ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> <NL> def dfs1 ( v , p ) : <NEWLINE> <INDENT> val = 1 <NEWLINE> pre_mul = [ 1 ] <NEWLINE> rev_mul = [ ] <NEWLINE> for c in links [ v ] : <NEWLINE> <INDENT> if c == p : <NEWLINE> <INDENT> pre_mul . append ( val ) <NEWLINE> rev_mul . append ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> res = 1 + dfs1 ( c , v ) <NEWLINE> val *= res <NEWLINE> val %= m <NEWLINE> pre_mul . append ( val ) <NEWLINE> rev_mul . append ( res ) <NEWLINE> <DEDENT> dp [ v ] = val <NEWLINE> for i in range ( len ( rev_mul ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> rev_mul [ i ] *= rev_mul [ i + 1 ] <NEWLINE> rev_mul [ i ] %= m <NEWLINE> <DEDENT> rev_mul . append ( 1 ) <NEWLINE> pre_muls [ v ] = [ pre_mul , rev_mul ] <NEWLINE> return val <NEWLINE> <NL> <NL> <DEDENT> def dfs2 ( v , p , a ) : <NEWLINE> <INDENT> dp [ v ] = dp [ v ] * a % m <NEWLINE> pmv = pre_muls [ v ] <NEWLINE> for i , c in enumerate ( links [ v ] ) : <NEWLINE> <INDENT> if c == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pmc = pmv [ 0 ] [ i ] * pmv [ 1 ] [ i + 1 ] % m <NEWLINE> pmc = pmc * a % m <NEWLINE> dfs2 ( c , v , pmc + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> links = [ [ ] for _ in range ( n ) ] <NEWLINE> dp = [ 0 for _ in range ( n ) ] <NEWLINE> pre_muls = [ None for _ in range ( n ) ] <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x , y = map ( int , line . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> links [ x ] . append ( y ) <NEWLINE> links [ y ] . append ( x ) <NEWLINE> <DEDENT> dfs1 ( 0 , None ) <NEWLINE> dfs2 ( 0 , None , 1 ) <NEWLINE> print ( <STRING> . join ( map ( str , dp ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans_box = dict ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = sorted ( map ( str , input ( ) ) ) <NEWLINE> if <STRING> . join ( s ) in ans_box . keys ( ) : <NEWLINE> <INDENT> ans_box [ <STRING> . join ( s ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_box [ <STRING> . join ( s ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for key , value in ans_box . items ( ) : <NEWLINE> <INDENT> if value == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += value * ( value - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( int ( 10 ** 9 ) ) <NEWLINE> n , m = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> edges = collections . defaultdict ( list ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , d = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> edges [ s - 1 ] . append ( d - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> maxPath = 0 <NEWLINE> @ lru_cache ( None ) <NEWLINE> def dfs ( node ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in edges [ node ] : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i ) + 1 ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> maxPath = max ( dfs ( i ) , maxPath ) <NEWLINE> <DEDENT> print ( maxPath ) <NEWLINE>
def iwa_check ( start , end ) : <NEWLINE> <INDENT> for i in range ( start , end ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s = [ <STRING> ] + s + [ <STRING> ] <NEWLINE> <NL> <COMMENT> <NL> if not iwa_check ( a , c ) or not iwa_check ( b , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if c > d : <NEWLINE> <INDENT> ok = False <NEWLINE> for i in range ( b , d + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ok = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> from bisect import bisect_left <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> ab = l [ i ] + l [ j ] <NEWLINE> idx = bisect_left ( l , ab ) <NEWLINE> ans += max ( 0 , idx - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> a , b , x = I ( ) <NEWLINE> <NL> if ( a ** 2 * b ) <= 2 * x : <NEWLINE> <INDENT> c = 2 * ( a ** 2 * b - x ) / a ** 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ( a * b ** 2 ) / ( 2 * x ) <NEWLINE> <NL> <DEDENT> print ( math . degrees ( math . atan ( c ) ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def f ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> cnt += ( A [ k ] < A [ i ] + A [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = np . int32 ( input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( f ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> V = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( V [ i ] - C [ i ] ) > 0 : <NEWLINE> <INDENT> m = m + V [ i ] - C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( reduce ( math . gcd , A ) ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( L , L [ i ] + L [ j ] ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt2 = [ 0 ] * ( n ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cnt2 [ i ] = cnt2 [ i - 1 ] + cnt [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cnt2 [ r - 1 ] - cnt2 [ l - 1 ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in C : <NEWLINE> <INDENT> if C [ i ] > i : <NEWLINE> <INDENT> ans += C [ i ] - i <NEWLINE> <DEDENT> elif C [ i ] < i : <NEWLINE> <INDENT> ans += C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> <NL> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> sorted_A = sorted ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> idx = bisect_left ( sorted_A , A [ i ] ) <NEWLINE> if i % 2 != idx % 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import heapq <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for pull in range ( K + 1 ) : <NEWLINE> <INDENT> push = K - pull <NEWLINE> if push < 0 or push > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for left_push in range ( push + 1 ) : <NEWLINE> <INDENT> tmp_que = deque ( V ) <NEWLINE> tmp_heap = [ ] <NEWLINE> heapq . heapify ( tmp_heap ) <NEWLINE> right_push = push - left_push <NEWLINE> for _ in range ( left_push ) : <NEWLINE> <INDENT> heapq . heappush ( tmp_heap , tmp_que . popleft ( ) ) <NEWLINE> <DEDENT> for _ in range ( right_push ) : <NEWLINE> <INDENT> heapq . heappush ( tmp_heap , tmp_que . pop ( ) ) <NEWLINE> <NL> <DEDENT> tmp_res = sum ( tmp_que ) <NEWLINE> for i in range ( min ( push , pull ) ) : <NEWLINE> <INDENT> x = heapq . heappop ( tmp_heap ) <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> heapq . heappush ( tmp_heap , x ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> res = max ( res , sum ( tmp_heap ) ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> for k in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> d [ k ] += 1 <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ c ] += b <NEWLINE> <DEDENT> sm = 0 <NEWLINE> c = 0 <NEWLINE> <NL> for k , v in sorted ( d . items ( ) , reverse = True ) : <NEWLINE> <INDENT> if c + v < n : <NEWLINE> <INDENT> sm += k * v <NEWLINE> c += v <NEWLINE> <DEDENT> elif c + v == n : <NEWLINE> <INDENT> sm += k * v <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sm += k * ( n - c ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sm ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> m = P [ 0 ] <NEWLINE> for p in P : <NEWLINE> <INDENT> if m >= p : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> m = p <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> GCD = math . gcd ( N , M ) <NEWLINE> L = N * M // GCD <NEWLINE> <NL> dist_N = L // N <NEWLINE> dist_M = L // M <NEWLINE> <NL> <COMMENT> <NL> for i in range ( GCD ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = dist_M * i <NEWLINE> t = dist_N * i <NEWLINE> if S [ s ] != T [ t ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = L <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> zero = s . count ( <STRING> ) <NEWLINE> one = s . count ( <STRING> ) <NEWLINE> print ( len ( s ) - abs ( zero - one ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( input ( ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> dflag = 0 <NEWLINE> cmin = 0 <NEWLINE> cmax = h [ 0 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if h [ i - 1 ] < h [ i ] and dflag == 1 : <NEWLINE> <INDENT> count += cmax - cmin <NEWLINE> cmax = h [ i ] <NEWLINE> dflag = 0 <NEWLINE> cmin = h [ i - 1 ] <NEWLINE> <NL> <DEDENT> elif h [ i - 1 ] > h [ i ] : <NEWLINE> <INDENT> dflag = 1 <NEWLINE> <NL> <DEDENT> elif h [ i - 1 ] < h [ i ] : <NEWLINE> <INDENT> cmax = h [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if dflag == 1 : <NEWLINE> <INDENT> count += cmax - cmin <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += max ( cmax , h [ i ] ) - cmin <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def search ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> pos = deque ( [ ] ) <NEWLINE> <NL> D = [ [ True ] * ( W + 2 ) ] <COMMENT> <NEWLINE> D += [ [ True ] + [ False ] * W + [ True ] for i in range ( H ) ] <COMMENT> <NEWLINE> D . append ( [ True ] * ( W + 2 ) ) <COMMENT> <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> maze = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if maze [ j ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ i + 1 , j + 1 , 0 ] ) <NEWLINE> D [ i + 1 ] [ j + 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while len ( pos ) > 0 : <NEWLINE> <INDENT> h , w , depth = pos . popleft ( ) <NEWLINE> if not D [ h + 1 ] [ w ] : <NEWLINE> <INDENT> pos . append ( [ h + 1 , w , depth + 1 ] ) <NEWLINE> D [ h + 1 ] [ w ] = True <NEWLINE> <NL> <DEDENT> if not D [ h - 1 ] [ w ] : <NEWLINE> <INDENT> pos . append ( [ h - 1 , w , depth + 1 ] ) <NEWLINE> D [ h - 1 ] [ w ] = True <NEWLINE> <NL> <DEDENT> if not D [ h ] [ w + 1 ] : <NEWLINE> <INDENT> pos . append ( [ h , w + 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w + 1 ] = True <NEWLINE> <NL> <DEDENT> if not D [ h ] [ w - 1 ] : <NEWLINE> <INDENT> pos . append ( [ h , w - 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> print ( search ( ) ) <NEWLINE>
<COMMENT> <NL> from functools import * <NEWLINE> from math import * <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> gcds = [ ] <NEWLINE> lgcd = [ ] <NEWLINE> rgcd = [ 0 for _ in range ( n ) ] <NEWLINE> l = r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> l = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = gcd ( l , a [ i - 1 ] ) <NEWLINE> <DEDENT> lgcd . append ( l ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> r = 0 <NEWLINE> rgcd [ n - 1 ] = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = gcd ( r , a [ n - i ] ) <NEWLINE> rgcd [ n - i - 1 ] = r <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> g = gcd ( lgcd [ i ] , rgcd [ i ] ) <NEWLINE> gcds . append ( g ) <NEWLINE> <NL> <DEDENT> print ( max ( gcds ) ) <NEWLINE>
import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dics = [ { } for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ky = r - 1 <NEWLINE> if ky in dics [ l - 1 ] : <NEWLINE> <INDENT> if c < dics [ l - 1 ] [ ky ] : <NEWLINE> <INDENT> dics [ l - 1 ] [ ky ] = c <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dics [ l - 1 ] [ ky ] = c <NEWLINE> <DEDENT> <DEDENT> dist = [ float ( <STRING> ) ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> hq = [ ] <NEWLINE> heapq . heappush ( hq , [ 0 , 0 ] ) <NEWLINE> idx = 0 <NEWLINE> while len ( hq ) > 0 : <NEWLINE> <INDENT> v , p = heapq . heappop ( hq ) <NEWLINE> if p < idx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if p == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( idx + 1 , p ) : <NEWLINE> <INDENT> if len ( dics [ i ] ) > 0 : <NEWLINE> <INDENT> for ky in dics [ i ] . keys ( ) : <NEWLINE> <INDENT> if ky in dics [ p ] : <NEWLINE> <INDENT> if dics [ p ] [ ky ] > dics [ i ] [ ky ] : <NEWLINE> <INDENT> dics [ p ] [ ky ] = dics [ i ] [ ky ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p < ky : <NEWLINE> <INDENT> dics [ p ] [ ky ] = dics [ i ] [ ky ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> idx = p <NEWLINE> for r in dics [ p ] . keys ( ) : <NEWLINE> <INDENT> if dist [ r ] > v + dics [ p ] [ r ] : <NEWLINE> <INDENT> dist [ r ] = v + dics [ p ] [ r ] <NEWLINE> heapq . heappush ( hq , [ v + dics [ p ] [ r ] , r ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dist [ n - 1 ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s + <STRING> <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 1 << 31 <NEWLINE> dist = np . array ( [ [ INF for _ in range ( N ) ] for _ in range ( N ) ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dist [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> dist [ a ] [ b ] = c <NEWLINE> dist [ b ] [ a ] = c <NEWLINE> <NL> <DEDENT> dist = floyd_warshall ( dist ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if dist [ i ] [ j ] <= L : <NEWLINE> <INDENT> dist [ i ] [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dist [ i ] [ j ] = INF <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dist = floyd_warshall ( dist ) <NEWLINE> dist [ dist == INF ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> Q = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * Q <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> t -= 1 <NEWLINE> ans [ q ] = int ( dist [ s ] [ t ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> attend = [ 0 ] * n <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> attend [ j - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * attend ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import bisect <NEWLINE> A , B , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> S = [ - INF ] + [ int ( input ( ) ) for i in range ( A ) ] + [ INF ] <NEWLINE> T = [ - INF ] + [ int ( input ( ) ) for i in range ( B ) ] + [ INF ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> i = bisect . bisect_right ( S , x ) <NEWLINE> j = bisect . bisect_right ( T , x ) <NEWLINE> d = INF <NEWLINE> for s in [ S [ i - 1 ] , S [ i ] ] : <NEWLINE> <INDENT> for t in [ T [ j - 1 ] , T [ j ] ] : <NEWLINE> <INDENT> d1 = abs ( s - x ) + abs ( s - t ) <NEWLINE> d2 = abs ( t - x ) + abs ( s - t ) <NEWLINE> d = min ( d , d1 , d2 ) <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = sum ( A ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += A [ 0 ] <NEWLINE> A [ 0 ] *= 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> T = tuple ( map ( int , input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> a = i // 100 <NEWLINE> b = ( i // 10 ) % 10 <NEWLINE> c = i % 10 <NEWLINE> flag1 = False <NEWLINE> flag2 = False <NEWLINE> flag3 = False <NEWLINE> for t in T : <NEWLINE> <INDENT> if flag2 : <NEWLINE> <INDENT> if t == c : <NEWLINE> <INDENT> flag3 = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag1 : <NEWLINE> <INDENT> if t == b : <NEWLINE> <INDENT> flag2 = True <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if t == a : <NEWLINE> <INDENT> flag1 = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> a = set ( a ) <NEWLINE> d = [ 1 ] + [ 1 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> d [ i + 1 ] = d [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + 1 ] = d [ i ] + d [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d [ n ] % 1000000007 ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> k = min ( k , n ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] * n <NEWLINE> kn = np . arange ( 1 , k ) <NEWLINE> h0 = h [ 0 ] <NEWLINE> c0 = c [ 0 ] <NEWLINE> for ( ii , hii ) in zip ( kn , h [ 1 : k ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> cii = c0 + abs ( hii - h0 ) <NEWLINE> for ( cjj , hjj ) in zip ( c [ 1 : ii ] , h [ 1 : ii ] ) : <NEWLINE> <INDENT> if cii > cjj : <NEWLINE> <COMMENT> <NL> <INDENT> if hii == hjj : <NEWLINE> <COMMENT> <NL> <INDENT> cii = cjj <NEWLINE> <DEDENT> elif hii > hjj : <NEWLINE> <INDENT> if cii > cjj + hii - hjj : <NEWLINE> <INDENT> cii = cjj + hii - hjj <NEWLINE> <DEDENT> <DEDENT> elif cii > cjj - hii + hjj : <NEWLINE> <INDENT> cii = cjj - hii + hjj <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c [ ii ] = cii <NEWLINE> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> kn = np . arange ( k , n ) <NEWLINE> for ( ii , hii , hiik ) in zip ( kn , h [ k : n ] , h [ 0 : n - k ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> cii = c [ ii - k ] + abs ( hii - hiik ) <NEWLINE> for ( cjj , hjj ) in zip ( c [ ii - k + 1 : ii ] , h [ ii - k + 1 : ii ] ) : <NEWLINE> <INDENT> if cii > cjj : <NEWLINE> <COMMENT> <NL> <INDENT> if hii == hjj : <NEWLINE> <COMMENT> <NL> <INDENT> cii = cjj <NEWLINE> <DEDENT> elif hii > hjj : <NEWLINE> <INDENT> if cii > cjj + hii - hjj : <NEWLINE> <INDENT> cii = cjj + hii - hjj <NEWLINE> <DEDENT> <DEDENT> elif cii > cjj - hii + hjj : <NEWLINE> <INDENT> cii = cjj - hii + hjj <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c [ ii ] = cii <NEWLINE> <COMMENT> <NL> <DEDENT> print ( c [ n - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> left = s [ 0 ] <NEWLINE> ans = 10 ** 6 <NEWLINE> left = { } <NEWLINE> left . setdefault ( <STRING> , 0 ) <NEWLINE> left . setdefault ( <STRING> , 0 ) <NEWLINE> right = { } <NEWLINE> right . setdefault ( <STRING> , 0 ) <NEWLINE> right . setdefault ( <STRING> , 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> right [ s [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 10 ** 6 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> right [ s [ i ] ] -= 1 <NEWLINE> ans = min ( ans , left [ <STRING> ] + right [ <STRING> ] ) <NEWLINE> <COMMENT> <NL> left [ s [ i ] ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ str ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> n = h * w <NEWLINE> <NL> def Find ( x , par ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = Find ( par [ x ] , par ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def Unite ( x , y , par , rank ) : <NEWLINE> <INDENT> x = Find ( x , par ) <NEWLINE> y = Find ( y , par ) <NEWLINE> <NL> if x != y : <NEWLINE> <INDENT> if rank [ x ] < rank [ y ] : <NEWLINE> <INDENT> par [ y ] += par [ x ] <NEWLINE> par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def Same ( x , y , par ) : <NEWLINE> <INDENT> return Find ( x , par ) == Find ( y , par ) <NEWLINE> <NL> <DEDENT> def Size ( x , par ) : <NEWLINE> <INDENT> return - par [ Find ( x , par ) ] <NEWLINE> <NL> <DEDENT> par = [ - 1 ] * n <NEWLINE> rank = [ 0 ] * n <NEWLINE> <NL> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> idx1 = y * w + x <NEWLINE> for dy , dx in ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < h and 0 <= nx < w : <NEWLINE> <INDENT> idx2 = ny * w + nx <NEWLINE> if S [ y ] [ x ] != S [ ny ] [ nx ] : <NEWLINE> <INDENT> Unite ( idx1 , idx2 , par , rank ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> X = [ [ 0 , 0 ] for _ in range ( n ) ] <NEWLINE> K = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> y , x = divmod ( i , w ) <NEWLINE> if par [ i ] < 0 : <NEWLINE> <INDENT> K . append ( i ) <NEWLINE> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> X [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ i ] [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> X [ Find ( i , par ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ Find ( i , par ) ] [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in K : <NEWLINE> <INDENT> ans += X [ k ] [ 0 ] * X [ k ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> paths = [ [ ] for i in range ( N ) ] <NEWLINE> longest_paths = [ - 1 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> def get_longest ( node ) : <NEWLINE> <INDENT> if longest_paths [ node ] != - 1 : <NEWLINE> <INDENT> return longest_paths [ node ] <NEWLINE> <DEDENT> if paths [ node ] == [ ] : <NEWLINE> <INDENT> longest_paths [ node ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = max ( [ get_longest ( nd ) for nd in paths [ node ] ] ) + 1 <NEWLINE> longest_paths [ node ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( [ get_longest ( i ) for i in range ( N ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * 9 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> aa = int ( A [ i ] / 400 ) <NEWLINE> if aa > 8 : <NEWLINE> <INDENT> aa = 8 <NEWLINE> <DEDENT> ans [ aa ] += 1 <NEWLINE> <NL> <DEDENT> min_a = 0 <NEWLINE> max_a = 0 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> if i != 8 : <NEWLINE> <INDENT> if ans [ i ] != 0 : <NEWLINE> <INDENT> min_a += 1 <NEWLINE> max_a += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max_a += ans [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> min_a = max ( min_a , 1 ) <NEWLINE> print ( min_a , max_a ) <NEWLINE> <NL> <NL> <NL>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A . add ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> if 1 in A : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if i + 2 in A : <NEWLINE> <INDENT> dp [ i + 2 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 2 ] = ( dp [ i ] + dp [ i + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b < 0 : <NEWLINE> <INDENT> S = ( b - a + 1 ) % 2 <NEWLINE> if S == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
b = input ( ) <NEWLINE> d = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> print ( d [ b ] ) <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> dp = np . full ( 10 ** 5 + 1 , W + 1 , dtype = int ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> np . minimum ( dp [ : - v ] + w , dp [ v : ] , out = dp [ v : ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( dp ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if dp [ i ] <= W : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> reverse_v = v [ : : - 1 ] <NEWLINE> lst = [ 0 ] * ( k + 1 ) <NEWLINE> left = [ [ ] ] <NEWLINE> right = [ [ ] ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> left . append ( v [ : i ] ) <NEWLINE> right . append ( reverse_v [ : i ] ) <NEWLINE> <NL> <DEDENT> for cnt in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> rest = k - cnt <NEWLINE> total = 0 <NEWLINE> if cnt <= n : <NEWLINE> <INDENT> for j in range ( cnt + 1 ) : <NEWLINE> <INDENT> lst_j = left [ j ] + right [ cnt - j ] <NEWLINE> lst_j . sort ( ) <NEWLINE> l = cnt <NEWLINE> for idx in range ( cnt ) : <NEWLINE> <INDENT> if lst_j [ idx ] >= 0 : <NEWLINE> <INDENT> l = idx <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if l == cnt : <NEWLINE> <INDENT> value = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = min ( l , rest ) <NEWLINE> value = sum ( lst_j [ flg : ] ) <NEWLINE> <DEDENT> if value > total : <NEWLINE> <INDENT> total = value <NEWLINE> <DEDENT> <DEDENT> lst [ cnt ] = total <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( lst ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> XY = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> dXY = Counter ( [ ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> dXY += Counter ( [ str ( XY [ i ] [ 0 ] - XY [ j ] [ 0 ] ) + <STRING> + str ( XY [ i ] [ 1 ] - XY [ j ] [ 1 ] ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - dXY . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> x = ab [ 0 ] [ 0 ] <NEWLINE> y = ab [ 0 ] [ 1 ] <NEWLINE> j = 1 <NEWLINE> flg = True <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> xx = ab [ i ] [ 0 ] <NEWLINE> yy = ab [ i ] [ 1 ] <NEWLINE> j = max ( x // xx , y // yy ) <NEWLINE> while flg : <NEWLINE> <INDENT> if x > j * xx or y > j * yy : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = xx * j <NEWLINE> y = yy * j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x + y ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ deque ( [ ] ) for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> a = [ 0 ] * - ~ n <NEWLINE> b = [ True ] * - ~ n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ p ] += x <NEWLINE> <NL> <DEDENT> d = deque ( [ 1 ] ) <NEWLINE> b [ 1 ] = False <NEWLINE> <NL> while len ( d ) : <NEWLINE> <INDENT> p = d . popleft ( ) <NEWLINE> for i in graph [ p ] : <NEWLINE> <INDENT> if b [ i ] : <NEWLINE> <INDENT> a [ i ] += a [ p ] <NEWLINE> b [ i ] = False <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a [ 1 : ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = Counter ( <STRING> . join ( input ( ) for _ in range ( h ) ) ) <NEWLINE> <NL> center = h * w % 2 <NEWLINE> side = ( h // 2 ) * ( w % 2 ) + ( w // 2 ) * ( h % 2 ) <NEWLINE> corner = ( h // 2 ) * ( w // 2 ) <NEWLINE> <NL> for _ in range ( center ) : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for _ in range ( side ) : <NEWLINE> <INDENT> for j in a : <NEWLINE> <INDENT> if a [ j ] % 4 == 2 : <NEWLINE> <INDENT> a [ j ] -= 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if sum ( a [ i ] % 4 for i in a ) == 0 else <STRING> ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> n , k = I ( ) <NEWLINE> h = l ( ) <NEWLINE> h . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( h [ k : ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 9 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> adj_list = [ [ ] for _ in range ( N ) ] <NEWLINE> counter = [ 0 for _ in range ( N ) ] <NEWLINE> reached = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> adj_list [ a ] . append ( b ) <NEWLINE> adj_list [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def df ( current , score ) : <NEWLINE> <INDENT> next_nodes = adj_list [ current ] <NEWLINE> reached [ current ] = 1 <NEWLINE> for node in next_nodes : <NEWLINE> <INDENT> if reached [ node ] == 0 : <NEWLINE> <INDENT> counter [ node ] += score <NEWLINE> df ( node , counter [ node ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <DEDENT> df ( 0 , counter [ 0 ] ) <NEWLINE> print ( * counter ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> if b == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 20 ) : <NEWLINE> <INDENT> if b <= a + ( a - 1 ) * i : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = [ - 1 for i in range ( n ) ] <NEWLINE> e = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> e [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> def dfs ( cur , par , di ) : <NEWLINE> <INDENT> d [ cur ] = di <NEWLINE> for i in e [ cur ] : <NEWLINE> <INDENT> if d [ i [ 0 ] ] == - 1 : <NEWLINE> <INDENT> if i == par : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i [ 0 ] , cur , di + i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( k - 1 , - 1 , 0 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( d [ x - 1 ] + d [ y - 1 ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ - 1 , - 10 ** 11 ] , [ - 1 , 10 ** 11 ] ] <NEWLINE> aa = [ - 10 ** 11 , 10 ** 11 ] <NEWLINE> bb = [ - 10 ** 11 , 10 ** 11 ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ab . append ( [ 0 , x ] ) <NEWLINE> aa . append ( x ) <NEWLINE> <NL> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ab . append ( [ 1 , x ] ) <NEWLINE> bb . append ( x ) <NEWLINE> <DEDENT> ab = sorted ( ab , key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) <NEWLINE> aa . sort ( ) <NEWLINE> bb . sort ( ) <NEWLINE> <NL> ab_arr = np . array ( ab ) <NEWLINE> ab_arr = ab_arr . T [ 1 ] <NEWLINE> <NL> a_arr = np . array ( aa ) <NEWLINE> b_arr = np . array ( bb ) <NEWLINE> <NL> for cq in range ( q ) : <NEWLINE> <INDENT> ans = 10 ** 12 <NEWLINE> s = int ( input ( ) ) <NEWLINE> ci = np . searchsorted ( ab_arr , s ) <NEWLINE> for cj in [ ci , ci - 1 ] : <NEWLINE> <INDENT> d = abs ( ab_arr [ cj ] - s ) <NEWLINE> flg = ab [ cj ] [ 0 ] <NEWLINE> if flg : <NEWLINE> <INDENT> na = np . searchsorted ( a_arr , ab_arr [ cj ] ) <NEWLINE> d2 = min ( abs ( a_arr [ na ] - ab_arr [ cj ] ) , abs ( a_arr [ na - 1 ] - ab_arr [ cj ] ) ) <NEWLINE> d += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nb = np . searchsorted ( b_arr , ab_arr [ cj ] ) <NEWLINE> d2 = min ( abs ( b_arr [ nb ] - ab_arr [ cj ] ) , abs ( b_arr [ nb - 1 ] - ab_arr [ cj ] ) ) <NEWLINE> d += d2 <NEWLINE> <DEDENT> ans = min ( ans , d ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> R , G , B , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> bingo = 0 <NEWLINE> <NL> for r in range ( N + 1 ) : <NEWLINE> <INDENT> if R * r > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for g in range ( N + 1 ) : <NEWLINE> <INDENT> b = ( N - ( R * r + G * g ) ) // B <NEWLINE> if b < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif R * r + G * g + B * b == N : <NEWLINE> <INDENT> bingo += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( bingo ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> reject = 0 <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> if ans >= N : <NEWLINE> <INDENT> reject = ans - N <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if j != reject : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ca = collections . Counter ( aa ) <NEWLINE> la = sorted ( [ a for a in ca . items ( ) ] , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> list1 = [ ] <NEWLINE> list2 = [ ] <NEWLINE> <NL> for a in la : <NEWLINE> <INDENT> if a [ 1 ] > 1 : <NEWLINE> <INDENT> list1 . append ( a ) <NEWLINE> <DEDENT> if a [ 1 ] > 3 : <NEWLINE> <INDENT> list2 . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( list1 ) > 1 : <NEWLINE> <INDENT> xr = list1 [ 0 ] [ 0 ] * list1 [ 1 ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xr = 0 <NEWLINE> <NL> <DEDENT> if len ( list2 ) > 0 : <NEWLINE> <INDENT> xs = list2 [ 0 ] [ 0 ] * list2 [ 0 ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xs = 0 <NEWLINE> <NL> <DEDENT> ans = max ( xr , xs ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
S = list ( map ( str , input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> num = [ - 1 ] * ( len ( S ) + 1 ) <NEWLINE> index0 = list ( ) <NEWLINE> than = 0 <COMMENT> <NEWLINE> <COMMENT> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> if ( than == 0 ) : <NEWLINE> <INDENT> num [ i ] = 0 <NEWLINE> index0 . append ( i ) <NEWLINE> <DEDENT> than = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> than = 0 <NEWLINE> <DEDENT> <DEDENT> if ( S [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> num [ - 1 ] = 0 <NEWLINE> index0 . append ( len ( S ) + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> if ( index0 [ 0 ] == 0 ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> num [ i ] = num [ i - 1 ] + 1 <NEWLINE> if ( i >= len ( S ) ) : break <NEWLINE> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> index0 . pop ( 0 ) <NEWLINE> <DEDENT> if ( len ( index0 ) > 0 ) : <NEWLINE> <INDENT> if ( index0 [ - 1 ] == len ( S ) + 1 ) : <NEWLINE> <INDENT> i = len ( S ) - 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> num [ i ] = num [ i + 1 ] + 1 <NEWLINE> i -= 1 <NEWLINE> if ( i < 0 ) : break <NEWLINE> if ( S [ i ] == <STRING> ) : break <NEWLINE> <DEDENT> index0 . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> while ( len ( index0 ) > 0 ) : <NEWLINE> <INDENT> for i in reversed ( range ( 0 , index0 [ 0 ] ) ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num [ i ] = max ( num [ i ] , num [ i + 1 ] + 1 ) <NEWLINE> <DEDENT> for i in range ( index0 [ 0 ] + 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> num [ i ] = max ( num [ i ] , num [ i - 1 ] + 1 ) <NEWLINE> if ( i >= len ( S ) ) : break <NEWLINE> if ( S [ i ] == <STRING> ) : break <NEWLINE> <DEDENT> index0 . pop ( 0 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> ans += num [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> def c ( P1 , P2 , P3 ) : <NEWLINE> <INDENT> x1 , y1 = P1 ; x2 , y2 = P2 ; x3 , y3 = P3 <NEWLINE> a = 2 * ( x1 - x2 ) ; b = 2 * ( y1 - y2 ) ; p = x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2 <NEWLINE> c = 2 * ( x1 - x3 ) ; d = 2 * ( y1 - y3 ) ; q = x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2 <NEWLINE> det = a * d - b * c <NEWLINE> x = d * p - b * q ; y = a * q - c * p <NEWLINE> if det < 0 : <NEWLINE> <INDENT> x = - x ; y = - y ; det = - det <NEWLINE> <DEDENT> if det != 0 : <NEWLINE> <INDENT> x /= det ; y /= det <NEWLINE> <DEDENT> r = ( ( x - x1 ) ** 2 + ( y - y1 ) ** 2 ) ** 0.5 <NEWLINE> return x , y , r <NEWLINE> <NL> <DEDENT> ans = ( 200000 ) ** 2 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> x1 , y1 = A [ i ] [ 0 ] , A [ i ] [ 1 ] <NEWLINE> x2 , y2 = A [ j ] [ 0 ] , A [ j ] [ 1 ] <NEWLINE> x , y = ( x1 + x2 ) / 2 , ( y1 + y2 ) / 2 <NEWLINE> r = ( ( x1 - x ) ** 2 + ( y1 - y ) ** 2 ) ** 0.5 <NEWLINE> for a , b in A : <NEWLINE> <INDENT> d = ( ( a - x ) ** 2 + ( b - y ) ** 2 ) ** 0.5 <NEWLINE> if d > r : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> ans = min ( ans , r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> f = 0 <NEWLINE> <NL> if N > 2 : <NEWLINE> <INDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> x , y , r = c ( A [ i ] , A [ j ] , A [ k ] ) <NEWLINE> if r > 0 : <NEWLINE> <INDENT> for a , b in A : <NEWLINE> <INDENT> d = ( ( a - x ) ** 2 + ( b - y ) ** 2 ) ** 0.5 <NEWLINE> if d > r : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> ans = min ( ans , r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> visited = [ False for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( n , count ) : <NEWLINE> <COMMENT> <NL> <INDENT> if count == 3 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n == N : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> visited [ n ] = True <NEWLINE> <NL> for edge in edges [ n ] : <NEWLINE> <INDENT> if visited [ edge ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dfs ( edge , count + 1 ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> print ( <STRING> if dfs ( 1 , 0 ) else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> F = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> F [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> P = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> P [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = - 10 ** 10 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , 2 ** 10 ) : <COMMENT> <NEWLINE> <INDENT> open_n = [ 0 ] * N <NEWLINE> profit = 0 <NEWLINE> for j in range ( 10 ) : <COMMENT> <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <COMMENT> <NEWLINE> <INDENT> for k in range ( N ) : <COMMENT> <NEWLINE> <INDENT> if F [ k ] [ j ] == 1 : <NEWLINE> <INDENT> open_n [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for l in range ( N ) : <NEWLINE> <INDENT> profit += P [ l ] [ open_n [ l ] ] <NEWLINE> <DEDENT> if ans < profit : <NEWLINE> <INDENT> ans = profit <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> inf = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> alst = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> work = [ inf ] * n <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> j = bisect_right ( work , alst [ i ] ) <NEWLINE> work [ j ] = alst [ i ] <NEWLINE> <DEDENT> print ( n - work . count ( inf ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ u - 1 ] . append ( v - 1 ) <NEWLINE> <NL> <DEDENT> S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> S -= 1 <NEWLINE> T -= 1 <NEWLINE> <NL> from collections import deque <NEWLINE> q = deque ( [ ] ) <NEWLINE> q . append ( [ S , 0 , 0 ] ) <NEWLINE> <NL> seen = [ [ False ] * 3 for i in range ( N ) ] <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v , cost , step = q . popleft ( ) <NEWLINE> if seen [ v ] [ step ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ v ] [ step ] = True <NEWLINE> if step == 0 : <NEWLINE> <INDENT> if v == T : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> break <NEWLINE> <DEDENT> cost += 1 <NEWLINE> step = 3 <NEWLINE> <DEDENT> for u in graph [ v ] : <NEWLINE> <INDENT> q . append ( [ u , cost , step - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from itertools import permutations <NEWLINE> <NL> N , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( C ) ] <NEWLINE> <COMMENT> <NL> <NL> colors = [ [ 0 ] * C for i in range ( 3 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j , color in enumerate ( tmp ) : <NEWLINE> <INDENT> num = ( ( i + 1 ) + ( j + 1 ) ) % 3 <NEWLINE> colors [ num ] [ color - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> data = [ [ 0 ] * C for i in range ( 3 ) ] <NEWLINE> <NL> <NL> for i in range ( 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( C ) : <NEWLINE> <INDENT> for k in range ( C ) : <NEWLINE> <INDENT> data [ i ] [ k ] += colors [ i ] [ j ] * D [ j ] [ k ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 10 ** 10 <NEWLINE> for iter_ in permutations ( list ( range ( C ) ) , 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = [ ] <NEWLINE> for i , j in enumerate ( iter_ ) : <NEWLINE> <INDENT> tmp . append ( data [ i ] [ j ] ) <NEWLINE> <DEDENT> ans = min ( ans , sum ( tmp ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> arr = np . array ( A ) <NEWLINE> <NL> <NL> print ( <STRING> . join ( map ( str , np . argsort ( arr ) + 1 ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> tn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_dict = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if str ( dn [ i ] ) in num_dict . keys ( ) : <NEWLINE> <INDENT> num_dict [ str ( dn [ i ] ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_dict [ str ( dn [ i ] ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if str ( tn [ i ] ) in num_dict . keys ( ) : <NEWLINE> <INDENT> num_dict [ str ( tn [ i ] ) ] += - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> result_list = list ( num_dict . values ( ) ) <NEWLINE> for i in range ( len ( result_list ) ) : <NEWLINE> <INDENT> if result_list [ i ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> flag = True <NEWLINE> i = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> if i == len ( s ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != <STRING> : <NEWLINE> <INDENT> res = s [ i ] <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if k > i : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> c = sorted ( [ R , G , B ] ) <NEWLINE> R = c [ 1 ] <NEWLINE> G = c [ 2 ] <NEWLINE> B = c [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> tmp = N - r * R <NEWLINE> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> ttmp = tmp - g * G <NEWLINE> ans += ( ttmp % B == 0 and ttmp >= 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> val = sorted ( input ( ) ) <NEWLINE> s . append ( val ) <NEWLINE> <NL> <DEDENT> an = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if len ( s [ an ] ) <= len ( s [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> an = i <NEWLINE> <NL> <DEDENT> <DEDENT> a = s [ an ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> while a != s [ i ] and n < len ( a ) and n < len ( s [ i ] ) : <NEWLINE> <INDENT> if a [ n ] == s [ i ] [ n ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ n ] > s [ i ] [ n ] : <NEWLINE> <INDENT> s [ i ] . pop ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . pop ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( a ) > len ( s [ i ] ) : <NEWLINE> <INDENT> a = s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from scipy . special import comb <NEWLINE> import copy <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def zz ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def z ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def S ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def C ( line ) : <NEWLINE> <INDENT> return [ sys . stdin . readline ( ) for _ in range ( line ) ] <NEWLINE> <NL> <NL> <DEDENT> N = z ( ) <NEWLINE> S = S ( ) <NEWLINE> after_lis = [ set ( ) for _ in range ( N + 1 ) ] <NEWLINE> i = N - 1 <NEWLINE> for s in reversed ( S ) : <NEWLINE> <INDENT> after_lis [ i ] = ( after_lis [ i ] | after_lis [ i + 1 ] ) <NEWLINE> after_lis [ i ] . add ( int ( s ) ) <NEWLINE> i -= 1 <NEWLINE> <NL> <DEDENT> left_index = { } <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s not in left_index : <NEWLINE> <INDENT> left_index [ s ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> ans_lis = np . zeros ( [ 10 , 10 , 10 ] , dtype = np . int32 ) <NEWLINE> <NL> for char in left_index : <NEWLINE> <INDENT> s_100 = int ( char ) <NEWLINE> for i_10 in range ( left_index [ char ] + 1 , N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> s_10 = int ( S [ i_10 ] ) <NEWLINE> ans_lis [ s_100 , s_10 , list ( after_lis [ i_10 + 1 ] ) ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( np . sum ( ans_lis ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if s == <STRING> * len ( s ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> idx = i <NEWLINE> num = s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if idx >= k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
<NL> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <NL> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( ans [ lr [ i ] [ 1 ] ] - ans [ lr [ i ] [ 0 ] ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> h . sort ( key = lambda x : - x [ 2 ] ) <NEWLINE> hmax = h [ 0 ] [ 2 ] + abs ( i - h [ 0 ] [ 0 ] ) + abs ( j - h [ 0 ] [ 1 ] ) <NEWLINE> for k in range ( 1 , n ) : <NEWLINE> <NL> <INDENT> if max ( hmax - abs ( h [ k ] [ 0 ] - i ) - abs ( h [ k ] [ 1 ] - j ) , 0 ) != h [ k ] [ 2 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ i , j , hmax ] <NEWLINE> <NL> <DEDENT> if ( len ( ans ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( len ( ans ) ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = map ( str , ans ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> num = len ( s ) <NEWLINE> a = [ 0 ] * ( num + 1 ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> if s [ i ] is <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = max ( a [ i + 1 ] , a [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if s [ - i ] is <STRING> : <NEWLINE> <INDENT> a [ - ( i + 1 ) ] = max ( a [ - ( i + 1 ) ] , a [ - i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s . rfind ( <STRING> ) + 1 - s . find ( <STRING> ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> ans [ 0 ] = 1 <NEWLINE> if 1 not in a : ans [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : continue <NEWLINE> ans [ i ] = ans [ i - 1 ] + ans [ i - 2 ] <NEWLINE> <DEDENT> print ( ans [ - 1 ] % mod ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> mn = 10 ** 10 <NEWLINE> cal = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <NL> <INDENT> cal = ( ( i % 2019 ) * ( j % 2019 ) ) % 2019 <NEWLINE> if cal < mn : <NEWLINE> <INDENT> mn = cal <NEWLINE> <DEDENT> if cal == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> ans = [ 100 ] * 26 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = [ 0 ] * 26 <NEWLINE> for s in S [ i ] : <NEWLINE> <INDENT> key = ord ( s ) - ord ( <STRING> ) <NEWLINE> if tmp [ key ] < ans [ key ] : <NEWLINE> <INDENT> tmp [ key ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = tmp . copy ( ) <NEWLINE> <NL> <DEDENT> res = <STRING> <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> res += chr ( ord ( <STRING> ) + i ) * tmp [ i ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Plot = [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> X = [ p [ 0 ] for p in Plot ] <NEWLINE> Y = [ p [ 1 ] for p in Plot ] <NEWLINE> X . sort ( ) <NEWLINE> Y . sort ( ) <NEWLINE> <COMMENT> <NL> ans = 10e20 <NEWLINE> from itertools import combinations <NEWLINE> for x1 , x2 in combinations ( X , 2 ) : <NEWLINE> <INDENT> for y1 in Y : <NEWLINE> <INDENT> y2 = [ y for x , y in Plot if x1 <= x <= x2 and y1 <= y ] <NEWLINE> if len ( y2 ) < K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> y2 . sort ( ) <NEWLINE> S = ( x2 - x1 ) * ( y2 [ K - 1 ] - y1 ) <NEWLINE> ans = min ( ans , S ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> a += int ( n [ i ] ) <NEWLINE> <DEDENT> print ( [ <STRING> , <STRING> ] [ min ( int ( n ) % a , 1 ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> height = h [ 0 ] <NEWLINE> <NL> q = 0 <NEWLINE> <NL> for i in h : <NEWLINE> <INDENT> if i < height : <NEWLINE> <INDENT> q = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif i > height : <NEWLINE> <INDENT> height = i - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> height = i <NEWLINE> <NL> <DEDENT> <DEDENT> if q == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> SA = list ( range ( A , min ( B , A + K ) ) ) <NEWLINE> SB = list ( range ( max ( A , B - K + 1 ) , B + 1 ) ) <NEWLINE> <NL> ans = sorted ( set ( SA + SB ) ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> P = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P [ i ] = int ( P [ i ] * ( 1 + P [ i ] ) / 2 ) / P [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += P [ i ] <NEWLINE> if i < K - 1 : continue <NEWLINE> ans = max ( tmp , ans ) <NEWLINE> tmp -= P [ i - K + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def Fib ( n ) : <NEWLINE> <INDENT> a , b = 0 , 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> if m > 1 : <NEWLINE> <INDENT> for i in range ( m - 1 ) : <NEWLINE> <INDENT> if a [ i + 1 ] - a [ i ] <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> return Fib ( n + 2 ) % 1000000007 <NEWLINE> <NL> <NL> <DEDENT> a = a + [ n ] <NEWLINE> l = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> l . append ( a [ i ] - a [ i - 1 ] - 1 ) <NEWLINE> <DEDENT> l = l + [ a [ - 1 ] - a [ - 2 ] ] <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= Fib ( i + 1 ) <NEWLINE> <NL> <DEDENT> return ans % 1000000007 <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rel = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> rel [ x - 1 ] . append ( y - 1 ) <NEWLINE> rel [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * n <NEWLINE> def hoge ( parent , pos ) : <NEWLINE> <INDENT> for i in rel [ pos ] : <NEWLINE> <INDENT> if ans [ i ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] = pos <NEWLINE> hoge ( pos , i ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] < 0 : <NEWLINE> <INDENT> hoge ( 0 , i ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for i in range ( N ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> root [ a ] . append ( b ) <NEWLINE> root [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visit = [ False ] * N <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> visit [ n ] = True <NEWLINE> for go in root [ n ] : <NEWLINE> <INDENT> if visit [ go ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ go ] += ans [ n ] <NEWLINE> dfs ( go ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> S = input ( ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> s_list = list ( S ) <NEWLINE> alpha_list = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> flag_list = [ False for _ in range ( 26 ) ] <NEWLINE> <NL> <NL> if len ( s_list ) == 26 : <NEWLINE> <INDENT> for i in range ( 25 , 0 , - 1 ) : <NEWLINE> <INDENT> if s_list [ i - 1 ] < s_list [ i ] : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> for j in range ( i , 26 ) : <NEWLINE> <INDENT> if s_list [ i - 1 ] < s_list [ j ] : <NEWLINE> <INDENT> c = min ( c , s_list [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( S [ : i - 1 ] + c ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i , alpha in enumerate ( alpha_list ) : <NEWLINE> <INDENT> if alpha in s_list : <NEWLINE> <INDENT> flag_list [ i ] = True <NEWLINE> <DEDENT> <DEDENT> for i , flag in enumerate ( flag_list ) : <NEWLINE> <INDENT> if not flag : <NEWLINE> <INDENT> print ( S + alpha_list [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> from math import gcd <NEWLINE> from operator import add , itemgetter , mul , xor <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> bunshi = 1 <NEWLINE> bunbo = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> bunbo = bunbo * ( i + 1 ) % mod <NEWLINE> bunshi = bunshi * ( n - i ) % mod <NEWLINE> <DEDENT> return ( bunshi * pow ( bunbo , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> n = I ( ) <NEWLINE> <NL> <COMMENT> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> prev_col = [ 0 ] * ( n + 1 ) <NEWLINE> a_b = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> a_b . append ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> check = [ - 1 ] * ( n + 1 ) <NEWLINE> check [ 0 ] = 0 <NEWLINE> check [ 1 ] = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> k = max ( len ( graph [ i ] ) , k ) <NEWLINE> <DEDENT> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> ans = dict ( ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> check [ v ] = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if check [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = cnt + 1 <NEWLINE> if prev_col [ v ] == cnt : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> prev_col [ i ] = cnt <NEWLINE> ans [ str ( min ( i , v ) ) + <STRING> + str ( max ( i , v ) ) ] = cnt <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE> for key in a_b : <NEWLINE> <INDENT> print ( ans [ key ] ) <NEWLINE> <DEDENT>
from sys import stdin , setrecursionlimit as srl <NEWLINE> from threading import stack_size <NEWLINE> srl ( int ( 1e9 ) + 7 ) <NEWLINE> stack_size ( int ( 1e8 ) ) <NEWLINE> <NL> def get ( i , value , vis ) : <NEWLINE> <INDENT> if vis [ i ] : <NEWLINE> <INDENT> return value [ i ] <NEWLINE> <DEDENT> vis [ i ] = True <NEWLINE> ans = 0 <NEWLINE> for j in adj [ i ] : <NEWLINE> <INDENT> ans = max ( ans , 1 + get ( j , value , vis ) ) <NEWLINE> <DEDENT> value [ i ] = ans <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> adj [ i ] = [ ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ x - 1 ] . append ( y - 1 ) <NEWLINE> <DEDENT> vis = [ False for i in range ( n ) ] <NEWLINE> value = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> value [ i ] = get ( i , value , vis ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> for i in value : <NEWLINE> <INDENT> x = max ( x , i ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - i - j <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> one_or_two = [ 0 ] + [ 1 ] + [ 2 ] + [ - 1 ] * n <NEWLINE> for i in range ( 3 , n + 3 ) : <NEWLINE> <INDENT> one_or_two [ i ] = ( one_or_two [ i - 1 ] + one_or_two [ i - 2 ] ) % mod <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> print ( one_or_two [ n ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> if a [ 0 ] > 1 : <NEWLINE> <INDENT> ans *= one_or_two [ a [ 0 ] - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> if a [ i ] - a [ i - 1 ] == 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a [ i ] - a [ i - 1 ] == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= one_or_two [ a [ i ] - a [ i - 1 ] - 2 ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if n - a [ - 1 ] > 1 : <NEWLINE> <INDENT> ans *= one_or_two [ n - a [ - 1 ] - 1 ] <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for i in range ( n ) ] <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( y - 1 ) <NEWLINE> edge [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ p - 1 ] += x <NEWLINE> <DEDENT> def dfs ( node , tmp ) : <NEWLINE> <INDENT> a [ node ] += tmp <NEWLINE> b [ node ] = 1 <NEWLINE> for i in edge [ node ] : <NEWLINE> <INDENT> if b [ i ] == 0 : <NEWLINE> <INDENT> dfs ( i , a [ node ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> print ( * a ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> tmp = list ( S ) <NEWLINE> tmp [ K - 1 ] = tmp [ K - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( tmp ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> C = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = input ( ) <NEWLINE> L = len ( S ) <NEWLINE> <NL> <NL> def dfs ( x , l ) : <NEWLINE> <INDENT> if l == L : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif l > L : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> match = S [ l : l + 7 ] <NEWLINE> for c in C : <NEWLINE> <INDENT> if match . find ( c ) == 0 : <NEWLINE> <INDENT> if dfs ( c , l + len ( c ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> if dfs ( <STRING> , 0 ) else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> i = 0 <NEWLINE> cnt = 1 <NEWLINE> cmpr = [ 0 ] <NEWLINE> while A [ i ] != 2 : <NEWLINE> <INDENT> if A [ i ] == i + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = A [ i ] - 1 <NEWLINE> cmpr . append ( i ) <NEWLINE> cnt += 1 <NEWLINE> if cnt > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> <COMMENT> <NL> d = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> d . append ( a [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> e = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] == n : <NEWLINE> <INDENT> e . append ( a [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( e ) & set ( d ) ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = n // 2019 <NEWLINE> b = m // 2019 <NEWLINE> if n * m % 2019 == 0 or b - a >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> best = 2018 <NEWLINE> for c in range ( n % 2019 , m % 2019 ) : <NEWLINE> <INDENT> for d in range ( c + 1 , m % 2019 + 1 ) : <NEWLINE> <INDENT> if c * d % 2019 < best : <NEWLINE> <INDENT> best = c * d % 2019 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( best ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cou = 0 <NEWLINE> <NL> if a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif a >= 0 and b <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cou = abs ( b - a ) + 1 <NEWLINE> if cou % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> mi = n + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mi = min ( mi , p [ i ] ) <NEWLINE> if mi == p [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( min ( i - L [ i ] + L [ N ] - L [ i + 1 ] for i in range ( N ) ) ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> ans += k - 1 - j <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> ij = i + j <NEWLINE> if ij > S : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( S - ij <= K ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> pos = [ [ ] for _ in range ( 26 ) ] <NEWLINE> <NL> len_s = len ( s ) <NEWLINE> len_t = len ( t ) <NEWLINE> <NL> <NL> for i in range ( len_s ) : <NEWLINE> <INDENT> idx = ord ( s [ i ] ) - 97 <NEWLINE> pos [ idx ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> tmp = - 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len_t ) : <NEWLINE> <INDENT> idx = ord ( t [ i ] ) - 97 <NEWLINE> if len ( pos [ idx ] ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if tmp < pos [ idx ] [ - 1 ] : <NEWLINE> <INDENT> l = - 1 <NEWLINE> r = len ( pos [ idx ] ) - 1 <NEWLINE> while l + 1 < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if pos [ idx ] [ mid ] <= tmp : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> ans . append ( pos [ idx ] [ r ] ) <NEWLINE> tmp = pos [ idx ] [ r ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans . append ( pos [ idx ] [ 0 ] ) <NEWLINE> tmp = pos [ idx ] [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt * len_s + ans [ - 1 ] + 1 ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> import bisect <COMMENT> <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( l , l [ i ] + l [ j ] ) - ( j + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> def solve ( n , a ) : <NEWLINE> <INDENT> d = Counter ( a ) <NEWLINE> if len ( d ) == 1 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> d_lst = list ( sorted ( d . keys ( ) ) ) <NEWLINE> first = d_lst [ - 1 ] <NEWLINE> second = d_lst [ - 2 ] <NEWLINE> if d [ first ] != 1 : <NEWLINE> <INDENT> return [ first ] * n <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return [ second if a [ i ] == first else first for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * solve ( N , a ) , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> TA = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> T , A = 0 , 0 <NEWLINE> for t , a in TA : <NEWLINE> <INDENT> if T == 0 and A == 0 : <NEWLINE> <INDENT> T = t <NEWLINE> A = a <NEWLINE> continue <NEWLINE> <DEDENT> if t == a : <NEWLINE> <INDENT> M = max ( T , A ) <NEWLINE> T = M <NEWLINE> A = M <NEWLINE> <DEDENT> elif t < a : <NEWLINE> <INDENT> n = max ( ( T // t ) * t , ( A // a ) * t ) <NEWLINE> while n < T or a * ( n // t ) < A : <NEWLINE> <INDENT> n += t <NEWLINE> <DEDENT> T = n <NEWLINE> A = a * ( T // t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = max ( ( A // a ) * a , ( T // t ) * a ) <NEWLINE> while n < A or t * ( n // a ) < T : <NEWLINE> <INDENT> n += a <NEWLINE> <DEDENT> A = n <NEWLINE> T = t * ( A // a ) <NEWLINE> <DEDENT> <DEDENT> print ( A + T ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> m = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> m = min ( m , P [ i ] ) <NEWLINE> if m == P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from functools import reduce <NEWLINE> MOD = 1_000_000_007 <NEWLINE> print ( reduce ( lambda a , b : a * b % MOD , range ( 1 , int ( input ( ) ) + 1 ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( 1 , x + 1 ) ) : <NEWLINE> <INDENT> for j in range ( 2 , 101 ) : <NEWLINE> <INDENT> for k in range ( 2 , 101 ) : <NEWLINE> <INDENT> number = j ** k <NEWLINE> if number == i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> from collections import deque <NEWLINE> <NL> h , w = nii ( ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> <NL> def BFS ( sy , sx , ans ) : <NEWLINE> <INDENT> s [ sy ] [ sx ] = <STRING> <NEWLINE> <NL> que = deque ( ) <NEWLINE> que . append ( ( sy , sx ) ) <NEWLINE> <NL> b_cnt = 1 <NEWLINE> w_cnt = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> y , x = que . popleft ( ) <NEWLINE> for dy , dx in [ [ - 1 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if 0 <= ny < h and 0 <= nx < w : <NEWLINE> <INDENT> if s [ y ] [ x ] == <STRING> and s [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> w_cnt += 1 <NEWLINE> s [ ny ] [ nx ] = <STRING> <NEWLINE> que . append ( ( ny , nx ) ) <NEWLINE> <DEDENT> if s [ y ] [ x ] == <STRING> and s [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> b_cnt += 1 <NEWLINE> s [ ny ] [ nx ] = <STRING> <NEWLINE> que . append ( ( ny , nx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans += b_cnt * w_cnt <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans = BFS ( i , j , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> battle = n * ( n - 1 ) // 2 <NEWLINE> lis = [ [ ] for i in range ( battle ) ] <NEWLINE> num = [ - 1 ] * ( n ** 2 ) <NEWLINE> cnt = - 1 <NEWLINE> for x in range ( n ** 2 ) : <NEWLINE> <INDENT> if x // n < x % n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> num [ x ] = cnt <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( n - 2 ) : <NEWLINE> <INDENT> x = a [ j ] - 1 <NEWLINE> y = a [ j + 1 ] - 1 <NEWLINE> px = num [ min ( i * n + x , x * n + i ) ] <NEWLINE> py = num [ min ( i * n + y , y * n + i ) ] <NEWLINE> lis [ px ] . append ( py ) <NEWLINE> <DEDENT> <DEDENT> node_in = [ 0 ] * ( battle ) <NEWLINE> for i in range ( battle ) : <NEWLINE> <INDENT> for x in lis [ i ] : <NEWLINE> <INDENT> node_in [ x ] += 1 <NEWLINE> <DEDENT> <DEDENT> zero = deque ( [ ] ) <NEWLINE> days = [ 10 ** 9 ] * ( battle ) <NEWLINE> for i in range ( battle ) : <NEWLINE> <INDENT> if node_in [ i ] == 0 : <NEWLINE> <INDENT> zero . append ( i ) <NEWLINE> days [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> while zero : <NEWLINE> <INDENT> r = zero . popleft ( ) <NEWLINE> for x in lis [ r ] : <NEWLINE> <INDENT> node_in [ x ] -= 1 <NEWLINE> if node_in [ x ] == 0 : <NEWLINE> <INDENT> zero . append ( x ) <NEWLINE> days [ x ] = days [ r ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if 10 ** 9 in days : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( days ) ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import itertools <NEWLINE> print ( abs ( m * n - ( ( n - 1 ) * 2 + ( m - 1 ) * 2 ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> m = 100000000000000 <NEWLINE> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> m = min ( m , i + N // i ) <NEWLINE> <DEDENT> <DEDENT> print ( m - 2 ) <NEWLINE>
import collections <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = dict ( collections . Counter ( A ) ) <NEWLINE> A = sorted ( A . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if len ( A ) > K : <NEWLINE> <INDENT> cnt += A [ - 1 ] [ 1 ] <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> n = 10 ** 5 <NEWLINE> <NL> work = [ 1 if i % 2 == 1 else 0 for i in range ( n + 1 ) ] <NEWLINE> primes = [ 2 ] <NEWLINE> lst = [ 0 ] * ( n + 1 ) <NEWLINE> work [ 1 ] == 0 <NEWLINE> <NL> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if not work [ i ] : continue <NEWLINE> primes . append ( i ) <NEWLINE> index = 1 <NEWLINE> while i * index <= n : <NEWLINE> <INDENT> work [ i * index ] = 0 <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in primes [ 1 : ] : <NEWLINE> <INDENT> if ( i + 1 ) // 2 in primes : <NEWLINE> <INDENT> lst [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> lst [ i ] += lst [ i - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> left , right = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lst [ right ] - lst [ left - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 9999999 <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if m >= P [ i - 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> m = P [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <NL> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( 0 , b - k + a ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_num = 10 ** 6 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] < min_num : <NEWLINE> <INDENT> min_num = p [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> if x > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if x + y > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> if ( i * A - i + 1 >= B ) : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( n + 1 ) : <NEWLINE> <INDENT> for y in range ( n + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> ri = [ ] <NEWLINE> num = 0 <NEWLINE> <NL> <NL> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> li . append ( L ) <NEWLINE> ri . append ( R ) <NEWLINE> <DEDENT> L = max ( li ) <NEWLINE> R = min ( ri ) <NEWLINE> num = R - L + 1 <NEWLINE> if num < 0 : <NEWLINE> <INDENT> num = 0 <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE> <NL>
from itertools import permutations as p <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> j = 0 <NEWLINE> <NL> for i in p ( range ( 1 , N + 1 ) ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> if i == P : a = j <NEWLINE> if i == Q : b = j <NEWLINE> <NL> <DEDENT> if a - b >= 0 : print ( a - b ) <NEWLINE> else : print ( b - a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = [ int ( input ( ) ) for i in range ( 2 ) ] <NEWLINE> print ( i [ 0 ] + i [ 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> p = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p *= i + 1 <NEWLINE> p %= 1000000007 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
import math <NEWLINE> <NL> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 2 * x / ( a * b ) <NEWLINE> <NL> if c <= a : <NEWLINE> <INDENT> ans = 90 - math . degrees ( math . atan ( c / b ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> d = 2 * ( a ** 2 * b - x ) / a ** 2 <NEWLINE> <NL> if d == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 90 - math . degrees ( math . atan ( a / d ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> primes = factorization ( M ) <NEWLINE> <COMMENT> <NL> <NL> if N == 1 or M == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for p , cnt in primes : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( 1 , min ( cnt , N ) + 1 ) : <NEWLINE> <INDENT> tmp += cmb ( N , i , mod ) * cmb ( cnt - 1 , i - 1 , mod ) <NEWLINE> <COMMENT> <NL> tmp %= mod <NEWLINE> <DEDENT> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa = bisect . bisect_left ( a , b [ i ] ) <NEWLINE> ca = n - bisect . bisect_right ( c , b [ i ] ) <NEWLINE> ans += aa * ca <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> range_total = sum ( P [ : K ] ) + K <NEWLINE> max_value = range_total <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> range_total += P [ K + i ] - P [ i ] <NEWLINE> max_value = max ( max_value , range_total ) <NEWLINE> <DEDENT> print ( max_value / 2 ) <NEWLINE>
<COMMENT> <NL> import heapq <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> item_no , discount_no = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> prices = [ int ( x ) * - 1 for x in input ( ) . split ( ) ] <NEWLINE> heapq . heapify ( prices ) <NEWLINE> <NL> for _ in range ( discount_no ) : <NEWLINE> <INDENT> current_max = heapq . heappop ( prices ) <NEWLINE> current_max = current_max * - 1 // 2 * - 1 <NEWLINE> heapq . heappush ( prices , current_max ) <NEWLINE> <NL> <DEDENT> print ( - sum ( prices ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> ans = ( x // 11 ) * 2 <NEWLINE> remainder = x % 11 <NEWLINE> if remainder == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif 1 <= remainder <= 6 : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans + 2 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> _3K = 3 * K <NEWLINE> _2K = 2 * K <NEWLINE> G = np . zeros ( ( _2K , _3K ) , dtype = <STRING> ) <COMMENT> <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , c = input ( ) . split ( ) <NEWLINE> x , y = int ( x ) , int ( y ) <NEWLINE> <COMMENT> <NL> if c == <STRING> : <NEWLINE> <INDENT> x = x % _2K <NEWLINE> y = y % _2K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( x + K ) % _2K <NEWLINE> y = y % _2K <NEWLINE> <COMMENT> <NL> <DEDENT> if ( y >= K ) and ( x >= K ) : <NEWLINE> <INDENT> x -= K <NEWLINE> y -= K <NEWLINE> <DEDENT> if ( y >= K ) and ( x < K ) : <NEWLINE> <INDENT> x += K <NEWLINE> y -= K <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> G [ y , x ] += 1 <NEWLINE> G [ y + K , x + K ] += 1 <NEWLINE> G [ y + K , x ] -= 1 <NEWLINE> G [ y , x + K ] -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> G = G . cumsum ( axis = 1 ) . cumsum ( axis = 0 ) <NEWLINE> <COMMENT> <NL> G = G [ : K , : _2K ] + G [ K : _2K , K : _3K ] + np . concatenate ( ( G [ : K , _2K : _3K ] , G [ K : _2K , : K ] ) , axis = 1 ) <NEWLINE> ans = G . max ( ) <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> V = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> V [ p - 1 ] . append ( ( y , i ) ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * M <NEWLINE> for i , v in enumerate ( V , start = 1 ) : <NEWLINE> <INDENT> v . sort ( ) <NEWLINE> for j , ( y , k ) in enumerate ( v , start = 1 ) : <NEWLINE> <INDENT> ans [ k ] = format ( str ( i ) , <STRING> ) + format ( str ( j ) , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rev = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> rev [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( rev [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m % n == 0 : <NEWLINE> <INDENT> print ( int ( m // n ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = m / n <NEWLINE> l = [ ] <NEWLINE> for i in range ( int ( m ** 0.5 ) , 0 , - 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> l . append ( m // i ) <NEWLINE> <DEDENT> <DEDENT> l = sorted ( l ) [ : : - 1 ] <NEWLINE> for j in l : <NEWLINE> <INDENT> if j <= a : <NEWLINE> <INDENT> print ( j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> feeindays = [ [ ] for _ in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= m : feeindays [ a - 1 ] += [ b ] <NEWLINE> <DEDENT> q = [ ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> pay = 0 <NEWLINE> for l in feeindays : <NEWLINE> <INDENT> for c in l : heapq . heappush ( q , - c ) <NEWLINE> if len ( q ) != 0 : pay += - 1 * heapq . heappop ( q ) <NEWLINE> <DEDENT> print ( pay ) <NEWLINE>
( n , ) , * a = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> d = { } <NEWLINE> for i , j in a : <NEWLINE> <INDENT> for x , y in a : <NEWLINE> <INDENT> if i != x or j != y : <NEWLINE> <INDENT> d [ ( i - x , j - y ) ] = d . get ( ( i - x , j - y ) , 0 ) + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n - max ( list ( d . values ( ) ) + [ 0 ] ) ) <NEWLINE>
n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> s = list ( s ) <NEWLINE> cnts = 0 <NEWLINE> cnti = 0 <NEWLINE> space = 0 <NEWLINE> iwa = 0 <NEWLINE> temp = 0 <NEWLINE> next = 0 <NEWLINE> if c < d : <NEWLINE> <INDENT> for i in range ( a - 1 , d ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnts = cnts + 1 <NEWLINE> space = max ( space , cnts ) <NEWLINE> cnti = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnti = cnti + 1 <NEWLINE> iwa = max ( iwa , cnti ) <NEWLINE> cnts = 0 <NEWLINE> <DEDENT> <DEDENT> if iwa > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a - 1 , c ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if i <= b - 2 : <NEWLINE> <INDENT> cnts = 0 <NEWLINE> <DEDENT> cnts = cnts + 1 <NEWLINE> space = max ( space , cnts ) <NEWLINE> cnti = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnti = cnti + 1 <NEWLINE> iwa = max ( iwa , cnti ) <NEWLINE> cnts = 0 <NEWLINE> <DEDENT> if i == d - 1 : <NEWLINE> <INDENT> temp = space <NEWLINE> if s [ i - 1 ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> next = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if iwa > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif temp < 3 and next == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sx = sorted ( x ) <NEWLINE> lx = len ( x ) // 2 <NEWLINE> m = sx [ lx ] <NEWLINE> _m = sx [ lx - 1 ] if 0 < m - 1 else sx [ 0 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> print ( m if i < m else _m ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> Flag = True <NEWLINE> for T in range ( 0 , min ( K , len ( S ) ) ) : <NEWLINE> <INDENT> if S [ T ] != <STRING> : <NEWLINE> <INDENT> Disp = S [ T ] <NEWLINE> Flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Flag : print ( <STRING> ) <NEWLINE> else : print ( Disp ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , k , l = map ( int , input ( ) . split ( ) ) <NEWLINE> city1 = [ i for i in range ( n ) ] <NEWLINE> city2 = [ i for i in range ( n ) ] <NEWLINE> <NL> def root ( c , x ) : <NEWLINE> <INDENT> if x == c [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return root ( c , c [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( c , x , y ) : <NEWLINE> <INDENT> rx = root ( c , x ) <NEWLINE> ry = root ( c , y ) <NEWLINE> if rx > ry : <NEWLINE> <INDENT> c [ rx ] = ry <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ ry ] = rx <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( city1 , a - 1 , b - 1 ) <NEWLINE> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( city2 , a - 1 , b - 1 ) <NEWLINE> <DEDENT> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r . append ( ( root ( city1 , i ) , root ( city2 , i ) ) ) <NEWLINE> <DEDENT> c = Counter ( r ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = c [ r [ i ] ] <NEWLINE> if i == n - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K , S = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if x > S : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for y in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if x + y > S : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif x + y + K < S : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - x - y <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] and n != 1 : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> for i in range ( 2 , N * 2 + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> primes = factorization ( M ) <NEWLINE> <COMMENT> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> for p , cnt in primes : <NEWLINE> <INDENT> tmp = cmb ( N + cnt - 1 , N - 1 , mod ) <NEWLINE> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> dp = [ n + 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while j <= n : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - j ] + 1 ) <NEWLINE> j *= 6 <NEWLINE> <NL> <DEDENT> k = 1 <NEWLINE> while k <= n : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - k ] + 1 ) <NEWLINE> k *= 9 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> if K > N : <NEWLINE> <INDENT> a = K - N <NEWLINE> <NL> <DEDENT> for _ in range ( a ) : <NEWLINE> <INDENT> H . append ( 0 ) <NEWLINE> <NL> <DEDENT> H . sort ( reverse = True ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> H [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> sum += H [ i ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> N = a [ 0 ] <NEWLINE> si = a [ 1 ] <NEWLINE> ti = a [ 2 ] <NEWLINE> s = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> s = sorted ( s ) <NEWLINE> X = int ( 0 ) <NEWLINE> ans = int ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> while N != X : <NEWLINE> <COMMENT> <NL> <INDENT> X += 1 <NEWLINE> ans += 1 <NEWLINE> <COMMENT> <NL> if N == X : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> temp = X <NEWLINE> for i in range ( min ( [ si - 1 , N - X ] ) ) : <NEWLINE> <INDENT> if s [ temp + i ] <= s [ temp - 1 ] + ti : <NEWLINE> <INDENT> X += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = dict ( ( i , 0 ) for i in range ( 1 , n + 1 ) ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> a [ int ( input ( ) ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if k - q + a [ i ] > 0 else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> N , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> edges [ l - 1 ] . append ( ( r - 1 , d ) ) <NEWLINE> edges [ r - 1 ] . append ( ( l - 1 , - d ) ) <NEWLINE> <NL> <DEDENT> visited = { } <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i in visited : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> q = deque ( [ ( i , 0 ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> l , c = q . popleft ( ) <NEWLINE> if l in visited : <NEWLINE> <INDENT> if visited [ l ] != c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> visited [ l ] = c <NEWLINE> <COMMENT> <NL> <NL> for r , nd in edges [ l ] : <NEWLINE> <INDENT> q . append ( ( r , c + nd ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P , CP = [ ] , [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> CP . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a , b = P [ i ] [ 0 ] , P [ i ] [ 1 ] <NEWLINE> now = 10 ** 10 <NEWLINE> for j in reversed ( range ( M ) ) : <NEWLINE> <INDENT> c , d = CP [ j ] [ 0 ] , CP [ j ] [ 1 ] <NEWLINE> distance = abs ( a - c ) + abs ( b - d ) <NEWLINE> if distance <= now : <NEWLINE> <INDENT> result = j + 1 <NEWLINE> now = distance <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = N + 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] < x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> x = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import heapq <NEWLINE> <NL> x , y , z , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> que = [ ( - ( a [ 0 ] + b [ 0 ] + c [ 0 ] ) , 0 , 0 , 0 ) ] <NEWLINE> is_pushed = { ( 0 , 0 , 0 ) : 1 } <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> v , p , q , r = heapq . heappop ( que ) <NEWLINE> print ( - v ) <NEWLINE> if p + 1 < x and not is_pushed . get ( ( p + 1 , q , r ) ) : <NEWLINE> <INDENT> heapq . heappush ( que , ( - ( a [ p + 1 ] + b [ q ] + c [ r ] ) , p + 1 , q , r ) ) <NEWLINE> is_pushed [ ( p + 1 , q , r ) ] = 1 <NEWLINE> <DEDENT> if q + 1 < y and not is_pushed . get ( ( p , q + 1 , r ) ) : <NEWLINE> <INDENT> heapq . heappush ( que , ( - ( a [ p ] + b [ q + 1 ] + c [ r ] ) , p , q + 1 , r ) ) <NEWLINE> is_pushed [ ( p , q + 1 , r ) ] = 1 <NEWLINE> <DEDENT> if r + 1 < z and not is_pushed . get ( ( p , q , r + 1 ) ) : <NEWLINE> <INDENT> heapq . heappush ( que , ( - ( a [ p ] + b [ q ] + c [ r + 1 ] ) , p , q , r + 1 ) ) <NEWLINE> is_pushed [ ( p , q , r + 1 ) ] = 1 <NEWLINE> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> with open ( 0 ) as f : <NEWLINE> <INDENT> N , H = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> ab = list ( map ( int , f . read ( ) . split ( ) ) ) <NEWLINE> <DEDENT> max_slash = max ( ab [ 0 : : 2 ] ) <NEWLINE> throw = sorted ( [ x for x in ab [ 1 : : 2 ] if x > max_slash ] , reverse = True ) <NEWLINE> cnt = 0 <NEWLINE> for t in throw : <NEWLINE> <INDENT> if H <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> H += - t <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if H > 0 : <NEWLINE> <INDENT> cnt += ( H + max_slash - 1 ) // max_slash <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> L = [ 0 ] * Q <NEWLINE> R = [ 0 ] * Q <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> min_L = min ( L ) <NEWLINE> max_R = max ( R ) <NEWLINE> <NL> check = [ ] <NEWLINE> for i in range ( min_L , max_R + 1 ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) : <NEWLINE> <INDENT> flg = ( is_prime ( i ) and is_prime ( ( i + 1 ) / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = 0 <NEWLINE> <DEDENT> check . append ( flg ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> check = [ 0 ] + check <NEWLINE> check = list ( accumulate ( check ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> print ( check [ R [ i ] - min_L + 1 ] - check [ L [ i ] - min_L ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( q ) ] <NEWLINE> C = Counter ( A ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if C [ i ] + k - q <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> m = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ i ] < m : <NEWLINE> <INDENT> m = P [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def modconb ( n , mod ) : <NEWLINE> <COMMENT> <NL> <INDENT> fac = [ 0 ] * ( n + 1 ) <NEWLINE> finv = [ 0 ] * ( n + 1 ) <NEWLINE> inv = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <COMMENT> <NL> <DEDENT> if n < k : return 0 <NEWLINE> if n < 0 or k < 0 : return 0 <NEWLINE> return fac , finv <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> fac , finv = modconb ( n , mod ) <NEWLINE> As . sort ( ) <NEWLINE> acc = list ( accumulate ( As ) ) <NEWLINE> As . sort ( reverse = True ) <NEWLINE> acc_r = list ( accumulate ( As ) ) <NEWLINE> ans = 0 <NEWLINE> for d in range ( 1 , n ) : <NEWLINE> <INDENT> if d - 1 < k - 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if k - 2 <= 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = fac [ d - 1 ] * ( finv [ k - 2 ] * finv [ d - 1 - ( k - 2 ) ] % mod ) % mod <NEWLINE> <COMMENT> <NL> <DEDENT> ind = min ( d - 1 , n - d - 1 ) <NEWLINE> mn = acc [ ind ] <NEWLINE> mx = acc_r [ ind ] <NEWLINE> ans += ( mx - mn ) * c <NEWLINE> <COMMENT> <NL> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n , q = input2 ( ) <NEWLINE> B = str ( input ( ) ) <NEWLINE> LR = [ input_array ( ) for _ in range ( q ) ] <NEWLINE> <NL> <COMMENT> <NL> T = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if B [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> T [ i + 1 ] = T [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i + 1 ] = T [ i ] <NEWLINE> <DEDENT> <DEDENT> for lr in LR : <NEWLINE> <INDENT> st = lr [ 0 ] - 1 <NEWLINE> fi = lr [ 1 ] - 1 <NEWLINE> print ( T [ fi ] - T [ st ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> p , m = i , i + 1 <NEWLINE> break <NEWLINE> <DEDENT> elif x [ i ] > 0 : <NEWLINE> <INDENT> p , m = i , i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( x [ 0 ] < 0 ) and ( x [ - 1 ] > 0 ) : <NEWLINE> <INDENT> pls = x [ p : ] <NEWLINE> mns = x [ : m ] <NEWLINE> ans = math . inf <NEWLINE> <NL> for i in range ( len ( pls ) ) : <NEWLINE> <INDENT> if i < K - 1 : <NEWLINE> <INDENT> if pls [ 0 ] == 0 : <NEWLINE> <INDENT> n = K - i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = K - i - 1 <NEWLINE> <DEDENT> if len ( mns ) >= n : <NEWLINE> <INDENT> tmp = 2 * abs ( mns [ - n ] ) + pls [ i ] <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> ans = min ( ans , pls [ i ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( mns ) ) : <NEWLINE> <INDENT> m = len ( mns ) - i <NEWLINE> if m < K : <NEWLINE> <INDENT> if pls [ 0 ] == 0 : <NEWLINE> <INDENT> n = K - m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = K - m - 1 <NEWLINE> <DEDENT> if len ( pls ) > n : <NEWLINE> <INDENT> tmp = 2 * pls [ n ] + abs ( mns [ - m ] ) <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> if m == K : <NEWLINE> <INDENT> ans = min ( ans , abs ( mns [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif x [ 0 ] >= 0 : <NEWLINE> <INDENT> ans = x [ K - 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( x [ - K ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> i = 0 ; p = 0 ; q = 0 <NEWLINE> while i != len ( S ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> p = 1 <NEWLINE> q = i <NEWLINE> if K < i + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> def fnw ( n , s ) : <NEWLINE> <INDENT> sm = deque ( [ ] ) <NEWLINE> if n <= len ( s ) : <NEWLINE> <INDENT> for _ in range ( n ) : <NEWLINE> <INDENT> sm . append ( s . popleft ( ) ) <NEWLINE> <DEDENT> <DEDENT> return <STRING> . join ( sm ) <NEWLINE> <NL> <DEDENT> def jfws ( s ) : <NEWLINE> <INDENT> fws = fnw ( 5 , s ) <NEWLINE> if fws == <STRING> : <NEWLINE> <INDENT> fws = fnw ( 2 , s ) <NEWLINE> if fws == <STRING> : <NEWLINE> <INDENT> if s : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . extendleft ( deque ( reversed ( list ( fws ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s . extendleft ( deque ( reversed ( list ( fws ) ) ) ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> elif fws == <STRING> : <NEWLINE> <INDENT> fws = fnw ( 1 , s ) <NEWLINE> if fws != <STRING> and fws != <STRING> : <NEWLINE> <INDENT> s . appendleft ( fws ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( s ) : <NEWLINE> <INDENT> while s : <NEWLINE> <INDENT> if jfws ( s ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> s = deque ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> print ( main ( s ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> j = 1 << i <NEWLINE> cnt = sum ( ( k & j ) >> i for k in a ) <NEWLINE> ans += ( cnt * ( n - cnt ) ) << i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if str ( i ) in s : <NEWLINE> <INDENT> first = s . index ( str ( i ) ) <NEWLINE> ss = s [ first + 1 : ] <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if str ( j ) in ss : <NEWLINE> <INDENT> sec = ss . index ( str ( j ) ) <NEWLINE> <NL> for k in range ( 10 ) : <NEWLINE> <INDENT> if str ( k ) in ss [ sec + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = <STRING> ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> q = int ( ( A >> i & 0b1 ) . sum ( ) ) <NEWLINE> ans += q * ( n - q ) * pow ( 2 , i , mod ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> w = [ ( input ( ) ) for _ in range ( n ) ] <NEWLINE> l = set ( w ) <NEWLINE> if len ( w ) != len ( l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if w [ i ] [ len ( w [ i ] ) - 1 ] != w [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = S . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if S . find ( str ( k ) , b + 1 ) != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> i = 0 <NEWLINE> j = len ( s ) - 1 <NEWLINE> ans = 0 <NEWLINE> while i < j : <NEWLINE> <INDENT> while s [ i ] == s [ j ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> j -= 1 <NEWLINE> if i > j : break <NEWLINE> <DEDENT> if i > j : break <NEWLINE> while s [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> ans += 1 <NEWLINE> if i > j : break <NEWLINE> <DEDENT> if i > j : break <NEWLINE> while s [ j ] == <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> ans += 1 <NEWLINE> if i > j : break <NEWLINE> <DEDENT> if i > j : break <NEWLINE> if s [ i ] != s [ j ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> j -= 1 <NEWLINE> if i > j : break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> q = deque ( [ ( S , 0 ) ] ) <NEWLINE> v = [ [ - 1 ] * 3 for i in range ( N + 1 ) ] <NEWLINE> <NL> while q : <NEWLINE> <INDENT> a , t = q . popleft ( ) <NEWLINE> b = t % 3 <NEWLINE> if v [ a ] [ b ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v [ a ] [ b ] = t <NEWLINE> t += 1 <NEWLINE> for x in to [ a ] : <NEWLINE> <INDENT> q . append ( ( x , t ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> if v [ T ] [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( v [ T ] [ 0 ] // 3 ) <NEWLINE> <DEDENT>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> D = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for p in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for q in range ( - 1 , 2 ) : <NEWLINE> <INDENT> aa = a + p <NEWLINE> bb = b + q <NEWLINE> if 2 <= aa <= h - 1 and 2 <= bb <= w - 1 : <NEWLINE> <INDENT> aabb = str ( aa ) + <STRING> + str ( bb ) <NEWLINE> if aabb in D : <NEWLINE> <INDENT> D [ aabb ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ aabb ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * 10 <NEWLINE> V = list ( D . values ( ) ) <NEWLINE> for v in V : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> ans [ 0 ] = ( h - 2 ) * ( w - 2 ) - sum ( ans ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 10 ** 9 + 3 <NEWLINE> if y >= x : <NEWLINE> <INDENT> ans = min ( ans , abs ( y - x ) ) <NEWLINE> <DEDENT> if - y >= x : <NEWLINE> <INDENT> ans = min ( ans , abs ( - y - x ) + 1 ) <NEWLINE> <DEDENT> if y >= - x : <NEWLINE> <INDENT> ans = min ( ans , abs ( y + x ) + 1 ) <NEWLINE> <DEDENT> if - y >= - x : <NEWLINE> <INDENT> ans = min ( ans , abs ( - y + x ) + 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> nekotyann = [ 0 ] * N <NEWLINE> wanntyann = [ 0 ] * N <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> nekotyann [ b - 1 ] += 1 <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> wanntyann [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> if nekotyann [ k ] != 0 and wanntyann [ k ] != 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = round ( n ** 0.5 ) <NEWLINE> <NL> while n % x != 0 : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> y = n // x <NEWLINE> print ( len ( str ( max ( x , y ) ) ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( a - b ) < 10 ** 18 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp_left = np . zeros ( ( N + 1 , K ) , dtype = bool ) <NEWLINE> dp_right = np . zeros ( ( N + 1 , K ) , dtype = bool ) <NEWLINE> dp_left [ 0 , 0 ] = 1 <NEWLINE> dp_right [ N , 0 ] = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp_left [ i + 1 ] = dp_left [ i ] <NEWLINE> dp_right [ N - i - 1 ] = dp_right [ N - i ] <NEWLINE> if ( a : = A [ i ] ) < K : <NEWLINE> <INDENT> dp_left [ i + 1 , a : ] |= dp_left [ i , : - a ] <NEWLINE> <DEDENT> if ( a : = A [ N - i - 1 ] ) < K : <NEWLINE> <INDENT> dp_right [ N - i - 1 , a : ] |= dp_right [ N - i , : - a ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> left_true = np . nonzero ( dp_left [ i ] ) [ 0 ] <NEWLINE> right_true = np . nonzero ( dp_right [ i + 1 ] ) [ 0 ] <NEWLINE> <NL> ss = np . searchsorted ( right_true , K - left_true ) - 1 <NEWLINE> if all ( right_true [ ss ] + left_true + a < K ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s_cnt = Counter ( s ) <NEWLINE> t_cnt = Counter ( t ) <NEWLINE> if all ( sv == tv for sv , tv in zip ( sorted ( s_cnt . values ( ) ) , sorted ( t_cnt . values ( ) ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
mini , maxi , K_ban = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( maxi - mini + 1 <= 2 * K_ban ) : <NEWLINE> <INDENT> ans = [ i for i in range ( mini , maxi + 1 ) ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> left = [ i for i in range ( mini , mini + K_ban ) ] <NEWLINE> right = [ i for i in range ( maxi - K_ban + 1 , maxi + 1 ) ] <NEWLINE> <NL> ans = left + right <NEWLINE> <NL> <NL> <DEDENT> [ print ( n ) for n in ans ] <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> <NL> b1 = [ i [ 0 ] for i in c . items ( ) if i [ 1 ] >= 4 ] <NEWLINE> b2 = [ i [ 0 ] for i in c . items ( ) if i [ 1 ] >= 2 ] <NEWLINE> b = b1 + b2 + [ 0 , 0 ] <NEWLINE> <NL> b . sort ( ) <NEWLINE> print ( b [ - 1 ] * b [ - 2 ] ) <NEWLINE>
s = input ( ) <NEWLINE> r = set ( map ( chr , range ( 97 , 97 + 26 ) ) ) <NEWLINE> r = r - set ( s ) <NEWLINE> if len ( r ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = min ( r ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if set ( t ) & set ( s ) == set ( t ) : <NEWLINE> <INDENT> n = - 1 <NEWLINE> c = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> n = s . find ( i , n + 1 ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> n = s . find ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( n + len ( s ) * c + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : print ( 2 * a ) <NEWLINE> else : print ( max ( a , b ) + max ( a - 1 , b - 1 ) ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> num = round ( p ** ( 1 / n ) ) <NEWLINE> for i in range ( num , 0 , - 1 ) : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> s = S ( ) <NEWLINE> ans = 0 <NEWLINE> w_cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - w_cnt <COMMENT> <NEWLINE> w_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a = s . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = s . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> c = s . find ( str ( k ) , b + 1 ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A2 = [ 0 ] * N <NEWLINE> <NL> i = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> A2 [ a - 1 ] = i <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( * A2 ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B . append ( A [ i ] - ( i + 1 ) ) <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> m = B [ 0 ] <NEWLINE> m2 = B [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = B [ n // 2 ] <NEWLINE> m2 = B [ n // 2 + 1 ] <NEWLINE> <DEDENT> tmp1 = 0 <NEWLINE> tmp2 = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp1 += abs ( A [ i ] - ( i + 1 ) - m ) <NEWLINE> tmp2 += abs ( A [ i ] - ( i + 1 ) - m2 ) <NEWLINE> <DEDENT> print ( min ( tmp1 , tmp2 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> H = sorted ( H ) <NEWLINE> if K >= len ( H ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , K ) : <NEWLINE> <INDENT> del H [ - 1 ] <NEWLINE> <DEDENT> result = sum ( H ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> import itertools <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = ns ( ) <NEWLINE> p = na1 ( ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = ns ( ) <NEWLINE> uf . union ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i , pi in enumerate ( p ) : <NEWLINE> <INDENT> if uf . same ( i , pi ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> <NL> for b in range ( 1 , x ) : <NEWLINE> <INDENT> for q in range ( 2 , x ) : <NEWLINE> <INDENT> if b ** q <= x : <NEWLINE> <INDENT> c = max ( c , b ** q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> X , Y , H = [ ] , [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( x ) , Y . append ( y ) , H . append ( h ) <NEWLINE> <NL> <DEDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for x , y , h in zip ( X , Y , H ) : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> hh = h + abs ( x - cx ) + abs ( y - cy ) <NEWLINE> res . append ( hh ) <NEWLINE> <DEDENT> if len ( set ( res ) ) == 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> for x , y , h in zip ( X , Y , H ) : <NEWLINE> <INDENT> if h != max ( res [ 0 ] - abs ( x - cx ) - abs ( y - cy ) , 0 ) : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( cx , cy , res [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> a = int ( math . sqrt ( X ) ) + 1 <COMMENT> <NEWLINE> for i in range ( 2 , a ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <COMMENT> <NEWLINE> <NL> <DEDENT> for j in range ( X , 10 ** 5 + 4 ) : <NEWLINE> <INDENT> if is_prime ( j ) : <NEWLINE> <INDENT> ans = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def read_pair ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N , M = read_pair ( ) <NEWLINE> adj = [ [ ] for x in range ( N ) ] <NEWLINE> rev = [ [ ] for y in range ( N ) ] <NEWLINE> <NL> outdegree = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = read_pair ( ) <NEWLINE> <NL> <COMMENT> <NL> x -= 1 <NEWLINE> y -= 1 <NEWLINE> <NL> adj [ x ] . append ( y ) <NEWLINE> rev [ y ] . append ( x ) <NEWLINE> outdegree [ x ] += 1 <NEWLINE> <NL> <DEDENT> maxpath = [ 0 ] * N <NEWLINE> q = deque ( ) <NEWLINE> <NL> for x in range ( N ) : <NEWLINE> <INDENT> if outdegree [ x ] == 0 : <NEWLINE> <INDENT> q . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> while q : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for y in adj [ x ] : <NEWLINE> <INDENT> maxpath [ x ] = max ( maxpath [ x ] , 1 + maxpath [ y ] ) <NEWLINE> <DEDENT> for z in rev [ x ] : <NEWLINE> <INDENT> outdegree [ z ] -= 1 <NEWLINE> if outdegree [ z ] == 0 : <NEWLINE> <INDENT> q . append ( z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( maxpath ) ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> X = il ( ) <NEWLINE> S = sorted ( X ) <NEWLINE> l = S [ N // 2 - 1 ] <NEWLINE> r = S [ N // 2 ] <NEWLINE> for x in X : <NEWLINE> <INDENT> if x <= l : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> x , y , k = 0 , 0 , 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif N <= 12 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> x = int ( 0.8 * N ) <NEWLINE> <NL> for i in range ( x , N ) : <NEWLINE> <INDENT> k = str ( i * 108 ) <NEWLINE> if int ( k [ 0 : - 2 ] ) == N : <NEWLINE> <INDENT> print ( i ) <NEWLINE> y += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if y != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque <NEWLINE> <NL> n , k = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> p = [ ( int ( x ) + 1 ) / 2 for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> m = sum ( p [ 0 : k ] ) <NEWLINE> maxm = m <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> m = m - p [ i - 1 ] + p [ i + k - 1 ] <NEWLINE> maxm = max ( [ maxm , m ] ) <NEWLINE> <NL> <DEDENT> print ( maxm ) <NEWLINE> <NL> <NL>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( x , k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if y <= z <= k : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> count += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> k = INT ( ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> t = s [ i ] <NEWLINE> a . add ( t ) <NEWLINE> if i < len ( s ) - 1 : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( i + k + 1 , len ( s ) ) ) : <NEWLINE> <INDENT> t += s [ j ] <NEWLINE> a . add ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> b = sorted ( list ( a ) ) <NEWLINE> print ( b [ k - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = tuple ( x ) <NEWLINE> x . sort ( ) <NEWLINE> if x [ ( n // 2 ) - 1 ] == x [ n // 2 ] : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( x [ n // 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for h in w : <NEWLINE> <INDENT> if h <= x [ ( n // 2 ) - 1 ] : <NEWLINE> <INDENT> print ( x [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ ( n // 2 ) - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> W = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( W [ ( W . index ( S ) + 1 ) % 3 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from heapq import heapify , heappush , heappop <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a1 = a [ 0 : n ] <NEWLINE> a_m = a [ n : 2 * n ] <NEWLINE> a2 = [ - x for x in a [ 2 * n : 3 * n ] ] <COMMENT> <NEWLINE> <NL> a1_sums = [ sum ( a1 ) ] <NEWLINE> a2_sums = [ sum ( a2 ) ] <NEWLINE> heapify ( a1 ) <NEWLINE> heapify ( a2 ) <NEWLINE> <NL> <COMMENT> <NL> for aa in a_m : <NEWLINE> <INDENT> heappush ( a1 , aa ) <NEWLINE> p = heappop ( a1 ) <NEWLINE> a1_sums . append ( a1_sums [ - 1 ] + aa - p ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a_m . reverse ( ) <NEWLINE> for aa in a_m : <NEWLINE> <INDENT> heappush ( a2 , - aa ) <NEWLINE> p = heappop ( a2 ) <NEWLINE> a2_sums . append ( a2_sums [ - 1 ] - aa - p ) <NEWLINE> <NL> <DEDENT> max_val = - float ( <STRING> ) <NEWLINE> for i in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> max_val = max ( max_val , a1_sums [ i ] + a2_sums [ n - i ] ) <NEWLINE> <NL> <DEDENT> print ( max_val ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( H , W , S ) : <NEWLINE> <INDENT> U = np . full ( shape = ( H + 2 , W + 2 ) , fill_value = - 1 , dtype = np . int64 ) <NEWLINE> D = np . full ( shape = ( H + 2 , W + 2 ) , fill_value = - 1 , dtype = np . int64 ) <NEWLINE> L = np . full ( shape = ( H + 2 , W + 2 ) , fill_value = - 1 , dtype = np . int64 ) <NEWLINE> R = np . full ( shape = ( H + 2 , W + 2 ) , fill_value = - 1 , dtype = np . int64 ) <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if not S [ h ] [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if U [ h ] [ w ] == - 1 : <NEWLINE> <INDENT> U [ h ] [ w ] = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> d += 1 <NEWLINE> if not S [ h + d ] [ w ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> U [ h + d ] [ w ] = d <NEWLINE> <DEDENT> <DEDENT> if L [ h ] [ w ] == - 1 : <NEWLINE> <INDENT> L [ h ] [ w ] = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> d += 1 <NEWLINE> if not S [ h ] [ w + d ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> L [ h ] [ w + d ] = d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for h in range ( H + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for w in range ( W + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if not S [ h ] [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if D [ h ] [ w ] == - 1 : <NEWLINE> <INDENT> D [ h ] [ w ] = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> d += 1 <NEWLINE> if not S [ h - d ] [ w ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> D [ h - d ] [ w ] = d <NEWLINE> <DEDENT> <DEDENT> if R [ h ] [ w ] == - 1 : <NEWLINE> <INDENT> R [ h ] [ w ] = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> d += 1 <NEWLINE> if not S [ h ] [ w - d ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> R [ h ] [ w - d ] = d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dist = U + D + L + R + 1 <NEWLINE> ans = np . max ( dist ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = np . zeros ( shape = ( H + 2 , W + 2 ) , dtype = np . bool ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> S [ i ] [ 1 : - 1 ] = [ s == <STRING> for s in input ( ) . rstrip ( ) ] <NEWLINE> <NL> <DEDENT> ans = solve ( H , W , S ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> lcm = n * m // math . gcd ( n , m ) <NEWLINE> ans = [ ] <NEWLINE> s_ind = lcm // n <NEWLINE> t_ind = lcm // m <NEWLINE> check_ind = s_ind * t_ind // math . gcd ( s_ind , t_ind ) <NEWLINE> for i in range ( 0 , lcm , check_ind ) : <NEWLINE> <INDENT> if s [ i // s_ind ] != t [ i // t_ind ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = [ 0 ] * m <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> survey = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = survey [ 0 ] <NEWLINE> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> favorite = survey [ j ] <NEWLINE> cnt [ favorite - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt . count ( n ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> x = [ - 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> x . append ( n - 1 ) <NEWLINE> t = len ( x ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( t - 1 ) : <NEWLINE> <INDENT> if i % 2 == s [ 0 ] : <NEWLINE> <INDENT> ans = max ( ans , x [ min ( t - 1 , i + 2 * k ) ] - x [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , x [ min ( t - 1 , i + 2 * k + 1 ) ] - x [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> ans = 1000000000000 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if ( n % i == 0 ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = n // a <NEWLINE> a_keta = len ( str ( a ) ) <NEWLINE> b_keta = len ( str ( b ) ) <NEWLINE> m_keta = max ( a_keta , b_keta ) <NEWLINE> ans = min ( ans , m_keta ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( a , a [ i ] + a [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = list ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> l = [ len ( i ) for i in s . split ( <STRING> ) ] <NEWLINE> r = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> r = min ( k , len ( l ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = min ( k - 1 , len ( l ) - 1 ) <NEWLINE> <NL> <DEDENT> t = l [ r ] <NEWLINE> <NL> for j in range ( 1 , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r - j >= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> t += l [ r - j ] <NEWLINE> <DEDENT> if r + j < len ( l ) : <NEWLINE> <COMMENT> <NL> <INDENT> t += l [ r + j ] <NEWLINE> <DEDENT> <DEDENT> ans = t <NEWLINE> for i in range ( r + 2 , len ( l ) , 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , 3 ) : <NEWLINE> <INDENT> if i - j - k >= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> t -= l [ i - j - k ] <NEWLINE> <DEDENT> if i + j + k - 2 < len ( l ) : <NEWLINE> <COMMENT> <NL> <INDENT> t += l [ i + j + k - 2 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d . sort ( ) <NEWLINE> print ( d [ int ( N / 2 ) ] - d [ int ( N / 2 ) - 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , t , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> b = 0 <NEWLINE> c = float ( <STRING> ) <NEWLINE> d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> if x - c > b : <NEWLINE> <INDENT> b = x - c <NEWLINE> d = 1 <NEWLINE> <DEDENT> elif x - c == b : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> c = min ( c , x ) <NEWLINE> <NL> <DEDENT> print ( d ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> d = [ 0 ] * 20002 <NEWLINE> for i in range ( h ) : d [ i ] = min ( d [ i - a ] + b for a , b in c ) <NEWLINE> print ( d [ h - 1 ] ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if R == B == G == 1 and N == 3000 : <NEWLINE> <INDENT> print ( 4504501 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> li = [ R , G , B ] <NEWLINE> ans = 0 <NEWLINE> li . sort ( reverse = True ) <NEWLINE> <NL> <NL> for i in range ( N // li [ 0 ] + 1 ) : <NEWLINE> <INDENT> for j in range ( N // li [ 1 ] + 1 ) : <NEWLINE> <INDENT> t = N - i * li [ 0 ] - j * li [ 1 ] <NEWLINE> if t >= 0 and t % li [ 2 ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> e_p = [ ] <NEWLINE> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> e_p . append ( ( P [ i ] + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> s = [ 0 ] * ( len ( P ) + 1 ) <NEWLINE> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + e_p [ i ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> res = max ( res , s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def sol ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> cnt = 0 <NEWLINE> t = [ ] <NEWLINE> for a , b in tmp : <NEWLINE> <INDENT> t += [ b ] * a <NEWLINE> cnt = cnt + a <NEWLINE> if cnt >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += t <NEWLINE> A . sort ( reverse = 1 ) <NEWLINE> print ( sum ( A [ : N ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sol ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> mod = 1000000007 <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> B = [ <STRING> ] * ( n + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> B [ a ] = <STRING> <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> if B [ 1 ] == <STRING> and B [ 2 ] == <STRING> : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = 2 <NEWLINE> <DEDENT> elif B [ 1 ] == <STRING> and B [ 2 ] == <STRING> : <NEWLINE> <INDENT> dp [ 2 ] = 1 <NEWLINE> <DEDENT> elif B [ 1 ] == <STRING> and B [ 2 ] == <STRING> : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if B [ i ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 2 ] + dp [ i - 1 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def bfs ( H , W , A , dist ) : <NEWLINE> <INDENT> queue = deque ( [ ] ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if A [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> dist [ h ] [ w ] = 0 <NEWLINE> queue . append ( ( h , w ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while queue : <NEWLINE> <INDENT> h , w = queue . popleft ( ) <NEWLINE> for y , x in [ ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ] : <NEWLINE> <INDENT> next_h , next_w = h + y , w + x <NEWLINE> if dist [ next_h ] [ next_w ] == - 1 : <NEWLINE> <INDENT> dist [ next_h ] [ next_w ] = dist [ h ] [ w ] + 1 <NEWLINE> queue . append ( ( next_h , next_w ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ None ] * ( H + 2 ) <NEWLINE> A [ 0 ] = A [ - 1 ] = <STRING> * ( W + 2 ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> A [ i ] = <STRING> . join ( [ <STRING> , input ( ) . rstrip ( ) , <STRING> ] ) <NEWLINE> <NL> <DEDENT> dist = [ [ 0 ] + [ - 1 ] * W + [ 0 ] for _ in range ( H + 2 ) ] <NEWLINE> dist [ 0 ] = dist [ - 1 ] = [ 0 ] * ( W + 2 ) <NEWLINE> bfs ( H + 2 , W + 2 , A , dist ) <NEWLINE> <NL> ans = max ( map ( max , dist ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] not in x : <NEWLINE> <INDENT> x . append ( s [ i ] ) <NEWLINE> <DEDENT> if t [ i ] not in y : <NEWLINE> <INDENT> y . append ( t [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> s = s . replace ( x [ i ] , str ( i ) ) <NEWLINE> <DEDENT> for i in range ( len ( y ) ) : <NEWLINE> <INDENT> t = t . replace ( y [ i ] , str ( i ) ) <NEWLINE> <DEDENT> print ( <STRING> if s == t else <STRING> ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def mapint ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> query = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = mapint ( ) <NEWLINE> query [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> query [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = mapint ( ) <NEWLINE> from collections import deque <NEWLINE> stack = deque ( [ ( K - 1 , 0 , - 1 ) ] ) <NEWLINE> dist = [ 0 ] * N <NEWLINE> while stack : <NEWLINE> <INDENT> now , cnt , per = stack . pop ( ) <NEWLINE> lis = query [ now ] <NEWLINE> dist [ now ] = cnt <NEWLINE> for nx , c in lis : <NEWLINE> <INDENT> if nx == per : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c != 0 : <NEWLINE> <INDENT> stack . append ( ( nx , cnt + c , now ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = mapint ( ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n , W = map ( int , input ( ) . split ( ) ) <NEWLINE> w = [ ] <NEWLINE> v = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w_ , v_ = map ( int , input ( ) . split ( ) ) <NEWLINE> w . append ( w_ ) <NEWLINE> v . append ( v_ ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( W + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ w [ i ] : ] = np . maximum ( dp [ : - w [ i ] ] + v [ i ] , dp [ w [ i ] : ] ) <NEWLINE> <DEDENT> print ( dp [ W ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> h . sort ( ) <NEWLINE> ans = 10 ** 10 <NEWLINE> <NL> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans_ = h [ i + K - 1 ] - h [ i ] <NEWLINE> ans = min ( ans , ans_ ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> table = { <NEWLINE> <INDENT> 1 : 2 , <NEWLINE> 2 : 5 , <NEWLINE> 3 : 5 , <NEWLINE> 4 : 4 , <NEWLINE> 5 : 5 , <NEWLINE> 6 : 6 , <NEWLINE> 7 : 3 , <NEWLINE> 8 : 7 , <NEWLINE> 9 : 6 , <NEWLINE> <DEDENT> } <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> mx = - 1 <NEWLINE> for j in a : <NEWLINE> <INDENT> if not 0 <= i - table [ j ] < n + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if dp [ i - table [ j ] ] < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if mx < dp [ i - table [ j ] ] * 10 + j : <NEWLINE> <INDENT> mx = dp [ i - table [ j ] ] * 10 + j <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = mx <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , Q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> path = [ [ ] for _ in range ( N - 1 ) ] <NEWLINE> query = [ [ ] for _ in range ( Q ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> path [ i ] = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> query [ i ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> query [ i ] [ 0 ] -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> add = [ 0 ] * N <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i , j in query : <NEWLINE> <INDENT> add [ i ] += j <NEWLINE> <NL> <DEDENT> children = [ [ ] for _ in range ( N ) ] <NEWLINE> for i , j in path : <NEWLINE> <INDENT> children [ i ] . append ( j ) <NEWLINE> children [ j ] . append ( i ) <NEWLINE> <NL> <DEDENT> def DFS ( id , parent , value ) : <NEWLINE> <INDENT> value += add [ id ] <NEWLINE> ans [ id ] = value <NEWLINE> for i in children [ id ] : <NEWLINE> <INDENT> if i == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> DFS ( i , id , value ) <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( 0 , - 1 , 0 ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> A , B , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ int ( input ( ) ) for _ in range ( A ) ] <NEWLINE> t = [ int ( input ( ) ) for _ in range ( B ) ] <NEWLINE> <NL> s . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> <NL> for k in range ( Q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> ms = bisect_left ( s , x ) <NEWLINE> for i in [ - 1 , 0 ] : <NEWLINE> <INDENT> if 0 <= ms + i <= A - 1 : <NEWLINE> <INDENT> mt = bisect_left ( t , s [ ms + i ] ) <NEWLINE> for j in [ - 1 , 0 ] : <NEWLINE> <INDENT> if 0 <= mt + j <= B - 1 : <NEWLINE> <INDENT> ans . append ( abs ( s [ ms + i ] - x ) + abs ( t [ mt + j ] - s [ ms + i ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> mt = bisect_left ( t , x ) <NEWLINE> for i in [ - 1 , 0 ] : <NEWLINE> <INDENT> if 0 <= mt + i <= B - 1 : <NEWLINE> <INDENT> ms = bisect_left ( s , t [ mt + i ] ) <NEWLINE> for j in [ - 1 , 0 ] : <NEWLINE> <INDENT> if 0 <= ms + j <= A - 1 : <NEWLINE> <INDENT> ans . append ( abs ( t [ mt + i ] - x ) + abs ( s [ ms + j ] - t [ mt + i ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ tuple ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> c = Counter ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> B = sorted ( A ) [ : N - 1 ] <NEWLINE> m = max ( A ) <NEWLINE> n = A . index ( max ( A ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i != n : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( B ) ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ x * ( - 1 ) for x in a ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> c = ( heapq . heappop ( a ) * ( - 1 ) // 2 ) * ( - 1 ) <NEWLINE> heapq . heappush ( a , c ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE> <NL>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = x * i <NEWLINE> x = x % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ a [ i ] , 1 ] ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( [ c , b ] ) <NEWLINE> <NL> <DEDENT> A . extend ( l ) <NEWLINE> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> B = [ ] <NEWLINE> <NL> j = 0 <NEWLINE> cnt = - 1 <NEWLINE> while cnt < n : <NEWLINE> <INDENT> B . extend ( [ A [ j ] [ 0 ] ] * A [ j ] [ 1 ] ) <NEWLINE> cnt = cnt + A [ j ] [ 1 ] <NEWLINE> if cnt >= n : <NEWLINE> <INDENT> del B [ n : ] <NEWLINE> <DEDENT> j = j + 1 <NEWLINE> <NL> <DEDENT> print ( sum ( B ) ) <NEWLINE>
xx = [ ] <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> xx = sorted ( ab , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += xx [ i ] [ 1 ] <NEWLINE> if ans >= k : <NEWLINE> <INDENT> print ( xx [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = list ( map ( int , input ( ) . split ( ) ) ) ; print ( min ( [ n [ i ] + n [ j ] for i in range ( 3 ) for j in range ( i + 1 , 3 ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , n - 2 , 2 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] or a [ i ] == a [ i + 2 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ - 2 ] != a [ - 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ 0 ] != 0 or a [ 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , n - 2 , 2 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] or a [ i ] == a [ i + 2 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ - 2 ] != a [ - 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> if n % 2 == 0 : print ( 2 ** ( n // 2 ) % mod ) <NEWLINE> else : print ( 2 ** ( ( n - 1 ) // 2 ) % mod ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> <NL> n = 10 ** 5 + 1 <NEWLINE> flag = [ True ] * n <NEWLINE> flag [ 1 ] = False <NEWLINE> for i in range ( 4 , n , 2 ) : flag [ i ] = False <NEWLINE> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , n , i ) : flag [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> nums = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> if flag [ i ] and flag [ ( i + 1 ) // 2 ] : nums [ i ] = nums [ i - 1 ] + 1 <NEWLINE> else : nums [ i ] = nums [ i - 1 ] <NEWLINE> <DEDENT> else : nums [ i ] = nums [ i - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( nums [ r ] - nums [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> X_L = [ None ] * N <NEWLINE> Y_L = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> _x , _y = map ( int , input ( ) . split ( ) ) <NEWLINE> X_L [ i ] = [ _x , i ] <NEWLINE> Y_L [ i ] = [ _y , i ] <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> X_L . sort ( ) <NEWLINE> Y_L . sort ( ) <NEWLINE> dx_l = [ None ] * ( N - 1 ) <NEWLINE> dy_l = [ None ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> dx_l [ i ] = [ X_L [ i + 1 ] [ 0 ] - X_L [ i ] [ 0 ] , X_L [ i ] [ 1 ] , X_L [ i + 1 ] [ 1 ] ] <NEWLINE> dy_l [ i ] = [ Y_L [ i + 1 ] [ 0 ] - Y_L [ i ] [ 0 ] , Y_L [ i ] [ 1 ] , Y_L [ i + 1 ] [ 1 ] ] <NEWLINE> <NL> <DEDENT> tmp_l = dx_l + dy_l <NEWLINE> tmp_l . sort ( ) <NEWLINE> <NL> UF = UnionFind ( N ) <NEWLINE> ans = 0 <NEWLINE> <NL> for _ in range ( 2 * N - 2 ) : <NEWLINE> <INDENT> _d , _i , _j = tmp_l [ _ ] <NEWLINE> if UF . same ( _i , _j ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> UF . unite ( _i , _j ) <NEWLINE> ans += _d <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist . insert ( 0 , 1e7 ) <NEWLINE> alist . append ( 1e7 ) <NEWLINE> core = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> core += min ( alist [ i ] , alist [ i + 1 ] ) <NEWLINE> <DEDENT> print ( core ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = len ( str ( N ) ) <NEWLINE> <NL> f = 1 <NEWLINE> while f * f <= N : <NEWLINE> <INDENT> if N % f == 0 : <NEWLINE> <INDENT> ans = min ( ans , max ( len ( str ( f ) ) , len ( str ( N // f ) ) ) ) <NEWLINE> <DEDENT> f += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> dist = [ INF ] * N <NEWLINE> dist [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for a , b , c in ABC : <NEWLINE> <INDENT> a , b , c = a - 1 , b - 1 , - c <NEWLINE> if dist [ b ] > dist [ a ] + c : <NEWLINE> <INDENT> dist [ b ] = dist [ a ] + c <NEWLINE> if i == N - 1 and b == N - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - dist [ - 1 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> import heapq <NEWLINE> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a = heapq . heappop ( A ) <NEWLINE> a /= 2 <NEWLINE> heapq . heappush ( A , a ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += int ( ( - 1 ) * a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> for j in range ( n // g + 1 ) : <NEWLINE> <INDENT> m = r * i + g * j <NEWLINE> if m <= n and ( n - m ) % b == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif m > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( A [ i ] + B [ i ] ) <NEWLINE> <DEDENT> l . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N // 2 ) : <NEWLINE> <INDENT> ans += l [ 2 * i ] <NEWLINE> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> ans += l [ - 1 ] <NEWLINE> <DEDENT> ans -= sum ( B ) <NEWLINE> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ - int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t = heapq . heappop ( a ) <NEWLINE> t = - t // 2 <NEWLINE> heapq . heappush ( a , - t ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> <NL> point = [ 0 ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> point [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if point [ i ] > q - k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if 0 <= k and k <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> s = <STRING> . join ( reversed ( list ( input ( ) ) ) ) <NEWLINE> t = <STRING> <NEWLINE> text = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> while len ( t ) < len ( s ) : <NEWLINE> <INDENT> for tx in text : <NEWLINE> <INDENT> if t + tx == s [ : len ( t + tx ) ] : <NEWLINE> <INDENT> t += tx <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = b - a <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , x , 1 ) : <NEWLINE> <INDENT> s += i <NEWLINE> <NL> <DEDENT> ans = s - a <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> if power >= 10 ** 9 + 7 : <NEWLINE> <INDENT> power %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> answer = 1 <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> answer = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> answer = s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , sys . stdin . readline ( ) . rsplit ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> res = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if A [ i ] [ j ] % 2 != 0 and j < W - 1 : <NEWLINE> <INDENT> A [ i ] [ j ] -= 1 <NEWLINE> A [ i ] [ j + 1 ] += 1 <NEWLINE> res . append ( [ i + 1 , j + 1 , i + 1 , j + 2 ] ) <NEWLINE> <DEDENT> elif A [ i ] [ j ] % 2 != 0 and i != H - 1 and j == W - 1 : <NEWLINE> <INDENT> A [ i ] [ j ] -= 1 <NEWLINE> A [ i + 1 ] [ j ] += 1 <NEWLINE> res . append ( [ i + 1 , j + 1 , i + 2 , j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( res ) ) <NEWLINE> for i in range ( len ( res ) ) : <NEWLINE> <INDENT> print ( * res [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> p = [ 0 ] + list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = np . zeros ( ( 3100 , 3100 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> dp [ 1 , 0 ] = 1 - p [ 1 ] <NEWLINE> dp [ 1 , 1 ] = p [ 1 ] <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] = np . roll ( dp [ i - 1 ] , 1 ) * p [ i ] + dp [ i - 1 ] * ( 1 - p [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for k in range ( - ( - N // 2 ) , N + 1 ) : <NEWLINE> <INDENT> ans += dp [ N , k ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i - 1 ] += 1 <NEWLINE> cnt [ i ] += 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
