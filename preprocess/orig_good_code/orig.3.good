n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * L ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> box = [ ] <NEWLINE> result = 0 <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - a <NEWLINE> result = a <NEWLINE> if k <= b : <NEWLINE> <INDENT> print ( result ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - b <NEWLINE> if k <= c : <NEWLINE> <INDENT> result = result - k <NEWLINE> print ( result ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = result - c <NEWLINE> print ( result ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> print ( i , n + 1 - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> turning_point = ( m + 1 ) // 2 <NEWLINE> for i in range ( 1 , turning_point + 1 ) : <NEWLINE> <INDENT> print ( i , n + 1 - i ) <NEWLINE> <DEDENT> for i in range ( turning_point + 1 , m + 1 ) : <NEWLINE> <INDENT> print ( i , n - i ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans = ans * int ( i ) <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = ( float ( i ) for i in input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
mod = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( k ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> lr [ i ] [ 1 ] += 1 <NEWLINE> <DEDENT> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> if i == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> for l , r in lr : <NEWLINE> <INDENT> if i - l >= 0 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - l ] <NEWLINE> <DEDENT> if i - r >= 0 : <NEWLINE> <INDENT> dp [ i ] -= dp [ i - r ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] %= mod <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
def waru ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return a // b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( a // b ) + 1 <NEWLINE> <DEDENT> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ue = sum ( A ) <NEWLINE> sita = 1 <NEWLINE> for i in range ( 50 ) : <NEWLINE> <INDENT> n = ( ue + sita ) // 2 <NEWLINE> L = [ waru ( i , n ) - 1 for i in A ] <NEWLINE> if sum ( L ) > K : <NEWLINE> <INDENT> sita = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ue = n <NEWLINE> <DEDENT> if ue == sita : <NEWLINE> <INDENT> print ( ue ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ue - sita == 1 : <NEWLINE> <INDENT> n = sita <NEWLINE> L = [ waru ( i , n ) - 1 for i in A ] <NEWLINE> if sum ( L ) > K : <NEWLINE> <INDENT> print ( n + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans [ A [ i - 1 ] - 1 ] = i <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in nums : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> ans = 1 <NEWLINE> if min ( a ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> def fn ( n , m ) : <NEWLINE> <INDENT> return ( m * pow ( m - 1 , n - 1 , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % MOD ) <NEWLINE> inv . append ( ( - inv [ MOD % i ] * ( MOD // i ) % MOD ) ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % MOD ) <NEWLINE> <NL> <DEDENT> def nCr ( n , r ) : <NEWLINE> <INDENT> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % MOD <NEWLINE> <NL> <DEDENT> ans = fn ( n , m ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += nCr ( n - 1 , i ) * fn ( n - i , m ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> list1 = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if a [ 1 ] > 0 : <NEWLINE> <INDENT> for j in range ( 2 , len ( a ) ) : <NEWLINE> <INDENT> list1 [ i ] [ a [ j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( * list1 [ i ] ) <NEWLINE> <NL> <DEDENT>
arr = list ( input ( ) ) <NEWLINE> down = list ( ) <NEWLINE> areas = list ( ) <NEWLINE> <NL> for i , el in enumerate ( arr ) : <NEWLINE> <INDENT> if el == <STRING> : <NEWLINE> <INDENT> down . append ( i ) <NEWLINE> <DEDENT> elif el == <STRING> and not len ( down ) == 0 : <NEWLINE> <INDENT> start_ind = down . pop ( ) <NEWLINE> area = i - start_ind <NEWLINE> while len ( areas ) > 0 and areas [ - 1 ] [ 0 ] > start_ind : <NEWLINE> <INDENT> area += areas . pop ( ) [ 1 ] <NEWLINE> <DEDENT> areas . append ( ( start_ind , area ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> areas = [ areas [ i ] [ 1 ] for i in range ( len ( areas ) ) ] <NEWLINE> print ( sum ( areas ) ) <NEWLINE> if len ( areas ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( areas ) , <STRING> . join ( map ( str , areas ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sum = sum ( A ) ** 2 <NEWLINE> <NL> squ = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> squ += A [ i ] ** 2 <NEWLINE> <NL> <DEDENT> answer = int ( ( ( sum - squ ) // 2 ) % mod ) <NEWLINE> print ( answer ) <NEWLINE>
A = input ( ) <NEWLINE> list1 = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> Ans = 1 <NEWLINE> <COMMENT> <NL> <NL> if <STRING> in list1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , A ) : <NEWLINE> <INDENT> Ans = Ans * int ( list1 [ i ] ) <NEWLINE> if Ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( Ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] = int ( B [ i - 1 ] ) + 1 <NEWLINE> <NL> <DEDENT> for j in B : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> s = input ( ) [ : : - 1 ] <NEWLINE> mod = 2019 <NEWLINE> <NL> x = [ 0 ] <NEWLINE> <NL> for i , j in enumerate ( s ) : <NEWLINE> <INDENT> x . append ( ( x [ - 1 ] + int ( j ) * pow ( 10 , i , mod ) ) % mod ) <NEWLINE> <NL> <DEDENT> C = Counter ( x ) <NEWLINE> ans = 0 <NEWLINE> <NL> for v in C . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ ] for i in range ( N ) ] <NEWLINE> checkd = [ False ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = ( map ( lambda a : int ( a ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> A [ a ] . append ( b ) <NEWLINE> A [ b ] . append ( a ) <NEWLINE> <DEDENT> nextS = set ( range ( N ) ) <NEWLINE> ans = 0 <NEWLINE> while len ( nextS ) > 0 : <NEWLINE> <INDENT> s = nextS . pop ( ) <NEWLINE> if checkd [ s ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count = 0 <NEWLINE> que = deque ( [ s ] ) <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> nn = que . popleft ( ) <NEWLINE> if checkd [ nn ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> checkd [ nn ] = True <NEWLINE> nextS . discard ( nn ) <NEWLINE> count += 1 <NEWLINE> que . extend ( A [ nn ] ) <NEWLINE> <DEDENT> ans = max ( count , ans ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> from collections import deque <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( c [ 7 : ] ) <NEWLINE> <DEDENT> elif c [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( c [ 7 : ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif c [ 6 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * q ) <NEWLINE>
import sys <NEWLINE> <NL> input_list = list ( int ( i ) for i in sys . stdin ) <NEWLINE> max_n = min ( 1000000 , max ( input_list ) + 1 ) <NEWLINE> <NL> prime_list = list ( i % 2 for i in range ( max_n ) ) <NEWLINE> prime_list [ 1 ] , prime_list [ 2 ] = 0 , 1 <NEWLINE> i = 3 <NEWLINE> while i * i < max_n : <NEWLINE> <INDENT> if prime_list [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , max_n , i ) : <NEWLINE> <INDENT> prime_list [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , max_n ) : <NEWLINE> <INDENT> prime_list [ i ] += prime_list [ i - 1 ] <NEWLINE> <NL> <DEDENT> inset = sorted ( ( n , i ) for i , n in enumerate ( input_list ) ) <NEWLINE> outset = sorted ( ( t [ 1 ] , prime_list [ t [ 0 ] ] ) for t in inset ) <NEWLINE> for t in outset : <NEWLINE> <INDENT> print ( t [ 1 ] ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 == X ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> n = int ( e ) ; m , f = [ [ 0 ] * n for _ in [ 0 ] * n ] , <STRING> * n <NEWLINE> j = n // 2 ; i = j + 1 <NEWLINE> m [ i ] [ j ] = 1 <NEWLINE> for k in range ( 2 , n * n + 1 ) : <NEWLINE> <INDENT> i , j = - ~ i % n , - ~ j % n <NEWLINE> if m [ i ] [ j ] : i , j = - ~ i % n , ~ - j % n <NEWLINE> m [ i ] [ j ] = k <NEWLINE> <DEDENT> for r in m : print ( f . format ( * r ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 0 ] == s [ 1 ] and s [ 1 ] == s [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> g = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g += 0.5 * i * ( n // i ) * ( ( n // i ) + 1 ) <NEWLINE> <DEDENT> print ( int ( g ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - 1 <= N : <NEWLINE> <INDENT> print ( A * ( B - 1 ) // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A * N // B ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> neighbors = { } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a not in neighbors . keys ( ) : <NEWLINE> <INDENT> neighbors . update ( { a : set ( ) } ) <NEWLINE> <DEDENT> if b not in neighbors [ a ] : <NEWLINE> <INDENT> neighbors [ a ] . add ( b ) <NEWLINE> <DEDENT> if b not in neighbors . keys ( ) : <NEWLINE> <INDENT> neighbors . update ( { b : set ( ) } ) <NEWLINE> <DEDENT> if a not in neighbors [ b ] : <NEWLINE> <INDENT> neighbors [ b ] . add ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> lst = [ 0 ] * ( n - 1 ) <NEWLINE> visited = set ( ) <NEWLINE> queue = [ [ 0 , set ( [ 1 ] ) ] ] <NEWLINE> while queue : <NEWLINE> <COMMENT> <NL> <INDENT> pre_room , rooms = queue . pop ( 0 ) <NEWLINE> <COMMENT> <NL> for room in rooms : <NEWLINE> <INDENT> if room in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if lst [ room - 2 ] == 0 and room != 1 : <NEWLINE> <INDENT> lst [ room - 2 ] = pre_room <NEWLINE> <DEDENT> visited . add ( room ) <NEWLINE> next_rooms = set ( ) <NEWLINE> for nei in neighbors [ room ] : <NEWLINE> <INDENT> next_rooms . add ( nei ) <NEWLINE> <DEDENT> next_rooms = [ room , next_rooms ] <NEWLINE> queue . append ( next_rooms ) <NEWLINE> <DEDENT> <DEDENT> if 0 in lst : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( lst [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if a % i == 0 : <NEWLINE> <INDENT> t = a // i <NEWLINE> if b % t == 0 : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> a , b = sorted ( map ( int , line . split ( ) ) ) <NEWLINE> gcdab = gcd ( a , b ) <NEWLINE> print ( gcdab , a // gcdab * b ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = math . gcd ( a [ i ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> work_day_min = [ ] <NEWLINE> work_day_max = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if i > 0 and len ( work_day_min ) > 0 : <NEWLINE> <INDENT> if i - work_day_min [ - 1 ] <= C : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> work_day_min . append ( i ) <NEWLINE> <DEDENT> if len ( work_day_min ) == K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ N - i - 1 ] == <STRING> : <NEWLINE> <INDENT> if i > 0 and len ( work_day_max ) > 0 : <NEWLINE> <INDENT> if work_day_max [ - 1 ] - ( N - i - 1 ) <= C : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> work_day_max . append ( N - i - 1 ) <NEWLINE> <DEDENT> if len ( work_day_max ) == K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> if work_day_min [ i ] == work_day_max [ K - i - 1 ] : <NEWLINE> <INDENT> print ( work_day_min [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> b = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> b . reverse ( ) <NEWLINE> <NL> print ( <STRING> . join ( b ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> r = N // ( A + B ) * A <NEWLINE> s = N % ( A + B ) <NEWLINE> <NL> x = r + min ( A , s ) <NEWLINE> print ( x ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ls = sorted ( ls ) <NEWLINE> ans = sum ( ls ) <NEWLINE> newls = [ 0 ] * ( 100000 + 1 + 1 ) <NEWLINE> for p in ls : <NEWLINE> <INDENT> newls [ p ] += 1 <NEWLINE> <DEDENT> ls = newls <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = ls [ b ] <NEWLINE> ans = ans + tmp * c - tmp * b <NEWLINE> ls [ b ] = 0 <NEWLINE> ls [ c ] += tmp <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( reverse = True ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> <COMMENT> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ [ ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> arr [ a - 1 ] . append ( b - 1 ) <NEWLINE> arr [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if len ( arr [ i ] ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bfs ( d ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> que . append ( 0 ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> while que : <NEWLINE> <INDENT> x = que . popleft ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> for i in arr [ x ] : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> que . append ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in arr [ x ] : <NEWLINE> <INDENT> if ans [ i ] == 0 and i != 0 : <NEWLINE> <INDENT> ans [ i ] = x + 1 <NEWLINE> que . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> bfs ( arr ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> lis = [ ] <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> dic [ i ] = abs ( x - i ) <NEWLINE> lis . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> mini = min ( dic . values ( ) ) <NEWLINE> for j in lis : <NEWLINE> <INDENT> if mini == dic [ j ] : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> ka = k - a <NEWLINE> <NL> if ka > 0 : <NEWLINE> <INDENT> kb = ka - b <NEWLINE> <DEDENT> elif ka <= 0 : <NEWLINE> <INDENT> a = k <NEWLINE> ka = 0 <NEWLINE> kb = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kb = 0 <NEWLINE> <DEDENT> print ( a * 1 + ka * 0 + kb * - 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for ( i , j ) in zip ( a [ k : ] , a [ : - k ] ) : <NEWLINE> <INDENT> if j < i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X % Y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if X * i % Y != 0 and X * i <= 10 ** 18 : <NEWLINE> <INDENT> print ( X * i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> if X * i > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if a [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> M = [ 1 ] <NEWLINE> now = 2 <NEWLINE> r = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> M . append ( now ) <NEWLINE> now -= a [ i + 1 ] <NEWLINE> if now < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif now < r : <NEWLINE> <INDENT> now *= 2 <NEWLINE> <DEDENT> <DEDENT> now = a [ - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> M [ - i - 1 ] = min ( now , M [ - i - 1 ] ) <NEWLINE> now = min ( now , M [ - i - 1 ] ) <NEWLINE> now += a [ - i - 2 ] <NEWLINE> <DEDENT> if a [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if M [ i ] <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( M ) ) <NEWLINE>
N = input ( ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if int ( N [ i ] ) == 7 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a - c ) <NEWLINE>
[ N , K ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> S = _S ( ) <NEWLINE> S += <STRING> <NEWLINE> <COMMENT> <NL> <NL> ans = np . zeros ( len ( S ) + 1 , dtype = <STRING> ) <NEWLINE> bc = S [ 0 ] <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> cc = S [ i ] <NEWLINE> if cc == bc : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if cc == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ i - 1 ] += math . ceil ( count / 2 ) <NEWLINE> <COMMENT> <NL> ans [ i ] += math . floor ( count / 2 ) <NEWLINE> count = 1 <NEWLINE> bc = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - count ] += math . ceil ( count / 2 ) <NEWLINE> ans [ i - count - 1 ] += math . floor ( count / 2 ) <NEWLINE> count = 1 <NEWLINE> bc = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ : - 2 ] ) <NEWLINE> <NL> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> book_a = [ 0 ] * ( n + 1 ) <NEWLINE> book_b = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> book_a [ i + 1 ] = book_a [ i ] + a [ i ] <NEWLINE> <NL> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> book_b [ j + 1 ] = book_b [ j ] + b [ j ] <NEWLINE> <NL> <DEDENT> r = m <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if book_a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while book_a [ i ] + book_b [ r ] > k : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + r ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> for i in A : <NEWLINE> <INDENT> d [ i - 1 ] += 1 <NEWLINE> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> print ( d [ n ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , math . ceil ( ( i + n ) / 2 ) ) : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ j * 2 - i ] and s [ j * 2 - i ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> load = { i : [ ] for i in range ( 1 , n + 1 ) } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> load [ a ] . append ( b ) <NEWLINE> load [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> visited = { 1 : 1 } <NEWLINE> <NL> while len ( queue ) != 0 : <NEWLINE> <INDENT> curr = queue . popleft ( ) <NEWLINE> for _next in load [ curr ] : <NEWLINE> <INDENT> if visited . get ( _next , - 1 ) == - 1 : <NEWLINE> <INDENT> visited [ _next ] = curr <NEWLINE> queue . append ( _next ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( visited ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( visited [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from _collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X = [ A [ i ] - ( i + 1 ) for i in range ( n ) ] <NEWLINE> Y = [ - A [ i ] - ( i + 1 ) for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> P = defaultdict ( int ) <NEWLINE> Q = defaultdict ( int ) <NEWLINE> <NL> for x in X : <NEWLINE> <INDENT> P [ x ] += 1 <NEWLINE> <DEDENT> for y in Y : <NEWLINE> <INDENT> Q [ y ] += 1 <NEWLINE> <NL> <DEDENT> p = set ( P . keys ( ) ) <NEWLINE> q = set ( Q . keys ( ) ) <NEWLINE> <NL> r = p & q <NEWLINE> <NL> for key in r : <NEWLINE> <INDENT> ans += P [ key ] * Q [ key ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = A . values ( ) <NEWLINE> k = len ( B ) - K <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( sorted ( B ) [ 0 : k ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = sum ( lis ) <NEWLINE> tmp = 0 <NEWLINE> for i in lis : <NEWLINE> <INDENT> tmp += i ** 2 <NEWLINE> <NL> <DEDENT> print ( ( ( s * s - tmp ) // 2 ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> LIM = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for e in a : <NEWLINE> <INDENT> ans *= e <NEWLINE> if ans > LIM or ans < - 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
data = [ <NEWLINE> <INDENT> [ [ 0 for r in range ( 10 ) ] for i in range ( 3 ) ] for b in range ( 4 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for bi , b in enumerate ( data ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> for r in f : <NEWLINE> <INDENT> print ( <STRING> . format ( r ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if bi < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ k + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> ans = 0 <NEWLINE> import itertools <NEWLINE> for p in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> if p [ i [ 1 ] - 1 ] - p [ i [ 0 ] - 1 ] == i [ 2 ] : <NEWLINE> <INDENT> d += i [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( d , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> self . dist = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return self . dist [ x ] , x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . find ( self . parents [ x ] ) <NEWLINE> self . dist [ x ] += tmp [ 0 ] <NEWLINE> self . parents [ x ] = tmp [ 1 ] <NEWLINE> return self . dist [ x ] , self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y , d ) : <NEWLINE> <INDENT> rx = self . find ( x ) [ 1 ] <NEWLINE> ry = self . find ( y ) [ 1 ] <NEWLINE> diff = self . dist [ y ] - self . dist [ x ] - d <NEWLINE> if rx == ry : <NEWLINE> <INDENT> if diff != 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if diff < 0 : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> diff = - diff <NEWLINE> <DEDENT> self . parents [ ry ] = min ( self . parents [ ry ] , self . parents [ rx ] - diff ) <NEWLINE> self . parents [ rx ] = ry <NEWLINE> self . dist [ rx ] = diff <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * lrd = map ( int , read ( ) . split ( ) ) <NEWLINE> v = Unionfind ( n ) <NEWLINE> for l , r , d in zip ( * [ iter ( lrd ) ] * 3 ) : <NEWLINE> <INDENT> if v . union ( l - 1 , r - 1 , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main_ ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( W + 1 , np . int64 ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> w = l [ n ] [ 0 ] <NEWLINE> v = l [ n ] [ 1 ] <NEWLINE> dp [ w : ] = np . maximum ( dp [ w : ] , dp [ : - w ] + v ) <NEWLINE> <DEDENT> return dp . max ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main_ ( ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> from builtins import max , min , range <NEWLINE> <NL> INF = 10 ** 6 <NEWLINE> <NL> H , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> Ch , Cw = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> Dh , Dw = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> S = [ readline ( ) [ : - 1 ] for _ in range ( H ) ] <NEWLINE> <NL> t = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> th = t [ h ] <NEWLINE> Sh = S [ h ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if Sh [ w ] == <STRING> : <NEWLINE> <INDENT> th [ w ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t [ Ch ] [ Cw ] = 0 <NEWLINE> q = deque ( [ ( Ch , Cw ) ] ) <NEWLINE> warp_count = 0 <NEWLINE> warpq = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> while q : <NEWLINE> <INDENT> warpq . append ( q [ 0 ] ) <NEWLINE> h , w = q . popleft ( ) <NEWLINE> if h - 1 >= 0 and t [ h - 1 ] [ w ] > warp_count : <NEWLINE> <INDENT> q . append ( ( h - 1 , w ) ) <NEWLINE> t [ h - 1 ] [ w ] = warp_count <NEWLINE> <DEDENT> if h + 1 < H and t [ h + 1 ] [ w ] > warp_count : <NEWLINE> <INDENT> q . append ( ( h + 1 , w ) ) <NEWLINE> t [ h + 1 ] [ w ] = warp_count <NEWLINE> <DEDENT> if w - 1 >= 0 and t [ h ] [ w - 1 ] > warp_count : <NEWLINE> <INDENT> q . append ( ( h , w - 1 ) ) <NEWLINE> t [ h ] [ w - 1 ] = warp_count <NEWLINE> <DEDENT> if w + 1 < W and t [ h ] [ w + 1 ] > warp_count : <NEWLINE> <INDENT> q . append ( ( h , w + 1 ) ) <NEWLINE> t [ h ] [ w + 1 ] = warp_count <NEWLINE> <NL> <DEDENT> <DEDENT> if t [ Dh ] [ Dw ] != INF : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> warp_count += 1 <NEWLINE> for h , w in warpq : <NEWLINE> <INDENT> for i in range ( max ( 0 , h - 2 ) , min ( H , h + 3 ) ) : <NEWLINE> <INDENT> ti = t [ i ] <NEWLINE> for j in range ( max ( 0 , w - 2 ) , min ( W , w + 3 ) ) : <NEWLINE> <INDENT> if ti [ j ] > warp_count : <NEWLINE> <INDENT> ti [ j ] = warp_count <NEWLINE> q . append ( ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> warpq . clear ( ) <NEWLINE> <NL> <DEDENT> if t [ Dh ] [ Dw ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ Dh ] [ Dw ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def check_prime ( num ) : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if num < 2 or num % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return pow ( 2 , num - 1 , num ) == 1 <NEWLINE> <NL> <DEDENT> cnt_num = int ( input ( ) ) <NEWLINE> dataset = [ int ( input ( ) ) for i in range ( cnt_num ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in dataset : <NEWLINE> <INDENT> if check_prime ( i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> mx = A [ 0 ] ; A = A [ 1 : ] <NEWLINE> mn = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> if abs ( mn - mx / 2 ) > abs ( a - mx / 2 ) : <NEWLINE> <INDENT> mn = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( mx , mn ) <NEWLINE>
n = input ( ) <NEWLINE> n_l = int ( n [ - 3 : ] ) <NEWLINE> if n_l == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - n_l ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> to = [ 0 ] <NEWLINE> to += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> passed = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> circle = [ 1 ] <NEWLINE> st = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> nx = to [ circle [ - 1 ] ] <NEWLINE> if passed [ nx ] == 1 : <NEWLINE> <INDENT> st = nx <NEWLINE> break <NEWLINE> <DEDENT> circle . append ( nx ) <NEWLINE> passed [ nx ] = 1 <NEWLINE> <NL> <NL> <DEDENT> l1 = circle . index ( st ) <NEWLINE> l2 = len ( circle ) - l1 <NEWLINE> <NL> if k < l1 : <NEWLINE> <INDENT> print ( circle [ k ] ) <NEWLINE> <DEDENT> elif k < l1 + l2 : <NEWLINE> <INDENT> print ( circle [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> div = ( k - l1 ) % l2 <NEWLINE> print ( circle [ l1 + div ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def reconstruction ( left , right ) : <NEWLINE> <INDENT> global pre_order <NEWLINE> global in_order <NEWLINE> global post_order <NEWLINE> global n <NEWLINE> <NL> if left > right : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif left == right : <NEWLINE> <INDENT> root = pre_order . pop ( 0 ) <NEWLINE> post_order . append ( root ) <NEWLINE> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = pre_order . pop ( 0 ) <NEWLINE> <NL> <DEDENT> root_pos = in_order . index ( root ) <NEWLINE> reconstruction ( left , root_pos - 1 ) <NEWLINE> reconstruction ( root_pos + 1 , right ) <NEWLINE> post_order . append ( root ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> pre_order = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> in_order = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> post_order = [ ] <NEWLINE> <NL> reconstruction ( 0 , n - 1 ) <NEWLINE> print ( * post_order ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) . split ( ) [ 0 ] <NEWLINE> T = input ( ) . split ( ) [ 0 ] <NEWLINE> T = T [ : - 1 ] <NEWLINE> if S == T : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> aa = [ True ] * ( N + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> aa [ i ] = False <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if aa [ 1 ] : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if ( aa [ i ] == False ) : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] = dp [ i ] % MOD <NEWLINE> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> connect = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> connect [ a - 1 ] . add ( b - 1 ) <NEWLINE> connect [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> counter = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> def dfs ( me , parent , cum ) : <NEWLINE> <INDENT> cum += counter [ me ] <NEWLINE> ans [ me ] = cum <NEWLINE> for child in connect [ me ] : <NEWLINE> <INDENT> if child != parent : <NEWLINE> <INDENT> dfs ( child , me , cum ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for nn in range ( 1 , n [ 0 ] + 1 ) : <NEWLINE> <INDENT> if nn % 3 == 0 or <STRING> in str ( nn ) : <NEWLINE> <INDENT> print ( <STRING> + str ( nn ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> ans = ans + sum ( list ( map ( lambda z : math . gcd ( math . gcd ( x , y ) , z ) , range ( 1 , K + 1 , 1 ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> A = input ( ) . split ( ) <NEWLINE> while ( len ( A ) > 1 ) : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if ( A [ i ] == <STRING> ) : <NEWLINE> <INDENT> A [ i ] = int ( A [ i - 2 ] ) + int ( A [ i - 1 ] ) <NEWLINE> A = A [ : i - 2 ] + A [ i : ] <NEWLINE> break <NEWLINE> <DEDENT> elif ( A [ i ] == <STRING> ) : <NEWLINE> <INDENT> A [ i ] = int ( A [ i - 2 ] ) - int ( A [ i - 1 ] ) <NEWLINE> A = A [ : i - 2 ] + A [ i : ] <NEWLINE> break <NEWLINE> <DEDENT> elif ( A [ i ] == <STRING> ) : <NEWLINE> <INDENT> A [ i ] = int ( A [ i - 2 ] ) * int ( A [ i - 1 ] ) <NEWLINE> A = A [ : i - 2 ] + A [ i : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A [ 0 ] ) <NEWLINE>
def func ( n , a ) : <NEWLINE> <INDENT> if ( 0 in a ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> tmp = [ 0 for i in range ( n ) ] <NEWLINE> tmp [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp [ i ] = tmp [ i - 1 ] * a [ i ] <NEWLINE> if ( tmp [ i ] > 10 ** 18 ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return str ( tmp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = func ( n , a ) <NEWLINE> print ( s ) <NEWLINE>
import copy <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> res = [ [ ] for i in range ( N + 5 ) ] <NEWLINE> <NL> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> res [ a ] . append ( b ) <NEWLINE> res [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> pre = [ - 1 ] * N <NEWLINE> dist = [ - 1 ] * N <NEWLINE> d = 1 <NEWLINE> dl = [ ] <NEWLINE> pre [ 0 ] = 0 <NEWLINE> dist [ 0 ] = 0 <NEWLINE> dl . append ( 0 ) <NEWLINE> <NL> while ( len ( dl ) != 0 ) : <NEWLINE> <INDENT> a = dl [ 0 ] <NEWLINE> dl . pop ( 0 ) <NEWLINE> for i in res [ a ] : <NEWLINE> <INDENT> if ( dist [ i ] != - 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] = dist [ a ] + 1 <NEWLINE> pre [ i ] = a <NEWLINE> dl . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( pre [ i ] + 1 ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in [ 0 ] * N ] <NEWLINE> for _ in [ 0 ] * M : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <DEDENT> for v in sorted ( get_lowlink ( edges , M ) [ 1 ] ) : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_lowlink ( edges , edge_num ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n = len ( edges ) <NEWLINE> order = [ - 1 ] * n <NEWLINE> low = [ float ( <STRING> ) ] * n <NEWLINE> bridges = [ ] <NEWLINE> articulations = [ 0 ] if edge_num == n - 1 and len ( edges [ 0 ] ) > 1 else [ ] <NEWLINE> append_bridge , append_articulation = bridges . append , articulations . append <NEWLINE> <NL> def dfs ( v , prev , k ) : <NEWLINE> <INDENT> order [ v ] = low [ v ] = k <NEWLINE> <NL> is_articulation = False <NEWLINE> for dest in edges [ v ] : <NEWLINE> <INDENT> if order [ dest ] == - 1 : <NEWLINE> <INDENT> dfs ( dest , v , k + 1 ) <NEWLINE> if low [ v ] > low [ dest ] : <NEWLINE> <INDENT> low [ v ] = low [ dest ] <NEWLINE> <DEDENT> if order [ v ] < low [ dest ] : <NEWLINE> <INDENT> append_bridge ( ( v , dest ) ) <NEWLINE> <DEDENT> is_articulation |= order [ v ] <= low [ dest ] <NEWLINE> <NL> <DEDENT> elif dest != prev and low [ v ] > order [ dest ] : <NEWLINE> <INDENT> low [ v ] = order [ dest ] <NEWLINE> <NL> <DEDENT> <DEDENT> if v > 0 and is_articulation : <NEWLINE> <INDENT> append_articulation ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , 0 , 0 ) <NEWLINE> return bridges , articulations <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> S = input ( ) <NEWLINE> mod = [ 1 ] + [ 0 ] * 2018 <NEWLINE> tmp = 0 <NEWLINE> seki = 1 <NEWLINE> for k in range ( len ( S ) ) : <NEWLINE> <INDENT> tmp = ( seki * int ( S [ len ( S ) - 1 - k ] ) + tmp ) % 2019 <NEWLINE> mod [ tmp ] += 1 <NEWLINE> seki = ( seki * 10 ) % 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for k in range ( 2019 ) : <NEWLINE> <INDENT> ans += mod [ k ] * ( mod [ k ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def func ( x ) : <NEWLINE> <INDENT> if x : <NEWLINE> <INDENT> return int ( x ) * func ( x - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( 1 ) <NEWLINE> <DEDENT> <DEDENT> def comb ( x , y ) : <NEWLINE> <INDENT> return func ( x ) // func ( x - y ) // func ( y ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> w , h , ax , ay , bx , by = map ( int , input ( ) . split ( ) ) <NEWLINE> dx = min ( w - abs ( ax - bx ) , abs ( ax - bx ) ) <NEWLINE> dy = min ( h - abs ( ay - by ) , abs ( ay - by ) ) <NEWLINE> ans = 1 <NEWLINE> if dx * 2 == w : ans *= 2 <NEWLINE> if dy * 2 == h : ans *= 2 <NEWLINE> ans *= comb ( dx + dy , dx ) <NEWLINE> print ( ans % 100000007 ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> x = n <NEWLINE> score = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( score ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> score = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( score ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> c = tuple ( int ( x ) + 1 for x in input ( ) . split ( ) ) <NEWLINE> d = [ int ( x ) + 1 for x in input ( ) . split ( ) ] <NEWLINE> maze = [ [ - 1 ] * ( W + 4 ) , [ - 1 ] * ( W + 4 ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> s0 = input ( ) <NEWLINE> s0 = <STRING> + s0 . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) + <STRING> <NEWLINE> for j , s in enumerate ( s0 ) : <NEWLINE> <INDENT> temp . append ( - int ( s ) ) <NEWLINE> <DEDENT> maze . append ( temp ) <NEWLINE> <DEDENT> maze . append ( [ - 1 ] * ( W + 4 ) ) <NEWLINE> maze . append ( [ - 1 ] * ( W + 4 ) ) <NEWLINE> <NL> def check55 ( i , j ) : <NEWLINE> <INDENT> cset = { ( ii , jj ) for ii in range ( i - 2 , i + 3 ) for jj in range ( j - 2 , j + 3 ) if maze [ ii ] [ jj ] == 0 } <NEWLINE> cset = cset - { ( i - 1 , j ) , ( i , j ) , ( i + 1 , j ) , ( i , j - 1 ) , ( i , j + 1 ) } <NEWLINE> return cset <NEWLINE> <NL> <DEDENT> def check ( i , j , delta ) : <NEWLINE> <INDENT> if delta [ 0 ] != 0 : <NEWLINE> <INDENT> ii = i + 3 * delta [ 0 ] <NEWLINE> for jj in range ( j - 2 , j + 3 ) : <NEWLINE> <INDENT> if maze [ ii ] [ jj ] == 0 : <NEWLINE> <INDENT> dset . add ( ( ii , jj ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> jj = j + 3 * delta [ 1 ] <NEWLINE> for ii in range ( i - 2 , i + 3 ) : <NEWLINE> <INDENT> if maze [ ii ] [ jj ] == 0 : <NEWLINE> <INDENT> dset . add ( ( ii , jj ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> k = 1 <NEWLINE> tempbfs = deque ( [ [ c [ 0 ] , c [ 1 ] , k ] ] ) <NEWLINE> flag = 0 <NEWLINE> while tempbfs : <NEWLINE> <INDENT> if flag == 1 : break <NEWLINE> p = tempbfs . popleft ( ) <NEWLINE> <NL> <COMMENT> <NL> if maze [ p [ 0 ] ] [ p [ 1 ] ] != 0 : continue <NEWLINE> maze [ p [ 0 ] ] [ p [ 1 ] ] = p [ 2 ] <NEWLINE> if p [ 0 ] == d [ 0 ] and p [ 1 ] == d [ 1 ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> k = p [ 2 ] <NEWLINE> break <NEWLINE> <DEDENT> temp = [ ( p [ 0 ] , p [ 1 ] ) ] <NEWLINE> dset = set ( ) <NEWLINE> while temp : <NEWLINE> <INDENT> p0 = temp . pop ( ) <NEWLINE> for delta in [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] : <NEWLINE> <INDENT> y = p0 [ 0 ] + delta [ 0 ] <NEWLINE> x = p0 [ 1 ] + delta [ 1 ] <NEWLINE> if maze [ y ] [ x ] != 0 : continue <NEWLINE> maze [ y ] [ x ] = p [ 2 ] <NEWLINE> if y == d [ 0 ] and x == d [ 1 ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> k = p [ 2 ] <NEWLINE> break <NEWLINE> <DEDENT> temp . append ( ( y , x ) ) <NEWLINE> check ( p0 [ 0 ] , p0 [ 1 ] , delta ) <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : break <NEWLINE> for l in dset : <NEWLINE> <INDENT> if maze [ l [ 0 ] ] [ l [ 1 ] ] == 0 : <NEWLINE> <INDENT> tempbfs . append ( [ l [ 0 ] , l [ 1 ] , p [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> dset = check55 ( p [ 0 ] , p [ 1 ] ) <NEWLINE> for l in dset : <NEWLINE> <INDENT> tempbfs . append ( [ l [ 0 ] , l [ 1 ] , p [ 2 ] + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( k - 1 if flag else - 1 ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> iwashi01 = 0 <NEWLINE> iwashi10 = 0 <NEWLINE> iwashi00 = 0 <NEWLINE> iwashi = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> iwashi00 += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> iwashi01 += 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> iwashi10 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> a //= g ; b //= g <NEWLINE> if a * b > 0 : <NEWLINE> <INDENT> if a < 0 and b < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> iwashi . setdefault ( ( a , b ) , [ 0 , 0 ] ) <NEWLINE> iwashi [ ( a , b ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> if a * b < 0 : <NEWLINE> <INDENT> if a < 0 and b > 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> a , b = - b , a <NEWLINE> iwashi . setdefault ( ( a , b ) , [ 0 , 0 ] ) <NEWLINE> iwashi [ ( a , b ) ] [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> r = 2 ** iwashi01 % mod - 1 + 2 ** iwashi10 % mod - 1 + 1 <NEWLINE> for s , t in iwashi . values ( ) : <NEWLINE> <INDENT> r *= 2 ** s % mod - 1 + 2 ** t % mod - 1 + 1 <NEWLINE> r %= mod <NEWLINE> <DEDENT> print ( ( r + iwashi00 - 1 ) % mod ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> <NL> ans , cnt , i = 0 , 0 , 0 <NEWLINE> while i < len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans += cnt <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> money = 1000 <NEWLINE> i = 0 <NEWLINE> while i < N - 1 : <NEWLINE> <INDENT> k = 1 <NEWLINE> while A [ i ] == A [ i + k ] : <NEWLINE> <INDENT> if i + k == N - 1 : <NEWLINE> <INDENT> i = i + k <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ i + k ] > A [ i ] : <NEWLINE> <INDENT> kabu = money // A [ i ] <NEWLINE> money -= kabu * A [ i ] <NEWLINE> money += kabu * A [ i + k ] <NEWLINE> i = i + k <NEWLINE> <DEDENT> elif A [ i + k ] < A [ i ] : <NEWLINE> <INDENT> i = i + k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lis = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> lis [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> print ( lis [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> b = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> child = { } <NEWLINE> parent = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> child [ a [ 0 ] ] = a [ 2 : ] <NEWLINE> for i in child [ a [ 0 ] ] : <NEWLINE> <INDENT> parent [ i ] = a [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> root = ( set ( child ) - set ( parent ) ) . pop ( ) <NEWLINE> depth = [ None ] * n <NEWLINE> depth [ root ] = 0 <NEWLINE> parent [ root ] = - 1 <NEWLINE> <NL> <NL> def dfs ( s ) : <NEWLINE> <INDENT> for i in child [ s ] : <NEWLINE> <INDENT> depth [ i ] = depth [ s ] + 1 <NEWLINE> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( root ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> node_type = <STRING> if parent [ i ] == - 1 else <STRING> if len ( child [ i ] ) == 0 else <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , n - 2 , 2 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] or a [ i ] == a [ i + 2 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ - 2 ] != a [ - 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ 0 ] != 0 or a [ 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , n - 2 , 2 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] or a [ i ] == a [ i + 2 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ - 2 ] != a [ - 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> if n % 2 == 0 : print ( 2 ** ( n // 2 ) % mod ) <NEWLINE> else : print ( 2 ** ( ( n - 1 ) // 2 ) % mod ) <NEWLINE>
x = [ ] <NEWLINE> y = [ ] <NEWLINE> i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b < a : <NEWLINE> <INDENT> stock = a <NEWLINE> a = b <NEWLINE> b = stock <NEWLINE> <DEDENT> x . append ( a ) <NEWLINE> y . append ( b ) <NEWLINE> if x [ i ] == 0 and y [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> for j in range ( i ) : <NEWLINE> <INDENT> print ( str ( x [ j ] ) , str ( y [ j ] ) ) <NEWLINE> <DEDENT>
<NL> from collections import defaultdict <NEWLINE> <NL> def submit ( ) : <NEWLINE> <INDENT> s = [ int ( c ) for c in input ( ) ] <NEWLINE> modp = 2019 <NEWLINE> <NL> curr = 0 <NEWLINE> modp_count = defaultdict ( int ) <NEWLINE> modp_count [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> base = 1 <NEWLINE> for c in reversed ( s ) : <NEWLINE> <INDENT> curr += base * c <NEWLINE> curr_mod = curr % modp <NEWLINE> ans += modp_count [ curr_mod ] <NEWLINE> modp_count [ curr_mod ] += 1 <NEWLINE> base *= 10 <NEWLINE> base %= modp <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> submit ( ) <NEWLINE>
A = [ ] <NEWLINE> for _ in range ( 12 ) : <NEWLINE> <INDENT> A . append ( [ 0 ] * 10 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ 3 * b - ( 3 - f ) - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , A [ i ] ) ) ) <NEWLINE> if i in [ 2 , 5 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> i = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> ans . append ( str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> <STRING> <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> ans . append ( str ( i ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> x = int ( x / 10 ) <NEWLINE> <NL> if x != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> if i <= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( ans ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> scs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if scs [ i ] > scs [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> if i is n - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> M = [ 0 ] <NEWLINE> mod = 0 <NEWLINE> ten = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> mod += ( int ( s ) * ten ) % 2019 <NEWLINE> mod %= 2019 <NEWLINE> M . append ( mod ) <NEWLINE> ten *= 10 <NEWLINE> ten %= 2019 <NEWLINE> <DEDENT> count = collections . Counter ( M ) <NEWLINE> print ( sum ( [ c * ( c - 1 ) // 2 for c in count . values ( ) ] ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> g = math . gcd ( c , d ) <NEWLINE> l = int ( c * d / g ) <NEWLINE> <NL> less_b = b - ( b // c + b // d - b // l ) <NEWLINE> less_a = ( a - 1 ) - ( ( a - 1 ) // c + ( a - 1 ) // d - ( a - 1 ) // l ) <NEWLINE> print ( less_b - less_a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for p in range ( 10 ) : <NEWLINE> <INDENT> s = S . find ( str ( p ) ) <NEWLINE> if s == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for q in range ( 10 ) : <NEWLINE> <INDENT> t = S . find ( str ( q ) , s + 1 ) <NEWLINE> if t == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> u = S . find ( str ( r ) , t + 1 ) <NEWLINE> if u != - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for n in range ( N - 1 ) : <NEWLINE> <INDENT> t = A [ n ] - A [ n + 1 ] <NEWLINE> if t <= 0 : continue <NEWLINE> else : <NEWLINE> <INDENT> A [ n + 1 ] += t <NEWLINE> ans += t <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = l [ 0 ] <NEWLINE> <NL> minn = min ( l ) <NEWLINE> <NL> if ( minn == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , len ( l ) ) : <NEWLINE> <INDENT> ans = ans * l [ i ] <NEWLINE> <NL> if ans >= 1000000000000000001 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans >= 1000000000000000001 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> max_ = 0 <NEWLINE> <NL> def dfs ( A ) : <NEWLINE> <INDENT> global max_ <NEWLINE> ans = 0 <NEWLINE> last = A [ - 1 ] <NEWLINE> if len ( A ) == n + 1 : <NEWLINE> <INDENT> for i in range ( q ) : <NEWLINE> <INDENT> if A [ b [ i ] ] - A [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> ans += d [ i ] <NEWLINE> <DEDENT> <DEDENT> max_ = max ( max_ , ans ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( last , m + 1 ) : <NEWLINE> <INDENT> dfs ( A + [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> aa , bb , cc , dd = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( aa ) <NEWLINE> b . append ( bb ) <NEWLINE> c . append ( cc ) <NEWLINE> d . append ( dd ) <NEWLINE> <NL> <DEDENT> dfs ( [ 1 ] ) <NEWLINE> <NL> print ( max_ ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = input ( ) <NEWLINE> M = int ( N ) <NEWLINE> <NL> A = 9 ** M <NEWLINE> a = int ( A ) <NEWLINE> B = 9 ** M <NEWLINE> b = int ( B ) <NEWLINE> C = 8 ** M <NEWLINE> c = int ( C ) <NEWLINE> D = a + b - c <NEWLINE> d = int ( D ) <NEWLINE> E = 10 ** M <NEWLINE> e = int ( E ) <NEWLINE> F = e - d <NEWLINE> f = int ( F ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif M == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif M == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <NL> <DEDENT> elif M >= 3 : <NEWLINE> <INDENT> print ( f % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def append_factor ( f , p ) : <NEWLINE> <INDENT> if p not in f : <NEWLINE> <INDENT> f [ p ] = 0 <NEWLINE> <DEDENT> f [ p ] += 1 <NEWLINE> <NL> <DEDENT> def append_factors ( n , f , p ) : <NEWLINE> <INDENT> num_factors = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> num_factors += 1 <NEWLINE> n //= p <NEWLINE> <DEDENT> if num_factors != 0 : <NEWLINE> <INDENT> f [ p ] = num_factors <NEWLINE> <DEDENT> return n <NEWLINE> <NL> <DEDENT> def factors ( n ) : <NEWLINE> <INDENT> l = int ( math . sqrt ( n ) ) + 1 <NEWLINE> ret = { } <NEWLINE> n = append_factors ( n , ret , 2 ) <NEWLINE> n = append_factors ( n , ret , 3 ) <NEWLINE> i = 6 <NEWLINE> while i * i <= n + 1 : <NEWLINE> <INDENT> p1 , p2 = i - 1 , i + 1 <NEWLINE> n = append_factors ( n , ret , i - 1 ) <NEWLINE> n = append_factors ( n , ret , i + 1 ) <NEWLINE> i += 6 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> append_factor ( ret , n ) <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def minimum_sum ( x ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> n = int ( math . sqrt ( x ) ) <NEWLINE> while ( n + 1 ) * ( n + 2 ) <= 2 * x : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> return n <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> fs = factors ( N ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for f in fs : <NEWLINE> <INDENT> ans += minimum_sum ( fs [ f ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> links = [ ] <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> L , R = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> links . append ( ( L , R ) ) <NEWLINE> <NL> <DEDENT> links = sorted ( links , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> count = [ 1 ] <NEWLINE> sub = [ 0 , 1 ] <NEWLINE> subtotal = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = 0 <NEWLINE> for l , r in links : <NEWLINE> <INDENT> r2 = i - l + 1 <NEWLINE> l2 = i - r <NEWLINE> if l2 < 0 : <NEWLINE> <INDENT> l2 = 0 <NEWLINE> <DEDENT> if r2 >= 0 : <NEWLINE> <INDENT> v += sub [ r2 ] - sub [ l2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> count . append ( v % 998244353 ) <NEWLINE> subtotal = ( subtotal + v ) % 998244353 <NEWLINE> sub . append ( subtotal ) <NEWLINE> <NL> <DEDENT> print ( count [ - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> max = 1e+18 <NEWLINE> is_zero = False <NEWLINE> ans = 1 <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( int ( a [ i ] ) == 0 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> is_zero = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not is_zero : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= int ( a [ i ] ) <NEWLINE> if ans > max : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( n , a_n , q , bc_n ) : <NEWLINE> <INDENT> m = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a_n [ i ] not in m : <NEWLINE> <INDENT> m [ a_n [ i ] ] = 0 <NEWLINE> <DEDENT> m [ a_n [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> s = [ ] <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> b , c = bc_n [ j ] <NEWLINE> <NL> diff = 0 <NEWLINE> if b in m : <NEWLINE> <INDENT> diff = m [ b ] * c - m [ b ] * b <NEWLINE> if c not in m : <NEWLINE> <INDENT> m [ c ] = m [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ c ] += m [ b ] <NEWLINE> <DEDENT> del m [ b ] <NEWLINE> <NL> <DEDENT> ts = 0 <NEWLINE> if len ( s ) == 0 : <NEWLINE> <INDENT> for k , v in m . items ( ) : <NEWLINE> <INDENT> ts += k * v <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ts = s [ - 1 ] + diff <NEWLINE> <DEDENT> s . append ( ts ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> a_n = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> q = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> bc_n = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> bc_n . append ( ( b , c ) ) <NEWLINE> <DEDENT> for i in main ( n , a_n , q , bc_n ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> L = len ( str ( X ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> Y = 0 <NEWLINE> <NL> for l in range ( L ) : <NEWLINE> <INDENT> Y += 7 * 10 ** l <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> for i in range ( 1000000 ) : <NEWLINE> <INDENT> Y = Y % X <NEWLINE> <COMMENT> <NL> <NL> if Y == 0 : <NEWLINE> <INDENT> ans = L + i <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Z = Y * 10 + 7 <NEWLINE> if Z == Y : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y = Z <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * N <NEWLINE> <NL> x = 1 <NEWLINE> while x * x <= N : <NEWLINE> <INDENT> y = 1 <NEWLINE> while x * x + y * y + x * y <= N : <NEWLINE> <INDENT> z = 1 <NEWLINE> while z * z + x * x + y * y + x * y + z * y + z * x <= N : <NEWLINE> <INDENT> a [ z * z + x * x + y * y + x * y + z * y + z * x - 1 ] += 1 <NEWLINE> z += 1 <NEWLINE> <DEDENT> y += 1 <NEWLINE> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT> for n in a : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = [ ] <NEWLINE> y = { } <NEWLINE> <NL> for i , elem in enumerate ( a ) : <NEWLINE> <INDENT> x . append ( i + a [ i ] ) <NEWLINE> y [ i - a [ i ] ] = y . get ( i - a [ i ] , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> ans += y . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> syou = x // d <NEWLINE> if k <= syou : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - syou <NEWLINE> x = x % d <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - d ) ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> <NL> cnts = [ 0 ] * 2019 <NEWLINE> cnts [ 0 ] = 1 <NEWLINE> num = 0 <NEWLINE> d = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> num += int ( i ) * d <NEWLINE> d *= 10 <NEWLINE> num %= 2019 <NEWLINE> d %= 2019 <NEWLINE> cnts [ num ] += 1 <NEWLINE> <NL> <DEDENT> for j in cnts : <NEWLINE> <INDENT> ans += j * ( j - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> flag = True <NEWLINE> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> result = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( i , len ( t ) + i ) : <NEWLINE> <INDENT> if s [ j ] == t [ j - i ] : <NEWLINE> <NL> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> result . append ( tmp ) <NEWLINE> <NL> <DEDENT> print ( len ( t ) - max ( result ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dp = [ - 1 for i in range ( a [ - 1 ] ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] - 1 ] == - 1 : <NEWLINE> <INDENT> dp [ a [ i ] - 1 ] = 1 <NEWLINE> for j in range ( 2 , a [ - 1 ] // a [ i ] + 1 ) : <NEWLINE> <INDENT> dp [ a [ i ] * j - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> elif dp [ a [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> dp [ a [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( dp ) ) : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_dict = dict ( ) <NEWLINE> b_dict = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = h_list [ i ] + i <NEWLINE> b = i - h_list [ i ] <NEWLINE> if not a in a_dict : <NEWLINE> <INDENT> a_dict [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ a ] += 1 <NEWLINE> <DEDENT> if not b in b_dict : <NEWLINE> <INDENT> b_dict [ b ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_dict [ b ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for a in a_dict : <NEWLINE> <INDENT> if a in b_dict : <NEWLINE> <INDENT> count += a_dict [ a ] * b_dict [ a ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> line_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = sum ( line_a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> numbers = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> for i in line_a : <NEWLINE> <INDENT> numbers [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = c - b <NEWLINE> stock = numbers [ b ] <NEWLINE> numbers [ c ] += numbers [ b ] <NEWLINE> numbers [ b ] = 0 <NEWLINE> total += stock * d <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( a , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> T = 1e18 <NEWLINE> arr = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = 1 <NEWLINE> for a in arr : <NEWLINE> <INDENT> A *= a <NEWLINE> if A < 0 : <NEWLINE> <INDENT> A = - 1 <NEWLINE> <DEDENT> if A > T : <NEWLINE> <INDENT> A = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
x , n = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> nums = set ( [ int ( x ) for x in input ( ) . split ( <STRING> ) ] ) <NEWLINE> <NL> dist = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if not x - dist in nums : <NEWLINE> <INDENT> print ( x - dist ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> if not x + dist in nums : <NEWLINE> <INDENT> print ( x + dist ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> dist += 1 <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def subtraction ( x ) : <NEWLINE> <INDENT> return x - 1 <NEWLINE> <DEDENT> A = list ( map ( subtraction , A ) ) <NEWLINE> <NL> <COMMENT> <NL> R = [ 0 ] * n <NEWLINE> R [ 0 ] = 1 <NEWLINE> ROUTE = [ 0 ] <NEWLINE> t = A [ 0 ] <NEWLINE> while R [ t ] == 0 : <NEWLINE> <INDENT> ROUTE . append ( t ) <NEWLINE> R [ t ] = 1 <NEWLINE> t = A [ t ] <NEWLINE> <NL> <DEDENT> x = ROUTE . index ( t ) <COMMENT> <NEWLINE> length = len ( ROUTE ) - x <NEWLINE> <NL> if k < x : <NEWLINE> <INDENT> print ( ROUTE [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - x <NEWLINE> s = k % length <NEWLINE> print ( ROUTE [ x + s ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> x *= i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> <NL> for i , j in enumerate ( H ) : <NEWLINE> <INDENT> L . append ( i + j ) <NEWLINE> R . append ( i - j ) <NEWLINE> <NL> <DEDENT> b = Counter ( R ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in L : <NEWLINE> <INDENT> ans += b . get ( i , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> import numpy as np <NEWLINE> n , W = map ( int , input ( ) . split ( ) ) <NEWLINE> w = [ ] <NEWLINE> v = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w_ , v_ = map ( int , input ( ) . split ( ) ) <NEWLINE> w . append ( w_ ) <NEWLINE> v . append ( v_ ) <NEWLINE> <DEDENT> dp = np . zeros ( W + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ w [ i ] : ] = np . maximum ( dp [ : - w [ i ] ] + v [ i ] , dp [ w [ i ] : ] ) <NEWLINE> <DEDENT> print ( dp [ W ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> A = [ int ( A [ i ] ) for i in range ( N - 1 ) ] <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def main_v2 ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> f_list = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> ans = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if ans <= N : <NEWLINE> <INDENT> f_list [ ans - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( f_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main_v2 ( ) <NEWLINE> <DEDENT>
from copy import copy <NEWLINE> from collections import Counter <NEWLINE> from scipy . special import comb <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> S = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> S += comb ( C [ i ] , 2 , exact = True ) <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> p = A [ k ] <NEWLINE> ans = S - comb ( C [ p ] , 2 , exact = True ) + comb ( C [ p ] - 1 , 2 , exact = True ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> n1 = np . count_nonzero ( ( A >> i ) & 1 ) <NEWLINE> n0 = n - n1 <NEWLINE> ans += ( 2 ** i ) * n1 * n0 % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> a_sum = sum ( a ) <NEWLINE> a_sum -= a [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * a_sum <NEWLINE> a_sum -= a [ i + 1 ] <NEWLINE> <DEDENT> ans %= 1000000007 <NEWLINE> print ( ans ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( n , m , q , sss , xy ) : <NEWLINE> <INDENT> dp1 = np . zeros ( ( n + 1 , m + 1 ) , dtype = np . int64 ) <NEWLINE> dpv = np . zeros ( ( n + 1 , m + 1 ) , dtype = np . int64 ) <NEWLINE> dph = np . zeros ( ( n + 1 , m + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if sss [ i , j ] == 1 : <NEWLINE> <INDENT> dp1 [ i + 1 , j + 1 ] = 1 <NEWLINE> <NL> if i > 0 and sss [ i - 1 , j ] == 1 : <NEWLINE> <INDENT> dpv [ i + 1 , j + 1 ] = 1 <NEWLINE> <DEDENT> if j > 0 and sss [ i , j - 1 ] == 1 : <NEWLINE> <INDENT> dph [ i + 1 , j + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> dp1 [ i , j ] += dp1 [ i , j - 1 ] <NEWLINE> dpv [ i , j ] += dpv [ i , j - 1 ] <NEWLINE> dph [ i , j ] += dph [ i , j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp1 [ i , j ] += dp1 [ i - 1 , j ] <NEWLINE> dpv [ i , j ] += dpv [ i - 1 , j ] <NEWLINE> dph [ i , j ] += dph [ i - 1 , j ] <NEWLINE> <NL> <DEDENT> <DEDENT> buf = np . zeros ( q , dtype = np . int64 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x1 = xy [ i * 4 + 0 ] <NEWLINE> y1 = xy [ i * 4 + 1 ] <NEWLINE> x2 = xy [ i * 4 + 2 ] <NEWLINE> y2 = xy [ i * 4 + 3 ] <NEWLINE> cnt1 = dp1 [ x2 ] [ y2 ] - dp1 [ x1 - 1 ] [ y2 ] - dp1 [ x2 ] [ y1 - 1 ] + dp1 [ x1 - 1 ] [ y1 - 1 ] <NEWLINE> ver1 = dpv [ x2 ] [ y2 ] - dpv [ x1 ] [ y2 ] - dpv [ x2 ] [ y1 - 1 ] + dpv [ x1 ] [ y1 - 1 ] <NEWLINE> hor1 = dph [ x2 ] [ y2 ] - dph [ x1 - 1 ] [ y2 ] - dph [ x2 ] [ y1 ] + dph [ x1 - 1 ] [ y1 ] <NEWLINE> buf [ i ] = cnt1 - ver1 - hor1 <NEWLINE> <NL> <DEDENT> return buf <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> <NL> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> sss = np . array ( [ list ( map ( int , input ( ) ) ) for _ in range ( n ) ] , dtype = np . int8 ) <NEWLINE> xy = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( n , m , q , sss , xy ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> up = 10 ** 5 + 1 <NEWLINE> lo = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if lo < l [ i ] [ 0 ] : <NEWLINE> <INDENT> lo = l [ i ] [ 0 ] <NEWLINE> <DEDENT> if up > l [ i ] [ 1 ] : <NEWLINE> <INDENT> up = l [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i >= lo and i <= up : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
<NL> k = int ( input ( ) ) <NEWLINE> <NL> gcd_cnt = { } <NEWLINE> <NL> for n in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> div_all = ( k // n ) ** 3 <NEWLINE> div_dup = 0 <NEWLINE> for m in range ( n * 2 , k + 1 , n ) : <NEWLINE> <INDENT> div_dup += gcd_cnt [ m ] <NEWLINE> <DEDENT> gcd_cnt [ n ] = div_all - div_dup <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for gcd in gcd_cnt . keys ( ) : <NEWLINE> <INDENT> ans += gcd * gcd_cnt [ gcd ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> array_sum_square = sum ( A ) ** 2 <NEWLINE> individual_square_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> individual_square_sum += A [ i ] ** 2 <NEWLINE> <DEDENT> print ( ( array_sum_square - individual_square_sum ) // 2 % ( 7 + 10 ** 9 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a = i + 1 <NEWLINE> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> def make_adjlist_d ( n , edges ) : <NEWLINE> <INDENT> res = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> res [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> res [ edge [ 1 ] ] . append ( edge [ 0 ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def make_adjlist_nond ( n , edges ) : <NEWLINE> <INDENT> res = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> res [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def cmb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // math . factorial ( r ) // math . factorial ( n - r ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> A = NLI ( ) <NEWLINE> Q = NI ( ) <NEWLINE> querys = [ NLI ( ) for _ in range ( Q ) ] <NEWLINE> res = sum ( A ) <NEWLINE> Dic = dict ( Counter ( A ) ) <NEWLINE> for b , c in querys : <NEWLINE> <INDENT> Dic . setdefault ( c , 0 ) <NEWLINE> Dic . setdefault ( b , 0 ) <NEWLINE> gap = ( c - b ) * Dic [ b ] <NEWLINE> Dic [ c ] += Dic [ b ] <NEWLINE> del Dic [ b ] <NEWLINE> res += gap <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> LineData = np . int64 ( sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> <NL> LineData = LineData . reshape ( - 1 , 3 ) <NEWLINE> A , B , C = LineData [ : N ] . T <NEWLINE> D , E , F = LineData [ N : ] . T <NEWLINE> X = np . unique ( np . concatenate ( [ D , [ - INF , 0 , INF ] ] ) ) <NEWLINE> Y = np . unique ( np . concatenate ( [ C , [ - INF , 0 , INF ] ] ) ) <NEWLINE> A = np . searchsorted ( X , A ) <NEWLINE> B = np . searchsorted ( X , B , <STRING> ) - 1 <NEWLINE> C = np . searchsorted ( Y , C ) <NEWLINE> D = np . searchsorted ( X , D ) <NEWLINE> E = np . searchsorted ( Y , E ) <NEWLINE> F = np . searchsorted ( Y , F , <STRING> ) - 1 <NEWLINE> <NL> area = cal_area ( A , B , C , D , E , F , X , Y ) <NEWLINE> <NL> if area == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( area ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ njit <NEWLINE> def cal_area ( A , B , C , D , E , F , X , Y ) : <NEWLINE> <INDENT> LenX = len ( X ) <NEWLINE> LenY = len ( Y ) <NEWLINE> <NL> LineX = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> LineY = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> <NL> for x1 , x2 , y in zip ( A , B , C ) : <NEWLINE> <INDENT> for x in range ( x1 , x2 ) : <NEWLINE> <INDENT> LineY [ x ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for x , y1 , y2 in zip ( D , E , F ) : <NEWLINE> <INDENT> for y in range ( y1 , y2 ) : <NEWLINE> <INDENT> LineX [ x ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> visit = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> x = np . searchsorted ( X , 0 , <STRING> ) - 1 <NEWLINE> y = np . searchsorted ( Y , 0 , <STRING> ) - 1 <NEWLINE> visit [ x ] [ y ] = True <NEWLINE> area = 0 <NEWLINE> queue = [ ( x , y ) ] <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> x , y = queue . pop ( ) <NEWLINE> <NL> if x == 0 or x == LenX - 1 or y == 0 or y == LenY - 1 : <NEWLINE> <INDENT> area = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> area += ( X [ x + 1 ] - X [ x ] ) * ( Y [ y + 1 ] - Y [ y ] ) <NEWLINE> <NL> if not LineX [ x ] [ y ] and not visit [ x - 1 ] [ y ] : <NEWLINE> <INDENT> visit [ x - 1 ] [ y ] = True <NEWLINE> queue . append ( ( x - 1 , y ) ) <NEWLINE> <DEDENT> if not LineY [ x ] [ y ] and not visit [ x ] [ y - 1 ] : <NEWLINE> <INDENT> visit [ x ] [ y - 1 ] = True <NEWLINE> queue . append ( ( x , y - 1 ) ) <NEWLINE> <DEDENT> if not LineX [ x + 1 ] [ y ] and not visit [ x + 1 ] [ y ] : <NEWLINE> <INDENT> visit [ x + 1 ] [ y ] = True <NEWLINE> queue . append ( ( x + 1 , y ) ) <NEWLINE> <DEDENT> if not LineY [ x ] [ y + 1 ] and not visit [ x ] [ y + 1 ] : <NEWLINE> <INDENT> visit [ x ] [ y + 1 ] = True <NEWLINE> queue . append ( ( x , y + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return area <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> sys . exit ( ) <NEWLINE>
import numpy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> res = [ 0 ] * N <NEWLINE> res [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> res [ i + 1 ] = res [ i ] + A [ i + 1 ] <NEWLINE> <NL> <DEDENT> sum_A = sum ( A ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( sum_A - res [ i ] ) <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = { } <NEWLINE> R = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L . setdefault ( i - a [ i ] , 0 ) <NEWLINE> R . setdefault ( i + a [ i ] , 0 ) <NEWLINE> L [ i - a [ i ] ] += 1 <NEWLINE> R [ i + a [ i ] ] += 1 <NEWLINE> <NL> if ( i - a [ i ] in R ) : <NEWLINE> <INDENT> ans += R [ i - a [ i ] ] <NEWLINE> <COMMENT> <NL> <DEDENT> if ( i + a [ i ] in L ) : <NEWLINE> <INDENT> ans += L [ i + a [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> nums = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in nums : <NEWLINE> <INDENT> nums [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums [ a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in nums : <NEWLINE> <INDENT> s -= nums [ b ] * b <NEWLINE> s += nums [ b ] * c <NEWLINE> if c in nums : <NEWLINE> <INDENT> nums [ c ] += nums [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums [ c ] = nums [ b ] <NEWLINE> <DEDENT> nums [ b ] = 0 <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> <COMMENT> <NL> d = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> d . append ( a [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> e = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] == n : <NEWLINE> <INDENT> e . append ( a [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( e ) & set ( d ) ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> graph [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> visited = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> def DFS ( a , b , c ) : <NEWLINE> <INDENT> for i , j in graph [ b ] : <NEWLINE> <INDENT> if ( i != a ) : <NEWLINE> <INDENT> visited [ i ] = c + j <NEWLINE> DFS ( b , i , c + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> DFS ( - 1 , K - 1 , 0 ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( visited [ x - 1 ] + visited [ y - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> class DisjointSets : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . ranks = [ 0 ] * self . size <NEWLINE> self . roots = [ 0 ] * self . size <NEWLINE> for x in range ( self . size ) : <NEWLINE> <INDENT> self . _make_set ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> def _make_set ( self , x ) : <NEWLINE> <INDENT> self . roots [ x ] = x <NEWLINE> self . ranks [ x ] = 0 <NEWLINE> <NL> <DEDENT> def _link ( self , x , y ) : <NEWLINE> <INDENT> if self . ranks [ x ] > self . ranks [ y ] : <NEWLINE> <INDENT> self . roots [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roots [ x ] = y <NEWLINE> if self . ranks [ x ] == self . ranks [ y ] : <NEWLINE> <INDENT> self . ranks [ y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def _find_set ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if x != self . roots [ x ] : <NEWLINE> <INDENT> self . roots [ x ] = self . _find_set ( self . roots [ x ] ) <NEWLINE> <NL> <DEDENT> return self . roots [ x ] <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> self . _link ( self . _find_set ( x ) , self . _find_set ( y ) ) <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . _find_set ( x ) == self . _find_set ( y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ds = DisjointSets ( n ) <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> query , x , y = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> if query == 0 : <NEWLINE> <INDENT> ds . unite ( x , y ) <NEWLINE> <DEDENT> elif query == 1 : <NEWLINE> <INDENT> if ds . same ( x , y ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> S_h = list ( input ( ) ) <NEWLINE> S . append ( S_h ) <NEWLINE> <NL> <DEDENT> d = [ - 1 , 1 ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> for j in range ( 2 ) : <NEWLINE> <INDENT> hs = h + d [ i ] <NEWLINE> ws = w + d [ j ] <NEWLINE> if 0 <= hs < H and 0 <= ws < W : <NEWLINE> <INDENT> ls . append ( S [ hs ] [ w ] ) <NEWLINE> ls . append ( S [ h ] [ ws ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if <STRING> not in ls : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> num_lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_counts = dict ( ) <NEWLINE> length = len ( set ( num_lists ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if length > k : <NEWLINE> <INDENT> d = Counter ( ) <NEWLINE> d . update ( num_lists ) <NEWLINE> count_sorted = list ( d . values ( ) ) <NEWLINE> count_sorted . sort ( ) <NEWLINE> for i in range ( length - k ) : <NEWLINE> <INDENT> ans += count_sorted [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> import collections <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> c2 = sorted ( c . values ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( len ( c ) - K ) : <NEWLINE> <INDENT> sum += c2 [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> while 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> : break <NEWLINE> if s . find ( <STRING> ) < 0 : a , b = s , <STRING> <NEWLINE> else : <NEWLINE> <INDENT> a , b = s . split ( <STRING> ) <NEWLINE> if a == <STRING> : a = <STRING> <NEWLINE> if b == <STRING> : b = <STRING> <NEWLINE> <DEDENT> k = 10 ** len ( b ) <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> if a > 255 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> sa = format ( a , <STRING> ) <NEWLINE> sb = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> b *= 2 <NEWLINE> if b >= k : sb += <STRING> <NEWLINE> else : sb += <STRING> <NEWLINE> b %= k <NEWLINE> <DEDENT> if b == 0 : print ( sa , <STRING> , sb , sep = <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> next_s = ( ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , <NEWLINE> <INDENT> ( - 1 , 0 ) , ( 1 , 0 ) , <NEWLINE> ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> def DFS ( x , y ) : <NEWLINE> <INDENT> if not ( 0 <= x < W and 0 <= y < H ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if map_ [ y ] [ x ] == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> map_ [ y ] [ x ] = 0 <NEWLINE> <NL> for dx , dy in next_s : <NEWLINE> <INDENT> DFS ( x + dx , y + dy ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> W , H = map ( int , input ( ) . split ( ) ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> map_ = [ list ( map ( int , input ( ) . split ( ) ) ) for h in range ( H ) ] <NEWLINE> island_num = 0 <NEWLINE> for x in range ( W ) : <NEWLINE> <INDENT> for y in range ( H ) : <NEWLINE> <INDENT> if map_ [ y ] [ x ] == 1 : <NEWLINE> <INDENT> DFS ( x , y ) <NEWLINE> island_num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( island_num ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> t_all , a_all = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> t_all = t <NEWLINE> a_all = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t >= t_all and a >= a_all : <NEWLINE> <INDENT> t_all , a_all = t , a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff1 , diff2 = 0 , 0 <NEWLINE> diff1 = t_all // t if t_all % t == 0 else t_all // t + 1 <NEWLINE> diff2 = a_all // a if a_all % a == 0 else a_all // a + 1 <NEWLINE> max_diff = max ( diff1 , diff2 ) <NEWLINE> t_all = t * max_diff <NEWLINE> a_all = a * max_diff <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t_all + a_all ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> P = 2019 <NEWLINE> N = len ( S ) <NEWLINE> num = [ 0 ] * P <NEWLINE> num [ 0 ] = 1 <NEWLINE> c = 0 <NEWLINE> ans = 0 <NEWLINE> dgt = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> c = ( c + int ( S [ i ] ) * dgt ) % P <NEWLINE> dgt *= 10 <NEWLINE> dgt %= P <NEWLINE> ans += num [ c ] <NEWLINE> num [ c ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ d [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> if a [ 0 ] == 1 and d [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i - 1 ] ** a [ i ] <NEWLINE> ans %= 998244353 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b <= n : <NEWLINE> <INDENT> print ( math . floor ( ( a * ( b - 1 ) ) / b ) - a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT> elif b > n : <NEWLINE> <INDENT> print ( math . floor ( ( a * ( n ) ) / b ) - a * math . floor ( ( n ) / b ) ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P . sort ( ) <NEWLINE> Q = [ i - 1 for i in range ( - 10 , 111 ) ] <NEWLINE> for a in P : <NEWLINE> <INDENT> Q . remove ( a ) <NEWLINE> <DEDENT> Q1 = [ abs ( b - X ) for b in Q ] <NEWLINE> print ( Q [ Q1 . index ( min ( Q1 ) ) ] ) <NEWLINE> <DEDENT>
print ( * { <STRING> , <STRING> } - { input ( ) } ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = 0 <NEWLINE> ca = [ tmp ] <NEWLINE> for x in a : <NEWLINE> <INDENT> tmp += x <NEWLINE> ca . append ( tmp ) <NEWLINE> <DEDENT> ans = float ( <STRING> ) <NEWLINE> bidx = 0 <NEWLINE> cidx = 1 <NEWLINE> didx = 2 <NEWLINE> eidx = 3 <NEWLINE> <NL> for didx in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> p = ca [ cidx ] - ca [ bidx ] <NEWLINE> q = ca [ didx ] - ca [ cidx ] <NEWLINE> r = ca [ eidx ] - ca [ didx ] <NEWLINE> s = ca [ - 1 ] - ca [ eidx ] <NEWLINE> <NL> np = ca [ cidx + 1 ] - ca [ bidx ] <NEWLINE> nq = ca [ didx ] - ca [ cidx + 1 ] <NEWLINE> while cidx + 1 < didx and abs ( p - q ) > abs ( np - nq ) : <NEWLINE> <INDENT> cidx += 1 <NEWLINE> p , q = np , nq <NEWLINE> np = ca [ cidx + 1 ] - ca [ bidx ] <NEWLINE> nq = ca [ didx ] - ca [ cidx + 1 ] <NEWLINE> <NL> <DEDENT> nr = ca [ eidx + 1 ] - ca [ didx ] <NEWLINE> ns = ca [ - 1 ] - ca [ eidx + 1 ] <NEWLINE> while eidx + 1 < n and abs ( r - s ) > abs ( nr - ns ) : <NEWLINE> <INDENT> eidx += 1 <NEWLINE> r , s = nr , ns <NEWLINE> nr = ca [ eidx + 1 ] - ca [ didx ] <NEWLINE> ns = ca [ - 1 ] - ca [ eidx + 1 ] <NEWLINE> <NL> <DEDENT> ans = min ( ans , max ( p , q , r , s ) - min ( p , q , r , s ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import copy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> sum = sum * i <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> ans = 0 <NEWLINE> on = 1 <NEWLINE> dif = 1 <NEWLINE> if x in p : <NEWLINE> <INDENT> now = p . index ( x ) <NEWLINE> while on == 1 : <NEWLINE> <INDENT> if now - dif < 0 : <NEWLINE> <INDENT> ans = x - dif <NEWLINE> on = 0 <NEWLINE> <DEDENT> elif p [ now - dif ] != x - dif : <NEWLINE> <INDENT> ans = x - dif <NEWLINE> on = 0 <NEWLINE> <DEDENT> elif now + dif == n : <NEWLINE> <INDENT> ans = x + dif <NEWLINE> on = 0 <NEWLINE> <DEDENT> elif p [ now + dif ] != x + dif : <NEWLINE> <INDENT> ans = x + dif <NEWLINE> on = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dif += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> sumA = sum ( A ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def f ( A , s , res ) : <NEWLINE> <INDENT> if res [ 0 ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if s == 0 : <NEWLINE> <INDENT> res [ 0 ] = True <NEWLINE> return <NEWLINE> <DEDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> f ( A [ i + 1 : ] , s - a , res ) <NEWLINE> <NL> <DEDENT> <DEDENT> for mi in m : <NEWLINE> <INDENT> res = [ False ] <NEWLINE> <NL> if mi <= sumA : <NEWLINE> <INDENT> f ( A , mi , res ) <NEWLINE> <NL> <DEDENT> if res [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( len ( [ i for i in range ( n ) if h [ i ] >= k ] ) ) <NEWLINE>
from collections import deque <NEWLINE> dq = deque ( ) <NEWLINE> for mak in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> com = input ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : dq . appendleft ( com [ 1 ] ) <NEWLINE> elif com [ 0 ] == <STRING> : dq . popleft ( ) <NEWLINE> elif com [ 0 ] == <STRING> : dq . pop ( ) <NEWLINE> else : <NEWLINE> <INDENT> if com [ 1 ] in dq : <NEWLINE> <INDENT> dq . remove ( com [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( dq ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> G [ int ( a ) - 1 ] += [ int ( b ) - 1 ] <NEWLINE> G [ int ( b ) - 1 ] += [ int ( a ) - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> dist = [ - 1 for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> count = 0 <NEWLINE> def bfs ( G ) : <NEWLINE> <INDENT> global count <NEWLINE> <COMMENT> <NL> if not que : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> v = que . popleft ( ) <NEWLINE> <NL> for nv in G [ v ] : <NEWLINE> <INDENT> if dist [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv ] = dist [ v ] + 1 <NEWLINE> que . append ( nv ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> bfs ( G ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if dist [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que = deque ( [ i ] ) <NEWLINE> dist [ i ] = 0 <NEWLINE> bfs ( G ) <NEWLINE> if ans < count : <NEWLINE> <INDENT> ans = count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> cs = { 0 : 1 } <NEWLINE> <NL> result = 0 <NEWLINE> <NL> n = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> c = int ( S [ - i - 1 ] ) <NEWLINE> n += c * pow ( 10 , i , 2019 ) <NEWLINE> m = n % 2019 <NEWLINE> if m in cs : <NEWLINE> <INDENT> result += cs [ m ] <NEWLINE> cs [ m ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cs [ m ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
S = input ( ) <NEWLINE> i = 0 <NEWLINE> n = len ( S ) <NEWLINE> while i <= n - 5 : <NEWLINE> <INDENT> if S [ i : i + 5 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> if S [ i : i + 2 ] == <STRING> and S [ i : i + 5 ] != <STRING> : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> <DEDENT> elif S [ i : i + 5 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> if S [ i : i + 1 ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i != len ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> multiple = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for j in range ( n - k ) : <NEWLINE> <INDENT> if a [ j + k ] > a [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
from copy import deepcopy <NEWLINE> <NL> def count ( A ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt += ( a * ( a - 1 ) ) // 2 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_A = max ( A ) <NEWLINE> <NL> count_A = [ 0 ] * ( max_A + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> count_A [ a ] += 1 <NEWLINE> <NL> <DEDENT> combi_A = 0 <NEWLINE> <NL> for c in count_A : <NEWLINE> <INDENT> combi_A += ( c * ( c - 1 ) ) // 2 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( combi_A - ( count_A [ a ] * ( count_A [ a ] - 1 ) - ( count_A [ a ] - 1 ) * ( count_A [ a ] - 2 ) ) // 2 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> return N , S <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , S : str ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> S_i_list = [ ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> S_i = S [ i ] <NEWLINE> if S_i in S_i_list : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S_j_list = [ ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> S_j = S [ j ] <NEWLINE> if S_j in S_j_list : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += len ( set ( S [ j + 1 : N ] ) ) <NEWLINE> S_j_list . append ( S_j ) <NEWLINE> <DEDENT> S_i_list . append ( S_i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N , S = get_input ( ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , S ) <NEWLINE> <DEDENT>
<NL> s = str ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> a = s . find ( <STRING> ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 1 <NEWLINE> if a < 2 : <NEWLINE> <INDENT> while ( s [ a + 1 ] == <STRING> ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> a += 1 <NEWLINE> if a == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * ( ( N // i ) + 1 ) * ( N // i ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a >= 1 and a <= n : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
from math import atan , degrees <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if pow ( a , 2 ) * b == x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif b * pow ( a , 2 ) / 2 <= x : <NEWLINE> <INDENT> print ( 90 - degrees ( atan ( ( a / 2 ) / ( b - x / pow ( a , 2 ) ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 90 - degrees ( atan ( ( 2 * x / ( a * b ) ) / b ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> n = int ( input ( ) . strip ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) . strip ( ) ) ) <NEWLINE> <NL> <DEDENT> min = a [ 0 ] <NEWLINE> cnt = - 1000000000 <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> x = a [ j ] - min <NEWLINE> if cnt < x : <NEWLINE> <INDENT> cnt = x <NEWLINE> <COMMENT> <NL> <DEDENT> if min > a [ j ] : <NEWLINE> <INDENT> min = a [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> l = [ 0 for i in range ( n ) ] <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> s = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ; <NEWLINE> if s <= n : <NEWLINE> <INDENT> l [ s - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
mod = 1000000007 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i , v in enumerate ( a ) : <NEWLINE> <INDENT> b [ i + 1 ] = ( b [ i ] + v ) % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ( ( ( a [ i ] * ( b [ n ] - b [ i + 1 ] ) ) % mod ) + ans ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> gcd = 0 <NEWLINE> gcd1 = 0 <NEWLINE> gcd2 = 0 <NEWLINE> gcd3 = 0 <NEWLINE> <NL> input_d31 = input ( ) <NEWLINE> K = int ( input_d31 ) <NEWLINE> <NL> gcd1 = sum ( range ( 1 , K + 1 ) ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> gcd2 += math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> gcdd = math . gcd ( i , j ) <NEWLINE> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> gcd3 += math . gcd ( gcdd , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> gcd = gcd1 + gcd2 * 6 + gcd3 * 6 <NEWLINE> <NL> print ( gcd ) <NEWLINE>
import sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> m = a [ - 1 ] + 1 <NEWLINE> ava = [ 0 ] * m <NEWLINE> for rep in a : <NEWLINE> <INDENT> ava [ rep ] += 1 <NEWLINE> if ava [ rep ] == 1 : <NEWLINE> <INDENT> for item in range ( 2 * rep , m , rep ) : <NEWLINE> <INDENT> ava [ item ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ava . count ( 1 ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> a = list ( IL ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> def sqmatrix ( n ) : <NEWLINE> <INDENT> return [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def magicsq ( m ) : <NEWLINE> <INDENT> n = len ( m ) <NEWLINE> j = int ( n / 2 ) <NEWLINE> i = j + 1 <NEWLINE> for num in range ( 1 , n ** 2 + 1 ) : <NEWLINE> <INDENT> m [ i ] [ j ] = num <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> i = i % n <NEWLINE> j = j % n <NEWLINE> if m [ i ] [ j ] != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> j -= 1 <NEWLINE> <DEDENT> if j < 0 : <NEWLINE> <INDENT> j = n - 1 <NEWLINE> <DEDENT> i = i % n <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> for line in stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sm = sqmatrix ( n ) <NEWLINE> for row in magicsq ( sm ) : print ( <STRING> . join ( map ( lambda x : str ( x ) . rjust ( 4 , <STRING> ) , row ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> MAX = a [ - 1 ] <NEWLINE> l = [ 0 ] * ( MAX + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if l [ a [ i ] ] == 1 : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> for g in range ( a [ i ] , MAX + 1 , a [ i ] ) : <NEWLINE> <INDENT> l [ g ] = 10 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total_xor = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> total_xor ^= a <NEWLINE> <NL> <DEDENT> result = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> result += [ str ( total_xor ^ a ) ] <NEWLINE> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> <NL> def eratosthenes ( lim ) : <NEWLINE> <INDENT> is_p = [ 1 ] * lim <NEWLINE> is_p [ 0 ] = 1 <NEWLINE> is_p [ 1 ] = 1 <NEWLINE> <NL> for i in set ( a ) : <NEWLINE> <INDENT> if is_p [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , lim , i ) : <NEWLINE> <INDENT> is_p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return is_p <NEWLINE> <NL> <DEDENT> lim = 10 ** 6 + 5 <NEWLINE> is_p = eratosthenes ( lim ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if is_p [ i ] == 1 and c [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> n = 0 <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> n = ( n * 10 + 7 ) % k <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 1 <NEWLINE> <NL> if 0 in alist : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in alist : <NEWLINE> <INDENT> num = num * a <NEWLINE> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = math . pi * ( pow ( r , 2 ) ) <NEWLINE> circ = math . pi * 2 * r <NEWLINE> print ( <STRING> . format ( area , circ ) ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> args = [ ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> args . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> r_sum = 0 <NEWLINE> for j in args [ i ] : <NEWLINE> <INDENT> r_sum += j <NEWLINE> <DEDENT> args [ i ] . append ( r_sum ) <NEWLINE> <NL> <DEDENT> l_row = [ ] <NEWLINE> <NL> for k in range ( c + 1 ) : <NEWLINE> <INDENT> c_sum = 0 <NEWLINE> for l in range ( r ) : <NEWLINE> <INDENT> c_sum += args [ l ] [ k ] <NEWLINE> <DEDENT> l_row . append ( c_sum ) <NEWLINE> <NL> <DEDENT> for m in range ( r ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , args [ m ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , l_row ) ) ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for item in A : <NEWLINE> <INDENT> m *= item <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> u = 0 <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> for i , n in enumerate ( map ( int , s ) ) : <NEWLINE> <INDENT> u = ( u + n * pow ( 10 , len ( s ) - i , 2019 ) ) % 2019 <NEWLINE> l [ u ] += 1 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> import math <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> <COMMENT> <NL> import decimal <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000001 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> <NL> lcm = a [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> lcm = lcm // math . gcd ( lcm , i ) * i <NEWLINE> <DEDENT> lcm %= MOD <NEWLINE> <NL> ans = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans += lcm * pow ( ai , MOD - 2 , MOD ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> <NL> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> b = math . gcd ( a , k ) * 6 <NEWLINE> if i == j and j == k : <NEWLINE> <INDENT> b = int ( b / 6 ) <NEWLINE> <DEDENT> elif i == j or j == k or i == k : <NEWLINE> <INDENT> b = int ( b / 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> cnt += b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> b = 10 ** 9 + 7 <NEWLINE> A = list ( ( int ( x ) for x in input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> sum += a <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum -= A [ i ] <NEWLINE> ans += A [ i ] * sum <NEWLINE> <DEDENT> print ( ans % b ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> f = factorization ( n ) <NEWLINE> l = len ( f ) <NEWLINE> x = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> x += int ( ( - 1 + math . sqrt ( 1 + 8 * f [ i ] [ 1 ] ) ) // 2 ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) . strip ( ) ) <NEWLINE> C = [ c for c in input ( ) . strip ( ) ] <NEWLINE> <NL> if <STRING> not in C or <STRING> not in C : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> import sys ; sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> i = 0 <NEWLINE> j = len ( C ) - 1 <NEWLINE> while i < j : <NEWLINE> <INDENT> while C [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> while C [ j ] == <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if i > j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> C [ i ] = <STRING> <NEWLINE> C [ j ] = <STRING> <NEWLINE> i += 1 <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
class path_compressed_quick_union : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . data = [ i for i in range ( n ) ] <NEWLINE> self . size = [ 1 for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def root ( self , p ) : <NEWLINE> <INDENT> while p != self . data [ p ] : <NEWLINE> <INDENT> self . data [ p ] = self . data [ self . data [ p ] ] <NEWLINE> p = self . data [ p ] <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def connected ( self , p , q ) : <NEWLINE> <INDENT> return self . root ( p ) == self . root ( q ) <NEWLINE> <NL> <DEDENT> def union ( self , p , q ) : <NEWLINE> <INDENT> proot = self . root ( p ) <NEWLINE> qroot = self . root ( q ) <NEWLINE> if self . size [ proot ] < self . size [ qroot ] : <NEWLINE> <INDENT> self . data [ qroot ] = proot <NEWLINE> self . size [ qroot ] += self . size [ proot ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . data [ proot ] = qroot <NEWLINE> self . size [ proot ] += self . size [ qroot ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = path_compressed_quick_union ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( uf . root ( i ) ) <NEWLINE> <DEDENT> print ( len ( set ( ans ) ) - 1 ) <NEWLINE>
import math <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> <NL> def prime_factorization ( num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> result = dict ( ) <NEWLINE> <NL> N = num <NEWLINE> <NL> x = 2 <NEWLINE> while x <= int ( math . sqrt ( num ) ) + 1 : <NEWLINE> <INDENT> if ( num % x ) == 0 : <NEWLINE> <INDENT> count = 0 <NEWLINE> while ( num % x ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> num = num / x <NEWLINE> <NL> <DEDENT> result [ x ] = count <NEWLINE> <NL> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT> if num != 1 : <NEWLINE> <INDENT> result [ num ] = 1 <NEWLINE> <NL> <DEDENT> if result == [ ] : <NEWLINE> <INDENT> result [ N ] = 1 <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> result = prime_factorization ( N ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for value in result . values ( ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> while ( value - c ) >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> value -= c <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> for j in range ( 1 , 102 ) : <NEWLINE> <INDENT> for k in range ( 1 , 102 ) : <NEWLINE> <INDENT> if ( i * i + j * j + k * k + i * j + j * k + i * k ) <= n : <NEWLINE> <INDENT> a [ i * i + j * j + k * k + i * j + j * k + i * k ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for x in a [ 1 : ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import itertools <COMMENT> <NEWLINE> import fractions <NEWLINE> import copy <NEWLINE> import bisect <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> from operator import itemgetter <NEWLINE> from sys import stdin <NEWLINE> <COMMENT> <NL> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> from collections import Counter <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> j = 0 <NEWLINE> k = 0 <NEWLINE> n = 3 <NEWLINE> r = 1 <NEWLINE> a = [ 0 ] * 5 <NEWLINE> b = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <STRING> <NEWLINE> <NL> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> k = ( ( A * x ) // B ) - A * ( x // B ) <NEWLINE> print ( k ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
line = input ( ) . split ( ) <NEWLINE> a = int ( line [ 0 ] ) <NEWLINE> b = int ( line [ 1 ] ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = input ( ) . split ( ) <NEWLINE> <NL> M = 1 <NEWLINE> if <STRING> in A : <NEWLINE> <INDENT> M = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> a = int ( a ) <NEWLINE> M *= a <NEWLINE> if M > 1000000000000000000 : <NEWLINE> <INDENT> M = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( M ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G1 = [ [ ] for _ in range ( N ) ] <NEWLINE> G2 = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : continue <NEWLINE> G1 [ a ] . append ( b ) <NEWLINE> G2 [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( a0 ) : <NEWLINE> <INDENT> global order <NEWLINE> todo = [ ~ a0 , a0 ] <NEWLINE> while todo : <NEWLINE> <INDENT> a = todo . pop ( ) <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> seen [ a ] = 1 <NEWLINE> for b in G1 [ a ] : <NEWLINE> <INDENT> if seen [ b ] : continue <NEWLINE> todo . append ( ~ b ) <NEWLINE> todo . append ( b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if postorder [ ~ a ] == - 1 : <NEWLINE> <INDENT> postorder [ ~ a ] = order <NEWLINE> order += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> def dfs2 ( v ) : <NEWLINE> <INDENT> todo = [ v ] <NEWLINE> seen [ v ] = 1 <NEWLINE> cc = [ v ] <NEWLINE> while todo : <NEWLINE> <INDENT> v = todo . pop ( ) <NEWLINE> for next_v in G2 [ v ] : <NEWLINE> <INDENT> if seen [ next_v ] : continue <NEWLINE> seen [ next_v ] = 1 <NEWLINE> todo . append ( next_v ) <NEWLINE> cc . append ( next_v ) <NEWLINE> <DEDENT> <DEDENT> return cc <NEWLINE> <NL> <DEDENT> seen = [ 0 ] * N <NEWLINE> postorder = [ - 1 ] * N <NEWLINE> order = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if seen [ i ] : continue <NEWLINE> dfs ( i ) <NEWLINE> <NL> <DEDENT> seen = [ 0 ] * N <NEWLINE> scc = [ ] <NEWLINE> for i , _ in sorted ( enumerate ( postorder ) , key = lambda x : x [ 1 ] , reverse = True ) : <NEWLINE> <INDENT> if seen [ i ] : continue <NEWLINE> cc = dfs2 ( i ) <NEWLINE> scc . append ( cc ) <NEWLINE> <NL> <DEDENT> print ( len ( scc ) ) <NEWLINE> for cc in scc : <NEWLINE> <INDENT> print ( len ( cc ) , * cc ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> S = input ( ) + <STRING> <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> moveX , moveY = [ ] , [ ] <NEWLINE> if S [ 0 ] == <STRING> : moveX . append ( 0 ) <NEWLINE> move = { 0 : moveX , 1 : moveY } <NEWLINE> direct = 0 <NEWLINE> step = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> if step > 0 : <NEWLINE> <INDENT> move [ direct ] . append ( step ) <NEWLINE> step = 0 <NEWLINE> <DEDENT> direct ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if possible ( x , moveX [ 1 : ] , moveX [ 0 ] ) and possible ( y , moveY ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def possible ( target , move , offset = 0 ) : <NEWLINE> <INDENT> l = len ( move ) <NEWLINE> dp = [ defaultdict ( lambda : False ) for _ in range ( l + 1 ) ] <NEWLINE> <COMMENT> <NL> dp [ 0 ] [ 0 ] = True <NEWLINE> for i , m in enumerate ( move ) : <NEWLINE> <INDENT> for key in dp [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ key + m ] = True <NEWLINE> dp [ i + 1 ] [ key - m ] = True <NEWLINE> <DEDENT> <DEDENT> return dp [ l ] [ target - offset ] <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> li = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if li [ i ] > limit : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * li [ i ] <NEWLINE> limit = limit / li [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> c = sum ( a ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c -= a [ i ] <NEWLINE> s += a [ i ] * c <NEWLINE> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> a_max = max ( a ) <NEWLINE> <NL> check = [ 0 ] * ( a_max + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if check [ i ] != 0 : <NEWLINE> <INDENT> check [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> if check [ i ] == 0 : <NEWLINE> <INDENT> check [ i ] = 1 <NEWLINE> for j in range ( 1 , a_max // i ) : <NEWLINE> <INDENT> check [ ( j + 1 ) * i ] = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( check . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> if a [ i ] in d : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in d . keys ( ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> Items = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> from collections import defaultdict as dd <NEWLINE> Bag = dd ( lambda : 0 ) <NEWLINE> Bag [ 0 ] = 0 <NEWLINE> for w , v in Items : <NEWLINE> <INDENT> temp = [ ( key + w , Bag [ key ] + v ) for key in Bag if key + w <= W ] <NEWLINE> for key , value in temp : <NEWLINE> <INDENT> Bag [ key ] = max ( Bag [ key ] , value ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( Bag . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> item = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> row = [ 0 ] * h <NEWLINE> col = [ 0 ] * w <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = item [ i ] <NEWLINE> row [ x - 1 ] += 1 <NEWLINE> col [ y - 1 ] += 1 <NEWLINE> <DEDENT> mr , mc = max ( row ) , max ( col ) <NEWLINE> xr = set ( [ i for i in range ( h ) if row [ i ] == mr ] ) <NEWLINE> xc = set ( [ i for i in range ( w ) if col [ i ] == mc ] ) <NEWLINE> check = len ( xr ) * len ( xc ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> r , c = item [ i ] <NEWLINE> if r - 1 in xr and c - 1 in xc : <NEWLINE> <INDENT> check -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( mr + mc if check > 0 else mr + mc - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( a ) <NEWLINE> <NL> for k in a : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> maxn = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for k in a : <NEWLINE> <INDENT> ans *= k <NEWLINE> if ans > maxn : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( cnt [ i + 1 ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> assert n >= 2 <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> assert len ( a ) == n <NEWLINE> ap = Counter ( [ i + x for i , x in enumerate ( a ) ] ) <NEWLINE> am = Counter ( [ i - x for i , x in enumerate ( a ) ] ) <NEWLINE> count = sum ( [ v * ap . get ( k , 0 ) for k , v in am . items ( ) if k >= 1 ] ) <NEWLINE> print ( count ) <NEWLINE>
<COMMENT> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , point ) : <NEWLINE> <INDENT> self . n = point <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> def Insert ( t , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = t <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . n < x . n : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> if y == None : <NEWLINE> <INDENT> return z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if z . n < y . n : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return t <NEWLINE> <NL> <DEDENT> <DEDENT> def Find ( t , p ) : <NEWLINE> <INDENT> if t . n == p : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif t . left != None and t . n > p : <NEWLINE> <INDENT> a = Find ( t . left , p ) <NEWLINE> <DEDENT> elif t . right != None and t . n < p : <NEWLINE> <INDENT> a = Find ( t . right , p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def Delete ( t , p ) : <NEWLINE> <INDENT> if t . left != None and t . left . n == p : <NEWLINE> <INDENT> if t . left . left == None and t . left . right == None : <NEWLINE> <INDENT> t . left = None <NEWLINE> <DEDENT> elif t . left . left == None and t . left . right != None : <NEWLINE> <INDENT> t . left = t . left . right <NEWLINE> <DEDENT> elif t . left . left != None and t . left . right == None : <NEWLINE> <INDENT> t . left = t . left . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = newPoint ( t . left . right ) <NEWLINE> Delete ( t , a ) <NEWLINE> t . left . n = a <NEWLINE> <DEDENT> <DEDENT> elif t . right != None and t . right . n == p : <NEWLINE> <INDENT> if t . right . left == None and t . right . right == None : <NEWLINE> <INDENT> t . right = None <NEWLINE> <DEDENT> elif t . right . left == None and t . right . right != None : <NEWLINE> <INDENT> t . right = t . right . right <NEWLINE> <DEDENT> elif t . right . left != None and t . right . right == None : <NEWLINE> <INDENT> t . right = t . right . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = newPoint ( t . right . right ) <NEWLINE> Delete ( t , a ) <NEWLINE> t . right . n = a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if t . n > p and t . left != None : <NEWLINE> <INDENT> Delete ( t . left , p ) <NEWLINE> <DEDENT> elif t . n < p and t . right != None : <NEWLINE> <INDENT> Delete ( t . right , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def newPoint ( t ) : <NEWLINE> <INDENT> if t . left != None : <NEWLINE> <INDENT> a = newPoint ( t . left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = t . n <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> def Pre ( t , l ) : <NEWLINE> <INDENT> l . append ( str ( t . n ) ) <NEWLINE> if t . left != None : <NEWLINE> <INDENT> Pre ( t . left , l ) <NEWLINE> <DEDENT> if t . right != None : <NEWLINE> <INDENT> Pre ( t . right , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> def In ( t , l ) : <NEWLINE> <INDENT> if t . left != None : <NEWLINE> <INDENT> In ( t . left , l ) <NEWLINE> <DEDENT> l . append ( str ( t . n ) ) <NEWLINE> if t . right != None : <NEWLINE> <INDENT> In ( t . right , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> def BST3 ( A , n ) : <NEWLINE> <INDENT> tree = None <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> PreAns = [ ] <NEWLINE> InAns = [ ] <NEWLINE> Pre ( tree , PreAns ) <NEWLINE> In ( tree , InAns ) <NEWLINE> print ( <STRING> + <STRING> . join ( InAns ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( PreAns ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ i ] . split ( <STRING> ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> point = int ( A [ i ] . split ( <STRING> ) [ 1 ] ) <NEWLINE> if Find ( tree , point ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A [ i ] . split ( <STRING> ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> point = int ( A [ i ] . split ( <STRING> ) [ 1 ] ) <NEWLINE> Delete ( tree , point ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = Node ( int ( A [ i ] . split ( <STRING> ) [ 1 ] ) ) <NEWLINE> tree = Insert ( tree , z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( input ( ) ) <NEWLINE> <DEDENT> BST3 ( A , n ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> def devisor ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n < 2 or n % 2 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif pow ( 2 , n - 1 , n ) == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> c += devisor ( x ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
from Queue import Queue <NEWLINE> mv = ( ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ) <NEWLINE> while True : <NEWLINE> <INDENT> X , Y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if X == Y == 0 : break <NEWLINE> tx , ty = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> kx , ky = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> tx , ty , kx , ky = tx - 1 , ty - 1 , kx - 1 , ky - 1 <NEWLINE> D = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( Y ) ] <NEWLINE> Q = Queue ( ) <NEWLINE> Q . put ( ( tx , ty , kx , ky , 0 ) ) <NEWLINE> visited = set ( ) <NEWLINE> visited . add ( ( tx , ty , kx , ky ) ) <NEWLINE> while not Q . empty ( ) : <NEWLINE> <INDENT> tx , ty , kx , ky , t = Q . get ( ) <NEWLINE> if t >= 100 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if tx == kx and ty == ky : <NEWLINE> <INDENT> print t <NEWLINE> break <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> dtx , dty = tx + mv [ i ] [ 0 ] , ty + mv [ i ] [ 1 ] <NEWLINE> dkx , dky = kx - mv [ i ] [ 0 ] , ky - mv [ i ] [ 1 ] <NEWLINE> if dtx < 0 or dtx >= X or dty < 0 or dty >= Y : <NEWLINE> <INDENT> dtx , dty = tx , ty <NEWLINE> <DEDENT> if dkx < 0 or dkx >= X or dky < 0 or dky >= Y : <NEWLINE> <INDENT> dkx , dky = kx , ky <NEWLINE> <DEDENT> if D [ dty ] [ dtx ] == 1 : <NEWLINE> <INDENT> dtx , dty = tx , ty <NEWLINE> <DEDENT> if D [ dky ] [ dkx ] == 1 : <NEWLINE> <INDENT> dkx , dky = kx , ky <NEWLINE> <DEDENT> if ( dtx , dty , dkx , dky ) not in visited : <NEWLINE> <INDENT> visited . add ( ( dtx , dty , dkx , dky ) ) <NEWLINE> Q . put ( ( dtx , dty , dkx , dky , t + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sum ( a ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> A = A - a [ i ] <NEWLINE> b = ( a [ i ] * A ) % ( 10 ** 9 + 7 ) <NEWLINE> s = s + b <NEWLINE> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if R == B == G == 1 and N == 3000 : <NEWLINE> <INDENT> print ( 4504501 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> li = [ R , G , B ] <NEWLINE> ans = 0 <NEWLINE> li . sort ( reverse = True ) <NEWLINE> <NL> <NL> for i in range ( N // li [ 0 ] + 1 ) : <NEWLINE> <INDENT> for j in range ( N // li [ 1 ] + 1 ) : <NEWLINE> <INDENT> t = N - i * li [ 0 ] - j * li [ 1 ] <NEWLINE> if t >= 0 and t % li [ 2 ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 100000 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> <NL> n = k ( ) <NEWLINE> a = l ( ) <NEWLINE> <NL> ruiseki = list ( itertools . accumulate ( a ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( ruiseki [ - 1 ] - ruiseki [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = [ 0 ] * N <COMMENT> <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> m [ i - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( m [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 1 ] <NEWLINE> x = 1 <NEWLINE> cnt = [ 0 for n in range ( N ) ] <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> y = A [ x - 1 ] <NEWLINE> l . append ( y ) <NEWLINE> cnt [ y - 1 ] += 1 <NEWLINE> x = y <NEWLINE> if cnt [ y - 1 ] == 2 : <NEWLINE> <INDENT> value = y <NEWLINE> temp = n <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for m in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ m ] == value : <NEWLINE> <INDENT> bias = m <NEWLINE> mul = temp - bias + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if bias > K : <NEWLINE> <INDENT> print ( l [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ bias + ( K - bias ) % mul ] ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> from numpy import int64 <NEWLINE> @ njit ( <STRING> , cache = True ) <NEWLINE> def func ( s , x ) : <NEWLINE> <INDENT> last = [ 0 ] * 26 <NEWLINE> score = 0 <NEWLINE> for i , v in enumerate ( x , 1 ) : <NEWLINE> <INDENT> last [ v ] = i <NEWLINE> c = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> c += s [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> score = score + s [ i * 26 + v ] - c <NEWLINE> <DEDENT> return score <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> d , * s = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> s = int64 ( s ) <NEWLINE> x = s [ 26 * - ~ d : d * 27 + 26 ] - 1 <NEWLINE> for d , q in s [ 27 * - ~ d : ] . reshape ( - 1 , 2 ) : <NEWLINE> <INDENT> x [ d - 1 ] = q - 1 <NEWLINE> print ( func ( s , x ) ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
class Edge : <NEWLINE> <INDENT> def __init__ ( self , dst , weight ) : <NEWLINE> <INDENT> self . dst , self . weight = dst , weight <NEWLINE> <NL> <DEDENT> def __lt__ ( self , e ) : <NEWLINE> <INDENT> return self . weight > e . weight <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Graph : <NEWLINE> <INDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . V = V <NEWLINE> self . E = [ [ ] for _ in range ( V ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , src , dst , weight ) : <NEWLINE> <INDENT> self . E [ src ] . append ( Edge ( dst , weight ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class HeavyLightDecomposition : <NEWLINE> <INDENT> def __init__ ( self , g , root = 0 ) : <NEWLINE> <INDENT> self . g = g <NEWLINE> self . vid , self . head , self . heavy , self . parent = [ 0 ] * g . V , [ - 1 ] * g . V , [ - 1 ] * g . V , [ - 1 ] * g . V <NEWLINE> self . dfs ( root ) <NEWLINE> self . bfs ( root ) <NEWLINE> <NL> <DEDENT> def dfs ( self , root ) : <NEWLINE> <INDENT> stack = [ ( root , - 1 ) ] <NEWLINE> sub , max_sub = [ 1 ] * self . g . V , [ ( 0 , - 1 ) ] * self . g . V <NEWLINE> used = [ False ] * self . g . V <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> v , par = stack . pop ( ) <NEWLINE> if not used [ v ] : <NEWLINE> <INDENT> used [ v ] = True <NEWLINE> self . parent [ v ] = par <NEWLINE> stack . append ( ( v , par ) ) <NEWLINE> stack . extend ( ( e . dst , v ) for e in self . g . E [ v ] if e . dst != par ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if par != - 1 : <NEWLINE> <INDENT> sub [ par ] += sub [ v ] <NEWLINE> max_sub [ par ] = max ( max_sub [ par ] , ( sub [ v ] , v ) ) <NEWLINE> <DEDENT> self . heavy [ v ] = max_sub [ v ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def bfs ( self , root = 0 ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> k , que = 0 , deque ( [ root ] ) <NEWLINE> while que : <NEWLINE> <INDENT> r = v = que . popleft ( ) <NEWLINE> while v != - 1 : <NEWLINE> <INDENT> self . vid [ v ] , self . head [ v ] = k , r <NEWLINE> for e in self . g . E [ v ] : <NEWLINE> <INDENT> if e . dst != self . parent [ v ] and e . dst != self . heavy [ v ] : <NEWLINE> <INDENT> que . append ( e . dst ) <NEWLINE> <DEDENT> <DEDENT> k += 1 <NEWLINE> v = self . heavy [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def lca ( self , u , v ) : <NEWLINE> <INDENT> while self . head [ u ] != self . head [ v ] : <NEWLINE> <INDENT> if self . vid [ u ] > self . vid [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> v = self . parent [ self . head [ v ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . vid [ u ] > self . vid [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> <DEDENT> return u <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> g = Graph ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for c in map ( int , input ( ) . split ( ) [ 1 : ] ) : <NEWLINE> <INDENT> g . add_edge ( i , c , 1 ) <NEWLINE> g . add_edge ( c , i , 1 ) <NEWLINE> <DEDENT> <DEDENT> hld = HeavyLightDecomposition ( g ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( hld . lca ( u , v ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> list . append ( s ) <NEWLINE> <NL> <DEDENT> set_list = set ( list ) <NEWLINE> print ( len ( set_list ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> print ( int ( A * x / B ) - A * int ( x / B ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> if S [ a ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ a ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif S [ a ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> all = r * g * b <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( all - count ) <NEWLINE>
str = list ( input ( ) ) <NEWLINE> for i in range ( len ( str ) ) : <NEWLINE> <INDENT> if str [ i ] . islower ( ) : <NEWLINE> <INDENT> str [ i ] = str [ i ] . upper ( ) <NEWLINE> <DEDENT> elif str [ i ] . isupper ( ) : <NEWLINE> <INDENT> str [ i ] = str [ i ] . lower ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( str ) ) : <NEWLINE> <INDENT> print ( str [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def judge ( n ) : <NEWLINE> <INDENT> if n == 2 or n == 3 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i <= n / i : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> print ( sum ( map ( judge , ls ) ) ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> res = [ <STRING> if tail > top else <STRING> for top , tail in zip ( A , A [ K : ] ) ] <NEWLINE> print ( <STRING> . join ( res ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> r = False <NEWLINE> prefix = [ ] <NEWLINE> suffix = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> query = input ( ) <NEWLINE> if query == <STRING> : <NEWLINE> <INDENT> r ^= True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _ , f , c = query . split ( ) <NEWLINE> front = f == <STRING> <NEWLINE> <NL> if r ^ front : <NEWLINE> <INDENT> prefix . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suffix . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if r : <NEWLINE> <INDENT> S = <STRING> . join ( suffix [ : : - 1 ] ) + S [ : : - 1 ] + <STRING> . join ( prefix ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = <STRING> . join ( prefix [ : : - 1 ] ) + S + <STRING> . join ( suffix ) <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
from functools import reduce <NEWLINE> from operator import mul <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> lim = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> <NL> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > lim : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> red = 0 <NEWLINE> white = 0 <NEWLINE> count = 0 <NEWLINE> li = list ( input ( ) ) <NEWLINE> for i in li : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> red += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> checkw = 0 <NEWLINE> for i in range ( red ) : <NEWLINE> <INDENT> if li [ i ] == <STRING> : <NEWLINE> <INDENT> checkw += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> checkr = 0 <NEWLINE> for i in range ( white ) : <NEWLINE> <INDENT> if li [ i + red ] == <STRING> : <NEWLINE> <INDENT> checkr += 1 <NEWLINE> <DEDENT> <DEDENT> sa = checkw - checkr <NEWLINE> if sa == 0 : <NEWLINE> <INDENT> print ( checkr ) <NEWLINE> <DEDENT> elif sa > 0 : <NEWLINE> <INDENT> print ( checkr + sa ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( checkw + sa ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> N , M , Q = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> X = [ [ int ( n ) for n in input ( ) . split ( ) ] for _ in range ( Q ) ] <NEWLINE> ans = [ ] <NEWLINE> for A in combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> if A [ x [ 1 ] - 1 ] - A [ x [ 0 ] - 1 ] == x [ 2 ] : <NEWLINE> <INDENT> t += x [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans . append ( t ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> p . sort ( ) <NEWLINE> d = 10 ** 9 <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if d > abs ( i - x ) and i not in p : <NEWLINE> <INDENT> d = abs ( i - x ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( 0 , len ( l ) ) : <NEWLINE> <INDENT> d [ i + 1 ] = l [ i ] <NEWLINE> <DEDENT> ans = 1 <NEWLINE> s = set ( ) <NEWLINE> seq = [ ] <NEWLINE> e = 0 <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> ans = d [ ans ] <NEWLINE> if ans in s : <NEWLINE> <INDENT> seq . append ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( ans ) <NEWLINE> <DEDENT> seq . append ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> e = 1 <NEWLINE> <DEDENT> if e == 0 : <NEWLINE> <INDENT> b = seq . index ( seq [ - 1 ] ) <NEWLINE> rep = seq [ b : - 1 ] <NEWLINE> sl = len ( seq ) - seq . index ( seq [ - 1 ] ) - 1 <NEWLINE> k = k - b - 1 <NEWLINE> ans = seq [ b ] <NEWLINE> x = k % sl <NEWLINE> <COMMENT> <NL> print ( rep [ x ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( set ( a ) ) == 1 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> a1 = [ a [ x ] for x in range ( 0 , n , 2 ) ] <NEWLINE> l_a1 = len ( a1 ) <NEWLINE> a2 = [ a [ y ] for y in range ( 1 , n , 2 ) ] <NEWLINE> l_a2 = len ( a2 ) <NEWLINE> c1 = collections . Counter ( a1 ) <NEWLINE> c2 = collections . Counter ( a2 ) <NEWLINE> K_a1 = c1 . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> K_a2 = c2 . most_common ( ) [ 0 ] [ 0 ] <NEWLINE> F_a1 = c1 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> F_a2 = c2 . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> if K_a1 == K_a2 : <NEWLINE> <INDENT> if F_a1 > F_a2 : <NEWLINE> <INDENT> F_a2 = c2 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> elif F_a1 == F_a2 : <NEWLINE> <INDENT> if c1 . most_common ( ) [ 1 ] [ 1 ] > c2 . most_common ( ) [ 1 ] [ 1 ] : <NEWLINE> <INDENT> F_a1 = c1 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> F_a2 = c2 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> F_a1 = c1 . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ( l_a1 - F_a1 ) + ( l_a2 - F_a2 ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( 500 ) : <NEWLINE> <INDENT> num = i ** 5 <NEWLINE> a . append ( num ) <NEWLINE> <NL> <DEDENT> for i in range ( 500 ) : <NEWLINE> <INDENT> for j in range ( i , 500 ) : <NEWLINE> <INDENT> if a [ i ] - a [ j ] == x : <NEWLINE> <INDENT> ans = str ( i ) + <STRING> + str ( j ) <NEWLINE> break <NEWLINE> <DEDENT> elif a [ i ] + a [ j ] == x : <NEWLINE> <INDENT> ans = str ( i ) + <STRING> + str ( j ) <NEWLINE> break <NEWLINE> <DEDENT> elif a [ j ] - a [ i ] == x : <NEWLINE> <INDENT> ans = <STRING> + str ( i ) + <STRING> + str ( j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = 1 <NEWLINE> order = [ n ] <NEWLINE> order_set = set ( [ n ] ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> n = A [ n - 1 ] <NEWLINE> if n in order_set : <NEWLINE> <INDENT> Li = order . index ( n ) <NEWLINE> Ri = len ( order ) <NEWLINE> idx = Li + ( K - Li ) % ( Ri - Li ) <NEWLINE> print ( order [ idx ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> order . append ( n ) <NEWLINE> order_set . add ( n ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> <NL> s [ k - 1 ] = s [ k - 1 ] . lower ( ) <NEWLINE> a = <STRING> . join ( s ) <NEWLINE> <NL> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( - 2 , 102 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> m = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> m . append ( abs ( a [ i ] - x ) ) <NEWLINE> <NL> <DEDENT> miner = min ( m ) <NEWLINE> res = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if abs ( x - i ) == miner : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( res ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if N // B == 0 : <NEWLINE> <INDENT> ans_i = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_i = B * ( N // B ) - 1 <NEWLINE> <NL> <DEDENT> print ( ( A * ans_i ) // B - A * ( ans_i // B ) ) <NEWLINE>
import math <NEWLINE> from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxi = max ( a ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> div = [ 0 ] * ( maxi + 1 ) <NEWLINE> for n in a : <NEWLINE> <INDENT> div [ n ] += 1 <NEWLINE> if div [ n ] == 1 : <NEWLINE> <INDENT> for j in range ( n * 2 , maxi + 1 , n ) : <NEWLINE> <INDENT> div [ j ] += 100 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( div . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> num_list = [ ] <NEWLINE> len_num_list = 0 <NEWLINE> <NL> a = 0 <NEWLINE> end = False <NEWLINE> while ( not end ) : <NEWLINE> <INDENT> num_list . append ( pow ( a , 5 ) ) <NEWLINE> len_num_list += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( len_num_list ) : <NEWLINE> <INDENT> for j in range ( i , len_num_list ) : <NEWLINE> <INDENT> i_5div = num_list [ i ] <NEWLINE> j_5div = num_list [ j ] <NEWLINE> <NL> if i_5div - j_5div == x : <NEWLINE> <INDENT> print ( <STRING> . format ( i , j ) ) <NEWLINE> end = True <NEWLINE> break <NEWLINE> <DEDENT> if j_5div - i_5div == x : <NEWLINE> <INDENT> print ( <STRING> . format ( j , i ) ) <NEWLINE> end = True <NEWLINE> break <NEWLINE> <DEDENT> if i_5div + j_5div == x : <NEWLINE> <INDENT> print ( <STRING> . format ( i , j * ( - 1 ) ) ) <NEWLINE> end = True <NEWLINE> break <NEWLINE> <DEDENT> if j_5div + i_5div == x : <NEWLINE> <INDENT> print ( <STRING> . format ( j , i * ( - 1 ) ) ) <NEWLINE> end = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> A = sorted ( A , reverse = True ) <NEWLINE> <NL> if 0 not in A : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <COMMENT> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ a - 1 ] . append ( b ) <NEWLINE> E [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> dic = { } <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if not p - 1 in dic : <NEWLINE> <INDENT> dic [ p - 1 ] = x <NEWLINE> continue <NEWLINE> <DEDENT> dic [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> res = [ 0 for _ in range ( N ) ] <NEWLINE> def dfs ( p , s , ans ) : <NEWLINE> <INDENT> global res <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if s - 1 in dic : <NEWLINE> <INDENT> ans += dic [ s - 1 ] <NEWLINE> <NL> <DEDENT> res [ s - 1 ] = str ( ans ) <NEWLINE> if E [ s - 1 ] == [ p ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for e in E [ s - 1 ] : <NEWLINE> <INDENT> if e == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( s , e , ans ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 1 , 1 , 0 ) <NEWLINE> print ( <STRING> . join ( res ) ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> subs = [ 0 ] * N <NEWLINE> <NL> for boss in A : <NEWLINE> <INDENT> subs [ boss - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( subs [ i ] ) <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> R = [ X ] <NEWLINE> dr = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> dr [ i ] = 0 <NEWLINE> <DEDENT> m = min ( N , M ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> r = R [ - 1 ] <NEWLINE> r = r ** 2 % M <NEWLINE> if dr [ r ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> R . append ( r ) <NEWLINE> dr [ r ] = 1 <NEWLINE> <DEDENT> for i in range ( len ( R ) ) : <NEWLINE> <INDENT> if r == R [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> a = 0 <NEWLINE> b = sum ( R ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> a += R [ j ] <NEWLINE> b -= R [ j ] <NEWLINE> <DEDENT> n = len ( R ) - i <NEWLINE> t = N - i <NEWLINE> p = t // n <NEWLINE> q = t % n <NEWLINE> c = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> c += R [ i + j ] <NEWLINE> <DEDENT> ans = a + b * p + c <NEWLINE> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i , j in zip ( range ( K , N ) , range ( N - K ) ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i ] > A [ j ] else <STRING> ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if pow ( i , n , 10 ** 20 ) > p : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if p % pow ( i , n , 10 ** 20 ) == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> b = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> aa = np . zeros ( n + 1 , np . int64 ) <NEWLINE> ba = np . zeros ( m + 1 , np . int64 ) <NEWLINE> aa [ 1 : ] = a . cumsum ( ) <NEWLINE> ba [ 1 : ] = b . cumsum ( ) <NEWLINE> aa = aa [ aa <= k ] <NEWLINE> ba = ba [ ba <= k ] <NEWLINE> rs = np . searchsorted ( ba , k - aa , side = <STRING> ) - 1 <NEWLINE> rs += np . arange ( len ( aa ) ) <NEWLINE> r = rs . max ( ) <NEWLINE> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> count = max ( count , i + j ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> p = [ 0 ] * 1000 <NEWLINE> <NL> flag = False <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> p [ i ] = i ** 5 <NEWLINE> <NL> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 1000 ) : <NEWLINE> <INDENT> if p [ i ] - p [ j ] == X : <NEWLINE> <INDENT> a = i <NEWLINE> <NL> b = j <NEWLINE> flag = True <NEWLINE> <DEDENT> if p [ i ] + p [ j ] == X : <NEWLINE> <INDENT> a = i <NEWLINE> b = - j <NEWLINE> flag = True <NEWLINE> <NL> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> memo = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> min_k = float ( <STRING> ) <NEWLINE> min_k = min ( [ memo [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ] ) <NEWLINE> memo [ i ] = min_k <NEWLINE> <NL> <DEDENT> print ( memo [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for num in A : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mod = 998244353 <NEWLINE> <NL> class mod_combination : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . fac = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> self . fac [ i ] = ( self . fac [ i - 1 ] * i ) % mod <NEWLINE> <DEDENT> self . invmod = [ 1 ] * ( N + 1 ) <NEWLINE> self . invmod [ N ] = pow ( self . fac [ N ] , mod - 2 , mod ) <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> self . invmod [ i - 1 ] = ( self . invmod [ i ] * i ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def calc ( self , n , k ) : <COMMENT> <NEWLINE> <INDENT> return self . fac [ n ] * self . invmod [ k ] % mod * self . invmod [ n - k ] % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> C = mod_combination ( n ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> ans = ( ans + C . calc ( n - 1 , n - x - 1 ) * m * pow ( m - 1 , n - x - 1 , mod ) % mod ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 2001 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 0 <NEWLINE> dp [ 2 ] = 0 <NEWLINE> <NL> if s >= 3 : <NEWLINE> <INDENT> for i in range ( 3 , s + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 3 ] ) % MOD <NEWLINE> <DEDENT> print ( dp [ s ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> X , N = MI ( ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P = LI ( ) <NEWLINE> <NL> _min = 10 ** 9 <NEWLINE> ans = [ ] <NEWLINE> for p in range ( X + 1 ) : <NEWLINE> <INDENT> for i in [ - 1 , 1 ] : <NEWLINE> <INDENT> a = X + ( i * p ) <NEWLINE> if a not in P : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> d = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a ] . append ( b ) <NEWLINE> d [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> c = defaultdict ( int ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ p ] += x <NEWLINE> <NL> <DEDENT> ans = [ 0 for i in range ( N ) ] <NEWLINE> que = [ ( 1 , 0 , - 1 ) ] <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for v , x , par in que : <NEWLINE> <INDENT> x += c [ v ] <NEWLINE> ans [ v - 1 ] = str ( x ) <NEWLINE> for w in d [ v ] : <NEWLINE> <INDENT> if w != par : <NEWLINE> <INDENT> tmp . append ( ( w , x , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> que = tmp <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> day_cost = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> holidays = N - sum ( day_cost ) <NEWLINE> <NL> if holidays >= 0 : <NEWLINE> <INDENT> print ( holidays ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> total = list ( str ( N ) ) <NEWLINE> ntotal = 0 <NEWLINE> for i in range ( len ( total ) ) : <NEWLINE> <INDENT> ntotal += int ( total [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> if ntotal % 9 == 0 or ntotal == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . array ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> co = collections . Counter ( a ) <NEWLINE> s = 0 <NEWLINE> for k , v in co . items ( ) : <NEWLINE> <INDENT> s += k * v <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in co . keys ( ) : <NEWLINE> <INDENT> s += ( c - b ) * co [ b ] <NEWLINE> co [ c ] += co [ b ] <NEWLINE> co . pop ( b ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = list ( s ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> f = ( - ord ( s [ i ] ) + ord ( <STRING> ) + 1 ) % 26 <NEWLINE> if f <= k : <NEWLINE> <INDENT> l [ i ] = <STRING> <NEWLINE> k -= f <NEWLINE> <NL> <DEDENT> <DEDENT> k = k % 26 <NEWLINE> a = ord ( l [ - 1 ] ) + k <NEWLINE> if a > ord ( <STRING> ) : a -= 26 <NEWLINE> l [ - 1 ] = chr ( a ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for q in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for r in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( q , r ) <NEWLINE> for s in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( x , s ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> Ans = 0 <NEWLINE> for A in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for B in range ( - A , A ) : <NEWLINE> <INDENT> Tar = A ** 5 - B ** 5 <NEWLINE> if Tar == X : <NEWLINE> <INDENT> Ans = [ A , B ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Ans != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( * Ans ) <NEWLINE>
def do ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num . extend ( l ) <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in num : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <NL> <DEDENT> print ( do ( ) ) <NEWLINE>
<COMMENT> <NL> max_num = 1000000 <NEWLINE> is_prime_num = [ True for i in range ( max_num + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> is_prime_num [ 0 ] = False <NEWLINE> is_prime_num [ 1 ] = False <NEWLINE> end = int ( max_num ** .5 ) <NEWLINE> <NL> for i in range ( 2 , end + 1 ) : <NEWLINE> <INDENT> if is_prime_num [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , max_num + 1 , i ) : <NEWLINE> <INDENT> is_prime_num [ j ] = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> prime_cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if is_prime_num [ i ] : <NEWLINE> <INDENT> prime_cnt = prime_cnt + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( str ( prime_cnt ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if l [ i - 1 ] < l [ i + k - 1 ] else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i , tgt in enumerate ( a , 1 ) : <NEWLINE> <INDENT> if a [ tgt - 1 ] == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
import string <NEWLINE> s = { i : <STRING> . format ( c ) for i , c in zip ( string . ascii_uppercase + <STRING> , range ( 32 ) ) } <NEWLINE> code = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> data = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = <STRING> . join ( s [ c ] for c in data ) <NEWLINE> ans = tmp = <STRING> <NEWLINE> for c in d : <NEWLINE> <INDENT> tmp += c <NEWLINE> if tmp in code : <NEWLINE> <INDENT> ans += code [ tmp ] <NEWLINE> tmp = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
sm = [ False for i in range ( 300001 ) ] <NEWLINE> for i in range ( 6 , 300000 , 7 ) : <NEWLINE> <INDENT> sm [ i ] = sm [ i + 2 ] = True <NEWLINE> <NL> <DEDENT> msprices = [ ] <NEWLINE> <NL> for i in range ( 6 , 300000 , 7 ) : <NEWLINE> <INDENT> if sm [ i ] : <NEWLINE> <INDENT> msprices . append ( i ) <NEWLINE> for j in range ( 2 * i , 300000 , i ) : <NEWLINE> <INDENT> sm [ j ] = False <NEWLINE> <DEDENT> <DEDENT> if sm [ i + 2 ] : <NEWLINE> <INDENT> msprices . append ( i + 2 ) <NEWLINE> for j in range ( 2 * ( i + 2 ) , 300000 , i + 2 ) : <NEWLINE> <INDENT> sm [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for msp in msprices : <NEWLINE> <INDENT> if N % msp == 0 : <NEWLINE> <INDENT> ans . append ( msp ) <NEWLINE> <DEDENT> <DEDENT> print ( N , end = <STRING> ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def quicksort ( array ) : <NEWLINE> <INDENT> if len ( array ) < 2 : <NEWLINE> <INDENT> return array <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pivot = array [ 0 ] <NEWLINE> less = [ i for i in array [ 1 : ] if i <= pivot ] <NEWLINE> <NL> greater = [ i for i in array [ 1 : ] if i > pivot ] <NEWLINE> <NL> return quicksort ( less ) + [ pivot ] + quicksort ( greater ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> array = [ ] <NEWLINE> for _ in range ( 10 ) : <NEWLINE> <INDENT> array . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> sorted_array = quicksort ( array ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( sorted_array [ 9 - i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ - 1 ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> if s [ - 1 ] in <STRING> else <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> parent = [ - 1 ] * N <NEWLINE> <NL> <NL> def union ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> parent [ x ] = y <NEWLINE> <NL> <NL> <DEDENT> def find ( x ) : <NEWLINE> <INDENT> if parent [ x ] == - 1 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> res = parent [ x ] = find ( parent [ x ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( a - 1 , b - 1 ) <NEWLINE> <NL> <NL> <DEDENT> count = Counter ( find ( i ) for i in range ( N ) ) <NEWLINE> print ( count . most_common ( 1 ) [ 0 ] [ 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = [ a [ i ] - b [ i ] for i in range ( n ) ] <NEWLINE> if sum ( diff ) < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff . sort ( ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in diff : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> count += i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in diff [ : : - 1 ] : <NEWLINE> <INDENT> if count >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> yaku = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> if i in yaku : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N / i <= i : <NEWLINE> <INDENT> yaku . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> yaku . append ( i ) <NEWLINE> yaku . append ( N // i ) <NEWLINE> <DEDENT> elif N / i < i : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> yaku . sort ( ) <NEWLINE> ans = str ( yaku [ len ( yaku ) // 2 ] ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> ( N , M , K ) = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> fact = [ 1 ] * ( N + 1 ) <NEWLINE> factinv = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % MOD <NEWLINE> factinv [ i ] = pow ( fact [ i ] , MOD - 2 , MOD ) <NEWLINE> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> return fact [ n ] * factinv [ k ] * factinv [ n - k ] % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans += ( comb ( N - 1 , k ) * M * pow ( M - 1 , N - k - 1 , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for aa in a : <NEWLINE> <INDENT> ans *= aa <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , f , b = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] , key = lambda x : x [ 1 ] ) , 1 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] [ 0 ] <NEWLINE> if b > a [ i ] [ 1 ] : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if f == 1 else <STRING> ) <NEWLINE>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( N ) ] <NEWLINE> rank = [ 1 ] * ( N ) <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <COMMENT> <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return par . count ( find ( x ) ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : return 0 <NEWLINE> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ y ] = x <NEWLINE> <COMMENT> <NL> if par [ x ] == par [ y ] : <NEWLINE> <INDENT> rank [ x ] += rank [ y ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> group_count = 0 <NEWLINE> <NL> group_count = max ( rank ) <NEWLINE> <NL> <COMMENT> <NL> print ( group_count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> start = 1 <NEWLINE> end = M <NEWLINE> while True : <NEWLINE> <INDENT> if start >= end : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( start , end ) <NEWLINE> start += 1 <NEWLINE> end -= 1 <NEWLINE> <NL> <DEDENT> start = M + 1 <NEWLINE> end = 2 * M + 1 <NEWLINE> while True : <NEWLINE> <INDENT> if start >= end : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( start , end ) <NEWLINE> start = start + 1 <NEWLINE> end = end - 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> num = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if num > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ num ] = ans [ num ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for m in ans [ 1 : ] : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ ] for i in range ( n ) ] <NEWLINE> union = [ ] <NEWLINE> vis = [ - 1 ] * n <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> q . append ( i ) <NEWLINE> while q : <NEWLINE> <INDENT> a = q . popleft ( ) <NEWLINE> if vis [ a ] == - 1 : <NEWLINE> <INDENT> vis [ a ] = 0 <NEWLINE> temp . append ( a ) <NEWLINE> for j in l [ a ] : <NEWLINE> <INDENT> q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( temp ) > 0 : <NEWLINE> <INDENT> union . append ( temp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in union : <NEWLINE> <INDENT> ans = max ( ans , len ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
EPS = 0.0001 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> dd = a [ 0 ] * a [ 4 ] - a [ 3 ] * a [ 1 ] <NEWLINE> d1 = a [ 2 ] * a [ 4 ] - a [ 5 ] * a [ 1 ] <NEWLINE> d2 = a [ 0 ] * a [ 5 ] - a [ 3 ] * a [ 2 ] <NEWLINE> print ( <STRING> . format ( d1 / dd + EPS , d2 / dd + EPS ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> final = <STRING> <NEWLINE> chars = <STRING> <NEWLINE> dic = { i : chars [ i ] for i in range ( 0 , 26 ) } <NEWLINE> pw_26 = [ 26 ** i for i in range ( 13 ) ] <NEWLINE> cum = 0 <NEWLINE> digit = 0 <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> cum += pw_26 [ i ] <NEWLINE> if N < cum : <NEWLINE> <INDENT> digit = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> start_from = cum - pw_26 [ digit ] <NEWLINE> temp = N - start_from <NEWLINE> digits = [ ] <NEWLINE> counter = 0 <NEWLINE> while counter < digit : <NEWLINE> <INDENT> res = temp % 26 <NEWLINE> temp //= 26 <NEWLINE> digits . append ( res ) <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> for j in range ( len ( digits ) ) : <NEWLINE> <INDENT> char = dic [ digits [ j ] ] <NEWLINE> final = char + final <NEWLINE> <DEDENT> print ( final ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 100200 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 6 ) : <NEWLINE> <INDENT> dp [ i + 100 + j ] = 1 <NEWLINE> if i + 100 + j == X : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def f ( N , c ) : <NEWLINE> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> n = N // 2 <NEWLINE> c += 1 <NEWLINE> return f ( n , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return c <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> count += f ( a , 0 ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
def get_n ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def get_ns ( ) : <NEWLINE> <INDENT> return [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <DEDENT> import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = get_n ( ) <NEWLINE> ns = sorted ( set ( [ get_n ( ) for _ in range ( n ) ] ) ) [ : 100 ] <NEWLINE> top3 = [ 9999999999 , 9999999999 , 9999999999 ] <NEWLINE> for i , a in enumerate ( ns ) : <NEWLINE> <INDENT> for j , b in enumerate ( ns ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> keta = int ( math . log10 ( b ) ) + 1 <NEWLINE> c = a * pow ( 10 , keta ) + b <NEWLINE> if c < top3 [ 2 ] : <NEWLINE> <INDENT> top3 = sorted ( top3 + [ c ] ) [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( top3 [ 2 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import itertools <NEWLINE> <NL> def abc167c_skill_up ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( v [ 0 ] ) <NEWLINE> a . append ( v [ 1 : ] ) <NEWLINE> <DEDENT> pattern = itertools . product ( [ 0 , 1 ] , repeat = n ) <NEWLINE> best = float ( <STRING> ) <NEWLINE> for p in pattern : <NEWLINE> <INDENT> cost = 0 <NEWLINE> skill = [ 0 ] * m <NEWLINE> for i , v in enumerate ( p ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> cost += c [ i ] <NEWLINE> if cost > best : break <NEWLINE> check = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> skill [ j ] += a [ i ] [ j ] <NEWLINE> if skill [ j ] < x : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> best = cost <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if best == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( best ) <NEWLINE> <DEDENT> <DEDENT> abc167c_skill_up ( ) <NEWLINE>
import itertools <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <NL> t = input ( ) <NEWLINE> <COMMENT> <NL> print ( t . replace ( <STRING> , <STRING> ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lists = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lists . append ( lis ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for list in lists : <NEWLINE> <INDENT> for i in range ( len ( list ) ) : <NEWLINE> <INDENT> ans [ list [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for h in ans : <NEWLINE> <INDENT> if h == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def isSquare ( x ) : <NEWLINE> <INDENT> return x == round ( x ** ( 1 / 2 ) ) ** 2 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> f = N <NEWLINE> while True : <NEWLINE> <INDENT> if isSquare ( f ) : <NEWLINE> <INDENT> print ( f ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f -= 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> x = sum ( line ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x -= line [ i ] <NEWLINE> ans += line [ i ] * x <NEWLINE> if ans > mod : <NEWLINE> <INDENT> ans = ans % mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def sigma ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> s = list ( map ( lambda x : 1 if x == <STRING> else - 1 , input ( ) ) ) <NEWLINE> l = [ s [ 0 ] ] <NEWLINE> for c in s [ 1 : ] : <NEWLINE> <INDENT> if c * l [ - 1 ] > 0 : <NEWLINE> <INDENT> l [ - 1 ] += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( c ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> now = 0 <NEWLINE> for c in l : <NEWLINE> <INDENT> if c < 0 : <NEWLINE> <INDENT> ans -= min ( now , abs ( c ) ) <NEWLINE> <DEDENT> ans += sigma ( abs ( c ) ) <NEWLINE> now = abs ( c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> n = <STRING> . join ( n ) <NEWLINE> c , ans = 0 , 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> ans = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> st = True <NEWLINE> deq = deque ( S ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> Query = input ( ) . split ( ) <NEWLINE> if Query [ 0 ] == <STRING> : <NEWLINE> <INDENT> st = not st <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( Query [ 1 ] == <STRING> ) ^ st : <NEWLINE> <INDENT> deq . append ( Query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> deq . appendleft ( Query [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if st : <NEWLINE> <INDENT> print ( <STRING> . join ( deq ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( reversed ( deq ) ) ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = [ ] <NEWLINE> n = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if <STRING> in S [ i ] : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for _ in range ( j + 1 - len ( ans ) ) : <NEWLINE> <INDENT> ans . append ( str ( n ) ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) < w : <NEWLINE> <INDENT> x = ans [ - 1 ] <NEWLINE> for _ in range ( w - len ( ans ) ) : <NEWLINE> <INDENT> ans . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> for _ in range ( i + 1 - cnt ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import log10 as log <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if min ( A ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> flag = 1 <NEWLINE> c_count = 0 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if 2 <= i <= len ( S ) - 2 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> c_count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] . islower ( ) == False : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> if c_count == 1 and flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from collections import defaultdict <NEWLINE> import queue <NEWLINE> <NL> <NL> q = queue . Queue ( ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> li = [ - 1 for _ in range ( n ) ] <NEWLINE> li [ 0 ] = 1 <NEWLINE> <NL> def search ( x ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for e in graph [ x ] : <NEWLINE> <COMMENT> <NL> <INDENT> if li [ e - 1 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> li [ e - 1 ] = x <NEWLINE> <COMMENT> <NL> q . put ( e ) <NEWLINE> <DEDENT> <DEDENT> x = 1 <NEWLINE> search ( x ) <NEWLINE> while q . queue : <NEWLINE> <INDENT> search ( q . get ( ) ) <NEWLINE> <NL> <DEDENT> if li [ 1 : ] . count ( - 1 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for e in li [ 1 : ] : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> l_r = set ( ) <NEWLINE> l_g = set ( ) <NEWLINE> l_b = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> l_r . add ( i ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> l_g . add ( i ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> l_b . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( l_r ) * len ( l_g ) * len ( l_b ) <NEWLINE> <NL> for r in l_r : <NEWLINE> <INDENT> for g in l_g : <NEWLINE> <INDENT> mi = min ( r , g ) <NEWLINE> ma = max ( r , g ) <NEWLINE> l = ma - mi <NEWLINE> if ma + l in l_b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if mi - l in l_b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if l % 2 == 0 and l // 2 + mi in l_b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> M = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> print ( int ( M [ : : - 1 ] ) - int ( M ) ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , M = il ( ) <NEWLINE> A = [ iss ( ) for _ in range ( N ) ] <NEWLINE> B = [ iss ( ) for _ in range ( M ) ] <NEWLINE> <NL> for i in range ( N - M + 1 ) : <NEWLINE> <INDENT> for j in range ( N - M + 1 ) : <NEWLINE> <INDENT> t = i <NEWLINE> for b in B : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if A [ t ] [ j : j + M ] == b : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import bisect <NEWLINE> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> rekkyo = [ ] <NEWLINE> for i in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> sum_a = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> sum_a -= a <NEWLINE> ans += ( sum_a * a ) % mod <NEWLINE> <NL> <DEDENT> ans %= mod <NEWLINE> print ( int ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a - 1 ] += 1 <NEWLINE> d [ b - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> march = [ 0 ] * 5 <NEWLINE> <NL> march_dic = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> name = input ( ) <NEWLINE> if name [ 0 ] in <STRING> : <NEWLINE> <INDENT> march [ march_dic [ name [ 0 ] ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def count_type ( march ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in march : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> return len ( ans ) , ans <NEWLINE> <NL> <DEDENT> type_num , each_num = count_type ( march ) <NEWLINE> if type_num < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( type_num - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , type_num - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , type_num ) : <NEWLINE> <INDENT> ans += each_num [ i ] * each_num [ j ] * each_num [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr ) <NEWLINE> s = set ( ) <NEWLINE> cnt = collections . Counter ( arr ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cnt [ arr [ i ] ] >= 2 : <NEWLINE> <INDENT> s . add ( arr [ i ] ) <NEWLINE> <DEDENT> for j in range ( 2 , 10 ** 6 // arr [ i ] + 1 ) : <NEWLINE> <INDENT> s . add ( arr [ i ] * j ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ [ ] for i in range ( 100001 ) ] <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> X , Y , Z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( X - 1 , Y ) : <NEWLINE> <INDENT> l [ j ] . append ( Z ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans = max ( ans , len ( set ( i ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> def sieve_of_erastosthenes ( num ) : <NEWLINE> <INDENT> input_list = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( num ) ] <NEWLINE> input_list [ 0 ] = input_list [ 1 ] = False <NEWLINE> input_list [ 2 ] = input_list [ 3 ] = input_list [ 5 ] = True <NEWLINE> sqrt = math . sqrt ( num ) <NEWLINE> <NL> for serial in range ( 3 , num , 2 ) : <NEWLINE> <INDENT> if serial >= sqrt : <NEWLINE> <INDENT> return input_list <NEWLINE> <DEDENT> for s in range ( serial ** 2 , num , serial ) : <NEWLINE> <INDENT> input_list [ s ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> primeTable = sieve_of_erastosthenes ( 13 * ( 10 ** 5 ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> if k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if primeTable [ k ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = k <NEWLINE> while primeTable [ i ] is False : i += 1 <NEWLINE> j = i - 1 <NEWLINE> while primeTable [ j ] is False : j -= 1 <NEWLINE> print ( i - j ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> loop_ = [ 1 ] <NEWLINE> l_set = set ( ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tar = None <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> num = lst [ loop_ [ - 1 ] - 1 ] <NEWLINE> if num in l_set : <NEWLINE> <INDENT> tar = num <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop_ . append ( num ) <NEWLINE> l_set . add ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> if tar == None : <NEWLINE> <INDENT> print ( loop_ [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> loop__ = loop_ [ loop_ . index ( tar ) : ] <NEWLINE> <NL> num = k + 1 - len ( loop_ ) <NEWLINE> try : <NEWLINE> <INDENT> print ( loop__ [ num % len ( loop__ ) - 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> try : <NEWLINE> <INDENT> list_P = [ int ( p ) for p in input ( ) . split ( ) ] <NEWLINE> list_not_P = [ x for x in range ( 102 ) if not x in list_P ] <NEWLINE> list_abs = [ abs ( x - i ) for i in list_not_P ] <NEWLINE> Index = list_abs . index ( min ( list_abs ) ) <NEWLINE> print ( list_not_P [ Index ] ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> def c ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> m = Counter ( A ) <NEWLINE> s = 0 <NEWLINE> for x , y in m . items ( ) : <NEWLINE> <INDENT> if y != 1 : <NEWLINE> <INDENT> s += c ( y ) <NEWLINE> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( s - ( m [ a ] - 1 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> d = collections . Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> M = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t_num = t . copy ( ) <NEWLINE> t_num = set ( list ( t_num ) ) <NEWLINE> t = collections . Counter ( t ) <NEWLINE> <NL> if N < M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for key in t_num : <NEWLINE> <INDENT> if d [ key ] < t [ key ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <NL> if k <= a : <COMMENT> <NEWLINE> <INDENT> ans = k <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> y = k - a <COMMENT> <NEWLINE> if y <= b : <COMMENT> <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y -= b <NEWLINE> ans = a - y <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
with open ( 0 ) as f : <NEWLINE> <INDENT> N , * a = map ( int , f . read ( ) . split ( ) ) <NEWLINE> <DEDENT> F = [ x for x in a [ : N ] ] <COMMENT> <NEWLINE> C = [ x for x in a [ N : 2 * N ] ] <NEWLINE> B = [ - x for x in a [ 2 * N : ] ] <COMMENT> <NEWLINE> import heapq as hq <NEWLINE> <COMMENT> <NL> hq . heapify ( F ) <NEWLINE> hq . heapify ( B ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from copy import deepcopy <NEWLINE> memoF = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> memoF [ 0 ] = sum ( F ) <NEWLINE> memoB = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> memoB [ N ] = sum ( B ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] > F [ 0 ] : <NEWLINE> <INDENT> memoF [ i + 1 ] = memoF [ i ] + C [ i ] - hq . heapreplace ( F , C [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memoF [ i + 1 ] = memoF [ i ] <NEWLINE> <NL> <DEDENT> if - C [ N - 1 - i ] > B [ 0 ] : <NEWLINE> <INDENT> memoB [ N - 1 - i ] = memoB [ N - i ] - C [ N - 1 - i ] - hq . heapreplace ( B , - C [ N - 1 - i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memoB [ N - 1 - i ] = memoB [ N - i ] <NEWLINE> <NL> <DEDENT> <DEDENT> Scores = [ memoF [ i ] + memoB [ i ] for i in range ( N + 1 ) ] <NEWLINE> ans = max ( Scores ) <NEWLINE> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n , l = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> S = [ input ( ) for i in range ( 0 , n ) ] <NEWLINE> print ( <STRING> . join ( sorted ( S ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if not ans > 10 ** 18 : <NEWLINE> <INDENT> ans *= ai <NEWLINE> <DEDENT> elif ai == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) . split ( ) ) ) ; print ( min ( [ n [ i ] + n [ j ] for i in range ( 3 ) for j in range ( i + 1 , 3 ) ] ) ) <NEWLINE>
import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> print ( <STRING> ) if scores [ i ] < scores [ i + K ] else print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> s = input ( ) <NEWLINE> <COMMENT> <NL> if len ( s ) <= 2 : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> N = len ( s ) // 2 <NEWLINE> q = 0 <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> q = 1 <NEWLINE> <DEDENT> Odd = [ ] <NEWLINE> for i in range ( N + q ) : <NEWLINE> <INDENT> Odd . append ( s [ 2 * i ] ) <NEWLINE> <DEDENT> Odd = <STRING> . join ( Odd ) <NEWLINE> print ( Odd ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * N <NEWLINE> b = [ None ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b [ s - 1 ] == c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ s - 1 ] += 1 <NEWLINE> b [ s - 1 ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] >= 2 : <NEWLINE> <INDENT> count = - 1 <NEWLINE> <DEDENT> elif b [ 0 ] == 0 and N > 1 : <NEWLINE> <INDENT> count = - 1 <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> if b [ i ] is None : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> b [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i > 0 : <NEWLINE> <INDENT> if b [ i ] is None : <NEWLINE> <INDENT> b [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> b . reverse ( ) <NEWLINE> if count == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> count += b [ i ] * 10 ** i <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( X + 1 ) : <NEWLINE> <INDENT> for j in [ - 1 , 1 ] : <NEWLINE> <INDENT> a = X + i * j <NEWLINE> if not ( a in p ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> mod = [ 0 for i in range ( 2019 ) ] <NEWLINE> mod2 = 0 <NEWLINE> ten = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> s = int ( S [ i ] ) * ten <NEWLINE> mod2 += np . mod ( s , 2019 ) <NEWLINE> mod2 = np . mod ( mod2 , 2019 ) <NEWLINE> mod [ mod2 ] += 1 <NEWLINE> ten = ( ten * 10 ) % 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> k = mod [ i ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> if k >= 2 : <NEWLINE> <INDENT> ans += k * ( k - 1 ) // 2 + k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if k >= 2 : <NEWLINE> <INDENT> ans += k * ( k - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 for i in range ( 0 , N ) ] <NEWLINE> for i in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( 0 , len ( B ) ) : <NEWLINE> <INDENT> print ( B [ j ] ) <NEWLINE> <DEDENT>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> c_lists = [ ] <NEWLINE> t_lists = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c_i , t_i = map ( int , input ( ) . split ( ) ) <NEWLINE> c_lists . append ( c_i ) <NEWLINE> t_lists . append ( t_i ) <NEWLINE> <NL> <DEDENT> costs = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if t_lists [ j ] <= t : <NEWLINE> <INDENT> costs . append ( c_lists [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if not costs : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> costs . sort ( ) <NEWLINE> ans = costs [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> a_max = max ( a ) <NEWLINE> a_max_cnt = a . count ( a_max ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] != a_max or a_max_cnt > 1 ) : <NEWLINE> <INDENT> print ( a_max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a [ : i ] + a [ i + 1 : ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 12 <NEWLINE> for i in range ( 11 , 0 , - 1 ) : <NEWLINE> <INDENT> m = n // 26 ** i <NEWLINE> a [ i ] = m <NEWLINE> n -= m * ( 26 ** i ) <NEWLINE> <DEDENT> a [ 0 ] = n <NEWLINE> for i in range ( 11 , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> a . pop ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> b = <STRING> <NEWLINE> c = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i == len ( a ) - 1 and a [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i != len ( a ) - 1 and a [ i ] == 0 : <NEWLINE> <INDENT> a [ i ] = 26 <NEWLINE> a [ i + 1 ] -= 1 <NEWLINE> <DEDENT> elif i != len ( a ) - 1 and a [ i ] == - 1 : <NEWLINE> <INDENT> a [ i ] = 25 <NEWLINE> a [ i + 1 ] -= 1 <NEWLINE> <DEDENT> c . append ( b [ a [ i ] - 1 ] ) <NEWLINE> <DEDENT> c . reverse ( ) <NEWLINE> print ( * c , sep = <STRING> ) <NEWLINE>
def call ( n ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> s += <STRING> . format ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> s += <STRING> . format ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x = x // 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> call ( m ) <NEWLINE>
n = 50021 <NEWLINE> c = [ 1 for i in range ( n ) ] <NEWLINE> c [ 0 ] = 0 <NEWLINE> i = 2 <NEWLINE> while i ** 2 <= n : <NEWLINE> <INDENT> j = i * 2 <NEWLINE> while j <= n : <NEWLINE> <INDENT> c [ j - 1 ] = 0 <NEWLINE> j += i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> i , a , b = 0 , 0 , 0 <NEWLINE> while a == 0 or b == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> if n - i - 1 >= 0 and a == 0 and c [ n - i - 1 ] == 1 : <NEWLINE> <INDENT> a = n - i <NEWLINE> <DEDENT> if n + i - 1 < 50021 and b == 0 and c [ n + i - 1 ] == 1 : <NEWLINE> <INDENT> b = n + i <NEWLINE> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> import fileinput <NEWLINE> import math <NEWLINE> for line in fileinput . input ( ) : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> g = gcd ( a , b ) <NEWLINE> lcm = a * b // g <NEWLINE> print ( g , lcm ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> N , Q = MI ( ) <NEWLINE> graph = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> point = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = MI ( ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <DEDENT> def dfs ( now , pre = - 1 ) : <NEWLINE> <INDENT> for next in graph [ now ] : <NEWLINE> <INDENT> if next == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> dfs ( next , now ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * point ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> plus . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> plus . sort ( key = lambda x : - x ) <NEWLINE> minus . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> numplus = k <NEWLINE> numminus = 0 <NEWLINE> <NL> <STRING> <NEWLINE> while numplus > len ( plus ) : <NEWLINE> <INDENT> numplus -= 2 <NEWLINE> numminus += 2 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> while numplus - 2 >= 0 and numminus + 1 < len ( minus ) : <NEWLINE> <INDENT> if plus [ numplus - 1 ] * plus [ numplus - 2 ] <= minus [ numminus ] * minus [ numminus + 1 ] : <NEWLINE> <INDENT> numplus -= 2 <NEWLINE> numminus += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> <NL> if numplus >= 0 and numminus >= 0 and numminus <= len ( minus ) and numplus <= len ( plus ) : <NEWLINE> <INDENT> for i in range ( numplus ) : <NEWLINE> <INDENT> ans = ans * plus [ i ] % mod <NEWLINE> <DEDENT> for i in range ( numminus ) : <NEWLINE> <INDENT> ans = ans * minus [ i ] % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> tmp = sorted ( a , key = lambda x : - x ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * tmp [ i ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def resolver ( N , A ) : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i , _ in enumerate ( A ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> ans += A [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = ( i // 2 ) <NEWLINE> ans += A [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> def _resolver ( N , A ) : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> circle = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if len ( circle ) == 0 : <NEWLINE> <INDENT> circle . append ( a ) <NEWLINE> <DEDENT> elif len ( circle ) == 1 : <NEWLINE> <INDENT> ans += circle [ 0 ] <NEWLINE> circle . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = max ( range ( len ( circle ) ) , key = lambda i : min ( circle [ i - 1 ] , circle [ i ] ) ) <NEWLINE> ans += min ( circle [ idx - 1 ] , circle [ idx ] ) <NEWLINE> circle . insert ( idx , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = resolver ( N , A ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = [ int ( x ) for x in list ( str ( N ) ) ] <NEWLINE> a = sum ( L ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , * l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = 1 <NEWLINE> for i in sorted ( l ) : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : a = - 1 ; break <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N // R + 1 ) : <NEWLINE> <INDENT> for j in range ( N // G + 1 ) : <NEWLINE> <INDENT> if ( N - ( R * i + G * j ) ) < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( N - ( R * i + G * j ) ) % B == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class BinaryIndexedTree ( object ) : <NEWLINE> <INDENT> __slots__ = [ <STRING> ] <NEWLINE> <NL> def __init__ ( self , size : int ) : <NEWLINE> <INDENT> self . tree = [ 0 ] * ( size + 1 ) <NEWLINE> <NL> <DEDENT> def add ( self , index : int , value : int ) -> None : <NEWLINE> <INDENT> tree = self . tree <NEWLINE> next_index = index + 1 <NEWLINE> <NL> while next_index < len ( tree ) : <NEWLINE> <INDENT> tree [ next_index ] += value <NEWLINE> next_index += next_index & - next_index <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , index : int ) : <NEWLINE> <INDENT> tree , result = self . tree , 0 <NEWLINE> next_index = index + 1 <NEWLINE> <NL> while next_index : <NEWLINE> <INDENT> result += tree [ next_index ] <NEWLINE> next_index -= next_index & - next_index <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> bit = BinaryIndexedTree ( n ) <NEWLINE> result = [ ] <NEWLINE> for com , x , y in ( map ( int , l . split ( ) ) for l in sys . stdin ) : <NEWLINE> <INDENT> if not com : <NEWLINE> <INDENT> bit . add ( x - 1 , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( bit . sum ( y - 1 ) - bit . sum ( x - 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * result , sep = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 1 in a : <NEWLINE> <INDENT> a . remove ( 1 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> ans = 0 <NEWLINE> comb = 1 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += ( ( ( m * pow ( m - 1 , n - i - 1 , mod ) ) % mod ) * comb ) % mod <NEWLINE> ans %= mod <NEWLINE> comb *= ( n - 1 - i ) <NEWLINE> comb %= mod <NEWLINE> comb *= pow ( i + 1 , mod - 2 , mod ) <NEWLINE> comb %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> list . append ( s ) <NEWLINE> <DEDENT> print ( len ( collections . Counter ( list ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> class Solution : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def doubly_linked_list ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> array_length = int ( input ( ) ) <NEWLINE> task_deque = deque ( ) <NEWLINE> _input = sys . stdin . readlines ( ) <NEWLINE> <NL> for i in range ( array_length ) : <NEWLINE> <INDENT> l_arg = _input [ i ] . split ( ) <NEWLINE> action = _input [ i ] . split ( ) [ 0 ] <NEWLINE> if len ( l_arg ) > 1 : <NEWLINE> <INDENT> value = _input [ i ] . split ( ) [ - 1 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if action == <STRING> : <NEWLINE> <INDENT> task_deque . appendleft ( value ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> task_deque . popleft ( ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> task_deque . pop ( ) <NEWLINE> <DEDENT> elif action == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> task_deque . remove ( value ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( task_deque ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution = Solution ( ) <NEWLINE> solution . doubly_linked_list ( ) <NEWLINE> <DEDENT>
def A ( x ) : <NEWLINE> <INDENT> if ord ( x ) - ord ( <STRING> ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def B ( n , k , p_list ) : <NEWLINE> <INDENT> p_list = sorted ( p_list ) <NEWLINE> print ( sum ( p_list [ : k ] ) ) <NEWLINE> <NL> <NL> <DEDENT> def C ( N ) : <NEWLINE> <INDENT> for i in range ( 99 ) : <NEWLINE> <INDENT> if N < 26 ** i : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> return <STRING> . join ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( C ( int ( input ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> dictionary = set ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> dictionary . add ( command [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if command [ 1 ] in dictionary else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def isPrime ( num ) : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for p in range ( 2 , num ) : <NEWLINE> <INDENT> if num % p == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> num = int ( n ) <NEWLINE> while True : <NEWLINE> <INDENT> if isPrime ( num ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> break <NEWLINE> <DEDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> a = 1 <NEWLINE> while ( a < N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // a <COMMENT> <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N - i ) : <NEWLINE> <INDENT> if i + 2 * j >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] != S [ i + j ] and S [ i ] != S [ i + 2 * j ] and S [ i + j ] != S [ i + 2 * j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N + 1 ) : <NEWLINE> <INDENT> if i > K : <NEWLINE> <INDENT> tmp1 = A [ i - K - 1 ] <NEWLINE> tmp2 = A [ i - 1 ] <NEWLINE> if tmp1 < tmp2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <STRING> <NEWLINE> <NL> R = dict ( ) <NEWLINE> L = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] + i + 1 in R : <NEWLINE> <INDENT> R [ a [ i ] + i + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ a [ i ] + i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> if i + 1 - a [ i ] in L : <NEWLINE> <INDENT> L [ i + 1 - a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i + 1 - a [ i ] ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in R : <NEWLINE> <INDENT> if i in L : <NEWLINE> <INDENT> cnt += R [ i ] * L [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL>
S = input ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> flg = 0 <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> e = input ( ) . split ( ) <NEWLINE> if e [ 0 ] == <STRING> : <NEWLINE> <INDENT> flg += 1 <NEWLINE> flg = flg % 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( ( ( flg + int ( e [ 1 ] ) ) % 2 , e [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> S = <STRING> . join ( list ( reversed ( S ) ) ) if flg else S <NEWLINE> s1 , s2 = <STRING> , <STRING> <NEWLINE> for f , v in L : <NEWLINE> <INDENT> if ( flg + f ) % 2 == 1 : <NEWLINE> <INDENT> s1 += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 += v <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> . join ( list ( reversed ( s1 ) ) ) + S + s2 <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sth , stw , glh , glw = map ( int , input ( ) . split ( ) ) <NEWLINE> sth , stw = sth - 1 , stw - 1 <NEWLINE> glh , glw = glh - 1 , glw - 1 <NEWLINE> <NL> INF = - 1 <NEWLINE> Gmap = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> Seen = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> direc = { ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) } <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> def bfs ( sth , stw , glh , glw ) : <NEWLINE> <INDENT> next_q = deque ( [ ] ) <NEWLINE> next_q . append ( ( sth , stw , 0 ) ) <NEWLINE> Seen [ sth ] [ stw ] = 0 <NEWLINE> <NL> while len ( next_q ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> h , w , c = next_q . popleft ( ) <NEWLINE> for dh , dw in direc : <NEWLINE> <INDENT> for sk in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> hs , ws = h + dh * sk , w + dw * sk <NEWLINE> if not ( 0 <= hs < H and 0 <= ws < W ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if Gmap [ hs ] [ ws ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if Seen [ hs ] [ ws ] == INF : <NEWLINE> <INDENT> next_q . append ( ( hs , ws , c + 1 ) ) <NEWLINE> Seen [ hs ] [ ws ] = c + 1 <NEWLINE> <DEDENT> elif Seen [ hs ] [ ws ] <= c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if hs == glh and ws == glw : <NEWLINE> <INDENT> return c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ret = bfs ( sth , stw , glh , glw ) <NEWLINE> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <NL> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 13 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> a = LI_ ( ) <NEWLINE> b = [ 0 ] <NEWLINE> c = [ [ None ] * 18 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t = a [ i ] <NEWLINE> b . append ( b [ t ] + 1 ) <NEWLINE> d = [ None ] * 18 <NEWLINE> d [ 0 ] = t <NEWLINE> for j in range ( 1 , 18 ) : <NEWLINE> <INDENT> if c [ d [ j - 1 ] ] [ j - 1 ] is None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d [ j ] = c [ d [ j - 1 ] ] [ j - 1 ] <NEWLINE> <DEDENT> c . append ( d ) <NEWLINE> <NL> <DEDENT> ii = [ 2 ** i for i in range ( 19 ) ] <NEWLINE> def f ( i , j ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if b [ i ] > b [ j ] : <NEWLINE> <INDENT> sa = b [ i ] - b [ j ] <NEWLINE> for k in range ( 1 , 18 ) : <NEWLINE> <INDENT> if sa < ii [ k ] : <NEWLINE> <INDENT> return ii [ k - 1 ] + f ( c [ i ] [ k - 1 ] , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b [ i ] < b [ j ] : <NEWLINE> <INDENT> sa = b [ j ] - b [ i ] <NEWLINE> for k in range ( 1 , 18 ) : <NEWLINE> <INDENT> if sa < ii [ k ] : <NEWLINE> <INDENT> return ii [ k - 1 ] + f ( c [ j ] [ k - 1 ] , i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( 1 , 18 ) : <NEWLINE> <INDENT> if c [ i ] [ k ] == c [ j ] [ k ] : <NEWLINE> <INDENT> return ii [ k ] + f ( c [ i ] [ k - 1 ] , c [ j ] [ k - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ba = sorted ( zip ( b , range ( n ) ) ) <NEWLINE> aa = [ 0 ] <NEWLINE> aai = { } <NEWLINE> aai [ 0 ] = 0 <NEWLINE> i = 1 <NEWLINE> while i < n : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> bi = ba [ i ] [ 0 ] <NEWLINE> while j < n and bi == ba [ j ] [ 0 ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> aa . extend ( list ( map ( lambda x : x [ 1 ] , sorted ( [ [ aai [ c [ _ ] [ 0 ] ] , _ ] for k , _ in ba [ i : j ] ] ) ) ) ) <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> aai [ aa [ k ] ] = k <NEWLINE> <DEDENT> i = j <NEWLINE> <DEDENT> r = 1 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> r += f ( aa [ i ] , aa [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> num = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( num , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ss = [ input ( ) for i in range ( n ) ] <NEWLINE> ok = True <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = ss [ i ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if a == 1 and b == 1 and c == 0 : <NEWLINE> <INDENT> if i + 1 < n and ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if i + 1 < n and ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> a -= 1 <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if a > b : <NEWLINE> <INDENT> b += 1 <NEWLINE> a -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> a += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if a == 1 and b == 0 and c == 1 : <NEWLINE> <INDENT> if i + 1 < n and ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> c -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if i + 1 < n and ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> c += 1 <NEWLINE> a -= 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if a > c : <NEWLINE> <INDENT> c += 1 <NEWLINE> a -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c -= 1 <NEWLINE> a += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a == 0 and b == 1 and c == 1 : <NEWLINE> <INDENT> if i + 1 < n and ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> c += 1 <NEWLINE> b -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if i + 1 < n and ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> c -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if c == 0 and b == 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if c > b : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> def FN ( n ) : <NEWLINE> <INDENT> if n == 0 or n == 1 : <NEWLINE> <INDENT> F [ n ] = 1 <NEWLINE> return F [ n ] <NEWLINE> <DEDENT> if F [ n ] != None : <NEWLINE> <INDENT> return F [ n ] <NEWLINE> <DEDENT> F [ n ] = FN ( n - 1 ) + FN ( n - 2 ) <NEWLINE> return F [ n ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> F = [ None ] * ( n + 1 ) <NEWLINE> ans = FN ( n ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def main ( i ) : <NEWLINE> <INDENT> blue = math . factorial ( k - 1 ) // ( math . factorial ( i - 1 ) * math . factorial ( k - i ) ) <NEWLINE> red = math . factorial ( n - k + 1 ) // ( math . factorial ( n - k + 1 - i ) * math . factorial ( i ) ) <NEWLINE> print ( ( blue * red ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i > n - k + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> main ( i ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> abc = { a , b , c } <NEWLINE> div = 1 <NEWLINE> if len ( abc ) == 2 : <NEWLINE> <INDENT> div = 3 <NEWLINE> <DEDENT> elif len ( abc ) == 1 : <NEWLINE> <INDENT> div = 1 <NEWLINE> <DEDENT> elif len ( abc ) == 3 : <NEWLINE> <INDENT> div = 6 <NEWLINE> <COMMENT> <NL> <DEDENT> add = div * math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> total += add <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> p = math . pi <NEWLINE> <NL> print ( <STRING> . format ( r * r * p , r * 2 * p ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> U = 10 ** 18 <NEWLINE> <NL> def main ( A ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> for x in A : <NEWLINE> <INDENT> a *= x <NEWLINE> if a > U : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> print ( main ( A ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Ans = 0 <NEWLINE> <NL> sum_L = L [ 0 ] <NEWLINE> <NL> l = len ( L ) <NEWLINE> <NL> for i in L [ 1 : ] : <NEWLINE> <INDENT> Ans += sum_L * i % ( 10 ** 9 + 7 ) <NEWLINE> sum_L += i <NEWLINE> <DEDENT> Ans = Ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( Ans ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> result = deque ( ) <NEWLINE> <NL> def operation ( command ) : <NEWLINE> <INDENT> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> result . appendleft ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> if command [ 1 ] in result : <NEWLINE> <INDENT> result . remove ( command [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> result . popleft ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> result . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> operation ( command ) <NEWLINE> <DEDENT> print ( * result ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import itertools <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( itertools . accumulate ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> s = [ None ] * ( n * ( n + 1 ) // 2 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> s [ cnt ] = format ( a [ j ] - a [ i ] , <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> sel = set ( range ( n * ( n + 1 ) // 2 ) ) <NEWLINE> for i in range ( 50 ) : <NEWLINE> <INDENT> nxt = set ( [ ] ) <NEWLINE> for j in sel : <NEWLINE> <INDENT> if s [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> nxt . add ( j ) <NEWLINE> <DEDENT> <DEDENT> if len ( nxt ) >= k : <NEWLINE> <INDENT> sel = nxt <NEWLINE> ret += 2 ** ( 49 - i ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> am = [ ] <NEWLINE> ap = [ ] <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ai > 0 : <NEWLINE> <INDENT> ap . append ( ai ) <NEWLINE> <DEDENT> elif ai < 0 : <NEWLINE> <INDENT> am . append ( - ai ) <NEWLINE> <DEDENT> <DEDENT> am . sort ( reverse = True ) <NEWLINE> ap . sort ( reverse = True ) <NEWLINE> <NL> nm = len ( am ) <NEWLINE> np = len ( ap ) <NEWLINE> nz = n - np - nm <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if np + nm < k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif np == 0 : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> if nz > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> am . sort ( ) <NEWLINE> ans = - 1 + MOD <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= am [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= am [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif np < k : <NEWLINE> <INDENT> if ( k - np ) % 2 == 1 : <NEWLINE> <INDENT> idx1 = np - 1 <NEWLINE> idx2 = k - np + 1 <NEWLINE> if k - np + 1 > nm : <NEWLINE> <INDENT> if nz > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if nm % 2 == 1 : <NEWLINE> <INDENT> ans = - 1 + MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> for i in range ( np ) : <NEWLINE> <INDENT> ans *= ap [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for i in range ( nm ) : <NEWLINE> <INDENT> ans *= am [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while idx1 >= 2 and idx2 + 1 < nm and ap [ idx1 - 1 ] * ap [ idx1 - 2 ] < am [ idx2 ] * am [ idx2 + 1 ] : <NEWLINE> <INDENT> idx1 -= 2 <NEWLINE> idx2 += 2 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( idx1 ) : <NEWLINE> <INDENT> ans *= ap [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for i in range ( idx2 ) : <NEWLINE> <INDENT> ans *= am [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx1 = np <NEWLINE> idx2 = k - np <NEWLINE> while idx1 >= 2 and idx2 + 1 < nm and ap [ idx1 - 1 ] * ap [ idx1 - 2 ] < am [ idx2 ] * am [ idx2 + 1 ] : <NEWLINE> <INDENT> idx1 -= 2 <NEWLINE> idx2 += 2 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( idx1 ) : <NEWLINE> <INDENT> ans *= ap [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for i in range ( idx2 ) : <NEWLINE> <INDENT> ans *= am [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx1 = k <NEWLINE> idx2 = 0 <NEWLINE> while idx1 >= 2 and idx2 + 1 < nm and ap [ idx1 - 1 ] * ap [ idx1 - 2 ] < am [ idx2 ] * am [ idx2 + 1 ] : <NEWLINE> <INDENT> idx1 -= 2 <NEWLINE> idx2 += 2 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( idx1 ) : <NEWLINE> <INDENT> ans *= ap [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for i in range ( idx2 ) : <NEWLINE> <INDENT> ans *= am [ i ] <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> from sys import stdin <NEWLINE> <NL> import time <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> temp = stdin . readline ( ) . split ( ) <NEWLINE> N = int ( temp [ 0 ] ) <NEWLINE> <NL> data = [ ] <NEWLINE> write = stdin . readline ( ) . split ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> data . append ( int ( write [ i ] ) ) <NEWLINE> <NL> <DEDENT> data = np . asarray ( data ) <NEWLINE> <NL> out = np . zeros ( N ) <NEWLINE> for d in data : <NEWLINE> <INDENT> out [ d - 1 ] += 1 <NEWLINE> <NL> <DEDENT> o = <STRING> <NEWLINE> for l in out : <NEWLINE> <INDENT> o += str ( int ( l ) ) + <STRING> <NEWLINE> <NL> <DEDENT> print ( o ) <NEWLINE>
import math <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lcm ( a , b ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> d = Counter ( c ) <NEWLINE> w , r = Counter ( c ) [ <STRING> ] , Counter ( c ) [ <STRING> ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> l = deque ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . appendleft ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ind = l . remove ( command [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . popleft ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE>
def ite ( N , M ) : <NEWLINE> <INDENT> import itertools <NEWLINE> return itertools . combinations_with_replacement ( range ( M ) , N ) <NEWLINE> <DEDENT> def check ( li ) : <NEWLINE> <INDENT> for i in range ( len ( li ) - 1 ) : <NEWLINE> <INDENT> if li [ i ] > li [ i + 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def score ( l1 , l2 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for ( a , b , c , d ) in l2 : <NEWLINE> <INDENT> if l1 [ b - 1 ] - l1 [ a - 1 ] == c : <NEWLINE> <INDENT> s += d <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> N , M , Q = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> li . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> m_s = 0 <NEWLINE> for l2 in ite ( N , M ) : <NEWLINE> <INDENT> s = score ( l2 , li ) <NEWLINE> if m_s < s : <NEWLINE> <INDENT> m_s = s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m_s ) <NEWLINE>
S = input ( ) <NEWLINE> S = S + <STRING> <NEWLINE> mod = 2019 <NEWLINE> p = [ 0 ] * mod <NEWLINE> r = 0 <NEWLINE> d = 1 <NEWLINE> for s in reversed ( S ) : <NEWLINE> <INDENT> t = int ( s ) % mod <NEWLINE> r += t * d <NEWLINE> r %= mod <NEWLINE> d = d * 10 % mod <NEWLINE> p [ r ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in p ] ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if not ( 2 <= N <= 10 ** 5 ) : sys . exit ( ) <NEWLINE> if not ( 0 <= min ( array ) and max ( array ) <= 10 ** 18 ) : sys . exit ( ) <NEWLINE> if 0 in array : print ( 0 ) ; sys . exit ( ) <NEWLINE> <NL> sum = array [ 0 ] <NEWLINE> for I in range ( 1 , len ( array ) ) : <NEWLINE> <INDENT> sum *= array [ I ] <NEWLINE> if sum > 10 ** 18 : print ( - 1 ) ; sys . exit ( ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> <COMMENT> <NL> if k >= n : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = input ( ) <NEWLINE> hairu = input ( ) <NEWLINE> kita = hairu . split ( <STRING> ) <NEWLINE> seki = 1 <NEWLINE> <NL> for c in kita : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> kita [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for c in kita : <NEWLINE> <INDENT> seki = seki * int ( c ) <NEWLINE> if seki > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if seki > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( seki ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , k , q = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> score = [ 0 ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> score [ a - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for s in score : <NEWLINE> <INDENT> print ( <STRING> if s + k - q > 0 else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = n // i <NEWLINE> s += d * ( d + 1 ) // 2 * i <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> def move_func ( dice_list , dir ) : <NEWLINE> <INDENT> new_dice = [ ] <NEWLINE> if dir == <STRING> : <NEWLINE> <INDENT> new_dice . append ( dice_list [ 1 ] ) <NEWLINE> new_dice . append ( dice_list [ 5 ] ) <NEWLINE> new_dice . append ( dice_list [ 2 ] ) <NEWLINE> new_dice . append ( dice_list [ 3 ] ) <NEWLINE> new_dice . append ( dice_list [ 0 ] ) <NEWLINE> new_dice . append ( dice_list [ 4 ] ) <NEWLINE> <DEDENT> elif dir == <STRING> : <NEWLINE> <INDENT> new_dice . append ( dice_list [ 3 ] ) <NEWLINE> new_dice . append ( dice_list [ 1 ] ) <NEWLINE> new_dice . append ( dice_list [ 0 ] ) <NEWLINE> new_dice . append ( dice_list [ 5 ] ) <NEWLINE> new_dice . append ( dice_list [ 4 ] ) <NEWLINE> new_dice . append ( dice_list [ 2 ] ) <NEWLINE> <DEDENT> elif dir == <STRING> : <NEWLINE> <INDENT> new_dice . append ( dice_list [ 4 ] ) <NEWLINE> new_dice . append ( dice_list [ 0 ] ) <NEWLINE> new_dice . append ( dice_list [ 2 ] ) <NEWLINE> new_dice . append ( dice_list [ 3 ] ) <NEWLINE> new_dice . append ( dice_list [ 5 ] ) <NEWLINE> new_dice . append ( dice_list [ 1 ] ) <NEWLINE> <DEDENT> elif dir == <STRING> : <NEWLINE> <INDENT> new_dice . append ( dice_list [ 2 ] ) <NEWLINE> new_dice . append ( dice_list [ 1 ] ) <NEWLINE> new_dice . append ( dice_list [ 5 ] ) <NEWLINE> new_dice . append ( dice_list [ 0 ] ) <NEWLINE> new_dice . append ( dice_list [ 4 ] ) <NEWLINE> new_dice . append ( dice_list [ 3 ] ) <NEWLINE> <DEDENT> return new_dice <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> dice_list = input ( ) . split ( <STRING> ) <NEWLINE> move_cmd = input ( ) <NEWLINE> for cmd in move_cmd : <NEWLINE> <INDENT> dice_list = move_func ( dice_list , cmd ) <NEWLINE> <NL> <DEDENT> print ( dice_list [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
from collections import * <NEWLINE> from itertools import * <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = map ( int , input ( ) . split ( ) ) <NEWLINE> SA = SB = 0 <NEWLINE> ABI = sorted ( ( ( b : = max ( N - i , i - 1 ) * a , SA : = SA + a , SB : = SB + b ) and ( a , b , i ) for i , a in enumerate ( A , 1 ) ) , reverse = True ) <NEWLINE> <NL> prev = [ 0 ] <NEWLINE> prev_max = 0 <NEWLINE> for k , ( a , b , i ) in enumerate ( ABI ) : <NEWLINE> <INDENT> curr = [ 0 ] * ( k + 2 ) <NEWLINE> for l in range ( k + 1 ) : <NEWLINE> <INDENT> r = k - l <NEWLINE> if prev [ l ] + SB - min ( l , r ) * SA < prev_max : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> curr [ l ] = max ( curr [ l ] , prev [ l ] + abs ( N - i - r ) * a ) <NEWLINE> curr [ l + 1 ] = prev [ l ] + abs ( i - l - 1 ) * a <NEWLINE> <DEDENT> SA -= a <NEWLINE> SB -= b <NEWLINE> prev = curr <NEWLINE> prev_max = max ( prev ) <NEWLINE> <NL> <DEDENT> print ( prev_max ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ x ] <NEWLINE> mod = x <NEWLINE> memo = [ - 1 for _ in range ( m + 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> mod = mod ** 2 % m <NEWLINE> idx = memo [ mod ] <NEWLINE> <NL> if idx != - 1 : <NEWLINE> <INDENT> a = i - idx <NEWLINE> q , _mod = divmod ( ( n - idx ) , a ) <NEWLINE> <NL> ans = sum ( arr [ 0 : idx ] ) + q * sum ( arr [ idx : idx + a ] ) + sum ( arr [ idx : idx + _mod ] ) <NEWLINE> break <NEWLINE> <DEDENT> arr . append ( mod ) <NEWLINE> memo [ mod ] = i <NEWLINE> <NL> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> ans = sum ( arr ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = set ( ) <NEWLINE> if n : <NEWLINE> <INDENT> p = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> mini = float ( <STRING> ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( - 400 , 400 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> if abs ( x - i ) < mini : <NEWLINE> <INDENT> mini = abs ( x - i ) <NEWLINE> ans = i <NEWLINE> <DEDENT> elif abs ( x - i ) == mini and ans > i : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> sumOfDigits = 0 <NEWLINE> <NL> for i in n : <NEWLINE> <INDENT> sumOfDigits += int ( i ) <NEWLINE> <NL> <DEDENT> if sumOfDigits % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> counter = np . zeros ( N , dtype = int ) <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> res = x ** 2 + y ** 2 + z ** 2 + x * y + x * z + y * z <NEWLINE> if res <= N : <NEWLINE> <INDENT> counter [ res - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for c in counter : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> <NL> def binom_preprocess ( n , MOD = 998244353 ) : <NEWLINE> <INDENT> f = [ 0 for i in range ( n + 1 ) ] <COMMENT> <NEWLINE> invf = [ 0 for i in range ( n + 1 ) ] <COMMENT> <NEWLINE> f [ 0 ] = 1 <NEWLINE> f [ 1 ] = 1 <NEWLINE> invf [ 0 ] = 1 <NEWLINE> invf [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> f [ i ] = f [ i - 1 ] * i % MOD <NEWLINE> invf [ i ] = pow ( f [ i ] , MOD - 2 , MOD ) <NEWLINE> <DEDENT> return f , invf <NEWLINE> <NL> <NL> <DEDENT> def binom ( n , k , f , invf , MOD = 998244353 ) : <NEWLINE> <INDENT> if n < k or n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( f [ n ] * invf [ k ] % MOD ) * invf [ n - k ] % MOD <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def read ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> return N , M , K <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def solve ( N , M , K , MOD = 998244353 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> f , invf = binom_preprocess ( N ) <NEWLINE> for k in range ( K + 1 ) : <NEWLINE> <INDENT> ans += binom ( N - 1 , N - k - 1 , f , invf ) * M * pow ( M - 1 , N - k - 1 , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for aa in a : <NEWLINE> <INDENT> if aa > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> i = 1 <NEWLINE> position = 1 <NEWLINE> position_list = [ 1 ] <NEWLINE> position_history = [ 0 ] * N <NEWLINE> start_loop = 0 <NEWLINE> def last ( ) : <NEWLINE> <INDENT> k = ( K - start_loop ) % ( count - start_loop ) <NEWLINE> print ( position_list [ start_loop + k ] ) <NEWLINE> <NL> <DEDENT> while i > 0 : <NEWLINE> <INDENT> position = A [ position - 1 ] <NEWLINE> position_history [ position - 1 ] += 1 <NEWLINE> count += 1 <NEWLINE> if count == K : <NEWLINE> <INDENT> print ( position ) <NEWLINE> break <NEWLINE> <DEDENT> elif position_history [ position - 1 ] > 1 : <NEWLINE> <INDENT> start_loop = position_list . index ( position ) <NEWLINE> position_list . append ( position ) <NEWLINE> last ( ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> position_list . append ( position ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <NL> <DEDENT> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] > k - A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dist = [ 0 ] * 100000 <NEWLINE> ans = sum ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> dist [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if dist [ b - 1 ] != 0 : <NEWLINE> <INDENT> dist [ c - 1 ] += dist [ b - 1 ] <NEWLINE> ans += dist [ b - 1 ] * ( c - b ) <NEWLINE> dist [ b - 1 ] = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( A ) <NEWLINE> all = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> s -= i <NEWLINE> all += ( i * s ) <NEWLINE> <DEDENT> ans = all % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> ans = n // ( a + b ) * a <NEWLINE> <COMMENT> <NL> rem = n % ( a + b ) <NEWLINE> <COMMENT> <NL> ans += min ( rem , a ) <NEWLINE> print ( ans ) <NEWLINE>
<NL> S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> mod = 2019 <NEWLINE> ss = [ 0 ] <NEWLINE> tmp = 0 <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> tmp += s * pow ( 10 , i , mod ) <NEWLINE> tmp %= mod <NEWLINE> ss . append ( tmp ) <NEWLINE> <NL> <DEDENT> cnts = [ 0 ] * 2019 <NEWLINE> ans = 0 <NEWLINE> for s in ss : <NEWLINE> <INDENT> ans += cnts [ s ] <NEWLINE> cnts [ s ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> def ng ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n , a , b , c = MI ( ) <NEWLINE> ss = [ SI ( ) for _ in range ( n ) ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = ss [ i ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if ( a , b ) == ( 0 , 0 ) : ng ( ) <NEWLINE> elif ( a , b ) == ( 0 , 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , b = a + 1 , b - 1 <NEWLINE> <DEDENT> elif ( a , b ) == ( 1 , 0 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , b = a - 1 , b + 1 <NEWLINE> <DEDENT> elif ( a , b , c ) == ( 1 , 1 , 0 ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , b = a + 1 , b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , b = a - 1 , b + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , b = a + 1 , b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , b = a - 1 , b + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if ( b , c ) == ( 0 , 0 ) : ng ( ) <NEWLINE> elif ( b , c ) == ( 0 , 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b , c = b + 1 , c - 1 <NEWLINE> <DEDENT> elif ( b , c ) == ( 1 , 0 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b , c = b - 1 , c + 1 <NEWLINE> <DEDENT> elif ( a , b , c ) == ( 0 , 1 , 1 ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b , c = b - 1 , c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b , c = b + 1 , c - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c < b : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b , c = b - 1 , c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b , c = b + 1 , c - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( a , c ) == ( 0 , 0 ) : ng ( ) <NEWLINE> elif ( a , c ) == ( 0 , 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , c = a + 1 , c - 1 <NEWLINE> <DEDENT> elif ( a , c ) == ( 1 , 0 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , c = a - 1 , c + 1 <NEWLINE> <DEDENT> elif ( a , b , c ) == ( 1 , 0 , 1 ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ss [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , c = a + 1 , c - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , c = a - 1 , c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a < c : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , c = a + 1 , c - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a , c = a - 1 , c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for s in ans : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> <COMMENT> <NL> L . append ( S ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( L ) ) ) <NEWLINE>
t = input ( ) <NEWLINE> <NL> list_t = list ( t ) <NEWLINE> <NL> n = len ( list_t ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if list_t [ i ] == <STRING> : <NEWLINE> <INDENT> if i > 0 and i < n - 1 : <NEWLINE> <INDENT> if list_t [ i - 1 ] == <STRING> and list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> if list_t [ i - 1 ] == <STRING> and list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> if list_t [ i - 1 ] == <STRING> and list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> if list_t [ i - 1 ] == <STRING> and list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> if list_t [ i - 1 ] == <STRING> and list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> if list_t [ i - 1 ] == <STRING> and list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i > 0 : <NEWLINE> <INDENT> if list_t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> if list_t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i < n - 1 : <NEWLINE> <INDENT> if list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> if list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <DEDENT> if list_t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list_t [ i ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( list_t ) ) <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> divisors = [ ] <NEWLINE> <NL> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> <NL> if i != x // i : <NEWLINE> <INDENT> divisors . append ( x // i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in divisors : <NEWLINE> <INDENT> for a in range ( i // 2 , x , 1 ) : <NEWLINE> <INDENT> b = a - i <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> elif a ** 5 - b ** 5 > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> string = input ( ) . split ( ) <NEWLINE> A = int ( string [ 0 ] ) <NEWLINE> B = int ( round ( float ( string [ 1 ] ) * 100 ) ) <NEWLINE> <NL> print ( int ( int ( ( A * B ) ) // int ( 100 ) ) ) <NEWLINE> <NL> <NL>
n , k = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> w_org = [ ] <NEWLINE> [ w_org . append ( int ( input ( ) ) ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def can ( p_org , k ) : <NEWLINE> <INDENT> p = p_org <NEWLINE> w = w_org [ : : - 1 ] <NEWLINE> while k and w : <NEWLINE> <INDENT> ww = w [ - 1 ] <NEWLINE> if ww <= p : <NEWLINE> <INDENT> p -= ww <NEWLINE> w . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p_org <NEWLINE> k -= 1 <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> p = p_org <NEWLINE> k -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return not ( w ) <NEWLINE> <NL> <NL> <DEDENT> left , right = max ( w_org ) - 1 , sum ( w_org ) + 1 <NEWLINE> roop = 0 <NEWLINE> while left + 1 < right : <NEWLINE> <INDENT> roop += 1 <NEWLINE> middle = ( left + right ) // 2 <NEWLINE> if can ( middle , k ) : <NEWLINE> <INDENT> right = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = middle <NEWLINE> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from functools import lru_cache <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , M = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> As = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> memo = [ False for _ in range ( N + 1 ) ] <NEWLINE> <NL> for item in As : <NEWLINE> <INDENT> memo [ item ] = True <NEWLINE> <NL> <DEDENT> res_list = [ ] <NEWLINE> <NL> prev = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if memo [ i ] == True : <NEWLINE> <INDENT> res_list . append ( i - 1 - prev ) <NEWLINE> prev = i + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if memo [ N ] == False and memo [ N ] == False : <NEWLINE> <INDENT> res_list . append ( N - prev ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ lru_cache <NEWLINE> def cal ( num ) : <NEWLINE> <INDENT> if 0 <= num <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif num == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return cal ( num - 1 ) + cal ( num - 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> res = 1 <NEWLINE> for item in res_list : <NEWLINE> <INDENT> res *= cal ( item ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( res % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> C = Counter ( A ) <NEWLINE> K = set ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in K : <NEWLINE> <INDENT> ans += C [ i ] * ( C [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> print ( ans - ( C [ i ] - 1 ) ) <COMMENT> <NEWLINE> <DEDENT>
from bisect import * <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A . insert ( 0 , 0 ) <NEWLINE> <NL> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , len ( B ) ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> rest_time = k - A [ i ] <NEWLINE> if rest_time >= 0 : <NEWLINE> <INDENT> numb = bisect_right ( B , rest_time ) <NEWLINE> anstmp = i + numb <NEWLINE> ans = max ( ans , anstmp ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def find ( Data , x ) : <NEWLINE> <INDENT> if Data [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Data [ x ] = find ( Data , Data [ x ] ) <NEWLINE> return Data [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( Data , a , b ) : <NEWLINE> <INDENT> a , b = find ( Data , a ) , find ( Data , b ) <NEWLINE> if a == b : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif Data [ a ] < Data [ b ] : <NEWLINE> <INDENT> Data [ a ] = Data [ a ] + Data [ b ] <NEWLINE> Data [ b ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Data [ b ] = Data [ b ] + Data [ a ] <NEWLINE> Data [ a ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> UF = [ - 1 for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> ai , bi = ai - 1 , bi - 1 <NEWLINE> unite ( UF , ai , bi ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if UF [ i ] < 0 : ans += 1 <NEWLINE> <DEDENT> print ( ans - 1 ) <NEWLINE>
import sys <NEWLINE> <NL> def check_alloc ( weights , cnt , cpct ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> cur = 0 <NEWLINE> for i in range ( len ( weights ) ) : <NEWLINE> <INDENT> w = weights [ i ] <NEWLINE> if cur + w > cpct : <NEWLINE> <INDENT> cur = w <NEWLINE> num += 1 <NEWLINE> if num > cnt or cur > cpct : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cur += w <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> weights = [ 0 ] * n <NEWLINE> sum = 0 <NEWLINE> maxi = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> weight = int ( input ( ) ) <NEWLINE> weights [ i ] = weight <NEWLINE> sum += weight <NEWLINE> maxi = max ( maxi , weight ) <NEWLINE> <NL> <DEDENT> if k == 1 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> start = maxi <NEWLINE> end = sum <NEWLINE> mid = 0 <NEWLINE> while start <= end : <NEWLINE> <INDENT> mid = int ( start + ( end - start ) / 2 ) <NEWLINE> can_alloc = check_alloc ( weights , k , mid ) <NEWLINE> if can_alloc == False : <NEWLINE> <INDENT> start = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if start == end : break <NEWLINE> end = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mid ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> N , K = map ( int , sysread ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> <NL> l = 0 <NEWLINE> r = 10 ** 9 <NEWLINE> while int ( l ) != int ( r ) : <NEWLINE> <COMMENT> <NL> <INDENT> test = ( l + r ) / 2 <NEWLINE> sum = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> sum += math . ceil ( a / test ) - 1 <NEWLINE> <NL> <DEDENT> if sum > K : <NEWLINE> <INDENT> l = test <NEWLINE> <DEDENT> elif sum < K : <NEWLINE> <INDENT> r = test <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> r = test <NEWLINE> <DEDENT> if int ( r ) == r and r - l < 1 : <NEWLINE> <INDENT> print ( int ( r ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> if int ( l ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> if int ( l ) == l : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> sum += math . ceil ( a / int ( l ) ) - 1 <NEWLINE> <DEDENT> if sum == K : <NEWLINE> <INDENT> print ( int ( l ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( l ) + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> a = int ( t [ 0 ] ) <NEWLINE> b = t [ 1 ] <NEWLINE> c = int ( t [ 2 ] ) <NEWLINE> d = 0 <NEWLINE> if ( b == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( b == <STRING> ) : <NEWLINE> <INDENT> d = a + c <NEWLINE> <DEDENT> if ( b == <STRING> ) : <NEWLINE> <INDENT> d = a - c <NEWLINE> <DEDENT> if ( b == <STRING> ) : <NEWLINE> <INDENT> d = a * c <NEWLINE> <DEDENT> if ( b == <STRING> ) : <NEWLINE> <INDENT> d = int ( a / c ) <NEWLINE> <DEDENT> print ( str ( d ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> r = 0 <NEWLINE> for i in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> r += int ( n [ i ] ) <NEWLINE> <DEDENT> if r % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> BUILDINGS = tuple ( x for x in range ( 4 ) ) <NEWLINE> FLOORS = tuple ( x for x in range ( 3 ) ) <NEWLINE> ROOMS = tuple ( x for x in range ( 10 ) ) <NEWLINE> <NL> occupant = [ [ [ 0 for r in ROOMS ] for f in FLOORS ] for b in BUILDINGS ] <NEWLINE> <NL> n = input ( ) <COMMENT> <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> b , f , r , v = map ( int , line . split ( ) ) <NEWLINE> occupant [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in BUILDINGS : <NEWLINE> <INDENT> if b : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> for f in FLOORS : <NEWLINE> <INDENT> print ( <STRING> , * occupant [ b ] [ f ] ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> a . append ( float ( <STRING> ) ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if a [ - 1 ] != 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i == a [ - 1 ] : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> import numpy as np <NEWLINE> mem = np . full ( ( H , W ) , inf ) <NEWLINE> l = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> mem [ i , j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( W - 1 ) : <NEWLINE> <INDENT> mem [ : , i + 1 ] = np . minimum ( mem [ : , i ] + 1 , mem [ : , i + 1 ] ) <NEWLINE> <DEDENT> for i in reversed ( range ( 1 , W ) ) : <NEWLINE> <INDENT> mem [ : , i - 1 ] = np . minimum ( mem [ : , i - 1 ] , mem [ : , i ] + 1 ) <NEWLINE> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> mem [ i + 1 , : ] = np . minimum ( mem [ i + 1 , : ] , mem [ i , : ] + 1 ) <NEWLINE> <DEDENT> for i in reversed ( range ( 1 , H ) ) : <NEWLINE> <INDENT> mem [ i - 1 , : ] = np . minimum ( mem [ i - 1 , : ] , mem [ i , : ] + 1 ) <NEWLINE> <DEDENT> print ( int ( np . max ( mem ) ) ) <NEWLINE>
s = input ( ) <NEWLINE> num = 0 <NEWLINE> a = [ 0 ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> a . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( a ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def read_pair ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N , M = read_pair ( ) <NEWLINE> adj = [ [ ] for x in range ( N ) ] <NEWLINE> rev = [ [ ] for y in range ( N ) ] <NEWLINE> <NL> outdegree = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = read_pair ( ) <NEWLINE> <NL> <COMMENT> <NL> x -= 1 <NEWLINE> y -= 1 <NEWLINE> <NL> adj [ x ] . append ( y ) <NEWLINE> rev [ y ] . append ( x ) <NEWLINE> outdegree [ x ] += 1 <NEWLINE> <NL> <DEDENT> maxpath = [ 0 ] * N <NEWLINE> q = deque ( ) <NEWLINE> <NL> for x in range ( N ) : <NEWLINE> <INDENT> if outdegree [ x ] == 0 : <NEWLINE> <INDENT> q . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> while q : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for y in adj [ x ] : <NEWLINE> <INDENT> maxpath [ x ] = max ( maxpath [ x ] , 1 + maxpath [ y ] ) <NEWLINE> <DEDENT> for z in rev [ x ] : <NEWLINE> <INDENT> outdegree [ z ] -= 1 <NEWLINE> if outdegree [ z ] == 0 : <NEWLINE> <INDENT> q . append ( z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( maxpath ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> journey = [ 1 ] <NEWLINE> dup = { } <NEWLINE> for i in range ( N + 100000 ) : <NEWLINE> <INDENT> journey . append ( A [ journey [ - 1 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> end_idx , start_idx = 0 , 0 <NEWLINE> dup = { } <NEWLINE> for i , j in enumerate ( journey ) : <NEWLINE> <INDENT> if j in dup : <NEWLINE> <INDENT> end_idx = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dup [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> for i , j in enumerate ( journey ) : <NEWLINE> <INDENT> if j == journey [ end_idx ] : <NEWLINE> <INDENT> start_idx = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if K <= start_idx : <NEWLINE> <INDENT> print ( journey [ K ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b = end_idx - start_idx <NEWLINE> m = ( K - start_idx ) % b <NEWLINE> print ( journey [ start_idx + m ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> kt = tuple ( range ( 1 , k + 1 ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> dp = [ INF ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in kt : <NEWLINE> <INDENT> i_j = i + j <NEWLINE> if i_j < n : <NEWLINE> <INDENT> x = dp [ i ] + abs ( h [ i ] - h [ i_j ] ) <NEWLINE> if dp [ i_j ] > x : <NEWLINE> <INDENT> dp [ i_j ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> nd = 1 <NEWLINE> mod1 = 0 <NEWLINE> listmod = [ 0 ] * 2019 <NEWLINE> for i in S [ : : - 1 ] : <NEWLINE> <INDENT> mod1 = ( int ( i ) * nd + mod1 ) % 2019 <NEWLINE> listmod [ mod1 ] += 1 <NEWLINE> nd = ( nd * 10 ) % 2019 <NEWLINE> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> n = listmod [ i ] <NEWLINE> if ( i == 0 ) : <NEWLINE> <INDENT> if ( n == 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif ( n >= 2 ) : <NEWLINE> <INDENT> ans += ( ( n + 1 ) * n ) // 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( n > 1 ) : <NEWLINE> <INDENT> ans += ( ( n - 1 ) * n ) // 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> from itertools import product , combinations_with_replacement <NEWLINE> <NL> def gcd_ ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> ans = 3 * K * ( K - 1 ) + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for i , j , k in combinations_with_replacement ( range ( 2 , K + 1 ) , 3 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> ans += gcd_ ( i , j , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd_ ( i , j , k ) * 6 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> from math import floor <NEWLINE> <NL> def parse ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> A , B , N = parse ( ) <NEWLINE> <NL> x = B - 1 if B - 1 <= N else N <NEWLINE> print ( floor ( ( A * x ) / B ) - A * floor ( x / B ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> limit_N = 5000000 <NEWLINE> N = limit_N if N > limit_N else N <NEWLINE> <NL> x = 0 <NEWLINE> max_val = floor ( ( A * x ) / B ) - A * floor ( x / B ) <NEWLINE> <NL> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> val = floor ( ( A * x ) / B ) - A * floor ( x / B ) <NEWLINE> if max_val < val : <NEWLINE> <INDENT> max_val = val <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_val ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> hw = [ ] <NEWLINE> hNum = [ 0 ] * H <NEWLINE> wNum = [ 0 ] * W <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h , w = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> hw . append ( [ h , w ] ) <NEWLINE> hNum [ h - 1 ] += 1 <NEWLINE> wNum [ w - 1 ] += 1 <NEWLINE> <NL> <DEDENT> hmax = max ( hNum ) <NEWLINE> hMaxList = [ ] <NEWLINE> wmax = max ( wNum ) <NEWLINE> wMaxList = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> if ( hmax == hNum [ i ] ) : <NEWLINE> <INDENT> hMaxList . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> if ( wmax == wNum [ i ] ) : <NEWLINE> <INDENT> wMaxList . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = wmax + hmax <NEWLINE> count = 0 <NEWLINE> for i in hw : <NEWLINE> <INDENT> if ( hNum [ i [ 0 ] - 1 ] == hmax and wNum [ i [ 1 ] - 1 ] == wmax ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if ( hNum . count ( hmax ) * wNum . count ( wmax ) == count ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( i + ( n // i ) * i ) * ( n // i ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> s1 = sum ( lst ) <NEWLINE> num = s1 * s1 <NEWLINE> denom = 0 <NEWLINE> mod = 1000000007 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> denom += ( lst [ i ] * lst [ i ] ) <NEWLINE> <DEDENT> print ( ( ( num - denom ) // 2 ) % mod ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> S = np . array ( list ( read ( ) . rstrip ( ) ) , np . int8 ) <NEWLINE> <NL> R = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> B = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> G = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> <NL> @ njit <NEWLINE> def f ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> answer = R * B * G - f ( S ) <NEWLINE> print ( answer ) <NEWLINE>
import sys <NEWLINE> from queue import deque <NEWLINE> <NL> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> <NL> def hierarchize ( source ) : <NEWLINE> <INDENT> global edges , hierarchy <NEWLINE> hierarchy = [ - 1 ] * n <NEWLINE> queue = deque ( [ ( 0 , source ) ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> h , v = queue . popleft ( ) <NEWLINE> if hierarchy [ v ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> hierarchy [ v ] = h <NEWLINE> if v == sink : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> queue . extend ( ( h + 1 , target ) <NEWLINE> <INDENT> for remain , target , _ in edges [ v ] if hierarchy [ target ] == - 1 and remain ) <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def augment ( v , limit ) : <NEWLINE> <INDENT> global sink , edges , hierarchy <NEWLINE> if v == sink : <NEWLINE> <INDENT> return limit <NEWLINE> <DEDENT> res = 0 <NEWLINE> for e in edges [ v ] : <NEWLINE> <INDENT> remain , target , idx = e <NEWLINE> if remain == 0 or hierarchy [ v ] >= hierarchy [ target ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> aug = augment ( target , min ( limit , remain ) ) <NEWLINE> e [ 0 ] -= aug <NEWLINE> edges [ target ] [ idx ] [ 0 ] += aug <NEWLINE> res += aug <NEWLINE> limit -= aug <NEWLINE> if not limit : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sink = n - 1 <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> hierarchy = [ - 1 ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t , c = map ( int , input ( ) . split ( ) ) <NEWLINE> es , et = edges [ s ] , edges [ t ] <NEWLINE> ls , lt = len ( es ) , len ( et ) <NEWLINE> edges [ s ] . append ( [ c , t , lt ] ) <NEWLINE> edges [ t ] . append ( [ 0 , s , ls ] ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> while hierarchize ( 0 ) : <NEWLINE> <INDENT> res += augment ( 0 , 10000001 ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> mul = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> mul *= ai <NEWLINE> if mul > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> pi = 3.14159265359 <NEWLINE> print ( <STRING> % ( pi * r * r , 2 * pi * r ) ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def gcd2 ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def gcd ( a , b , c ) : <NEWLINE> <INDENT> return gcd2 ( gcd2 ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 ) : <NEWLINE> <INDENT> for k in range ( j , N + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> res += gcd ( k , j , i ) <NEWLINE> <DEDENT> elif i != j != k : <NEWLINE> <INDENT> res += gcd ( k , j , i ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += gcd ( k , j , i ) * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> rl = [ i for i , _ in enumerate ( c ) if _ == <STRING> ] <NEWLINE> <NL> cnt = 0 <NEWLINE> loc = 0 <NEWLINE> rid = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if c [ loc ] == <STRING> : <NEWLINE> <INDENT> rloc = rl [ rid ] <NEWLINE> rid -= 1 <NEWLINE> if rloc < loc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> loc += 1 <NEWLINE> if loc == n : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> tScore = 0 <NEWLINE> hScore = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> T , H = input ( ) . split ( ) <NEWLINE> if T == H : <NEWLINE> <INDENT> tScore += 1 <NEWLINE> hScore += 1 <NEWLINE> <DEDENT> elif T > H : <NEWLINE> <INDENT> tScore += 3 <NEWLINE> <DEDENT> elif H > T : <NEWLINE> <INDENT> hScore += 3 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % ( tScore , hScore ) ) <NEWLINE>
import heapq <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = [ ] <NEWLINE> cnt_plus = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] > 0 : <NEWLINE> <INDENT> cnt_plus += 1 <NEWLINE> heapq . heappush ( q , ( - arr [ i ] , 1 ) ) <NEWLINE> <DEDENT> elif arr [ i ] < 0 : <NEWLINE> <INDENT> heapq . heappush ( q , ( arr [ i ] , - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapq . heappush ( q , ( 0 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> pick = [ ] <NEWLINE> prev_plus = 0 <NEWLINE> prev_minus = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> tmp , flag = heapq . heappop ( q ) <NEWLINE> tmp *= - 1 <NEWLINE> if flag == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> pick . append ( tmp ) <NEWLINE> prev_plus = tmp <NEWLINE> <DEDENT> if flag == - 1 : <NEWLINE> <INDENT> if cnt == 0 : <NEWLINE> <INDENT> prev_minus = tmp <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> pick . append ( prev_minus ) <NEWLINE> pick . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= pick [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand_plus = 0 <NEWLINE> cand_minus = 0 <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> tmp , flag = heapq . heappop ( q ) <NEWLINE> tmp *= - 1 <NEWLINE> if flag == 1 and cand_plus == 0 : <NEWLINE> <INDENT> cand_plus = tmp <NEWLINE> <DEDENT> if flag == - 1 and cand_minus == 0 : <NEWLINE> <INDENT> cand_minus = tmp <NEWLINE> <DEDENT> <DEDENT> if ( k % 2 == 1 and cnt_plus == 0 ) or ( cand_plus == 0 and cand_minus == 0 ) : <NEWLINE> <INDENT> if arr . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> heapq . heappush ( q , abs ( arr [ i ] ) ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> ans *= heapq . heappop ( q ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ( - ans ) % mod ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if prev_plus * cand_plus >= prev_minus * cand_minus : <NEWLINE> <INDENT> pick . append ( cand_plus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if prev_plus != 0 : <NEWLINE> <INDENT> pick . remove ( prev_plus ) <NEWLINE> pick . append ( prev_minus ) <NEWLINE> pick . append ( cand_minus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pick . append ( cand_plus ) <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= pick [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <DEDENT> <DEDENT>
def check ( numbers , threshold ) : <NEWLINE> <NL> <INDENT> total = 0 <NEWLINE> <NL> for number in numbers : <NEWLINE> <INDENT> d , m = divmod ( number , threshold ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> total += d <NEWLINE> <DEDENT> return total <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> numbers = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> bottom , top = 1 , 2 * ( 10 ** 9 ) <NEWLINE> <NL> while bottom < top : <NEWLINE> <COMMENT> <NL> <INDENT> if check ( numbers , ( bottom + top ) // 2 ) <= k : <NEWLINE> <INDENT> top = ( bottom + top ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bottom = ( ( bottom + top ) // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( top ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input = stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> lst = [ ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> left = s [ : i ] <NEWLINE> right = s [ i : ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for j in set ( left ) : <NEWLINE> <INDENT> if j in set ( right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> lst . append ( cnt ) <NEWLINE> <NL> <DEDENT> if not lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( lst ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i - 1 for i in a ] <NEWLINE> visited = [ - 1 ] * n <NEWLINE> route = [ ] <NEWLINE> now = 0 <NEWLINE> hop = 0 <NEWLINE> while visited [ now ] == - 1 : <NEWLINE> <INDENT> visited [ now ] = hop <NEWLINE> route . append ( now ) <NEWLINE> now = a [ now ] <NEWLINE> hop += 1 <NEWLINE> <DEDENT> loop_st = 0 <NEWLINE> for r in route : <NEWLINE> <INDENT> if r == now : break <NEWLINE> loop_st += 1 <NEWLINE> <DEDENT> loop = route [ loop_st : ] <NEWLINE> if k < len ( route ) : <NEWLINE> <INDENT> print ( route [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( k - loop_st ) % len ( loop ) ] + 1 ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> n = input ( ) <NEWLINE> ans = 0 <NEWLINE> r_set = set ( ) <NEWLINE> g_set = set ( ) <NEWLINE> b_set = set ( ) <NEWLINE> <NL> for _ in range ( s ) : <NEWLINE> <INDENT> if n [ _ ] == <STRING> : <NEWLINE> <INDENT> r_set . add ( _ ) <NEWLINE> <DEDENT> elif n [ _ ] == <STRING> : <NEWLINE> <INDENT> g_set . add ( _ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_set . add ( _ ) <NEWLINE> <NL> <DEDENT> <DEDENT> len_b = len ( b_set ) <NEWLINE> <NL> for r in r_set : <NEWLINE> <INDENT> for g in g_set : <NEWLINE> <INDENT> diff = abs ( r - g ) <NEWLINE> minus = set ( ) <NEWLINE> if r < g : <NEWLINE> <INDENT> if g + diff in b_set : <NEWLINE> <INDENT> minus . add ( g + diff ) <NEWLINE> <DEDENT> if r - diff in b_set : <NEWLINE> <INDENT> minus . add ( r - diff ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if r + diff in b_set : <NEWLINE> <INDENT> minus . add ( r + diff ) <NEWLINE> <DEDENT> if g - diff in b_set : <NEWLINE> <INDENT> minus . add ( g - diff ) <NEWLINE> <DEDENT> <DEDENT> if ( r + g ) / 2 in b_set : <NEWLINE> <INDENT> minus . add ( ( r + g ) / 2 ) <NEWLINE> <DEDENT> ans += len_b - len ( minus ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , b = divmod ( n , 26 ) <NEWLINE> n = a <NEWLINE> lst . append ( b ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( lst ) - 1 ) : <NEWLINE> <INDENT> if lst [ i ] <= 0 : <NEWLINE> <INDENT> lst [ i ] += 26 <NEWLINE> lst [ i + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if lst [ - 1 ] == 0 : <NEWLINE> <INDENT> lst . pop ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> lst [ i ] = chr ( lst [ i ] + 96 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( lst [ : : - 1 ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> place = [ 0 ] <NEWLINE> table = [ 0 ] * N <NEWLINE> table [ 0 ] = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> next_place = A_list [ place [ - 1 ] ] - 1 <NEWLINE> if table [ next_place ] == 1 : <NEWLINE> <INDENT> idx = place . index ( next_place ) <NEWLINE> loop = place [ idx : ] <NEWLINE> break <NEWLINE> <DEDENT> table [ next_place ] = 1 <NEWLINE> place . append ( next_place ) <NEWLINE> <NL> <DEDENT> if K < len ( place ) : <NEWLINE> <INDENT> print ( place [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( K - idx ) % len ( loop ) ] + 1 ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> c = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> c [ i ] = c [ i - 1 ] + ( s [ i - 1 ] + s [ i ] == <STRING> ) <NEWLINE> <NL> <DEDENT> for x in a : <NEWLINE> <INDENT> print ( c [ x [ 1 ] - 1 ] - c [ x [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ K + i ] / A [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ float ( <STRING> ) ] * n <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count = x * i <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> l [ j ] = min ( l [ j ] , a [ ( j - i ) % n ] ) <NEWLINE> count += l [ j ] <NEWLINE> <DEDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 18 <NEWLINE> left = 0 <NEWLINE> right = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( left - right ) ) <NEWLINE> left += A [ i ] <NEWLINE> right -= A [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = sum ( b ) <NEWLINE> d = 0 <NEWLINE> e = 0 <NEWLINE> f = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> d = d + b [ i ] <NEWLINE> if d >= c / 2 : <NEWLINE> <INDENT> e = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( e ) : <NEWLINE> <INDENT> f = f + b [ i ] <NEWLINE> <DEDENT> if abs ( d - ( c - d ) ) < abs ( f - ( c - f ) ) : <NEWLINE> <INDENT> print ( abs ( d - ( c - d ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( f - ( c - f ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> min_num = N + 1 <NEWLINE> <NL> W = [ ] <NEWLINE> E = [ ] <NEWLINE> <NL> w_cnt = 0 <NEWLINE> e_cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> w_cnt += 1 <NEWLINE> <DEDENT> W . append ( w_cnt ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> min_num = min ( min_num , W [ i - 1 ] + e_cnt ) <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> e_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( min_num , e_cnt ) ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> def devide ( n ) : <NEWLINE> <INDENT> if memo [ n ] != - 1 : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> if 3 <= n : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if n - i >= 3 : <NEWLINE> <INDENT> tmp += devide ( n - i ) <NEWLINE> <DEDENT> <DEDENT> memo [ n ] = tmp <NEWLINE> return tmp <NEWLINE> <NL> <DEDENT> s = int ( input ( ) ) <NEWLINE> memo = [ - 1 for i in range ( s + 1 ) ] <NEWLINE> print ( devide ( s ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for aa in a : <NEWLINE> <INDENT> ans *= aa <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= k : <NEWLINE> <INDENT> k -= a <NEWLINE> if b <= k : <NEWLINE> <INDENT> k -= b <NEWLINE> print ( 0 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , b - k ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( N ) <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ j ] - h [ i ] ) for j in range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> h , w = ( int ( n ) for n in stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for cnt in range ( h ) : <NEWLINE> <INDENT> print ( ( <STRING> * ( ( w + 2 ) // 2 ) ) [ cnt % 2 : w + cnt % 2 ] ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 1 <NEWLINE> if not 0 in A : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> answer = answer * i <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if answer <= 10 ** 18 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> s = int ( input ( ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> maximum = int ( s / 3 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( maximum ) : <NEWLINE> <INDENT> ans += ( math . factorial ( i + s - ( i * 3 + 3 ) ) // ( math . factorial ( i ) * math . factorial ( s - ( i * 3 + 3 ) ) ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( int ( ans ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
s = str ( input ( ) ) [ : : - 1 ] <NEWLINE> sum_of_digits = 0 <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> <NL> cnt [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> for c in s : <NEWLINE> <INDENT> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> sum_of_digits += d * int ( c ) <NEWLINE> sum_of_digits %= 2019 <NEWLINE> cnt [ sum_of_digits ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in cnt ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> import math <NEWLINE> S = <STRING> % ( r ** 2 * math . pi ) <NEWLINE> L = <STRING> % ( 2 * r * math . pi ) <NEWLINE> print ( str ( S ) + <STRING> + str ( L ) ) <NEWLINE> <NL>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ ni ] ] ) ) <NEWLINE> <DEDENT>
def bubble_sort ( A ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in reversed ( range ( len ( A ) ) ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if A [ j ] > A [ j + 1 ] : <NEWLINE> <INDENT> temp = A [ j ] <NEWLINE> A [ j ] = A [ j + 1 ] <NEWLINE> A [ j + 1 ] = temp <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = bubble_sort ( A ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( count ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( t [ 0 ] ) <NEWLINE> A . append ( t [ 1 : ] ) <NEWLINE> <NL> <DEDENT> alist = [ ] <NEWLINE> <NL> for i in range ( 1 << N ) : <NEWLINE> <INDENT> mlist = [ ] <NEWLINE> slist = [ ] <NEWLINE> plist = [ 0 ] * M <COMMENT> <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <NL> <INDENT> if ( i >> j ) & 1 == 1 : <NEWLINE> <INDENT> mlist . append ( C [ j ] ) <NEWLINE> slist . append ( A [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( len ( slist ) ) : <NEWLINE> <INDENT> if len ( slist ) == 1 : <NEWLINE> <INDENT> plist = slist [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plist = [ a + b for a , b in zip ( plist , slist [ j ] ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> if all ( ( x >= X for x in plist ) ) == True : <NEWLINE> <INDENT> alist . append ( sum ( mlist ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( alist ) != 0 : <NEWLINE> <INDENT> print ( min ( alist ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def bubblesort ( N , A ) : <NEWLINE> <INDENT> c , flag = 0 , 1 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> c += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( A , c ) <NEWLINE> <NL> <DEDENT> A , c = bubblesort ( int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> . join ( [ str ( v ) for v in A ] ) ) <NEWLINE> print ( c ) <NEWLINE>
def calc ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 ** ( n - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def normailze ( s , n ) : <NEWLINE> <INDENT> return ( n - len ( s ) ) * <STRING> + s <NEWLINE> <NL> <NL> <DEDENT> def solution ( s ) : <NEWLINE> <INDENT> a = calc ( len ( s ) ) <NEWLINE> cnt = 0 <NEWLINE> n = len ( s ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return int ( s ) <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> binary = normailze ( bin ( i ) [ 2 : ] , n - 1 ) <NEWLINE> b = s [ 0 ] <NEWLINE> f = 1 <NEWLINE> for j in binary : <NEWLINE> <INDENT> if int ( j ) == 1 : <NEWLINE> <INDENT> cnt += int ( b ) <NEWLINE> b = s [ f ] <NEWLINE> f += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += s [ f ] <NEWLINE> f += 1 <NEWLINE> <DEDENT> <DEDENT> cnt += int ( b ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> print ( solution ( input ( ) ) ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> lis [ B - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> lis [ A - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ A - 1 ] = 0 <NEWLINE> lis [ B - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lis . count ( 1 ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> k = min ( n , b - 1 ) <NEWLINE> print ( int ( ( a * k ) / b ) - a * int ( k / b ) ) <NEWLINE>
import sys <NEWLINE> <NL> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> abc = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> ans = [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> u , v = s [ 0 ] , s [ 1 ] <NEWLINE> if abc [ u ] == abc [ v ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif abc [ u ] > abc [ v ] : <NEWLINE> <INDENT> abc [ u ] -= 1 <NEWLINE> abc [ v ] += 1 <NEWLINE> ans . append ( v ) <NEWLINE> <DEDENT> elif abc [ u ] < abc [ v ] : <NEWLINE> <INDENT> abc [ u ] += 1 <NEWLINE> abc [ v ] -= 1 <NEWLINE> ans . append ( u ) <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> ans . append ( u ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if u in S [ i + 1 ] : <NEWLINE> <INDENT> abc [ u ] += 1 <NEWLINE> abc [ v ] -= 1 <NEWLINE> ans . append ( u ) <NEWLINE> <DEDENT> elif v in S [ i + 1 ] : <NEWLINE> <INDENT> abc [ v ] += 1 <NEWLINE> abc [ u ] -= 1 <NEWLINE> ans . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for ans_ in ans : print ( ans_ ) <NEWLINE>
import networkx as nx <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = nx . utils . UnionFind ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in uf . to_sets ( ) : <NEWLINE> <INDENT> ans = max ( ans , len ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> if len ( s ) < 26 : <NEWLINE> <INDENT> for i in range ( 97 , 124 ) : <NEWLINE> <INDENT> if chr ( i ) not in s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s + chr ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prep = [ s [ - 1 ] ] <NEWLINE> for i in s [ - 2 : : - 1 ] : <NEWLINE> <INDENT> if i > prep [ - 1 ] : <NEWLINE> <INDENT> prep . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( prep ) == 26 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : - len ( prep ) - 1 ] + min ( i for i in prep if i > s [ - len ( prep ) - 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> total *= A [ i ] <NEWLINE> if total > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = 0 <NEWLINE> if K <= N : <NEWLINE> <INDENT> current = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> current = A [ current - 1 ] <NEWLINE> <DEDENT> print ( current ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> isReturn = [ 0 for i in range ( N ) ] <NEWLINE> step = 1 <NEWLINE> current = 1 <NEWLINE> isReturn [ current - 1 ] = step <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> current = A [ current - 1 ] <NEWLINE> step += 1 <NEWLINE> if isReturn [ current - 1 ] == 0 : <NEWLINE> <INDENT> isReturn [ current - 1 ] = step <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = step - isReturn [ current - 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> t = ( ( K - step ) % r ) + 1 <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> current = A [ current - 1 ] <NEWLINE> <NL> <DEDENT> print ( current ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> Aq = [ ] <NEWLINE> DP = [ 0 for i in range ( 5 * 10 ** 5 ) ] <NEWLINE> DPP = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i >= A [ i ] : <NEWLINE> <INDENT> ans += DP [ i - A [ i ] ] <NEWLINE> <DEDENT> if A [ i ] <= N : <NEWLINE> <INDENT> DP [ A [ i ] + i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( ( 10 ** n - 9 ** n * 2 + 8 ** n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> datas = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> now_max = max ( datas [ 1 : ] ) <NEWLINE> max_index = datas . index ( now_max ) <NEWLINE> diff = now_max - datas [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if i == max_index : <NEWLINE> <INDENT> d = datas [ i + 1 : ] <NEWLINE> now_max = max ( d ) <NEWLINE> max_index = d . index ( now_max ) + i + 1 <NEWLINE> <DEDENT> new_diff = now_max - datas [ i ] <NEWLINE> if diff < new_diff : <NEWLINE> <INDENT> diff = new_diff <NEWLINE> <NL> <DEDENT> <DEDENT> print ( diff ) <NEWLINE> <COMMENT> <NL>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> matrixL = [ [ 0 ] * m for i in range ( n ) ] <NEWLINE> matrixR = [ [ 0 ] * l for i in range ( m ) ] <NEWLINE> for row in range ( n ) : <NEWLINE> <INDENT> matrixL [ row ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> for row in range ( m ) : <NEWLINE> <INDENT> matrixR [ row ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> c = [ [ 0 ] * l for i in range ( n ) ] <NEWLINE> for ansColumn in range ( l ) : <NEWLINE> <INDENT> for row in range ( n ) : <NEWLINE> <INDENT> for column in range ( m ) : <NEWLINE> <INDENT> c [ row ] [ ansColumn ] = c [ row ] [ ansColumn ] + matrixL [ row ] [ column ] * matrixR [ column ] [ ansColumn ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for row in range ( n ) : <NEWLINE> <INDENT> for column in range ( l ) : <NEWLINE> <INDENT> if column == l - 1 : <NEWLINE> <INDENT> print ( c [ row ] [ column ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % c [ row ] [ column ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ <STRING> ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = input ( ) <NEWLINE> <DEDENT> s = set ( s ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ <STRING> ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s [ i ] = str ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> dp = [ <STRING> ] * N <NEWLINE> a , b , c = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) <NEWLINE> a [ 0 ] , b [ 0 ] , c [ 0 ] = A , B , C <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if a [ i ] + b [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a [ i ] == 1 and b [ i ] == 0 : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] == 0 and b [ i ] == 1 : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] == 0 and b [ i ] > 1 : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] > 1 and b [ i ] == 0 : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] == 1 and b [ i ] == 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif a [ i ] == 1 and b [ i ] > 1 : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] > 1 and b [ i ] == 1 : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] > 1 and b [ i ] > 1 : <NEWLINE> <INDENT> if a [ i ] >= b [ i ] : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] < b [ i ] : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> if b [ i ] + c [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif b [ i ] == 1 and c [ i ] == 0 : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] == 0 and c [ i ] == 1 : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] == 0 and c [ i ] > 1 : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] > 1 and c [ i ] == 0 : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] == 1 and c [ i ] == 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif b [ i ] == 1 and c [ i ] > 1 : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] > 1 and c [ i ] == 1 : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] > 1 and c [ i ] > 1 : <NEWLINE> <INDENT> if b [ i ] >= c [ i ] : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] - 1 <NEWLINE> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] < c [ i ] : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + 1 <NEWLINE> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> if c [ i ] + a [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif c [ i ] == 1 and a [ i ] == 0 : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif c [ i ] == 0 and a [ i ] == 1 : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif c [ i ] == 0 and a [ i ] > 1 : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif c [ i ] > 1 and a [ i ] == 0 : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif c [ i ] == 1 and a [ i ] == 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif c [ i ] == 1 and a [ i ] > 1 : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif c [ i ] > 1 and a [ i ] == 1 : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif c [ i ] > 1 and a [ i ] > 1 : <NEWLINE> <INDENT> if c [ i ] >= a [ i ] : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] - 1 <NEWLINE> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <DEDENT> elif c [ i ] < a [ i ] : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> a [ i + 1 ] = a [ i ] - 1 <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> dp [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for v in dp : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : left + n1 ] <NEWLINE> R = A [ mid : mid + n2 ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( S , 0 , len ( S ) ) <NEWLINE> print ( <STRING> . join ( map ( str , S ) ) ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> p = 0 <NEWLINE> for e in a : <NEWLINE> <INDENT> if p != e : <NEWLINE> <INDENT> b . append ( e ) <NEWLINE> <DEDENT> p = e <NEWLINE> <DEDENT> a = b <NEWLINE> n = len ( b ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i + 1 == n : break <NEWLINE> else : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> while i + 1 < n and a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i + 1 < n and a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> a = b = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = s <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a >= K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( H , W , S ) : <NEWLINE> <INDENT> U = np . full ( shape = ( H + 2 , W + 2 ) , fill_value = - 1 , dtype = np . int64 ) <NEWLINE> D = np . full ( shape = ( H + 2 , W + 2 ) , fill_value = - 1 , dtype = np . int64 ) <NEWLINE> L = np . full ( shape = ( H + 2 , W + 2 ) , fill_value = - 1 , dtype = np . int64 ) <NEWLINE> R = np . full ( shape = ( H + 2 , W + 2 ) , fill_value = - 1 , dtype = np . int64 ) <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if not S [ h ] [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if U [ h ] [ w ] == - 1 : <NEWLINE> <INDENT> U [ h ] [ w ] = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> d += 1 <NEWLINE> if not S [ h + d ] [ w ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> U [ h + d ] [ w ] = d <NEWLINE> <DEDENT> <DEDENT> if L [ h ] [ w ] == - 1 : <NEWLINE> <INDENT> L [ h ] [ w ] = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> d += 1 <NEWLINE> if not S [ h ] [ w + d ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> L [ h ] [ w + d ] = d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for h in range ( H + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for w in range ( W + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if not S [ h ] [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if D [ h ] [ w ] == - 1 : <NEWLINE> <INDENT> D [ h ] [ w ] = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> d += 1 <NEWLINE> if not S [ h - d ] [ w ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> D [ h - d ] [ w ] = d <NEWLINE> <DEDENT> <DEDENT> if R [ h ] [ w ] == - 1 : <NEWLINE> <INDENT> R [ h ] [ w ] = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> d += 1 <NEWLINE> if not S [ h ] [ w - d ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> R [ h ] [ w - d ] = d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dist = U + D + L + R + 1 <NEWLINE> ans = np . max ( dist ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = np . zeros ( shape = ( H + 2 , W + 2 ) , dtype = np . bool ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> S [ i ] [ 1 : - 1 ] = [ s == <STRING> for s in input ( ) . rstrip ( ) ] <NEWLINE> <NL> <DEDENT> ans = solve ( H , W , S ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> dp_not = defaultdict ( lambda : - INF ) <NEWLINE> dp_take = defaultdict ( lambda : - INF ) <NEWLINE> dp_not [ ( 0 , 0 ) ] = 0 <NEWLINE> <NL> for i , x in enumerate ( A , 1 ) : <NEWLINE> <INDENT> j = ( i - 1 ) // 2 <NEWLINE> for n in ( j , j + 1 ) : <NEWLINE> <INDENT> dp_not [ ( i , n ) ] = max ( dp_not [ ( i - 1 , n ) ] , dp_take [ ( i - 1 , n ) ] ) <NEWLINE> dp_take [ ( i , n ) ] = dp_not [ ( i - 1 , n - 1 ) ] + x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp_not [ ( N , N // 2 ) ] , dp_take [ ( N , N // 2 ) ] ) ) <NEWLINE>
def makeFibonacci ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return str ( 1 ) <NEWLINE> <DEDENT> F = [ None ] * ( n + 1 ) <NEWLINE> F [ 0 ] = 1 <NEWLINE> F [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> F [ i ] = F [ i - 1 ] + F [ i - 2 ] <NEWLINE> <DEDENT> return str ( F [ n ] ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( makeFibonacci ( n ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> m = 7 % k <NEWLINE> s = set ( ) <NEWLINE> cnt = 1 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> elif m in s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( m ) <NEWLINE> <DEDENT> m = ( ( m * ( 10 % k ) ) % k + 7 % k ) % k <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> sl = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> sl . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> if sum ( sl ) % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( sl ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for v in itertools . combinations ( sl , n - 1 ) : <NEWLINE> <INDENT> if sum ( v ) % 10 != 0 : <NEWLINE> <INDENT> ans = max ( ans , sum ( v ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> s = <STRING> . join ( reversed ( list ( input ( ) ) ) ) <NEWLINE> t = <STRING> <NEWLINE> text = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> while len ( t ) < len ( s ) : <NEWLINE> <INDENT> for tx in text : <NEWLINE> <INDENT> if t + tx == s [ : len ( t + tx ) ] : <NEWLINE> <INDENT> t += tx <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N <= B - 1 : <NEWLINE> <INDENT> max = int ( A * N / B ) - A * int ( N / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = int ( A * ( B - 1 ) / B ) - A * int ( ( B - 1 ) / B ) <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> l_ans = set ( ) <NEWLINE> <NL> count = 1 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if count <= k : <NEWLINE> <INDENT> l_ans . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> for i in range ( b , a - 1 , - 1 ) : <NEWLINE> <INDENT> if count <= k : <NEWLINE> <INDENT> l_ans . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> for num in sorted ( l_ans ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> S = input ( ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> s_list = list ( S ) <NEWLINE> alpha_list = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> flag_list = [ False for _ in range ( 26 ) ] <NEWLINE> <NL> <NL> if len ( s_list ) == 26 : <NEWLINE> <INDENT> for i in range ( 25 , 0 , - 1 ) : <NEWLINE> <INDENT> if s_list [ i - 1 ] < s_list [ i ] : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> for j in range ( i , 26 ) : <NEWLINE> <INDENT> if s_list [ i - 1 ] < s_list [ j ] : <NEWLINE> <INDENT> c = min ( c , s_list [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( S [ : i - 1 ] + c ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i , alpha in enumerate ( alpha_list ) : <NEWLINE> <INDENT> if alpha in s_list : <NEWLINE> <INDENT> flag_list [ i ] = True <NEWLINE> <DEDENT> <DEDENT> for i , flag in enumerate ( flag_list ) : <NEWLINE> <INDENT> if not flag : <NEWLINE> <INDENT> print ( S + alpha_list [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <NL> def bfs ( table , i , j , h , w ) : <NEWLINE> <INDENT> dq = deque ( ) <NEWLINE> ans = 0 <NEWLINE> dq . append ( ( i , j , 0 ) ) <COMMENT> <NEWLINE> table [ i ] [ j ] = <STRING> <NEWLINE> while dq : <NEWLINE> <INDENT> x , y , dis = dq . popleft ( ) <NEWLINE> ans = max ( ans , dis ) <NEWLINE> if x > 0 and ( x - 1 , y ) and table [ x - 1 ] [ y ] != <STRING> : <NEWLINE> <INDENT> dq . append ( ( x - 1 , y , dis + 1 ) ) <NEWLINE> table [ x - 1 ] [ y ] = <STRING> <NEWLINE> <DEDENT> if x < h - 1 and ( x + 1 , y ) and table [ x + 1 ] [ y ] != <STRING> : <NEWLINE> <INDENT> dq . append ( ( x + 1 , y , dis + 1 ) ) <NEWLINE> table [ x + 1 ] [ y ] = <STRING> <NEWLINE> <DEDENT> if y > 0 and ( x , y - 1 ) and table [ x ] [ y - 1 ] != <STRING> : <NEWLINE> <INDENT> dq . append ( ( x , y - 1 , dis + 1 ) ) <NEWLINE> table [ x ] [ y - 1 ] = <STRING> <NEWLINE> <DEDENT> if y < w - 1 and ( x , y + 1 ) and table [ x ] [ y + 1 ] != <STRING> : <NEWLINE> <INDENT> dq . append ( ( x , y + 1 , dis + 1 ) ) <NEWLINE> table [ x ] [ y + 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> grid = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> _grid = deepcopy ( grid ) <NEWLINE> max_path = bfs ( _grid , i , j , h , w ) <NEWLINE> ans = max ( ans , max_path ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> a = S . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = S . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c = S . find ( str ( k ) , b + 1 ) <NEWLINE> if c == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> ans = ans * int ( i ) <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s . rfind ( <STRING> ) + 1 - s . find ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = p ^ a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> k = p ^ a [ i ] <NEWLINE> ans . append ( k ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> sr = set ( ) <NEWLINE> sg = set ( ) <NEWLINE> sb = set ( ) <NEWLINE> for ii in range ( n ) : <NEWLINE> <INDENT> if s [ ii ] == <STRING> : <NEWLINE> <INDENT> sr . add ( ii ) <NEWLINE> <DEDENT> if s [ ii ] == <STRING> : <NEWLINE> <INDENT> sg . add ( ii ) <NEWLINE> <DEDENT> if s [ ii ] == <STRING> : <NEWLINE> <INDENT> sb . add ( ii ) <NEWLINE> <DEDENT> <DEDENT> l = [ len ( sr ) , len ( sg ) , len ( sb ) ] <NEWLINE> l . sort ( ) <NEWLINE> <NL> if l [ 0 ] == len ( sr ) : <NEWLINE> <INDENT> s1 = sr <NEWLINE> if l [ 1 ] == len ( sg ) : <NEWLINE> <INDENT> s2 = sg <NEWLINE> s3 = sb <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 = sb <NEWLINE> s3 = sg <NEWLINE> <DEDENT> <DEDENT> elif l [ 0 ] == len ( sg ) : <NEWLINE> <INDENT> s1 = sg <NEWLINE> if l [ 1 ] == len ( sr ) : <NEWLINE> <INDENT> s2 = sr <NEWLINE> s3 = sb <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 = sb <NEWLINE> s3 = sr <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s1 = sb <NEWLINE> if l [ 1 ] == len ( sr ) : <NEWLINE> <INDENT> s2 = sr <NEWLINE> s3 = sg <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 = sg <NEWLINE> s3 = sr <NEWLINE> <NL> <DEDENT> <DEDENT> r = 0 <NEWLINE> for ii in s1 : <NEWLINE> <INDENT> for jj in s2 : <NEWLINE> <INDENT> r += len ( s3 ) <NEWLINE> dt = abs ( ii - jj ) <NEWLINE> if ii + dt in s3 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> if ii - dt in s3 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> if jj + dt in s3 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> if jj - dt in s3 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> if ( ii + jj ) % 2 == 0 : <NEWLINE> <INDENT> if ( ii + jj ) // 2 in s3 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def num_divisors_table ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return table <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> <NL> summ = 0 <NEWLINE> <NL> summ = sum ( num_divisors_table ( N - 1 ) ) <NEWLINE> print ( summ ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ [ ] for i in range ( N ) ] <NEWLINE> C = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c_as = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] , A [ i ] = c_as [ 0 ] , c_as [ 1 : ] <NEWLINE> <NL> <DEDENT> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> for s in range ( 0 , 1 << N ) : <NEWLINE> <INDENT> smart = [ 0 ] * M <NEWLINE> cost_sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( s >> i ) % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost_sum += C [ i ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> smart [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ok = True <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if smart [ j ] < X : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , cost_sum ) <NEWLINE> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> class DList : <NEWLINE> <INDENT> class Cell : <NEWLINE> <INDENT> def __init__ ( self , k ) : <NEWLINE> <INDENT> self . key = k <NEWLINE> self . prev = None <NEWLINE> self . next = None <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . head = DList . Cell ( None ) <NEWLINE> self . last = DList . Cell ( None ) <NEWLINE> self . head . next = self . last <NEWLINE> self . last . prev = self . head <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> c = DList . Cell ( x ) <NEWLINE> c . prev = self . head <NEWLINE> c . next = self . head . next <NEWLINE> c . next . prev = c <NEWLINE> self . head . next = c <NEWLINE> <NL> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> c = self . __find ( x ) <NEWLINE> if c != None : <NEWLINE> <INDENT> self . __delete ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __delete ( self , c ) : <NEWLINE> <INDENT> c . prev . next = c . next <NEWLINE> c . next . prev = c . prev <NEWLINE> <NL> <DEDENT> def __find ( self , x ) : <NEWLINE> <INDENT> c = self . head . next <NEWLINE> while c != None and c . key != x : <NEWLINE> <INDENT> c = c . next <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . __delete ( self . head . next ) <NEWLINE> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . __delete ( self . last . prev ) <NEWLINE> <NL> <DEDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> self . it = self . head . next <NEWLINE> return self <NEWLINE> <DEDENT> def __next__ ( self ) : <NEWLINE> <INDENT> if self . it == self . last : <NEWLINE> <INDENT> raise StopIteration <NEWLINE> <DEDENT> k = self . it . key <NEWLINE> self . it = self . it . next <NEWLINE> return k <NEWLINE> <NL> <DEDENT> <DEDENT> dlist = DList ( ) <NEWLINE> <NL> n = int ( stdin . readline ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) <NEWLINE> if cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> dlist . insert ( cmd [ 7 : - 1 ] ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> dlist . deleteFirst ( ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> dlist . deleteLast ( ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> dlist . delete ( cmd [ 7 : - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( dlist ) ) <NEWLINE> <NL>
<COMMENT> <NL> from heapq import heappop , heappush <NEWLINE> n = int ( input ( ) ) <NEWLINE> inf = 100 * 100000 <NEWLINE> <NL> M = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = L [ 0 ] <NEWLINE> k = L [ 1 ] <NEWLINE> v = L [ 2 : : 2 ] <NEWLINE> c = L [ 3 : : 2 ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> M [ u ] . append ( ( v [ j ] , c [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> result = [ 0 ] * n <NEWLINE> S = set ( ) <NEWLINE> V = set ( range ( n ) ) <NEWLINE> S . add ( 0 ) <NEWLINE> d = [ ] <NEWLINE> for m in M [ 0 ] : <NEWLINE> <INDENT> heappush ( d , ( m [ 1 ] , m [ 0 ] ) ) <NEWLINE> <DEDENT> T = V - S <NEWLINE> <NL> while len ( T ) != 0 : <NEWLINE> <INDENT> c , v = heappop ( d ) <NEWLINE> while v in S : <NEWLINE> <INDENT> c , v = heappop ( d ) <NEWLINE> <DEDENT> result [ v ] = c <NEWLINE> S . add ( v ) <NEWLINE> T . remove ( v ) <NEWLINE> for m in M [ v ] : <NEWLINE> <INDENT> if m [ 0 ] in T : <NEWLINE> <INDENT> heappush ( d , ( result [ v ] + m [ 1 ] , m [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i , v in enumerate ( result ) : <NEWLINE> <INDENT> print ( i , v ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> z = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( a + b ) <NEWLINE> y . append ( a - b ) <NEWLINE> z . append ( b - a ) <NEWLINE> <DEDENT> print ( max ( max ( x ) - min ( x ) , max ( y ) - min ( y ) , max ( z ) - min ( z ) ) ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> hsummation = [ [ int ( S [ 0 ] [ k ] ) ] for k in range ( W ) ] <NEWLINE> for k in range ( W ) : <NEWLINE> <INDENT> for j in range ( 1 , H ) : <NEWLINE> <INDENT> hsummation [ k ] . append ( hsummation [ k ] [ j - 1 ] + int ( S [ j ] [ k ] ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = float ( <STRING> ) <NEWLINE> anskouho = 0 <NEWLINE> h = 2 ** ( H - 1 ) <NEWLINE> for j in range ( 2 ** ( H - 1 ) ) : <NEWLINE> <INDENT> h -= 1 <NEWLINE> binh = <STRING> * ( H - len ( str ( bin ( h ) ) ) + 1 ) + str ( bin ( h ) ) [ 2 : ] <NEWLINE> hlist = [ ] <NEWLINE> for k in range ( H - 1 ) : <NEWLINE> <INDENT> if binh [ - k - 1 ] == <STRING> : <NEWLINE> <INDENT> hlist . append ( k ) <NEWLINE> <DEDENT> <DEDENT> hlist . append ( - 1 ) <NEWLINE> <COMMENT> <NL> anskouho = len ( hlist ) - 1 <NEWLINE> now = 0 <NEWLINE> while now < W : <NEWLINE> <INDENT> counter = [ 0 for _ in range ( len ( hlist ) ) ] <NEWLINE> while now < W : <NEWLINE> <INDENT> for l in range ( len ( hlist ) ) : <NEWLINE> <INDENT> if l == 0 : <NEWLINE> <INDENT> counter [ l ] += hsummation [ now ] [ int ( hlist [ l ] ) ] <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter [ l ] += - hsummation [ now ] [ hlist [ l - 1 ] ] + hsummation [ now ] [ hlist [ l ] ] <NEWLINE> <DEDENT> <DEDENT> if max ( counter ) > K : <NEWLINE> <INDENT> anskouho += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> <DEDENT> if anskouho > ans : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , anskouho ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] not in T : T [ a [ i ] ] = 1 <NEWLINE> else : T [ a [ i ] ] += 1 <NEWLINE> <DEDENT> Sum = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b not in T : T [ b ] = 0 <NEWLINE> Sum = Sum - ( T [ b ] * b ) + ( T [ b ] * c ) <NEWLINE> print ( Sum ) <NEWLINE> if c not in T : T [ c ] = T [ b ] <NEWLINE> else : T [ c ] += T [ b ] <NEWLINE> T [ b ] = 0 <NEWLINE> <DEDENT>
def is_prime ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return pow ( 2 , x - 1 , x ) == 1 <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = n <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> ans -= ans // 2 <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> n //= 2 <NEWLINE> <DEDENT> <DEDENT> d = 3 <NEWLINE> while d <= n ** 0.5 : <NEWLINE> <INDENT> if is_prime ( d ) and n % d == 0 : <NEWLINE> <INDENT> ans -= ans // d <NEWLINE> while n % d == 0 : <NEWLINE> <INDENT> n //= d <NEWLINE> <DEDENT> <DEDENT> d += 2 <NEWLINE> <DEDENT> if is_prime ( n ) : <NEWLINE> <INDENT> ans -= ans // n <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def RD ( ) : return sys . stdin . read ( ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = MI ( ) <NEWLINE> p = LI ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> p [ i ] = p [ i ] / 2 + 0.5 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = sum ( p [ : k ] ) <NEWLINE> now = sum ( p [ : k ] ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> now = now - p [ i ] + p [ i + k ] <NEWLINE> ans = max ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> x [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in x : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> a = X . count ( <STRING> ) <NEWLINE> ap , am = a + 1 , a - 1 <NEWLINE> Flag = True <NEWLINE> <NL> if am == 0 : <NEWLINE> <INDENT> Flag = False <NEWLINE> am += 1 <NEWLINE> <NL> <DEDENT> Ap = [ 1 ] <NEWLINE> Am = [ 1 ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> Ap . append ( Ap [ - 1 ] * 2 % ap ) <NEWLINE> Am . append ( Am [ - 1 ] * 2 % am ) <NEWLINE> <NL> <DEDENT> Aps = 0 <NEWLINE> Ams = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ - 1 - i ] == <STRING> : <NEWLINE> <INDENT> Aps += Ap [ i ] <NEWLINE> Aps %= ap <NEWLINE> Ams += Am [ i ] <NEWLINE> Ams %= am <NEWLINE> <NL> <DEDENT> <DEDENT> def popcount ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if Flag : <NEWLINE> <INDENT> p = Ams - Am [ - 1 - i ] <NEWLINE> p %= am <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = Aps + Ap [ - 1 - i ] <NEWLINE> p %= ap <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> while p > 0 : <NEWLINE> <INDENT> p %= popcount ( p ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( P ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 1 / N <NEWLINE> check = round ( P ** l ) <NEWLINE> while check > 1 : <NEWLINE> <INDENT> if P % ( check ** N ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> check -= 1 <NEWLINE> <DEDENT> print ( check ) <NEWLINE> <DEDENT>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> XYC = sys . stdin . buffer . read ( ) . split ( ) <NEWLINE> X , Y , C = np . array ( XYC [ : : 3 ] , dtype = np . int64 ) , np . array ( XYC [ 1 : : 3 ] , dtype = np . int64 ) , np . array ( XYC [ 2 : : 3 ] ) == <STRING> <NEWLINE> solve ( N , K , X , Y , C ) <NEWLINE> <NL> <DEDENT> def solve ( N , K , X , Y , C ) : <NEWLINE> <INDENT> M = np . zeros ( ( K * 2 + 1 , K * 4 ) , dtype = np . int64 ) <NEWLINE> for x , y , c in zip ( X , Y , C ) : <NEWLINE> <INDENT> if c : <NEWLINE> <INDENT> x += K <NEWLINE> <DEDENT> x %= 2 * K <NEWLINE> y %= 2 * K <NEWLINE> if x >= K and y >= K : <NEWLINE> <INDENT> x -= K <NEWLINE> y -= K <NEWLINE> <DEDENT> elif y >= K : <NEWLINE> <INDENT> y -= K <NEWLINE> x += K <NEWLINE> <DEDENT> M [ y , x ] += 1 <NEWLINE> M [ y , ( x + 2 * K ) % ( 4 * K ) ] += 1 <NEWLINE> M [ y + K , x + K ] += 1 <NEWLINE> M [ y + K , ( x + 3 * K ) % ( 4 * K ) ] += 1 <NEWLINE> if y == 0 : <NEWLINE> <INDENT> M [ 2 * K , x ] += 1 <NEWLINE> M [ 2 * K , ( x + 2 * K ) % ( 4 * K ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for y in range ( 2 * K ) : <NEWLINE> <INDENT> for x in range ( 4 * K ) : <NEWLINE> <INDENT> M [ y + 1 , x ] += M [ y , x ] <NEWLINE> <DEDENT> <DEDENT> for y in range ( 2 * K + 1 ) : <NEWLINE> <INDENT> for x in range ( 4 * K - 1 ) : <NEWLINE> <INDENT> M [ y , x + 1 ] += M [ y , x ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( [ M [ y + K , x + K ] + M [ y , x ] - M [ y + K , x ] - M [ y , x + K ] for y in range ( K + 1 ) for x in range ( 2 * K + 1 ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> main ( ) <NEWLINE>
n = [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> N1 , N2 = max ( n ) , sorted ( n ) [ - 2 ] <NEWLINE> for i in n : <NEWLINE> <INDENT> if i < N1 : print ( N1 ) <NEWLINE> elif i == N1 : print ( N2 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> inf = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for x in a : <NEWLINE> <INDENT> if arr [ x ] == 0 : <NEWLINE> <INDENT> for i in range ( x , 10 ** 6 + 1 , x ) : <NEWLINE> <INDENT> arr [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> arr [ x ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if arr [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def x ( p0 , p1 ) : <NEWLINE> <INDENT> d = abs ( p0 - p1 ) <NEWLINE> if d > 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> elif d == 2 : <NEWLINE> <INDENT> return [ ( p0 + p1 ) / 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = ( p0 + p1 ) / 2 <NEWLINE> v = m - p0 <NEWLINE> w = complex ( v . imag , - v . real ) <NEWLINE> l = abs ( w ) <NEWLINE> h = ( 1 - l ** 2 ) ** .5 * w / l <NEWLINE> return [ m + h , m - h ] <NEWLINE> <NL> <DEDENT> <DEDENT> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> n = int ( e ) <NEWLINE> P = [ complex ( * map ( float , input ( ) . split ( <STRING> ) ) ) for _ in [ 0 ] * n ] <NEWLINE> Q = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> Q += x ( P [ i ] , P [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( sum ( 1.01 >= abs ( q - p ) for p in P ) for q in Q ) if Q else 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> printV = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> printH = lambda x : print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> def IS ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LII ( rows_number ) : return [ II ( ) for _ in range ( rows_number ) ] <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def LLI1 ( rows_number ) : return [ LI1 ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> a = LI ( ) <NEWLINE> a = [ 0 ] + a <NEWLINE> dp_t = defaultdict ( lambda : - 10 ** 18 ) <NEWLINE> dp_f = defaultdict ( lambda : - 10 ** 18 ) <NEWLINE> dp_f [ ( 0 , 0 ) ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp_f [ ( i , ( i - 1 ) // 2 ) ] = max ( dp_f [ ( i - 1 , ( i - 1 ) // 2 ) ] , dp_t [ ( i - 1 , ( i - 1 ) // 2 ) ] ) <NEWLINE> dp_t [ ( i , ( i - 1 ) // 2 ) ] = dp_f [ ( i - 1 , ( i - 1 ) // 2 - 1 ) ] + a [ i ] <NEWLINE> dp_f [ ( i , ( i - 1 ) // 2 + 1 ) ] = max ( dp_f [ ( i - 1 , ( i - 1 ) // 2 + 1 ) ] , dp_t [ ( i - 1 , ( i - 1 ) // 2 + 1 ) ] ) <NEWLINE> dp_t [ ( i , ( i - 1 ) // 2 + 1 ) ] = dp_f [ ( i - 1 , ( i - 1 ) // 2 ) ] + a [ i ] <NEWLINE> <DEDENT> print ( max ( dp_t [ ( n , n // 2 ) ] , dp_f [ ( n , n // 2 ) ] ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def get_count ( S , H , W , i , j ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> start_i = start_j = - 1 <NEWLINE> end_i = end_j = 2 <NEWLINE> if W == 1 : <NEWLINE> <INDENT> start_i = 0 <NEWLINE> end_i = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> start_i = 0 <NEWLINE> <DEDENT> elif i == W - 1 : <NEWLINE> <INDENT> end_i = 1 <NEWLINE> <DEDENT> <DEDENT> if H == 1 : <NEWLINE> <INDENT> start_j = 0 <NEWLINE> end_j = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> start_j = 0 <NEWLINE> <DEDENT> elif j == H - 1 : <NEWLINE> <INDENT> end_j = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for y in range ( start_j , end_j , 1 ) : <NEWLINE> <INDENT> for x in range ( start_i , end_i , 1 ) : <NEWLINE> <INDENT> if S [ j + y ] [ i + x ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return num <NEWLINE> <NL> <NL> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> if S [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> num = get_count ( S , H , W , x , y ) <NEWLINE> S [ y ] [ x ] = str ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for y in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> . join ( S [ y ] ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dic = collections . defaultdict ( lambda : [ ] ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> dic [ a ] . append ( b ) <NEWLINE> dic [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ None ] * n <NEWLINE> bfs = [ ( 1 , dic [ 1 ] ) ] <NEWLINE> visited = set ( ) <NEWLINE> get = 0 <NEWLINE> while bfs and get < n : <NEWLINE> <INDENT> now , nexts = bfs . pop ( 0 ) <NEWLINE> <NL> for i in nexts : <NEWLINE> <INDENT> if i in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i - 1 ] = now <NEWLINE> get += 1 <NEWLINE> bfs . append ( ( i , dic [ i ] ) ) <NEWLINE> visited . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
A , B , C , K = input ( ) . split ( ) <NEWLINE> a = int ( A ) <NEWLINE> b = int ( B ) <NEWLINE> c = int ( C ) <NEWLINE> k = int ( K ) <NEWLINE> <NL> B_number = 0 <NEWLINE> C_number = 0 <NEWLINE> <NL> A_number = min ( a , k ) <NEWLINE> k1 = k - a <NEWLINE> if k1 > 0 : <NEWLINE> <INDENT> B_number = min ( b , k1 ) <NEWLINE> k2 = k1 - b <NEWLINE> if k2 > 0 : <NEWLINE> <INDENT> C_number = min ( c , k2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A_number - C_number ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import time <NEWLINE> sys . setrecursionlimit ( int ( 1e6 ) ) <NEWLINE> if False : <NEWLINE> <INDENT> dprint = print <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> def dprint ( * args ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dprint ( <STRING> , n , k ) <NEWLINE> <NL> lx = int ( 0 ) <COMMENT> <NEWLINE> rx = int ( 1e9 ) <COMMENT> <NEWLINE> <COMMENT> <NL> while ( ( rx - lx ) > 1 ) : <NEWLINE> <INDENT> x = ( rx + lx ) // 2 <NEWLINE> dprint ( <STRING> , lx , x , rx ) <NEWLINE> n = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> n += ( A [ i ] - 1 ) // x <NEWLINE> if n > k : break <NEWLINE> <DEDENT> dprint ( <STRING> , n ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> dprint ( <STRING> ) <NEWLINE> rx = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dprint ( <STRING> ) <NEWLINE> lx = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( rx ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> maxA = A [ - 1 ] <NEWLINE> work = [ 0 ] * ( A [ - 1 ] + 1 ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if work [ A [ i ] ] <= 1 : <NEWLINE> <INDENT> maxN = int ( maxA / A [ i ] ) <NEWLINE> for n in range ( 1 , maxN + 1 ) : <NEWLINE> <INDENT> buf = A [ i ] * n <NEWLINE> <COMMENT> <NL> work [ buf ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> sm = 0 <NEWLINE> for s in A : <NEWLINE> <INDENT> if work [ s ] == 1 : sm += 1 <NEWLINE> <DEDENT> print ( sm ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * 10 ** 4 <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> n = ( x + y + z ) ** 2 - ( x * y + y * z + z * x ) <NEWLINE> if n <= 10000 : <NEWLINE> <INDENT> a [ n - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> print ( a [ n ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s1 = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 . append ( s1 [ - 1 ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> s2 = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s2 . append ( s2 [ - 1 ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <NL> <INDENT> if k - s1 [ i ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while k - s1 [ i ] - s2 [ j ] < 0 and j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( i + j , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import numpy <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> l . append ( 0 ) <NEWLINE> l . reverse ( ) <NEWLINE> cum = numpy . cumsum ( l ) % mod <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res += ( ( l [ n - i ] % mod ) * cum [ n - i - 1 ] ) % mod <NEWLINE> <DEDENT> print ( res % mod ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x - a ) < abs ( x - b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import queue <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ A - 1 ] . append ( B - 1 ) <NEWLINE> graph [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> up = [ - 1 for _ in range ( N ) ] <NEWLINE> up [ 0 ] = 0 <NEWLINE> <NL> q = queue . Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> for x in graph [ now ] : <NEWLINE> <INDENT> if up [ x ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> up [ x ] = now <NEWLINE> q . put ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( up [ i ] + 1 ) <NEWLINE> <DEDENT>
table = [ 0 ] * 4 * 3 * 10 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> table [ 30 * ( b - 1 ) + 10 * ( f - 1 ) + ( r - 1 ) ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 120 ) : <NEWLINE> <INDENT> if i != 0 and i % 30 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> % table [ i ] , end = <STRING> ) <NEWLINE> if i % 10 == 9 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> a = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format ( data [ 0 ] , data [ 1 ] , data [ 2 ] ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r * r * math . pi ) , <STRING> % ( 2 * math . pi * r ) ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return f ( x % bin ( x ) . count ( <STRING> ) ) + 1 <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> d = x . count ( <STRING> ) <NEWLINE> y = int ( x , base = 2 ) <NEWLINE> y0 = y % ( d + 1 ) <NEWLINE> y1 = y % ( d - 1 ) if d > 1 else 0 <NEWLINE> buf = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> m = d + 1 <NEWLINE> z = ( y0 + pow ( 2 , n - i - 1 , m ) ) % m <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> m = d - 1 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> buf . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> z = ( y1 - pow ( 2 , n - i - 1 , m ) ) % m <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> buf . append ( f ( z ) + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , buf ) ) ) <NEWLINE>
import math <NEWLINE> <NL> def f ( a , b , x ) : <NEWLINE> <INDENT> return math . floor ( a * x / b ) - 5 * math . floor ( x / b ) <NEWLINE> <NL> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> max = 0 <NEWLINE> <NL> if b <= n : <NEWLINE> <INDENT> print ( f ( a , b , b - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( a , b , n ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( M ) ] <NEWLINE> <NL> G = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = g [ i ] <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> marks = [ - 1 for i in range ( N ) ] <NEWLINE> node = deque ( [ [ 0 , 0 ] ] ) <NEWLINE> while len ( node ) > 0 : <NEWLINE> <INDENT> v = node . popleft ( ) <NEWLINE> if marks [ v [ 0 ] ] == - 1 : <NEWLINE> <INDENT> marks [ v [ 0 ] ] = v [ 1 ] <NEWLINE> for i in G [ v [ 0 ] ] : <NEWLINE> <INDENT> if marks [ i ] == - 1 : <NEWLINE> <INDENT> node . append ( [ i , v [ 0 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if - 1 not in marks : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( marks [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def cmb ( n , r ) : <NEWLINE> <INDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : return 1 <NEWLINE> over = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return over // under <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( al ) <NEWLINE> <NL> k = 0 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += cmb ( v , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in al : <NEWLINE> <INDENT> if c [ a ] == 1 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif c [ a ] == 2 : <NEWLINE> <INDENT> print ( k - cmb ( c [ a ] , 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k - cmb ( c [ a ] , 2 ) + cmb ( c [ a ] - 1 , 2 ) ) <NEWLINE> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> if N < B : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( A * ( B - 1 ) / B - A * math . floor ( ( B - 1 ) / B ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ 0 ] * W <NEWLINE> R = [ 0 ] * H <NEWLINE> S = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = h - 1 , w - 1 <COMMENT> <NEWLINE> C [ w ] += 1 <NEWLINE> R [ h ] += 1 <NEWLINE> S . add ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> col_max = max ( C ) <NEWLINE> col_idx = [ i for i in range ( W ) if C [ i ] == col_max ] <NEWLINE> row_max = max ( R ) <NEWLINE> row_idx = [ i for i in range ( H ) if R [ i ] == row_max ] <NEWLINE> <NL> ans = col_max + row_max <NEWLINE> for r in row_idx : <NEWLINE> <INDENT> for c in col_idx : <NEWLINE> <INDENT> if not ( r , c ) in S : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
<COMMENT> <NL> <NL> s = int ( input ( ) ) <NEWLINE> <NL> <NL> <NL> if s <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ 0 ] * ( s + 1 ) <NEWLINE> a [ 0 ] = 1 <NEWLINE> for i in range ( 3 , s + 1 ) : <NEWLINE> <INDENT> a [ i ] = int ( ( a [ i - 1 ] + a [ i - 3 ] ) % ( 1e9 + 7 ) ) <NEWLINE> <NL> <DEDENT> print ( a [ s ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x_kouho = [ ] <NEWLINE> count = 1 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while count <= n // b : <NEWLINE> <INDENT> x_kouho . append ( b * count - 1 ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> if not x_kouho : <NEWLINE> <INDENT> x_kouho . append ( n ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( 0 , len ( x_kouho ) ) : <NEWLINE> <INDENT> keep = x_kouho [ i ] <NEWLINE> kept = ( a * keep ) // b - a * ( keep // b ) <NEWLINE> if kept > res : <NEWLINE> <INDENT> res = kept <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> s += <STRING> + str ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> <COMMENT> <NL> while x > 0 and x % 10 != 3 : <NEWLINE> <COMMENT> <NL> <INDENT> x //= 10 <NEWLINE> <DEDENT> if x % 10 == 3 : <NEWLINE> <INDENT> s += <STRING> + str ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> THE_NUM = 10 ** 6 + 1 <NEWLINE> <NL> dp = [ True ] * THE_NUM <NEWLINE> <NL> prev_num = - 1 <NEWLINE> for i in A : <NEWLINE> <COMMENT> <NL> <INDENT> if prev_num != i : <NEWLINE> <INDENT> for j in range ( i * 2 , THE_NUM , i ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <DEDENT> prev_num = i <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in A : <NEWLINE> <COMMENT> <NL> <INDENT> if dp [ i ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> import math <NEWLINE> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lcm = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> lcm = lcm * A [ i ] // math . gcd ( lcm , A [ i ] ) <NEWLINE> <DEDENT> first = lcm // 2 <NEWLINE> <NL> ans_exists = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if first % A [ i ] == 0 : <NEWLINE> <INDENT> ans_exists = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ans_exists : <NEWLINE> <INDENT> ans = int ( ( M - first ) // lcm + 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> <COMMENT> <NL> L = len ( T ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( L ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> or T [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> edeg = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> edeg [ a ] . append ( b ) <NEWLINE> edeg [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for node in range ( n ) : <NEWLINE> <INDENT> good = True <NEWLINE> for neigber in edeg [ node ] : <NEWLINE> <COMMENT> <NL> <INDENT> if h [ node ] <= h [ neigber ] : <NEWLINE> <INDENT> good = False <NEWLINE> <DEDENT> <DEDENT> if good : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
border = 1000000000000000000 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for n in nums : <NEWLINE> <INDENT> result = result * n <NEWLINE> if result > border : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> from itertools import accumulate <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum = ( accumulate ( reversed ( a ) ) ) <NEWLINE> a_sum = list ( reversed ( list ( a_sum ) ) ) <NEWLINE> sum = 0 <NEWLINE> mod = 1000000007 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum += a [ i ] * a_sum [ i + 1 ] <NEWLINE> <DEDENT> print ( sum % mod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> re = n % 26 <NEWLINE> if re != 0 : <NEWLINE> <INDENT> ans = chr ( ord ( <STRING> ) + re - 1 ) + ans <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> + ans <NEWLINE> n = ( n // 26 ) - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> left = 1 <NEWLINE> right = 10 ** 9 <NEWLINE> <NL> while left < right : <NEWLINE> <INDENT> center = ( left + right ) // 2 <NEWLINE> <NL> total = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % center == 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> total += i // center <NEWLINE> <NL> <DEDENT> if total > k : <NEWLINE> <INDENT> left = center + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = center <NEWLINE> <NL> <DEDENT> <DEDENT> print ( left ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 13 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> r , t = LF ( ) <NEWLINE> a = [ LI ( ) for _ in range ( n ) ] <NEWLINE> d = { } <NEWLINE> M = 32 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ax , ay = a [ i ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> bx , by = a [ j ] <NEWLINE> d [ i * M + j ] = math . atan2 ( bx - ax , by - ay ) / math . pi * 180 <NEWLINE> <DEDENT> <DEDENT> ky = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ax , ay = a [ i ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> bx , by = a [ j ] <NEWLINE> ky [ i * M + j ] = pow ( pow ( ax - bx , 2 ) + pow ( ay - by , 2 ) , 0.5 ) <NEWLINE> <DEDENT> <DEDENT> e = collections . defaultdict ( list ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ij = i * M + j <NEWLINE> dij = d [ ij ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if k == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> jk = j * M + k <NEWLINE> djk = d [ jk ] <NEWLINE> if abs ( dij - djk ) <= t or 360 - abs ( dij - djk ) <= t : <NEWLINE> <INDENT> e [ ( i , j ) ] . append ( ( ( j , k ) , ky [ jk ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def search ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> dp = [ [ None ] * n for _ in range ( n ) ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> k = ky [ j ] <NEWLINE> if k > r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s = ( j , 1 ) <NEWLINE> res = 1 <NEWLINE> dp [ 0 ] [ j ] = k <NEWLINE> <DEDENT> if res == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> wf = False <NEWLINE> nd = [ [ None ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] is None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dij = dp [ i ] [ j ] <NEWLINE> for nn , k in e [ ( i , j ) ] : <NEWLINE> <INDENT> nk = dij + k <NEWLINE> if nk > r or ( not nd [ j ] [ nn [ 1 ] ] is None and nd [ j ] [ nn [ 1 ] ] < nk ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nd [ j ] [ nn [ 1 ] ] = nk <NEWLINE> wf = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if wf : <NEWLINE> <INDENT> res += 1 <NEWLINE> dp = nd <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> return search ( ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> rr . append ( f ( ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for v in range ( 2 ) : <NEWLINE> <INDENT> if a [ 0 ] >= a [ 1 ] : <NEWLINE> <INDENT> count += a [ 0 ] <NEWLINE> a [ 0 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += a [ 1 ] <NEWLINE> a [ 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> D , G , * pc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> pc = list ( zip ( * [ iter ( pc ) ] * 2 ) ) <NEWLINE> p , c = np . array ( [ ] ) , np . array ( [ ] ) <NEWLINE> for ( x , y ) in pc : <NEWLINE> <INDENT> p = np . append ( p , x ) <NEWLINE> c = np . append ( c , y ) <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> import math <NEWLINE> <NL> base_points = np . array ( [ i * 100 for i in range ( 1 , D + 1 ) ] ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 2 ** D ) : <NEWLINE> <INDENT> bit_flag = np . array ( list ( map ( int , format ( i , <STRING> % D ) ) ) ) <NEWLINE> points = sum ( bit_flag * ( c + p * base_points ) ) <NEWLINE> solved_num = sum ( bit_flag * p ) <NEWLINE> <NL> if points >= G : <NEWLINE> <INDENT> ans . append ( solved_num ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> remained = G - points <NEWLINE> remained_problems = sorted ( ( bit_flag == False ) * np . array ( range ( 1 , D + 1 ) ) , reverse = True ) <NEWLINE> i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if remained <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> highest_p = remained_problems [ i ] <NEWLINE> <NL> if math . ceil ( remained / ( highest_p * 100 ) ) <= p [ highest_p - 1 ] : <NEWLINE> <INDENT> solved_num += math . ceil ( remained / ( highest_p * 100 ) ) <NEWLINE> remained -= ( math . ceil ( remained / ( highest_p * 100 ) ) * highest_p * 100 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solved_num += p [ highest_p - 1 ] <NEWLINE> remained -= ( highest_p * 100 * p [ highest_p - 1 ] + c [ highest_p - 1 ] ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( solved_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( min ( ans ) ) ) <NEWLINE>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , length ) : <NEWLINE> <INDENT> self . r = [ - 1 ] * length <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> rx = self . r [ x ] <NEWLINE> if ( rx ) < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> return self . root ( rx ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> r = self . r <NEWLINE> <NL> if r [ x ] > r [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> r [ x ] += r [ y ] <NEWLINE> r [ y ] = x <NEWLINE> <NL> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . r [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> def debug ( self ) : <NEWLINE> <INDENT> print ( self . r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> relations = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> relations . unite ( A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> max_ = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> max_ = max ( relations . size ( i ) , max_ ) <NEWLINE> <NL> <DEDENT> print ( max_ ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> data = { <NEWLINE> <INDENT> <STRING> : A , <NEWLINE> <STRING> : B , <NEWLINE> <STRING> : C <NEWLINE> <DEDENT> } <NEWLINE> select = [ ] <NEWLINE> S = list ( input ( ) for _ in range ( N ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> if data [ s [ 0 ] ] == data [ s [ 1 ] ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif data [ s [ 0 ] ] > data [ s [ 1 ] ] : <NEWLINE> <INDENT> data [ s [ 0 ] ] -= 1 <NEWLINE> data [ s [ 1 ] ] += 1 <NEWLINE> select . append ( s [ 1 ] ) <NEWLINE> <DEDENT> elif data [ s [ 0 ] ] < data [ s [ 1 ] ] : <NEWLINE> <INDENT> data [ s [ 0 ] ] += 1 <NEWLINE> data [ s [ 1 ] ] -= 1 <NEWLINE> select . append ( s [ 0 ] ) <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> select . append ( s [ 0 ] ) <NEWLINE> <DEDENT> elif s [ 0 ] in S [ i + 1 ] : <NEWLINE> <INDENT> data [ s [ 0 ] ] += 1 <NEWLINE> data [ s [ 1 ] ] -= 1 <NEWLINE> select . append ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data [ s [ 0 ] ] -= 1 <NEWLINE> data [ s [ 1 ] ] += 1 <NEWLINE> select . append ( s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in select : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> line = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = [ 0 for s in range ( n ) ] <NEWLINE> <NL> for i in line : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> boss = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> boss [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in boss : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> if k > a : <NEWLINE> <INDENT> k = k - a <NEWLINE> total += a <NEWLINE> <NL> <DEDENT> elif k == a : <NEWLINE> <INDENT> k = 0 <NEWLINE> total = a <NEWLINE> <NL> <DEDENT> elif k < a : <NEWLINE> <INDENT> total = k <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> if k > b : <NEWLINE> <INDENT> k = k - b <NEWLINE> <NL> <DEDENT> elif k == b : <NEWLINE> <INDENT> k = 0 <NEWLINE> <NL> <DEDENT> elif k < b : <NEWLINE> <INDENT> k = 0 <NEWLINE> <NL> <DEDENT> if k > c : <NEWLINE> <INDENT> total -= c <NEWLINE> k -= c <NEWLINE> <NL> <DEDENT> elif k == c : <NEWLINE> <INDENT> total -= k <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> elif k < c : <NEWLINE> <INDENT> total -= k <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s = [ ord ( c ) % 3 for c in input ( ) ] <NEWLINE> ans = 1 <NEWLINE> ans = s . count ( 0 ) * s . count ( 1 ) * s . count ( 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] == s [ j ] or s [ i ] == s [ k ] or s [ j ] == s [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> X = readline ( ) . rstrip ( ) <NEWLINE> <NL> X0 = int ( X , 2 ) <NEWLINE> count1 = X . count ( <STRING> ) <NEWLINE> <NL> X0mod0to1 = X0 % ( count1 + 1 ) <COMMENT> <NEWLINE> if count1 > 1 : <NEWLINE> <INDENT> X0mod1to0 = X0 % ( count1 - 1 ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X0mod1to0 = 0 <NEWLINE> <NL> <DEDENT> from collections import defaultdict <NEWLINE> dp = defaultdict ( int ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> def f ( x ) : <COMMENT> <NEWLINE> <INDENT> if x in dp : <NEWLINE> <INDENT> return dp [ x ] <NEWLINE> <DEDENT> pc = bin ( x ) . count ( <STRING> ) <NEWLINE> val = f ( x % pc ) + 1 <NEWLINE> dp [ x ] = val <NEWLINE> return val <NEWLINE> <NL> <DEDENT> val0to1 = 1 <NEWLINE> val1to0 = 1 <NEWLINE> ans = [ - 1 ] * N <NEWLINE> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> if X [ i ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> pat = ( X0mod0to1 + val0to1 % ( count1 + 1 ) ) % ( count1 + 1 ) <NEWLINE> ans [ i ] = f ( pat ) + 1 <NEWLINE> <DEDENT> elif X [ i ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> if count1 > 1 : <NEWLINE> <INDENT> pat = ( X0mod1to0 - val1to0 % ( count1 - 1 ) ) % ( count1 - 1 ) <NEWLINE> ans [ i ] = f ( pat ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> val0to1 = val0to1 * 2 % ( count1 + 1 ) <NEWLINE> if count1 != 1 : <NEWLINE> <INDENT> val1to0 = val1to0 * 2 % ( count1 - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> res_graph = [ [ 1 , i ] for i in range ( 2 , n + 1 ) ] <NEWLINE> res = ( n - 1 ) * ( n - 2 ) // 2 <NEWLINE> <NL> if ( k > ( n - 2 ) * ( n - 1 ) // 2 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> tmp_edge = 2 <NEWLINE> while res != k : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> for i in range ( n - tmp_edge ) : <NEWLINE> <INDENT> res_graph . append ( [ tmp_edge , tmp + tmp_edge ] ) <NEWLINE> res -= 1 <NEWLINE> tmp += 1 <NEWLINE> if res == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> tmp_edge += 1 <NEWLINE> <NL> <DEDENT> print ( len ( res_graph ) ) <NEWLINE> for i , j in res_graph : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <DEDENT>
import math <NEWLINE> ini = lambda : int ( input ( ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gcd = lambda x , y : gcd ( y , x % y ) if x % y else y <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <DEDENT> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <NL> n , m = inm ( ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = inm ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import collections <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = 2 <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numval = list ( ) <NEWLINE> for data in range ( n ) : <NEWLINE> <INDENT> numval . append ( 1000000000 ) <NEWLINE> <DEDENT> numval [ 0 ] = 0 <NEWLINE> i = 0 <NEWLINE> if ( n < k ) : <NEWLINE> <INDENT> k = n - 1 <NEWLINE> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for data in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if ( i + data ) >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> numval [ i + data ] = min ( numval [ i + data ] , numval [ i ] + abs ( num [ i ] - num [ i + data ] ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( numval [ n - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nodes = [ ] <NEWLINE> currentLeaf = 1 <NEWLINE> fail = False <NEWLINE> <COMMENT> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> nodes . append ( currentLeaf ) <NEWLINE> currentLeaf = ( currentLeaf - nums [ i ] ) * 2 <NEWLINE> if ( currentLeaf < 0 ) : <NEWLINE> <INDENT> fail = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( fail ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> currentLeaf = 0 <NEWLINE> totalNode = 0 <NEWLINE> for i in reversed ( range ( N + 1 ) ) : <NEWLINE> <INDENT> currentLeaf += nums [ i ] <NEWLINE> currentLeaf = min ( currentLeaf , nodes [ i ] ) <NEWLINE> totalNode += currentLeaf <NEWLINE> <NL> <DEDENT> if ( fail ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( totalNode ) <NEWLINE> <DEDENT> <DEDENT>
from math import pi <NEWLINE> <NL> a = float ( input ( ) ) <NEWLINE> s = round ( pi * ( a ** 2 ) , 11 ) <NEWLINE> l = round ( 2 * pi * a , 11 ) <NEWLINE> print ( s , l ) <NEWLINE>
a , b , m = map ( int , input ( ) . split ( ) ) <NEWLINE> reizo = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> renji = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cost = reizo [ p [ i ] [ 0 ] - 1 ] + renji [ p [ i ] [ 1 ] - 1 ] - p [ i ] [ 2 ] <NEWLINE> ans . append ( cost ) <NEWLINE> <DEDENT> ans . append ( min ( reizo ) + min ( renji ) ) <NEWLINE> print ( min ( ans ) ) <NEWLINE>
from math import gcd <NEWLINE> counter = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if gcd ( a , b ) == 1 : <NEWLINE> <INDENT> counter += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d = gcd ( a , b ) <NEWLINE> counter += gcd ( c , d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , K = Scanner . map_int ( ) <NEWLINE> A = Scanner . map_int ( ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> f = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if N % f == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> while N % f == 0 : <NEWLINE> <INDENT> N /= f <NEWLINE> c += 1 <NEWLINE> <DEDENT> n = 1 <NEWLINE> while n * ( n + 1 ) // 2 <= c : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> ans += n - 1 <NEWLINE> <DEDENT> if f * f > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> f += 1 <NEWLINE> <DEDENT> if N > 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> n = X // D <NEWLINE> m = K - n <NEWLINE> <NL> A1 = abs ( X - n * D ) <NEWLINE> A2 = abs ( X - ( n + 1 ) * D ) <NEWLINE> <NL> Ans = A2 <NEWLINE> <NL> if m > 1 : <NEWLINE> <INDENT> if A1 <= A2 : <NEWLINE> <INDENT> if m % 2 == 0 : <NEWLINE> <INDENT> Ans = A1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if m % 2 == 0 : <NEWLINE> <INDENT> Ans = A1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Ans = abs ( X - K * D ) <NEWLINE> <NL> <DEDENT> print ( Ans ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> <NL> n = list ( map ( int , n ) ) <NEWLINE> if ( n [ 0 ] > n [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n [ 0 ] == n [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def search ( x , y ) : <NEWLINE> <INDENT> x_length = len ( x ) <NEWLINE> y_length = len ( y ) <NEWLINE> memo = [ [ 0 ] * ( y_length + 1 ) for i in range ( x_length + 1 ) ] <NEWLINE> for i , ch_x in enumerate ( x , 1 ) : <NEWLINE> <INDENT> row = memo [ i ] <NEWLINE> pre_row = memo [ i - 1 ] <NEWLINE> for j , ch_y in enumerate ( y , 1 ) : <NEWLINE> <INDENT> if ch_x == ch_y : <NEWLINE> <INDENT> row [ j ] = pre_row [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif pre_row [ j ] < row [ j - 1 ] : <NEWLINE> <INDENT> row [ j ] = row [ j - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row [ j ] = pre_row [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return memo [ - 1 ] [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> strs = [ list ( val ) for val in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> result = [ search ( strs [ i * 2 ] , strs [ i * 2 + 1 ] ) for i in range ( n ) ] <NEWLINE> print ( * result , sep = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = [ ] <NEWLINE> t = 1 <NEWLINE> count = 1 <NEWLINE> while n > t * 26 : <NEWLINE> <INDENT> t *= 26 <NEWLINE> n -= t <NEWLINE> count += 1 <NEWLINE> <DEDENT> n -= 1 <NEWLINE> for i in range ( count - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> m = 26 ** i <NEWLINE> a = n // m <NEWLINE> n %= m <NEWLINE> num . append ( a ) <NEWLINE> <DEDENT> a_list = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> s = num [ i ] <NEWLINE> ans . append ( a_list [ s ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a . reverse ( ) <NEWLINE> <NL> for ( i , item ) in enumerate ( a ) : <NEWLINE> <INDENT> print ( str ( item ) , end = <STRING> if i != len ( a ) - 1 else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> H , W = map ( int , line . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) * ( H - 2 ) , end = <STRING> ) <NEWLINE> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from bisect import bisect_left <NEWLINE> from heapq import heappush <NEWLINE> <NL> def cal_divisors ( N ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != N // i : <NEWLINE> <INDENT> divisors . append ( N // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = cal_divisors ( M ) <NEWLINE> <COMMENT> <NL> i = bisect_left ( ans , N ) <NEWLINE> print ( M // ans [ i ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> sum_ = 0 <NEWLINE> <NL> for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <NL> <INDENT> sum_ += i ** 2 <NEWLINE> <NL> k1 = N // i <NEWLINE> <COMMENT> <NL> <NL> k1_sum = k1 * ( k1 + 1 ) // 2 <NEWLINE> k2_sum = i * ( i + 1 ) // 2 <NEWLINE> sum_ += 2 * i * ( k1_sum - k2_sum ) <NEWLINE> <NL> <DEDENT> print ( sum_ ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = X <NEWLINE> ALL_cal = [ False ] * M <NEWLINE> ALL = [ ] <NEWLINE> rou = False <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> X = pow ( X , 2 , M ) <NEWLINE> if ALL_cal [ X ] : <NEWLINE> <INDENT> num = ALL_cal [ X ] <NEWLINE> now = i <NEWLINE> rou = True <NEWLINE> break <NEWLINE> <DEDENT> ALL . append ( X ) <NEWLINE> ALL_cal [ X ] = i <NEWLINE> ans += X <NEWLINE> <DEDENT> if rou : <NEWLINE> <INDENT> roupe = now - num <NEWLINE> nokori = N - now - 1 <NEWLINE> print ( sum ( ALL [ num : ] ) * ( nokori // roupe ) + ans + sum ( ALL [ num : num + nokori % roupe ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter , defaultdict <NEWLINE> a = defaultdict ( int ) <NEWLINE> a [ 0 ] += 1 <NEWLINE> s = input ( ) [ : : - 1 ] <NEWLINE> cur = 0 <NEWLINE> for i , x in enumerate ( s ) : <NEWLINE> <INDENT> cur += ( int ( x ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> cur %= 2019 <NEWLINE> a [ cur ] += 1 <NEWLINE> <NL> <DEDENT> def comb ( a ) : <NEWLINE> <INDENT> return a * ( a - 1 ) // 2 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in a . values ( ) : <NEWLINE> <INDENT> if x >= 2 : <NEWLINE> <INDENT> ans += comb ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> suc = <STRING> <NEWLINE> maxN = H [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if maxN - 1 > H [ i ] : <NEWLINE> <INDENT> suc = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif maxN < H [ i ] : <NEWLINE> <INDENT> maxN = H [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( suc ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> s_dic = { } <NEWLINE> s_set = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <NL> s = <STRING> . join ( sorted ( s ) ) <NEWLINE> <NL> if s in s_set : <NEWLINE> <INDENT> s_dic [ s ] += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> s_set . add ( s ) <NEWLINE> s_dic [ s ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> <NL> for val in s_dic . values ( ) : <NEWLINE> <NL> <INDENT> if val > 1 : <NEWLINE> <INDENT> result += int ( ( val * ( val - 1 ) ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> height = h [ 0 ] <NEWLINE> <NL> q = 0 <NEWLINE> <NL> for i in h : <NEWLINE> <INDENT> if i < height : <NEWLINE> <INDENT> q = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif i > height : <NEWLINE> <INDENT> height = i - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> height = i <NEWLINE> <NL> <DEDENT> <DEDENT> if q == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = 1 <NEWLINE> res = 7 % k <NEWLINE> while res != 0 : <NEWLINE> <INDENT> res = ( res * 10 + 7 ) % k <NEWLINE> ret += 1 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 2147483647 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> a_max = a [ - 1 ] <NEWLINE> b = 0 <NEWLINE> db = [ 0 ] * a_max <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + 1 ] and a [ i ] != a [ i - 1 ] : <NEWLINE> <INDENT> db [ a [ i ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> if n == 1 or a [ 0 ] != a [ 1 ] : <NEWLINE> <INDENT> db [ a [ 0 ] - 1 ] = 1 <NEWLINE> <DEDENT> if n > 1 and a [ - 1 ] != a [ - 2 ] : <NEWLINE> <INDENT> db [ - 1 ] = 1 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> t = 2 <NEWLINE> while ( i * t <= a_max ) : <NEWLINE> <INDENT> db [ i * t - 1 ] = 0 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( db ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ [ None for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> maze [ i ] = list ( input ( ) ) <NEWLINE> <NL> <DEDENT> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for j in range ( H ) : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> if maze [ j ] [ k ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sy = j <NEWLINE> sx = k <NEWLINE> <NL> seen = [ [ - 1 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> seen [ sy ] [ sx ] = 0 <NEWLINE> <NL> que = collections . deque ( ) <COMMENT> <NEWLINE> que . append ( [ sy , sx ] ) <NEWLINE> <NL> while ( len ( que ) != 0 ) : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = p [ 0 ] + dy [ i ] <NEWLINE> nx = p [ 1 ] + dx [ i ] <NEWLINE> if ( ny >= 0 and nx >= 0 and ny < H and nx < W and seen [ ny ] [ nx ] == - 1 and maze [ ny ] [ nx ] != <STRING> ) : <NEWLINE> <INDENT> seen [ ny ] [ nx ] = seen [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> que . append ( [ ny , nx ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = max ( cnt , max ( [ x for row in seen for x in row ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> S_set = list ( sorted ( set ( S ) ) ) <NEWLINE> <NL> counter = { } <NEWLINE> for k in S_set : <NEWLINE> <INDENT> counter [ k ] = 0 <NEWLINE> <DEDENT> for i in S : <NEWLINE> <INDENT> counter [ i ] += 1 <NEWLINE> <NL> <DEDENT> maxim = max ( counter . values ( ) ) <NEWLINE> ans = [ i for i in S if counter [ i ] == maxim ] <NEWLINE> ans = list ( sorted ( set ( ans ) ) ) <NEWLINE> <NL> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
<NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) . rstrip ( <STRING> ) <NEWLINE> count = [ 0 ] * ( N + 2 ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count [ i + 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> count [ i ] += count [ i - 1 ] <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( count [ r - 1 ] - count [ l - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT>
a , b , c , d = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( ( ( a - c ) ** 2 + ( b - d ) ** 2 ) ** 0.5 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > ( 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i - 1 ] != S [ j - 1 ] and S [ j - 1 ] != S [ k - 1 ] and S [ k - 1 ] != S [ i - 1 ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for e in a : <NEWLINE> <INDENT> x *= e <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> r = <STRING> <NEWLINE> <NL> def to_moji ( x : int ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> x = 26 <NEWLINE> <DEDENT> return chr ( 96 + x ) <NEWLINE> <NL> <DEDENT> def devide ( x , moji ) : <NEWLINE> <INDENT> a = x // 26 <NEWLINE> b = x % 26 <NEWLINE> <NL> if b == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <NL> <DEDENT> if a < 1 : <NEWLINE> <INDENT> moji = to_moji ( b ) + moji <NEWLINE> return moji <NEWLINE> <DEDENT> elif 1 <= a and a <= 26 : <NEWLINE> <INDENT> moji = to_moji ( b ) + moji <NEWLINE> moji = to_moji ( a ) + moji <NEWLINE> return moji <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> moji = to_moji ( b ) + moji <NEWLINE> return devide ( a , moji ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( devide ( n , r ) ) <NEWLINE>
import sys <NEWLINE> <NL> convert = { <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <INDENT> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> <STRING> : { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } , <NEWLINE> } <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> line = line [ : - 1 ] <NEWLINE> <NL> if len ( line ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> message = <STRING> <NEWLINE> <NL> line = iter ( line ) <NEWLINE> <NL> for first , second in zip ( * [ line , line ] ) : <NEWLINE> <NL> <INDENT> if <STRING> <= first <= <STRING> and <STRING> <= second <= <STRING> : <NEWLINE> <INDENT> message += convert . get ( first ) . get ( second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( message ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tele = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> loc = 1 <NEWLINE> act = [ - 1 ] * n <NEWLINE> act [ 0 ] = 0 <NEWLINE> count = 1 <NEWLINE> log = [ ] <NEWLINE> log . append ( loc ) <NEWLINE> flg = True <NEWLINE> while True : <NEWLINE> <INDENT> newloc = tele [ loc - 1 ] <NEWLINE> if count == k : <NEWLINE> <INDENT> print ( newloc ) <NEWLINE> flg = False <NEWLINE> <DEDENT> log . append ( newloc ) <NEWLINE> <COMMENT> <NL> if act [ newloc - 1 ] == - 1 : <NEWLINE> <INDENT> act [ newloc - 1 ] = count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = count - act [ newloc - 1 ] <NEWLINE> loopstart = act [ newloc - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> loc = newloc <NEWLINE> <NL> <NL> <NL> <DEDENT> if flg : <NEWLINE> <INDENT> num = ( k - loopstart ) % loop <NEWLINE> ans = log [ loopstart + num ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> datasqr = [ i ** 2 for i in data ] <NEWLINE> print ( <STRING> % ( sum ( datasqr ) / num - ( sum ( data ) / num ) ** 2 ) ** 0.5 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> funcionarios = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> frequencia = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in funcionarios : <NEWLINE> <INDENT> frequencia [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in frequencia : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> def C ( T ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if h [ i ] > B * T : <NEWLINE> <INDENT> t += math . ceil ( ( h [ i ] - B * T ) / ( A - B ) ) <NEWLINE> <DEDENT> <DEDENT> if t <= T : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> False <NEWLINE> <DEDENT> <DEDENT> l , r = 0 , 10 ** 18 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if C ( mid ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * 10001 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> if i ** 2 + j ** 2 < 10001 : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> tmp = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + i * k <NEWLINE> if tmp < 10001 : <NEWLINE> <INDENT> ans [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> P = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P [ i ] = int ( P [ i ] * ( 1 + P [ i ] ) / 2 ) / P [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += P [ i ] <NEWLINE> if i < K - 1 : continue <NEWLINE> ans = max ( tmp , ans ) <NEWLINE> tmp -= P [ i - K + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = input ( ) <NEWLINE> nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> s = 10 ** 18 <NEWLINE> <NL> for i in nums : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ( ans > s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( ans <= s ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 7 : <NEWLINE> <INDENT> L = 9 * N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * N // 7 <NEWLINE> <DEDENT> num = 1 <NEWLINE> if L % 2 and L % 5 : <NEWLINE> <INDENT> i = 1 <NEWLINE> while i <= L : <NEWLINE> <INDENT> num = ( num * 10 ) % L <NEWLINE> if num == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if b > a : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> if b < 0 : <NEWLINE> <INDENT> ab = - a - - b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ab = - a + b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ab = b - a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b < 0 : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> ab = - b - - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ab = - b + a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ab = a - b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> vt = v * t <NEWLINE> wt = w * t <NEWLINE> <NL> <NL> <NL> if vt - wt >= ab : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
z = <STRING> <NEWLINE> for x in input ( ) : print ( z [ z . index ( x ) - 3 ] , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> item = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> item . add ( s ) <NEWLINE> <DEDENT> print ( len ( item ) ) <NEWLINE> <NL> <NL>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = [ ] <NEWLINE> Sum = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> Wa = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> Wa += A [ i ] <NEWLINE> Sum . append ( Wa ) <NEWLINE> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( 0 , i ) : <NEWLINE> <INDENT> Num = Sum [ i ] - Sum [ j ] <NEWLINE> Sum . append ( Num ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( Sum ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if s - i - j <= k and s - i - j >= 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * n <NEWLINE> prev = [ - 1 ] * n <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> d = dist [ v ] <NEWLINE> for w in g [ v ] : <NEWLINE> <INDENT> if dist [ w ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w ] = d + 1 <NEWLINE> que . append ( w ) <NEWLINE> prev [ w ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in prev [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> n = str ( n ) <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> c += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> if c % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = n // i <NEWLINE> ans += i * ( k ) * ( k + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> class DisjointSet ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . parent = None <NEWLINE> self . ancestor = self <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def ancestor ( elems , x ) : <NEWLINE> <INDENT> s = elems [ x ] . ancestor <NEWLINE> while s . parent is not None : <NEWLINE> <INDENT> s = s . parent <NEWLINE> <DEDENT> elems [ x ] . ancestor = s <NEWLINE> return s <NEWLINE> <NL> <NL> <DEDENT> def unite ( elems , x , y ) : <NEWLINE> <INDENT> ax = ancestor ( elems , x ) <NEWLINE> ay = ancestor ( elems , y ) <NEWLINE> if ax is not ay : <NEWLINE> <INDENT> parent = DisjointSet ( ) <NEWLINE> ax . parent = ay . parent = parent <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def same ( elems , x , y ) : <NEWLINE> <INDENT> return ancestor ( elems , x ) is ancestor ( elems , y ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> elems = [ DisjointSet ( ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if com == 0 : <NEWLINE> <INDENT> unite ( elems , x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 if same ( elems , x , y ) else 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_nl2 = lambda H : [ in_nl ( ) for _ in range ( H ) ] <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in readline ( ) if s != ord ( <STRING> ) ] <NEWLINE> in_map2 = lambda H : [ in_map ( ) for _ in range ( H ) ] <NEWLINE> in_all = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = in_n ( ) <NEWLINE> A = in_nl ( ) <NEWLINE> <NL> pa , ma = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] >= 0 : <NEWLINE> <INDENT> pa . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> pa = deque ( sorted ( pa ) ) <NEWLINE> ma = deque ( sorted ( ma ) [ : : - 1 ] ) <NEWLINE> <NL> max_value = 0 <NEWLINE> ans = [ ] <NEWLINE> while pa or ma : <NEWLINE> <NL> <INDENT> if len ( pa ) >= 1 and len ( ma ) >= 1 : <NEWLINE> <INDENT> if len ( pa ) == 1 and len ( ma ) == 1 : <NEWLINE> <INDENT> p , m = pa . popleft ( ) , ma . popleft ( ) <NEWLINE> ans . append ( ( p , m ) ) <NEWLINE> max_value = p - m <NEWLINE> <DEDENT> elif len ( pa ) >= 2 and len ( ma ) >= 1 : <NEWLINE> <INDENT> p , m = pa . popleft ( ) , ma [ 0 ] <NEWLINE> ans . append ( ( m , p ) ) <NEWLINE> ma [ 0 ] -= p <NEWLINE> <DEDENT> elif len ( pa ) >= 1 and len ( ma ) >= 2 : <NEWLINE> <INDENT> p , m = pa [ 0 ] , ma . popleft ( ) <NEWLINE> ans . append ( ( p , m ) ) <NEWLINE> pa [ 0 ] -= m <NEWLINE> <DEDENT> <DEDENT> elif len ( pa ) >= 2 : <NEWLINE> <INDENT> if len ( pa ) == 2 : <NEWLINE> <INDENT> p1 , p2 = pa . popleft ( ) , pa . popleft ( ) <NEWLINE> p1 , p2 = max ( p1 , p2 ) , min ( p1 , p2 ) <NEWLINE> ans . append ( ( p1 , p2 ) ) <NEWLINE> max_value = p1 - p2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p1 , p2 = pa . popleft ( ) , pa . popleft ( ) <NEWLINE> ans . append ( ( p1 , p2 ) ) <NEWLINE> if ( tp : = p1 - p2 ) >= 0 : <NEWLINE> <INDENT> pa . appendleft ( tp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma . append ( tp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif len ( ma ) >= 2 : <NEWLINE> <INDENT> if len ( ma ) == 2 : <NEWLINE> <INDENT> m1 , m2 = ma . popleft ( ) , ma . popleft ( ) <NEWLINE> m1 , m2 = max ( m1 , m2 ) , min ( m1 , m2 ) <NEWLINE> ans . append ( ( m1 , m2 ) ) <NEWLINE> max_value = m1 - m2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m1 , m2 = ma . popleft ( ) , ma . popleft ( ) <NEWLINE> ans . append ( ( m1 , m2 ) ) <NEWLINE> pa . appendleft ( m1 - m2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_value ) <NEWLINE> print ( <STRING> . join ( map ( lambda a : <STRING> . format ( a [ 0 ] , a [ 1 ] ) , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> dp = np . zeros ( n , dtype = int ) <NEWLINE> <COMMENT> <NL> h = np . array ( h ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = max ( 0 , i - k ) <NEWLINE> <COMMENT> <NL> dp [ i ] = min ( dp [ start : i ] + np . abs ( h [ i ] - h [ start : i ] ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> def solve ( n , l , pos ) : <NEWLINE> <INDENT> if ( pos == n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if ( pos == n - 1 ) : <NEWLINE> <INDENT> return abs ( l [ - 1 ] - l [ - 2 ] ) <NEWLINE> <DEDENT> if ( t [ pos ] != - 1 ) : <NEWLINE> <INDENT> return t [ pos ] <NEWLINE> <DEDENT> t [ pos ] = min ( abs ( l [ pos - 1 ] - l [ pos ] ) + solve ( n , l , pos + 1 ) , abs ( l [ pos - 1 ] - l [ pos + 1 ] ) + solve ( n , l , pos + 2 ) ) <NEWLINE> return t [ pos ] <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> global t <NEWLINE> t = [ - 1 ] * ( n + 1 ) <NEWLINE> print ( solve ( n , l , 1 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> AB . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> J = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if H [ AB [ i ] [ 0 ] - 1 ] < H [ AB [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> J [ AB [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> elif H [ AB [ i ] [ 0 ] - 1 ] == H [ AB [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> J [ AB [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> J [ AB [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> J [ AB [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in J : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> d2 = d ** 2 <NEWLINE> <NL> xy2 = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xy2 . append ( x ** 2 + y ** 2 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <DEDENT> for i in xy2 : <NEWLINE> <INDENT> if d2 >= i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> q = n // ( a + b ) <NEWLINE> mod = n % ( a + b ) <NEWLINE> if mod > a : <NEWLINE> <INDENT> remain = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> remain = mod <NEWLINE> <NL> <DEDENT> print ( q * a + remain ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> dp = [ 0 ] * ( a [ - 1 ] + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = a [ i ] <NEWLINE> while tmp <= a [ - 1 ] : <NEWLINE> <INDENT> dp [ tmp ] += 1 <NEWLINE> tmp += a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
print ( input ( ) . swapcase ( ) ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> arg = [ 0 ] * ( 100005 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> arg [ a ] += 1 <NEWLINE> <DEDENT> ans = sum ( A ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += arg [ a ] * ( b - a ) <NEWLINE> print ( ans ) <NEWLINE> arg [ b ] += arg [ a ] <NEWLINE> arg [ a ] = 0 <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> lis = list ( S ) <NEWLINE> C = collections . Counter ( lis ) <NEWLINE> count = list ( C . values ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , ( N + i - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if ( lis [ i ] != lis [ j ] ) : <NEWLINE> <INDENT> if ( lis [ j ] != lis [ 2 * j - i ] ) : <NEWLINE> <INDENT> if ( lis [ i ] != lis [ 2 * j - i ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( len ( count ) == 3 ) : <NEWLINE> <INDENT> print ( count [ 0 ] * count [ 1 ] * count [ 2 ] - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> [ <NEWLINE> <INDENT> [ <NEWLINE> <INDENT> 0 for r in range ( 10 ) <NEWLINE> <DEDENT> ] for f in range ( 3 ) <NEWLINE> <DEDENT> ] for b in range ( 4 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , data [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] == S [ j ] or S [ j ] == S [ k ] or S [ i ] == S [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def map_int_input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) ) <NEWLINE> <NL> <DEDENT> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def MII_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) ) <NEWLINE> <NL> <DEDENT> def MII_split_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def list_int_inputs ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <DEDENT> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def LII_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> def LII_split_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = MII_split ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> uf = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = MII_split ( ) <NEWLINE> uf . union ( A - 1 , B - 1 ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( max ( uf . size ( x ) for x in range ( uf . group_count ( ) ) ) ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> x = min ( N , B - 1 ) <NEWLINE> <NL> A_x = A * x <NEWLINE> left_ = int ( A_x / B ) <NEWLINE> right_ = A * int ( x / B ) <NEWLINE> fnc_ = left_ - right_ <NEWLINE> if x <= N : <NEWLINE> <INDENT> ans = max ( ans , fnc_ ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = K <NEWLINE> score = 0 <NEWLINE> <NL> if ( K <= A ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( K <= ( A + B ) ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - ( A + B ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import pprint <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> class Logger : <NEWLINE> <INDENT> def __init__ ( self , debug ) : <NEWLINE> <INDENT> self . debug = debug <NEWLINE> <DEDENT> def print ( self , * args ) : <NEWLINE> <INDENT> if self . debug : <NEWLINE> <INDENT> pprint . pprint ( args ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> log = Logger ( 0 ) <NEWLINE> x , n = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> i = x - 1 <NEWLINE> lower = 0 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> if not i + 1 in p : <NEWLINE> <INDENT> lower = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> i -= 1 <NEWLINE> <DEDENT> i = x - 1 <NEWLINE> upper = 101 <NEWLINE> while i <= 101 : <NEWLINE> <INDENT> if not i + 1 in p : <NEWLINE> <INDENT> upper = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if abs ( x - lower ) == abs ( x - upper ) : <NEWLINE> <INDENT> print ( lower ) <NEWLINE> <DEDENT> elif abs ( x - lower ) < abs ( x - upper ) : <NEWLINE> <INDENT> print ( lower ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( upper ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumA = sum ( A ) <NEWLINE> x = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sumA -= A [ i ] <NEWLINE> x += A [ i ] * sumA <NEWLINE> <DEDENT> print ( x % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rem_list = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> rem_list . append ( a - 1 ) <NEWLINE> <DEDENT> if h [ b - 1 ] <= h [ a - 1 ] : <NEWLINE> <INDENT> rem_list . append ( b - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - len ( set ( rem_list ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> t *= a [ i ] <NEWLINE> if t > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = a [ : ] <NEWLINE> p = max ( a ) <NEWLINE> b . remove ( p ) <NEWLINE> q = max ( b ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i != p : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT> <DEDENT>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( reverse = True ) <NEWLINE> q . sort ( reverse = True ) <NEWLINE> <NL> p2 = p [ : x ] <NEWLINE> q2 = q [ : y ] <NEWLINE> <NL> l = p2 + q2 + r <NEWLINE> l . sort ( reverse = True ) <NEWLINE> <NL> ans = sum ( l [ : x + y ] ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import collections <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> a_cnt = collections . Counter ( A ) <NEWLINE> p = sorted ( [ i for i in a_cnt . items ( ) if i [ 1 ] >= 2 ] , reverse = True ) <NEWLINE> if len ( p ) > 0 : <NEWLINE> <INDENT> if p [ 0 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( p [ 0 ] [ 0 ] ** 2 ) <NEWLINE> <DEDENT> elif len ( p ) > 1 : <NEWLINE> <INDENT> print ( p [ 0 ] [ 0 ] * p [ 1 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> B = collections . Counter ( A ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> print ( B [ i + 1 ] ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> r = [ [ ] for i in range ( N + 1 ) ] <COMMENT> <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> r [ a ] . append ( b ) <NEWLINE> r [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> miteru = deque ( [ 1 ] ) <COMMENT> <NEWLINE> mita = { 1 } <COMMENT> <NEWLINE> res = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> while miteru : <NEWLINE> <INDENT> now = miteru . popleft ( ) <NEWLINE> x = set ( r [ now ] ) <NEWLINE> x = x - mita <NEWLINE> for i in x : <NEWLINE> <INDENT> miteru . append ( i ) <NEWLINE> if res [ i ] == - 1 : res [ i ] = now <NEWLINE> mita . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in res [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT>
import sys <NEWLINE> <NL> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> s = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> s *= x <NEWLINE> if s > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if s > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B_i , C_i = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> B . append ( B_i ) <NEWLINE> C . append ( C_i ) <NEWLINE> <NL> <DEDENT> max_i = max ( max ( A ) , max ( C ) ) <NEWLINE> <NL> A_N = [ 0 for _ in range ( max_i + 1 ) ] <NEWLINE> sum_i = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> A_N [ a ] += a <NEWLINE> sum_i += a <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> diff_replace = int ( A_N [ B [ i ] ] / B [ i ] ) * C [ i ] <NEWLINE> sum_i += diff_replace - A_N [ B [ i ] ] <NEWLINE> <NL> A_N [ C [ i ] ] += diff_replace <NEWLINE> A_N [ B [ i ] ] = 0 <NEWLINE> <NL> print ( sum_i ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ 0 for _ in range ( k ) ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> sn = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( d [ i ] ) : <NEWLINE> <INDENT> sn [ a [ i ] [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> print ( sn . count ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> a_sort = sorted ( a , reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a_sort [ 0 ] : <NEWLINE> <INDENT> print ( a_sort [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a_sort [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> DP = [ ] <NEWLINE> ans = 0 <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> b = math . gcd ( a , k ) <NEWLINE> ans += b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( l [ i + 1 ] + l [ i ] ) <NEWLINE> <DEDENT> print ( l [ n ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , h = nii ( ) <NEWLINE> l . append ( [ x , y , h ] ) <NEWLINE> if h != 0 : <NEWLINE> <INDENT> ini_x = x <NEWLINE> ini_y = y <NEWLINE> ini_h = h <NEWLINE> <NL> <DEDENT> <DEDENT> for tx in range ( 101 ) : <NEWLINE> <INDENT> for ty in range ( 101 ) : <NEWLINE> <INDENT> n_h = abs ( tx - ini_x ) + abs ( ty - ini_y ) + ini_h <NEWLINE> for x , y , h in l : <NEWLINE> <INDENT> t_h = max ( n_h - ( abs ( tx - x ) + abs ( ty - y ) ) , 0 ) <NEWLINE> if h != t_h : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( tx , ty , n_h ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> HL , WL = [ 0 ] * H , [ 0 ] * W <NEWLINE> B = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> B . append ( ( h , w ) ) <NEWLINE> HL [ h ] += 1 <NEWLINE> WL [ w ] += 1 <NEWLINE> <NL> <DEDENT> HM , WM = max ( HL ) , max ( WL ) <NEWLINE> K = HL . count ( HM ) * WL . count ( WM ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for h , w in B : <NEWLINE> <INDENT> if HL [ h ] == HM and WL [ w ] == WM : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if K > cnt : <NEWLINE> <INDENT> print ( HM + WM ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( HM + WM - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> item_list = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> item_list . append ( str ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> item_set = ( set ( item_list ) ) <NEWLINE> print ( len ( item_set ) ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> sat = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , ( input ( ) . split ( ) ) ) ) ) <NEWLINE> sat += max ( s [ i ] ) <NEWLINE> ans = s [ i ] . index ( max ( s [ i ] ) ) + 1 <NEWLINE> t . append ( ans ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> L = [ 0 ] * 201 <NEWLINE> <NL> for g in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> L [ g ] += gcd ( g , c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> ans += L [ g ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> point_l = [ k - q ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> ans = int ( input ( ) ) <NEWLINE> point_l [ ans - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> if point_l [ i ] > 0 else <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) . split ( ) <NEWLINE> a , b = int ( x [ 0 ] ) , int ( x [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX = 10 ** 18 <NEWLINE> <NL> if min ( nums ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for num in nums : <NEWLINE> <INDENT> ans = ans * num <NEWLINE> if ans > MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> sum_of_digits = 0 <NEWLINE> <NL> cnts = [ 0 ] * 2019 <NEWLINE> <NL> cnts [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> sum_of_digits += int ( c ) * d <NEWLINE> sum_of_digits %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> cnts [ sum_of_digits ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for cnt in cnts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> h = s // 3600 <NEWLINE> m = s % 3600 // 60 <NEWLINE> s = s % 3600 % 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> if m % 2 == 1 : <NEWLINE> <INDENT> for i in range ( m // 2 ) : <NEWLINE> <INDENT> print ( i + 1 , m - i ) <NEWLINE> <DEDENT> for i in range ( m // 2 + 1 ) : <NEWLINE> <INDENT> print ( m + 1 + i , 2 * m + 1 - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m // 2 ) : <NEWLINE> <INDENT> print ( i + 1 , m - i + 1 ) <NEWLINE> <DEDENT> for i in range ( m // 2 ) : <NEWLINE> <INDENT> print ( m + 2 + i , 2 * m + 1 - i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> inp = input ( ) <NEWLINE> ten = inp . find ( <STRING> ) <NEWLINE> L = len ( inp ) <NEWLINE> batu = 9 <NEWLINE> if ten != - 1 : <NEWLINE> <INDENT> batu -= L - ten - 1 <NEWLINE> <DEDENT> inp = inp . replace ( <STRING> , <STRING> ) <NEWLINE> inp = int ( inp ) <NEWLINE> inp *= 10 ** batu <NEWLINE> A . append ( inp ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> dat = [ [ 0 ] * 19 for _ in range ( 19 ) ] <NEWLINE> rui = [ [ 0 ] * 19 for _ in range ( 19 ) ] <NEWLINE> <NL> B = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dev2 , dev5 = 0 , 0 <NEWLINE> while A [ i ] % 2 == 0 and dev2 < 18 : <NEWLINE> <INDENT> dev2 += 1 <NEWLINE> A [ i ] //= 2 <NEWLINE> <DEDENT> while A [ i ] % 5 == 0 and dev5 < 18 : <NEWLINE> <INDENT> dev5 += 1 <NEWLINE> A [ i ] //= 5 <NEWLINE> <DEDENT> dat [ dev2 ] [ dev5 ] += 1 <NEWLINE> B . append ( [ dev2 , dev5 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 19 ) : <NEWLINE> <INDENT> for j in range ( 19 ) : <NEWLINE> <INDENT> for k in range ( i + 1 ) : <NEWLINE> <INDENT> for l in range ( j + 1 ) : <NEWLINE> <INDENT> rui [ k ] [ l ] += dat [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dev2 , dev5 = B [ i ] <NEWLINE> t_dev2 , t_dev5 = 18 - dev2 , 18 - dev5 <NEWLINE> if dev2 >= t_dev2 and dev5 >= t_dev5 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> ans += rui [ t_dev2 ] [ t_dev5 ] <NEWLINE> <NL> <DEDENT> print ( ans // 2 ) <NEWLINE> <NL> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> d = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> v = 1 <NEWLINE> while ( d [ v ] == - 1 ) : <NEWLINE> <INDENT> d [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <DEDENT> c = len ( s ) - d [ v ] <NEWLINE> l = d [ v ] <NEWLINE> <NL> if ( k < l ) : print ( s [ k ] ) <NEWLINE> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( s [ k + l ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> t = 0 <NEWLINE> A = [ 0 ] * 2019 <NEWLINE> A [ 0 ] += 1 <NEWLINE> d = 1 <NEWLINE> for s in reversed ( S ) : <NEWLINE> <INDENT> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> t += ( int ( s ) * d ) <NEWLINE> t %= 2019 <NEWLINE> A [ t ] += 1 <NEWLINE> <DEDENT> result = sum ( [ a * ( a - 1 ) // 2 for a in A ] ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> N , M = map ( int , pin ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , pin ( ) . split ( ) ) <NEWLINE> uf . union ( A - 1 , B - 1 ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> temp = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> temp -= A [ i ] <NEWLINE> ans += A [ i ] * temp <NEWLINE> <NL> <DEDENT> print ( int ( ans % ( 10 ** 9 + 7 ) ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> if i == j and i == k : <NEWLINE> <INDENT> buff = 1 <NEWLINE> <DEDENT> elif i == j : <NEWLINE> <INDENT> buff = 3 <NEWLINE> <DEDENT> elif j == k : <NEWLINE> <INDENT> buff = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buff = 6 <NEWLINE> <DEDENT> g1 = math . gcd ( i , j ) <NEWLINE> g = math . gcd ( k , g1 ) <NEWLINE> ans += g * buff <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = min ( n % k , k - n % k ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> cnt = collections . Counter ( S ) <NEWLINE> max_cnt = max ( cnt . values ( ) ) <NEWLINE> <NL> ans_list = [ ] <NEWLINE> <NL> for key , value in cnt . items ( ) : <NEWLINE> <INDENT> if value == max_cnt : <NEWLINE> <INDENT> ans_list . append ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * sorted ( ans_list ) , sep = <STRING> ) <NEWLINE> <NL>
import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dics = [ { } for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ky = r - 1 <NEWLINE> if ky in dics [ l - 1 ] : <NEWLINE> <INDENT> if c < dics [ l - 1 ] [ ky ] : <NEWLINE> <INDENT> dics [ l - 1 ] [ ky ] = c <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dics [ l - 1 ] [ ky ] = c <NEWLINE> <DEDENT> <DEDENT> dist = [ float ( <STRING> ) ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> hq = [ ] <NEWLINE> heapq . heappush ( hq , [ 0 , 0 ] ) <NEWLINE> idx = 0 <NEWLINE> while len ( hq ) > 0 : <NEWLINE> <INDENT> v , p = heapq . heappop ( hq ) <NEWLINE> if p < idx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if p == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( idx + 1 , p ) : <NEWLINE> <INDENT> if len ( dics [ i ] ) > 0 : <NEWLINE> <INDENT> for ky in dics [ i ] . keys ( ) : <NEWLINE> <INDENT> if ky in dics [ p ] : <NEWLINE> <INDENT> if dics [ p ] [ ky ] > dics [ i ] [ ky ] : <NEWLINE> <INDENT> dics [ p ] [ ky ] = dics [ i ] [ ky ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p < ky : <NEWLINE> <INDENT> dics [ p ] [ ky ] = dics [ i ] [ ky ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> idx = p <NEWLINE> for r in dics [ p ] . keys ( ) : <NEWLINE> <INDENT> if dist [ r ] > v + dics [ p ] [ r ] : <NEWLINE> <INDENT> dist [ r ] = v + dics [ p ] [ r ] <NEWLINE> heapq . heappush ( hq , [ v + dics [ p ] [ r ] , r ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dist [ n - 1 ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pp = [ 0 ] * n <NEWLINE> res = 0 <NEWLINE> <NL> qq = [ True ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> i , j = input ( ) . split ( ) <NEWLINE> i = int ( i ) <NEWLINE> i -= 1 <NEWLINE> if j == <STRING> : <NEWLINE> <INDENT> if qq [ i ] : <NEWLINE> <INDENT> qq [ i ] = False <NEWLINE> res += pp [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pp [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( qq . count ( False ) , res ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c_ = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> cc_ = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cc_ . append ( c_ [ i ] [ 0 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> import numpy as np <NEWLINE> import itertools <NEWLINE> l_ = np . arange ( n ) . tolist ( ) <NEWLINE> <NL> res_ = [ ] <NEWLINE> resList = [ ] <NEWLINE> flag = False <NEWLINE> flag3 = True <NEWLINE> if n == 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if c_ [ 0 ] [ i + 1 ] < x : <NEWLINE> <COMMENT> <NL> <INDENT> flag3 = False <NEWLINE> <DEDENT> <DEDENT> print ( cc_ [ 0 ] if flag3 else - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c = list ( itertools . combinations ( l_ , i ) ) <NEWLINE> for j in c : <NEWLINE> <INDENT> res_ = [ ] <NEWLINE> flag2 = True <NEWLINE> for l in range ( m ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> sum_money = 0 <NEWLINE> for k in range ( len ( j ) ) : <NEWLINE> <INDENT> res += c_ [ j [ k ] ] [ l + 1 ] <NEWLINE> sum_money += c_ [ j [ k ] ] [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> if res < x : <NEWLINE> <INDENT> flag2 = False <NEWLINE> <DEDENT> <DEDENT> if flag2 : <NEWLINE> <INDENT> resList . append ( sum_money ) <NEWLINE> flag = True <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( resList ) if flag else - 1 ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d / t <= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class BinaryTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , insert_node ) : <NEWLINE> <INDENT> p = None <NEWLINE> r = self . root <NEWLINE> while r : <NEWLINE> <INDENT> p = r <NEWLINE> if insert_node . value < r . value : <NEWLINE> <INDENT> r = r . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = r . right <NEWLINE> <NL> <DEDENT> <DEDENT> if not p : <NEWLINE> <INDENT> self . root = insert_node <NEWLINE> <DEDENT> elif insert_node . value < p . value : <NEWLINE> <INDENT> p . left = insert_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = insert_node <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , find_value ) : <NEWLINE> <INDENT> r = self . root <NEWLINE> while r : <NEWLINE> <INDENT> if find_value == r . value : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if find_value < r . value : <NEWLINE> <INDENT> r = r . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = r . right <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def delete ( self , delete_value ) : <NEWLINE> <INDENT> flag = None <NEWLINE> p = None <NEWLINE> r = self . root <NEWLINE> while True : <NEWLINE> <INDENT> if delete_value == r . value : <NEWLINE> <INDENT> if r . left == None and r . right == None : <NEWLINE> <INDENT> if flag == <STRING> : <NEWLINE> <INDENT> p . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = None <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> elif r . left == None : <NEWLINE> <INDENT> if flag == <STRING> : <NEWLINE> <INDENT> p . left = r . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = r . right <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> elif r . right == None : <NEWLINE> <INDENT> if flag == <STRING> : <NEWLINE> <INDENT> p . left = r . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = r . left <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r2 = r . right <NEWLINE> while r2 : <NEWLINE> <INDENT> p = r2 <NEWLINE> r2 = r2 . left <NEWLINE> <DEDENT> swap_value = p . value <NEWLINE> self . delete ( swap_value ) <NEWLINE> r . value = swap_value <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> elif delete_value < r . value : <NEWLINE> <INDENT> p = r <NEWLINE> r = r . left <NEWLINE> flag = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = r <NEWLINE> r = r . right <NEWLINE> flag = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , value , left , right ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def pre_order_search ( self ) : <NEWLINE> <INDENT> l = self . left <NEWLINE> r = self . right <NEWLINE> print ( <STRING> , self . value , end = <STRING> ) <NEWLINE> if l : <NEWLINE> <INDENT> l . pre_order_search ( ) <NEWLINE> <DEDENT> if r : <NEWLINE> <INDENT> r . pre_order_search ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def in_order_search ( self ) : <NEWLINE> <INDENT> l = self . left <NEWLINE> r = self . right <NEWLINE> if l : <NEWLINE> <INDENT> l . in_order_search ( ) <NEWLINE> <DEDENT> print ( <STRING> , self . value , end = <STRING> ) <NEWLINE> if r : <NEWLINE> <INDENT> r . in_order_search ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> m = int ( input ( ) ) <NEWLINE> tree = BinaryTree ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> inp = input ( ) . split ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( Node ( int ( inp [ 1 ] ) , None , None ) ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( tree . find ( int ( inp [ 1 ] ) ) ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . delete ( int ( inp [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . root . in_order_search ( ) <NEWLINE> print ( ) <NEWLINE> tree . root . pre_order_search ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ map ( int , input ( ) . split ( ) ) for _ in range ( M ) ] <NEWLINE> a , b = map ( list , zip ( * ab ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> removeList = [ ] <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if ( H [ a [ i ] - 1 ] > H [ b [ i ] - 1 ] ) : <NEWLINE> <INDENT> removeList . append ( b [ i ] ) <NEWLINE> <DEDENT> elif ( H [ a [ i ] - 1 ] < H [ b [ i ] - 1 ] ) : <NEWLINE> <INDENT> removeList . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> removeList . append ( a [ i ] ) <NEWLINE> removeList . append ( b [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> set ( removeList ) <NEWLINE> print ( N - len ( set ( removeList ) ) ) <NEWLINE>
import math <NEWLINE> L = 10 ** 6 + 1 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ 0 ] * L <NEWLINE> flag = 0 <COMMENT> <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> memo [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , L ) : <COMMENT> <NEWLINE> <INDENT> if sum ( memo [ i : : i ] ) > 1 : <COMMENT> <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> g = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> g = math . gcd ( g , A [ i ] ) <NEWLINE> <NL> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> elif flag == 1 and g == 1 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> maxn = 1000000 <NEWLINE> plist = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( maxn ) ] <NEWLINE> <NL> plist [ 0 ] = plist [ 1 ] = False <NEWLINE> plist [ 2 ] = plist [ 3 ] = plist [ 5 ] = True <NEWLINE> <NL> for chki in range ( 3 , maxn , 2 ) : <NEWLINE> <INDENT> for j in range ( chki ** 2 , maxn , chki ) : <NEWLINE> <INDENT> plist [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <COMMENT> <NL> <INDENT> inn = int ( raw_input ( ) ) <NEWLINE> print plist [ 0 : inn + 1 ] . count ( True ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> counter = Counter ( a ) <NEWLINE> sum_res = sum ( a ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> before , after = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> sum_res -= before * counter [ before ] <NEWLINE> sum_res += after * counter [ before ] <NEWLINE> <NL> <COMMENT> <NL> counter [ after ] += counter [ before ] <NEWLINE> counter [ before ] = 0 <NEWLINE> <NL> print ( sum_res ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def RD ( ) : return sys . stdin . read ( ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def TI ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , k = MI ( ) <NEWLINE> x1 , y1 , x2 , y2 = MI ( ) <NEWLINE> G = [ <STRING> ] * ( w + 2 ) <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> G . append ( <STRING> ) <NEWLINE> G += ( list ( map ( str , input ( ) . rstrip ( ) ) ) ) <NEWLINE> G . append ( <STRING> ) <NEWLINE> <DEDENT> G += [ <STRING> ] * ( w + 2 ) <NEWLINE> <COMMENT> <NL> <NL> <NL> G [ x1 * ( w + 2 ) + y1 ] = 0 <NEWLINE> <COMMENT> <NL> <NL> Q = deque ( ) <NEWLINE> Q . append ( ( x1 * ( w + 2 ) + y1 , 0 ) ) <NEWLINE> <NL> while Q : <NEWLINE> <COMMENT> <NL> <INDENT> now , d = Q . popleft ( ) <NEWLINE> <COMMENT> <NL> for m in [ 1 , - 1 , w + 2 , - w - 2 ] : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if G [ now + m * i ] == d or G [ now + m * i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif G [ now + m * i ] == <STRING> : <NEWLINE> <INDENT> G [ now + m * i ] = d + 1 <NEWLINE> Q . append ( [ now + m * i , d + 1 ] ) <NEWLINE> <DEDENT> elif G [ now + m * i ] == d + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if G [ x2 * ( w + 2 ) + y2 ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( G [ x2 * ( w + 2 ) + y2 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> sumA = sum ( A ) % mod <NEWLINE> ans = 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> sumA -= i <NEWLINE> ans += i * sumA <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> data = [ [ int ( num ) for num in input ( ) . split ( <STRING> ) ] for i in range ( n ) ] <NEWLINE> state = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for datum in data : <NEWLINE> <INDENT> state [ datum [ 0 ] - 1 ] [ datum [ 1 ] - 1 ] [ datum [ 2 ] - 1 ] += datum [ 3 ] <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> s += <STRING> + str ( state [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> name = [ 0 ] * 5 <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> st = input ( ) <NEWLINE> if st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 0 ] += 1 <NEWLINE> <DEDENT> elif st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 1 ] += 1 <NEWLINE> <DEDENT> elif st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 2 ] += 1 <NEWLINE> <DEDENT> elif st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 3 ] += 1 <NEWLINE> <DEDENT> elif st [ 0 ] == <STRING> : <NEWLINE> <INDENT> name [ 4 ] += 1 <NEWLINE> <DEDENT> s . append ( st ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for v in itertools . combinations ( name , 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += v [ 0 ] * v [ 1 ] * v [ 2 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alice = 0 <NEWLINE> bob = 0 <NEWLINE> <NL> nums . sort ( ) <NEWLINE> while nums : <NEWLINE> <INDENT> alice += nums . pop ( ) <NEWLINE> if nums : <NEWLINE> <INDENT> bob += nums . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] ] = i + 1 <NEWLINE> <DEDENT> s = [ ans [ i + 1 ] for i in range ( n ) ] <NEWLINE> print ( * s ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> commands = [ input ( ) for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> l = deque ( ) <NEWLINE> for com in commands : <NEWLINE> <INDENT> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . appendleft ( com [ 7 : ] ) <NEWLINE> <DEDENT> elif com [ 6 ] == <STRING> : <NEWLINE> <INDENT> l . popleft ( ) <NEWLINE> <DEDENT> elif com [ 6 ] == <STRING> : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l . remove ( com [ 7 : ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s = <STRING> . join ( l ) <NEWLINE> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> t = s <NEWLINE> s_list = list ( s ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if s_list [ i ] == <STRING> : <NEWLINE> <NL> <NL> <INDENT> if s_list [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if i == len ( t ) - 1 : <NEWLINE> <INDENT> s_list [ i ] = <STRING> <NEWLINE> <DEDENT> elif s_list [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s_list [ i ] = <STRING> <NEWLINE> <DEDENT> elif s_list [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s_list [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_list [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s_list [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s_cha = <STRING> . join ( s_list ) <NEWLINE> print ( s_cha ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> s = 0 <NEWLINE> for g in range ( len ( a ) ) : <NEWLINE> <INDENT> s += a [ g ] <NEWLINE> <DEDENT> e = [ 0 ] * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> e [ i ] += 1 <NEWLINE> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> s += ( bc [ j ] [ 1 ] - bc [ j ] [ 0 ] ) * e [ bc [ j ] [ 0 ] ] <NEWLINE> e [ bc [ j ] [ 1 ] ] += e [ bc [ j ] [ 0 ] ] <NEWLINE> e [ bc [ j ] [ 0 ] ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> rgb = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in s : <NEWLINE> <INDENT> rgb [ i ] += 1 <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 * j - i <NEWLINE> if j < k and k < n and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( rgb [ <STRING> ] * rgb [ <STRING> ] * rgb [ <STRING> ] - c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> all_sunuke = [ 1 ] * n <NEWLINE> <NL> for i in range ( 0 , k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( 0 , d ) : <NEWLINE> <INDENT> all_sunuke [ ( a [ j ] - 1 ) ] = all_sunuke [ ( a [ j ] - 1 ) ] * 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( all_sunuke ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import collections <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ [ 0 ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> hw [ a ] . append ( b ) <NEWLINE> hw [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dis = [ 0 ] * ( n + 1 ) <NEWLINE> arr = [ - 1 ] * ( n + 1 ) <NEWLINE> que = collections . deque ( [ 1 ] ) <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> a = que . popleft ( ) <NEWLINE> test = hw [ a ] <NEWLINE> for i in range ( len ( test ) ) : <NEWLINE> <INDENT> if test [ i ] != 0 : <NEWLINE> <INDENT> goal = test [ i ] <NEWLINE> if arr [ goal ] == - 1 : <NEWLINE> <INDENT> arr [ goal ] = a <NEWLINE> que . append ( goal ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if 0 in arr [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , len ( arr ) ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def g ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * g ( n // i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> l = math . pi * r * 2 <NEWLINE> s = ( r ** 2 ) * math . pi <NEWLINE> print ( <STRING> . format ( l , s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> total = sum ( a ) <NEWLINE> dct = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in dct : <NEWLINE> <INDENT> dct [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dct [ a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b not in dct : dct [ b ] = 0 <NEWLINE> if c not in dct : dct [ c ] = 0 <NEWLINE> total += dct [ b ] * ( c - b ) <NEWLINE> print ( total ) <NEWLINE> <NL> dct [ c ] += dct [ b ] <NEWLINE> dct [ b ] = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> fin = sys . stdin <NEWLINE> <NL> n , m = map ( int , fin . readline ( ) . split ( ) ) <NEWLINE> <NL> A = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = list ( map ( int , fin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> b = [ 0 for i in range ( m ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = int ( fin . readline ( ) ) <NEWLINE> <NL> <DEDENT> c = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] += A [ i ] [ j ] * b [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> ans = None <NEWLINE> d_ls = make_divisors ( x ) <NEWLINE> for d in d_ls : <NEWLINE> <INDENT> for a in range ( 0 , 1000 ) : <NEWLINE> <INDENT> b = a - d <NEWLINE> c = a ** 5 - b ** 5 <NEWLINE> if c == x : <NEWLINE> <INDENT> ans = ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans is not None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> lighted = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> u = lighted [ - 1 ] <NEWLINE> v = a [ u ] - 1 <NEWLINE> ans += 1 <NEWLINE> if v == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> lighted . append ( v ) <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> M = A [ - 1 ] + 1 <NEWLINE> DP = [ 0 ] * M <NEWLINE> for i in A : <NEWLINE> <INDENT> DP [ i ] += 1 <NEWLINE> for j in range ( i * 2 , M , i ) : <NEWLINE> <INDENT> DP [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> print ( DP . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m , * ab = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> to = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 0 , m * 2 , 2 ) : <NEWLINE> <INDENT> a = ab [ i ] <NEWLINE> b = ab [ i + 1 ] <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ None ] * ( n + 1 ) <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> p = q . pop ( ) <NEWLINE> children = to [ p ] <NEWLINE> for child in children : <NEWLINE> <INDENT> if ans [ child ] is None : <NEWLINE> <INDENT> ans [ child ] = p <NEWLINE> q . appendleft ( child ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , ans [ 2 : ] ) ) ) <NEWLINE>
r , g , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> if r >= g : <NEWLINE> <INDENT> g *= 2 <NEWLINE> <DEDENT> elif g >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> <NL> <DEDENT> if r < g and g < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def test ( n ) : <NEWLINE> <INDENT> buf = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i ** 2 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i ** 2 == n : <NEWLINE> <INDENT> buf += 1 <NEWLINE> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> buf += 2 <NEWLINE> <DEDENT> <DEDENT> return buf <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += int ( ( N - 1 ) / ( i + 1 ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> y = 0 <NEWLINE> a = [ 0 ] <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> y += int ( x ) <NEWLINE> a . append ( y ) <NEWLINE> <DEDENT> y = 0 <NEWLINE> b = [ 0 ] <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> y += int ( x ) <NEWLINE> b . append ( y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while j >= 0 : <NEWLINE> <INDENT> if a [ i ] + b [ j ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for j in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> if A [ j - k - 1 ] < A [ j - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> p . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> q = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q [ p [ i ] - 1 ] = i <NEWLINE> <DEDENT> m , cnt = 1 , 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if q [ i ] > q [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt > m : <NEWLINE> <INDENT> m = cnt <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - m ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> p = 1000000007 <NEWLINE> <NL> k = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = lcm ( k , a [ i ] ) <NEWLINE> <NL> <DEDENT> k %= p <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += k * pow ( a [ i ] , p - 2 , p ) <NEWLINE> ans %= p <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> point = 0 <NEWLINE> rList = [ ] <NEWLINE> gList = [ ] <NEWLINE> bList = [ ] <NEWLINE> for value in s : <NEWLINE> <INDENT> point += 1 <NEWLINE> if value == <STRING> : <NEWLINE> <INDENT> rList . append ( point ) <NEWLINE> <DEDENT> elif value == <STRING> : <NEWLINE> <INDENT> gList . append ( point ) <NEWLINE> <DEDENT> elif value == <STRING> : <NEWLINE> <INDENT> bList . append ( point ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( rList ) < 1 or len ( gList ) < 1 or len ( bList ) < 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = len ( rList ) * len ( gList ) * len ( bList ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> Q = int ( input ( ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> s = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <COMMENT> <NL> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if c [ B ] : <NEWLINE> <INDENT> s += ( C - B ) * c [ B ] <NEWLINE> c [ C ] += c [ B ] <NEWLINE> c [ B ] = 0 <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
def srch ( i , l , Lng , Dst ) : <NEWLINE> <INDENT> if Lng [ i ] != - 1 and Lng [ i ] < l : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> Lng [ i ] = l <NEWLINE> if Dst [ i ] is not None and len ( Dst [ i ] ) > 0 : <NEWLINE> <INDENT> for c in Dst [ i ] : <NEWLINE> <INDENT> srch ( c , l + 1 , Lng , Dst ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> Dst = [ None for i in range ( num + 1 ) ] <NEWLINE> Lng = [ - 1 ] * ( num + 1 ) <NEWLINE> <NL> for n in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = a [ 0 ] <NEWLINE> if a [ 1 ] > 0 : <NEWLINE> <INDENT> Dst [ u ] = a [ 2 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> srch ( 1 , 0 , Lng , Dst ) <NEWLINE> <NL> for n in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> l = Lng [ n ] <NEWLINE> if l > num : <NEWLINE> <INDENT> l = - 1 <NEWLINE> <DEDENT> print ( <STRING> . format ( n , l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( A - 1 , B - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
string = input ( ) <NEWLINE> for i in string : <NEWLINE> <INDENT> if i . isupper ( ) : <NEWLINE> <INDENT> print ( i . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> elif i . islower ( ) : <NEWLINE> <INDENT> print ( i . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
A , B , N = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> aa = 0 <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> print ( int ( A * N / B ) - A * int ( N / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) / B ) - A * int ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> from copy import copy <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def div ( x ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> ret . append ( i ) <NEWLINE> ret . append ( x // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def judge_prime ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if cnt >= 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> div_a = div ( a ) <NEWLINE> div_b = div ( b ) <NEWLINE> <NL> data = list ( set ( div_a ) & set ( div_b ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in data : <NEWLINE> <INDENT> if judge_prime ( x ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> logs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxL = max ( logs ) <NEWLINE> <NL> def binsearch ( minz , maxz ) : <NEWLINE> <INDENT> if minz >= maxz : <NEWLINE> <INDENT> return minz <NEWLINE> <NL> <DEDENT> mid = ( maxz + minz ) // 2 <NEWLINE> ncut = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> thiscut = int ( ( logs [ i ] + mid - 1 ) / mid ) - 1 <NEWLINE> ncut += thiscut <NEWLINE> if ncut > K : <NEWLINE> <INDENT> return binsearch ( mid + 1 , maxz ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ncut < K : <NEWLINE> <INDENT> return binsearch ( minz , mid ) <NEWLINE> <COMMENT> <NL> <DEDENT> maxx = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> thiscut = int ( ( logs [ i ] + mid - 1 ) / mid ) - 1 <NEWLINE> thislen = int ( ( logs [ i ] + thiscut ) / ( thiscut + 1 ) ) <NEWLINE> if maxx < thislen : maxx = thislen <NEWLINE> <DEDENT> return maxx <NEWLINE> <NL> <DEDENT> if K > 0 : <NEWLINE> <INDENT> ans = binsearch ( 1 , maxL + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = maxL <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> s = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> s += A [ math . ceil ( i / 2 ) ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> from itertools import product , permutations , combinations , accumulate <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from math import ceil , floor , sqrt <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( 10 ** 4 + 1 ) <NEWLINE> h = 0 <NEWLINE> <NL> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> for j in range ( 1 , 99 ) : <NEWLINE> <INDENT> for m in range ( 1 , 99 ) : <NEWLINE> <INDENT> h = i ** 2 + j ** 2 + m ** 2 + i * j + j * m + m * i <NEWLINE> if h >= ( 10 ** 4 ) + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ h ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> if H == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> count = 1 <NEWLINE> while H // 2 != 1 : <NEWLINE> <INDENT> i *= 2 <NEWLINE> count += i <NEWLINE> H = H // 2 <NEWLINE> <DEDENT> i *= 2 <NEWLINE> count += i <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = int ( input ( ) ) <NEWLINE> lists = [ ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> sum = sum + math . gcd ( math . gcd ( i , j ) , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . sort ( ) <NEWLINE> if li [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in li : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> moji = { <STRING> , <STRING> , <STRING> } <NEWLINE> <NL> count = 0 <NEWLINE> for j in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> sj = S [ j ] <NEWLINE> diff_m = moji - { sj } <NEWLINE> rem_moji = list ( diff_m ) <NEWLINE> for mi , mj in zip ( rem_moji , rem_moji [ : : - 1 ] ) : <NEWLINE> <INDENT> ci = S . count ( mi , 0 , j ) <NEWLINE> ck = S . count ( mj , j + 1 , N ) <NEWLINE> count += ci * ck <NEWLINE> <NL> <DEDENT> l = min ( [ j + 1 , N - j ] ) <NEWLINE> for d in range ( 1 , l ) : <NEWLINE> <INDENT> si = S [ j - d ] <NEWLINE> sk = S [ j + d ] <NEWLINE> if si != sj and sj != sk and sk != si : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> an = 0 <NEWLINE> ii = [ ] <NEWLINE> jj = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ii . append ( i + a [ i ] ) <NEWLINE> jj . append ( i - a [ i ] ) <NEWLINE> <DEDENT> jjj = collections . Counter ( jj ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> an += jjj [ ii [ i ] ] <NEWLINE> <DEDENT> print ( an ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> print ( ( n * ( n - 1 ) // 2 ) ) <NEWLINE>
ABs = [ ] <NEWLINE> CDs = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x_1 , y_1 , x_2 , y_2 , x_3 , y_3 , x_4 , y_4 , = map ( float , input ( ) . split ( ) ) <NEWLINE> AB = [ x_2 - x_1 , y_2 - y_1 ] <NEWLINE> CD = [ x_4 - x_3 , y_4 - y_3 ] <NEWLINE> ABs . append ( AB ) <NEWLINE> CDs . append ( CD ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if abs ( ABs [ i ] [ 0 ] * CDs [ i ] [ 1 ] - ABs [ i ] [ 1 ] * CDs [ i ] [ 0 ] ) < 10 ** ( - 10 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = input ( ) <NEWLINE> <NL> status = s [ 0 ] <NEWLINE> cnt = 1 <NEWLINE> sa = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] != status : <NEWLINE> <INDENT> sa . append ( status * cnt ) <NEWLINE> cnt = 0 <NEWLINE> status = s [ i ] <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> sa . append ( status * cnt ) <NEWLINE> <NL> for i in range ( 1 , min ( k * 2 , len ( sa ) ) , 2 ) : <NEWLINE> <INDENT> sa [ i ] = ( <STRING> if sa [ i ] [ 0 ] == <STRING> else <STRING> ) * len ( sa [ i ] ) <NEWLINE> <NL> <DEDENT> sa = <STRING> . join ( sa ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sa [ i ] == <STRING> : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if sa [ i - 1 ] == <STRING> : ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i < n - 1 : <NEWLINE> <INDENT> if sa [ i + 1 ] == <STRING> : ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 20 ) : <NEWLINE> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> n -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ( n % 26 ) + ord ( <STRING> ) ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = sorted ( [ a [ i ] - i for i in range ( n ) ] ) <NEWLINE> print ( sum ( [ abs ( i - a [ n // 2 ] ) for i in a ] ) ) <NEWLINE>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> flag = [ - 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> <NL> flag [ 0 ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> i = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> num = 0 <NEWLINE> <NL> while True : <NEWLINE> <NL> <COMMENT> <NL> <NL> <INDENT> num += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> i = A [ i ] - 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> if flag [ i ] != - 1 : <NEWLINE> <NL> <COMMENT> <NL> <NL> <INDENT> ini = flag [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> flag [ i ] = num <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> loop = num - ini <NEWLINE> <NL> <COMMENT> <NL> <NL> if K > ini : <NEWLINE> <NL> <COMMENT> <NL> <NL> <INDENT> K -= ini <NEWLINE> <NL> <COMMENT> <NL> <NL> t = flag . index ( ini + K % loop ) + 1 <NEWLINE> <NL> print ( t ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> t = flag . index ( K ) + 1 <NEWLINE> print ( t ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = 1 <NEWLINE> LOG = { } <NEWLINE> PATH = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> PATH . append ( D ) <NEWLINE> LOG . setdefault ( D , i ) <NEWLINE> <NL> if LOG [ D ] == i : <NEWLINE> <INDENT> D = A [ D - 1 ] <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if LOG [ D ] < K : <NEWLINE> <INDENT> K = ( K - i ) % ( i - LOG [ D ] ) <NEWLINE> LAST = PATH [ LOG [ D ] + K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LAST = PATH [ K ] <NEWLINE> <DEDENT> print ( LAST ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> a , i , c = list ( range ( 1 , m + 1 ) ) , 0 , 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> i += 1 <NEWLINE> b , f = input ( ) , 0 <NEWLINE> if m < 2 : continue <NEWLINE> if i % 15 == 0 : <NEWLINE> <INDENT> if b != <STRING> : <NEWLINE> <INDENT> del a [ c ] <NEWLINE> f = 1 <NEWLINE> <DEDENT> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> if b != <STRING> : <NEWLINE> <INDENT> del a [ c ] <NEWLINE> f = 1 <NEWLINE> <DEDENT> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> if b != <STRING> : <NEWLINE> <INDENT> del a [ c ] <NEWLINE> f = 1 <NEWLINE> <DEDENT> <DEDENT> elif b != str ( i ) : <NEWLINE> <INDENT> del a [ c ] <NEWLINE> f = 1 <NEWLINE> <DEDENT> if f : m -= 1 <NEWLINE> else : c += 1 <NEWLINE> c %= m <NEWLINE> <DEDENT> print ( * a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> X10 = int ( X , 2 ) <NEWLINE> one = X . count ( <STRING> ) <NEWLINE> def popcount ( n ) : <NEWLINE> <INDENT> c = format ( n , <STRING> ) . count ( <STRING> ) <NEWLINE> if c != 0 : <NEWLINE> <INDENT> return n % c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n = popcount ( n ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT> if one == 1 : <NEWLINE> <INDENT> e = X10 % 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> Y = e + pow ( 2 , N - i - 1 , 2 ) <NEWLINE> print ( f ( Y ) + 1 ) <NEWLINE> <NL> <DEDENT> elif X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if one == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> if one > 1 : <NEWLINE> <INDENT> a = X10 % ( one - 1 ) <NEWLINE> b = X10 % ( one + 1 ) <NEWLINE> c = one - 1 <NEWLINE> d = one + 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> Y = ( a - pow ( 2 , N - i - 1 , c ) ) % c <NEWLINE> print ( f ( Y ) + 1 ) <NEWLINE> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> Y = ( b + pow ( 2 , N - i - 1 , d ) ) % d <NEWLINE> print ( f ( Y ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = 0 <NEWLINE> r = N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if L > l : <NEWLINE> <INDENT> l = L <NEWLINE> <NL> <DEDENT> if R < r : <NEWLINE> <INDENT> r = R <NEWLINE> <NL> <DEDENT> ans = r - l + 1 <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = [ [ ] for _ in range ( n ) ] <NEWLINE> dp = [ 0 ] * n <NEWLINE> from collections import deque <NEWLINE> que = deque ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> m [ a ] . append ( b ) <NEWLINE> m [ b ] . append ( a ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> que . append ( b ) <NEWLINE> dp [ b ] = 1 <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> que . append ( a ) <NEWLINE> dp [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while que : <NEWLINE> <INDENT> c = que . popleft ( ) <NEWLINE> for i in m [ c ] : <NEWLINE> <INDENT> if dp [ i ] == 0 : <NEWLINE> <INDENT> dp [ i ] = c + 1 <NEWLINE> que . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> [ print ( dp [ i ] ) for i in range ( 1 , n ) ] <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while A [ i + cnt ] == A [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i + cnt == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i += cnt <NEWLINE> if i == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> s = list ( s ) <NEWLINE> cnts = 0 <NEWLINE> cnti = 0 <NEWLINE> space = 0 <NEWLINE> iwa = 0 <NEWLINE> temp = 0 <NEWLINE> next = 0 <NEWLINE> if c < d : <NEWLINE> <INDENT> for i in range ( a - 1 , d ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnts = cnts + 1 <NEWLINE> space = max ( space , cnts ) <NEWLINE> cnti = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnti = cnti + 1 <NEWLINE> iwa = max ( iwa , cnti ) <NEWLINE> cnts = 0 <NEWLINE> <DEDENT> <DEDENT> if iwa > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a - 1 , c ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if i <= b - 2 : <NEWLINE> <INDENT> cnts = 0 <NEWLINE> <DEDENT> cnts = cnts + 1 <NEWLINE> space = max ( space , cnts ) <NEWLINE> cnti = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnti = cnti + 1 <NEWLINE> iwa = max ( iwa , cnti ) <NEWLINE> cnts = 0 <NEWLINE> <DEDENT> if i == d - 1 : <NEWLINE> <INDENT> temp = space <NEWLINE> if s [ i - 1 ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> next = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if iwa > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif temp < 3 and next == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> M_NUM = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> for item in a : <NEWLINE> <INDENT> if ans > M_NUM : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans *= item <NEWLINE> <NL> <DEDENT> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans > M_NUM : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> ll = list ( combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for l in ll : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for data in abcd : <NEWLINE> <INDENT> if l [ data [ 1 ] - 1 ] - l [ data [ 0 ] - 1 ] == data [ 2 ] : <NEWLINE> <INDENT> tmp += data [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if tmp > ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> count [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in count : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( X > 0 ) : <NEWLINE> <INDENT> if ( X - K * D >= 0 ) : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = X // D <NEWLINE> X = X - D * ( l + 1 ) <NEWLINE> K = K - l - 1 <NEWLINE> if ( K % 2 == 0 ) : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X + D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif ( X < 0 ) : <NEWLINE> <INDENT> if ( ( X + K * D ) <= 0 ) : <NEWLINE> <INDENT> print ( abs ( X + K * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = - X // D <NEWLINE> X = X + D * ( l + 1 ) <NEWLINE> K = K - l - 1 <NEWLINE> if ( K % 2 == 0 ) : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( K % 2 == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( D ) ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( 0 , q ) ] <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> anum = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x , y = b [ i ] [ 0 ] , b [ i ] [ 1 ] <NEWLINE> ans += anum [ x ] * ( y - x ) <NEWLINE> anum [ y ] += anum [ x ] <NEWLINE> anum [ x ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> L = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for A in a : <NEWLINE> <INDENT> L [ A ] += 1 <NEWLINE> s += A <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> s += L [ b [ i ] ] * ( c [ i ] - b [ i ] ) <NEWLINE> L [ c [ i ] ] += L [ b [ i ] ] <NEWLINE> L [ b [ i ] ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def counting_sort ( MAX ) : <NEWLINE> <INDENT> C = [ 0 for _ in range ( MAX + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> C [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> C [ A [ i ] ] -= 1 <NEWLINE> B [ C [ A [ i ] ] ] = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX = 0 <NEWLINE> for n in A : <NEWLINE> <INDENT> if MAX < n : <NEWLINE> <INDENT> MAX = n <NEWLINE> <NL> <DEDENT> <DEDENT> B = [ 0 for _ in range ( N ) ] <NEWLINE> counting_sort ( MAX ) <NEWLINE> print ( <STRING> . join ( map ( str , B ) ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> def nb ( b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif b > 0 : <NEWLINE> <INDENT> return - b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - b + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> b = 0 <NEWLINE> <NL> def fac ( x ) : <NEWLINE> <INDENT> if x >= 0 : <NEWLINE> <INDENT> return x ** 0.2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - ( - x ) ** 0.2 <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a_est = int ( fac ( b ** 5 + X ) ) <NEWLINE> if a_est ** 5 - b ** 5 == X : <NEWLINE> <INDENT> a = a_est <NEWLINE> break <NEWLINE> <DEDENT> elif ( a_est + 1 ) ** 5 - b == X : <NEWLINE> <INDENT> a = a_est + 1 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> b = nb ( b ) <NEWLINE> <NL> <DEDENT> print ( a , b ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cd = collections . Counter ( d ) <NEWLINE> ct = collections . Counter ( t ) <NEWLINE> <NL> flg = True <NEWLINE> for k in ct . items ( ) : <NEWLINE> <INDENT> if k [ 1 ] > cd [ k [ 0 ] ] : <NEWLINE> <INDENT> flg = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if flg else <STRING> ) <NEWLINE>
F = { } <NEWLINE> <NL> def fib ( n ) : <NEWLINE> <INDENT> global F <NEWLINE> if n < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> F [ n ] = 1 <NEWLINE> return F [ n ] <NEWLINE> <COMMENT> <NL> <DEDENT> F [ n ] = F [ n - 1 ] + F [ n - 2 ] <NEWLINE> return F [ n ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> result = fib ( i ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> lines = sys . stdin . readlines ( ) <NEWLINE> N = int ( lines [ 0 ] ) <NEWLINE> X = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Si = str ( lines [ i + 1 ] . split ( <STRING> ) [ 0 ] ) <NEWLINE> X . append ( Si ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> <NL> z = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if X [ i ] != X [ i + 1 ] : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> a = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> op = input ( ) . strip ( ) <NEWLINE> if op == <STRING> : break <NEWLINE> b = int ( input ( ) ) <NEWLINE> if op == <STRING> : a += b <NEWLINE> elif op == <STRING> : a -= b <NEWLINE> elif op == <STRING> : a *= b <NEWLINE> else : a //= b <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
x , k , d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x = - x <NEWLINE> <DEDENT> l = min ( k , x // d ) <NEWLINE> k -= l <NEWLINE> x -= l * d <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - x ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 1 <NEWLINE> path = [ 1 ] <NEWLINE> <NL> for i in range ( N + 2 ) : <NEWLINE> <INDENT> now = A [ now ] <NEWLINE> path . append ( now ) <NEWLINE> <NL> <DEDENT> if i >= K : <NEWLINE> <INDENT> print ( path [ K ] ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> now = path . pop ( ) <NEWLINE> lo_start = i - 1 <NEWLINE> while path [ lo_start ] != now : <NEWLINE> <INDENT> lo_start -= 1 <NEWLINE> <NL> <DEDENT> loop = path [ lo_start : ] <NEWLINE> <NL> ans = loop [ ( K - path . index ( now ) ) % len ( loop ) ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> cnt = X . count ( <STRING> ) <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> for x in X [ : - 1 ] : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if X [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> M = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> M <<= 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> M += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> n %= bin ( n ) . count ( <STRING> ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> p = M % ( cnt + 1 ) <NEWLINE> m = M % ( cnt - 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( solve ( ( p + pow ( 2 , N - i - 1 , cnt + 1 ) ) % ( cnt + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( solve ( ( m - pow ( 2 , N - i - 1 , cnt - 1 ) ) % ( cnt - 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> yuka = lambda a , b : ( a - ( a % b ) ) // b <NEWLINE> <NL> x = min ( n , b - 1 ) <NEWLINE> score = yuka ( a * ( x % b ) , b ) <NEWLINE> ans = score <NEWLINE> <NL> print ( ans ) <NEWLINE>
S , Q = input ( ) , int ( input ( ) ) <NEWLINE> l , r = <STRING> , <STRING> <NEWLINE> reverse = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> T = input ( ) . split ( ) <NEWLINE> if T [ 0 ] == <STRING> : reverse = 0 if reverse else 1 <NEWLINE> else : <NEWLINE> <INDENT> if T [ 1 ] == <STRING> : <NEWLINE> <INDENT> if reverse : r = r + T [ 2 ] <NEWLINE> else : l = T [ 2 ] + l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if reverse : l = T [ 2 ] + l <NEWLINE> else : r = r + T [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if reverse : <NEWLINE> <INDENT> s = list ( l + S + r ) ; s . reverse ( ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l + S + r ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if d <= a : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> elif d <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( d - ( a + b ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( c [ 7 : ] ) <NEWLINE> <DEDENT> elif c [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( c [ 7 : ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif c [ 6 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * q ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( p [ : k ] ) <NEWLINE> q = [ ans ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> ans = ans + p [ i ] - p [ i - k ] <NEWLINE> q . append ( ans ) <NEWLINE> <DEDENT> print ( ( max ( q ) + k ) / 2 ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> c = math . ceil ( ( B - A ) / ( A - 1 ) ) <NEWLINE> print ( c + 1 ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cross = abs ( - ( - X // D ) ) <NEWLINE> <NL> if cross >= K : <NEWLINE> <INDENT> if X >= 0 : <NEWLINE> <INDENT> X -= D * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += D * K <NEWLINE> <DEDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X >= 0 : <NEWLINE> <INDENT> X -= D * cross <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += D * cross <NEWLINE> <NL> <DEDENT> if ( K - cross ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X >= 0 : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X + D ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , ID = None , parent = - 1 , left = - 1 , right = - 1 ) : <NEWLINE> <INDENT> self . id = ID <NEWLINE> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> <DEDENT> def preParse ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> + str ( u ) , end = <STRING> ) <NEWLINE> preParse ( T [ u ] . left ) <NEWLINE> preParse ( T [ u ] . right ) <NEWLINE> <NL> <DEDENT> def inParse ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inParse ( T [ u ] . left ) <NEWLINE> print ( <STRING> + str ( u ) , end = <STRING> ) <NEWLINE> inParse ( T [ u ] . right ) <NEWLINE> <NL> <DEDENT> def postParse ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> postParse ( T [ u ] . left ) <NEWLINE> postParse ( T [ u ] . right ) <NEWLINE> print ( <STRING> + str ( u ) , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> T = [ Node ( ) for i in range ( n ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ID , left , right = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> T [ ID ] . id = ID <NEWLINE> T [ ID ] . left = left <NEWLINE> T [ ID ] . right = right <NEWLINE> if left != - 1 : <NEWLINE> <INDENT> T [ left ] . parent = ID <NEWLINE> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> T [ right ] . parent = ID <NEWLINE> <NL> <DEDENT> <DEDENT> for node in T : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> r = node . id <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> preParse ( r ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> inParse ( r ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> postParse ( r ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> la . append ( N + 1 ) <NEWLINE> <NL> lb = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> lb [ la [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( lb [ j ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n <= 1000 : <NEWLINE> <INDENT> print ( 1000 - n ) <NEWLINE> <DEDENT> elif 1000 < n <= 2000 : <NEWLINE> <INDENT> print ( 2000 - n ) <NEWLINE> <DEDENT> elif 2000 < n <= 3000 : <NEWLINE> <INDENT> print ( 3000 - n ) <NEWLINE> <DEDENT> elif 3000 < n <= 4000 : <NEWLINE> <INDENT> print ( 4000 - n ) <NEWLINE> <DEDENT> elif 4000 < n <= 5000 : <NEWLINE> <INDENT> print ( 5000 - n ) <NEWLINE> <DEDENT> elif 5000 < n <= 6000 : <NEWLINE> <INDENT> print ( 6000 - n ) <NEWLINE> <DEDENT> elif 6000 < n <= 7000 : <NEWLINE> <INDENT> print ( 7000 - n ) <NEWLINE> <DEDENT> elif 7000 < n <= 8000 : <NEWLINE> <INDENT> print ( 8000 - n ) <NEWLINE> <DEDENT> elif 8000 < n <= 9000 : <NEWLINE> <INDENT> print ( 9000 - n ) <NEWLINE> <DEDENT> elif 9000 < n <= 10000 : <NEWLINE> <INDENT> print ( 10000 - n ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 ; <NEWLINE> for i in s : <NEWLINE> <INDENT> ans += int ( i ) <NEWLINE> <DEDENT> if ( ans % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( 0 if n == 0 else len ( str ( bin ( n ) ) [ 2 : ] ) ) <NEWLINE>
L , R = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> diff = R - L <NEWLINE> if diff >= 2019 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( [ i * j % 2019 for j in range ( L + 1 , R + 1 ) for i in range ( L , R ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> reversed_cumsum = [ ] <NEWLINE> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += A [ N - 1 - i ] <NEWLINE> reversed_cumsum . append ( tmp ) <NEWLINE> <DEDENT> cumsum = reversed_cumsum [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] * cumsum [ i + 1 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * math . pi , ( r + r ) * math . pi ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> l1 = sorted ( a ) [ - 1 ] <NEWLINE> l2 = sorted ( a ) [ - 2 ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == l1 : <NEWLINE> <INDENT> print ( l2 ) <NEWLINE> <DEDENT> if i != l1 : <NEWLINE> <INDENT> print ( l1 ) <NEWLINE> <DEDENT> <DEDENT>
nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if nums [ 0 ] < nums [ 1 ] < nums [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count_r = s . count ( <STRING> ) <NEWLINE> count_g = s . count ( <STRING> ) <NEWLINE> count_b = s . count ( <STRING> ) <NEWLINE> sum = count_r * count_g * count_b <NEWLINE> minus = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( 2 , n - i + 1 , 2 ) : <NEWLINE> <INDENT> if i + j <= n - 1 : <NEWLINE> <INDENT> tem = [ s [ i ] , s [ i + j // 2 ] , s [ i + j ] ] <NEWLINE> if tem [ 0 ] != tem [ 1 ] and tem [ 0 ] != tem [ 2 ] and tem [ 1 ] != tem [ 2 ] : <NEWLINE> <INDENT> minus += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum - minus ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def merge ( array , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> L = array [ left : mid ] + [ sentinel ] <NEWLINE> R = array [ mid : right ] + [ sentinel ] <NEWLINE> i = j = 0 <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> array [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> cnt += len ( L ) - 1 - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( array , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( array , left , mid ) <NEWLINE> merge_sort ( array , mid , right ) <NEWLINE> merge ( array , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> sentinel = 10 ** 9 + 1 <NEWLINE> merge_sort ( numbers , 0 , len ( numbers ) ) <NEWLINE> print ( cnt ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = [ 0 ] * 100001 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sum ( A ) <NEWLINE> for j in A : <NEWLINE> <INDENT> D [ j ] += 1 <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> start = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a += D [ x ] * ( y - x ) <NEWLINE> print ( a ) <NEWLINE> D [ y ] += D [ x ] <NEWLINE> D [ x ] = 0 <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> <COMMENT> <NL> <NL> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> M = [ ] <NEWLINE> m = 0 <NEWLINE> <NL> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <NL> <INDENT> m = ( pow ( 10 , n - i , 2019 ) * int ( S [ i ] ) + m ) % 2019 <NEWLINE> M . append ( m ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> M . append ( 0 ) <COMMENT> <NEWLINE> <NL> c = Counter ( M ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> sum += i * ( i - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( sum ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> flag = 0 <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> flag = 2 <NEWLINE> print ( 0 ) <NEWLINE> <NL> <DEDENT> if flag != 2 : <NEWLINE> <INDENT> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> <COMMENT> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> p = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i < n : <NEWLINE> <INDENT> p *= a [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if p <= 10 ** 18 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> NN = 10 ** 6 + 1 <NEWLINE> A = sorted ( A ) <NEWLINE> checks = np . array ( [ True ] * NN ) <NEWLINE> ret = 0 <NEWLINE> for i , a in enumerate ( A [ : - 1 ] ) : <NEWLINE> <INDENT> if checks [ a ] and a != A [ i + 1 ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> if checks [ a ] : <NEWLINE> <INDENT> checks [ a : NN + 1 : a ] = False <NEWLINE> <DEDENT> <DEDENT> if checks [ A [ - 1 ] ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def calc ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> lim = 130 <NEWLINE> <NL> result = np . zeros ( n + 1 , dtype = int ) <NEWLINE> for x in range ( 1 , lim ) : <NEWLINE> <INDENT> for y in range ( 1 , lim ) : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for z in range ( 1 , lim ) : <NEWLINE> <INDENT> if y > z : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> index = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if index > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s = set ( [ x , y , z ] ) <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> result [ index ] += 1 <NEWLINE> <DEDENT> elif len ( s ) == 2 : <NEWLINE> <INDENT> result [ index ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ index ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return result [ 1 : ] <NEWLINE> <NL> <NL> <DEDENT> for i in calc ( int ( input ( ) ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> goods = set ( input ( ) for _ in range ( n ) ) <NEWLINE> print ( len ( goods ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> y = sorted ( x ) <NEWLINE> a , b = y [ n // 2 - 1 ] , y [ n // 2 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> if i > a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <NL> <DEDENT> elif A < K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> cs = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> from collections import defaultdict <NEWLINE> prev = - 1 <NEWLINE> c_comp = [ ] <NEWLINE> <COMMENT> <NL> for c in cs : <NEWLINE> <INDENT> if prev != c : <NEWLINE> <INDENT> c_comp . append ( c ) <NEWLINE> <DEDENT> prev = c <NEWLINE> <NL> <DEDENT> d = defaultdict ( list ) <NEWLINE> for i , c in enumerate ( c_comp ) : <NEWLINE> <INDENT> d [ c ] . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> dp = [ 0 ] * 220000 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> inds = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i , c in enumerate ( c_comp ) : <NEWLINE> <INDENT> i_prev = d [ c ] [ inds [ c ] - 1 ] <NEWLINE> if inds [ c ] >= 1 : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 ] += dp [ i ] + dp [ i_prev + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> dp [ i + 1 ] %= mod <NEWLINE> inds [ c ] += 1 <NEWLINE> <DEDENT> print ( dp [ len ( c_comp ) ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( maze , visited , sy , sx , gy , gx ) : <NEWLINE> <INDENT> queue = deque ( [ [ sy , sx ] ] ) <NEWLINE> visited [ sy ] [ sx ] = 0 <NEWLINE> while queue : <NEWLINE> <COMMENT> <NL> <INDENT> y , x = queue . popleft ( ) <COMMENT> <NEWLINE> if [ y , x ] == [ gy , gx ] : <COMMENT> <NEWLINE> <INDENT> return visited [ y ] [ x ] <NEWLINE> <DEDENT> for j , k in ( [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ) : <NEWLINE> <INDENT> l = 1 <NEWLINE> while True : <NEWLINE> <INDENT> new_y , new_x = y + j * l , x + k * l <NEWLINE> if ( 0 <= new_y < H ) and ( 0 <= new_x < W ) : <NEWLINE> <INDENT> if maze [ new_y ] [ new_x ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif visited [ new_y ] [ new_x ] == - 1 : <COMMENT> <NEWLINE> <INDENT> visited [ new_y ] [ new_x ] = visited [ y ] [ x ] + 1 <NEWLINE> queue . append ( [ new_y , new_x ] ) <COMMENT> <NEWLINE> <DEDENT> elif visited [ new_y ] [ new_x ] < visited [ y ] [ x ] + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l += 1 <NEWLINE> if l == K + 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = x1 - 1 , y1 - 1 , x2 - 1 , y2 - 1 <NEWLINE> C = [ 0 ] * H <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> C [ i ] = str ( input ( ) ) <NEWLINE> <DEDENT> visited = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> bfs ( C , visited , x1 , y1 , x2 , y2 ) <NEWLINE> <COMMENT> <NL> print ( visited [ x2 ] [ y2 ] ) <NEWLINE>
<COMMENT> <NL> <NL> iim = lambda : map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , S = iim ( ) <NEWLINE> A = list ( iim ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> S1 = S + 1 <NEWLINE> <NL> dp = [ 0 ] * ( S + 1 ) <NEWLINE> <NL> dp [ 0 ] = pow ( 2 , N , mod ) <NEWLINE> inv = pow ( 2 , mod - 2 , mod ) <NEWLINE> <NL> for ai in A : <NEWLINE> <INDENT> for i in range ( S , ai - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i ] + dp [ i - ai ] * inv ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> c = 0 <NEWLINE> s = sum ( A ) <NEWLINE> table = [ 0 ] * 100010 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in A : <NEWLINE> <INDENT> table [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> c = table [ B ] <NEWLINE> s += ( C - B ) * c <NEWLINE> table [ C ] += table [ B ] <NEWLINE> table [ B ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> S . append ( s ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> for s in S : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> p = 0 <NEWLINE> <NL> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> d = gcd ( a , b ) <NEWLINE> e = gcd ( d , c ) <NEWLINE> return ( e ) <NEWLINE> <NL> <DEDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> j = gcd3 ( a , b , c ) <NEWLINE> i = i + j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K + 1 ) : <NEWLINE> <INDENT> o = gcd ( a , b ) <NEWLINE> p = p + o <NEWLINE> <NL> <DEDENT> <DEDENT> d = int ( ( 1 + K ) * K / 2 ) <NEWLINE> <NL> print ( 6 * i + d + 6 * p ) <NEWLINE>
<NL> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> f = 1 <NEWLINE> if ( 0 in l ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> f = 0 <NEWLINE> <DEDENT> if ( f == 1 ) : <NEWLINE> <NL> <INDENT> for x in l : <NEWLINE> <INDENT> res = res * x <NEWLINE> if ( res > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> f = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( f == 1 ) : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = sorted ( input ( ) for _ in range ( N ) ) <NEWLINE> <NL> print ( <STRING> . join ( S ) ) <NEWLINE>
import sys <NEWLINE> <NL> ary = [ ] <NEWLINE> ans = [ ] <NEWLINE> def solve ( a , b , c , d , e , f ) : <NEWLINE> <INDENT> if c * e - b * f == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> <DEDENT> if c * d - a * f == 0 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = ( c * d - a * f ) / ( b * d - a * e ) <NEWLINE> <DEDENT> return [ x , y ] <NEWLINE> <NL> <DEDENT> for i in sys . stdin : <NEWLINE> <INDENT> ary . append ( list ( map ( int , i . split ( ) ) ) ) <NEWLINE> ans . append ( solve ( * ary [ - 1 ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( round ( ans [ i ] [ 0 ] , 3 ) , round ( ans [ i ] [ 1 ] , 3 ) ) ) <NEWLINE> <DEDENT>
def my_code ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> <COMMENT> <NL> for i in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> a [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * a , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> my_code ( ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if A . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <NL> <INDENT> ans = ans * i <NEWLINE> if ans > int ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > int ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a ] . append ( [ b , i ] ) <NEWLINE> tree [ b ] . append ( [ a , i ] ) <NEWLINE> <DEDENT> queue = deque ( [ [ 1 , 0 ] ] ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> ans [ 1 ] = 1 <NEWLINE> visited = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> v , c = queue . popleft ( ) <NEWLINE> color = 1 <NEWLINE> for nv , i in tree [ v ] : <NEWLINE> <INDENT> if c == color : <NEWLINE> <INDENT> color += 1 <NEWLINE> <DEDENT> if visited [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ i ] = 1 <NEWLINE> queue . append ( [ nv , color ] ) <NEWLINE> ans [ i ] = color <NEWLINE> color += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> sp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> import copy <NEWLINE> result = [ ] <NEWLINE> def test ( i , i_sum , cost ) : <NEWLINE> <NL> <INDENT> flag = 0 <NEWLINE> if i <= n : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if i_sum [ j ] < x : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> test ( copy . deepcopy ( i ) + 1 , i_sum [ : ] , cost [ : ] ) <COMMENT> <NEWLINE> <NL> for j in range ( 1 , m + 1 ) : <COMMENT> <NEWLINE> <INDENT> i_sum [ j - 1 ] += sp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> cost [ 0 ] += sp [ i - 1 ] [ 0 ] <NEWLINE> test ( copy . deepcopy ( i ) + 1 , i_sum [ : ] , cost [ : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( cost [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> test ( 0 , [ 0 ] * m , [ 0 ] ) <NEWLINE> <NL> if result != [ ] : <NEWLINE> <INDENT> print ( min ( result ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> M = 1000005 <NEWLINE> cnt = [ 0 ] * M <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if cnt [ a [ i ] ] != 0 : <NEWLINE> <INDENT> cnt [ a [ i ] ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( a [ i ] , M , a [ i ] ) : <NEWLINE> <INDENT> cnt [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if cnt [ a [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> v = [ 0 ] * n <NEWLINE> v [ 0 ] = 1 <NEWLINE> f = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> d = deque ( ) <NEWLINE> d . append ( 0 ) <NEWLINE> <NL> while d : <NEWLINE> <INDENT> room = d . popleft ( ) <NEWLINE> for i in g [ room ] : <NEWLINE> <INDENT> if v [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> d . append ( i ) <NEWLINE> v [ i ] = 1 <NEWLINE> f [ i ] = room <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( f [ i ] + 1 ) <NEWLINE> <DEDENT>
n = input ( <STRING> ) <NEWLINE> <NL> s = 0 <NEWLINE> for c in n : <NEWLINE> <INDENT> s += int ( c ) <NEWLINE> <NL> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> s = [ h [ N - 1 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> s . append ( s [ - 1 ] + h [ - i - 1 ] ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += h [ i ] * s [ - i - 2 ] <NEWLINE> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
X , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for d in range ( X + 1 ) : <NEWLINE> <INDENT> for f in [ - 1 , 1 ] : <NEWLINE> <INDENT> a = X + d * f <NEWLINE> if p . count ( a ) == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 5 <NEWLINE> cnt = [ 0 ] * ( INF + 1 ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> BC = [ ] <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> BC . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <NL> <DEDENT> total = sum ( A ) <NEWLINE> <NL> for b , c in BC : <NEWLINE> <INDENT> total += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * ( 10 ** 5 + 5 ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> total = sum ( A ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> s [ i ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> d = s [ B ] <NEWLINE> s [ B ] = 0 <NEWLINE> s [ C ] += d <NEWLINE> total += ( C - B ) * d <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> d = c . most_common ( ) <NEWLINE> len_A = len ( set ( A ) ) <NEWLINE> if ( len_A <= K ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len_A - K ) : <NEWLINE> <INDENT> ans += d [ - 1 * ( i + 1 ) ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> num . append ( ( i + 1 ) - a [ i ] ) <NEWLINE> <NL> <DEDENT> ct = Counter ( num ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> scan = ( i + 1 ) + a [ i ] <NEWLINE> if ( ct [ scan ] != 0 ) : <NEWLINE> <INDENT> ans += ct [ scan ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main3 ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> A = np . array ( [ int ( i ) for i in A ] ) . astype ( np . uint64 ) <NEWLINE> l = [ ] <NEWLINE> A = np . sort ( A ) <NEWLINE> A = np . flip ( A ) . astype ( np . uint64 ) <NEWLINE> sum = 0 <NEWLINE> for i , num in enumerate ( A ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> l . append ( num ) <NEWLINE> continue <NEWLINE> <DEDENT> l1 = np . array ( l , dtype = np . uint64 ) <NEWLINE> l2 = np . roll ( l1 , 1 ) <NEWLINE> l1 = l1 . reshape ( - 1 , 1 ) <NEWLINE> l2 = l2 . reshape ( - 1 , 1 ) <NEWLINE> l1 = np . concatenate ( [ l1 , l2 ] , 1 ) <NEWLINE> l2 = l1 . min ( 1 ) <NEWLINE> arg = l2 . argmax ( ) <NEWLINE> l = l [ : arg + 1 ] + [ num ] + l [ arg + 1 : ] <NEWLINE> sum += l2 [ arg ] <NEWLINE> <NL> <DEDENT> print ( int ( sum ) ) <NEWLINE> <NL> <NL> <DEDENT> def correct ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> A = np . array ( [ int ( i ) for i in A ] ) . astype ( np . uint64 ) <NEWLINE> l = [ ] <NEWLINE> A = np . sort ( A ) . astype ( np . uint64 ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum += A [ N - ( i + 1 ) // 2 - 1 ] <NEWLINE> <DEDENT> print ( int ( sum ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> correct ( ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> cur = 0 <NEWLINE> count = [ 0 ] * 2020 <NEWLINE> count [ 0 ] = 1 <NEWLINE> for i , c in enumerate ( map ( int , S [ : : - 1 ] ) ) : <NEWLINE> <INDENT> cur = ( cur + c * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> count [ cur ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( c * ( c - 1 ) // 2 for c in count ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> suzi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in suzi : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for kazu in suzi : <NEWLINE> <INDENT> ans *= kazu <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
m = 24 * 60 * 60 <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> dp = [ 0 ] * ( m + 1 ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , d = input ( ) . split ( ) <NEWLINE> a , b , c = map ( int , a . split ( <STRING> ) ) ; <NEWLINE> d , e , f = map ( int , d . split ( <STRING> ) ) ; <NEWLINE> dp [ a * 3600 + b * 60 + c ] += 1 <NEWLINE> dp [ d * 3600 + e * 60 + f ] -= 1 <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> dp [ i + 1 ] += dp [ i ] <NEWLINE> <DEDENT> print ( max ( dp ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def RoT ( A , B , ans ) : <NEWLINE> <INDENT> if A : <NEWLINE> <INDENT> root = A [ 0 ] <NEWLINE> rindex = B . index ( root ) <NEWLINE> Aleft = A [ 1 : rindex + 1 ] <NEWLINE> Aright = A [ rindex + 1 : ] <NEWLINE> Bleft = B [ : rindex ] <NEWLINE> Bright = B [ rindex + 1 : ] <NEWLINE> RoT ( Aleft , Bleft , ans ) <NEWLINE> RoT ( Aright , Bright , ans ) <NEWLINE> ans . append ( root ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> B = input ( ) . split ( <STRING> ) <NEWLINE> ans = [ ] <NEWLINE> RoT ( A , B , ans ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , 1000000007 ) ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = False <NEWLINE> <NL> for x in range ( N + 1 ) : <NEWLINE> <INDENT> if flag == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( N - x + 1 ) : <NEWLINE> <INDENT> if 10000 * x + 5000 * y + 1000 * ( N - x - y ) == Y : <NEWLINE> <INDENT> print ( x , y , N - x - y ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> aaa = set ( [ ] ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> aaa . add ( n ) <NEWLINE> <DEDENT> print ( len ( aaa ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x , y , z = 0 , 0 , 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> elif i == 3 : <NEWLINE> <INDENT> z += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dp = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1 , dtype = np . float64 ) <NEWLINE> <NL> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def calc ( h , i , j , N , dp ) : <NEWLINE> <INDENT> if h + i + j == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ h ] [ i ] [ j ] >= 0 : <NEWLINE> <INDENT> return dp [ h ] [ i ] [ j ] <NEWLINE> <DEDENT> A = 1 <NEWLINE> if h >= 1 : <NEWLINE> <INDENT> A += calc ( h - 1 , i , j , N , dp ) * h / N <NEWLINE> <DEDENT> if i >= 1 : <NEWLINE> <INDENT> A += calc ( h + 1 , i - 1 , j , N , dp ) * i / N <NEWLINE> <DEDENT> if j >= 1 : <NEWLINE> <INDENT> A += calc ( h , i + 1 , j - 1 , N , dp ) * j / N <NEWLINE> <DEDENT> A = A * N / ( h + i + j ) <NEWLINE> dp [ h ] [ i ] [ j ] = A <NEWLINE> return A <NEWLINE> <NL> <DEDENT> a = calc ( x , y , z , N , dp ) <NEWLINE> <NL> print ( dp [ x ] [ y ] [ z ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr ) <NEWLINE> ans = 1 <NEWLINE> for val in arr : <NEWLINE> <INDENT> ans *= val <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x * 2 == W and y * 2 == H : <NEWLINE> <INDENT> print ( W * H / 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H / 2 , 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> boss = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for id in a : <NEWLINE> <INDENT> boss [ id - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for cnt in boss : <NEWLINE> <INDENT> ans = cnt <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> X_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( X_lst ) == 1 : <NEWLINE> <INDENT> print ( abs ( X_lst [ 0 ] - X ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> u = 0 <NEWLINE> if X_lst [ 0 ] == X : <NEWLINE> <INDENT> u = float ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i , x in enumerate ( X_lst [ 1 : ] , start = 1 ) : <NEWLINE> <INDENT> if x == X : <NEWLINE> <INDENT> u = float ( <STRING> ) <NEWLINE> <NL> <DEDENT> if X_lst [ i - 1 ] < X < x : <NEWLINE> <INDENT> u = [ X - X_lst [ - 1 ] , x - X ] <NEWLINE> <NL> <DEDENT> if i == 1 : <NEWLINE> <INDENT> g = X_lst [ 1 ] - X_lst [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( g , x - X_lst [ i - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if u == 0 : <NEWLINE> <INDENT> u = [ X - X_lst [ - 1 ] ] <NEWLINE> <DEDENT> elif u != float ( <STRING> ) : <NEWLINE> <INDENT> g = max ( math . gcd ( g , u [ 0 ] ) , math . gcd ( g , u [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = sum ( a ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_a -= a [ i ] <NEWLINE> ans += a [ i ] * sum_a <NEWLINE> <NL> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> from math import sin , cos <NEWLINE> import math <NEWLINE> <NL> alphabet = <STRING> <NEWLINE> <NL> <NL> def rotate_char ( c , num ) : <NEWLINE> <INDENT> if c == <STRING> or c == <STRING> or c == <STRING> : <NEWLINE> <INDENT> return c <NEWLINE> <NL> <DEDENT> n = ord ( c ) + num <NEWLINE> if n > 122 : <NEWLINE> <INDENT> n -= 26 <NEWLINE> <DEDENT> return chr ( n ) <NEWLINE> <NL> <DEDENT> def rotate_string ( s , num ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> new_c = rotate_char ( c , num ) <NEWLINE> ret . append ( new_c ) <NEWLINE> <DEDENT> return <STRING> . join ( ret ) <NEWLINE> <NL> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> rotated = rotate_string ( s , i ) <NEWLINE> if <STRING> in rotated or <STRING> in rotated or <STRING> in rotated : <NEWLINE> <INDENT> print ( rotated , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a - k + b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> sum1 = 0 <NEWLINE> mod = 1000000000 + 7 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= mod : <NEWLINE> <INDENT> a [ i ] = a [ i ] % mod <NEWLINE> <DEDENT> sum1 += a [ i ] <NEWLINE> sum1 %= mod <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> sum1 -= a [ i ] <NEWLINE> <COMMENT> <NL> if sum1 < 0 : <NEWLINE> <INDENT> sum1 += mod <NEWLINE> <DEDENT> sum += a [ i ] * sum1 <NEWLINE> sum %= mod <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> ans = [ ] <NEWLINE> if A + B + C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = { <STRING> : A , <STRING> : B , <STRING> : C } <NEWLINE> for n , i in enumerate ( S ) : <NEWLINE> <INDENT> l , r = list ( i ) <NEWLINE> L , R = d [ l ] , d [ r ] <NEWLINE> if L == R == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif L == 0 : <NEWLINE> <INDENT> ans . append ( l ) <NEWLINE> d [ l ] += 1 <NEWLINE> d [ r ] -= 1 <NEWLINE> <DEDENT> elif R == 0 : <NEWLINE> <INDENT> d [ l ] -= 1 <NEWLINE> d [ r ] += 1 <NEWLINE> ans . append ( r ) <NEWLINE> <DEDENT> elif L == R == 1 and n != N - 1 and i != S [ n + 1 ] : <NEWLINE> <INDENT> if l in S [ n + 1 ] : <NEWLINE> <INDENT> d [ l ] += 1 <NEWLINE> d [ r ] -= 1 <NEWLINE> ans . append ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ l ] -= 1 <NEWLINE> d [ r ] += 1 <NEWLINE> ans . append ( r ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if L >= R : <NEWLINE> <INDENT> d [ l ] -= 1 <NEWLINE> d [ r ] += 1 <NEWLINE> ans . append ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ l ] += 1 <NEWLINE> d [ r ] -= 1 <NEWLINE> ans . append ( l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> good = [ 1 for i in range ( N ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> if height [ a ] <= height [ b ] : <NEWLINE> <INDENT> good [ a ] = 0 <NEWLINE> <NL> <DEDENT> if height [ a ] >= height [ b ] : <NEWLINE> <INDENT> good [ b ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( sum ( good ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> if 4 * h * n - N * n - N * h > 0 : <NEWLINE> <INDENT> if ( N * h * n ) % ( 4 * h * n - N * n - N * h ) == 0 : <NEWLINE> <INDENT> print ( h , n , ( N * h * n ) // ( 4 * h * n - N * n - N * h ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def run ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> print ( <STRING> if x % 9 == 0 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> run ( x ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> check = <STRING> <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans += check [ n % 26 ] <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sorted ( X ) <NEWLINE> l = x [ n // 2 - 1 ] <NEWLINE> r = x [ n // 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] <= l : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> l = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> x = l [ i ] + l [ i + 1 ] + l [ i - 1 ] <NEWLINE> ans = max ( ans , x ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ n - ( i // 2 ) - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> <NL> def main2 ( ) : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A + K - 1 >= B - K + 1 : <NEWLINE> <INDENT> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A , A + K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( B - K + 1 , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> numbers = np . arange ( a , b + 1 ) <NEWLINE> A = set ( numbers [ : k ] ) <NEWLINE> B = set ( numbers [ - k : ] ) <NEWLINE> answers = A | B <NEWLINE> <NL> for i in sorted ( answers ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> A_list = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A_list : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1e+18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = defaultdict ( int ) <NEWLINE> sm = 0 <NEWLINE> for e in a : <NEWLINE> <INDENT> sm += e <NEWLINE> num [ e ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = sm + ( c - b ) * num [ b ] <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> sm = ans <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> def solve ( N , ABs ) : <NEWLINE> <INDENT> groups = { } <NEWLINE> zero_count = 0 <NEWLINE> for a , b in ABs : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero_count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> k = ( 0 , 1 ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> k = ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> if a * b < 0 : <NEWLINE> <INDENT> k = ( abs ( a ) , - abs ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( abs ( a ) , abs ( b ) ) <NEWLINE> <DEDENT> <DEDENT> groups . setdefault ( k , 0 ) <NEWLINE> groups [ k ] += 1 <NEWLINE> <NL> <DEDENT> visited = set ( ) <NEWLINE> possibles = [ ] <NEWLINE> for k , v in groups . items ( ) : <NEWLINE> <INDENT> if k in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> p = 0 <NEWLINE> p += pow ( 2 , v , MOD ) <NEWLINE> if k [ 1 ] == 0 : <NEWLINE> <INDENT> m = ( 0 , 1 ) <NEWLINE> <DEDENT> elif k [ 0 ] == 0 : <NEWLINE> <INDENT> m = ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k [ 1 ] < 0 : <NEWLINE> <INDENT> m = ( - k [ 1 ] , k [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = ( k [ 1 ] , - k [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if m in groups . keys ( ) and m not in visited : <NEWLINE> <INDENT> p += pow ( 2 , groups [ m ] , MOD ) <NEWLINE> visited . add ( m ) <NEWLINE> p -= 1 <NEWLINE> <DEDENT> visited . add ( k ) <NEWLINE> possibles . append ( p % MOD ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for p in possibles : <NEWLINE> <INDENT> ans *= p <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> if zero_count : <NEWLINE> <INDENT> ans += zero_count <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> return ( ans - 1 ) % MOD <NEWLINE> <NL> <NL> <DEDENT> def slow_solve ( N , ABs ) : <NEWLINE> <INDENT> import itertools <NEWLINE> ans = 0 <NEWLINE> for k in range ( 1 , 2 ** N ) : <NEWLINE> <INDENT> b = ( <STRING> + str ( N ) + <STRING> ) . format ( k ) <NEWLINE> taken = [ ] <NEWLINE> for i , c in enumerate ( b ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> taken . append ( ABs [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( taken ) == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif all ( comb [ 0 ] [ 0 ] * comb [ 1 ] [ 0 ] + comb [ 0 ] [ 1 ] * comb [ 1 ] [ 1 ] != 0 <NEWLINE> <INDENT> for comb in itertools . combinations ( taken , 2 ) ) : <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans % MOD <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ABs = [ tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( N ) ] <NEWLINE> print ( solve ( N , ABs ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> vs = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> g = [ vs [ 0 ] , vs [ - 1 ] ] <NEWLINE> rest = K <NEWLINE> for k in [ K - 1 , K ] : <NEWLINE> <INDENT> for b in range ( K // 2 ) : <NEWLINE> <INDENT> t = k - b <NEWLINE> if t > N : <NEWLINE> <INDENT> t = N <NEWLINE> <DEDENT> for i in range ( t + 1 ) : <NEWLINE> <INDENT> v = [ ] <NEWLINE> if i < t : <NEWLINE> <INDENT> v . extend ( vs [ : i ] ) <NEWLINE> v . extend ( vs [ - ( t - i ) : ] ) <NEWLINE> for _ in range ( b ) : <NEWLINE> <INDENT> if min ( v ) < 0 : <NEWLINE> <INDENT> v . remove ( min ( v ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> v . extend ( vs [ : t ] ) <NEWLINE> for _ in range ( b ) : <NEWLINE> <INDENT> if min ( v ) < 0 : <NEWLINE> <INDENT> v . remove ( min ( v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> g . append ( sum ( v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if max ( g ) < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( g ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_ij = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd_ij , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> self . left , self . right = None , None <NEWLINE> <NL> <DEDENT> def insert ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if data < self . data : <NEWLINE> <INDENT> if not self . left : <NEWLINE> <INDENT> self . left = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . left . insert ( data ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not self . right : <NEWLINE> <INDENT> self . right = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . right . insert ( data ) <NEWLINE> <NL> <DEDENT> <DEDENT> return self . data <NEWLINE> <NL> <DEDENT> def find ( self , data , parent = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if data < self . data : <NEWLINE> <INDENT> if not self . left : <NEWLINE> <INDENT> return None , None <NEWLINE> <DEDENT> return self . left . find ( data = data , parent = self ) <NEWLINE> <DEDENT> elif data > self . data : <NEWLINE> <INDENT> if not self . right : <NEWLINE> <INDENT> return None , None <NEWLINE> <DEDENT> return self . right . find ( data = data , parent = self ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self , parent <NEWLINE> <NL> <DEDENT> <DEDENT> def children_count ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cnt = 0 <NEWLINE> if self . left : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def delete ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> node , parent = self . find ( data ) <NEWLINE> if node : <NEWLINE> <INDENT> children_count = node . children_count ( ) <NEWLINE> if children_count == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if parent . left is node : <NEWLINE> <INDENT> parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = None <NEWLINE> <DEDENT> del node <NEWLINE> <DEDENT> elif children_count == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if node . left : <NEWLINE> <INDENT> n = node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = node . right <NEWLINE> <DEDENT> if parent : <NEWLINE> <INDENT> if parent . left is node : <NEWLINE> <INDENT> parent . left = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = n <NEWLINE> <DEDENT> <DEDENT> del node <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> successor = node . right <NEWLINE> while successor . left : <NEWLINE> <INDENT> successor = successor . left <NEWLINE> <DEDENT> copy_data = successor . data <NEWLINE> self . delete ( copy_data ) <NEWLINE> node . data = copy_data <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def pre_order ( node ) : <NEWLINE> <INDENT> if node : <NEWLINE> <INDENT> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> pre_order ( node . left ) <NEWLINE> pre_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def in_order ( node ) : <NEWLINE> <INDENT> if node : <NEWLINE> <INDENT> in_order ( node . left ) <NEWLINE> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> in_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def action ( command , content ) : <NEWLINE> <COMMENT> <NL> <INDENT> if command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root . insert ( int ( content ) ) <NEWLINE> <NL> <DEDENT> elif command . startswith ( <STRING> ) : <NEWLINE> <INDENT> if tree_root . find ( int ( content ) ) == ( None , None ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root . delete ( int ( content ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> in_order ( tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> pre_order ( tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> command_list = list ( map ( lambda x : x . split ( ) , _input [ 1 : ] ) ) <NEWLINE> <COMMENT> <NL> <NL> flag , tree_root = False , None <NEWLINE> for each in command_list : <NEWLINE> <INDENT> command , content = each [ 0 ] , each [ - 1 ] <NEWLINE> if ( not flag ) and command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root = Node ( data = int ( content ) ) <NEWLINE> flag = True <NEWLINE> continue <NEWLINE> <DEDENT> action ( command , content ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Bs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> a . append ( a [ i ] + As [ i ] ) <COMMENT> <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> b . append ( b [ i ] + Bs [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <COMMENT> <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <COMMENT> <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <COMMENT> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def mcg ( a , b ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> while a % b != 0 : <NEWLINE> <INDENT> x = a % b <NEWLINE> a = b <NEWLINE> b = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> <DEDENT> num = sorted ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> print ( mcg ( num [ 0 ] , num [ 1 ] ) ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> P . sort ( ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range ( int ( K ) ) : <NEWLINE> <INDENT> total = total + P [ i ] <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> l = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l . append ( math . gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> ans += math . gcd ( j , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if not n : <NEWLINE> <INDENT> print ( x ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flgs = [ 1 ] * 102 <NEWLINE> <NL> for p in ps : <NEWLINE> <INDENT> flgs [ p ] = 0 <NEWLINE> <NL> <DEDENT> ansr = 101 <NEWLINE> ansl = 101 <NEWLINE> index = x <NEWLINE> while 1 : <NEWLINE> <INDENT> if flgs [ index ] == 1 : <NEWLINE> <INDENT> ansr = index <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> index = x <NEWLINE> while 1 : <NEWLINE> <INDENT> if flgs [ index ] == 1 : <NEWLINE> <INDENT> ansl = index <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if abs ( ansr - x ) >= abs ( ansl - x ) : <NEWLINE> <INDENT> print ( ansl ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ansr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> city = { } <NEWLINE> city_name = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S = input ( ) . split ( ) <NEWLINE> city [ n + 1 ] = S <NEWLINE> city_name . append ( S [ 0 ] ) <NEWLINE> <NL> <DEDENT> city_name = list ( set ( city_name ) ) <NEWLINE> city_name . sort ( ) <NEWLINE> <NL> for c_name in city_name : <NEWLINE> <INDENT> city_temp = { } <NEWLINE> for c_key in city . keys ( ) : <NEWLINE> <INDENT> if city [ c_key ] [ 0 ] == c_name : <NEWLINE> <INDENT> city_temp [ int ( city [ c_key ] [ 1 ] ) ] = c_key <NEWLINE> <NL> <DEDENT> <DEDENT> p_temp = list ( city_temp . keys ( ) ) <NEWLINE> p_temp . sort ( reverse = True ) <NEWLINE> for v in p_temp : <NEWLINE> <INDENT> print ( city_temp [ v ] ) <NEWLINE> <DEDENT> <DEDENT>
nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> a = nums [ 0 ] <NEWLINE> b = nums [ 1 ] <NEWLINE> c = nums [ 2 ] <NEWLINE> d = nums [ 3 ] <NEWLINE> max = a * c <NEWLINE> if a * d > max : <NEWLINE> <INDENT> max = a * d <NEWLINE> <DEDENT> if b * c > max : <NEWLINE> <INDENT> max = b * c <NEWLINE> <DEDENT> if b * d > max : <NEWLINE> <INDENT> max = b * d <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> D . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> S = min ( a ) + min ( b ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> P . append ( a [ D [ i ] [ 0 ] - 1 ] + b [ D [ i ] [ 1 ] - 1 ] - D [ i ] [ 2 ] ) <NEWLINE> <DEDENT> P . append ( S ) <NEWLINE> print ( min ( P ) ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque <NEWLINE> <NL> n , m = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> if a not in d : <NEWLINE> <INDENT> d [ a ] = [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> if b not in d : <NEWLINE> <INDENT> d [ b ] = [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> sol = { } <NEWLINE> <NL> m = [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> next_m = [ ] <NEWLINE> for mm in m : <NEWLINE> <INDENT> b = d [ mm ] <NEWLINE> for bb in b : <NEWLINE> <INDENT> if bb not in sol : <NEWLINE> <INDENT> sol [ bb ] = mm <NEWLINE> next_m . append ( bb ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( next_m ) == 0 : break <NEWLINE> m = next_m <NEWLINE> <NL> <DEDENT> sol = sorted ( sol . items ( ) ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for v in sol [ 1 : ] : <NEWLINE> <INDENT> print ( v [ 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> class Graph ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . adjacency_dict = { } <NEWLINE> self . weight = [ ] <NEWLINE> <NL> <DEDENT> def add_vertex ( self , v ) : <NEWLINE> <INDENT> self . adjacency_dict [ v ] = [ ] <NEWLINE> self . weight . append ( [ ] ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , v1 , v2 , w ) : <NEWLINE> <INDENT> self . adjacency_dict [ v1 ] . append ( v2 ) <NEWLINE> self . adjacency_dict [ v2 ] . append ( v1 ) <NEWLINE> self . weight [ v1 ] . append ( w ) <NEWLINE> self . weight [ v2 ] . append ( w ) <NEWLINE> <NL> <DEDENT> def get_vertexes ( self ) : <NEWLINE> <INDENT> return self . adjacency_dict . keys ( ) <NEWLINE> <NL> <DEDENT> def get_edges ( self , v ) : <NEWLINE> <INDENT> return self . adjacency_dict [ v ] , self . weight [ v ] <NEWLINE> <NL> <DEDENT> def print_graph ( self ) : <NEWLINE> <INDENT> print ( self . adjacency_dict ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> g = Graph ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res . append ( - 1 ) <NEWLINE> g . add_vertex ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> g . add_edge ( u - 1 , v - 1 , w % 2 ) <NEWLINE> <NL> <DEDENT> q = [ ] <NEWLINE> res [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> while ( len ( q ) > 0 ) : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> u_l , w_l = g . get_edges ( v ) <NEWLINE> for u , w in zip ( u_l , w_l ) : <NEWLINE> <INDENT> if res [ u ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> res [ u ] = ( res [ v ] + w ) % 2 <NEWLINE> q . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( res [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> ans = len ( set ( S ) ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import logging <NEWLINE> <NL> logging . basicConfig ( level = logging . DEBUG , format = <STRING> ) <NEWLINE> <NL> def dbg ( msg , * args , ** kwargs ) : <NEWLINE> <INDENT> logging . debug ( msg , * args , ** kwargs ) <NEWLINE> <NL> <DEDENT> Mat = collections . namedtuple ( <STRING> , <STRING> ) <NEWLINE> <NL> def mat_mul ( ms ) : <NEWLINE> <INDENT> return Mat ( ms [ 0 ] . r , ms [ - 1 ] . c ) <NEWLINE> <NL> <DEDENT> def cost ( m1 , m2 ) : <NEWLINE> <INDENT> return m1 . r * m1 . c * m2 . c <NEWLINE> <NL> <DEDENT> def solve ( n , ms ) : <NEWLINE> <INDENT> if n == 1 : return 0 <NEWLINE> <NL> dp = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ ( i , i ) ] = 0 <NEWLINE> <NL> <DEDENT> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( n - l + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> cost_min = float ( <STRING> ) <NEWLINE> for j in range ( l - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> m_lhs = mat_mul ( ms [ i : i + j + 1 ] ) <NEWLINE> m_rhs = mat_mul ( ms [ i + j + 1 : i + l ] ) <NEWLINE> <COMMENT> <NL> cost_lhs = dp [ ( i , i + j ) ] <NEWLINE> cost_rhs = dp [ ( i + j + 1 , i + l - 1 ) ] <NEWLINE> <COMMENT> <NL> cost_mul = cost ( m_lhs , m_rhs ) <NEWLINE> <COMMENT> <NL> cost_now = cost_mul + cost_lhs + cost_rhs <NEWLINE> <COMMENT> <NL> if cost_min > cost_now : <NEWLINE> <INDENT> cost_min = cost_now <NEWLINE> <DEDENT> <DEDENT> dp [ ( i , i + l - 1 ) ] = cost_min <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return dp [ ( 0 , n - 1 ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> ms = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ms . append ( Mat ( r , c ) ) <NEWLINE> <NL> <DEDENT> print ( solve ( n , ms ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : main ( ) <NEWLINE>
_ = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = 0 <NEWLINE> a = 0 <NEWLINE> for _a in A : <NEWLINE> <INDENT> s += _a * a <NEWLINE> a = ( a + _a ) % mod <NEWLINE> <DEDENT> print ( s % mod ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if 0 <= z and z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> for i in range ( max ( B - K + 1 , A + 1 ) , B + 1 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> l = list ( set ( l ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( * l , sep = <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> if inp == <STRING> : break <NEWLINE> <NL> num = 1 <NEWLINE> for i in range ( 1 , int ( inp ) + 1 ) : <NEWLINE> <INDENT> num = num * i <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> strnum = str ( num ) <NEWLINE> while True : <NEWLINE> <INDENT> if strnum [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> strnum = strnum [ : - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L_dict , R_dict = { } , { } <NEWLINE> i = 0 <NEWLINE> for ipt in input ( ) . split ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> L_dict [ i + int ( ipt ) ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> L_dict [ i + int ( ipt ) ] = 1 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> R_dict [ i - int ( ipt ) ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> R_dict [ i - int ( ipt ) ] = 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for Lk , Lv in L_dict . items ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> cnt += R_dict [ Lk ] * Lv <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = np . array ( input ( ) . split ( ) , dtype = <STRING> ) <NEWLINE> bad_tower = np . zeros ( ( n ) , dtype = <STRING> ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ha = h [ a - 1 ] <NEWLINE> hb = h [ b - 1 ] <NEWLINE> <NL> if ha > hb : <NEWLINE> <INDENT> bad_tower [ b - 1 ] = 1 <NEWLINE> <DEDENT> elif ha < hb : <NEWLINE> <INDENT> bad_tower [ a - 1 ] = 1 <NEWLINE> <DEDENT> elif ha == hb : <NEWLINE> <INDENT> bad_tower [ a - 1 ] = 1 <NEWLINE> bad_tower [ b - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = n - np . sum ( bad_tower ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif r >= 50 or total < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if N <= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minuscount = 0 <NEWLINE> Rcount = 0 <NEWLINE> Gcount = 0 <NEWLINE> Bcount = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> Rcount += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> Gcount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Bcount += 1 <NEWLINE> <DEDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> if i + 2 * j >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ i + j ] and S [ i + j ] != S [ i + 2 * j ] and S [ i + 2 * j ] != S [ i ] : <NEWLINE> <INDENT> minuscount += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Rcount * Gcount * Bcount - minuscount ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> B = [ ] <NEWLINE> flg_m = 0 <NEWLINE> flg_p = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> B . append ( [ abs ( a ) , - 1 ] ) <NEWLINE> flg_m = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( [ abs ( a ) , 1 ] ) <NEWLINE> flg_p = 1 <NEWLINE> <NL> <DEDENT> b = 0 <NEWLINE> <DEDENT> ans = - 10 ** 9 <NEWLINE> if k == 1 : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans = max ( ans , a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> B . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> if flg_p == 0 and k % 2 == 1 : <NEWLINE> <INDENT> B . sort ( ) <NEWLINE> L = B [ : k ] <NEWLINE> ans = cal_ans ( L ) <NEWLINE> ans *= - 1 <NEWLINE> print ( ans % MOD ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif flg_p * flg_m == 0 : <NEWLINE> <INDENT> L = B [ : k ] <NEWLINE> ans = cal_ans ( L ) <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> flg_p = 0 <NEWLINE> flg_m = 0 <NEWLINE> flg_lm = 0 <NEWLINE> flg_lp = 0 <NEWLINE> <COMMENT> <NL> for i , ( n , sign ) in enumerate ( B ) : <NEWLINE> <INDENT> if i < k : <NEWLINE> <INDENT> if sign == - 1 : <NEWLINE> <INDENT> flg_lp = 1 <NEWLINE> last_m = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg_lm = 1 <NEWLINE> last_p = n <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sign == - 1 : <NEWLINE> <INDENT> if flg_m == 0 : <NEWLINE> <INDENT> first_m = n <NEWLINE> flg_m = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if flg_p == 0 : <NEWLINE> <INDENT> first_p = n <NEWLINE> flg_p = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> L = B [ : k ] <NEWLINE> ans = cal_ans ( L ) <NEWLINE> c = 0 <NEWLINE> for n , sign in L : <NEWLINE> <INDENT> if sign == - 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if flg_p == 1 and flg_m == 1 and flg_lp == 1 and flg_lm == 1 : <NEWLINE> <INDENT> if first_p * last_p >= first_m * last_m : <NEWLINE> <INDENT> a = first_p <NEWLINE> b = last_m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = first_m <NEWLINE> b = last_p <NEWLINE> <DEDENT> <DEDENT> elif flg_p == 1 : <NEWLINE> <INDENT> a = first_p <NEWLINE> b = last_m <NEWLINE> <DEDENT> elif flg_m == 1 : <NEWLINE> <INDENT> a = first_m <NEWLINE> b = last_p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> ans *= pow ( b , MOD - 2 , MOD ) <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> def cal_ans ( L ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> for i , j in L : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> ab = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> l = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> parents = [ - 1 ] * ( n + 1 ) <NEWLINE> order = [ ] <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> while q : <NEWLINE> <INDENT> c = q . pop ( ) <NEWLINE> order . append ( c ) <NEWLINE> for i in l [ c ] : <NEWLINE> <INDENT> if i == parents [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parents [ i ] = c <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> color = [ - 1 ] * ( n + 1 ) <NEWLINE> for i in order : <NEWLINE> <INDENT> ng = color [ i ] <NEWLINE> c = 1 <NEWLINE> for j in l [ i ] : <NEWLINE> <INDENT> if j == parents [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c == ng : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> color [ j ] = c <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> if a == parents [ b ] : <NEWLINE> <INDENT> ans . append ( color [ b ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( color [ a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , ans ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> if s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s [ 0 ] not in d : <NEWLINE> <INDENT> d [ s [ 0 ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s [ 0 ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> d = list ( d . values ( ) ) <NEWLINE> if len ( d ) == 3 : <NEWLINE> <INDENT> count += d [ 0 ] * d [ 1 ] * d [ 2 ] <NEWLINE> <DEDENT> elif len ( d ) == 4 : <NEWLINE> <INDENT> count += d [ 0 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 3 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 0 ] * d [ 1 ] * d [ 3 ] <NEWLINE> count += d [ 0 ] * d [ 3 ] * d [ 2 ] <NEWLINE> <DEDENT> elif len ( d ) == 5 : <NEWLINE> <INDENT> count += d [ 0 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 3 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 0 ] * d [ 1 ] * d [ 3 ] <NEWLINE> count += d [ 0 ] * d [ 3 ] * d [ 2 ] <NEWLINE> <NL> <COMMENT> <NL> count += d [ 4 ] * d [ 1 ] * d [ 2 ] <NEWLINE> count += d [ 0 ] * d [ 1 ] * d [ 4 ] <NEWLINE> count += d [ 0 ] * d [ 4 ] * d [ 2 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> count += d [ 4 ] * d [ 1 ] * d [ 3 ] <NEWLINE> count += d [ 4 ] * d [ 3 ] * d [ 2 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> count += d [ 0 ] * d [ 4 ] * d [ 3 ] <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = pow ( 10 , N , MOD ) <NEWLINE> ans -= 2 * pow ( 9 , N , MOD ) <NEWLINE> ans += pow ( 8 , N , MOD ) <NEWLINE> ans %= MOD <COMMENT> <NEWLINE> <NL> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n != 0 ) : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> kouho = list ( range ( - 200 , 200 ) ) <NEWLINE> <NL> <NL> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ i ] != x : <NEWLINE> <INDENT> del kouho [ kouho . index ( p [ i ] ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> kouho_num = kouho . index ( x ) <NEWLINE> right = kouho_num + 1 <NEWLINE> left = kouho_num - 1 <NEWLINE> <NL> if ( x not in p ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif abs ( kouho [ right ] - kouho [ kouho_num ] ) > abs ( kouho [ kouho_num ] - kouho [ left ] ) : <NEWLINE> <INDENT> print ( kouho [ left ] ) <NEWLINE> <DEDENT> elif abs ( kouho [ right ] - kouho [ kouho_num ] ) == abs ( kouho [ kouho_num ] - kouho [ left ] ) : <NEWLINE> <INDENT> print ( kouho [ left ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( kouho [ right ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> roomSign = [ - 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> D = deque ( [ 0 ] ) <NEWLINE> <NL> while D : <NEWLINE> <INDENT> v = D . popleft ( ) <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if roomSign [ i ] == - 1 : <NEWLINE> <INDENT> roomSign [ i ] = v <NEWLINE> D . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( roomSign [ i ] + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import collections <NEWLINE> import itertools as it <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = a [ 0 ] <NEWLINE> for a_ in a [ 1 : ] : <NEWLINE> <INDENT> if ans * a_ <= 10 ** 18 : <NEWLINE> <INDENT> ans *= a_ <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> s = [ 0 ] * n <NEWLINE> a . append ( input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a [ 0 ] [ i ] = int ( a [ 0 ] [ i ] ) <NEWLINE> s [ a [ 0 ] [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> ele = a [ i + k ] <NEWLINE> if ele <= a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = [ ] <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a += i <NEWLINE> <NL> <DEDENT> if a : <NEWLINE> <INDENT> if i == <STRING> and a [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a += i <NEWLINE> <DEDENT> if i == <STRING> and a [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a . pop ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif i == <STRING> and len ( a ) == 0 : <NEWLINE> <INDENT> a += i <NEWLINE> <DEDENT> <DEDENT> print ( len ( a ) ) <NEWLINE>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> <NL> x = input ( ) <NEWLINE> x = int ( x ) <NEWLINE> <NL> present_min_value = x <NEWLINE> max_profit_candidate = 1 - 10 ** 9 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> diff = a - present_min_value <NEWLINE> if diff > max_profit_candidate : <NEWLINE> <INDENT> max_profit_candidate = diff <NEWLINE> <DEDENT> if a < present_min_value : <NEWLINE> <INDENT> present_min_value = a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_profit_candidate ) <NEWLINE>
def D ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> next = a [ 0 ] <NEWLINE> path = [ 1 ] <NEWLINE> visited = [ True ] + [ False ] * ( n - 1 ) <NEWLINE> while not visited [ next - 1 ] : <NEWLINE> <INDENT> k -= 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( next ) <NEWLINE> break <NEWLINE> <DEDENT> path . append ( next ) <NEWLINE> visited [ next - 1 ] = True <NEWLINE> next = a [ next - 1 ] <NEWLINE> <DEDENT> if k != 0 : <NEWLINE> <INDENT> cyclic = path [ path . index ( next ) : ] <NEWLINE> print ( cyclic [ k % ( len ( cyclic ) ) - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> D ( ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import queue <NEWLINE> <NL> SPACE = 0 <NEWLINE> <NL> adjacents_list = ( <NEWLINE> <INDENT> ( 1 , 3 ) , <COMMENT> <NEWLINE> ( 0 , 2 , 4 ) , <COMMENT> <NEWLINE> ( 1 , 5 ) , <COMMENT> <NEWLINE> ( 0 , 4 , 6 ) , <COMMENT> <NEWLINE> ( 1 , 3 , 5 , 7 ) , <COMMENT> <NEWLINE> ( 2 , 4 , 8 ) , <COMMENT> <NEWLINE> ( 3 , 7 ) , <COMMENT> <NEWLINE> ( 4 , 6 , 8 ) , <COMMENT> <NEWLINE> ( 5 , 7 ) <COMMENT> <NEWLINE> <DEDENT> ) <NEWLINE> <NL> class State : <NEWLINE> <INDENT> def __init__ ( self , board , space , prev ) : <NEWLINE> <INDENT> self . board = board <NEWLINE> self . space = space <NEWLINE> self . prev = prev <NEWLINE> <NL> <DEDENT> <DEDENT> def mininum_steps ( start , goal ) : <NEWLINE> <INDENT> if start == goal : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> q = queue . Queue ( ) <NEWLINE> q . put ( State ( start , start . index ( 0 ) , None ) ) <NEWLINE> history = { } <NEWLINE> history [ tuple ( start ) ] = True <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> state = q . get ( ) <NEWLINE> for adjacent in adjacents_list [ state . space ] : <NEWLINE> <INDENT> board = state . board [ : ] <NEWLINE> board [ state . space ] = board [ adjacent ] <NEWLINE> board [ adjacent ] = SPACE <NEWLINE> if tuple ( board ) in history : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if board == goal : <NEWLINE> <INDENT> return go_back ( state ) <NEWLINE> <DEDENT> history [ tuple ( board ) ] = True <NEWLINE> next_state = State ( board , adjacent , state ) <NEWLINE> q . put ( next_state ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> step = 0 <NEWLINE> def go_back ( state ) : <NEWLINE> <INDENT> global step <NEWLINE> if state is not None : <NEWLINE> <INDENT> step += 1 <NEWLINE> go_back ( state . prev ) <NEWLINE> <DEDENT> return step <NEWLINE> <NL> <NL> <DEDENT> initial_board = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) <NEWLINE> goal = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 ] <NEWLINE> <NL> print ( mininum_steps ( initial_board , goal ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> sm = sum ( a ) <NEWLINE> hm = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> hm [ i ] += 1 <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sm += ( c - b ) * hm [ b ] <NEWLINE> hm [ c ] += hm [ b ] <NEWLINE> hm [ b ] = 0 <NEWLINE> print ( sm ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> i = 1 <NEWLINE> while ( i < n - 1 ) : <NEWLINE> <INDENT> if ( s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ls = [ ] <NEWLINE> i = 0 <NEWLINE> c = 0 <NEWLINE> while i < N and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if i == N : <NEWLINE> <INDENT> print ( N ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while i < N : <NEWLINE> <INDENT> l = c <NEWLINE> c = 0 <NEWLINE> while i < N and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> m = c <NEWLINE> c = 0 <NEWLINE> while i < N and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> r = c <NEWLINE> ls . append ( ( l , m , r ) ) <NEWLINE> <DEDENT> K = min ( K , len ( ls ) ) <NEWLINE> from itertools import accumulate <NEWLINE> acc = list ( accumulate ( [ 0 ] + ls , lambda x , y : x + y [ 1 ] + y [ 2 ] ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( ls ) - K + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , acc [ i + K ] - acc [ i ] + ls [ i ] [ 0 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def is_good ( mid , key ) : <NEWLINE> <INDENT> return sum ( count_cuts ( a , mid ) for a in A ) <= key <NEWLINE> <NL> <NL> <DEDENT> def binary_search ( key ) : <NEWLINE> <INDENT> bad , good = 0 , 2 * 10 ** 14 + 1 <NEWLINE> while good - bad > 1 : <NEWLINE> <INDENT> mid = ( bad + good ) // 2 <NEWLINE> if is_good ( mid , key ) : <NEWLINE> <INDENT> good = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad = mid <NEWLINE> <DEDENT> <DEDENT> return good <NEWLINE> <NL> <NL> <DEDENT> def count_cuts ( a , unit ) : <NEWLINE> <INDENT> return ( a + unit - 1 ) // unit - 1 <NEWLINE> <NL> <NL> <DEDENT> N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( binary_search ( K ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> Boss = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AA = collections . Counter ( Boss ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( AA [ i + 1 ] ) <NEWLINE> <DEDENT>
def cal ( ) : <NEWLINE> <INDENT> import queue <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> cost = [ [ - 1 ] * w for _ in range ( h ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> count , ans = 0 , INF <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> cost [ i ] [ j ] = INF <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = queue . Queue ( ) <NEWLINE> q . put ( ( 0 , 0 , 1 ) ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> c0 , c1 , c2 = q . get ( ) <NEWLINE> s [ c0 ] [ c1 ] = <STRING> <NEWLINE> if c0 == h - 1 and c1 == w - 1 : <NEWLINE> <INDENT> return h * w - count - c2 <NEWLINE> <DEDENT> for i , j in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> x , y = c0 + i , c1 + j <NEWLINE> if 0 <= x < h and 0 <= y < w : <NEWLINE> <INDENT> if s [ x ] [ y ] != <STRING> and cost [ x ] [ y ] == INF : <NEWLINE> <INDENT> cost [ x ] [ y ] = c2 + 1 <NEWLINE> q . put ( ( x , y , c2 + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = cal ( ) <NEWLINE> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> org = input ( ) . split ( ) <NEWLINE> for i in range ( len ( org ) ) : <NEWLINE> <INDENT> org [ i ] = int ( org [ i ] ) <NEWLINE> <DEDENT> A = sorted ( org ) <NEWLINE> <NL> answer = A [ 0 ] <NEWLINE> overl = False <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> answer *= A [ i + 1 ] <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> overl = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if overl : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> m = 2019 <NEWLINE> ans = 0 <NEWLINE> x = 1 <NEWLINE> tot = 0 <NEWLINE> cnt = [ 0 ] * m <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> for s in s : <NEWLINE> <INDENT> tot += int ( s ) * x <NEWLINE> tot %= m <NEWLINE> <COMMENT> <NL> x *= 10 <NEWLINE> x %= m <NEWLINE> cnt [ tot ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in cnt ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> from collections import defaultdict <NEWLINE> count = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i - a in count : <NEWLINE> <INDENT> ans += count [ i - a ] <NEWLINE> <DEDENT> count [ i + a ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> no = [ ] <NEWLINE> for i in AB : <NEWLINE> <INDENT> if H [ i [ 0 ] - 1 ] > H [ i [ 1 ] - 1 ] : <NEWLINE> <INDENT> no . append ( i [ 1 ] - 1 ) <NEWLINE> <DEDENT> elif H [ i [ 0 ] - 1 ] < H [ i [ 1 ] - 1 ] : <NEWLINE> <INDENT> no . append ( i [ 0 ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> no . append ( i [ 1 ] - 1 ) <NEWLINE> no . append ( i [ 0 ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( n - len ( set ( no ) ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def divide ( n ) : <NEWLINE> <INDENT> c1 , c2 = 0 , 0 <NEWLINE> while ( n % 2 == 0 ) : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> while ( n % 5 == 0 ) : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> n //= 5 <NEWLINE> <DEDENT> return ( c1 , c2 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sub = input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> if <STRING> in sub : <NEWLINE> <INDENT> x , y = map ( str , sub . split ( <STRING> ) ) <NEWLINE> s = int ( x ) * 1000000000 + 10 ** ( 9 - len ( y ) ) * int ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = int ( sub ) <NEWLINE> s *= 1000000000 <NEWLINE> <DEDENT> a [ i ] = divide ( s ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * 100 for _ in range ( 100 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c1 , c2 = a [ i ] <NEWLINE> dp [ c1 ] [ c2 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 98 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 98 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] += dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i + 1 ] [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c1 , c2 = a [ i ] <NEWLINE> if ( c1 >= 9 and c2 >= 9 ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if c1 >= 18 and c2 >= 18 : <NEWLINE> <INDENT> ans += dp [ 0 ] [ 0 ] <NEWLINE> continue <NEWLINE> <DEDENT> if c1 >= 18 : <NEWLINE> <INDENT> ans += dp [ 0 ] [ 18 - c2 ] <NEWLINE> continue <NEWLINE> <DEDENT> if c2 >= 18 : <NEWLINE> <INDENT> ans += dp [ 18 - c1 ] [ 0 ] <NEWLINE> continue <NEWLINE> <DEDENT> ans += dp [ 18 - c1 ] [ 18 - c2 ] <NEWLINE> <NL> <DEDENT> print ( ans // 2 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> i -= 1 <NEWLINE> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> a_max = a [ - 1 ] <NEWLINE> dp = [ 1 ] * a_max <NEWLINE> <NL> for i in set ( a ) : <NEWLINE> <INDENT> j = 2 <NEWLINE> while i * j <= a_max : <NEWLINE> <INDENT> dp [ i * j - 1 ] = 0 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a . append ( 0 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] - 1 ] and a [ i - 1 ] != a [ i ] and a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> y = x . split ( <STRING> ) <NEWLINE> c = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c . append ( y [ ( a - 1 ) - i ] ) <NEWLINE> <DEDENT> b = <STRING> . join ( c ) <NEWLINE> print ( b ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( A - B ) > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( A - B ) * ( - 1 ) ** K ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ i for i in range ( 0 , 102 ) if i not in a ] <NEWLINE> b_tmp = list ( map ( lambda s : abs ( s - x ) , b ) ) <NEWLINE> address = b_tmp . index ( min ( b_tmp ) ) <NEWLINE> print ( b [ address ] ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for base in range ( x + 1 ) : <NEWLINE> <INDENT> if p . count ( x + base * - 1 ) == 0 : <NEWLINE> <INDENT> print ( x + base * - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if p . count ( x + base ) == 0 : <NEWLINE> <INDENT> print ( x + base ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> arr = [ 0 ] * ( k + 1 ) <NEWLINE> r = 7 % k <NEWLINE> ans = 1 <NEWLINE> <NL> while arr [ r ] == 0 : <NEWLINE> <INDENT> if r == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> arr [ r ] += 1 <NEWLINE> r = ( 10 * r + 7 ) % k <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> bc = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] , key = lambda x : x [ 1 ] ) <NEWLINE> bc . reverse ( ) <NEWLINE> <NL> flg = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if bc [ flg ] [ 1 ] > a [ i ] and flg < m : <NEWLINE> <INDENT> a [ i ] = bc [ flg ] [ 1 ] <NEWLINE> cnt += 1 <NEWLINE> if cnt == bc [ flg ] [ 0 ] : <NEWLINE> <INDENT> flg += 1 <NEWLINE> cnt = 0 <NEWLINE> if flg == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> ln = set ( ) <NEWLINE> for i in ( range ( n ) ) : <NEWLINE> <INDENT> stn = input ( ) <NEWLINE> if stn in ln : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ln . add ( stn ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( ln ) ) <NEWLINE>
t = input ( ) <NEWLINE> n = len ( t ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = t [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if a [ i - 1 ] == <STRING> and a [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i - 1 ] == <STRING> and a [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i - 1 ] == <STRING> and a [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> s = <STRING> . join ( a ) <NEWLINE> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sum ( A ) <NEWLINE> Z = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> Z [ A [ n ] ] = 0 <NEWLINE> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> Z [ A [ n ] ] += 1 <NEWLINE> <DEDENT> D = [ ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x in Z : <NEWLINE> <INDENT> C = C - x * Z [ x ] <NEWLINE> C = C + y * Z [ x ] <NEWLINE> D . append ( C ) <NEWLINE> if x == y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if y in Z : <NEWLINE> <INDENT> Z [ y ] += 1 * Z [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Z [ y ] = Z [ x ] <NEWLINE> <DEDENT> Z . pop ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( C ) <NEWLINE> <DEDENT> <DEDENT> for d in D : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT>
N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ok = 0 <NEWLINE> ng = 0 <NEWLINE> ng_l = { } <NEWLINE> end = set ( ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> p , S = [ x for x in input ( ) . split ( ) ] <NEWLINE> p = int ( p ) <NEWLINE> <NL> if not p in end : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> ok += 1 <NEWLINE> end . add ( p ) <NEWLINE> <NL> if p in ng_l : <NEWLINE> <INDENT> ng += ng_l [ p ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p in ng_l : <NEWLINE> <INDENT> ng_l [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng_l [ p ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( ok , ng ) ) <NEWLINE>
T , P = input ( ) , input ( ) <NEWLINE> T_len = len ( T ) <NEWLINE> P_len = len ( P ) <NEWLINE> for i in range ( T_len - P_len + 1 ) : <NEWLINE> <INDENT> if T [ i : i + P_len ] == P : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def abs_search ( o , * l ) : <NEWLINE> <INDENT> if X not in p : <NEWLINE> <INDENT> print ( X ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for pl_num in range ( X + 1 , 102 ) : <NEWLINE> <INDENT> if pl_num not in p : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for mi_num in range ( X - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if mi_num not in p : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> abs_pl = abs ( pl_num - X ) <NEWLINE> abs_mi = abs ( mi_num - X ) <NEWLINE> <NL> if abs_pl < abs_mi : <NEWLINE> <INDENT> print ( pl_num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mi_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> abs_search ( * p ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def gcd ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> res = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for m in range ( j , k + 1 ) : <NEWLINE> <INDENT> if i == j and j == m : <NEWLINE> <INDENT> res += gcd ( [ i , j , m ] ) <NEWLINE> <DEDENT> elif i == j or j == m or i == m : <NEWLINE> <INDENT> res += gcd ( [ i , j , m ] ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += gcd ( [ i , j , m ] ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> pair = [ i for i in range ( n ) ] <NEWLINE> que = [ ] <NEWLINE> e = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ i ] = ( i , x , y ) <NEWLINE> <DEDENT> ex = sorted ( e , key = lambda x : x [ 1 ] ) <NEWLINE> ey = sorted ( e , key = lambda x : x [ 2 ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> w = ex [ i + 1 ] [ 1 ] - ex [ i ] [ 1 ] <NEWLINE> heappush ( que , ( w , ex [ i ] [ 0 ] , ex [ i + 1 ] [ 0 ] ) ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> w = ey [ i + 1 ] [ 2 ] - ey [ i ] [ 2 ] <NEWLINE> heappush ( que , ( w , ey [ i ] [ 0 ] , ey [ i + 1 ] [ 0 ] ) ) <NEWLINE> <DEDENT> def find ( x ) : <NEWLINE> <INDENT> if x == pair [ x ] : return x <NEWLINE> else : <NEWLINE> <INDENT> tmp = find ( pair [ x ] ) <NEWLINE> pair [ x ] = tmp <NEWLINE> return tmp <NEWLINE> <DEDENT> <DEDENT> q = [ ] <NEWLINE> ans = 0 <NEWLINE> while que : <NEWLINE> <INDENT> w , s , t = heappop ( que ) <NEWLINE> root_s = find ( s ) <NEWLINE> root_t = find ( t ) <NEWLINE> if root_s != root_t : <NEWLINE> <INDENT> pair [ root_s ] = root_t <NEWLINE> ans += w <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N >= B : <NEWLINE> <INDENT> print ( A * ( B - 1 ) // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A * N // B ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if i != K - 1 : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chr ( ord ( S [ i ] ) + 32 ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , mm , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c , d = [ 0 ] * q , [ 0 ] * q , [ 0 ] * q , [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> import itertools <NEWLINE> td = [ ] <NEWLINE> ttd = [ ] <NEWLINE> <NL> m = [ ] <NEWLINE> for i in range ( 1 , mm + 1 ) : <NEWLINE> <INDENT> m . append ( i ) <NEWLINE> <NL> <DEDENT> s = list ( itertools . combinations_with_replacement ( m , n ) ) <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> for i in range ( q ) : <NEWLINE> <INDENT> if s [ j ] [ b [ i ] - 1 ] - s [ j ] [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> td . append ( d [ i ] ) <NEWLINE> <DEDENT> <DEDENT> ttd . append ( sum ( td ) ) <NEWLINE> td = [ ] <NEWLINE> <DEDENT> if ttd == [ ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( ttd ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> zeros = 0 <NEWLINE> a_zeros = 0 <NEWLINE> b_zeros = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if not any ( ( a , b ) ) : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if not a : <NEWLINE> <INDENT> a_zeros += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if not b : <NEWLINE> <INDENT> b_zeros += 1 <NEWLINE> continue <NEWLINE> <DEDENT> g = gcd ( a , b ) * ( a // abs ( a ) ) <NEWLINE> p = a // g , b // g <NEWLINE> d [ p ] = d . get ( p , 0 ) + 1 <NEWLINE> <DEDENT> counts = dict ( ) <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> a , b = k <NEWLINE> if counts . get ( ( b , - a ) , False ) or counts . get ( ( - b , a ) , False ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counts [ k ] = v , d . get ( ( b , - a ) , 0 ) + d . get ( ( - b , a ) , 0 ) <NEWLINE> <DEDENT> total = 1 <NEWLINE> for k , v in counts . items ( ) : <NEWLINE> <INDENT> a , b = v <NEWLINE> total = ( total * ( pow ( 2 , a , MOD ) + pow ( 2 , b , MOD ) - 1 ) ) % MOD <NEWLINE> <DEDENT> total = ( total * ( pow ( 2 , a_zeros , MOD ) + pow ( 2 , b_zeros , MOD ) - 1 ) ) % MOD <NEWLINE> print ( ( total + zeros + MOD - 1 ) % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> L1 = factorization ( N - 1 ) <NEWLINE> s = 1 <NEWLINE> <COMMENT> <NL> for [ a , b ] in L1 : <NEWLINE> <INDENT> s *= ( b + 1 ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> for i in set ( make_divisors ( N ) ) - { 1 } : <NEWLINE> <INDENT> temp = N <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> temp //= i <NEWLINE> <DEDENT> if ( temp - 1 ) % i == 0 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> s -= 1 <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n , a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n != ( a + b ) : print ( a * ( n // ( a + b ) ) + min ( a , n % ( a + b ) ) ) <NEWLINE> else : print ( a ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> r = <STRING> <NEWLINE> t2 = T + T <NEWLINE> <NL> if set ( S ) == set ( T ) : <NEWLINE> <INDENT> if t2 . count ( S ) > 0 : <NEWLINE> <INDENT> r = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> r = <STRING> <NEWLINE> <NL> <DEDENT> print ( r ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> lcm = n * m // math . gcd ( n , m ) <NEWLINE> ans = [ ] <NEWLINE> s_ind = lcm // n <NEWLINE> t_ind = lcm // m <NEWLINE> check_ind = s_ind * t_ind // math . gcd ( s_ind , t_ind ) <NEWLINE> for i in range ( 0 , lcm , check_ind ) : <NEWLINE> <INDENT> if s [ i // s_ind ] != t [ i // t_ind ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
class Node ( ) : <NEWLINE> <INDENT> key = 0 <NEWLINE> l = None <NEWLINE> r = None <NEWLINE> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> <DEDENT> <DEDENT> T = [ None ] * 5000005 <NEWLINE> def insert ( z ) : <NEWLINE> <INDENT> if z == 0 : return <NEWLINE> y = 0 <NEWLINE> x = 0 <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> x = ( T [ x ] . l if T [ z ] . key < T [ x ] . key else T [ x ] . r ) <NEWLINE> <DEDENT> if T [ z ] . key < T [ y ] . key : T [ y ] . l = z <NEWLINE> else : T [ y ] . r = z <NEWLINE> <DEDENT> def inorder ( x ) : <NEWLINE> <INDENT> if x == None : return ; <NEWLINE> inorder ( T [ x ] . l ) ; <NEWLINE> print ( <STRING> , T [ x ] . key , end = <STRING> ) <NEWLINE> inorder ( T [ x ] . r ) ; <NEWLINE> <DEDENT> def preorder ( x ) : <NEWLINE> <INDENT> if x == None : return ; <NEWLINE> print ( <STRING> , T [ x ] . key , end = <STRING> ) <NEWLINE> preorder ( T [ x ] . l ) ; <NEWLINE> preorder ( T [ x ] . r ) ; <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> inorder ( 0 ) <NEWLINE> print ( ) <NEWLINE> preorder ( 0 ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( s . split ( ) [ 1 ] ) <NEWLINE> T [ i ] = Node ( x ) <NEWLINE> insert ( i ) <NEWLINE> <DEDENT> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ht = [ 0 ] * h <NEWLINE> wt = [ 0 ] * w <NEWLINE> for y , x in t : <NEWLINE> <INDENT> ht [ y ] += 1 <NEWLINE> wt [ x ] += 1 <NEWLINE> <DEDENT> htm = max ( ht ) <NEWLINE> wtm = max ( wt ) <NEWLINE> htt = [ i for i in range ( h ) if ht [ i ] == htm ] <NEWLINE> wtt = [ i for i in range ( w ) if wt [ i ] == wtm ] <NEWLINE> ans = htm + wtm - 1 <NEWLINE> t = set ( t ) <NEWLINE> for i in htt : <NEWLINE> <INDENT> for j in wtt : <NEWLINE> <INDENT> if ( i , j ) not in t : <NEWLINE> <INDENT> print ( htm + wtm ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( htm + wtm - 1 ) <NEWLINE>
import math <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lo_d , up_d = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lo_d . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> up_d . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lo_d + up_d [ : : - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> List = make_divisors ( N ) <NEWLINE> len_a = len ( List ) <NEWLINE> ans = List [ len_a // 2 ] <NEWLINE> print ( math . floor ( math . log ( ans , 10 ) ) + 1 ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> i = 0 <NEWLINE> while i < n and p [ i ] < x : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> if p [ i ] != x : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = 1 <NEWLINE> up = x + j <NEWLINE> down = x - j <NEWLINE> while True : <NEWLINE> <INDENT> if i - j >= 0 and p [ i - j ] != x - j : <NEWLINE> <INDENT> print ( x - j ) <NEWLINE> break <NEWLINE> <DEDENT> elif i - j < 0 : <NEWLINE> <INDENT> print ( x - j ) <NEWLINE> break <NEWLINE> <DEDENT> if i + j < n and p [ i + j ] != x + j : <NEWLINE> <INDENT> print ( x + j ) <NEWLINE> break <NEWLINE> <DEDENT> elif i + j >= n : <NEWLINE> <INDENT> print ( x + j ) <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ap = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ap [ i - a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += ap [ a [ i ] + i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> S = math . pi * r ** 2 <NEWLINE> L = 2 * math . pi * r <NEWLINE> <NL> print ( S , L ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = np . array ( list ( read ( ) . rstrip ( ) ) ) <NEWLINE> <NL> r = np . sum ( s == <STRING> ) <NEWLINE> g = np . sum ( s == <STRING> ) <NEWLINE> b = np . sum ( s == <STRING> ) <NEWLINE> @ njit <NEWLINE> def f ( s ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i1 in range ( n ) : <NEWLINE> <INDENT> for i2 in range ( i1 + 1 , n ) : <NEWLINE> <INDENT> i3 = i2 * 2 - i1 <NEWLINE> if i3 <= n - 1 : <NEWLINE> <INDENT> if s [ i1 ] != s [ i2 ] and s [ i1 ] != s [ i3 ] and s [ i2 ] != s [ i3 ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> res = r * g * b - f ( s ) <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> sumy = 0 <NEWLINE> <COMMENT> <NL> numhalf = int ( n / 2 ) <NEWLINE> <COMMENT> <NL> for i in range ( numhalf ) : <NEWLINE> <INDENT> t = i + 1 <NEWLINE> k = int ( n / t ) <NEWLINE> sumy += int ( t * k * ( k + 1 ) / 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> sumy += int ( ( n + numhalf + 1 ) * ( n - numhalf ) / 2 ) <NEWLINE> print ( sumy ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> a = [ ] <NEWLINE> <NL> a = dict ( collections . Counter ( A ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for k in a : <NEWLINE> <INDENT> s += k * a [ k ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <COMMENT> <NL> <INDENT> after = { B [ i ] : 0 , C [ i ] : a . setdefault ( B [ i ] , 0 ) + a . setdefault ( C [ i ] , 0 ) } <NEWLINE> <COMMENT> <NL> <NL> s = s + ( C [ i ] - B [ i ] ) * a [ B [ i ] ] <NEWLINE> <NL> print ( s ) <NEWLINE> <NL> a . update ( after ) <NEWLINE> <NL> <NL> <DEDENT>
i = input ; i ( ) ; l = i ( ) . split ( ) ; x = not <STRING> in l <NEWLINE> for j in l : <NEWLINE> <INDENT> x *= int ( j ) ; <NEWLINE> if x > 1e18 : x = - 1 ; break <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> x = 7 % K <NEWLINE> <NL> for i in range ( 1 , K + 8 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = ( 10 * x + 7 ) % K <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> X = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> Y = gcd ( X , c ) <NEWLINE> ans += Y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> bosses = [ 0 ] * N <NEWLINE> for a in As : <NEWLINE> <INDENT> bosses [ a - 1 ] = bosses [ a - 1 ] + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , bosses ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = np . zeros ( int ( N ) ) <NEWLINE> <NL> if N < 10001 and N > 3 : <NEWLINE> <INDENT> maxa = int ( np . sqrt ( N - 2 ) ) <NEWLINE> for x in range ( 1 , maxa ) : <NEWLINE> <INDENT> for y in range ( 1 , x ) : <NEWLINE> <INDENT> for z in range ( 1 , y ) : <NEWLINE> <INDENT> p = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if p < N + 1 : <NEWLINE> <INDENT> ans [ p - 1 ] += 6 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for x in range ( 1 , maxa ) : <NEWLINE> <INDENT> for y in range ( 1 , x ) : <NEWLINE> <INDENT> p = x * x * 3 + y * y + x * y * 2 <NEWLINE> if p < N + 1 : <NEWLINE> <INDENT> ans [ p - 1 ] += 3 <NEWLINE> <DEDENT> p = y * y * 3 + x * x + x * y * 2 <NEWLINE> if p < N + 1 : <NEWLINE> <INDENT> ans [ p - 1 ] += 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( 1 , maxa ) : <NEWLINE> <INDENT> p = x * x * 6 <NEWLINE> if p < N + 1 : <NEWLINE> <INDENT> ans [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( 0 , N ) : <NEWLINE> <INDENT> print ( int ( ans [ x ] ) ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if 0 <= k and k <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b > k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = a - ( k - a - b ) <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import math <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> import bisect <NEWLINE> from collections import deque , defaultdict <NEWLINE> import heapq as hpq <NEWLINE> from sys import stdin , setrecursionlimit <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ipt = stdin . readline <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ls = len ( s ) <NEWLINE> t = input ( ) <NEWLINE> if t [ 0 ] in s : <NEWLINE> <INDENT> idx = s . find ( t [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in t [ 1 : : ] : <NEWLINE> <INDENT> nt = s . find ( i , idx % ls + 1 ) <NEWLINE> ntl = s . find ( i ) <NEWLINE> if ntl == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif nt == - 1 : <NEWLINE> <INDENT> idx = ( idx // ls ) * ls + ls + ntl <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = ( idx // ls ) * ls + nt <NEWLINE> <DEDENT> <DEDENT> print ( idx + 1 ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import itertools as it <NEWLINE> <NL> <COMMENT> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( res ) == 0 : <NEWLINE> <INDENT> res = [ n ] <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> m = n <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def comb ( n , r ) : <COMMENT> <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> l = min ( r , n - r ) <NEWLINE> m = n <NEWLINE> u = 1 <NEWLINE> for _i in range ( l ) : <NEWLINE> <INDENT> u *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return u // fact ( l ) <NEWLINE> <DEDENT> def combmod ( n , r , mod ) : <NEWLINE> <INDENT> return ( fact ( n ) / fact ( n - r ) * pow ( fact ( r ) , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> def printQueue ( q ) : <NEWLINE> <INDENT> r = copyQueue ( q ) <NEWLINE> ans = [ 0 ] * r . qsize ( ) <NEWLINE> for i in range ( r . qsize ( ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans [ i ] = r . get ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - 1 * self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <COMMENT> <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <COMMENT> <NEWLINE> <DEDENT> <DEDENT> def bitArr ( n ) : <COMMENT> <NEWLINE> <INDENT> x = 1 <NEWLINE> zero = <STRING> * n <NEWLINE> ans = [ ] <NEWLINE> ans . append ( [ 0 ] * n ) <NEWLINE> for i in range ( 2 ** n - 1 ) : <NEWLINE> <INDENT> ans . append ( list ( map ( lambda x : int ( x ) , list ( ( zero + bin ( x ) [ 2 : ] ) [ - 1 * n : ] ) ) ) ) <NEWLINE> x += 1 <NEWLINE> <DEDENT> return ans ; <NEWLINE> <DEDENT> def arrsSum ( a1 , a2 ) : <NEWLINE> <INDENT> for i in range ( len ( a1 ) ) : <NEWLINE> <INDENT> a1 [ i ] += a2 [ i ] <NEWLINE> <DEDENT> return a1 <NEWLINE> <DEDENT> def maxValue ( a , b , v ) : <NEWLINE> <INDENT> v2 = v <NEWLINE> for i in range ( v2 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( v2 // a + 1 ) : <COMMENT> <NEWLINE> <INDENT> k = i - a * j <NEWLINE> if k % b == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> def copyQueue ( q ) : <NEWLINE> <INDENT> nq = queue . Queue ( ) <NEWLINE> n = q . qsize ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = q . get ( ) <NEWLINE> q . put ( x ) <NEWLINE> nq . put ( x ) <NEWLINE> <DEDENT> return nq <NEWLINE> <DEDENT> def get_sieve_of_eratosthenes ( n ) : <NEWLINE> <INDENT> data = [ 2 ] <NEWLINE> <COMMENT> <NL> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> data . append ( i ) <NEWLINE> data . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> interval = data [ i ] <NEWLINE> if interval != 0 : <NEWLINE> <INDENT> for j in range ( i + interval , n - 1 , interval ) : <NEWLINE> <INDENT> data [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = [ x for x in data if x != 0 ] <NEWLINE> <COMMENT> <NL> return ans <NEWLINE> <NL> <DEDENT> n = readInt ( ) <NEWLINE> a = readInts ( ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> max_a = 10 ** 6 <NEWLINE> ans = [ 0 ] * ( max_a + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> for i in set ( a ) : <NEWLINE> <INDENT> if ans [ i ] > 0 : <NEWLINE> <INDENT> for j in range ( i * 2 , len ( ans ) , i ) : <NEWLINE> <INDENT> ans [ j ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> <NL> <NL> print ( ans . count ( 1 ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_s = [ 0 ] * ( len ( A ) + 1 ) <NEWLINE> b_s = [ 0 ] * ( len ( B ) + 1 ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> a_s [ i + 1 ] = a_s [ i ] + A [ i ] <NEWLINE> <DEDENT> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> b_s [ i + 1 ] = b_s [ i ] + B [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( len ( a_s ) ) : <NEWLINE> <INDENT> if a_s [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b_s [ j ] + a_s [ i ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > n : <NEWLINE> <INDENT> print ( int ( a * n / b ) - a * int ( n / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a * ( b - 1 ) / b ) - a * int ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT>
from sys import exit <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Query = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> Query . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> flag0 = True <NEWLINE> for j in Query : <NEWLINE> <INDENT> if j [ 0 ] != 1 or j [ 1 ] != 0 : <NEWLINE> <INDENT> flag0 = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> None <NEWLINE> <NL> <DEDENT> <DEDENT> if flag0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 10 ** ( N - 1 ) , 10 ** N ) : <NEWLINE> <INDENT> strnum = str ( i ) <NEWLINE> flag = True <NEWLINE> for j in Query : <NEWLINE> <INDENT> if strnum [ j [ 0 ] - 1 ] != str ( j [ 1 ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= 10 : <NEWLINE> <INDENT> res = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = r + ( 100 * ( 10 - n ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ K - Q ] * N <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> arr [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in arr : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if A_list . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A_list [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> abc = math . gcd ( ab , c ) <NEWLINE> sum = sum + abc <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for j in range ( H ) : <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S [ i ] = list ( S [ i ] ) <NEWLINE> <NL> <DEDENT> if ( H == 1 ) and ( W == 1 ) : <NEWLINE> <INDENT> if S [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> S [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif ( H == 1 ) and ( W != 1 ) : <NEWLINE> <INDENT> for col in range ( W ) : <NEWLINE> <INDENT> if S [ 0 ] [ col ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if col == 0 : <NEWLINE> <INDENT> S [ 0 ] [ col ] = str ( [ S [ 0 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> elif col == W - 1 : <NEWLINE> <INDENT> S [ 0 ] [ col ] = str ( [ S [ 0 ] [ col - 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ 0 ] [ col ] = str ( [ S [ 0 ] [ col - 1 ] , S [ 0 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif ( H != 1 ) and ( W == 1 ) : <NEWLINE> <INDENT> for row in range ( H ) : <NEWLINE> <INDENT> if S [ row ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if row == 0 : <NEWLINE> <INDENT> S [ row ] [ 0 ] = str ( [ S [ row + 1 ] [ 0 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> elif row == H - 1 : <NEWLINE> <INDENT> S [ row ] [ 0 ] = str ( [ S [ row - 1 ] [ 0 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ row ] [ 0 ] = str ( [ S [ row - 1 ] [ 0 ] , S [ row + 1 ] [ 0 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for row in range ( H ) : <NEWLINE> <INDENT> for col in range ( W ) : <NEWLINE> <INDENT> if S [ row ] [ col ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if row == 0 : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row ] [ col + 1 ] , S [ row + 1 ] [ col ] , S [ row + 1 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> elif col == W - 1 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row ] [ col - 1 ] , S [ row + 1 ] [ col - 1 ] , S [ row + 1 ] [ col ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row ] [ col - 1 ] , S [ row ] [ col + 1 ] , S [ row + 1 ] [ col - 1 ] , <NEWLINE> <INDENT> S [ row + 1 ] [ col ] , S [ row + 1 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif row == H - 1 : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col ] , S [ row - 1 ] [ col + 1 ] , S [ row ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> elif col == W - 1 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col - 1 ] , S [ row - 1 ] [ col ] , S [ row ] [ col - 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col - 1 ] , S [ row - 1 ] [ col ] , S [ row - 1 ] [ col + 1 ] , <NEWLINE> <INDENT> S [ row ] [ col - 1 ] , S [ row ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col ] , S [ row - 1 ] [ col + 1 ] , <NEWLINE> <INDENT> S [ row ] [ col + 1 ] , <NEWLINE> S [ row + 1 ] [ col ] , S [ row + 1 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> elif col == W - 1 : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col - 1 ] , S [ row - 1 ] [ col ] , <NEWLINE> <INDENT> S [ row ] [ col - 1 ] , <NEWLINE> S [ row + 1 ] [ col - 1 ] , S [ row + 1 ] [ col ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> S [ row ] [ col ] = str ( [ S [ row - 1 ] [ col - 1 ] , S [ row - 1 ] [ col ] , S [ row - 1 ] [ col + 1 ] , <NEWLINE> <INDENT> S [ row ] [ col - 1 ] , S [ row ] [ col + 1 ] , <NEWLINE> S [ row + 1 ] [ col - 1 ] , S [ row + 1 ] [ col ] , S [ row + 1 ] [ col + 1 ] ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( S [ i ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> <NL> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S *= A [ N - 1 - n ] <NEWLINE> if S > 10 ** 18 : <NEWLINE> <INDENT> S = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_dic = dict ( ) <NEWLINE> a_set = set ( ) <NEWLINE> for num in a : <NEWLINE> <INDENT> if num in a_dic : <NEWLINE> <INDENT> a_dic [ num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dic [ num ] = 1 <NEWLINE> <DEDENT> a_set . add ( num ) <NEWLINE> <DEDENT> k = len ( a_dic ) <NEWLINE> a_set = list ( a_set ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> if 0 in a_dic : <NEWLINE> <INDENT> if a_dic [ 0 ] == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif k == 2 : <NEWLINE> <INDENT> if a_dic [ 0 ] == n / 3 and a_dic [ a_set [ 1 ] ] == 2 * n / 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif k == 3 : <NEWLINE> <INDENT> if a_set [ 0 ] ^ a_set [ 1 ] ^ a_set [ 2 ] == 0 : <NEWLINE> <INDENT> if a_dic [ a_set [ 0 ] ] == a_dic [ a_set [ 1 ] ] == a_dic [ a_set [ 2 ] ] == n / 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> a , * an = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> A += an <NEWLINE> A . sort ( ) <NEWLINE> <NL> Node = [ ] <NEWLINE> score = 0 <NEWLINE> Node . append ( A . pop ( ) ) <NEWLINE> <NL> <COMMENT> <NL> start = 0 <NEWLINE> <NL> for n in range ( N - 1 ) : <NEWLINE> <INDENT> score += Node [ start ] <NEWLINE> num = A . pop ( ) <NEWLINE> start += 1 <NEWLINE> <COMMENT> <NL> Node . append ( num ) <NEWLINE> Node . append ( num ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( score ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> Ans *= a <NEWLINE> if Ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( Ans ) <NEWLINE> <DEDENT> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = 10 ** 6 + 1 <NEWLINE> p = [ 0 ] * k <NEWLINE> m . sort ( ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if m [ i ] == m [ i - 1 ] : <NEWLINE> <INDENT> p [ m [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ m [ i ] ] == 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> if i != n - 1 and m [ i ] != m [ i + 1 ] : <NEWLINE> <INDENT> for j in range ( m [ i ] * 2 , k , m [ i ] ) : <NEWLINE> <INDENT> p [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> score = [ ] <NEWLINE> <NL> j = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> j = next_j <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if j >= n - 1 or h [ j ] < h [ j + 1 ] : <NEWLINE> <INDENT> score . append ( cnt ) <NEWLINE> next_j = j + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h [ j ] >= h [ j + 1 ] <NEWLINE> cnt += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( score ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> mc = [ 0 ] * 2019 <NEWLINE> <NL> tg = 0 <NEWLINE> digit = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> tg += int ( s ) * digit <NEWLINE> mc [ tg % 2019 ] += 1 <NEWLINE> digit = digit * 10 % 2019 <NEWLINE> <NL> <DEDENT> ans = sum ( m * ( m - 1 ) // 2 for m in mc ) <NEWLINE> print ( ans + mc [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> p = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if round ( ( p [ 2 ] - p [ 0 ] ) * ( p [ 7 ] - p [ 5 ] ) - ( p [ 3 ] - p [ 1 ] ) * ( p [ 6 ] - p [ 4 ] ) , 10 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> Q = int ( input ( ) ) <NEWLINE> <NL> S = set ( ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> qtype , number = map ( int , input ( ) . split ( ) ) <NEWLINE> if qtype == 0 : <NEWLINE> <INDENT> S . add ( number ) <NEWLINE> print ( len ( S ) ) <NEWLINE> <DEDENT> elif qtype == 1 : <NEWLINE> <INDENT> if number in S : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif qtype == 2 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> S . remove ( number ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> def swap ( index , swap_with_right ) : <NEWLINE> <INDENT> global p <NEWLINE> <NL> if swap_with_right : <NEWLINE> <INDENT> l = index <NEWLINE> r = index + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = index - 1 <NEWLINE> r = index <NEWLINE> <NL> <DEDENT> pl = p [ l ] <NEWLINE> pr = p [ r ] <NEWLINE> p [ l ] = pr <NEWLINE> p [ r ] = pl <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . insert ( 0 , 0 ) <NEWLINE> ans = 0 <NEWLINE> <NL> if p [ 1 ] == 1 : <NEWLINE> <INDENT> swap ( 1 , True ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i < N : <NEWLINE> <INDENT> if i == p [ i ] and i + 1 == p [ i + 1 ] : <NEWLINE> <INDENT> swap ( i , True ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif i == p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> elif i == p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_a = max ( a ) <NEWLINE> l = [ 0 ] * max_a <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while a [ i ] * j - 1 < max_a : <NEWLINE> <INDENT> l [ a [ i ] * j - 1 ] += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if l [ a [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <DEDENT> print ( f ( min ( N , B - 1 ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S in d . keys ( ) : <NEWLINE> <INDENT> d [ S ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ S ] = 1 <NEWLINE> <DEDENT> <DEDENT> max_val = max ( d . values ( ) ) <NEWLINE> key_list = [ kv [ 0 ] for kv in d . items ( ) if kv [ 1 ] == max_val ] <NEWLINE> for k in sorted ( key_list ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , read ( ) . split ( ) ) <NEWLINE> target = set ( ) <NEWLINE> row = np . zeros ( h , dtype = int ) <NEWLINE> col = np . zeros ( w , dtype = int ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> hi , wi = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> target . add ( ( hi , wi ) ) <NEWLINE> row [ hi ] += 1 <NEWLINE> col [ wi ] += 1 <NEWLINE> <DEDENT> r = np . arange ( h ) [ row == row . max ( ) ] <NEWLINE> c = np . arange ( w ) [ col == col . max ( ) ] <NEWLINE> ans = row . max ( ) + col . max ( ) <NEWLINE> for ri in r : <NEWLINE> <INDENT> for ci in c : <NEWLINE> <INDENT> if ( ri , ci ) not in target : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> a = int ( s [ 1 ] / 10000 ) <NEWLINE> b = int ( s [ 1 ] / 5000 ) <NEWLINE> c = int ( s [ 1 ] / 1000 ) <NEWLINE> for i in range ( 0 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , b + 1 ) : <NEWLINE> <INDENT> if ( s [ 0 ] - i - j >= 0 ) : <NEWLINE> <INDENT> check = 10000 * i + 5000 * j + 1000 * ( s [ 0 ] - i - j ) <NEWLINE> if ( check == s [ 1 ] ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> ans . append ( j ) <NEWLINE> ans . append ( s [ 0 ] - i - j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( ans == [ ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( ans [ 0 ] , ans [ 1 ] , ans [ 2 ] ) ) <NEWLINE> <DEDENT>
data = input ( ) . split ( ) <NEWLINE> a = int ( data [ 0 ] ) <NEWLINE> b = int ( data [ 1 ] ) <NEWLINE> while ( a != 0 or b != 0 ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> temp = a <NEWLINE> a = b <NEWLINE> b = temp <NEWLINE> <DEDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> data = input ( ) . split ( ) <NEWLINE> a = int ( data [ 0 ] ) <NEWLINE> b = int ( data [ 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import itertools <NEWLINE> import numpy <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> zentan = itertools . product ( [ 0 , 1 ] , repeat = n ) <NEWLINE> condi = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ln = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> condi . append ( ln ) <NEWLINE> <DEDENT> min_cost = 10 ** 10 <NEWLINE> for i in zentan : <COMMENT> <NEWLINE> <INDENT> cost = 0 <NEWLINE> skills = [ 0 ] * m <NEWLINE> <COMMENT> <NL> for n1 , n2 in enumerate ( i ) : <COMMENT> <NEWLINE> <INDENT> cost += condi [ n1 ] [ 0 ] * n2 <NEWLINE> <COMMENT> <NL> for n3 in range ( m ) : <COMMENT> <NEWLINE> <INDENT> skills [ n3 ] += condi [ n1 ] [ n3 + 1 ] * n2 <NEWLINE> <DEDENT> <DEDENT> if min ( skills ) >= x and cost < min_cost : <NEWLINE> <INDENT> min_cost = cost <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if min_cost < 10 ** 10 : <NEWLINE> <INDENT> print ( min_cost ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> OK = 10 ** 9 <NEWLINE> NG = 0 <NEWLINE> <NL> while OK - NG > 1 : <NEWLINE> <INDENT> mid = ( OK + NG ) // 2 <NEWLINE> <NL> ANS = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ANS += ( a - 0.01 ) // mid <NEWLINE> <NL> <DEDENT> if ANS <= K : <NEWLINE> <INDENT> OK = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NG = mid <NEWLINE> <DEDENT> <DEDENT> print ( OK ) <NEWLINE>
from operator import itemgetter <NEWLINE> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h_count = [ [ i , 0 ] for i in range ( H ) ] <NEWLINE> w_count = [ [ i , 0 ] for i in range ( W ) ] <NEWLINE> exist = dict ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> h_count [ h ] [ 1 ] += 1 <NEWLINE> w_count [ w ] [ 1 ] += 1 <NEWLINE> exist [ ( h , w ) ] = True <NEWLINE> <NL> <DEDENT> h_count . sort ( key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> w_count . sort ( key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> h_max = h_count [ 0 ] [ 1 ] <NEWLINE> w_max = w_count [ 0 ] [ 1 ] <NEWLINE> res = 0 <NEWLINE> is_dup = True <NEWLINE> for h in h_count : <NEWLINE> <INDENT> if h [ 1 ] != h_max or not is_dup : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for w in w_count : <NEWLINE> <INDENT> if w [ 1 ] != w_max or not is_dup : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> val = h [ 1 ] + w [ 1 ] <NEWLINE> if exist . get ( ( h [ 0 ] , w [ 0 ] ) , False ) : <NEWLINE> <INDENT> val -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> is_dup = False <NEWLINE> <DEDENT> res = max ( res , val ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
input ( ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in x [ : : - 1 ] : <NEWLINE> <INDENT> if i == x [ 0 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 1 for i in range ( n ) ] <NEWLINE> <NL> <NL> now = 0 <NEWLINE> next = a [ now ] - 1 <NEWLINE> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ next ] == 0 : <NEWLINE> <INDENT> d = c [ : c . index ( next ) ] <NEWLINE> e = c [ c . index ( next ) : ] <NEWLINE> <COMMENT> <NL> break <NEWLINE> <COMMENT> <NL> <DEDENT> b [ now ] = 0 <NEWLINE> c . append ( now ) <NEWLINE> next = a [ now ] - 1 <NEWLINE> <COMMENT> <NL> now = next <NEWLINE> <NL> <DEDENT> if k >= len ( d ) : <NEWLINE> <INDENT> k = k - len ( d ) <NEWLINE> k = k % len ( e ) <NEWLINE> print ( e [ k ] + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( d [ k ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> l = { } <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i in l : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] = 1 <NEWLINE> <NL> <DEDENT> res += i <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if B [ i ] in l : <NEWLINE> <INDENT> t = l [ B [ i ] ] <NEWLINE> <NL> <NL> res += ( C [ i ] - B [ i ] ) * t <NEWLINE> <NL> l [ B [ i ] ] = 0 <NEWLINE> if C [ i ] in l : <NEWLINE> <INDENT> l [ C [ i ] ] += t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ C [ i ] ] = t <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> rc = S . count ( <STRING> ) <NEWLINE> bc = S . count ( <STRING> ) <NEWLINE> gc = S . count ( <STRING> ) <NEWLINE> <NL> cnt = rc * bc * gc <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for d in range ( 0 , N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if N < k + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import scipy as sp <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , N + 1 ) : <NEWLINE> <NL> <INDENT> ans += math . gcd ( c , d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in numbers : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for n in numbers : <NEWLINE> <INDENT> result *= n <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> from functools import reduce <NEWLINE> from operator import mul , ior <NEWLINE> <NL> from typing import Callable , ClassVar , Sequence , Type , TypeVar <NEWLINE> <NL> <NL> T = TypeVar ( <STRING> , bound = <STRING> ) <NEWLINE> <NL> <NL> class ModIntBase : <NEWLINE> <INDENT> value : int <NEWLINE> mod : ClassVar [ int ] <NEWLINE> fac : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> inv : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> finv : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> <NL> def __init__ ( self , value : int ) -> None : <NEWLINE> <INDENT> self . value = value % self . mod <NEWLINE> <NL> <DEDENT> def __hash__ ( self ) -> int : <NEWLINE> <INDENT> return hash ( ( self . value , self . mod ) ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) -> bool : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . value == other . value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __ne__ ( self , other ) -> bool : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . value != other . value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( ( self . value + other . value ) % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( ( self . value - other . value ) % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( self . value * other . value % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> a = other . value <NEWLINE> b = self . mod <NEWLINE> u = 1 <NEWLINE> v = 0 <NEWLINE> while b : <NEWLINE> <INDENT> t = a // b <NEWLINE> a , b = b , a - t * b <NEWLINE> u , v = v , u - t * v <NEWLINE> <DEDENT> return self . __class__ ( self . value * u % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> v = 1 <NEWLINE> a = self . value <NEWLINE> b = other . value <NEWLINE> mod = self . mod <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> v = v * a % mod <NEWLINE> <DEDENT> a = a * a % mod <NEWLINE> b >>= 1 <NEWLINE> <DEDENT> return self . __class__ ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def comb ( cls , n : int , k : int ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return cls ( 0 ) <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return cls ( 0 ) <NEWLINE> <NL> <DEDENT> if n < len ( cls . fac ) : <NEWLINE> <INDENT> return cls ( cls . fac [ n ] * ( cls . finv [ k ] * cls . finv [ n - k ] % cls . mod ) % cls . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = min ( k , n - k ) <NEWLINE> a = reduce ( mul , map ( cls , range ( n - k + 1 , n + 1 ) ) , cls ( 1 ) ) <NEWLINE> b = reduce ( mul , map ( cls , range ( 1 , k + 1 ) ) , cls ( 1 ) ) <NEWLINE> return a / b <NEWLINE> <NL> <DEDENT> <DEDENT> def __repr__ ( self ) -> str : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def __str__ ( self ) -> str : <NEWLINE> <INDENT> return str ( self . value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ModInt ( ModIntBase ) : <NEWLINE> <INDENT> mod = 1000000007 <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> def prime_factor ( a , temp ) : <NEWLINE> <INDENT> while a > 1 : <NEWLINE> <INDENT> yield temp [ a ] <NEWLINE> a //= temp [ a ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( in_ ) : <NEWLINE> <INDENT> N = int ( next ( in_ ) ) <NEWLINE> A = tuple ( map ( int , next ( in_ ) . split ( ) ) ) <NEWLINE> <NL> max_a = max ( A ) <NEWLINE> temp = [ 0 ] * ( max_a + 1 ) <NEWLINE> temp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , max_a + 1 ) : <NEWLINE> <INDENT> if temp [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for j in range ( i , max_a + 1 , i ) : <NEWLINE> <INDENT> temp [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> ap_list = ( Counter ( prime_factor ( a , temp ) ) for a in A ) <NEWLINE> lcm = reduce ( ior , ap_list , Counter ( ) ) <NEWLINE> lcm_i = ModInt ( 1 ) <NEWLINE> for v in lcm . elements ( ) : <NEWLINE> <INDENT> lcm_i *= ModInt ( v ) <NEWLINE> <NL> <NL> <DEDENT> ans = ModInt ( 0 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += lcm_i / ModInt ( a ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if m - a not in p : <NEWLINE> <INDENT> print ( m - a ) <NEWLINE> break <NEWLINE> <DEDENT> elif m + a not in p : <NEWLINE> <INDENT> print ( m + a ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> p = 10 ** 9 + 7 <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> ans [ 0 ] = 1 <NEWLINE> ans [ 1 ] = 1 <NEWLINE> <NL> broken = [ 0 ] * ( n + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> broken [ i ] = - 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if broken [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> ans [ i + 1 ] = ans [ i - 1 ] % p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i + 1 ] = ( ans [ i - 1 ] + ans [ i ] ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> agents = { } <NEWLINE> n_pair = 0 <NEWLINE> <NL> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> x = i - a <NEWLINE> if x not in agents : <NEWLINE> <INDENT> agents [ x ] = 0 <NEWLINE> <DEDENT> agents [ x ] += 1 <NEWLINE> <NL> <DEDENT> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> x = i + a <NEWLINE> if x in agents : <NEWLINE> <INDENT> n_pair += agents [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( n_pair ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> hs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> stack = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i , h in enumerate ( hs ) : <NEWLINE> <INDENT> j = - 1 <NEWLINE> while stack and stack [ - 1 ] [ 1 ] > h : <NEWLINE> <INDENT> j , h2 = stack . pop ( ) <NEWLINE> ans = max ( ans , ( i - j ) * h2 ) <NEWLINE> <DEDENT> if not stack or stack [ - 1 ] [ 1 ] < h : <NEWLINE> <INDENT> stack . append ( ( i if j == - 1 else j , h ) ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , max ( ( n - j ) * h2 for j , h2 in stack ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> from enum import Enum , auto <NEWLINE> <NL> INFTY = float ( <STRING> ) <NEWLINE> <NL> class Color ( Enum ) : <NEWLINE> <INDENT> WHITE = auto ( ) <NEWLINE> GRAY = auto ( ) <NEWLINE> BLACK = auto ( ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> adj_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> u , k , * kv = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> adj_list . append ( kv ) <NEWLINE> <NL> <DEDENT> colors = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> def dijkstra ( s ) : <NEWLINE> <INDENT> global d <NEWLINE> colors = [ Color . WHITE for i in range ( n ) ] <NEWLINE> d = [ INFTY for i in range ( n ) ] <NEWLINE> pque = [ ] <NEWLINE> d [ s ] = 0 <NEWLINE> <NL> heappush ( pque , ( 0 , s ) ) <NEWLINE> <NL> while len ( pque ) >= 1 : <NEWLINE> <INDENT> vert_u = heappop ( pque ) <NEWLINE> u = vert_u [ 1 ] <NEWLINE> colors [ u ] = Color . BLACK <NEWLINE> if d [ u ] < vert_u [ 0 ] : continue <NEWLINE> i = 0 <NEWLINE> while i <= len ( adj_list [ u ] ) - 2 : <NEWLINE> <INDENT> v = adj_list [ u ] [ i ] <NEWLINE> if colors [ v ] != Color . BLACK : <NEWLINE> <INDENT> if d [ u ] + adj_list [ u ] [ i + 1 ] < d [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u ] + adj_list [ u ] [ i + 1 ] <NEWLINE> colors [ v ] = Color . GRAY <NEWLINE> heappush ( pque , ( d [ v ] , v ) ) <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dijkstra ( 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( i , d [ i ] ) <NEWLINE> <NL> <DEDENT>
from math import sqrt <NEWLINE> def isPrime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i , xx = 3 , int ( sqrt ( x ) ) <NEWLINE> while i <= xx : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = i + 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( sum ( [ 1 for _ in range ( N ) if isPrime ( int ( input ( ) ) ) ] ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> number = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> number = collections . Counter ( number ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in number : <NEWLINE> <INDENT> print ( number [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from networkx import * <NEWLINE> print ( max ( * map ( len , connected_components ( Graph ( [ * map ( str . split , open ( 0 ) ) ] [ 1 : ] ) ) ) , 1 , 0 ) ) <NEWLINE>
def pow_with_mod ( x , n , m ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> K = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 != 0 : <NEWLINE> <INDENT> K *= x <NEWLINE> K %= m <NEWLINE> <DEDENT> x *= x <NEWLINE> x %= m <NEWLINE> n //= 2 <NEWLINE> <NL> <DEDENT> return ( K * x ) % m <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> S = sys . stdin . readline ( ) . strip ( ) <NEWLINE> N = len ( S ) <NEWLINE> L = [ 0 ] * 2019 <NEWLINE> now = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now += int ( S [ - i - 1 ] ) * pow_with_mod ( 10 , i , 2019 ) <NEWLINE> now %= 2019 <NEWLINE> L [ now ] += 1 <NEWLINE> <DEDENT> print ( L [ 0 ] + sum ( [ x * ( x - 1 ) // 2 for x in L ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 100000 ) <NEWLINE> <NL> def dfs ( i , pre , n , a , ans ) : <NEWLINE> <INDENT> if ( pre * 2 < a [ i ] ) : return - 1 <NEWLINE> ans [ i ] += a [ i ] <NEWLINE> if ( i >= n ) : <NEWLINE> <INDENT> return a [ i ] <NEWLINE> <NL> <DEDENT> pre = pre * 2 - a [ i ] <NEWLINE> u = dfs ( i + 1 , pre , n , a , ans ) ; <NEWLINE> if ( u < 0 or pre * 2 < u ) : return - 1 ; <NEWLINE> ans [ i ] += min ( pre , u ) <NEWLINE> return min ( pre , u ) + a [ i ] <NEWLINE> <NL> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( n == 0 ) : <NEWLINE> <INDENT> if ( a [ 0 ] == 1 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> ans = [ 1 ] + [ 0 ] * n <NEWLINE> u = dfs ( 1 , 1 , n , a , ans ) <NEWLINE> if ( a [ 0 ] != 0 ) : u = - 1 <NEWLINE> <NL> if ( u >= 0 ) : <NEWLINE> <INDENT> print ( sum ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> min_ = min ( list_ ) <NEWLINE> max_ = max ( list_ ) <NEWLINE> num = [ ] <NEWLINE> for a in range ( min_ , max_ ) : <NEWLINE> <INDENT> _ = [ ] <NEWLINE> for b in range ( len ( list_ ) ) : <NEWLINE> <INDENT> _ . append ( ( a - list_ [ b ] ) ** 2 ) <NEWLINE> <DEDENT> num . append ( sum ( _ ) ) <NEWLINE> <DEDENT> if len ( list ( set ( list_ ) ) ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( min ( num ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> amax = a [ - 1 ] + 1 <NEWLINE> dp = [ True ] * amax <NEWLINE> ans_set = set ( ) <NEWLINE> remove_set = set ( ) <NEWLINE> for e in a : <NEWLINE> <INDENT> if dp [ e ] : <NEWLINE> <INDENT> if e in ans_set : <NEWLINE> <INDENT> remove_set . add ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_set . add ( e ) <NEWLINE> for i in range ( e * 2 , amax , e ) : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans_set - remove_set ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumv = 0 <NEWLINE> d = { } <NEWLINE> for i in arr : <NEWLINE> <INDENT> sumv += i <NEWLINE> try : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> while q : <NEWLINE> <NL> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in d : <NEWLINE> <INDENT> sumv += ( c - b ) * d [ b ] <NEWLINE> <NL> try : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> <DEDENT> <DEDENT> d [ b ] = 0 <NEWLINE> print ( sumv ) <NEWLINE> <NL> <NL> q -= 1 <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> <NL> s = 0 <NEWLINE> for k , v in cnt . items ( ) : <NEWLINE> <INDENT> s += int ( k ) * v <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> BC = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if BC [ 0 ] in cnt : <NEWLINE> <INDENT> if BC [ 1 ] in cnt : <NEWLINE> <INDENT> cnt [ BC [ 1 ] ] += cnt [ BC [ 0 ] ] <NEWLINE> s += int ( BC [ 1 ] ) * cnt [ BC [ 0 ] ] <NEWLINE> s -= int ( BC [ 0 ] ) * cnt [ BC [ 0 ] ] <NEWLINE> del cnt [ BC [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ BC [ 1 ] ] = cnt [ BC [ 0 ] ] <NEWLINE> s += int ( BC [ 1 ] ) * cnt [ BC [ 0 ] ] <NEWLINE> s -= int ( BC [ 0 ] ) * cnt [ BC [ 0 ] ] <NEWLINE> del cnt [ BC [ 0 ] ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> heap = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = readline ( ) <NEWLINE> if line [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( heapq . heappop ( heap ) [ 1 ] ) <NEWLINE> <DEDENT> elif line [ 2 ] == <STRING> : <NEWLINE> <INDENT> n = int ( line . split ( ) [ 1 ] ) <NEWLINE> heapq . heappush ( heap , ( - n , n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> def solve ( H , W , CH , CW , DH , DW , S ) : <NEWLINE> <COMMENT> <NL> <INDENT> S = [ <STRING> . format ( row ) for row in S ] <NEWLINE> S . insert ( 0 , <STRING> . format ( <STRING> * W ) ) <NEWLINE> S . insert ( 0 , <STRING> . format ( <STRING> * W ) ) <NEWLINE> S . append ( <STRING> . format ( <STRING> * W ) ) <NEWLINE> S . append ( <STRING> . format ( <STRING> * W ) ) <NEWLINE> <NL> <NL> MAX_COST = 10 ** 9 <NEWLINE> Cost = [ [ MAX_COST for _ in range ( W + 4 ) ] for _ in range ( H + 4 ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> ans = - 1 <NEWLINE> <NL> cost0 = deque ( ) <NEWLINE> <NL> cost0 . append ( ( CH + 1 , CW + 1 , 0 ) ) <NEWLINE> Cost [ CH + 1 ] [ CW + 1 ] = 0 ; <NEWLINE> <NL> <COMMENT> <NL> walk = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> warp = [ ( i , j ) for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) if ( i , j ) not in [ ( 0 , 0 ) ] + walk ] <NEWLINE> <COMMENT> <NL> <NL> cost1 = deque ( ) <NEWLINE> <NL> while cost0 : <NEWLINE> <INDENT> h , w , c = cost0 . popleft ( ) <NEWLINE> cost1 . append ( ( h , w , c ) ) <NEWLINE> <NL> for i , j in walk : <NEWLINE> <INDENT> dh = h + i <NEWLINE> dw = w + j <NEWLINE> if S [ dh ] [ dw ] == <STRING> and c < Cost [ dh ] [ dw ] : <NEWLINE> <INDENT> Cost [ dh ] [ dw ] = c <NEWLINE> <COMMENT> <NL> cost0 . appendleft ( ( dh , dw , Cost [ dh ] [ dw ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( cost0 ) == 0 : <NEWLINE> <NL> <INDENT> while cost1 : <NEWLINE> <INDENT> h , w , c = cost1 . popleft ( ) <NEWLINE> <COMMENT> <NL> for i , j in warp : <NEWLINE> <INDENT> dh = h + i <NEWLINE> dw = w + j <NEWLINE> <COMMENT> <NL> if S [ dh ] [ dw ] == <STRING> and c + 1 < Cost [ dh ] [ dw ] : <NEWLINE> <INDENT> Cost [ dh ] [ dw ] = c + 1 <NEWLINE> cost0 . append ( ( dh , dw , Cost [ dh ] [ dw ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if Cost [ DH + 1 ] [ DW + 1 ] == MAX_COST : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Cost [ DH + 1 ] [ DW + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> CH , CW = map ( int , input ( ) . split ( ) ) <NEWLINE> DH , DW = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> solve ( H , W , CH , CW , DH , DW , S ) <NEWLINE> <DEDENT>
def add_memo ( tate , yoko ) : <NEWLINE> <INDENT> global memo <NEWLINE> if 2 <= tate <= h - 1 : <NEWLINE> <INDENT> if 2 <= yoko <= w - 1 : <NEWLINE> <INDENT> memo . append ( [ tate , yoko ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> memo = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> add_memo ( x - 1 , y - 1 ) <NEWLINE> add_memo ( x - 1 , y ) <NEWLINE> add_memo ( x - 1 , y + 1 ) <NEWLINE> add_memo ( x , y - 1 ) <NEWLINE> add_memo ( x , y ) <NEWLINE> add_memo ( x , y + 1 ) <NEWLINE> add_memo ( x + 1 , y - 1 ) <NEWLINE> add_memo ( x + 1 , y ) <NEWLINE> add_memo ( x + 1 , y + 1 ) <NEWLINE> <NL> <DEDENT> memo . sort ( ) <NEWLINE> ans = [ 0 ] * 10 <NEWLINE> ans [ 0 ] = ( h - 2 ) * ( w - 2 ) <NEWLINE> tmp_x = 0 <NEWLINE> tmp_y = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , len ( memo ) ) : <NEWLINE> <INDENT> if tmp_x == memo [ i ] [ 0 ] and tmp_y == memo [ i ] [ 1 ] : <NEWLINE> <INDENT> ans [ count ] -= 1 <NEWLINE> count += 1 <NEWLINE> ans [ count ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 0 ] -= 1 <NEWLINE> count = 1 <NEWLINE> ans [ count ] += 1 <NEWLINE> <DEDENT> tmp_x = memo [ i ] [ 0 ] <NEWLINE> tmp_y = memo [ i ] [ 1 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = A [ : : - 1 ] <NEWLINE> <NL> mod_n = 10 ** 9 + 7 <NEWLINE> <NL> cum_A = [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> cum_A . append ( cum_A [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> cum_B = cum_A [ : : - 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * cum_B [ i ] % mod_n <NEWLINE> <NL> <DEDENT> print ( ans % mod_n ) <NEWLINE>
n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if A . count ( 0 ) == 0 : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> [ N , W ] = input ( ) . split ( <STRING> ) <NEWLINE> N = int ( N ) <NEWLINE> W = int ( W ) <NEWLINE> inputset = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> [ vi , wi ] = input ( ) . split ( <STRING> ) <NEWLINE> inputset . append ( [ int ( vi ) , int ( wi ) ] ) <NEWLINE> <NL> <DEDENT> graph = [ ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> graph . append ( [ ] ) <NEWLINE> for j in range ( W + 1 ) : <NEWLINE> <INDENT> graph [ i ] . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> if ( inputset [ i ] [ 1 ] > j ) : <NEWLINE> <INDENT> graph [ i + 1 ] [ j ] = graph [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = j - inputset [ i ] [ 1 ] <NEWLINE> choosevalue = graph [ i ] [ rest ] + inputset [ i ] [ 0 ] <NEWLINE> nonchoosevalue = graph [ i ] [ j ] <NEWLINE> if ( choosevalue > nonchoosevalue ) : <NEWLINE> <INDENT> graph [ i + 1 ] [ j ] = choosevalue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> graph [ i + 1 ] [ j ] = nonchoosevalue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( graph [ N ] [ W ] ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> l . append ( s ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
sieve = [ 0 ] * 1000009 <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if sieve [ i ] < 2 : <NEWLINE> <INDENT> for j in range ( i , 1000009 , i ) : sieve [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( sieve [ i ] == 1 for i in s ) ) <NEWLINE>
input_number = int ( input ( ) ) <NEWLINE> int_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> check = 10 ** 18 <NEWLINE> ans = int_list [ 0 ] <NEWLINE> for i in int_list [ 1 : ] : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <NL> if ans > check : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in int_list : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UFTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . N = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , n ) : <NEWLINE> <INDENT> if self . parents [ n ] < 0 : return n <NEWLINE> else : <NEWLINE> <INDENT> self . parents [ n ] = self . root ( self . parents [ n ] ) <NEWLINE> return self . parents [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx , ry = self . root ( x ) , self . root ( y ) <NEWLINE> if rx == ry : return <NEWLINE> if rx > ry : rx , ry = ry , rx <NEWLINE> self . parents [ rx ] += self . parents [ ry ] <NEWLINE> self . parents [ ry ] = rx <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uft = UFTree ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uft . unite ( A - 1 , B - 1 ) <NEWLINE> <DEDENT> print ( max ( [ uft . size ( i ) for i in range ( N ) ] ) ) <NEWLINE>
def call ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> res . append ( str ( i ) ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> res . append ( str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( res ) ) <NEWLINE> <NL> <DEDENT> call ( int ( input ( ) ) ) <NEWLINE>
<COMMENT> <NL> def soinsu_bunkai ( m ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> <NL> for i in range ( 2 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> m //= i <NEWLINE> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> pf [ m ] = 1 <NEWLINE> <DEDENT> return pf <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> def cmb ( n , r , p ) : <NEWLINE> <NL> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> from collections import Counter <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> p = mod <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = soinsu_bunkai ( M ) <NEWLINE> ans = 1 <NEWLINE> <NL> n = 10 ** 5 + 100 <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> for i in a . values ( ) : <NEWLINE> <INDENT> x = cmb ( N + i - 1 , i , mod ) <NEWLINE> ans *= x <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> bef = 0 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> val = a [ i ] <NEWLINE> bef = a [ i - k ] <NEWLINE> if val > bef : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> bef = val <NEWLINE> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if H [ i ] > H [ i + 1 ] : <NEWLINE> <INDENT> H [ i ] -= 1 <NEWLINE> if H [ i ] > H [ i + 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if H [ i - 1 ] > H [ i ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif H [ i - 1 ] <= H [ i ] - 1 : <NEWLINE> <INDENT> H [ i ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( arg ) for arg in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 3600 % 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ 0 ] * 10050 <NEWLINE> <NL> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a < 10050 : <NEWLINE> <INDENT> A [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( A [ i + 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 10 ** 6 + 1 <NEWLINE> memo = [ 0 ] * max <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> memo [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , max ) : <NEWLINE> <INDENT> if sum ( memo [ i : : i ] ) > 1 : <NEWLINE> <INDENT> if reduce ( math . gcd , a_list ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def div ( n ) : <NEWLINE> <INDENT> low , high = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> low . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> high . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return low + high [ : : - 1 ] <NEWLINE> <DEDENT> S = div ( N ) <NEWLINE> ans = 0 <NEWLINE> S = S [ 1 : ] <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if N % ( i - 1 ) == N // ( i - 1 ) : <NEWLINE> <INDENT> ans += i - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bom_set = set ( ) <NEWLINE> h_dict = { } <NEWLINE> w_dict = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hh , ww = map ( int , input ( ) . split ( ) ) <NEWLINE> bom_set . add ( tuple ( [ hh , ww ] ) ) <NEWLINE> if hh in h_dict : <NEWLINE> <INDENT> h_dict [ hh ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h_dict [ hh ] = 1 <NEWLINE> <DEDENT> if ww in w_dict : <NEWLINE> <INDENT> w_dict [ ww ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w_dict [ ww ] = 1 <NEWLINE> <DEDENT> <DEDENT> h_max_count = max ( h_dict . values ( ) ) <NEWLINE> w_max_count = max ( w_dict . values ( ) ) <NEWLINE> hh_dict = { } <NEWLINE> ww_dict = { } <NEWLINE> for hh in h_dict : <NEWLINE> <INDENT> if h_dict [ hh ] == h_max_count : <NEWLINE> <INDENT> hh_dict [ hh ] = h_max_count <NEWLINE> <DEDENT> <DEDENT> for ww in w_dict : <NEWLINE> <INDENT> if w_dict [ ww ] == w_max_count : <NEWLINE> <INDENT> ww_dict [ ww ] = w_max_count <NEWLINE> <DEDENT> <DEDENT> flag = 0 <NEWLINE> for hh in hh_dict : <NEWLINE> <INDENT> for ww in ww_dict : <NEWLINE> <INDENT> if tuple ( [ hh , ww ] ) not in bom_set : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( h_max_count + w_max_count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h_max_count + w_max_count - 1 ) <NEWLINE> <DEDENT>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( e ) ) : <NEWLINE> <INDENT> ans += o [ i ] + e [ i ] <NEWLINE> <DEDENT> if len ( o ) != len ( e ) : <NEWLINE> <INDENT> ans += o [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> v = 0 <NEWLINE> mods = { } <NEWLINE> mods [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> v += int ( c ) * d <NEWLINE> <COMMENT> <NL> v %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> try : <NEWLINE> <INDENT> mods [ v ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> mods [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for n in mods . values ( ) : <NEWLINE> <INDENT> ans += ( n * ( n - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> <NL> <NL> def permutations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // math . factorial ( n - r ) <NEWLINE> <NL> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , ( a % b ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> K = int ( input ( ) ) <NEWLINE> data = [ k + 1 for k in range ( K ) ] <NEWLINE> result = list ( itertools . combinations_with_replacement ( data , 3 ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for r in result : <NEWLINE> <INDENT> r0 , r1 , r2 = r <NEWLINE> g0 = gcd ( r0 , r1 ) <NEWLINE> g = gcd ( g0 , r2 ) <NEWLINE> if r0 == r1 == r2 : <NEWLINE> <INDENT> s += g <NEWLINE> <DEDENT> elif r0 != r1 and r1 != r2 : <NEWLINE> <INDENT> s += g * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += g * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> num = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> kotae = 0 <NEWLINE> temp = 0 <NEWLINE> a = { } <NEWLINE> b = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> temp = i - num [ i ] <NEWLINE> if ( temp in a ) : <NEWLINE> <INDENT> a [ temp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ temp ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> temp = i + num [ i ] <NEWLINE> if ( temp in b ) : <NEWLINE> <INDENT> b [ temp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ temp ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 200000 ) : <NEWLINE> <INDENT> if ( ( i in a ) and ( i in b ) ) : <NEWLINE> <INDENT> kotae += a [ i ] * b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( kotae ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> A = 0 <NEWLINE> B = int ( - X ** ( 1 / 5 ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> ans = A ** 5 - B ** 5 <NEWLINE> if ans == X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans < X : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> elif ans > X : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( A , B ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ab [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 100500 ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> uf . union ( ab [ i ] [ 0 ] - 1 , ab [ i ] [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
INF = int ( 1e18 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , * A , = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if INF < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def main2 ( ) : <NEWLINE> <INDENT> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_books = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_books = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( len ( a_books ) ) : <NEWLINE> <INDENT> a . append ( a [ i ] + a_books [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( b_books ) ) : <NEWLINE> <INDENT> b . append ( b [ i ] + b_books [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , len ( b_books ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> x = <STRING> + x <NEWLINE> <NL> x = int ( x , 0 ) <NEWLINE> m = bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> if m > 1 : <NEWLINE> <INDENT> a = x % ( m - 1 ) <NEWLINE> <DEDENT> b = x % ( m + 1 ) <NEWLINE> tmp_a = 1 <NEWLINE> tmp_b = 1 <NEWLINE> xx = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( x >> i ) & 1 : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> xx . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = ( a - tmp_a ) % ( m - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> y = ( b + tmp_b ) % ( m + 1 ) <NEWLINE> <DEDENT> tmp_a *= 2 <NEWLINE> if m > 1 : <NEWLINE> <INDENT> tmp_a %= ( m - 1 ) <NEWLINE> <DEDENT> tmp_b *= 2 <NEWLINE> tmp_b %= ( m + 1 ) <NEWLINE> <NL> cnt = 1 <NEWLINE> while y != 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> y = solve ( y ) <NEWLINE> <DEDENT> xx . append ( cnt ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( xx [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> m = bin ( n ) . count ( <STRING> ) <NEWLINE> return n % m <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> N_sum = [ ] <NEWLINE> for A in range ( 1 , int ( N / 2 ) + 1 ) : <NEWLINE> <INDENT> B = N - A <NEWLINE> N_sum . append ( sum ( map ( int , str ( A ) + str ( B ) ) ) ) <NEWLINE> <DEDENT> print ( min ( N_sum ) ) <NEWLINE>
<NL> from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> base = [ <STRING> * ( w + 4 ) ] <NEWLINE> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> for n in range ( h ) : <NEWLINE> <INDENT> base . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> ans = [ [ - 1 ] * ( w + 4 ) for _ in range ( h + 4 ) ] <NEWLINE> for i in range ( h + 4 ) : <NEWLINE> <INDENT> for j in range ( w + 4 ) : <NEWLINE> <INDENT> if base [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ch += 1 <NEWLINE> cw += 1 <NEWLINE> dh += 1 <NEWLINE> dw += 1 <NEWLINE> <NL> ans [ ch ] [ cw ] = 0 <NEWLINE> move1 = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> move2 = [ <NEWLINE> <INDENT> [ - 2 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 2 , 2 ] , [ - 1 , - 2 ] , [ - 1 , - 1 ] , <NEWLINE> [ - 1 , 1 ] , [ - 1 , 2 ] , [ 0 , - 2 ] , [ 0 , 2 ] , [ 1 , - 2 ] , [ 1 , - 1 ] , [ 1 , 1 ] , <NEWLINE> [ 1 , 2 ] , [ 2 , - 2 ] , [ 2 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] <NEWLINE> <DEDENT> ] <NEWLINE> q1 = deque ( [ [ ch , cw ] ] ) <NEWLINE> q2 = deque ( [ ] ) <NEWLINE> <NL> while q1 : <NEWLINE> <INDENT> x1 , y1 = q1 . popleft ( ) <NEWLINE> q2 . append ( [ x1 , y1 ] ) <NEWLINE> for i , j in move1 : <NEWLINE> <INDENT> nx , ny = x1 + i , y1 + j <NEWLINE> <STRING> <NEWLINE> if ans [ nx ] [ ny ] == - 1 : <NEWLINE> <INDENT> ans [ nx ] [ ny ] = ans [ x1 ] [ y1 ] <NEWLINE> q1 . append ( [ nx , ny ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( q1 ) == 0 : <NEWLINE> <INDENT> while q2 : <NEWLINE> <INDENT> x2 , y2 = q2 . popleft ( ) <NEWLINE> for i , j in move2 : <NEWLINE> <INDENT> mx , my = x2 + i , y2 + j <NEWLINE> <STRING> <NEWLINE> if ans [ mx ] [ my ] == - 1 : <NEWLINE> <INDENT> ans [ mx ] [ my ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> q1 . append ( [ mx , my ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ dh ] [ dw ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = g = b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> res = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if 0 <= k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> n = X <NEWLINE> div = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> div . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> div . append ( n // i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in div : <NEWLINE> <INDENT> for a in range ( 0 , 10001 ) : <NEWLINE> <INDENT> b = a - i <NEWLINE> <COMMENT> <NL> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ism ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def isl ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> <NL> n , k = iim ( ) <NEWLINE> A = iil ( ) <NEWLINE> d = { 0 : True } <NEWLINE> l = [ 0 ] <NEWLINE> def move ( num ) : <NEWLINE> <INDENT> l . append ( A [ num ] - 1 ) <NEWLINE> if d . get ( A [ num ] - 1 , False ) : <NEWLINE> <INDENT> return True if A [ num ] - 1 == 0 else False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ num ] - 1 ] = True <NEWLINE> return move ( A [ num ] - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if move ( 0 ) : <NEWLINE> <INDENT> rep = len ( l ) - 1 <NEWLINE> ini = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ini = l . index ( l [ - 1 ] ) <NEWLINE> rep = len ( l ) - ini - 1 <NEWLINE> <NL> <DEDENT> if k <= ini : <NEWLINE> <INDENT> print ( l [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = ( k - ini ) % rep <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> mod = rep <NEWLINE> <COMMENT> <NL> <DEDENT> print ( l [ ini + mod ] + 1 ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> seq = list ( range ( 1 , M + 1 ) ) <NEWLINE> dlist = defaultdict ( list ) <NEWLINE> dres = defaultdict ( int ) <NEWLINE> Na = 0 <NEWLINE> <NL> for i , v in enumerate ( itertools . combinations_with_replacement ( seq , N ) ) : <NEWLINE> <INDENT> dlist [ i ] = v <NEWLINE> Na += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> ai , bi , ci , di = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( Na ) : <NEWLINE> <INDENT> tmp = dlist [ j ] <NEWLINE> if tmp [ bi - 1 ] - tmp [ ai - 1 ] == ci : <NEWLINE> <INDENT> dres [ j ] += di <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( [ dres [ i ] for i in range ( Na ) ] ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( n , b - 1 ) <NEWLINE> print ( int ( a * ( x % b ) / b ) ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> line = <STRING> + ( <STRING> * ( W - 2 ) ) + <STRING> <NEWLINE> for i in range ( 0 , H - 2 ) : <NEWLINE> <INDENT> print ( line ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - A <NEWLINE> sum += A <NEWLINE> <NL> <DEDENT> if B >= K : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - B <NEWLINE> <NL> <DEDENT> print ( sum - K ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> def gcd ( a , b , c ) : <NEWLINE> <INDENT> s = math . gcd ( a , b ) <NEWLINE> s = math . gcd ( s , c ) <NEWLINE> return s <NEWLINE> <DEDENT> t = 0 <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> s = math . gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( K ) : <NEWLINE> <INDENT> t += math . gcd ( c + 1 , s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
<COMMENT> <NL> def sell ( asset , price ) : <NEWLINE> <INDENT> return price * asset [ 1 ] + asset [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> def buy ( money , price ) : <NEWLINE> <INDENT> stock = money // price <NEWLINE> remainder = money % price <NEWLINE> <NL> return ( remainder , stock ) <NEWLINE> <NL> <NL> <DEDENT> from collections import deque <NEWLINE> import copy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> assets = deque ( ) <NEWLINE> assets . append ( ( 1000 , 0 ) ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> new_assets = deque ( ) <NEWLINE> max_money = 0 <NEWLINE> <NL> for a in assets : <NEWLINE> <INDENT> max_money = max ( max_money , sell ( a , A [ i ] ) ) <NEWLINE> <NL> <DEDENT> assets . append ( ( max_money , 0 ) ) <NEWLINE> assets . append ( buy ( max_money , A [ i ] ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for a in assets : <NEWLINE> <INDENT> ans = max ( ans , sell ( a , A [ N - 1 ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> mod = 998244353 <NEWLINE> <NL> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> DP = np . zeros ( 3005 , dtype = np . int64 ) <NEWLINE> <NL> for num , a in enumerate ( A ) : <NEWLINE> <INDENT> double = DP * 2 <NEWLINE> shift = np . hstack ( [ np . zeros ( a ) , DP [ : - a ] ] ) . astype ( np . int64 ) <NEWLINE> DP = double + shift <NEWLINE> DP [ a ] += pow ( 2 , num , mod ) <NEWLINE> DP %= mod <NEWLINE> <NL> <DEDENT> print ( DP [ s ] ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] * ( H + 1 ) <NEWLINE> w = [ 0 ] * ( W + 1 ) <NEWLINE> l = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ x ] += 1 <NEWLINE> w [ y ] += 1 <NEWLINE> l . add ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> c = max ( h ) <NEWLINE> d = max ( w ) <NEWLINE> a = [ i for i , x in enumerate ( h ) if x == c ] <NEWLINE> b = [ i for i , x in enumerate ( w ) if x == d ] <NEWLINE> <NL> flag = False <NEWLINE> for s in a : <NEWLINE> <INDENT> for t in b : <NEWLINE> <INDENT> if ( s , t ) not in l : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = c + d <NEWLINE> if not flag : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = MAP ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B > N : <NEWLINE> <INDENT> a = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = B - 1 <NEWLINE> <DEDENT> judge = math . floor ( A * a / B ) - A * math . floor ( a / B ) <NEWLINE> print ( judge ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def bfs ( s ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> check = [ - 1 ] * ( n + 1 ) <NEWLINE> check [ s ] = 0 <NEWLINE> q = deque ( [ s ] ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for next in graph [ now ] : <NEWLINE> <INDENT> if check [ next ] == - 1 : <NEWLINE> <INDENT> check [ next ] = now <NEWLINE> q . append ( next ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return check <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , readline ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for v in bfs ( 1 ) [ 2 : ] : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( a ) <NEWLINE> count = [ 0 for _ in range ( m + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if count [ i ] != 0 : <NEWLINE> <INDENT> count [ i ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( 2 * i , m + 1 , i ) : <NEWLINE> <INDENT> count [ j ] = 1 <NEWLINE> <DEDENT> count [ i ] = 2 <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> if count [ i ] != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = 0 <NEWLINE> number = 0 <NEWLINE> <COMMENT> <NL> m = [ 0 ] * 2019 <NEWLINE> m [ 0 ] = 1 <NEWLINE> a = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> t = t + int ( s [ len ( s ) - 1 - i ] ) * a <NEWLINE> <COMMENT> <NL> m [ t % 2019 ] += 1 <NEWLINE> a = a * 10 <NEWLINE> a = a % 2019 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for j in range ( 2019 ) : <NEWLINE> <COMMENT> <NL> <INDENT> number += ( m [ j ] * ( m [ j ] - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( number ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import collections <NEWLINE> <NL> mod = 2019 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> lenS = len ( S ) <NEWLINE> Smod2019 = [ 0 ] * lenS <NEWLINE> tmp = 0 <NEWLINE> for i in range ( lenS ) : <NEWLINE> <INDENT> tmp += ( pow ( 10 , i , mod ) * int ( S [ - ( i + 1 ) ] ) ) % mod <NEWLINE> Smod2019 [ i ] = tmp % mod <NEWLINE> <NL> <DEDENT> cnt = collections . Counter ( Smod2019 ) <NEWLINE> cntitems = cnt . items ( ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for c in cntitems : <NEWLINE> <INDENT> if c [ 0 ] == 0 : <NEWLINE> <INDENT> ans += c [ 1 ] <NEWLINE> <DEDENT> ans += ( c [ 1 ] * ( c [ 1 ] - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def kochCurve ( p1 , p2 , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> print ( p2 [ 0 ] , p2 [ 1 ] ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> v = [ ( p2 [ 0 ] - p1 [ 0 ] ) / 3 , ( p2 [ 1 ] - p1 [ 1 ] ) / 3 ] <NEWLINE> s = [ p1 [ 0 ] + v [ 0 ] , p1 [ 1 ] + v [ 1 ] ] <NEWLINE> t = [ s [ 0 ] + v [ 0 ] , s [ 1 ] + v [ 1 ] ] <NEWLINE> <NL> theta = math . atan2 ( v [ 1 ] , v [ 0 ] ) + math . pi / 2 <NEWLINE> <NL> a = math . sqrt ( ( t [ 0 ] - s [ 0 ] ) ** 2 + ( t [ 1 ] - s [ 1 ] ) ** 2 ) <NEWLINE> h = 3 ** ( 1 / 2 ) * a / 2 <NEWLINE> u = [ s [ 0 ] + ( t [ 0 ] - s [ 0 ] ) / 2 + h * math . cos ( theta ) , s [ 1 ] + ( t [ 1 ] - s [ 1 ] ) / 2 + h * math . sin ( theta ) ] <NEWLINE> <NL> n -= 1 <NEWLINE> kochCurve ( p1 , s , n ) <NEWLINE> kochCurve ( s , u , n ) <NEWLINE> kochCurve ( u , t , n ) <NEWLINE> kochCurve ( t , p2 , n ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( 0 , 0 ) <NEWLINE> kochCurve ( [ 0 , 0 ] , [ 100 , 0 ] , n ) <NEWLINE> <DEDENT>
import math <NEWLINE> c = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> for i in range ( 2 , int ( math . sqrt ( t ) + 1 ) ) : <NEWLINE> <INDENT> if t % i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e6 ) ) <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> source , target = map ( int , v_detail ) <NEWLINE> init_adj_table [ source ] . append ( target ) <NEWLINE> init_adj_table [ target ] . append ( source ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def Tarjan ( current , parents , visited , disc , low ) : <NEWLINE> <INDENT> global timer <NEWLINE> current_children_count = 0 <NEWLINE> visited [ current ] = True <NEWLINE> disc [ current ] = low [ current ] = timer <NEWLINE> timer += 1 <NEWLINE> <NL> for adj in adj_table [ current ] : <NEWLINE> <INDENT> if not visited [ adj ] : <NEWLINE> <INDENT> parents [ adj ] = current <NEWLINE> current_children_count += 1 <NEWLINE> <NL> Tarjan ( adj , parents , visited , disc , low ) <NEWLINE> <NL> low [ current ] = min ( low [ current ] , low [ adj ] ) <NEWLINE> <COMMENT> <NL> if parents [ current ] == - 1 and current_children_count > 1 : <NEWLINE> <INDENT> art_set . add ( current ) <NEWLINE> <NL> <DEDENT> elif parents [ current ] != - 1 and low [ adj ] >= disc [ current ] : <NEWLINE> <INDENT> art_set . add ( current ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif adj != parents [ current ] : <NEWLINE> <INDENT> low [ current ] = min ( low [ current ] , disc [ adj ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def art_points ( ) : <NEWLINE> <INDENT> parents = [ - 1 ] * vertices <NEWLINE> visited = [ False ] * vertices <NEWLINE> disc = [ float ( <STRING> ) ] * vertices <NEWLINE> low = [ float ( <STRING> ) ] * vertices <NEWLINE> <NL> for v in range ( vertices ) : <NEWLINE> <INDENT> Tarjan ( v , parents , visited , disc , low ) <NEWLINE> <NL> <DEDENT> return art_set <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> timer = 0 <NEWLINE> art_set = set ( ) <NEWLINE> ans = art_points ( ) <NEWLINE> if ans : <NEWLINE> <INDENT> print ( * sorted ( ans ) , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
M , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if ( sum ( x ) ) > M : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif ( sum ( x ) == M ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( sum ( x ) < M ) : <NEWLINE> <INDENT> print ( M - sum ( x ) ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = a * x // b - a * ( x // b ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> md = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> cnt_memo = [ 0 ] * ( K + 1 ) <NEWLINE> cnt_R_memo = [ 0 ] * ( K + 1 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> cnt_R_memo [ k ] = pow ( K // k , N , md ) <NEWLINE> <DEDENT> for k in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> cnt_memo [ k ] = ( cnt_R_memo [ k ] - sum ( cnt_memo [ 2 * k : : k ] ) ) % md <NEWLINE> ret += ( cnt_memo [ k ] * k ) % md <NEWLINE> <DEDENT> print ( ret % md ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( n , a ) : <NEWLINE> <INDENT> s = a [ 0 ] + a [ 1 ] <NEWLINE> z = 0 <NEWLINE> for ai in a [ 2 : ] : <NEWLINE> <INDENT> z ^= ai <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if s - z < 0 or ( s - z ) % 2 == 1 : return - 1 <NEWLINE> d = ( s - z ) // 2 <NEWLINE> if d & z != 0 : return - 1 <NEWLINE> if not d <= a [ 0 ] : return - 1 <NEWLINE> part = [ ] <NEWLINE> i = 0 <NEWLINE> while z // pow ( 2 , i ) : <NEWLINE> <INDENT> if ( z // pow ( 2 , i ) ) % 2 == 1 : part . append ( pow ( 2 , i ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> ans = float ( <STRING> ) <NEWLINE> k = len ( part ) <NEWLINE> x = 0 <NEWLINE> while part : <NEWLINE> <INDENT> tmp = part . pop ( ) <NEWLINE> if d ^ ( x + tmp ) <= a [ 0 ] : <NEWLINE> <INDENT> x += tmp <NEWLINE> <DEDENT> <DEDENT> return a [ 0 ] - ( d ^ x ) if d ^ x else - 1 <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( main ( n , a ) ) <NEWLINE>
class Dice ( ) : <NEWLINE> <INDENT> def __init__ ( self , label ) : <NEWLINE> <INDENT> self . d = label <NEWLINE> <NL> <DEDENT> def roll ( self , drt ) : <NEWLINE> <INDENT> if drt == <STRING> : <NEWLINE> <INDENT> self . d [ 1 ] , self . d [ 2 ] , self . d [ 6 ] , self . d [ 5 ] = self . d [ 2 ] , self . d [ 6 ] , self . d [ 5 ] , self . d [ 1 ] <NEWLINE> <DEDENT> elif drt == <STRING> : <NEWLINE> <INDENT> self . d [ 1 ] , self . d [ 3 ] , self . d [ 6 ] , self . d [ 4 ] = self . d [ 4 ] , self . d [ 1 ] , self . d [ 3 ] , self . d [ 6 ] <NEWLINE> <DEDENT> elif drt == <STRING> : <NEWLINE> <INDENT> self . d [ 2 ] , self . d [ 6 ] , self . d [ 5 ] , self . d [ 1 ] = self . d [ 1 ] , self . d [ 2 ] , self . d [ 6 ] , self . d [ 5 ] <NEWLINE> <DEDENT> elif drt == <STRING> : <NEWLINE> <INDENT> self . d [ 4 ] , self . d [ 1 ] , self . d [ 3 ] , self . d [ 6 ] = self . d [ 1 ] , self . d [ 3 ] , self . d [ 6 ] , self . d [ 4 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def printl ( self , lct ) : <NEWLINE> <INDENT> print ( self . d [ lct ] ) <NEWLINE> <NL> <DEDENT> def rot ( self , drc ) : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> if drc == <STRING> : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif drc == <STRING> : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> self . roll ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> label = [ 0 ] <NEWLINE> label . extend ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dice1 = Dice ( label ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> ST = <STRING> <NEWLINE> SF = <STRING> <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( 7 ) : <NEWLINE> <INDENT> if dice1 . d [ 1 ] == s [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice1 . roll ( ST [ j ] ) <NEWLINE> <DEDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if dice1 . d [ 2 ] == s [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice1 . rot ( SF [ k ] ) <NEWLINE> <DEDENT> dice1 . printl ( 3 ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( r ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> list [ i ] . append ( sum ( list [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> print ( list [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( list [ i ] [ c ] ) <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> a += list [ j ] [ i ] <NEWLINE> <DEDENT> print ( a , end = <STRING> ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> a += list [ j ] [ c ] <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans [ a [ i ] ] += 1 <NEWLINE> <DEDENT> ans = ans [ 1 : ] <NEWLINE> ansstr = <STRING> <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ None ] * N <NEWLINE> A = [ None for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C [ i ] , * A [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 10 ** 12 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> tmp = [ 0 ] * M <NEWLINE> tmpC = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> for k in range ( M ) : <NEWLINE> <INDENT> tmp [ k ] += A [ j ] [ k ] <NEWLINE> <DEDENT> tmpC += C [ j ] <NEWLINE> <DEDENT> <DEDENT> flag = True <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> if tmp [ k ] < X : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = min ( ans , tmpC ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 10 ** 12 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> mod = 998244353 <NEWLINE> dp2 = [ 0 ] * n <NEWLINE> dp2 [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp2 [ i ] += dp2 [ i - 1 ] <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> if i - l >= 0 : <NEWLINE> <INDENT> dp2 [ i ] += dp2 [ i - l ] <NEWLINE> <DEDENT> elif i - l < 0 and i - r >= 0 : <NEWLINE> <INDENT> dp2 [ i ] += dp2 [ 0 ] <NEWLINE> <DEDENT> if i - r - 1 >= 0 : <NEWLINE> <INDENT> dp2 [ i ] -= dp2 [ i - r - 1 ] <NEWLINE> <DEDENT> <DEDENT> dp2 [ i ] %= mod <NEWLINE> <DEDENT> print ( ( dp2 [ - 1 ] - dp2 [ - 2 ] ) % mod ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( W * H / 2 , int ( ( x + x == W and y + y == H ) ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 and len ( s ) == 1 : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif i == 0 and s [ 1 ] == <STRING> : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif i == 0 and s [ 1 ] == <STRING> : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif i == 0 and s [ 1 ] == <STRING> : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> and ( i == len ( s ) - 1 ) : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> and ( i < len ( s ) - 1 and ( s [ i + 1 ] == <STRING> or s [ i + 1 ] == <STRING> ) ) : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> A = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> maxdiff = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> R = tuple ( A ) <NEWLINE> <NL> Dmax = R [ 1 ] - R [ 0 ] <NEWLINE> Rmin = R [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if R [ i ] >= R [ i - 1 ] : <NEWLINE> <INDENT> if R [ i ] - Rmin > Dmax : <NEWLINE> <INDENT> Dmax = R [ i ] - Rmin <NEWLINE> <DEDENT> <DEDENT> if R [ i ] < Rmin : <NEWLINE> <INDENT> Rmin = R [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( Dmax ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> tmp = input ( ) . split ( <STRING> ) <NEWLINE> <NL> list = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> list . append ( int ( tmp [ i ] ) ) <NEWLINE> <NL> <DEDENT> answer = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> answer [ list [ i ] ] += 1 <NEWLINE> <DEDENT> answer . append ( 0 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( answer [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import collections <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> mod_list = [ 0 ] <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> index = len ( S ) - i - 1 <NEWLINE> num = int ( S [ index ] ) <NEWLINE> <NL> mod_list . append ( ( mod_list [ - 1 ] + num * pow ( 10 , i , 2019 ) ) % 2019 ) <NEWLINE> <NL> <DEDENT> CTR_mod_list = collections . Counter ( mod_list ) . most_common ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( len ( CTR_mod_list ) ) : <NEWLINE> <INDENT> n = CTR_mod_list [ i ] [ 1 ] <NEWLINE> <NL> if ( n == 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cnt += n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> p *= i <NEWLINE> <COMMENT> <NL> if p > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - ( k - ( a + b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if n . count ( n [ 0 ] ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> while n != <STRING> : <NEWLINE> <INDENT> L , S = list ( n ) , list ( n ) <NEWLINE> L . sort ( reverse = True ) <NEWLINE> S . sort ( ) <NEWLINE> n = str ( int ( <STRING> . join ( L ) ) - int ( <STRING> . join ( S ) ) ) . zfill ( 4 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= c [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> out = 1 <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> out = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> out *= i <NEWLINE> if out > 1e18 : <NEWLINE> <INDENT> out = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R = [ [ ] for _ in range ( n ) ] <NEWLINE> sign = [ 0 for _ in range ( n - 1 ) ] <NEWLINE> dp = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R [ a - 1 ] . append ( b ) <NEWLINE> R [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> start = deque ( ) <NEWLINE> start . append ( 0 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> while start : <NEWLINE> <INDENT> s = start . popleft ( ) <NEWLINE> for r in R [ s ] : <NEWLINE> <INDENT> if dp [ r - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sign [ r - 2 ] = s + 1 <NEWLINE> start . append ( r - 1 ) <NEWLINE> dp [ r - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in sign : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for s in sign : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
number = int ( input ( ) ) <NEWLINE> character = input ( ) <NEWLINE> rnumber = character . count ( <STRING> ) <NEWLINE> gnumber = character . count ( <STRING> ) <NEWLINE> bnumber = character . count ( <STRING> ) <NEWLINE> count = rnumber * gnumber * bnumber <NEWLINE> <NL> for j in range ( 1 , number ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= number : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if character [ i ] == character [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if character [ i ] == character [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if character [ j ] == character [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def cal ( a , b ) : <NEWLINE> <INDENT> return a ** 5 - b ** 5 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> update = True <NEWLINE> for i in range ( 10 ** 3 ) : <NEWLINE> <INDENT> for j in range ( 10 ** 3 ) : <NEWLINE> <INDENT> if cal ( i , j ) == X : <NEWLINE> <INDENT> a , b = i , j <NEWLINE> update = False <NEWLINE> break <NEWLINE> <DEDENT> if cal ( i , - j ) == X : <NEWLINE> <INDENT> a , b = i , - j <NEWLINE> update = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not update : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> out = 0 <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> x = 0 <NEWLINE> now = 1 <NEWLINE> for i in S [ : : - 1 ] : <NEWLINE> <INDENT> x += now * int ( i ) <NEWLINE> x %= 2019 <NEWLINE> l [ x ] += 1 <NEWLINE> <NL> now *= 10 <NEWLINE> now %= 2019 <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> out += ( i - 1 ) * i // 2 <NEWLINE> <DEDENT> print ( out + l [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for h in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( h , gcd ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from math import isinf <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e5 ) ) <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> v_from , v_to = map ( int , v_detail ) <NEWLINE> init_adj_table [ v_from ] . append ( v_to ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def Tarjan ( current , low , dfn , scc_stack , in_scc_stack ) : <NEWLINE> <INDENT> global timer <NEWLINE> dfn [ current ] = low [ current ] = timer <NEWLINE> timer += 1 <NEWLINE> <NL> scc_stack . append ( current ) <NEWLINE> in_scc_stack [ current ] = True <NEWLINE> <NL> current_scc_set = set ( ) <NEWLINE> for adj in adj_table [ current ] : <NEWLINE> <INDENT> if isinf ( dfn [ adj ] ) : <NEWLINE> <INDENT> Tarjan ( adj , low , dfn , scc_stack , in_scc_stack ) <NEWLINE> low [ current ] = min ( low [ current ] , low [ adj ] ) <NEWLINE> <NL> <DEDENT> elif in_scc_stack [ adj ] : <NEWLINE> <INDENT> low [ current ] = min ( low [ current ] , dfn [ adj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> scc_candidate = - 1 <NEWLINE> if dfn [ current ] == low [ current ] : <NEWLINE> <INDENT> while scc_candidate != current : <NEWLINE> <INDENT> scc_candidate = scc_stack . pop ( ) <NEWLINE> in_scc_stack [ scc_candidate ] = False <NEWLINE> current_scc_set . add ( scc_candidate ) <NEWLINE> <NL> <DEDENT> init_scc_sets_list . append ( current_scc_set ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def scc_cluster ( ) : <NEWLINE> <INDENT> dfn = [ float ( <STRING> ) ] * vertices <NEWLINE> low = [ float ( <STRING> ) ] * vertices <NEWLINE> scc_stack = list ( ) <NEWLINE> in_scc_stack = [ False ] * vertices <NEWLINE> <NL> for v in range ( vertices ) : <NEWLINE> <INDENT> if isinf ( dfn [ v ] ) : <NEWLINE> <INDENT> Tarjan ( v , low , dfn , scc_stack , in_scc_stack ) <NEWLINE> <NL> <DEDENT> <DEDENT> return init_scc_sets_list <NEWLINE> <NL> <NL> <DEDENT> def solve ( _scc_sets_list ) : <NEWLINE> <INDENT> for question in q_list : <NEWLINE> <INDENT> flag = False <NEWLINE> ele1 , ele2 = map ( int , question ) <NEWLINE> for each in _scc_sets_list : <NEWLINE> <INDENT> if ( ele1 in each ) and ( ele2 in each ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : edges + 1 ] ) <NEWLINE> q_num = int ( _input [ edges + 1 ] ) <NEWLINE> q_list = map ( lambda x : x . split ( ) , _input [ edges + 2 : ] ) <NEWLINE> <NL> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> timer = 0 <NEWLINE> init_scc_sets_list = [ ] <NEWLINE> scc_sets_list = scc_cluster ( ) <NEWLINE> <NL> solve ( scc_sets_list ) <NEWLINE> <DEDENT>
N , M , K = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> sumA = [ 0 ] * ( N + 1 ) <NEWLINE> sumB = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sumA [ i + 1 ] = sumA [ i ] + A [ i ] <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> sumB [ i + 1 ] = sumB [ i ] + B [ i ] <NEWLINE> <NL> <DEDENT> b_i = M <NEWLINE> max_count = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> a = sumA [ i ] <NEWLINE> if a > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if b_i > 0 : <NEWLINE> <INDENT> while a + sumB [ b_i ] > K : <NEWLINE> <INDENT> b_i -= 1 <NEWLINE> if b_i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> max_count = max ( max_count , i + b_i ) <NEWLINE> <DEDENT> print ( max_count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt = n // i <NEWLINE> tt = cnt * ( cnt + 1 ) * i // 2 <NEWLINE> ret += tt <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> x = set ( ) <NEWLINE> y = set ( ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> x . add ( b ) <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> y . add ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if x & y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_cumsum = [ 0 ] + list ( accumulate ( a ) ) <NEWLINE> b_cumsum = [ 0 ] + list ( accumulate ( b ) ) <NEWLINE> j = m <NEWLINE> res = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_cumsum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a_cumsum [ i ] + b_cumsum [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if ( v : = i + j ) > res : <NEWLINE> <INDENT> res = v <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , D , A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> monsters = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> monsters . sort ( ) <NEWLINE> X = [ m [ 0 ] for m in monsters ] <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> damages = [ 0 ] * ( N + 1 ) <NEWLINE> for n , monster in enumerate ( monsters ) : <NEWLINE> <INDENT> x , h = monster <NEWLINE> h = max ( 0 , h - damages [ n ] ) <NEWLINE> to_n = bisect . bisect_right ( X , x + 2 * D ) <NEWLINE> cnt = ( h + A - 1 ) // A <COMMENT> <NEWLINE> ans += cnt <NEWLINE> damages [ n ] += A * cnt <NEWLINE> damages [ to_n ] -= A * cnt <NEWLINE> damages [ n + 1 ] += damages [ n ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
alpha = input ( ) <NEWLINE> <NL> large = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> small = [ i . lower ( ) for i in large ] <NEWLINE> <NL> if alpha in large : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> v . sort ( ) <NEWLINE> <NL> if v [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for l in v : <NEWLINE> <INDENT> ans *= l <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return int ( a * x / b ) - a * int ( x / b ) <NEWLINE> <DEDENT> print ( f ( min ( b - 1 , n ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> root = [ 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t = a [ root [ i ] - 1 ] <NEWLINE> if ( t == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ root [ i ] - 1 ] = 0 <NEWLINE> root . append ( t ) <NEWLINE> <DEDENT> x = root . index ( root [ - 1 ] ) <NEWLINE> bef = root [ 0 : x ] <NEWLINE> <COMMENT> <NL> loop = root [ x : - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if ( k < len ( bef ) ) : <NEWLINE> <INDENT> print ( bef [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = ( ( k - len ( bef ) ) % len ( loop ) ) <NEWLINE> <COMMENT> <NL> print ( loop [ p ] ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ x ] <NEWLINE> checkA = { x } <NEWLINE> ans = x <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> buf = A [ i - 1 ] * A [ i - 1 ] % m <NEWLINE> if buf in checkA : <NEWLINE> <INDENT> idx = A . index ( buf ) <NEWLINE> back = len ( A ) - idx <NEWLINE> nokori = n - len ( A ) <NEWLINE> sumKurikaeshi = sum ( A [ idx : ] ) <NEWLINE> ans += int ( nokori / back ) * sumKurikaeshi <NEWLINE> last = nokori % back <NEWLINE> ans += sum ( A [ idx : idx + last ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( buf ) <NEWLINE> checkA . add ( buf ) <NEWLINE> ans += buf <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> pear = 0 <NEWLINE> <NL> i_result = { } <NEWLINE> j_result = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> result = str ( i + int ( A [ i ] ) ) <NEWLINE> if result in i_result : <NEWLINE> <INDENT> i_result [ result ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i_result [ result ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> result = str ( j - int ( A [ j ] ) ) <NEWLINE> if result in j_result : <NEWLINE> <INDENT> j_result [ result ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j_result [ result ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k in i_result . keys ( ) : <NEWLINE> <INDENT> if k in j_result : <NEWLINE> <INDENT> pear += ( i_result [ k ] * j_result [ k ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( pear ) <NEWLINE>
n = input ( ) <NEWLINE> if n [ 0 ] == <STRING> or n [ 1 ] == <STRING> or n [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A , B , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> x , y , c = [ ] , [ ] , [ ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> tmp = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x . append ( tmp [ 0 ] ) <NEWLINE> y . append ( tmp [ 1 ] ) <NEWLINE> c . append ( tmp [ 2 ] ) <NEWLINE> <NL> <DEDENT> prices = [ ] <NEWLINE> <NL> prices . append ( min ( a ) + min ( b ) ) <NEWLINE> <NL> for k in range ( M ) : <NEWLINE> <INDENT> prices . append ( a [ x [ k ] - 1 ] + b [ y [ k ] - 1 ] - c [ k ] ) <NEWLINE> <NL> <DEDENT> print ( min ( prices ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == N : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> if 2 not in a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <NL> <INDENT> x = a [ x - 1 ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <NL> if x == 2 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = i_map ( ) <NEWLINE> <NL> def prime_decomposition ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <COMMENT> <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> table . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> table . append ( n ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> a = set ( prime_decomposition ( a ) ) <NEWLINE> b = set ( prime_decomposition ( b ) ) <NEWLINE> print ( len ( a & b ) + 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> x , y , z = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if x == 0 and y == 0 and z == 0 : break <NEWLINE> data = [ ] <NEWLINE> for i in range ( 1 , z ) : <NEWLINE> <INDENT> t1 = i + int ( i * x / 100 ) <NEWLINE> for j in range ( 1 , z - t1 + 1 ) : <NEWLINE> <INDENT> t2 = j + int ( j * x / 100 ) <NEWLINE> if t1 + t2 == z : data . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in data : <NEWLINE> <INDENT> temp = k [ 0 ] + int ( k [ 0 ] * y / 100 ) + k [ 1 ] + int ( k [ 1 ] * y / 100 ) <NEWLINE> if temp > ans : ans = temp <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import numba <NEWLINE> <NL> @ numba . njit ( <STRING> , cache = True ) <NEWLINE> def pow_numba ( a , r , mod ) : <NEWLINE> <INDENT> r %= ( mod - 1 ) <NEWLINE> res = 1 <NEWLINE> while r : <NEWLINE> <INDENT> if r % 2 : <NEWLINE> <INDENT> res = res * a % mod <NEWLINE> <DEDENT> a = a * a % mod <NEWLINE> r //= 2 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> @ numba . njit ( <STRING> , cache = True ) <NEWLINE> def egcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b , 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g , y , x = egcd ( b % a , a ) <NEWLINE> return g , x - ( b // a ) * y , y <NEWLINE> <NL> <DEDENT> <DEDENT> @ numba . njit ( <STRING> , cache = True ) <NEWLINE> def get_table ( mod , n_max ) : <NEWLINE> <INDENT> f = 1 <NEWLINE> fac = [ f ] <NEWLINE> for i in range ( 1 , n_max + 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> fac . append ( f ) <NEWLINE> <COMMENT> <NL> <DEDENT> f = pow_numba ( f , - 1 , mod ) <NEWLINE> facinv = [ f ] <NEWLINE> for i in range ( n_max , 0 , - 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> facinv . append ( f ) <NEWLINE> <DEDENT> facinv . reverse ( ) <NEWLINE> return np . array ( fac ) , np . array ( facinv ) <NEWLINE> <NL> <DEDENT> @ numba . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( K , N ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> fac , facinv = get_table ( mod , 2020202 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> a = fac [ N + K - 1 - i ] * facinv [ N - 1 ] % mod * facinv [ K - i ] % mod <NEWLINE> a = a * pow_numba ( 25 , K - i , mod ) % mod * pow_numba ( 26 , i , mod ) % mod <NEWLINE> ans += a <NEWLINE> <DEDENT> return ans % mod <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> print ( solve ( K , N ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if k <= l else s [ l ] ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = Counter ( a ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if B in A . keys ( ) : <NEWLINE> <INDENT> if C in A . keys ( ) : <NEWLINE> <INDENT> A [ C ] += A [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ C ] = A [ B ] <NEWLINE> <DEDENT> ans += ( C - B ) * A [ B ] <NEWLINE> A [ B ] = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += i * n * ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> s = int ( input ( ) ) <NEWLINE> h = int ( s / 3600 ) <NEWLINE> m = int ( ( s % 3600 ) / 60 ) <NEWLINE> s = ( s % 3600 ) % 60 <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
def cmb ( n , r , p ) : <NEWLINE> <INDENT> r = min ( r , n - r ) <NEWLINE> upper = 1 <NEWLINE> for i in range ( n , n - r , - 1 ) : <NEWLINE> <INDENT> upper = ( upper * i ) % p <NEWLINE> <NL> <DEDENT> lower = 1 <NEWLINE> for i in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> lower = ( lower * i ) % p <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return ( upper * pow ( lower , p - 2 , p ) ) % p <NEWLINE> <NL> <DEDENT> mod = pow ( 10 , 9 ) + 7 <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ( pow ( 2 , n , mod ) - 1 - cmb ( n , a , mod ) - cmb ( n , b , mod ) ) % mod <NEWLINE> print ( ans ) <NEWLINE>
N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ 0 ] + list ( range ( N - 1 , 0 , - 1 ) ) <NEWLINE> X , Y = min ( X , Y ) , max ( X , Y ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> if i <= X : <NEWLINE> <INDENT> if j >= Y : <NEWLINE> <INDENT> d [ j - i ] -= 1 <NEWLINE> d [ j - Y + X - i + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j > ( X + Y ) / 2 : <NEWLINE> <INDENT> d [ j - i ] -= 1 <NEWLINE> d [ X - i + 1 + Y - j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i - X + abs ( j - Y ) + 1 < j - i : <NEWLINE> <INDENT> d [ j - i ] -= 1 <NEWLINE> d [ i - X + abs ( j - Y ) + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = abs ( A - B ) <NEWLINE> if L / ( V - W ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from math import isinf <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e5 ) ) <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> v_from , v_to = map ( int , v_detail ) <NEWLINE> init_adj_table [ v_from ] . append ( v_to ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def Tarjan ( current , low , disc , scc_stack , in_scc_stack ) : <NEWLINE> <INDENT> global timer <NEWLINE> disc [ current ] = low [ current ] = timer <NEWLINE> timer += 1 <NEWLINE> <NL> <COMMENT> <NL> in_scc_stack [ current ] = True <NEWLINE> scc_stack . append ( current ) <NEWLINE> <NL> current_scc_set = set ( ) <NEWLINE> for adj in adj_table [ current ] : <NEWLINE> <INDENT> if isinf ( disc [ adj ] ) : <NEWLINE> <INDENT> Tarjan ( adj , low , disc , scc_stack , in_scc_stack ) <NEWLINE> low [ current ] = min ( low [ current ] , low [ adj ] ) <NEWLINE> <NL> <DEDENT> elif in_scc_stack [ adj ] : <NEWLINE> <INDENT> low [ current ] = min ( low [ current ] , disc [ adj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> scc_candidate = - 1 <NEWLINE> if disc [ current ] == low [ current ] : <NEWLINE> <INDENT> while scc_candidate != current : <NEWLINE> <INDENT> scc_candidate = scc_stack . pop ( ) <NEWLINE> current_scc_set . add ( scc_candidate ) <NEWLINE> <COMMENT> <NL> in_scc_stack [ scc_candidate ] = False <NEWLINE> <NL> <DEDENT> init_scc_sets_list . append ( current_scc_set ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def scc ( ) : <NEWLINE> <INDENT> disc = [ float ( <STRING> ) ] * vertices <NEWLINE> low = [ float ( <STRING> ) ] * vertices <NEWLINE> <COMMENT> <NL> scc_stack = list ( ) <NEWLINE> in_scc_stack = [ False ] * vertices <NEWLINE> <NL> for v in range ( vertices ) : <NEWLINE> <INDENT> if isinf ( disc [ v ] ) : <NEWLINE> <INDENT> Tarjan ( v , low , disc , scc_stack , in_scc_stack ) <NEWLINE> <NL> <DEDENT> <DEDENT> return init_scc_sets_list <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> for question in q_list : <NEWLINE> <INDENT> flag = False <NEWLINE> ele1 , ele2 = map ( int , question ) <NEWLINE> for each in scc_sets_list : <NEWLINE> <INDENT> if ( ele1 in each ) and ( ele2 in each ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : edges + 1 ] ) <NEWLINE> q_num = int ( _input [ edges + 1 ] ) <NEWLINE> q_list = map ( lambda x : x . split ( ) , _input [ edges + 2 : ] ) <NEWLINE> <NL> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> timer = 0 <NEWLINE> init_scc_sets_list = [ ] <NEWLINE> scc_sets_list = scc ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> aL = sorted ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> bcL = sorted ( [ list ( map ( int , <NEWLINE> <INDENT> input ( ) . split ( <STRING> ) ) ) for _ in range ( m ) ] , <NEWLINE> key = lambda x : x [ 1 ] , <NEWLINE> reverse = True ) <NEWLINE> <NL> <DEDENT> csl = 0 <NEWLINE> for cnt , point in bcL : <NEWLINE> <INDENT> for i in range ( cnt ) : <NEWLINE> <INDENT> if csl == n or aL [ csl ] >= point : <NEWLINE> <INDENT> print ( sum ( aL ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> aL [ csl ] = point <NEWLINE> csl += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( aL ) ) <NEWLINE> exit ( ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * n <NEWLINE> visited [ 0 ] = True <NEWLINE> <NL> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> <NL> for i in graph [ now ] : <NEWLINE> <INDENT> if visited [ i ] : continue <NEWLINE> <NL> visited [ i ] = True <NEWLINE> ans [ i ] = now <NEWLINE> q . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <DEDENT>
A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> minn = min ( a ) + min ( b ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> minn = min ( minn , a [ List [ i ] [ 0 ] - 1 ] + b [ List [ i ] [ 1 ] - 1 ] - List [ i ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> print ( minn ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a_i = [ i - aa for i , aa in enumerate ( a ) ] <NEWLINE> a_j = [ j + aa for j , aa in enumerate ( a ) ] <NEWLINE> <NL> ci = collections . Counter ( a_i ) <NEWLINE> cj = collections . Counter ( a_j ) <NEWLINE> ans = 0 <NEWLINE> for item , value in ci . items ( ) : <NEWLINE> <INDENT> if item in cj . keys ( ) : <NEWLINE> <INDENT> ans += cj [ item ] * ci [ item ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = LI ( ) <NEWLINE> <NL> anss = [ ] <NEWLINE> ans_base = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans_base ^= a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> anss . append ( ans_base ^ a [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> anss = map ( str , anss ) <NEWLINE> print ( <STRING> . join ( anss ) ) <NEWLINE>
import math <NEWLINE> available_set = { 6 , 11 , 17 , 18 , 24 , 25 , 27 , 33 , 34 , 35 , 38 , 43 , 44 , 45 , 47 , 51 , 54 , 55 , 57 , 58 , 61 , 66 , 67 , 68 , 69 , 71 , 72 , 73 , 77 , 81 , 82 , 83 , 85 , 86 , 87 , 89 , 90 , 95 , 96 , 97 , 99 , 100 , 102 , 103 , 105 , 108 , 109 , 113 , 114 , 115 , 117 , 118 , 119 , 121 , 122 , 123 , 125 , 129 , 130 , 131 , 132 , 133 , 135 , 136 , 137 , 139 , 140 , 141 , 143 , 145 , 146 , 147 , 150 , 151 , 152 , 153 , 154 , 157 , 159 , 161 , 162 , 163 , 166 , 169 , 171 , 172 , 173 , 175 , 176 , 177 , 178 , 179 , 180 , 181 , 183 , 185 , 187 , 188 , 191 , 193 , 194 , 195 , 197 , 198 , 199 , 201 , 202 , 203 , 204 , 205 , 207 , 209 , 210 , 213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 , 223 , 225 , 227 , 228 , 229 , 232 , 233 , 234 , 235 , 237 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 249 , 250 , 251 , 253 , 255 , 257 , 258 , 261 , 262 , 263 , 264 , 265 , 266 , 267 , 268 , 269 , 271 , 272 , 273 , 274 , 275 , 276 , 277 , 278 , 279 , 281 , 283 , 284 , 285 , 287 , 288 , 289 , 291 , 292 , 293 , 294 , 295 , 297 , 298 , 299 , 301 , 303 , 306 , 307 , 308 , 310 , 311 , 313 , 315 , 319 , 321 , 322 , 323 , 324 , 325 , 326 , 327 , 328 , 329 , 330 , 331 , 332 , 333 , 335 , 337 , 339 , 340 , 342 , 343 , 344 , 345 , 346 , 347 , 348 , 349 , 353 , 354 , 355 , 356 , 357 , 358 , 359 , 360 , 361 , 362 , 363 , 365 , 367 , 369 , 370 , 373 , 374 , 375 , 377 , 378 , 379 , 380 , 383 , 384 , 385 , 386 , 387 , 388 , 389 , 390 , 391 , 393 , 394 , 395 , 396 , 397 , 400 , 402 , 403 , 405 , 407 , 408 , 409 , 411 , 412 , 415 , 417 , 418 , 419 , 420 , 421 , 422 , 423 , 425 , 426 , 427 , 429 , 431 , 432 , 433 , 434 , 435 , 436 , 437 , 438 , 439 , 441 , 442 , 443 , 445 , 447 , 449 , 450 , 451 , 452 , 453 , 454 , 455 , 456 , 457 , 458 , 459 , 460 , 461 , 463 , 465 , 466 , 467 , 468 , 471 , 472 , 473 , 474 , 475 , 476 , 477 , 481 , 482 , 483 , 484 , 485 , 486 , 487 , 488 , 489 , 490 , 491 , 492 , 493 , 495 , 497 , 498 , 499 , 500 , 501 , 502 , 503 , 505 , 506 , 507 , 509 , 511 , 513 , 514 , 515 , 516 , 517 , 519 , 520 , 521 , 522 , 523 , 524 , 525 , 527 , 528 , 529 , 531 , 532 , 533 , 534 , 535 , 537 , 538 , 539 , 540 , 543 , 544 , 545 , 547 , 548 , 549 , 550 , 551 , 553 , 555 , 556 , 557 , 559 , 560 , 561 , 562 , 563 , 564 , 565 , 566 , 567 , 569 , 570 , 571 , 572 , 573 , 575 , 577 , 578 , 579 , 580 , 581 , 582 , 583 , 584 , 585 , 586 , 587 , 588 , 591 , 593 , 594 , 595 , 597 , 598 , 599 , 600 , 601 , 602 , 603 , 604 , 605 , 607 , 608 , 609 , 610 , 611 , 612 , 613 , 615 , 616 , 617 , 618 , 619 , 621 , 625 , 626 , 627 , 628 , 630 , 631 , 633 , 634 , 635 , 636 , 637 , 639 , 641 , 642 , 643 , 644 , 645 , 646 , 647 , 648 , 649 , 650 , 651 , 652 , 653 , 655 , 657 , 658 , 661 , 662 , 663 , 664 , 665 , 666 , 667 , 671 , 673 , 674 , 675 , 676 , 677 , 678 , 679 , 681 , 682 , 683 , 684 , 685 , 687 , 688 , 689 , 690 , 691 , 692 , 693 , 694 , 695 , 697 , 698 , 699 , 700 , 701 , 703 , 704 , 705 , 706 , 707 , 708 , 709 , 710 , 711 , 712 , 713 , 715 , 716 , 717 , 719 , 720 , 722 , 723 , 724 , 725 , 726 , 727 , 729 , 730 , 731 , 732 , 733 , 735 , 737 , 738 , 739 , 740 , 741 , 742 , 743 , 745 , 747 , 748 , 749 , 751 , 752 , 753 , 754 , 755 , 757 , 759 , 761 , 762 , 763 , 764 , 765 , 769 , 770 , 771 , 772 , 773 , 774 , 775 , 776 , 777 , 778 , 779 , 780 , 781 , 783 , 785 , 786 , 787 , 788 , 789 , 790 , 791 , 792 , 793 , 795 , 796 , 797 , 799 , 801 , 802 , 803 , 804 , 805 , 806 , 807 , 808 , 809 , 810 , 811 , 812 , 813 , 815 , 816 , 817 , 818 , 819 , 820 , 821 , 822 , 823 , 825 , 826 , 827 , 828 , 829 , 831 , 833 , 834 , 835 , 836 , 837 , 838 , 839 , 840 , 841 , 842 , 843 , 845 , 847 , 849 , 850 , 851 , 852 , 853 , 854 , 855 , 856 , 857 , 858 , 859 , 860 , 861 , 863 , 864 , 865 , 866 , 867 , 868 , 869 , 871 , 872 , 873 , 874 , 875 , 876 , 877 , 879 , 880 , 881 , 882 , 883 , 885 , 886 , 887 , 889 , 891 , 892 , 893 , 895 , 897 , 898 , 899 , 900 , 901 , 902 , 903 , 906 , 907 , 908 , 909 , 911 , 912 , 913 , 914 , 915 , 916 , 917 , 918 , 919 , 921 , 922 , 923 , 925 , 927 , 928 , 929 , 930 , 931 , 932 , 933 , 934 , 935 , 936 , 937 , 938 , 939 , 940 , 941 , 943 , 945 , 946 , 947 , 948 , 949 , 950 , 951 , 953 , 954 , 955 , 957 , 959 , 961 , 962 , 963 , 964 , 965 , 966 , 967 , 968 , 969 , 970 , 971 , 972 , 973 , 975 , 976 , 977 , 978 , 979 , 980 , 981 , 982 , 983 , 984 , 985 , 987 , 988 , 989 , 991 , 993 , 994 , 995 , 996 , 997 , 998 , 999 , 1000 , 1002 , 1003 , 1004 , 1005 , 1007 , 1009 , 1010 , 1011 , 1012 , 1013 , 1014 , 1015 , 1017 , 1018 , 1019 , 1020 , 1021 , 1023 , 1025 , 1026 , 1027 , 1028 , 1029 , 1030 , 1032 , 1033 , 1034 , 1035 , 1037 , 1039 , 1041 , 1042 , 1043 , 1044 , 1045 , 1046 , 1048 , 1049 , 1050 , 1051 , 1052 , 1053 , 1055 , 1056 , 1057 , 1058 , 1059 , 1060 , 1061 , 1062 , 1063 , 1064 , 1065 , 1066 , 1067 , 1068 , 1069 , 1071 , 1072 , 1073 , 1074 , 1075 , 1076 , 1077 , 1078 , 1079 , 1081 , 1083 , 1084 , 1085 , 1087 , 1088 , 1089 , 1090 , 1091 , 1092 , 1093 , 1095 , 1096 , 1097 , 1098 , 1099 , 1100 , 1101 , 1103 , 1104 , 1105 , 1107 , 1108 , 1109 , 1111 , 1112 , 1113 , 1114 , 1116 , 1117 , 1119 , 1121 , 1122 , 1123 , 1124 , 1125 , 1126 , 1127 , 1129 , 1130 , 1131 , 1132 , 1133 , 1135 , 1136 , 1137 , 1138 , 1139 , 1140 , 1141 , 1142 , 1143 , 1145 , 1146 , 1147 , 1148 , 1149 , 1151 , 1152 , 1153 , 1154 , 1155 , 1156 , 1157 , 1158 , 1159 , 1161 , 1162 , 1163 , 1164 , 1165 , 1167 , 1168 , 1169 , 1170 , 1171 , 1172 , 1173 , 1174 , 1175 , 1176 , 1177 , 1178 , 1179 , 1180 , 1181 , 1183 , 1185 , 1186 , 1187 , 1188 , 1189 , 1190 , 1191 , 1192 , 1193 , 1195 , 1196 , 1197 , 1199 , 1201 , 1202 , 1203 , 1204 , 1205 , 1206 , 1207 , 1209 , 1210 , 1211 , 1212 , 1213 , 1215 , 1217 , 1218 , 1219 , 1221 , 1222 , 1223 , 1224 , 1225 , 1226 , 1227 , 1228 , 1229 , 1231 , 1232 , 1233 , 1234 , 1235 , 1237 , 1238 , 1239 , 1240 , 1241 , 1242 , 1243 , 1244 , 1245 , 1247 , 1249 , 1250 , 1251 , 1252 , 1253 , 1254 , 1255 , 1257 , 1258 , 1259 , 1260 , 1261 , 1263 , 1265 , 1266 , 1267 , 1269 , 1270 , 1271 , 1273 , 1274 , 1275 , 1276 , 1277 , 1279 , 1281 , 1282 , 1283 , 1284 , 1285 , 1287 , 1288 , 1289 , 1290 , 1291 , 1292 , 1293 , 1295 , 1296 , 1297 , 1298 , 1299 , 1300 , 1301 , 1302 , 1303 , 1304 , 1305 , 1306 , 1307 , 1308 , 1309 , 1311 , 1312 , 1313 , 1314 , 1315 , 1316 , 1317 , 1318 , 1319 , 1320 , 1321 , 1322 , 1323 , 1324 , 1325 , 1327 , 1328 , 1329 , 1330 , 1331 , 1332 , 1333 , 1334 , 1335 , 1337 , 1338 , 1339 , 1340 , 1341 , 1343 , 1345 , 1346 , 1347 , 1348 , 1349 , 1350 , 1351 , 1353 , 1354 , 1355 , 1356 , 1357 , 1359 , 1360 , 1361 , 1362 , 1363 , 1365 , 1366 , 1367 , 1368 , 1369 , 1370 , 1371 , 1372 , 1373 , 1375 , 1376 , 1377 , 1378 , 1379 , 1380 , 1381 , 1382 , 1383 , 1384 , 1385 , 1386 , 1387 , 1388 , 1389 , 1391 , 1392 , 1393 , 1394 , 1395 , 1396 , 1398 , 1399 , 1401 , 1402 , 1403 , 1405 , 1407 , 1410 , 1411 , 1412 , 1413 , 1414 , 1415 , 1416 , 1417 , 1419 , 1420 , 1421 , 1423 , 1424 , 1425 , 1426 , 1427 , 1428 , 1429 , 1430 , 1431 , 1432 , 1433 , 1434 , 1435 , 1436 , 1437 , 1440 , 1441 , 1442 , 1443 , 1444 , 1445 , 1446 , 1447 , 1448 , 1449 , 1450 , 1451 , 1452 , 1453 , 1455 , 1457 , 1458 , 1459 , 1460 , 1461 , 1462 , 1463 , 1465 , 1466 , 1467 , 1468 , 1469 , 1471 , 1473 , 1474 , 1475 , 1476 , 1477 , 1478 , 1479 , 1480 , 1481 , 1482 , 1483 , 1485 , 1487 , 1489 , 1490 , 1491 , 1492 , 1493 , 1494 , 1495 , 1496 , 1497 , 1498 , 1499 , 1500 , 1501 , 1503 , 1505 , 1506 , 1507 , 1508 , 1509 , 1510 , 1511 , 1512 , 1513 , 1514 , 1515 , 1516 , 1517 , 1519 , 1520 , 1521 , 1522 , 1523 , 1525 , 1527 , 1529 , 1530 , 1531 , 1532 , 1533 , 1535 , 1536 , 1537 , 1538 , 1539 , 1540 , 1541 , 1542 , 1543 , 1544 , 1545 , 1546 , 1547 , 1548 , 1549 , 1551 , 1552 , 1553 , 1554 , 1555 , 1556 , 1557 , 1558 , 1559 , 1560 , 1561 , 1562 , 1563 , 1564 , 1565 , 1567 , 1569 , 1570 , 1571 , 1572 , 1573 , 1574 , 1575 , 1576 , 1577 , 1578 , 1579 , 1580 , 1581 , 1583 , 1584 , 1585 , 1587 , 1588 , 1589 , 1591 , 1593 , 1594 , 1595 , 1597 , 1599 , 1600 , 1601 , 1602 , 1603 , 1605 , 1606 , 1607 , 1608 , 1609 , 1610 , 1611 , 1612 , 1613 , 1615 , 1617 , 1618 , 1619 , 1620 , 1621 , 1622 , 1623 , 1625 , 1626 , 1627 , 1628 , 1629 , 1631 , 1632 , 1633 , 1634 , 1635 , 1636 , 1637 , 1638 , 1639 , 1641 , 1642 , 1643 , 1644 , 1645 , 1647 , 1648 , 1649 , 1650 , 1651 , 1653 , 1654 , 1655 , 1657 , 1658 , 1659 , 1660 , 1661 , 1663 , 1665 , 1666 , 1667 , 1668 , 1669 , 1670 , 1671 , 1672 , 1673 , 1674 , 1675 , 1676 , 1677 , 1679 , 1680 , 1681 , 1682 , 1683 , 1684 , 1685 , 1686 , 1687 , 1688 , 1689 , 1690 , 1691 , 1692 , 1693 , 1695 , 1697 , 1698 , 1699 , 1700 , 1701 , 1702 , 1703 , 1704 , 1705 , 1706 , 1707 , 1708 , 1709 , 1711 , 1713 , 1714 , 1715 , 1716 , 1717 , 1719 , 1721 , 1722 , 1723 , 1724 , 1725 , 1727 , 1728 , 1729 , 1730 , 1731 , 1732 , 1733 , 1734 , 1735 , 1736 , 1737 , 1738 , 1739 , 1740 , 1741 , 1743 , 1744 , 1745 , 1746 , 1747 , 1748 , 1749 , 1750 , 1752 , 1753 , 1754 , 1755 , 1756 , 1757 , 1759 , 1761 , 1762 , 1763 , 1764 , 1765 , 1766 , 1767 , 1768 , 1769 , 1770 , 1771 , 1772 , 1773 , 1775 , 1777 , 1778 , 1779 , 1780 , 1781 , 1782 , 1783 , 1785 , 1786 , 1787 , 1788 , 1789 , 1791 , 1793 , 1795 , 1796 , 1797 , 1798 , 1799 , 1800 , 1801 , 1802 , 1803 , 1804 , 1805 , 1807 , 1808 , 1809 , 1810 , 1811 , 1812 , 1813 , 1814 , 1815 , 1816 , 1817 , 1818 , 1819 , 1820 , 1821 , 1823 , 1824 , 1825 , 1826 , 1827 , 1828 , 1829 , 1830 , 1831 , 1832 , 1833 , 1834 , 1835 , 1836 , 1837 , 1839 , 1840 , 1841 , 1842 , 1843 , 1844 , 1845 , 1846 , 1847 , 1849 , 1851 , 1852 , 1853 , 1855 , 1857 , 1858 , 1859 , 1860 , 1861 , 1862 , 1863 , 1864 , 1865 , 1866 , 1867 , 1868 , 1869 , 1871 , 1872 , 1873 , 1874 , 1875 , 1877 , 1878 , 1879 , 1881 , 1882 , 1883 , 1884 , 1885 , 1887 , 1888 , 1889 , 1890 , 1891 , 1892 , 1893 , 1894 , 1895 , 1896 , 1897 , 1898 , 1899 , 1900 , 1901 , 1903 , 1904 , 1905 , 1906 , 1907 , 1908 , 1909 , 1910 , 1911 , 1913 , 1914 , 1915 , 1917 , 1919 , 1921 , 1922 , 1923 , 1924 , 1925 , 1926 , 1927 , 1928 , 1929 , 1930 , 1931 , 1932 , 1933 , 1935 , 1936 , 1937 , 1938 , 1939 , 1940 , 1941 , 1942 , 1943 , 1944 , 1945 , 1946 , 1947 , 1948 , 1949 , 1951 , 1952 , 1953 , 1954 , 1955 , 1956 , 1957 , 1958 , 1959 , 1960 , 1961 , 1962 , 1963 , 1964 , 1965 , 1967 , 1968 , 1969 , 1970 , 1971 , 1972 , 1973 , 1974 , 1975 , 1977 , 1978 , 1979 , 1980 , 1981 , 1983 , 1985 , 1986 , 1987 , 1988 , 1989 , 1990 , 1992 , 1993 , 1994 , 1995 , 1996 , 1997 , 1999 , 2000 , 2001 , 2002 , 2003 , 2004 , 2005 , 2006 , 2007 , 2008 , 2009 , 2010 , 2011 , 2012 , 2013 , 2015 , 2017 , 2018 , 2019 , 2020 , 2021 , 2022 , 2023 , 2024 , 2025 , 2026 , 2027 , 2028 , 2029 , 2031 , 2033 , 2034 , 2035 , 2036 , 2037 , 2038 , 2039 , 2041 , 2042 , 2043 , 2044 , 2045 , 2047 , 2049 , 2050 , 2051 , 2052 , 2053 , 2054 , 2055 , 2056 , 2057 , 2058 , 2059 , 2060 , 2061 , 2063 , 2064 , 2065 , 2066 , 2067 , 2068 , 2069 , 2070 , 2071 , 2073 , 2074 , 2075 , 2076 , 2077 , 2079 , 2080 , 2081 , 2082 , 2083 , 2084 , 2085 , 2086 , 2087 , 2088 , 2089 , 2090 , 2091 , 2092 , 2093 , 2095 , 2096 , 2097 , 2098 , 2099 , 2100 , 2101 , 2102 , 2103 , 2105 , 2106 , 2107 , 2108 , 2109 , 2111 , 2112 , 2113 , 2114 , 2115 , 2116 , 2117 , 2118 , 2119 , 2121 , 2122 , 2123 , 2124 , 2125 , 2127 , 2128 , 2129 , 2130 , 2131 , 2132 , 2133 , 2134 , 2135 , 2136 , 2137 , 2138 , 2139 , 2140 , 2141 , 2143 , 2145 , 2146 , 2147 , 2148 , 2149 , 2150 , 2151 , 2152 , 2153 , 2154 , 2155 , 2156 , 2157 , 2159 , 2160 , 2161 , 2162 , 2163 , 2165 , 2166 , 2167 , 2169 , 2170 , 2171 , 2172 , 2173 , 2175 , 2176 , 2177 , 2178 , 2179 , 2180 , 2181 , 2182 , 2183 , 2185 , 2186 , 2187 , 2188 , 2189 , 2191 , 2192 , 2193 , 2194 , 2195 , 2196 , 2197 , 2199 , 2200 , 2201 , 2202 , 2203 , 2204 , 2205 , 2207 , 2209 , 2211 , 2212 , 2213 , 2214 , 2215 , 2217 , 2218 , 2219 , 2220 , 2221 , 2223 , 2224 , 2225 , 2226 , 2227 , 2228 , 2229 , 2230 , 2231 , 2233 , 2234 , 2235 , 2236 , 2237 , 2239 , 2240 , 2241 , 2242 , 2243 , 2244 , 2245 , 2246 , 2247 , 2248 , 2249 , 2250 , 2251 , 2252 , 2253 , 2255 , 2256 , 2257 , 2258 , 2259 , 2260 , 2261 , 2263 , 2264 , 2265 , 2266 , 2267 , 2268 , 2269 , 2271 , 2273 , 2274 , 2275 , 2276 , 2277 , 2278 , 2279 , 2280 , 2281 , 2282 , 2283 , 2284 , 2285 , 2287 , 2288 , 2289 , 2290 , 2291 , 2292 , 2293 , 2294 , 2295 , 2297 , 2299 , 2300 , 2301 , 2303 , 2305 , 2306 , 2307 , 2308 , 2309 , 2310 , 2311 , 2312 , 2313 , 2314 , 2315 , 2316 , 2317 , 2319 , 2320 , 2321 , 2322 , 2323 , 2324 , 2325 , 2326 , 2327 , 2328 , 2329 , 2330 , 2331 , 2332 , 2333 , 2335 , 2336 , 2337 , 2338 , 2339 , 2340 , 2341 , 2342 , 2343 , 2344 , 2345 , 2346 , 2347 , 2348 , 2349 , 2351 , 2352 , 2353 , 2354 , 2355 , 2357 , 2358 , 2359 , 2361 , 2362 , 2363 , 2364 , 2365 , 2367 , 2369 , 2370 , 2371 , 2372 , 2373 , 2374 , 2375 , 2376 , 2377 , 2378 , 2379 , 2380 , 2381 , 2383 , 2385 , 2386 , 2387 , 2388 , 2389 , 2390 , 2391 , 2392 , 2393 , 2394 , 2395 , 2396 , 2397 , 2399 , 2400 , 2401 , 2402 , 2403 , 2404 , 2405 , 2406 , 2407 , 2408 , 2409 , 2410 , 2411 , 2412 , 2413 , 2415 , 2416 , 2417 , 2418 , 2419 , 2420 , 2421 , 2422 , 2423 , 2425 , 2426 , 2427 , 2428 , 2429 , 2431 , 2432 , 2433 , 2434 , 2435 , 2436 , 2437 , 2438 , 2439 , 2440 , 2441 , 2442 , 2443 , 2444 , 2445 , 2447 , 2448 , 2449 , 2450 , 2451 , 2452 , 2453 , 2454 , 2455 , 2457 , 2458 , 2460 , 2461 , 2463 , 2464 , 2465 , 2466 , 2467 , 2468 , 2469 , 2470 , 2471 , 2472 , 2473 , 2474 , 2475 , 2476 , 2477 , 2479 , 2481 , 2482 , 2483 , 2484 , 2485 , 2486 , 2487 , 2489 , 2490 , 2491 , 2493 , 2495 , 2497 , 2498 , 2499 , 2500 , 2501 , 2502 , 2503 , 2504 , 2505 , 2506 , 2507 , 2508 , 2509 , 2511 , 2512 , 2513 , 2514 , 2515 , 2517 , 2518 , 2519 , 2520 , 2521 , 2522 , 2523 , 2524 , 2525 , 2527 , 2529 , 2530 , 2531 , 2532 , 2533 , 2535 , 2536 , 2537 , 2538 , 2539 , 2540 , 2541 , 2544 , 2545 , 2546 , 2547 , 2548 , 2549 , 2550 , 2551 , 2553 , 2554 , 2555 , 2556 , 2557 , 2559 , 2561 , 2562 , 2563 , 2564 , 2565 , 2566 , 2567 , 2568 , 2569 , 2570 , 2571 , 2572 , 2573 , 2575 , 2576 , 2577 , 2578 , 2579 , 2580 , 2581 , 2582 , 2583 , 2584 , 2585 , 2586 , 2587 , 2588 , 2589 , 2591 , 2592 , 2593 , 2595 , 2596 , 2597 , 2598 , 2599 , 2600 , 2601 , 2602 , 2603 , 2604 , 2605 , 2607 , 2608 , 2609 , 2610 , 2611 , 2612 , 2613 , 2614 , 2615 , 2617 , 2618 , 2619 , 2620 , 2621 , 2623 , 2625 , 2626 , 2627 , 2628 , 2629 , 2630 , 2631 , 2632 , 2633 , 2634 , 2635 , 2637 , 2639 , 2641 , 2642 , 2643 , 2644 , 2645 , 2646 , 2647 , 2648 , 2649 , 2650 , 2651 , 2652 , 2653 , 2655 , 2656 , 2657 , 2658 , 2659 , 2660 , 2661 , 2662 , 2663 , 2664 , 2665 , 2666 , 2667 , 2668 , 2669 , 2671 , 2673 , 2674 , 2675 , 2677 , 2678 , 2679 , 2681 , 2682 , 2683 , 2684 , 2685 , 2687 , 2689 , 2690 , 2691 , 2692 , 2693 , 2694 , 2695 , 2696 , 2697 , 2698 , 2699 , 2700 , 2701 , 2703 , 2704 , 2705 , 2706 , 2707 , 2708 , 2709 , 2710 , 2711 , 2712 , 2713 , 2714 , 2715 , 2716 , 2717 , 2719 , 2721 , 2722 , 2723 , 2724 , 2725 , 2726 , 2727 , 2728 , 2729 , 2730 , 2731 , 2732 , 2733 , 2735 , 2736 , 2737 , 2738 , 2739 , 2740 , 2741 , 2742 , 2743 , 2745 , 2746 , 2747 , 2748 , 2749 , 2751 , 2752 , 2753 , 2754 , 2755 , 2756 , 2757 , 2758 , 2759 , 2760 , 2761 , 2762 , 2763 , 2764 , 2765 , 2767 , 2768 , 2769 , 2770 , 2771 , 2772 , 2773 , 2775 , 2776 , 2777 , 2778 , 2779 , 2780 , 2781 , 2783 , 2785 , 2786 , 2787 , 2788 , 2789 , 2790 , 2791 , 2792 , 2793 , 2794 , 2795 , 2796 , 2797 , 2799 , 2800 , 2801 , 2802 , 2803 , 2804 , 2805 , 2806 , 2807 , 2809 , 2810 , 2811 , 2812 , 2813 , 2815 , 2816 , 2817 , 2818 , 2819 , 2820 , 2821 , 2822 , 2823 , 2824 , 2825 , 2826 , 2827 , 2828 , 2829 , 2831 , 2832 , 2833 , 2834 , 2835 , 2836 , 2837 , 2838 , 2839 , 2840 , 2841 , 2842 , 2843 , 2844 , 2845 , 2847 , 2848 , 2849 , 2850 , 2851 , 2852 , 2853 , 2854 , 2855 , 2857 , 2858 , 2859 , 2860 , 2861 , 2863 , 2864 , 2865 , 2866 , 2867 , 2868 , 2869 , 2870 , 2871 , 2873 , 2874 , 2875 , 2876 , 2877 , 2879 , 2880 , 2881 , 2882 , 2883 , 2885 , 2886 , 2887 , 2888 , 2889 , 2890 , 2891 , 2892 , 2893 , 2895 , 2896 , 2897 , 2898 , 2899 , 2900 , 2901 , 2902 , 2903 , 2904 , 2905 , 2906 , 2907 , 2908 , 2909 , 2911 , 2913 , 2914 , 2915 , 2916 , 2917 , 2918 , 2919 , 2920 , 2921 , 2922 , 2923 , 2924 , 2925 , 2927 , 2928 , 2929 , 2930 , 2931 , 2932 , 2933 , 2934 , 2935 , 2937 , 2938 , 2939 , 2940 , 2941 , 2943 , 2945 , 2946 , 2947 , 2948 , 2949 , 2950 , 2951 , 2952 , 2953 , 2954 , 2955 , 2956 , 2957 , 2959 , 2960 , 2961 , 2962 , 2963 , 2964 , 2965 , 2966 , 2967 , 2968 , 2969 , 2970 , 2971 , 2972 , 2973 , 2975 , 2977 , 2978 , 2979 , 2980 , 2981 , 2982 , 2983 , 2985 , 2986 , 2987 , 2988 , 2989 , 2991 , 2992 , 2993 , 2994 , 2995 , 2996 , 2997 , 2998 , 2999 , 3001 , 3002 , 3003 , 3004 , 3005 , 3007 , 3008 , 3009 , 3010 , 3011 , 3012 , 3013 , 3014 , 3015 , 3016 , 3017 , 3018 , 3019 , 3020 , 3021 , 3023 , 3025 , 3026 , 3027 , 3028 , 3029 , 3030 , 3031 , 3033 , 3034 , 3035 , 3036 , 3037 , 3039 , 3041 , 3042 , 3043 , 3044 , 3045 , 3046 , 3047 , 3048 , 3049 , 3050 , 3051 , 3052 , 3053 , 3055 , 3056 , 3057 , 3058 , 3059 , 3060 , 3061 , 3062 , 3063 , 3065 , 3066 , 3067 , 3069 , 3071 , 3073 , 3074 , 3075 , 3076 , 3077 , 3078 , 3079 , 3080 , 3081 , 3082 , 3083 , 3084 , 3085 , 3087 , 3088 , 3089 , 3090 , 3091 , 3092 , 3093 , 3094 , 3095 , 3096 , 3097 , 3098 , 3099 , 3100 , 3101 , 3103 , 3104 , 3105 , 3106 , 3107 , 3108 , 3109 , 3111 , 3112 , 3113 , 3114 , 3115 , 3116 , 3117 , 3119 , 3120 , 3121 , 3122 , 3123 , 3124 , 3125 , 3126 , 3127 , 3129 , 3130 , 3131 , 3132 , 3133 , 3135 , 3137 , 3138 , 3139 , 3140 , 3141 , 3142 , 3143 , 3144 , 3145 , 3146 , 3147 , 3148 , 3149 , 3151 , 3152 , 3153 , 3154 , 3155 , 3156 , 3157 , 3158 , 3159 , 3160 , 3161 , 3162 , 3163 , 3164 , 3165 , 3167 , 3168 , 3169 , 3170 , 3171 , 3172 , 3173 , 3174 , 3175 , 3177 , 3178 , 3179 , 3180 , 3181 , 3183 , 3184 , 3185 , 3186 , 3187 , 3188 , 3189 , 3190 , 3191 , 3193 , 3194 , 3195 , 3196 , 3197 , 3199 , 3201 , 3202 , 3203 , 3204 , 3205 , 3207 , 3208 , 3209 , 3210 , 3211 , 3212 , 3213 , 3215 , 3216 , 3217 , 3218 , 3219 , 3220 , 3221 , 3222 , 3223 , 3224 , 3225 , 3226 , 3227 , 3228 , 3229 , 3231 , 3232 , 3233 , 3234 , 3235 , 3236 , 3237 , 3238 , 3239 , 3240 , 3241 , 3243 , 3244 , 3245 , 3247 , 3248 , 3249 , 3250 , 3251 , 3252 , 3253 , 3254 , 3255 , 3257 , 3258 , 3259 , 3260 , 3261 , 3263 , 3264 , 3265 , 3267 , 3268 , 3269 , 3270 , 3271 , 3272 , 3273 , 3274 , 3275 , 3276 , 3277 , 3279 , 3280 , 3281 , 3282 , 3283 , 3284 , 3285 , 3286 , 3287 , 3288 , 3289 , 3290 , 3291 , 3292 , 3293 , 3295 , 3297 , 3298 , 3299 , 3300 , 3301 , 3302 , 3303 , 3304 , 3305 , 3306 , 3307 , 3308 , 3309 , 3311 , 3312 , 3313 , 3314 , 3315 , 3316 , 3317 , 3318 , 3319 , 3321 , 3322 , 3323 , 3324 , 3325 , 3327 , 3329 , 3330 , 3331 , 3332 , 3333 , 3334 , 3335 , 3336 , 3337 , 3338 , 3339 , 3340 , 3341 , 3343 , 3344 , 3345 , 3346 , 3347 , 3348 , 3349 , 3350 , 3351 , 3352 , 3353 , 3354 , 3355 , 3356 , 3357 , 3359 , 3360 , 3361 , 3362 , 3363 , 3364 , 3365 , 3366 , 3367 , 3368 , 3369 , 3370 , 3371 , 3372 , 3373 , 3375 , 3377 , 3378 , 3379 , 3380 , 3381 , 3382 , 3383 , 3385 , 3386 , 3387 , 3388 , 3389 , 3391 , 3393 , 3394 , 3395 , 3396 , 3397 , 3398 , 3399 , 3400 , 3401 , 3402 , 3403 , 3404 , 3405 , 3407 , 3408 , 3409 , 3410 , 3411 , 3412 , 3413 , 3414 , 3415 , 3416 , 3417 , 3418 , 3419 , 3420 , 3421 , 3423 , 3424 , 3425 , 3426 , 3427 , 3428 , 3429 , 3430 , 3431 , 3432 , 3433 , 3434 , 3435 , 3436 , 3437 , 3439 , 3440 , 3441 , 3442 , 3443 , 3444 , 3445 , 3446 , 3447 , 3449 , 3450 , 3451 , 3452 , 3453 , 3455 , 3456 , 3457 , 3458 , 3459 , 3460 , 3461 , 3462 , 3463 , 3464 , 3465 , 3466 , 3467 , 3468 , 3469 , 3471 , 3472 , 3473 , 3474 , 3475 , 3476 , 3477 , 3478 , 3479 , 3481 , 3482 , 3483 , 3484 , 3485 , 3487 , 3488 , 3489 , 3490 , 3491 , 3492 , 3493 , 3494 , 3495 , 3496 , 3497 , 3498 , 3499 , 3500 , 3501 , 3503 , 3504 , 3505 , 3506 , 3507 , 3508 , 3509 , 3510 , 3511 , 3513 , 3514 , 3515 , 3516 , 3517 , 3519 , 3520 , 3521 , 3522 , 3523 , 3524 , 3525 , 3526 , 3527 , 3528 , 3529 , 3530 , 3531 , 3532 , 3533 , 3535 , 3537 , 3538 , 3539 , 3540 , 3541 , 3542 , 3543 , 3544 , 3545 , 3546 , 3547 , 3548 , 3549 , 3551 , 3553 , 3554 , 3555 , 3556 , 3557 , 3558 , 3559 , 3561 , 3562 , 3563 , 3564 , 3565 , 3567 , 3568 , 3569 , 3570 , 3571 , 3572 , 3573 , 3574 , 3575 , 3577 , 3578 , 3579 , 3580 , 3581 , 3583 , 3585 , 3586 , 3587 , 3588 , 3589 , 3590 , 3591 , 3592 , 3593 , 3594 , 3595 , 3596 , 3597 , 3599 , 3600 , 3601 , 3602 , 3603 , 3604 , 3605 , 3606 , 3607 , 3608 , 3609 , 3610 , 3611 , 3612 , 3613 , 3615 , 3617 , 3618 , 3619 , 3621 , 3622 , 3623 , 3624 , 3625 , 3626 , 3627 , 3628 , 3629 , 3631 , 3632 , 3633 , 3634 , 3635 , 3636 , 3637 , 3638 , 3639 , 3641 , 3642 , 3643 , 3644 , 3645 , 3647 , 3648 , 3649 , 3650 , 3651 , 3652 , 3653 , 3654 , 3655 , 3656 , 3657 , 3658 , 3659 , 3660 , 3661 , 3663 , 3664 , 3665 , 3666 , 3667 , 3668 , 3669 , 3670 , 3671 , 3672 , 3673 , 3674 , 3675 , 3676 , 3677 , 3679 , 3681 , 3682 , 3683 , 3684 , 3685 , 3686 , 3687 , 3688 , 3689 , 3690 , 3691 , 3692 , 3693 , 3695 , 3697 , 3698 , 3699 , 3700 , 3701 , 3702 , 3703 , 3705 , 3706 , 3707 , 3708 , 3709 , 3711 , 3712 , 3713 , 3714 , 3715 , 3716 , 3717 , 3718 , 3719 , 3720 , 3721 , 3722 , 3723 , 3724 , 3725 , 3727 , 3728 , 3729 , 3730 , 3731 , 3732 , 3733 , 3734 , 3735 , 3736 , 3737 , 3738 , 3739 , 3740 , 3741 , 3743 , 3744 , 3745 , 3746 , 3747 , 3748 , 3749 , 3750 , 3751 , 3752 , 3753 , 3754 , 3755 , 3756 , 3757 , 3759 , 3760 , 3761 , 3762 , 3763 , 3764 , 3765 , 3766 , 3767 , 3769 , 3770 , 3771 , 3772 , 3773 , 3775 , 3777 , 3778 , 3779 , 3780 , 3781 , 3782 , 3783 , 3784 , 3785 , 3786 , 3787 , 3788 , 3789 , 3791 , 3792 , 3793 , 3794 , 3795 , 3796 , 3797 , 3798 , 3799 , 3800 , 3801 , 3802 , 3803 , 3804 , 3805 , 3807 , 3809 , 3810 , 3811 , 3812 , 3813 , 3814 , 3815 , 3816 , 3817 , 3818 , 3819 , 3820 , 3821 , 3823 , 3825 , 3826 , 3827 , 3828 , 3829 , 3830 , 3831 , 3833 , 3834 , 3835 , 3836 , 3837 , 3839 , 3841 , 3842 , 3843 , 3844 , 3845 , 3846 , 3847 , 3848 , 3849 , 3850 , 3851 , 3852 , 3853 , 3855 , 3856 , 3857 , 3858 , 3859 , 3860 , 3861 , 3862 , 3863 , 3864 , 3865 , 3866 , 3867 , 3868 , 3869 , 3871 , 3872 , 3873 , 3874 , 3875 , 3876 , 3877 , 3878 , 3879 , 3880 , 3881 , 3882 , 3883 , 3884 , 3885 , 3887 , 3888 , 3889 , 3890 , 3891 , 3892 , 3893 , 3894 , 3895 , 3897 , 3898 , 3899 , 3900 , 3901 , 3903 , 3904 , 3905 , 3906 , 3907 , 3908 , 3909 , 3910 , 3911 , 3912 , 3913 , 3914 , 3915 , 3916 , 3917 , 3919 , 3920 , 3921 , 3922 , 3923 , 3924 , 3925 , 3927 , 3928 , 3929 , 3930 , 3931 , 3932 , 3933 , 3935 , 3936 , 3937 , 3938 , 3939 , 3940 , 3941 , 3942 , 3943 , 3945 , 3946 , 3947 , 3948 , 3949 , 3951 , 3952 , 3953 , 3954 , 3955 , 3956 , 3957 , 3958 , 3959 , 3961 , 3962 , 3963 , 3964 , 3965 , 3967 , 3969 , 3970 , 3971 , 3972 , 3973 , 3974 , 3975 , 3976 , 3977 , 3978 , 3979 , 3980 , 3981 , 3983 , 3984 , 3985 , 3986 , 3987 , 3988 , 3989 , 3990 , 3991 , 3992 , 3993 , 3994 , 3995 , 3996 , 3997 , 3999 , 4000 , 4001 , 4002 , 4003 , 4005 , 4006 , 4007 , 4008 , 4009 , 4010 , 4011 , 4012 , 4013 , 4015 , 4016 , 4017 , 4018 , 4019 , 4020 , 4021 , 4022 , 4023 , 4025 , 4027 , 4028 , 4029 , 4031 , 4033 , 4034 , 4035 , 4036 , 4037 , 4038 , 4039 , 4040 , 4041 , 4042 , 4043 , 4044 , 4045 , 4047 , 4048 , 4049 , 4050 , 4051 , 4052 , 4053 , 4054 , 4055 , 4056 , 4057 , 4058 , 4059 , 4060 , 4061 , 4063 , 4065 , 4066 , 4067 , 4068 , 4069 , 4070 , 4071 , 4072 , 4073 , 4074 , 4075 , 4076 , 4077 , 4079 , 4080 , 4081 , 4082 , 4083 , 4084 , 4085 , 4086 , 4087 , 4089 , 4090 , 4091 , 4092 , 4093 , 4095 , 4097 , 4098 , 4099 , 4100 , 4101 , 4102 , 4103 , 4104 , 4105 , 4106 , 4107 , 4108 , 4109 , 4111 , 4112 , 4113 , 4114 , 4115 , 4116 , 4117 , 4118 , 4119 , 4120 , 4121 , 4122 , 4123 , 4125 , 4127 , 4128 , 4129 , 4130 , 4131 , 4132 , 4133 , 4135 , 4136 , 4137 , 4138 , 4139 , 4140 , 4141 , 4143 , 4145 , 4146 , 4147 , 4148 , 4149 , 4150 , 4151 , 4153 , 4154 , 4155 , 4156 , 4157 , 4159 , 4161 , 4162 , 4163 , 4164 , 4165 , 4166 , 4167 , 4168 , 4169 , 4170 , 4171 , 4172 , 4173 , 4175 , 4176 , 4177 , 4178 , 4179 , 4180 , 4181 , 4182 , 4183 , 4184 , 4185 , 4186 , 4187 , 4189 , 4191 , 4192 , 4193 , 4194 , 4195 , 4196 , 4197 , 4198 , 4199 , 4200 , 4201 , 4202 , 4203 , 4204 , 4205 , 4207 , 4208 , 4209 , 4210 , 4211 , 4212 , 4213 , 4214 , 4215 , 4217 , 4218 , 4219 , 4220 , 4221 , 4223 , 4224 , 4225 , 4226 , 4227 , 4228 , 4229 , 4230 , 4231 , 4232 , 4233 , 4234 , 4235 , 4236 , 4237 , 4239 , 4240 , 4241 , 4242 , 4243 , 4244 , 4245 , 4246 , 4247 , 4248 , 4249 , 4250 , 4251 , 4252 , 4253 , 4255 , 4256 , 4257 , 4258 , 4259 , 4260 , 4261 , 4262 , 4263 , 4264 , 4265 , 4266 , 4267 , 4268 , 4269 , 4271 , 4272 , 4273 , 4274 , 4275 , 4276 , 4277 , 4278 , 4279 , 4281 , 4282 , 4283 , 4284 , 4285 , 4287 , 4288 , 4289 , 4290 , 4291 , 4292 , 4293 , 4294 , 4295 , 4296 , 4297 , 4298 , 4299 , 4300 , 4301 , 4303 , 4304 , 4305 , 4306 , 4307 , 4308 , 4309 , 4310 , 4311 , 4312 , 4313 , 4314 , 4315 , 4316 , 4317 , 4319 , 4321 , 4322 , 4323 , 4324 , 4325 , 4326 , 4327 , 4329 , 4330 , 4331 , 4332 , 4333 , 4335 , 4336 , 4337 , 4338 , 4339 , 4340 , 4341 , 4342 , 4343 , 4345 , 4346 , 4347 , 4348 , 4349 , 4351 , 4352 , 4353 , 4354 , 4356 , 4357 , 4358 , 4359 , 4360 , 4361 , 4362 , 4363 , 4364 , 4365 , 4367 , 4368 , 4369 , 4370 , 4371 , 4372 , 4373 , 4374 , 4375 , 4377 , 4378 , 4379 , 4380 , 4381 , 4383 , 4384 , 4385 , 4386 , 4387 , 4388 , 4389 , 4390 , 4391 , 4392 , 4393 , 4394 , 4395 , 4396 , 4397 , 4399 , 4400 , 4401 , 4402 , 4403 , 4404 , 4405 , 4406 , 4407 , 4409 , 4410 , 4411 , 4412 , 4413 , 4415 , 4416 , 4417 , 4418 , 4419 , 4420 , 4421 , 4422 , 4423 , 4425 , 4426 , 4427 , 4428 , 4429 , 4431 , 4432 , 4433 , 4434 , 4435 , 4436 , 4437 , 4438 , 4439 , 4441 , 4442 , 4443 , 4444 , 4445 , 4447 , 4448 , 4449 , 4450 , 4451 , 4452 , 4453 , 4454 , 4455 , 4456 , 4457 , 4458 , 4459 , 4461 , 4463 , 4464 , 4465 , 4466 , 4467 , 4468 , 4469 , 4470 , 4471 , 4473 , 4474 , 4475 , 4476 , 4477 , 4479 , 4481 , 4482 , 4483 , 4484 , 4485 , 4486 , 4487 , 4488 , 4489 , 4490 , 4491 , 4492 , 4493 , 4495 , 4496 , 4497 , 4498 , 4499 , 4500 , 4501 , 4502 , 4503 , 4504 , 4505 , 4506 , 4507 , 4508 , 4509 , 4511 , 4513 , 4514 , 4515 , 4516 , 4517 , 4518 , 4519 , 4520 , 4521 , 4522 , 4523 , 4524 , 4525 , 4527 , 4528 , 4529 , 4530 , 4531 , 4532 , 4533 , 4534 , 4535 , 4537 , 4538 , 4539 , 4540 , 4541 , 4543 , 4544 , 4545 , 4546 , 4547 , 4548 , 4549 , 4550 , 4551 , 4552 , 4553 , 4554 , 4555 , 4556 , 4557 , 4559 , 4560 , 4561 , 4562 , 4563 , 4564 , 4565 , 4566 , 4567 , 4568 , 4569 , 4570 , 4571 , 4572 , 4573 , 4575 , 4577 , 4578 , 4579 , 4580 , 4581 , 4582 , 4583 , 4584 , 4585 , 4586 , 4587 , 4588 , 4589 , 4591 , 4592 , 4593 , 4594 , 4595 , 4596 , 4597 , 4598 , 4599 , 4601 , 4602 , 4603 , 4604 , 4605 , 4607 , 4608 , 4609 , 4610 , 4611 , 4612 , 4613 , 4614 , 4615 , 4616 , 4617 , 4618 , 4619 , 4620 , 4621 , 4623 , 4624 , 4625 , 4626 , 4627 , 4628 , 4629 , 4630 , 4631 , 4632 , 4633 , 4634 , 4635 , 4636 , 4637 , 4639 , 4641 , 4642 , 4643 , 4644 , 4645 , 4646 , 4647 , 4648 , 4649 , 4650 , 4651 , 4652 , 4653 , 4655 , 4656 , 4657 , 4658 , 4659 , 4660 , 4661 , 4662 , 4663 , 4665 , 4666 , 4667 , 4668 , 4669 , 4671 , 4672 , 4673 , 4674 , 4675 , 4676 , 4677 , 4678 , 4679 , 4680 , 4681 , 4682 , 4683 , 4684 , 4685 , 4687 , 4688 , 4689 , 4690 , 4691 , 4692 , 4693 , 4694 , 4695 , 4696 , 4697 , 4698 , 4699 , 4700 , 4701 , 4703 , 4704 , 4705 , 4706 , 4707 , 4708 , 4709 , 4710 , 4711 , 4712 , 4713 , 4714 , 4715 , 4716 , 4717 , 4719 , 4720 , 4721 , 4722 , 4723 , 4724 , 4725 , 4726 , 4727 , 4729 , 4730 , 4731 , 4732 , 4733 , 4735 , 4737 , 4738 , 4739 , 4740 , 4741 , 4742 , 4743 , 4744 , 4745 , 4746 , 4747 , 4748 , 4749 , 4751 , 4752 , 4753 , 4754 , 4755 , 4756 , 4757 , 4758 , 4759 , 4760 , 4761 , 4762 , 4763 , 4764 , 4765 , 4767 , 4768 , 4769 , 4770 , 4771 , 4772 , 4773 , 4774 , 4775 , 4777 , 4778 , 4779 , 4780 , 4781 , 4783 , 4784 , 4785 , 4786 , 4787 , 4788 , 4789 , 4790 , 4791 , 4793 , 4794 , 4795 , 4796 , 4797 , 4799 , 4801 , 4802 , 4803 , 4804 , 4805 , 4806 , 4807 , 4808 , 4809 , 4810 , 4811 , 4812 , 4813 , 4815 , 4816 , 4817 , 4818 , 4819 , 4820 , 4821 , 4822 , 4823 , 4824 , 4825 , 4826 , 4827 , 4828 , 4829 , 4831 , 4833 , 4834 , 4835 , 4836 , 4837 , 4838 , 4839 , 4840 , 4841 , 4842 , 4843 , 4844 , 4845 , 4847 , 4848 , 4849 , 4850 , 4851 , 4852 , 4853 , 4854 , 4855 , 4857 , 4858 , 4859 , 4860 , 4861 , 4863 , 4865 , 4866 , 4867 , 4868 , 4869 , 4870 , 4871 , 4872 , 4873 , 4874 , 4875 , 4876 , 4877 , 4879 , 4881 , 4882 , 4883 , 4884 , 4885 , 4886 , 4887 , 4888 , 4889 , 4890 , 4891 , 4892 , 4893 , 4895 , 4896 , 4897 , 4898 , 4899 , 4900 , 4901 , 4902 , 4903 , 4904 , 4905 , 4906 , 4907 , 4908 , 4909 , 4911 , 4912 , 4913 , 4914 , 4915 , 4916 , 4917 , 4918 , 4919 , 4921 , 4922 , 4923 , 4924 , 4925 , 4927 , 4928 , 4929 , 4930 , 4931 , 4932 , 4933 , 4934 , 4935 , 4936 , 4937 , 4938 , 4939 , 4940 , 4941 , 4943 , 4945 , 4946 , 4947 , 4948 , 4949 , 4950 , 4951 , 4952 , 4953 , 4954 , 4955 , 4956 , 4957 , 4959 , 4960 , 4961 , 4962 , 4963 , 4964 , 4965 , 4966 , 4967 , 4968 , 4969 , 4970 , 4971 , 4972 , 4973 , 4975 , 4976 , 4977 , 4978 , 4979 , 4980 , 4981 , 4982 , 4983 , 4985 , 4986 , 4987 , 4988 , 4989 , 4991 , 4993 , 4994 , 4995 , 4996 , 4997 , 4998 , 4999 , 5000 , 5001 , 5002 , 5003 , 5004 , 5005 , 5007 , 5008 , 5009 , 5010 , 5011 , 5012 , 5013 , 5014 , 5015 , 5016 , 5017 , 5018 , 5019 , 5020 , 5021 , 5023 , 5025 , 5026 , 5027 , 5028 , 5029 , 5031 , 5032 , 5033 , 5034 , 5035 , 5036 , 5037 , 5039 , 5040 , 5041 , 5042 , 5043 , 5044 , 5045 , 5046 , 5047 , 5049 , 5050 , 5051 , 5052 , 5053 , 5055 , 5057 , 5058 , 5059 , 5060 , 5061 , 5062 , 5063 , 5064 , 5065 , 5066 , 5067 , 5068 , 5069 , 5071 , 5073 , 5074 , 5075 , 5076 , 5077 , 5078 , 5079 , 5080 , 5081 , 5082 , 5083 , 5084 , 5085 , 5087 , 5089 , 5090 , 5091 , 5092 , 5093 , 5094 , 5095 , 5096 , 5097 , 5098 , 5099 , 5100 , 5101 , 5103 , 5104 , 5105 , 5106 , 5107 , 5108 , 5109 , 5110 , 5111 , 5113 , 5114 , 5115 , 5116 , 5117 , 5119 , 5121 , 5122 , 5123 , 5124 , 5125 , 5126 , 5127 , 5128 , 5129 , 5130 , 5131 , 5132 , 5133 , 5135 , 5136 , 5137 , 5138 , 5139 , 5140 , 5141 , 5142 , 5143 , 5145 , 5146 , 5147 , 5148 , 5149 , 5151 , 5152 , 5153 , 5154 , 5155 , 5156 , 5157 , 5158 , 5159 , 5160 , 5161 , 5162 , 5163 , 5164 , 5165 , 5167 , 5168 , 5169 , 5170 , 5171 , 5172 , 5173 , 5174 , 5175 , 5177 , 5178 , 5179 , 5180 , 5181 , 5183 , 5184 , 5185 , 5186 , 5187 , 5188 , 5189 , 5190 , 5191 , 5192 , 5193 , 5194 , 5195 , 5196 , 5197 , 5199 , 5200 , 5201 , 5202 , 5203 , 5204 , 5205 , 5206 , 5207 , 5208 , 5209 , 5211 , 5212 , 5213 , 5215 , 5216 , 5217 , 5218 , 5219 , 5220 , 5221 , 5222 , 5223 , 5224 , 5225 , 5226 , 5227 , 5228 , 5229 , 5231 , 5232 , 5233 , 5234 , 5235 , 5236 , 5237 , 5238 , 5239 , 5241 , 5242 , 5243 , 5244 , 5245 , 5247 , 5248 , 5249 , 5250 , 5251 , 5252 , 5253 , 5254 , 5255 , 5256 , 5257 , 5258 , 5259 , 5260 , 5261 , 5263 , 5264 , 5265 , 5266 , 5267 , 5268 , 5269 , 5270 , 5271 , 5272 , 5273 , 5274 , 5275 , 5276 , 5277 , 5279 , 5280 , 5281 , 5282 , 5283 , 5284 , 5285 , 5286 , 5287 , 5288 , 5289 , 5290 , 5291 , 5292 , 5293 , 5295 , 5296 , 5297 , 5298 , 5299 , 5300 , 5301 , 5302 , 5303 , 5305 , 5306 , 5307 , 5308 , 5309 , 5311 , 5312 , 5313 , 5314 , 5315 , 5316 , 5317 , 5318 , 5319 , 5320 , 5321 , 5322 , 5323 , 5324 , 5325 , 5327 , 5328 , 5329 , 5330 , 5331 , 5332 , 5333 , 5334 , 5335 , 5336 , 5337 , 5338 , 5339 , 5340 , 5341 , 5343 , 5345 , 5346 , 5347 , 5348 , 5349 , 5350 , 5351 , 5352 , 5353 , 5354 , 5355 , 5356 , 5357 , 5359 , 5360 , 5361 , 5362 , 5363 , 5364 , 5365 , 5366 , 5367 , 5369 , 5370 , 5371 , 5372 , 5373 , 5375 , 5377 , 5378 , 5379 , 5380 , 5381 , 5382 , 5383 , 5384 , 5385 , 5386 , 5387 , 5388 , 5389 , 5391 , 5392 , 5393 , 5394 , 5395 , 5396 , 5397 , 5398 , 5399 , 5400 , 5401 , 5402 , 5403 , 5404 , 5405 , 5407 , 5409 , 5410 , 5411 , 5412 , 5413 , 5414 , 5415 , 5416 , 5417 , 5418 , 5419 , 5420 , 5421 , 5423 , 5424 , 5425 , 5426 , 5427 , 5428 , 5429 , 5430 , 5431 , 5433 , 5434 , 5435 , 5436 , 5437 , 5439 , 5440 , 5441 , 5442 , 5443 , 5444 , 5445 , 5446 , 5447 , 5448 , 5449 , 5450 , 5451 , 5452 , 5453 , 5455 , 5457 , 5458 , 5459 , 5460 , 5461 , 5462 , 5463 , 5464 , 5465 , 5466 , 5467 , 5468 , 5469 , 5471 , 5472 , 5473 , 5475 , 5476 , 5477 , 5478 , 5479 , 5480 , 5481 , 5482 , 5483 , 5484 , 5485 , 5487 , 5488 , 5489 , 5490 , 5491 , 5492 , 5493 , 5494 , 5495 , 5497 , 5498 , 5499 , 5500 , 5501 , 5503 , 5504 , 5505 , 5506 , 5507 , 5508 , 5509 , 5510 , 5511 , 5512 , 5513 , 5514 , 5515 , 5516 , 5517 , 5519 , 5520 , 5521 , 5522 , 5523 , 5524 , 5525 , 5526 , 5527 , 5528 , 5529 , 5530 , 5531 , 5532 , 5533 , 5535 , 5536 , 5537 , 5538 , 5539 , 5540 , 5541 , 5542 , 5543 , 5544 , 5545 , 5546 , 5547 , 5548 , 5549 , 5551 , 5552 , 5553 , 5554 , 5555 , 5556 , 5557 , 5558 , 5559 , 5561 , 5562 , 5563 , 5564 , 5565 , 5567 , 5568 , 5569 , 5570 , 5571 , 5572 , 5573 , 5574 , 5575 , 5576 , 5577 , 5578 , 5579 , 5580 , 5581 , 5583 , 5584 , 5585 , 5586 , 5587 , 5589 , 5590 , 5591 , 5592 , 5593 , 5595 , 5596 , 5597 , 5599 , 5601 , 5602 , 5603 , 5604 , 5605 , 5606 , 5607 , 5608 , 5609 , 5610 , 5611 , 5612 , 5613 , 5615 , 5617 , 5618 , 5619 , 5620 , 5621 , 5622 , 5623 , 5625 , 5626 , 5627 , 5628 , 5629 , 5631 , 5633 , 5634 , 5635 , 5637 , 5638 , 5639 , 5640 , 5641 , 5642 , 5643 , 5644 , 5645 , 5647 , 5648 , 5649 , 5650 , 5651 , 5652 , 5653 , 5654 , 5655 , 5656 , 5657 , 5658 , 5659 , 5660 , 5661 , 5663 , 5664 , 5665 , 5666 , 5667 , 5668 , 5669 , 5670 , 5671 , 5673 , 5674 , 5675 , 5676 , 5677 , 5679 , 5680 , 5681 , 5682 , 5683 , 5684 , 5685 , 5686 , 5687 , 5689 , 5690 , 5691 , 5692 , 5693 , 5695 , 5696 , 5697 , 5698 , 5699 , 5700 , 5701 , 5702 , 5703 , 5704 , 5705 , 5706 , 5707 , 5708 , 5709 , 5711 , 5712 , 5713 , 5714 , 5715 , 5716 , 5717 , 5718 , 5719 , 5720 , 5721 , 5722 , 5723 , 5724 , 5725 , 5727 , 5728 , 5729 , 5730 , 5731 , 5732 , 5733 , 5734 , 5735 , 5736 , 5737 , 5738 , 5739 , 5740 , 5741 , 5743 , 5744 , 5745 , 5746 , 5747 , 5748 , 5749 , 5750 , 5751 , 5753 , 5754 , 5755 , 5757 , 5759 , 5760 , 5761 , 5762 , 5763 , 5764 , 5765 , 5766 , 5767 , 5768 , 5769 , 5770 , 5771 , 5772 , 5773 , 5775 , 5776 , 5777 , 5778 , 5779 , 5780 , 5781 , 5782 , 5783 , 5784 , 5785 , 5786 , 5787 , 5788 , 5789 , 5791 , 5792 , 5793 , 5794 , 5795 , 5796 , 5797 , 5798 , 5799 , 5800 , 5801 , 5802 , 5803 , 5804 , 5805 , 5807 , 5808 , 5809 , 5810 , 5811 , 5812 , 5813 , 5814 , 5815 , 5817 , 5818 , 5819 , 5820 , 5821 , 5823 , 5825 , 5826 , 5827 , 5828 , 5829 , 5830 , 5831 , 5832 , 5833 , 5834 , 5835 , 5836 , 5837 , 5839 , 5840 , 5841 , 5842 , 5843 , 5844 , 5845 , 5846 , 5847 , 5848 , 5849 , 5850 , 5851 , 5852 , 5853 , 5855 , 5857 , 5858 , 5859 , 5860 , 5861 , 5862 , 5863 , 5864 , 5865 , 5866 , 5867 , 5868 , 5869 , 5871 , 5872 , 5873 , 5874 , 5875 , 5876 , 5877 , 5878 , 5879 , 5881 , 5882 , 5883 , 5884 , 5885 , 5887 , 5889 , 5890 , 5891 , 5892 , 5893 , 5895 , 5896 , 5897 , 5898 , 5899 , 5900 , 5901 , 5903 , 5904 , 5905 , 5906 , 5907 , 5908 , 5910 , 5911 , 5912 , 5913 , 5914 , 5915 , 5916 , 5917 , 5919 , 5920 , 5921 , 5922 , 5923 , 5924 , 5925 , 5926 , 5927 , 5928 , 5929 , 5930 , 5931 , 5932 , 5933 , 5935 , 5937 , 5938 , 5939 , 5940 , 5941 , 5942 , 5943 , 5945 , 5946 , 5947 , 5948 , 5949 , 5951 , 5953 , 5954 , 5955 , 5956 , 5957 , 5958 , 5959 , 5960 , 5961 , 5962 , 5963 , 5964 , 5965 , 5967 , 5968 , 5970 , 5971 , 5972 , 5973 , 5974 , 5975 , 5976 , 5977 , 5978 , 5979 , 5980 , 5981 , 5983 , 5984 , 5985 , 5986 , 5987 , 5988 , 5989 , 5990 , 5991 , 5992 , 5993 , 5994 , 5995 , 5996 , 5997 , 5999 , 6000 , 6001 , 6002 , 6003 , 6004 , 6005 , 6006 , 6007 , 6009 , 6010 , 6011 , 6012 , 6013 , 6015 , 6017 , 6018 , 6019 , 6020 , 6021 , 6022 , 6023 , 6024 , 6025 , 6026 , 6027 , 6028 , 6029 , 6031 , 6032 , 6033 , 6034 , 6035 , 6036 , 6037 , 6038 , 6039 , 6040 , 6041 , 6042 , 6043 , 6044 , 6045 , 6047 , 6048 , 6049 , 6050 , 6051 , 6052 , 6053 , 6054 , 6055 , 6056 , 6057 , 6058 , 6059 , 6060 , 6061 , 6063 , 6064 , 6065 , 6066 , 6067 , 6068 , 6069 , 6070 , 6071 , 6073 , 6074 , 6075 , 6076 , 6077 , 6079 , 6080 , 6081 , 6082 , 6083 , 6084 , 6085 , 6086 , 6087 , 6088 , 6089 , 6090 , 6091 , 6092 , 6093 , 6095 , 6097 , 6098 , 6099 , 6100 , 6101 , 6102 , 6103 , 6105 , 6106 , 6107 , 6108 , 6109 , 6111 , 6113 , 6114 , 6115 , 6116 , 6117 , 6118 , 6119 , 6120 , 6121 , 6122 , 6123 , 6124 , 6125 , 6127 , 6128 , 6129 , 6130 , 6131 , 6132 , 6133 , 6134 , 6135 , 6137 , 6138 , 6139 , 6140 , 6141 , 6143 , 6144 , 6145 , 6146 , 6147 , 6148 , 6149 , 6150 , 6151 , 6152 , 6153 , 6154 , 6155 , 6156 , 6157 , 6159 , 6160 , 6161 , 6162 , 6163 , 6164 , 6165 , 6166 , 6167 , 6168 , 6169 , 6170 , 6171 , 6172 , 6173 , 6175 , 6176 , 6177 , 6178 , 6179 , 6180 , 6181 , 6182 , 6183 , 6184 , 6185 , 6186 , 6187 , 6188 , 6189 , 6191 , 6192 , 6193 , 6194 , 6195 , 6196 , 6197 , 6198 , 6199 , 6201 , 6202 , 6203 , 6204 , 6205 , 6207 , 6208 , 6209 , 6210 , 6211 , 6212 , 6213 , 6214 , 6215 , 6216 , 6217 , 6218 , 6219 , 6220 , 6221 , 6223 , 6224 , 6225 , 6226 , 6227 , 6228 , 6229 , 6230 , 6231 , 6232 , 6233 , 6234 , 6235 , 6236 , 6237 , 6239 , 6240 , 6241 , 6242 , 6243 , 6244 , 6245 , 6246 , 6247 , 6248 , 6249 , 6250 , 6251 , 6252 , 6253 , 6255 , 6256 , 6257 , 6258 , 6259 , 6260 , 6261 , 6262 , 6263 , 6265 , 6266 , 6267 , 6268 , 6269 , 6271 , 6273 , 6274 , 6275 , 6276 , 6277 , 6278 , 6279 , 6280 , 6281 , 6282 , 6283 , 6284 , 6285 , 6287 , 6288 , 6289 , 6290 , 6291 , 6292 , 6293 , 6294 , 6295 , 6296 , 6297 , 6298 , 6299 , 6300 , 6301 , 6303 , 6304 , 6305 , 6306 , 6307 , 6308 , 6309 , 6310 , 6311 , 6312 , 6313 , 6314 , 6315 , 6316 , 6317 , 6319 , 6320 , 6321 , 6322 , 6323 , 6324 , 6325 , 6326 , 6327 , 6329 , 6330 , 6331 , 6332 , 6333 , 6335 , 6336 , 6337 , 6338 , 6339 , 6340 , 6341 , 6342 , 6343 , 6345 , 6346 , 6347 , 6348 , 6349 , 6351 , 6352 , 6353 , 6354 , 6355 , 6356 , 6357 , 6358 , 6359 , 6361 , 6362 , 6363 , 6364 , 6365 , 6367 , 6369 , 6370 , 6371 , 6372 , 6373 , 6374 , 6375 , 6376 , 6377 , 6378 , 6379 , 6380 , 6381 , 6383 , 6385 , 6386 , 6387 , 6388 , 6389 , 6390 , 6391 , 6393 , 6394 , 6395 , 6396 , 6397 , 6399 , 6400 , 6401 , 6402 , 6403 , 6404 , 6405 , 6406 , 6407 , 6408 , 6409 , 6410 , 6411 , 6412 , 6413 , 6415 , 6417 , 6418 , 6419 , 6420 , 6421 , 6422 , 6423 , 6424 , 6425 , 6426 , 6427 , 6428 , 6429 , 6431 , 6432 , 6433 , 6434 , 6435 , 6436 , 6437 , 6438 , 6439 , 6440 , 6441 , 6442 , 6443 , 6444 , 6445 , 6447 , 6448 , 6449 , 6450 , 6451 , 6452 , 6453 , 6454 , 6455 , 6457 , 6458 , 6459 , 6460 , 6461 , 6463 , 6465 , 6466 , 6467 , 6468 , 6469 , 6470 , 6471 , 6472 , 6473 , 6474 , 6475 , 6476 , 6477 , 6479 , 6480 , 6481 , 6482 , 6483 , 6484 , 6485 , 6486 , 6487 , 6488 , 6489 , 6490 , 6491 , 6492 , 6493 , 6495 , 6497 , 6498 , 6499 , 6500 , 6501 , 6502 , 6503 , 6504 , 6505 , 6506 , 6507 , 6508 , 6509 , 6511 , 6512 , 6513 , 6514 , 6515 , 6516 , 6517 , 6519 , 6521 , 6522 , 6523 , 6524 , 6525 , 6527 , 6528 , 6529 , 6530 , 6531 , 6532 , 6533 , 6534 , 6535 , 6536 , 6537 , 6538 , 6539 , 6540 , 6541 , 6543 , 6544 , 6545 , 6546 , 6547 , 6548 , 6549 , 6550 , 6551 , 6552 , 6553 , 6554 , 6555 , 6556 , 6557 , 6559 , 6561 , 6562 , 6563 , 6564 , 6565 , 6566 , 6567 , 6568 , 6569 , 6570 , 6571 , 6572 , 6573 , 6575 , 6576 , 6577 , 6578 , 6579 , 6580 , 6581 , 6582 , 6583 , 6585 , 6586 , 6587 , 6588 , 6589 , 6591 , 6592 , 6593 , 6594 , 6595 , 6596 , 6597 , 6598 , 6599 , 6600 , 6601 , 6602 , 6603 , 6604 , 6605 , 6607 , 6609 , 6610 , 6611 , 6612 , 6613 , 6614 , 6615 , 6616 , 6617 , 6618 , 6619 , 6620 , 6621 , 6623 , 6625 , 6626 , 6627 , 6628 , 6629 , 6630 , 6631 , 6632 , 6633 , 6634 , 6635 , 6636 , 6637 , 6639 , 6640 , 6641 , 6642 , 6643 , 6644 , 6645 , 6646 , 6647 , 6649 , 6650 , 6651 , 6652 , 6653 , 6655 , 6657 , 6658 , 6659 , 6660 , 6661 , 6662 , 6663 , 6664 , 6665 , 6666 , 6667 , 6668 , 6669 , 6671 , 6672 , 6673 , 6674 , 6675 , 6676 , 6677 , 6678 , 6679 , 6680 , 6681 , 6682 , 6683 , 6684 , 6685 , 6687 , 6688 , 6689 , 6690 , 6691 , 6692 , 6693 , 6694 , 6695 , 6696 , 6697 , 6698 , 6699 , 6700 , 6701 , 6703 , 6704 , 6705 , 6706 , 6707 , 6708 , 6709 , 6711 , 6713 , 6714 , 6715 , 6716 , 6717 , 6719 , 6720 , 6721 , 6722 , 6723 , 6724 , 6725 , 6726 , 6727 , 6728 , 6729 , 6730 , 6731 , 6732 , 6733 , 6735 , 6736 , 6737 , 6738 , 6739 , 6740 , 6741 , 6742 , 6743 , 6744 , 6745 , 6746 , 6747 , 6748 , 6749 , 6751 , 6752 , 6753 , 6754 , 6755 , 6756 , 6757 , 6758 , 6759 , 6760 , 6761 , 6762 , 6763 , 6764 , 6765 , 6767 , 6768 , 6769 , 6770 , 6771 , 6772 , 6773 , 6774 , 6775 , 6777 , 6778 , 6779 , 6780 , 6781 , 6783 , 6785 , 6786 , 6787 , 6788 , 6789 , 6790 , 6791 , 6792 , 6793 , 6795 , 6796 , 6797 , 6799 , 6800 , 6801 , 6802 , 6803 , 6804 , 6805 , 6806 , 6807 , 6808 , 6809 , 6810 , 6811 , 6812 , 6813 , 6815 , 6816 , 6817 , 6818 , 6819 , 6820 , 6821 , 6822 , 6823 , 6824 , 6825 , 6826 , 6827 , 6828 , 6829 , 6831 , 6832 , 6833 , 6834 , 6835 , 6836 , 6837 , 6838 , 6839 , 6841 , 6842 , 6843 , 6844 , 6845 , 6847 , 6849 , 6850 , 6851 , 6852 , 6853 , 6854 , 6855 , 6856 , 6857 , 6858 , 6859 , 6860 , 6861 , 6863 , 6864 , 6865 , 6866 , 6867 , 6868 , 6869 , 6870 , 6871 , 6873 , 6874 , 6875 , 6876 , 6877 , 6879 , 6881 , 6882 , 6883 , 6884 , 6885 , 6886 , 6887 , 6888 , 6889 , 6890 , 6891 , 6892 , 6893 , 6895 , 6896 , 6897 , 6898 , 6899 , 6900 , 6901 , 6902 , 6903 , 6905 , 6906 , 6907 , 6908 , 6909 , 6911 , 6912 , 6913 , 6914 , 6915 , 6916 , 6917 , 6918 , 6919 , 6920 , 6921 , 6922 , 6923 , 6924 , 6925 , 6927 , 6928 , 6929 , 6930 , 6931 , 6932 , 6933 , 6934 , 6935 , 6936 , 6937 , 6938 , 6939 , 6940 , 6941 , 6943 , 6944 , 6945 , 6946 , 6947 , 6948 , 6949 , 6950 , 6951 , 6952 , 6953 , 6954 , 6955 , 6956 , 6957 , 6959 , 6960 , 6961 , 6962 , 6963 , 6964 , 6965 , 6966 , 6967 , 6969 , 6970 , 6971 , 6972 , 6973 , 6975 , 6976 , 6977 , 6978 , 6979 , 6980 , 6981 , 6982 , 6983 , 6984 , 6985 , 6986 , 6987 , 6988 , 6989 , 6991 , 6992 , 6993 , 6994 , 6995 , 6996 , 6997 , 6998 , 6999 , 7000 , 7001 , 7002 , 7003 , 7005 , 7007 , 7008 , 7009 , 7010 , 7011 , 7012 , 7013 , 7014 , 7015 , 7016 , 7017 , 7018 , 7019 , 7020 , 7021 , 7023 , 7024 , 7025 , 7026 , 7027 , 7028 , 7029 , 7030 , 7031 , 7033 , 7034 , 7035 , 7036 , 7037 , 7039 , 7041 , 7042 , 7043 , 7044 , 7045 , 7046 , 7047 , 7048 , 7049 , 7050 , 7051 , 7052 , 7053 , 7055 , 7056 , 7057 , 7058 , 7059 , 7060 , 7061 , 7062 , 7063 , 7064 , 7065 , 7066 , 7067 , 7068 , 7069 , 7071 , 7072 , 7073 , 7074 , 7075 , 7076 , 7077 , 7078 , 7079 , 7080 , 7081 , 7082 , 7083 , 7084 , 7085 , 7087 , 7088 , 7089 , 7090 , 7091 , 7092 , 7093 , 7094 , 7095 , 7097 , 7098 , 7099 , 7100 , 7101 , 7103 , 7105 , 7106 , 7107 , 7108 , 7109 , 7110 , 7111 , 7112 , 7113 , 7114 , 7115 , 7116 , 7117 , 7119 , 7120 , 7121 , 7122 , 7123 , 7124 , 7125 , 7126 , 7127 , 7128 , 7129 , 7130 , 7131 , 7132 , 7133 , 7135 , 7137 , 7138 , 7139 , 7140 , 7141 , 7142 , 7143 , 7144 , 7145 , 7146 , 7147 , 7148 , 7149 , 7151 , 7152 , 7153 , 7154 , 7155 , 7156 , 7157 , 7158 , 7159 , 7161 , 7162 , 7163 , 7164 , 7165 , 7167 , 7169 , 7170 , 7171 , 7172 , 7173 , 7174 , 7175 , 7177 , 7178 , 7179 , 7180 , 7181 , 7183 , 7184 , 7185 , 7186 , 7187 , 7188 , 7189 , 7190 , 7191 , 7192 , 7193 , 7194 , 7195 , 7196 , 7197 , 7199 , 7200 , 7201 , 7202 , 7203 , 7204 , 7205 , 7206 , 7207 , 7208 , 7209 , 7210 , 7211 , 7212 , 7213 , 7215 , 7216 , 7217 , 7218 , 7219 , 7220 , 7221 , 7222 , 7223 , 7225 , 7226 , 7227 , 7228 , 7229 , 7231 , 7232 , 7233 , 7234 , 7235 , 7236 , 7237 , 7238 , 7239 , 7240 , 7241 , 7242 , 7243 , 7244 , 7245 , 7247 , 7248 , 7249 , 7250 , 7251 , 7252 , 7253 , 7254 , 7255 , 7256 , 7257 , 7258 , 7259 , 7260 , 7261 , 7263 , 7264 , 7265 , 7266 , 7267 , 7268 , 7269 , 7270 , 7271 , 7272 , 7273 , 7274 , 7275 , 7276 , 7277 , 7279 , 7280 , 7281 , 7282 , 7283 , 7284 , 7285 , 7286 , 7287 , 7289 , 7290 , 7291 , 7292 , 7293 , 7295 , 7296 , 7297 , 7298 , 7299 , 7300 , 7301 , 7302 , 7303 , 7304 , 7305 , 7306 , 7307 , 7308 , 7309 , 7311 , 7312 , 7313 , 7314 , 7315 , 7316 , 7317 , 7318 , 7319 , 7320 , 7321 , 7322 , 7323 , 7324 , 7325 , 7327 , 7328 , 7329 , 7330 , 7331 , 7332 , 7333 , 7334 , 7335 , 7336 , 7337 , 7338 , 7339 , 7340 , 7341 , 7343 , 7344 , 7345 , 7346 , 7347 , 7348 , 7349 , 7350 , 7351 , 7353 , 7354 , 7355 , 7356 , 7357 , 7359 , 7360 , 7361 , 7362 , 7363 , 7364 , 7365 , 7366 , 7367 , 7368 , 7369 , 7370 , 7371 , 7372 , 7373 , 7375 , 7376 , 7377 , 7378 , 7379 , 7380 , 7381 , 7382 , 7383 , 7384 , 7385 , 7386 , 7387 , 7388 , 7389 , 7391 , 7393 , 7394 , 7395 , 7396 , 7397 , 7398 , 7399 , 7401 , 7402 , 7403 , 7404 , 7405 , 7407 , 7408 , 7409 , 7410 , 7411 , 7412 , 7413 , 7414 , 7415 , 7417 , 7418 , 7419 , 7420 , 7421 , 7423 , 7425 , 7426 , 7427 , 7428 , 7429 , 7430 , 7431 , 7432 , 7433 , 7434 , 7435 , 7436 , 7437 , 7439 , 7440 , 7441 , 7442 , 7443 , 7444 , 7445 , 7446 , 7447 , 7448 , 7449 , 7450 , 7451 , 7452 , 7453 , 7455 , 7456 , 7457 , 7458 , 7459 , 7460 , 7461 , 7462 , 7463 , 7464 , 7465 , 7466 , 7467 , 7468 , 7469 , 7471 , 7472 , 7473 , 7474 , 7475 , 7476 , 7477 , 7478 , 7479 , 7481 , 7482 , 7483 , 7484 , 7485 , 7487 , 7488 , 7489 , 7490 , 7491 , 7492 , 7493 , 7494 , 7495 , 7496 , 7497 , 7498 , 7499 , 7500 , 7501 , 7503 , 7505 , 7506 , 7507 , 7508 , 7509 , 7510 , 7511 , 7512 , 7513 , 7514 , 7515 , 7516 , 7517 , 7519 , 7521 , 7522 , 7523 , 7524 , 7525 , 7527 , 7528 , 7529 , 7530 , 7531 , 7532 , 7533 , 7535 , 7536 , 7537 , 7538 , 7539 , 7540 , 7541 , 7542 , 7543 , 7545 , 7546 , 7547 , 7548 , 7549 , 7551 , 7552 , 7553 , 7554 , 7555 , 7556 , 7557 , 7558 , 7559 , 7560 , 7561 , 7562 , 7563 , 7564 , 7565 , 7567 , 7568 , 7569 , 7570 , 7571 , 7572 , 7573 , 7574 , 7575 , 7576 , 7577 , 7578 , 7579 , 7580 , 7581 , 7583 , 7584 , 7585 , 7586 , 7587 , 7588 , 7589 , 7590 , 7591 , 7592 , 7593 , 7594 , 7595 , 7596 , 7597 , 7599 , 7600 , 7601 , 7602 , 7603 , 7604 , 7605 , 7606 , 7607 , 7609 , 7610 , 7611 , 7612 , 7613 , 7615 , 7616 , 7617 , 7618 , 7619 , 7620 , 7621 , 7622 , 7623 , 7624 , 7625 , 7626 , 7627 , 7628 , 7629 , 7631 , 7632 , 7633 , 7634 , 7635 , 7636 , 7637 , 7638 , 7639 , 7640 , 7641 , 7642 , 7643 , 7644 , 7645 , 7647 , 7649 , 7650 , 7651 , 7652 , 7653 , 7654 , 7655 , 7656 , 7657 , 7658 , 7659 , 7660 , 7661 , 7663 , 7665 , 7666 , 7667 , 7668 , 7669 , 7670 , 7671 , 7673 , 7674 , 7675 , 7676 , 7677 , 7679 , 7681 , 7682 , 7683 , 7684 , 7685 , 7686 , 7687 , 7688 , 7689 , 7690 , 7691 , 7692 , 7693 , 7695 , 7696 , 7697 , 7698 , 7699 , 7700 , 7701 , 7702 , 7703 , 7704 , 7705 , 7706 , 7707 , 7708 , 7709 , 7711 , 7712 , 7713 , 7714 , 7715 , 7716 , 7717 , 7718 , 7719 , 7720 , 7721 , 7722 , 7723 , 7724 , 7725 , 7727 , 7728 , 7729 , 7730 , 7731 , 7732 , 7733 , 7734 , 7735 , 7737 , 7738 , 7739 , 7740 , 7741 , 7743 , 7744 , 7745 , 7746 , 7747 , 7748 , 7749 , 7750 , 7751 , 7752 , 7753 , 7754 , 7755 , 7756 , 7757 , 7759 , 7760 , 7761 , 7762 , 7763 , 7764 , 7765 , 7766 , 7767 , 7768 , 7769 , 7770 , 7771 , 7772 , 7773 , 7775 , 7776 , 7777 , 7778 , 7779 , 7780 , 7781 , 7782 , 7783 , 7784 , 7785 , 7786 , 7787 , 7788 , 7789 , 7791 , 7792 , 7793 , 7794 , 7795 , 7796 , 7797 , 7798 , 7799 , 7801 , 7802 , 7803 , 7804 , 7805 , 7807 , 7808 , 7809 , 7810 , 7811 , 7812 , 7813 , 7814 , 7815 , 7816 , 7817 , 7818 , 7819 , 7820 , 7821 , 7823 , 7824 , 7825 , 7826 , 7827 , 7828 , 7829 , 7830 , 7831 , 7832 , 7833 , 7834 , 7835 , 7836 , 7837 , 7839 , 7840 , 7841 , 7842 , 7843 , 7844 , 7845 , 7846 , 7847 , 7848 , 7849 , 7850 , 7851 , 7852 , 7853 , 7855 , 7856 , 7857 , 7858 , 7859 , 7860 , 7861 , 7862 , 7863 , 7865 , 7866 , 7867 , 7868 , 7869 , 7871 , 7872 , 7873 , 7874 , 7875 , 7876 , 7877 , 7878 , 7879 , 7880 , 7881 , 7882 , 7883 , 7884 , 7885 , 7887 , 7888 , 7889 , 7890 , 7891 , 7892 , 7893 , 7894 , 7895 , 7896 , 7897 , 7898 , 7899 , 7900 , 7901 , 7903 , 7905 , 7906 , 7907 , 7908 , 7909 , 7910 , 7911 , 7912 , 7913 , 7914 , 7915 , 7916 , 7917 , 7919 , 7920 , 7921 , 7922 , 7923 , 7924 , 7925 , 7926 , 7927 , 7929 , 7930 , 7931 , 7932 , 7933 , 7935 , 7937 , 7938 , 7939 , 7940 , 7941 , 7942 , 7943 , 7944 , 7945 , 7946 , 7947 , 7948 , 7949 , 7951 , 7952 , 7953 , 7954 , 7955 , 7956 , 7957 , 7958 , 7959 , 7960 , 7961 , 7962 , 7963 , 7965 , 7967 , 7968 , 7969 , 7970 , 7971 , 7972 , 7973 , 7974 , 7975 , 7976 , 7977 , 7978 , 7979 , 7980 , 7981 , 7983 , 7984 , 7985 , 7986 , 7987 , 7988 , 7989 , 7990 , 7991 , 7993 , 7994 , 7995 , 7996 , 7997 , 7999 , 8000 , 8001 , 8002 , 8003 , 8004 , 8005 , 8006 , 8007 , 8008 , 8009 , 8010 , 8011 , 8012 , 8013 , 8015 , 8016 , 8017 , 8018 , 8019 , 8020 , 8021 , 8022 , 8023 , 8024 , 8025 , 8026 , 8027 , 8028 , 8029 , 8031 , 8032 , 8033 , 8034 , 8035 , 8036 , 8037 , 8038 , 8039 , 8040 , 8041 , 8042 , 8043 , 8044 , 8045 , 8047 , 8048 , 8049 , 8050 , 8051 , 8052 , 8053 , 8054 , 8055 , 8057 , 8058 , 8059 , 8060 , 8061 , 8063 , 8065 , 8066 , 8067 , 8068 , 8069 , 8070 , 8071 , 8072 , 8073 , 8074 , 8075 , 8076 , 8077 , 8079 , 8080 , 8081 , 8082 , 8083 , 8084 , 8085 , 8086 , 8087 , 8088 , 8089 , 8090 , 8091 , 8092 , 8093 , 8095 , 8096 , 8097 , 8098 , 8099 , 8100 , 8101 , 8102 , 8103 , 8104 , 8105 , 8106 , 8107 , 8108 , 8109 , 8111 , 8112 , 8113 , 8114 , 8115 , 8116 , 8117 , 8118 , 8119 , 8121 , 8122 , 8123 , 8124 , 8125 , 8127 , 8129 , 8130 , 8131 , 8132 , 8133 , 8134 , 8135 , 8136 , 8137 , 8138 , 8139 , 8140 , 8141 , 8143 , 8144 , 8145 , 8146 , 8147 , 8148 , 8149 , 8150 , 8151 , 8152 , 8153 , 8154 , 8155 , 8156 , 8157 , 8159 , 8161 , 8162 , 8163 , 8164 , 8165 , 8166 , 8167 , 8168 , 8169 , 8170 , 8171 , 8172 , 8173 , 8175 , 8176 , 8177 , 8178 , 8179 , 8180 , 8181 , 8182 , 8183 , 8185 , 8186 , 8187 , 8188 , 8189 , 8191 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8203 , 8204 , 8205 , 8207 , 8208 , 8209 , 8210 , 8211 , 8212 , 8213 , 8214 , 8215 , 8216 , 8217 , 8218 , 8219 , 8220 , 8221 , 8223 , 8224 , 8225 , 8226 , 8227 , 8228 , 8229 , 8230 , 8231 , 8232 , 8233 , 8234 , 8235 , 8236 , 8237 , 8239 , 8240 , 8241 , 8242 , 8243 , 8244 , 8245 , 8246 , 8247 , 8249 , 8250 , 8251 , 8252 , 8253 , 8255 , 8256 , 8257 , 8258 , 8259 , 8260 , 8261 , 8262 , 8263 , 8264 , 8265 , 8266 , 8267 , 8268 , 8269 , 8271 , 8272 , 8273 , 8274 , 8275 , 8276 , 8277 , 8278 , 8279 , 8280 , 8281 , 8282 , 8283 , 8284 , 8285 , 8287 , 8289 , 8290 , 8291 , 8292 , 8293 , 8294 , 8295 , 8296 , 8297 , 8298 , 8299 , 8300 , 8301 , 8303 , 8304 , 8305 , 8306 , 8307 , 8308 , 8309 , 8310 , 8311 , 8313 , 8314 , 8315 , 8316 , 8317 , 8319 , 8320 , 8321 , 8322 , 8323 , 8324 , 8325 , 8326 , 8327 , 8328 , 8329 , 8330 , 8331 , 8332 , 8333 , 8335 , 8336 , 8337 , 8338 , 8339 , 8340 , 8341 , 8342 , 8343 , 8344 , 8345 , 8346 , 8347 , 8348 , 8349 , 8351 , 8352 , 8353 , 8354 , 8355 , 8356 , 8357 , 8358 , 8359 , 8360 , 8361 , 8362 , 8363 , 8364 , 8365 , 8367 , 8368 , 8369 , 8370 , 8371 , 8372 , 8373 , 8374 , 8375 , 8377 , 8378 , 8379 , 8380 , 8381 , 8383 , 8384 , 8385 , 8386 , 8387 , 8388 , 8389 , 8390 , 8391 , 8392 , 8393 , 8394 , 8395 , 8396 , 8397 , 8399 , 8400 , 8401 , 8402 , 8403 , 8404 , 8405 , 8406 , 8407 , 8408 , 8409 , 8410 , 8411 , 8412 , 8413 , 8415 , 8417 , 8418 , 8419 , 8420 , 8421 , 8422 , 8423 , 8424 , 8425 , 8426 , 8427 , 8428 , 8429 , 8431 , 8432 , 8433 , 8434 , 8435 , 8436 , 8437 , 8438 , 8439 , 8441 , 8442 , 8443 , 8444 , 8445 , 8447 , 8448 , 8449 , 8450 , 8451 , 8452 , 8453 , 8454 , 8455 , 8456 , 8457 , 8458 , 8459 , 8460 , 8461 , 8463 , 8464 , 8465 , 8466 , 8467 , 8468 , 8469 , 8470 , 8471 , 8472 , 8473 , 8474 , 8475 , 8476 , 8477 , 8479 , 8481 , 8482 , 8483 , 8484 , 8485 , 8486 , 8487 , 8488 , 8489 , 8490 , 8491 , 8492 , 8493 , 8495 , 8496 , 8497 , 8498 , 8499 , 8500 , 8501 , 8502 , 8503 , 8505 , 8506 , 8507 , 8508 , 8509 , 8511 , 8512 , 8513 , 8514 , 8515 , 8516 , 8517 , 8518 , 8519 , 8520 , 8521 , 8522 , 8523 , 8524 , 8525 , 8527 , 8528 , 8529 , 8530 , 8531 , 8532 , 8533 , 8534 , 8535 , 8536 , 8537 , 8538 , 8539 , 8540 , 8541 , 8543 , 8544 , 8545 , 8546 , 8547 , 8548 , 8549 , 8550 , 8551 , 8552 , 8553 , 8554 , 8555 , 8556 , 8557 , 8559 , 8560 , 8561 , 8562 , 8563 , 8564 , 8565 , 8566 , 8567 , 8569 , 8570 , 8571 , 8572 , 8573 , 8575 , 8577 , 8578 , 8579 , 8580 , 8581 , 8582 , 8583 , 8584 , 8585 , 8586 , 8587 , 8588 , 8589 , 8591 , 8592 , 8593 , 8594 , 8595 , 8596 , 8597 , 8598 , 8599 , 8600 , 8601 , 8602 , 8603 , 8604 , 8605 , 8607 , 8608 , 8609 , 8610 , 8611 , 8612 , 8613 , 8614 , 8615 , 8616 , 8617 , 8618 , 8619 , 8620 , 8621 , 8623 , 8624 , 8625 , 8626 , 8627 , 8628 , 8629 , 8630 , 8631 , 8633 , 8634 , 8635 , 8636 , 8637 , 8639 , 8640 , 8641 , 8642 , 8643 , 8644 , 8645 , 8646 , 8647 , 8648 , 8649 , 8650 , 8651 , 8652 , 8653 , 8655 , 8657 , 8658 , 8659 , 8660 , 8661 , 8662 , 8663 , 8664 , 8665 , 8666 , 8667 , 8668 , 8669 , 8671 , 8673 , 8674 , 8675 , 8676 , 8677 , 8678 , 8679 , 8680 , 8681 , 8682 , 8683 , 8684 , 8685 , 8687 , 8688 , 8689 , 8690 , 8691 , 8692 , 8693 , 8694 , 8695 , 8697 , 8698 , 8699 , 8700 , 8701 , 8703 , 8704 , 8705 , 8706 , 8707 , 8708 , 8709 , 8710 , 8711 , 8712 , 8713 , 8714 , 8715 , 8716 , 8717 , 8719 , 8720 , 8721 , 8722 , 8723 , 8724 , 8725 , 8726 , 8727 , 8728 , 8729 , 8730 , 8731 , 8732 , 8733 , 8735 , 8737 , 8738 , 8739 , 8740 , 8741 , 8742 , 8743 , 8744 , 8745 , 8746 , 8747 , 8748 , 8749 , 8751 , 8752 , 8753 , 8754 , 8755 , 8756 , 8757 , 8758 , 8759 , 8761 , 8762 , 8763 , 8764 , 8765 , 8767 , 8768 , 8769 , 8770 , 8771 , 8772 , 8773 , 8774 , 8775 , 8776 , 8777 , 8778 , 8779 , 8780 , 8781 , 8783 , 8784 , 8785 , 8786 , 8787 , 8788 , 8789 , 8790 , 8791 , 8793 , 8794 , 8795 , 8796 , 8797 , 8799 , 8800 , 8801 , 8802 , 8803 , 8804 , 8805 , 8806 , 8807 , 8808 , 8809 , 8810 , 8811 , 8812 , 8813 , 8815 , 8816 , 8817 , 8818 , 8819 , 8820 , 8821 , 8822 , 8823 , 8825 , 8826 , 8827 , 8828 , 8829 , 8831 , 8833 , 8834 , 8835 , 8836 , 8837 , 8838 , 8839 , 8841 , 8842 , 8843 , 8844 , 8845 , 8847 , 8848 , 8849 , 8850 , 8851 , 8852 , 8853 , 8854 , 8855 , 8856 , 8857 , 8858 , 8859 , 8860 , 8861 , 8863 , 8865 , 8866 , 8867 , 8868 , 8869 , 8870 , 8871 , 8872 , 8873 , 8874 , 8875 , 8876 , 8877 , 8879 , 8880 , 8881 , 8882 , 8883 , 8884 , 8885 , 8886 , 8887 , 8889 , 8890 , 8891 , 8892 , 8893 , 8895 , 8896 , 8897 , 8898 , 8899 , 8900 , 8901 , 8902 , 8903 , 8904 , 8905 , 8906 , 8907 , 8908 , 8909 , 8911 , 8912 , 8913 , 8914 , 8915 , 8916 , 8917 , 8918 , 8919 , 8920 , 8921 , 8922 , 8923 , 8924 , 8925 , 8927 , 8929 , 8930 , 8931 , 8932 , 8933 , 8934 , 8935 , 8936 , 8937 , 8938 , 8939 , 8940 , 8941 , 8943 , 8944 , 8945 , 8946 , 8947 , 8948 , 8949 , 8950 , 8951 , 8953 , 8954 , 8955 , 8956 , 8957 , 8959 , 8960 , 8961 , 8962 , 8963 , 8964 , 8965 , 8966 , 8967 , 8968 , 8969 , 8970 , 8971 , 8972 , 8973 , 8975 , 8976 , 8977 , 8978 , 8979 , 8980 , 8981 , 8982 , 8983 , 8984 , 8985 , 8986 , 8987 , 8988 , 8989 , 8991 , 8992 , 8993 , 8994 , 8995 , 8996 , 8997 , 8998 , 8999 , 9000 , 9001 , 9002 , 9003 , 9004 , 9005 , 9007 , 9008 , 9009 , 9010 , 9011 , 9012 , 9013 , 9014 , 9015 , 9017 , 9018 , 9019 , 9020 , 9021 , 9023 , 9024 , 9025 , 9026 , 9027 , 9028 , 9029 , 9030 , 9031 , 9032 , 9033 , 9034 , 9035 , 9036 , 9037 , 9039 , 9040 , 9041 , 9042 , 9043 , 9044 , 9045 , 9046 , 9047 , 9049 , 9050 , 9051 , 9052 , 9053 , 9055 , 9056 , 9057 , 9058 , 9059 , 9060 , 9061 , 9062 , 9063 , 9064 , 9065 , 9066 , 9067 , 9068 , 9069 , 9071 , 9072 , 9073 , 9074 , 9075 , 9076 , 9077 , 9078 , 9079 , 9081 , 9082 , 9083 , 9084 , 9085 , 9087 , 9089 , 9090 , 9091 , 9092 , 9093 , 9094 , 9095 , 9096 , 9097 , 9098 , 9099 , 9100 , 9101 , 9103 , 9104 , 9105 , 9106 , 9107 , 9108 , 9109 , 9110 , 9111 , 9112 , 9113 , 9114 , 9115 , 9116 , 9117 , 9119 , 9120 , 9121 , 9122 , 9123 , 9124 , 9125 , 9126 , 9127 , 9128 , 9129 , 9130 , 9131 , 9132 , 9133 , 9135 , 9136 , 9137 , 9138 , 9139 , 9140 , 9141 , 9142 , 9143 , 9145 , 9146 , 9147 , 9148 , 9149 , 9151 , 9152 , 9153 , 9154 , 9155 , 9156 , 9157 , 9158 , 9159 , 9160 , 9161 , 9162 , 9163 , 9164 , 9165 , 9167 , 9168 , 9169 , 9170 , 9171 , 9172 , 9173 , 9174 , 9175 , 9176 , 9177 , 9178 , 9179 , 9180 , 9181 , 9183 , 9185 , 9186 , 9187 , 9188 , 9189 , 9190 , 9191 , 9193 , 9194 , 9195 , 9196 , 9197 , 9199 , 9200 , 9201 , 9202 , 9203 , 9204 , 9205 , 9206 , 9207 , 9209 , 9210 , 9211 , 9212 , 9213 , 9215 , 9217 , 9218 , 9219 , 9220 , 9221 , 9222 , 9223 , 9224 , 9225 , 9226 , 9227 , 9228 , 9229 , 9231 , 9232 , 9233 , 9234 , 9235 , 9236 , 9237 , 9238 , 9239 , 9240 , 9241 , 9242 , 9243 , 9244 , 9245 , 9247 , 9248 , 9249 , 9250 , 9251 , 9252 , 9253 , 9254 , 9255 , 9256 , 9257 , 9258 , 9259 , 9260 , 9261 , 9263 , 9264 , 9265 , 9266 , 9267 , 9268 , 9269 , 9270 , 9271 , 9273 , 9274 , 9275 , 9276 , 9277 , 9279 , 9280 , 9281 , 9282 , 9283 , 9284 , 9285 , 9286 , 9287 , 9288 , 9289 , 9290 , 9291 , 9292 , 9293 , 9295 , 9296 , 9297 , 9298 , 9299 , 9300 , 9301 , 9302 , 9303 , 9304 , 9305 , 9306 , 9307 , 9308 , 9309 , 9311 , 9312 , 9313 , 9314 , 9315 , 9316 , 9317 , 9318 , 9319 , 9320 , 9321 , 9322 , 9323 , 9324 , 9325 , 9327 , 9328 , 9329 , 9330 , 9331 , 9332 , 9333 , 9334 , 9335 , 9337 , 9338 , 9339 , 9340 , 9341 , 9343 , 9344 , 9345 , 9346 , 9347 , 9348 , 9349 , 9350 , 9351 , 9352 , 9353 , 9354 , 9355 , 9356 , 9357 , 9359 , 9360 , 9361 , 9362 , 9363 , 9364 , 9365 , 9366 , 9367 , 9368 , 9369 , 9370 , 9371 , 9372 , 9373 , 9375 , 9376 , 9377 , 9378 , 9379 , 9380 , 9381 , 9382 , 9383 , 9384 , 9385 , 9386 , 9387 , 9388 , 9389 , 9391 , 9392 , 9393 , 9394 , 9395 , 9396 , 9397 , 9398 , 9399 , 9401 , 9402 , 9403 , 9404 , 9405 , 9407 , 9408 , 9409 , 9410 , 9411 , 9412 , 9413 , 9414 , 9415 , 9416 , 9417 , 9418 , 9419 , 9420 , 9421 , 9423 , 9425 , 9426 , 9427 , 9428 , 9429 , 9430 , 9431 , 9432 , 9433 , 9434 , 9435 , 9436 , 9437 , 9439 , 9441 , 9442 , 9443 , 9444 , 9445 , 9446 , 9447 , 9448 , 9449 , 9450 , 9451 , 9452 , 9453 , 9455 , 9456 , 9457 , 9458 , 9459 , 9460 , 9461 , 9462 , 9463 , 9465 , 9466 , 9467 , 9468 , 9469 , 9471 , 9473 , 9474 , 9475 , 9476 , 9477 , 9478 , 9479 , 9480 , 9481 , 9482 , 9483 , 9484 , 9485 , 9487 , 9488 , 9489 , 9490 , 9491 , 9492 , 9493 , 9494 , 9495 , 9496 , 9497 , 9498 , 9499 , 9500 , 9501 , 9503 , 9504 , 9505 , 9506 , 9507 , 9508 , 9509 , 9510 , 9511 , 9512 , 9513 , 9514 , 9515 , 9516 , 9517 , 9519 , 9520 , 9521 , 9522 , 9523 , 9524 , 9525 , 9526 , 9527 , 9529 , 9530 , 9531 , 9532 , 9533 , 9535 , 9537 , 9538 , 9539 , 9540 , 9541 , 9542 , 9543 , 9544 , 9545 , 9546 , 9547 , 9548 , 9549 , 9551 , 9552 , 9553 , 9554 , 9555 , 9556 , 9557 , 9558 , 9559 , 9560 , 9561 , 9562 , 9563 , 9564 , 9565 , 9567 , 9568 , 9569 , 9570 , 9571 , 9572 , 9573 , 9574 , 9575 , 9576 , 9577 , 9578 , 9579 , 9580 , 9581 , 9583 , 9584 , 9585 , 9586 , 9587 , 9588 , 9589 , 9590 , 9591 , 9593 , 9594 , 9595 , 9596 , 9597 , 9599 , 9600 , 9601 , 9602 , 9603 , 9604 , 9605 , 9606 , 9607 , 9608 , 9609 , 9610 , 9611 , 9612 , 9613 , 9615 , 9616 , 9617 , 9618 , 9619 , 9620 , 9621 , 9622 , 9623 , 9624 , 9625 , 9626 , 9627 , 9628 , 9629 , 9631 , 9632 , 9633 , 9634 , 9635 , 9636 , 9637 , 9638 , 9639 , 9640 , 9641 , 9642 , 9643 , 9644 , 9645 , 9647 , 9648 , 9649 , 9650 , 9651 , 9652 , 9653 , 9654 , 9655 , 9657 , 9658 , 9659 , 9660 , 9661 , 9663 , 9664 , 9665 , 9666 , 9667 , 9668 , 9669 , 9670 , 9671 , 9672 , 9673 , 9674 , 9675 , 9676 , 9677 , 9679 , 9680 , 9681 , 9682 , 9683 , 9684 , 9685 , 9686 , 9687 , 9688 , 9689 , 9690 , 9691 , 9692 , 9693 , 9695 , 9697 , 9698 , 9699 , 9700 , 9701 , 9702 , 9703 , 9704 , 9705 , 9706 , 9707 , 9708 , 9709 , 9711 , 9712 , 9713 , 9714 , 9715 , 9716 , 9717 , 9718 , 9719 , 9721 , 9722 , 9723 , 9724 , 9725 , 9727 , 9728 , 9729 , 9730 , 9731 , 9732 , 9733 , 9734 , 9735 , 9736 , 9737 , 9738 , 9739 , 9740 , 9741 , 9743 , 9744 , 9745 , 9746 , 9747 , 9748 , 9749 , 9750 , 9751 , 9752 , 9753 , 9754 , 9755 , 9756 , 9757 , 9759 , 9760 , 9761 , 9762 , 9763 , 9764 , 9765 , 9766 , 9767 , 9768 , 9769 , 9770 , 9771 , 9772 , 9773 , 9775 , 9776 , 9777 , 9778 , 9779 , 9780 , 9781 , 9782 , 9783 , 9785 , 9786 , 9787 , 9788 , 9789 , 9791 , 9792 , 9793 , 9794 , 9795 , 9796 , 9797 , 9798 , 9799 , 9800 , 9801 , 9802 , 9803 , 9804 , 9805 , 9807 , 9808 , 9809 , 9810 , 9811 , 9812 , 9813 , 9814 , 9815 , 9816 , 9817 , 9818 , 9819 , 9820 , 9821 , 9823 , 9825 , 9826 , 9827 , 9828 , 9829 , 9830 , 9831 , 9832 , 9833 , 9834 , 9835 , 9837 , 9839 , 9840 , 9841 , 9842 , 9843 , 9844 , 9845 , 9846 , 9847 , 9849 , 9850 , 9851 , 9852 , 9853 , 9855 , 9856 , 9857 , 9858 , 9859 , 9860 , 9861 , 9862 , 9863 , 9864 , 9865 , 9866 , 9867 , 9868 , 9869 , 9871 , 9872 , 9873 , 9874 , 9875 , 9876 , 9877 , 9878 , 9879 , 9880 , 9881 , 9882 , 9883 , 9884 , 9885 , 9887 , 9888 , 9889 , 9890 , 9891 , 9892 , 9893 , 9894 , 9895 , 9896 , 9897 , 9898 , 9899 , 9900 , 9901 , 9903 , 9904 , 9905 , 9906 , 9907 , 9908 , 9909 , 9910 , 9911 , 9913 , 9914 , 9915 , 9916 , 9917 , 9919 , 9921 , 9922 , 9923 , 9924 , 9925 , 9926 , 9927 , 9928 , 9929 , 9930 , 9931 , 9932 , 9933 , 9935 , 9936 , 9937 , 9938 , 9939 , 9940 , 9941 , 9942 , 9943 , 9944 , 9945 , 9946 , 9947 , 9948 , 9949 , 9951 , 9953 , 9954 , 9955 , 9956 , 9957 , 9958 , 9959 , 9960 , 9961 , 9962 , 9963 , 9964 , 9965 , 9967 , 9969 , 9970 , 9971 , 9972 , 9973 , 9974 , 9975 , 9977 , 9978 , 9979 , 9980 , 9981 , 9983 , 9985 , 9986 , 9987 , 9988 , 9989 , 9990 , 9991 , 9992 , 9993 , 9994 , 9995 , 9996 , 9997 , 9999 , 10000 , 10001 } <NEWLINE> <NL> <COMMENT> <NL> well_known_i = [ <STRING> , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 0 , 0 , 0 , 0 , 0 , 1 , 6 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 6 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 3 , 3 , 6 , 0 , 6 , 0 , 0 , 0 , 3 , 0 , 0 , 1 , 6 , 0 , 6 , 6 , 0 , 0 , 6 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 6 , 0 , 6 , 3 , 6 , 0 , 0 , 0 , 6 , 0 , 0 , 0 , 3 , 3 , 9 , 0 , 6 , 3 , 6 , 0 , 3 , 6 , 0 , 0 , 0 , 0 , 6 , 1 , 6 , 0 , 6 , 6 , 0 , 3 , 12 , 0 , 6 , 0 , 0 , 3 , 6 , 0 , 0 , 0 , 3 , 3 , 12 , 0 , 6 , 3 , 6 , 0 , 3 , 6 , 9 , 0 , 6 , 0 , 0 , 0 , 3 , 6 , 3 , 3 , 6 , 0 , 6 , 3 , 12 , 0 , 3 , 6 , 6 , 0 , 6 , 0 , 6 , 3 , 6 , 0 , 0 , 1 , 6 , 3 , 12 , 6 , 0 , 0 , 12 , 0 , 6 , 0 , 6 , 6 , 12 , 0 , 0 , 6 , 0 , 0 , 6 , 0 , 12 , 3 , 6 , 0 , 6 , 3 , 9 , 6 , 3 , 6 , 6 , 0 , 6 , 0 , 6 , 0 , 15 , 6 , 0 , 0 , 6 , 0 , 3 , 3 , 12 , 0 , 12 , 6 , 6 , 0 , 3 , 6 , 6 , 3 , 12 , 0 , 6 , 0 , 9 , 6 , 0 , 0 , 6 , 3 , 12 , 1 , 6 , 6 , 6 , 6 , 0 , 0 , 18 , 0 , 12 , 0 , 3 , 6 , 12 , 0 , 0 , 6 , 3 , 6 , 12 , 0 , 12 , 0 , 0 , 0 , 9 , 3 , 9 , 6 , 12 , 3 , 12 , 0 , 3 , 6 , 6 , 0 , 12 , 0 , 12 , 0 , 9 , 9 , 0 , 0 , 6 , 3 , 6 , 3 , 12 , 6 , 9 , 3 , 6 , 0 , 12 , 3 , 6 , 3 , 9 , 6 , 12 , 6 , 6 , 0 , 6 , 0 , 9 , 6 , 6 , 0 , 12 , 3 , 6 , 0 , 9 , 6 , 6 , 1 , 6 , 0 , 21 , 12 , 6 , 0 , 12 , 0 , 12 , 0 , 0 , 6 , 15 , 6 , 0 , 6 , 12 , 0 , 12 , 0 , 12 , 0 , 0 , 0 , 12 , 0 , 12 , 12 , 3 , 3 , 18 , 3 , 6 , 3 , 6 , 6 , 9 , 9 , 18 , 0 , 6 , 0 , 12 , 0 , 9 , 6 , 0 , 3 , 12 , 3 , 6 , 6 , 12 , 6 , 6 , 0 , 0 , 0 , 15 , 3 , 18 , 3 , 18 , 3 , 12 , 6 , 3 , 6 , 9 , 0 , 12 , 0 , 12 , 0 , 18 , 12 , 0 , 0 , 12 , 3 , 6 , 0 , 6 , 6 , 9 , 6 , 0 , 0 , 18 , 1 , 18 , 3 , 12 , 6 , 6 , 6 , 12 , 0 , 15 , 6 , 12 , 6 , 18 , 0 , 0 , 6 , 0 , 9 , 12 , 0 , 18 , 0 , 6 , 3 , 12 , 0 , 12 , 12 , 0 , 0 , 12 , 0 , 3 , 6 , 12 , 6 , 18 , 9 , 18 , 0 , 9 , 6 , 18 , 0 , 6 , 0 , 6 , 3 , 27 , 6 , 6 , 6 , 6 , 3 , 6 , 0 , 12 , 6 , 9 , 0 , 6 , 0 , 18 , 0 , 9 , 9 , 15 , 3 , 12 , 6 , 6 , 3 , 9 , 6 , 12 , 12 , 18 , 0 , 18 , 0 , 6 , 6 , 21 , 6 , 0 , 0 , 6 , 3 , 15 , 6 , 12 , 6 , 18 , 0 , 0 , 0 , 12 , 6 , 6 , 3 , 6 , 4 , 18 , 6 , 12 , 6 , 3 , 9 , 30 , 0 , 18 , 0 , 6 , 6 , 12 , 6 , 6 , 9 , 12 , 0 , 18 , 6 , 18 , 0 , 6 , 0 , 12 , 0 , 6 , 12 , 6 , 3 , 18 , 0 , 6 , 6 , 6 , 6 , 15 , 3 , 24 , 0 , 6 , 3 , 18 , 0 , 12 , 6 , 12 , 6 , 24 , 0 , 15 , 18 , 9 , 6 , 0 , 0 , 18 , 3 , 6 , 0 , 15 , 12 , 12 , 6 , 6 , 0 , 18 , 0 , 6 , 3 , 12 , 0 , 12 , 6 , 6 , 9 , 9 , 6 , 24 , 3 , 24 , 0 , 9 , 12 , 6 , 6 , 12 , 0 , 12 , 0 , 21 , 9 , 15 , 6 , 12 , 3 , 18 , 3 , 12 , 6 , 12 , 6 , 0 , 0 , 12 , 0 , 12 , 6 , 24 , 0 , 6 , 12 , 6 , 1 , 9 , 6 , 12 , 6 , 24 , 0 , 18 , 3 , 12 , 6 , 6 , 12 , 24 , 0 , 12 , 6 , 15 , 6 , 18 , 0 , 18 , 0 , 0 , 0 , 18 , 9 , 21 , 12 , 0 , 6 , 18 , 0 , 9 , 6 , 6 , 6 , 12 , 0 , 12 , 0 , 9 , 9 , 27 , 6 , 6 , 3 , 18 , 6 , 21 , 6 , 6 , 12 , 12 , 0 , 12 , 0 , 24 , 12 , 0 , 0 , 24 , 3 , 24 , 6 , 12 , 12 , 18 , 0 , 0 , 0 , 12 , 0 , 18 , 3 , 15 , 6 , 12 , 9 , 6 , 0 , 15 , 6 , 9 , 12 , 24 , 0 , 12 , 3 , 6 , 6 , 21 , 6 , 18 , 3 , 18 , 0 , 21 , 12 , 15 , 6 , 6 , 0 , 12 , 3 , 12 , 9 , 18 , 9 , 12 , 6 , 6 , 6 , 24 , 0 , 18 , 3 , 24 , 0 , 6 , 6 , 0 , 6 , 9 , 6 , 6 , 4 , 30 , 0 , 18 , 12 , 9 , 6 , 24 , 0 , 18 , 0 , 9 , 12 , 21 , 6 , 6 , 12 , 12 , 0 , 18 , 0 , 21 , 15 , 12 , 0 , 12 , 6 , 12 , 12 , 18 , 0 , 18 , 0 , 6 , 0 , 9 , 12 , 18 , 6 , 30 , 0 , 0 , 0 , 24 , 6 , 9 , 3 , 12 , 6 , 30 , 3 , 6 , 12 , 6 , 12 , 12 , 0 , 36 , 0 , 6 , 3 , 27 , 12 , 12 , 6 , 6 , 6 , 24 , 0 , 12 , 6 , 12 , 0 , 18 , 0 , 18 , 15 , 18 , 3 , 18 , 6 , 12 , 6 , 6 , 12 , 3 , 6 , 6 , 0 , 12 , 3 , 39 , 3 , 12 , 12 , 12 , 3 , 18 , 0 , 21 , 12 , 21 , 6 , 18 , 0 , 12 , 0 , 9 , 9 , 12 , 9 , 24 , 9 , 12 , 6 , 12 , 6 , 33 , 0 , 6 , 0 , 18 , 0 , 9 , 15 , 12 , 6 , 24 , 6 , 6 , 3 , 15 , 6 , 15 , 12 , 18 , 0 , 18 , 1 , 18 , 6 , 12 , 6 , 6 , 0 , 24 , 6 , 24 , 12 , 18 , 6 , 24 , 0 , 6 , 6 , 12 , 15 , 24 , 0 , 24 , 6 , 6 , 0 , 18 , 0 , 15 , 18 , 12 , 0 , 24 , 0 , 12 , 6 , 12 , 12 , 18 , 6 , 24 , 0 , 0 , 6 , 24 , 3 , 12 , 0 , 12 , 6 , 30 , 9 , 6 , 12 , 24 , 12 , 12 , 0 , 15 , 18 , 12 , 0 , 18 , 0 , 24 , 6 , 15 , 6 , 18 , 3 , 18 , 3 , 12 , 6 , 24 , 12 , 12 , 12 , 6 , 0 , 36 , 0 , 18 , 3 , 6 , 12 , 6 , 9 , 12 , 0 , 3 , 12 , 36 , 0 , 30 , 0 , 12 , 0 , 18 , 6 , 12 , 9 , 12 , 6 , 24 , 3 , 18 , 12 , 15 , 9 , 24 , 0 , 18 , 6 , 18 , 9 , 18 , 12 , 6 , 6 , 24 , 3 , 24 , 0 , 12 , 12 , 12 , 0 , 6 , 0 , 27 , 12 , 18 , 3 , 30 , 3 , 18 , 6 , 0 , 12 , 15 , 6 , 18 , 0 , 24 , 0 , 9 , 6 , 9 , 12 , 18 , 7 , 24 , 0 , 24 , 12 , 15 , 12 , 24 , 0 , 24 , 0 , 6 , 9 , 30 , 9 , 6 , 6 , 0 , 9 , 33 , 12 , 36 , 0 , 12 , 0 , 18 , 0 , 6 , 21 , 12 , 6 , 36 , 6 , 0 , 3 , 18 , 6 , 12 , 6 , 24 , 0 , 12 , 3 , 24 , 6 , 9 , 12 , 6 , 6 , 30 , 6 , 18 , 12 , 9 , 9 , 12 , 0 , 30 , 3 , 18 , 3 , 27 , 6 , 30 , 12 , 12 , 0 , 24 , 0 , 27 , 12 , 6 , 0 , 24 , 3 , 18 , 18 , 9 , 6 , 18 , 0 , 12 , 3 , 33 , 18 , 12 , 9 , 6 , 0 , 12 , 6 , 30 , 0 , 24 , 12 , 12 , 0 , 30 , 6 , 6 , 6 , 0 , 6 , 24 , 0 , 12 , 0 , 18 , 15 , 33 , 6 , 30 , 15 , 18 , 0 , 9 , 12 , 24 , 9 , 12 , 0 , 18 , 6 , 27 , 18 , 15 , 6 , 18 , 3 , 24 , 0 , 6 , 6 , 36 , 12 , 18 , 0 , 12 , 3 , 30 , 3 , 12 , 6 , 12 , 15 , 6 , 0 , 18 , 12 , 15 , 9 , 30 , 0 , 18 , 6 , 12 , 12 , 18 , 6 , 6 , 3 , 24 , 1 , 27 , 12 , 18 , 6 , 18 , 0 , 24 , 0 , 18 , 15 , 15 , 21 , 30 , 6 , 12 , 12 , 18 , 0 , 30 , 6 , 24 , 0 , 6 , 0 , 18 , 6 , 36 , 12 , 6 , 6 , 36 , 0 , 6 , 12 , 12 , 12 , 24 , 0 , 30 , 0 , 9 , 6 , 18 , 0 , 18 , 12 , 12 , 6 , 24 , 6 , 9 , 15 , 12 , 0 , 12 , 6 , 30 , 9 , 18 , 0 , 42 , 3 , 18 , 6 , 12 , 18 , 33 , 12 , 12 , 0 , 18 , 0 , 21 , 12 , 12 , 12 , 24 , 6 , 30 , 0 , 27 , 18 , 6 , 12 , 6 , 0 , 24 , 0 , 18 , 15 , 30 , 0 , 18 , 12 , 6 , 0 , 21 , 6 , 21 , 12 , 24 , 0 , 30 , 0 , 6 , 6 , 6 , 12 , 24 , 0 , 30 , 12 , 9 , 12 , 21 , 3 , 24 , 0 , 12 , 3 , 21 , 18 , 9 , 18 , 18 , 6 , 30 , 3 , 42 , 6 , 21 , 6 , 30 , 0 , 6 , 3 , 24 , 9 , 36 , 6 , 6 , 9 , 12 , 6 , 18 , 12 , 33 , 9 , 12 , 0 , 24 , 9 , 9 , 6 , 3 , 18 , 36 , 6 , 18 , 0 , 24 , 6 , 6 , 6 , 18 , 0 , 12 , 0 , 30 , 3 , 39 , 12 , 12 , 7 , 18 , 0 , 15 , 18 , 18 , 9 , 36 , 0 , 24 , 6 , 6 , 18 , 30 , 0 , 18 , 9 , 18 , 3 , 24 , 6 , 21 , 12 , 24 , 0 , 30 , 3 , 33 , 24 , 12 , 6 , 18 , 6 , 6 , 6 , 18 , 6 , 18 , 12 , 18 , 0 , 24 , 6 , 36 , 3 , 18 , 6 , 0 , 12 , 30 , 0 , 9 , 24 , 18 , 0 , 24 , 0 , 18 , 0 , 0 , 12 , 30 , 15 , 30 , 6 , 18 , 3 , 30 , 0 , 24 , 18 , 12 , 0 , 36 , 3 , 24 , 12 , 15 , 18 , 18 , 6 , 24 , 3 , 24 , 12 , 18 , 12 , 24 , 0 , 0 , 6 , 39 , 6 , 24 , 3 , 18 , 3 , 42 , 6 , 12 , 12 , 15 , 9 , 30 , 0 , 12 , 0 , 18 , 6 , 18 , 12 , 24 , 15 , 12 , 0 , 12 , 12 , 30 , 12 , 12 , 0 , 18 , 0 , 15 , 15 , 18 , 18 , 30 , 3 , 24 , 12 , 9 , 6 , 48 , 0 , 18 , 0 , 30 , 0 , 21 , 6 , 12 , 12 , 24 , 12 , 18 , 3 , 48 , 24 , 6 , 6 , 18 , 0 , 36 , 0 , 12 , 15 , 27 , 6 , 12 , 12 , 18 , 6 , 27 , 6 , 12 , 9 , 18 , 0 , 24 , 6 , 18 , 18 , 21 , 0 , 36 , 0 , 12 , 0 , 18 , 12 , 21 , 18 , 24 , 0 , 12 , 1 , 18 , 9 , 21 , 18 , 6 , 9 , 42 , 3 , 36 , 12 , 12 , 12 , 30 , 0 , 12 , 6 , 21 , 12 , 36 , 6 , 24 , 9 , 12 , 6 , 12 , 12 , 24 , 12 , 18 , 0 , 42 , 0 , 15 , 6 , 15 , 15 , 42 , 6 , 30 , 6 , 12 , 12 , 18 , 12 , 18 , 0 , 6 , 6 , 36 , 0 , 30 , 18 , 6 , 0 , 6 , 0 , 30 , 18 , 18 , 0 , 42 , 0 , 18 , 6 , 15 , 18 , 24 , 0 , 12 , 6 , 36 , 9 , 33 , 12 , 12 , 12 , 18 , 0 , 36 , 0 , 21 , 21 , 15 , 18 , 18 , 15 , 18 , 0 , 18 , 6 , 42 , 6 , 24 , 0 , 18 , 3 , 42 , 6 , 18 , 12 , 12 , 12 , 18 , 0 , 15 , 12 , 18 , 12 , 36 , 0 , 30 , 12 , 3 , 21 , 18 , 0 , 30 , 6 , 24 , 0 , 27 , 12 , 18 , 12 , 6 , 0 , 12 , 0 , 36 , 15 , 15 , 3 , 36 , 12 , 18 , 6 , 30 , 6 , 33 , 12 , 12 , 0 , 12 , 6 , 24 , 6 , 54 , 18 , 12 , 3 , 36 , 9 , 9 , 12 , 12 , 18 , 36 , 0 , 6 , 0 , 21 , 15 , 27 , 9 , 24 , 12 , 30 , 6 , 24 , 6 , 27 , 18 , 12 , 0 , 30 , 0 , 21 , 12 , 18 , 6 , 30 , 0 , 18 , 0 , 21 , 18 , 21 , 6 , 30 , 0 , 24 , 3 , 6 , 6 , 15 , 27 , 12 , 10 , 42 , 6 , 36 , 12 , 12 , 6 , 24 , 0 , 24 , 6 , 12 , 12 , 48 , 6 , 18 , 12 , 0 , 3 , 51 , 6 , 30 , 6 , 24 , 0 , 24 , 0 , 30 , 21 , 15 , 12 , 24 , 9 , 18 , 6 , 18 , 12 , 30 , 9 , 24 , 0 , 18 , 0 , 27 , 18 , 9 , 6 , 18 , 9 , 54 , 0 , 18 , 24 , 21 , 18 , 12 , 0 , 24 , 0 , 12 , 0 , 30 , 9 , 30 , 12 , 6 , 9 , 24 , 6 , 15 , 15 , 18 , 0 , 30 , 3 , 33 , 18 , 21 , 12 , 42 , 3 , 30 , 6 , 6 , 24 , 27 , 6 , 12 , 0 , 24 , 3 , 42 , 6 , 42 , 9 , 12 , 6 , 18 , 6 , 24 , 12 , 12 , 12 , 54 , 0 , 6 , 12 , 18 , 6 , 18 , 18 , 30 , 12 , 30 , 0 , 18 , 0 , 27 , 18 , 24 , 0 , 18 , 0 , 15 , 24 , 21 , 6 , 24 , 3 , 36 , 6 , 6 , 6 , 45 , 21 , 18 , 0 , 18 , 6 , 33 , 3 , 18 , 0 , 24 , 15 , 30 , 0 , 30 , 24 , 12 , 6 , 36 , 0 , 24 , 3 , 21 , 24 , 18 , 15 , 30 , 3 , 12 , 6 , 42 , 12 , 12 , 12 , 6 , 0 , 54 , 6 , 30 , 15 , 24 , 18 , 24 , 6 , 12 , 0 , 9 , 6 , 30 , 0 , 48 , 0 , 24 , 0 , 15 , 12 , 39 , 12 , 24 , 6 , 24 , 6 , 15 , 30 , 12 , 6 , 24 , 0 , 24 , 3 , 24 , 12 , 24 , 6 , 6 , 18 , 12 , 4 , 54 , 6 , 21 , 18 , 18 , 0 , 36 , 6 , 24 , 9 , 30 , 12 , 24 , 9 , 36 , 6 , 12 , 18 , 42 , 3 , 30 , 0 , 6 , 9 , 21 , 6 , 12 , 30 , 30 , 6 , 30 , 0 , 27 , 12 , 9 , 18 , 30 , 0 , 36 , 0 , 18 , 9 , 42 , 6 , 24 , 12 , 0 , 6 , 51 , 12 , 24 , 12 , 12 , 0 , 18 , 6 , 12 , 18 , 6 , 6 , 36 , 3 , 54 , 9 , 18 , 6 , 27 , 12 , 18 , 0 , 30 , 0 , 39 , 9 , 18 , 18 , 12 , 9 , 30 , 6 , 21 , 12 , 27 , 18 , 24 , 0 , 12 , 0 , 42 , 18 , 42 , 6 , 24 , 15 , 18 , 0 , 24 , 12 , 45 , 12 , 6 , 0 , 54 , 0 , 15 , 21 , 6 , 6 , 30 , 6 , 18 , 12 , 24 , 18 , 30 , 6 , 36 , 0 , 12 , 3 , 24 , 12 , 18 , 18 , 18 , 12 , 24 , 0 , 33 , 12 , 27 , 6 , 42 , 0 , 18 , 6 , 9 , 15 , 30 , 6 , 30 , 6 , 12 , 6 , 18 , 6 , 33 , 15 , 30 , 0 , 36 , 3 , 27 , 21 , 33 , 24 , 30 , 9 , 24 , 0 , 12 , 18 , 33 , 6 , 6 , 0 , 18 , 3 , 57 , 12 , 24 , 18 , 30 , 9 , 18 , 0 , 18 , 12 , 27 , 12 , 36 , 0 , 36 , 6 , 12 , 6 , 27 , 12 , 30 , 9 , 24 , 6 , 39 , 18 , 12 , 24 , 12 , 0 , 30 , 0 , 30 , 6 , 15 , 15 , 18 , 3 , 24 , 18 , 9 , 12 , 30 , 9 , 30 , 0 , 18 , 6 , 42 , 18 , 30 , 0 , 6 , 10 , 48 , 0 , 24 , 12 , 12 , 18 , 48 , 0 , 30 , 3 , 30 , 15 , 18 , 6 , 24 , 18 , 18 , 0 , 42 , 6 , 36 , 15 , 24 , 0 , 42 , 12 , 21 , 24 , 12 , 12 , 24 , 0 , 12 , 6 , 18 , 18 , 60 , 6 , 30 , 0 , 12 , 0 , 24 , 0 , 12 , 18 , 30 , 15 , 42 , 0 , 33 , 30 , 6 , 6 , 12 , 0 , 42 , 3 , 27 , 6 , 33 , 12 , 36 , 12 , 18 , 0 , 30 , 6 , 18 , 12 , 12 , 0 , 18 , 6 , 15 , 27 , 27 , 6 , 42 , 6 , 36 , 9 , 18 , 30 , 33 , 9 , 30 , 0 , 6 , 6 , 54 , 6 , 36 , 24 , 24 , 0 , 30 , 3 , 12 , 6 , 21 , 24 , 30 , 0 , 24 , 0 , 24 , 12 , 42 , 9 , 42 , 21 , 12 , 12 , 27 , 12 , 27 , 6 , 12 , 0 , 48 , 6 , 12 , 18 , 12 , 12 , 36 , 6 , 30 , 0 , 24 , 0 , 42 , 12 , 12 , 0 , 36 , 0 , 24 , 15 , 21 , 21 , 18 , 6 , 12 , 9 , 36 , 18 , 18 , 15 , 42 , 0 , 18 , 6 , 9 , 18 , 48 , 12 , 30 , 9 , 24 , 3 , 33 , 6 , 18 , 18 , 18 , 0 , 36 , 3 , 54 , 24 , 3 , 12 , 36 , 9 , 36 , 6 , 30 , 12 , 36 , 12 , 24 , 0 , 18 , 6 , 24 , 6 , 42 , 0 , 24 , 18 , 18 , 0 , 9 , 30 , 39 , 12 , 42 , 0 , 36 , 0 , 12 , 12 , 21 , 12 , 18 , 12 , 24 , 6 , 45 , 6 , 18 , 24 , 18 , 0 , 36 , 0 , 42 , 15 , 18 , 6 , 24 , 6 , 12 , 12 , 18 , 12 , 30 , 6 , 18 , 0 , 30 , 1 , 30 , 9 , 57 , 9 , 12 , 9 , 48 , 6 , 21 , 24 , 18 , 12 , 66 , 0 , 18 , 6 , 9 , 24 , 24 , 24 , 30 , 12 , 18 , 0 , 48 , 6 , 24 , 18 , 18 , 0 , 24 , 3 , 27 , 18 , 24 , 12 , 36 , 6 , 48 , 6 , 15 , 18 , 42 , 6 , 24 , 0 , 12 , 12 , 36 , 6 , 6 , 24 , 12 , 3 , 48 , 0 , 48 , 18 , 0 , 12 , 18 , 0 , 36 , 6 , 18 , 9 , 54 , 15 , 12 , 12 , 6 , 6 , 39 , 6 , 24 , 18 , 42 , 0 , 30 , 0 , 33 , 18 , 24 , 18 , 18 , 9 , 18 , 0 , 15 , 18 , 54 , 0 , 36 , 0 , 24 , 0 , 48 , 24 , 15 , 18 , 18 , 12 , 42 , 9 , 24 , 12 , 36 , 21 , 30 , 0 , 36 , 12 , 24 , 3 , 30 , 0 , 48 , 15 , 12 , 6 , 15 , 18 , 18 , 18 , 24 , 0 , 30 , 0 , 24 , 24 , 18 , 9 , 72 , 0 , 30 , 6 , 21 , 18 , 30 , 6 , 24 , 0 , 0 , 6 , 24 , 18 , 42 , 12 , 6 , 15 , 36 , 0 , 30 , 18 , 30 , 12 , 24 , 0 , 6 , 0 , 18 , 12 , 54 , 9 , 36 , 9 , 36 , 9 , 30 , 6 , 27 , 27 , 24 , 0 , 54 , 6 , 21 , 18 , 21 , 6 , 36 , 15 , 36 , 3 , 30 , 12 , 6 , 18 , 30 , 0 , 18 , 6 , 54 , 0 , 30 , 21 , 36 , 9 , 30 , 6 , 30 , 24 , 24 , 6 , 30 , 0 , 36 , 12 , 9 , 24 , 24 , 12 , 18 , 9 , 30 , 0 , 48 , 12 , 24 , 12 , 12 , 0 , 48 , 0 , 18 , 12 , 24 , 24 , 30 , 6 , 18 , 12 , 21 , 12 , 24 , 0 , 66 , 0 , 12 , 0 , 30 , 9 , 24 , 24 , 18 , 13 , 42 , 3 , 18 , 18 , 27 , 24 , 24 , 0 , 30 , 6 , 15 , 18 , 39 , 12 , 12 , 9 , 36 , 12 , 54 , 12 , 42 , 18 , 6 , 0 , 36 , 0 , 51 , 18 , 12 , 0 , 66 , 12 , 24 , 0 , 6 , 24 , 51 , 12 , 24 , 0 , 24 , 0 , 33 , 6 , 18 , 18 , 30 , 6 , 42 , 3 , 18 , 30 , 15 , 15 , 30 , 0 , 30 , 6 , 30 , 12 , 48 , 12 , 24 , 12 , 12 , 9 , 36 , 6 , 36 , 6 , 12 , 0 , 30 , 0 , 24 , 21 , 24 , 15 , 42 , 12 , 24 , 6 , 9 , 18 , 15 , 9 , 42 , 0 , 24 , 12 , 66 , 12 , 30 , 24 , 6 , 9 , 54 , 0 , 36 , 12 , 21 , 12 , 36 , 0 , 24 , 3 , 24 , 15 , 36 , 6 , 30 , 24 , 12 , 6 , 33 , 6 , 39 , 21 , 30 , 0 , 42 , 6 , 12 , 30 , 30 , 18 , 36 , 0 , 48 , 3 , 36 , 12 , 30 , 18 , 18 , 0 , 24 , 0 , 30 , 6 , 33 , 21 , 24 , 6 , 18 , 12 , 24 , 12 , 12 , 15 , 48 , 0 , 24 , 6 , 21 , 21 , 60 , 6 , 24 , 12 , 18 , 0 , 30 , 12 , 15 , 12 , 24 , 0 , 24 , 3 , 60 , 27 , 18 , 12 , 30 , 3 , 24 , 9 , 21 , 12 , 60 , 18 , 24 , 0 , 24 , 9 , 33 , 6 , 36 , 12 , 24 , 15 , 42 , 6 , 27 , 36 , 27 , 6 , 42 , 0 , 42 , 6 , 12 , 15 , 15 , 24 , 42 , 18 , 12 , 0 , 33 , 6 , 21 , 18 , 24 , 0 , 48 , 3 , 36 , 9 , 24 , 24 , 30 , 6 , 36 , 0 , 39 , 18 , 60 , 6 , 18 , 0 , 12 , 6 , 21 , 27 , 30 , 0 , 18 , 6 , 42 , 6 , 42 , 18 , 24 , 9 , 48 , 0 , 6 , 6 , 18 , 18 , 18 , 6 , 18 , 15 , 30 , 4 , 60 , 12 , 30 , 30 , 18 , 0 , 36 , 0 , 27 , 18 , 30 , 18 , 48 , 9 , 30 , 12 , 18 , 6 , 42 , 9 , 48 , 0 , 18 , 6 , 42 , 6 , 30 , 24 , 12 , 3 , 36 , 0 , 36 , 36 , 15 , 18 , 30 , 0 , 66 , 0 , 12 , 18 , 42 , 9 , 24 , 15 , 18 , 12 , 54 , 6 , 18 , 21 , 36 , 0 , 30 , 6 , 24 , 24 , 12 , 6 , 24 , 9 , 36 , 12 , 6 , 12 , 45 , 12 , 36 , 0 , 36 , 0 , 48 , 3 , 24 , 18 , 12 , 24 , 36 , 0 , 30 , 12 , 30 , 21 , 30 , 0 , 6 , 15 , 18 , 15 , 66 , 12 , 42 , 3 , 12 , 0 , 39 , 12 , 30 , 12 , 18 , 0 , 54 , 6 , 30 , 24 , 9 , 12 , 60 , 12 , 30 , 12 , 30 , 24 , 24 , 18 , 30 , 0 , 36 , 0 , 27 , 9 , 45 , 18 , 24 , 12 , 24 , 0 , 36 , 24 , 12 , 6 , 60 , 0 , 18 , 0 , 24 , 15 , 51 , 9 , 24 , 12 , 30 , 12 , 27 , 18 , 51 , 18 , 24 , 0 , 36 , 6 , 27 , 27 , 12 , 30 , 36 , 6 , 30 , 0 , 12 , 6 , 42 , 0 , 18 , 0 , 18 , 0 , 48 , 12 , 45 , 24 , 6 , 15 , 42 , 6 , 12 , 18 , 27 , 9 , 54 , 0 , 42 , 3 , 33 , 12 , 15 , 12 , 54 , 18 , 30 , 6 , 36 , 18 , 21 , 30 , 18 , 0 , 48 , 3 , 30 , 18 , 36 , 6 , 18 , 0 , 18 , 12 , 57 , 24 , 42 , 6 , 24 , 0 , 18 , 12 , 36 , 18 , 30 , 12 , 36 , 3 , 78 , 0 , 24 , 6 , 6 , 36 , 42 , 0 , 24 , 0 , 21 , 15 , 33 , 6 , 42 , 18 , 12 , 3 , 30 , 12 , 30 , 27 , 24 , 0 , 42 , 12 , 39 , 12 , 30 , 12 , 30 , 15 , 30 , 6 , 12 , 24 , 54 , 6 , 24 , 0 , 18 , 6 , 33 , 12 , 18 , 24 , 24 , 7 , 30 , 0 , 60 , 24 , 21 , 12 , 30 , 0 , 48 , 6 , 18 , 15 , 39 , 12 , 18 , 18 , 18 , 0 , 48 , 12 , 54 , 18 , 42 , 0 , 30 , 0 , 15 , 30 , 27 , 18 , 72 , 0 , 30 , 15 , 12 , 12 , 30 , 18 , 36 , 0 , 6 , 3 , 60 , 15 , 24 , 18 , 6 , 18 , 54 , 6 , 21 , 24 , 24 , 12 , 30 , 0 , 30 , 6 , 30 , 15 , 54 , 6 , 48 , 12 , 30 , 12 , 36 , 0 , 24 , 3 , 24 , 0 , 54 , 6 , 18 , 30 , 15 , 6 , 42 , 9 , 36 , 0 , 21 , 30 , 15 , 12 , 12 , 0 , 24 , 3 , 72 , 0 , 51 , 39 , 24 , 12 , 30 , 3 , 33 , 18 , 15 , 12 , 42 , 0 , 30 , 12 , 27 , 24 , 51 , 12 , 42 , 12 , 18 , 3 , 42 , 12 , 39 , 18 , 12 , 0 , 30 , 0 , 24 , 21 , 21 , 21 , 30 , 6 , 66 , 12 , 12 , 6 , 69 , 21 , 30 , 0 , 24 , 6 , 45 , 12 , 12 , 18 , 42 , 12 , 18 , 0 , 39 , 30 , 33 , 12 , 54 , 0 , 12 , 0 , 12 , 18 , 36 , 9 , 30 , 9 , 24 , 9 , 60 , 12 , 30 , 12 , 12 , 0 , 42 , 9 , 42 , 18 , 45 , 24 , 42 , 6 , 12 , 9 , 24 , 6 , 30 , 12 , 42 , 0 , 30 , 6 , 15 , 15 , 30 , 12 , 18 , 12 , 54 , 6 , 21 , 30 , 12 , 33 , 60 , 0 , 48 , 0 , 30 , 15 , 42 , 6 , 24 , 24 , 30 , 0 , 36 , 18 , 33 , 18 , 12 , 0 , 60 , 0 , 72 , 15 , 12 , 9 , 30 , 12 , 24 , 15 , 21 , 24 , 51 , 12 , 24 , 0 , 24 , 6 , 12 , 6 , 33 , 24 , 36 , 9 , 54 , 6 , 27 , 24 , 30 , 6 , 48 , 0 , 24 , 3 , 36 , 27 , 42 , 15 , 18 , 18 , 12 , 6 , 54 , 6 , 30 , 15 , 36 , 0 , 12 , 12 , 18 , 24 , 21 , 18 , 30 , 3 , 60 , 0 , 33 , 12 , 36 , 18 , 48 , 0 , 24 , 1 , 39 , 12 , 24 , 18 , 24 , 9 , 66 , 6 , 48 , 24 , 12 , 12 , 42 , 0 , 24 , 6 , 18 , 12 , 63 , 6 , 36 , 24 , 18 , 0 , 39 , 12 , 39 , 24 , 24 , 0 , 54 , 6 , 15 , 24 , 15 , 24 , 48 , 3 , 36 , 12 , 12 , 24 , 39 , 18 , 36 , 0 , 42 , 6 , 42 , 6 , 60 , 24 , 12 , 18 , 18 , 0 , 45 , 6 , 6 , 6 , 72 , 0 , 30 , 6 , 24 , 9 , 36 , 12 , 24 , 9 , 30 , 15 , 36 , 18 , 33 , 24 , 6 , 0 , 54 , 0 , 33 , 36 , 18 , 24 , 36 , 6 , 18 , 6 , 24 , 18 , 75 , 6 , 18 , 0 , 18 , 0 , 48 , 9 , 36 , 18 , 42 , 9 , 30 , 0 , 27 , 36 , 24 , 15 , 42 , 0 , 42 , 18 , 36 , 12 , 18 , 12 , 72 , 9 , 24 , 0 , 54 , 18 , 21 , 24 , 12 , 0 , 60 , 0 , 24 , 24 , 39 , 12 , 42 , 18 , 30 , 6 , 9 , 12 , 48 , 12 , 30 , 0 , 18 , 12 , 36 , 15 , 48 , 18 , 18 , 3 , 42 , 6 , 42 , 18 , 18 , 24 , 54 , 0 , 36 , 0 , 24 , 36 , 42 , 0 , 12 , 27 , 30 , 6 , 60 , 6 , 30 , 24 , 12 , 0 , 36 , 3 , 42 , 12 , 18 , 12 , 36 , 9 , 30 , 0 , 15 , 18 , 33 , 12 , 54 , 0 , 30 , 6 , 33 , 21 , 27 , 30 , 42 , 12 , 54 , 9 , 42 , 24 , 27 , 6 , 36 , 0 , 24 , 12 , 24 , 12 , 45 , 24 , 12 , 6 , 30 , 12 , 69 , 12 , 42 , 12 , 30 , 0 , 24 , 0 , 42 , 18 , 24 , 15 , 60 , 9 , 48 , 18 , 18 , 24 , 27 , 12 , 36 , 0 , 30 , 0 , 54 , 9 , 30 , 18 , 24 , 15 , 48 , 0 , 24 , 24 , 45 , 24 , 24 , 0 , 18 , 6 , 36 , 9 , 54 , 15 , 24 , 12 , 12 , 6 , 18 , 12 , 54 , 18 , 12 , 0 , 60 , 3 , 48 , 30 , 12 , 18 , 60 , 6 , 24 , 3 , 36 , 12 , 33 , 12 , 36 , 0 , 36 , 6 , 36 , 3 , 33 , 24 , 12 , 13 , 42 , 12 , 27 , 18 , 30 , 12 , 54 , 0 , 30 , 12 , 21 , 39 , 54 , 6 , 54 , 18 , 18 , 0 , 33 , 12 , 36 , 36 , 36 , 0 , 30 , 0 , 42 , 33 , 18 , 18 , 36 , 12 , 30 , 3 , 30 , 12 , 66 , 6 , 30 , 0 , 18 , 12 , 63 , 18 , 24 , 6 , 30 , 12 , 48 , 9 , 6 , 24 , 30 , 12 , 42 , 0 , 72 , 0 , 30 , 12 , 48 , 3 , 24 , 15 , 12 , 12 , 66 , 18 , 9 , 36 , 12 , 0 , 54 , 0 , 54 , 18 , 15 , 30 , 36 , 6 , 12 , 0 , 21 , 18 , 54 , 12 , 30 , 0 , 6 , 0 , 36 , 15 , 60 , 18 , 18 , 15 , 48 , 6 , 27 , 24 , 21 , 12 , 54 , 0 , 54 , 9 , 12 , 24 , 48 , 12 , 48 , 15 , 54 , 6 , 36 , 6 , 39 , 24 , 24 , 0 , 24 , 3 , 33 , 24 , 18 , 18 , 66 , 12 , 18 , 12 , 30 , 12 , 75 , 15 , 36 , 0 , 30 , 9 , 24 , 6 , 21 , 24 , 24 , 12 , 60 , 0 , 66 , 36 , 12 , 18 , 36 , 0 , 24 , 6 , 30 , 18 , 39 , 18 , 30 , 12 , 24 , 9 , 30 , 6 , 36 , 18 , 18 , 0 , 54 , 12 , 33 , 24 , 36 , 6 , 66 , 0 , 30 , 6 , 12 , 12 , 33 , 24 , 54 , 0 , 18 , 3 , 60 , 3 , 30 , 24 , 24 , 21 , 48 , 0 , 18 , 30 , 51 , 12 , 18 , 0 , 30 , 12 , 33 , 15 , 18 , 12 , 30 , 27 , 24 , 0 , 48 , 12 , 45 , 6 , 30 , 0 , 72 , 0 , 51 , 18 , 27 , 27 , 54 , 9 , 48 , 12 , 27 , 30 , 36 , 18 , 18 , 0 , 42 , 3 , 36 , 9 , 45 , 30 , 6 , 6 , 36 , 3 , 51 , 24 , 24 , 18 , 72 , 0 , 18 , 6 , 9 , 36 , 42 , 0 , 36 , 9 , 30 , 12 , 60 , 30 , 24 , 15 , 24 , 0 , 36 , 6 , 30 , 27 , 27 , 18 , 42 , 12 , 48 , 0 , 42 , 0 , 33 , 24 , 24 , 0 , 30 , 0 , 42 , 12 , 48 , 9 , 36 , 9 , 24 , 6 , 27 , 36 , 12 , 9 , 60 , 0 , 30 , 12 , 15 , 18 , 42 , 18 , 36 , 18 , 24 , 7 , 48 , 12 , 54 , 24 , 30 , 0 , 78 , 0 , 18 , 18 , 27 , 24 , 24 , 6 , 30 , 12 , 33 , 18 , 60 , 15 , 54 , 0 , 12 , 12 , 36 , 12 , 36 , 24 , 30 , 18 , 54 , 0 , 18 , 18 , 18 , 24 , 84 , 0 , 54 , 0 , 27 , 15 , 42 , 6 , 36 , 12 , 18 , 9 , 54 , 6 , 30 , 30 , 24 , 0 , 30 , 9 , 60 , 30 , 36 , 6 , 42 , 12 , 30 , 6 , 6 , 30 , 60 , 0 , 18 , 0 , 24 , 9 , 51 , 18 , 24 , 33 , 30 , 0 , 42 , 12 , 60 , 18 , 18 , 36 , 18 , 0 , 24 , 0 , 18 , 9 , 78 , 12 , 48 , 24 , 12 , 0 , 48 , 6 , 12 , 18 , 42 , 0 , 48 , 0 , 30 , 27 , 18 , 6 , 48 , 3 , 66 , 21 , 18 , 18 , 33 , 12 , 48 , 0 , 30 , 6 , 63 , 21 , 18 , 36 , 24 , 15 , 60 , 6 , 36 , 30 , 36 , 0 , 48 , 0 , 48 , 3 , 36 , 30 , 42 , 18 , 24 , 24 , 12 , 6 , 21 , 6 , 72 , 12 , 36 , 0 , 60 , 6 , 12 , 18 , 15 , 24 , 60 , 9 , 30 , 0 , 39 , 30 , 54 , 12 , 18 , 0 , 18 , 3 , 60 , 9 , 57 , 24 , 6 , 18 , 48 , 6 , 60 , 18 , 18 , 9 , 48 , 0 , 24 , 12 , 18 , 18 , 39 , 6 , 42 , 15 , 36 , 6 , 36 , 18 , 18 , 30 , 18 , 0 , 42 , 6 , 39 , 27 , 27 , 18 , 48 , 12 , 42 , 12 , 24 , 18 , 27 , 9 , 30 , 0 , 24 , 9 , 81 , 12 , 72 , 12 , 30 , 6 , 36 , 0 , 33 , 42 , 39 , 30 , 42 , 0 , 12 , 3 , 12 , 6 , 24 , 18 , 48 , 12 , 48 , 3 , 63 , 24 , 24 , 27 , 30 , 0 , 78 , 6 , 36 , 18 , 36 , 30 , 30 , 12 , 36 , 12 , 30 , 6 , 60 , 12 , 48 , 0 , 24 , 0 , 36 , 21 , 30 , 24 , 30 , 12 , 48 , 0 , 36 , 12 , 24 , 27 , 36 , 0 , 42 , 12 , 27 , 24 , 54 , 6 , 18 , 12 , 48 , 0 , 30 , 6 , 72 , 24 , 12 , 0 , 30 , 3 , 45 , 24 , 0 , 18 , 78 , 15 , 18 , 18 , 39 , 18 , 39 , 9 , 36 , 0 , 24 , 6 , 39 , 12 , 30 , 18 , 30 , 16 , 48 , 0 , 36 , 30 , 12 , 12 , 60 , 0 , 42 , 3 , 24 , 21 , 84 , 33 , 30 , 12 , 18 , 18 , 48 , 12 , 36 , 12 , 30 , 0 , 48 , 9 , 42 , 36 , 42 , 6 , 48 , 3 , 42 , 0 , 33 , 24 , 30 , 12 , 36 , 0 , 36 , 6 , 54 , 12 , 30 , 30 , 6 , 21 , 66 , 0 , 39 , 24 , 36 , 24 , 36 , 0 , 24 , 12 , 30 , 15 , 54 , 12 , 78 , 30 , 6 , 0 , 33 , 12 , 27 , 30 , 30 , 0 , 36 , 6 , 18 , 36 , 36 , 6 , 66 , 3 , 60 , 6 , 18 , 30 , 42 , 0 , 12 , 0 , 36 , 6 , 54 , 6 , 33 , 24 , 24 , 12 , 54 , 0 , 42 , 12 , 15 , 12 , 60 , 0 , 30 , 0 , 21 , 18 , 75 , 18 , 48 , 18 , 18 , 15 , 30 , 24 , 42 , 33 , 36 , 0 , 30 , 6 , 45 , 24 , 9 , 30 , 36 , 3 , 54 , 15 , 24 , 18 , 63 , 18 , 42 , 0 , 24 , 0 , 75 , 6 , 30 , 9 , 30 , 15 , 42 , 12 , 33 , 36 , 21 , 24 , 60 , 0 , 54 , 9 , 30 , 30 , 48 , 12 , 18 , 12 , 24 , 0 , 66 , 12 , 24 , 18 , 36 , 0 , 72 , 6 , 36 , 15 , 27 , 27 , 30 , 6 , 12 , 18 , 24 , 6 , 78 , 15 , 42 , 0 , 12 , 6 , 27 , 24 , 51 , 18 , 36 , 12 , 60 , 3 , 51 , 30 , 12 , 24 , 36 , 0 , 30 , 0 , 48 , 12 , 21 , 6 , 36 , 24 , 54 , 6 , 42 , 6 , 36 , 36 , 6 , 0 , 54 , 12 , 27 , 15 , 18 , 18 , 66 , 6 , 42 , 0 , 15 , 30 , 63 , 12 , 48 , 0 , 36 , 3 , 63 , 12 , 36 , 30 , 18 , 9 , 48 , 3 , 48 , 36 , 30 , 12 , 42 , 0 , 72 , 6 , 36 , 30 , 30 , 12 , 24 , 12 , 6 , 15 , 75 , 18 , 30 , 6 , 36 , 0 , 24 , 0 , 18 , 36 , 48 , 18 , 60 , 18 , 60 , 12 , 33 , 12 , 33 , 15 , 72 , 0 , 18 , 9 , 54 , 15 , 21 , 30 , 36 , 12 , 30 , 0 , 42 , 24 , 48 , 18 , 36 , 0 , 24 , 6 , 18 , 15 , 81 , 12 , 12 , 27 , 36 , 12 , 30 , 6 , 36 , 18 , 24 , 0 , 48 , 6 , 36 , 36 , 27 , 6 , 48 , 9 , 36 , 3 , 36 , 36 , 36 , 24 , 30 , 0 , 24 , 1 , 42 , 6 , 66 , 27 , 24 , 18 , 48 , 12 , 51 , 18 , 24 , 18 , 84 , 0 , 24 , 6 , 12 , 9 , 63 , 18 , 48 , 9 , 30 , 0 , 36 , 12 , 33 , 24 , 30 , 0 , 72 , 0 , 42 , 48 , 36 , 18 , 42 , 12 , 42 , 15 , 24 , 12 , 60 , 15 , 24 , 0 , 12 , 21 , 72 , 3 , 42 , 30 , 24 , 18 , 36 , 6 , 42 , 18 , 30 , 12 , 42 , 0 , 48 , 12 , 12 , 24 , 24 , 18 , 66 , 6 , 24 , 0 , 93 , 12 , 51 , 30 , 12 , 0 , 54 , 6 , 18 , 27 , 24 , 24 , 36 , 12 , 30 , 0 , 45 , 18 , 60 , 6 , 54 , 0 , 24 , 0 , 51 , 24 , 21 , 18 , 30 , 6 , 72 , 6 , 6 , 18 , 21 , 36 , 42 , 0 , 48 , 12 , 27 , 24 , 36 , 6 , 30 , 27 , 30 , 6 , 39 , 18 , 51 , 36 , 30 , 0 , 42 , 0 , 66 , 18 , 36 , 6 , 66 , 9 , 24 , 12 , 24 , 24 , 78 , 12 , 36 , 0 , 36 , 12 , 60 , 15 , 42 , 24 , 6 , 15 , 54 , 0 , 33 , 30 , 21 , 30 , 42 , 0 , 54 , 0 , 24 , 9 , 60 , 9 , 36 , 24 , 24 , 6 , 66 , 12 , 48 , 18 , 54 , 0 , 30 , 0 , 30 , 39 , 30 , 18 , 48 , 6 , 42 , 12 , 33 , 24 , 33 , 12 , 60 , 0 , 18 , 6 , 42 , 24 , 42 , 24 , 6 , 12 , 72 , 6 , 42 , 30 , 18 , 9 , 30 , 0 , 24 , 15 , 30 , 18 , 60 , 12 , 54 , 15 , 24 , 0 , 48 , 24 , 33 , 12 , 36 , 0 , 66 , 6 , 36 , 18 , 21 , 30 , 72 , 3 , 24 , 9 , 27 , 30 , 30 , 18 , 42 , 0 , 42 , 0 , 72 , 6 , 39 , 42 , 24 , 18 , 60 , 3 , 24 , 18 , 36 , 18 , 30 , 0 , 54 , 6 , 27 , 33 , 60 , 12 , 24 , 24 , 18 , 18 , 30 , 12 , 21 , 33 , 48 , 0 , 78 , 12 , 78 , 12 , 30 , 12 , 42 , 12 , 48 , 0 , 24 , 12 , 75 , 18 , 24 , 0 , 18 , 0 , 33 , 24 , 30 , 21 , 42 , 15 , 30 , 12 , 39 , 30 , 51 , 12 , 54 , 0 , 36 , 12 , 18 , 12 , 48 , 24 , 78 , 18 , 18 , 6 , 78 , 6 , 24 , 30 , 12 , 0 , 42 , 0 , 45 , 18 , 15 , 27 , 42 , 0 , 54 , 18 , 36 , 18 , 36 , 6 , 48 , 0 , 30 , 12 , 36 , 21 , 45 , 6 , 24 , 7 , 54 , 0 , 27 , 42 , 33 , 24 , 72 , 0 , 42 , 0 , 48 , 24 , 45 , 18 , 18 , 15 , 36 , 15 , 66 , 6 , 66 , 30 , 18 , 0 , 48 , 0 , 27 , 39 , 30 , 18 , 66 , 27 , 12 , 12 , 18 , 24 , 60 , 6 , 66 , 0 , 42 , 0 , 42 , 6 , 33 , 21 , 36 , 12 , 42 , 6 , 21 , 36 , 33 , 21 , 48 , 0 , 66 , 12 , 6 , 18 , 75 , 24 , 36 , 12 , 18 , 0 , 81 , 12 , 42 , 30 , 36 , 0 , 24 , 0 , 30 , 30 , 30 , 6 , 60 , 9 , 60 , 6 , 24 , 30 , 30 , 6 , 30 , 0 , 30 , 12 , 75 , 18 , 30 , 24 , 24 , 15 , 78 , 0 , 42 , 24 , 18 , 30 , 42 , 0 , 30 , 12 , 21 , 12 , 48 , 9 , 60 , 21 , 30 , 12 , 24 , 24 , 39 , 21 , 24 , 0 , 54 , 3 , 39 , 30 , 33 , 24 , 72 , 12 , 60 , 0 , 18 , 24 , 57 , 12 , 24 , 0 , 24 , 3 , 90 , 9 , 12 , 21 , 36 , 12 , 30 , 18 , 84 , 24 , 30 , 9 , 60 , 0 , 36 , 18 , 18 , 24 , 78 , 18 , 24 , 18 , 48 , 6 , 24 , 0 , 45 , 30 , 24 , 0 , 66 , 3 , 60 , 36 , 21 , 42 , 42 , 6 , 30 , 6 , 33 , 12 , 60 , 21 , 36 , 0 , 6 , 6 , 36 , 15 , 36 , 30 , 48 , 21 , 48 , 0 , 39 , 36 , 36 , 6 , 54 , 0 , 66 , 3 , 18 , 18 , 33 , 24 , 36 , 18 , 30 , 9 , 66 , 6 , 15 , 36 , 24 , 0 , 96 , 6 , 30 , 12 , 42 , 6 , 36 , 6 , 36 , 9 , 27 , 36 , 42 , 12 , 42 , 0 , 18 , 6 , 51 , 12 , 78 , 18 , 30 , 9 , 54 , 12 , 39 , 24 , 24 , 33 , 66 , 0 , 36 , 9 , 45 , 33 , 36 , 12 , 18 , 27 , 36 , 0 , 78 , 12 , 48 , 24 , 30 , 0 , 42 , 9 , 48 , 21 , 18 , 9 , 60 , 12 , 54 , 6 , 21 , 24 , 72 , 3 , 66 , 0 , 18 , 18 , 33 , 12 , 21 , 36 , 36 , 6 , 36 , 6 , 60 , 36 , 36 , 18 , 48 , 0 , 24 , 0 , 30 , 24 , 87 , 24 , 24 , 27 , 42 , 6 , 60 , 18 , 66 , 6 , 18 , 0 , 36 , 6 , 39 , 36 , 30 , 18 , 36 , 9 , 30 , 0 , 18 , 18 , 51 , 12 , 48 , 0 , 54 , 0 , 48 , 18 , 36 , 30 , 36 , 30 , 66 , 3 , 12 , 18 , 15 , 39 , 60 , 0 , 24 , 12 , 66 , 6 , 54 , 12 , 48 , 6 , 18 , 7 , 30 , 24 , 48 , 18 , 30 , 0 , 84 , 0 , 30 , 48 , 12 , 15 , 60 , 9 , 42 , 18 , 42 , 18 , 42 , 18 , 48 , 0 , 30 , 9 , 48 , 21 , 69 , 36 , 12 , 12 , 48 , 0 , 57 , 18 , 24 , 24 , 66 , 0 , 36 , 6 , 24 , 21 , 69 , 6 , 54 , 12 , 30 , 18 , 72 , 18 , 30 , 30 , 18 , 0 , 42 , 0 , 42 , 42 , 12 , 18 , 42 , 6 , 54 , 9 , 42 , 12 , 72 , 18 , 24 , 0 , 24 , 3 , 78 , 0 , 24 , 24 , 30 , 15 , 60 , 6 , 42 , 30 , 39 , 21 , 36 , 0 , 54 , 12 , 27 , 24 , 42 , 24 , 72 , 21 , 30 , 0 , 48 , 18 , 24 , 30 , 12 , 0 , 30 , 3 , 24 , 15 , 72 , 33 , 42 , 6 , 24 , 24 , 12 , 24 , 66 , 12 , 60 , 0 , 24 , 6 , 63 , 12 , 42 , 18 , 24 , 18 , 84 , 6 , 30 , 24 , 24 , 6 , 90 , 0 , 72 , 6 , 21 , 24 , 30 , 18 , 18 , 30 , 24 , 6 , 66 , 18 , 54 , 18 , 36 , 0 , 36 , 12 , 60 , 27 , 30 , 18 , 90 , 18 , 18 , 0 , 18 , 24 , 48 , 24 , 30 , 0 , 36 , 6 , 36 , 18 , 66 , 36 , 30 , 3 , 66 , 3 , 57 , 48 , 12 , 18 , 36 , 0 , 48 , 6 , 36 , 21 , 48 , 0 , 60 , 12 , 36 , 12 , 72 , 0 , 36 , 30 , 30 , 0 , 48 , 0 , 33 , 30 , 48 , 9 , 54 , 9 , 36 , 24 , 18 , 30 , 42 , 18 , 54 , 0 , 12 , 0 , 54 , 12 , 21 , 24 , 30 , 21 , 72 , 0 , 66 , 24 , 27 , 18 , 36 , 0 , 24 , 0 , 45 , 24 , 78 , 0 , 42 , 21 , 24 , 12 , 39 , 30 , 54 , 30 , 24 , 0 , 84 , 15 , 24 , 24 , 9 , 30 , 54 , 9 , 48 , 6 , 33 , 18 , 57 , 18 , 30 , 0 , 60 , 3 , 54 , 27 , 33 , 30 , 36 , 24 , 42 , 0 , 54 , 18 , 39 , 24 , 54 , 0 , 60 , 18 , 24 , 15 , 75 , 12 , 24 , 12 , 42 , 0 , 39 , 12 , 36 , 36 , 36 , 0 , 30 , 3 , 66 , 42 , 15 , 24 , 72 , 12 , 48 , 12 , 42 , 12 , 48 , 15 , 24 , 0 , 18 , 18 , 60 , 6 , 60 , 18 , 36 , 9 , 24 , 6 , 27 , 36 , 30 , 24 , 90 , 0 , 60 , 3 , 21 , 18 , 54 , 24 , 48 , 18 , 18 , 12 , 51 , 24 , 39 , 18 , 18 , 0 , 72 , 12 , 42 , 21 , 36 , 24 , 36 , 6 , 36 , 0 , 33 , 18 , 42 , 0 , 60 , 0 , 18 , 6 , 42 , 21 , 39 , 39 , 36 , 13 , 84 , 6 , 24 , 18 , 30 , 24 , 78 , 0 , 36 , 3 , 54 , 39 , 51 , 18 , 30 , 21 , 24 , 3 , 60 , 12 , 87 , 42 , 30 , 0 , 36 , 6 , 30 , 15 , 36 , 12 , 54 , 18 , 42 , 12 , 27 , 24 , 84 , 15 , 42 , 0 , 18 , 9 , 54 , 18 , 30 , 30 , 48 , 12 , 72 , 0 , 54 , 42 , 9 , 12 , 36 , 0 , 60 , 0 , 27 , 21 , 78 , 18 , 42 , 30 , 30 , 6 , 54 , 6 , 30 , 18 , 24 , 0 , 60 , 12 , 42 , 36 , 48 , 24 , 54 , 6 , 36 , 15 , 12 , 48 , 21 , 12 , 30 , 0 , 36 , 0 , 102 , 6 , 18 , 12 , 24 , 9 , 60 , 12 , 48 , 24 , 33 , 30 , 66 , 0 , 30 , 12 , 30 , 15 , 60 , 12 , 54 , 36 , 30 , 0 , 36 , 6 , 72 , 18 , 36 , 0 , 54 , 0 , 30 , 36 , 9 , 15 , 60 , 0 , 60 , 15 , 39 , 12 , 63 , 18 , 42 , 0 , 30 , 18 , 60 , 21 , 57 , 30 , 0 , 18 , 54 , 3 , 75 , 30 , 48 , 24 , 42 , 0 , 24 , 12 , 36 , 42 , 57 , 9 , 48 , 9 , 36 , 6 , 45 , 12 , 24 , 48 , 54 , 0 , 66 , 0 , 45 , 33 , 30 , 18 , 54 , 18 , 36 , 0 , 36 , 6 , 54 , 30 , 54 , 0 , 36 , 0 , 66 , 12 , 42 , 21 , 24 , 18 , 48 , 6 , 21 , 48 , 42 , 12 , 60 , 0 , 84 , 12 , 0 , 12 , 54 , 24 , 36 , 18 , 18 , 12 , 81 , 18 , 33 , 18 , 12 , 0 , 66 , 3 , 66 , 6 , 33 , 48 , 48 , 6 , 24 , 24 , 36 , 18 , 60 , 6 , 36 , 0 , 24 , 6 , 39 , 21 , 42 , 18 , 42 , 12 , 60 , 0 , 24 , 30 , 33 , 36 , 72 , 0 , 30 , 0 , 36 , 36 , 42 , 12 , 36 , 15 , 24 , 15 , 75 , 30 , 63 , 27 , 24 , 0 , 42 , 6 , 63 , 30 , 18 , 12 , 108 , 9 , 48 , 12 , 24 , 12 , 72 , 18 , 30 , 0 , 54 , 6 , 30 , 9 , 63 , 27 , 48 , 15 , 36 , 6 , 48 , 36 , 18 , 12 , 54 , 0 , 42 , 9 , 36 , 36 , 63 , 18 , 36 , 24 , 36 , 0 , 75 , 6 , 63 , 24 , 36 , 0 , 48 , 6 , 27 , 39 , 30 , 18 , 30 , 9 , 54 , 18 , 36 , 18 , 39 , 21 , 66 , 0 , 30 , 0 , 54 , 18 , 42 , 36 , 12 , 24 , 108 , 0 , 30 , 24 , 42 , 12 , 48 , 0 , 24 , 0 , 15 , 9 , 48 , 18 , 66 , 24 , 24 , 12 , 54 , 12 , 36 , 21 , 54 , 0 , 54 , 18 , 45 , 42 , 36 , 24 , 42 , 3 , 36 , 0 , 42 , 48 , 42 , 12 , 36 , 0 , 36 , 1 , 60 , 18 , 36 , 18 , 36 , 15 , 54 , 9 , 60 , 30 , 24 , 21 , 48 , 0 , 24 , 18 , 24 , 18 , 90 , 6 , 72 , 15 , 36 , 9 , 48 , 6 , 36 , 42 , 48 , 0 , 78 , 3 , 54 , 27 , 18 , 36 , 48 , 15 , 54 , 12 , 30 , 24 , 84 , 12 , 18 , 0 , 18 , 12 , 105 , 12 , 24 , 30 , 30 , 18 , 36 , 0 , 60 , 30 , 27 , 12 , 48 , 0 , 90 , 6 , 18 , 18 , 33 , 21 , 42 , 24 , 24 , 12 , 45 , 24 , 60 , 36 , 36 , 0 , 66 , 6 , 27 , 15 , 42 , 24 , 60 , 12 , 18 , 9 , 30 , 18 , 84 , 12 , 72 , 0 , 12 , 6 , 42 , 21 , 45 , 12 , 18 , 9 , 96 , 12 , 21 , 30 , 30 , 24 , 66 , 0 , 48 , 12 , 42 , 18 , 36 , 18 , 24 , 24 , 24 , 0 , 30 , 12 , 27 , 42 , 18 , 0 , 72 , 0 , 84 , 27 , 54 , 15 , 102 , 12 , 36 , 6 , 39 , 36 , 36 , 15 , 36 , 0 , 30 , 15 , 57 , 12 , 57 , 42 , 30 , 9 , 60 , 6 , 27 , 42 , 27 , 30 , 36 , 0 , 54 , 6 , 24 , 21 , 78 , 12 , 42 , 18 , 18 , 12 , 84 , 18 , 54 , 18 , 48 , 0 , 66 , 12 , 15 , 36 , 30 , 18 , 72 , 9 , 66 , 0 , 27 , 18 , 24 , 6 , 78 , 0 , 42 , 6 , 81 , 27 , 27 , 36 , 24 , 24 , 48 , 0 , 72 , 18 , 39 , 30 , 42 , 0 , 18 , 18 , 30 , 24 , 78 , 6 , 18 , 18 , 36 , 0 , 48 , 30 , 84 , 6 , 18 , 0 , 54 , 0 , 42 , 36 , 12 , 30 , 90 , 12 , 48 , 18 , 24 , 18 , 21 , 18 , 48 , 0 , 60 , 0 , 60 , 6 , 30 , 42 , 24 , 18 , 66 , 0 , 27 , 36 , 24 , 18 , 54 , 0 , 48 , 6 , 30 , 18 , 90 , 15 , 42 , 9 , 48 , 18 , 42 , 6 , 45 , 24 , 36 , 0 , 48 , 0 , 78 , 39 , 27 , 12 , 42 , 27 , 48 , 6 , 45 , 18 , 72 , 36 , 48 , 0 , 18 , 9 , 66 , 9 , 54 , 33 , 18 , 18 , 66 , 12 , 39 , 36 , 45 , 12 , 72 , 0 , 48 , 12 , 21 , 39 , 33 , 18 , 60 , 18 , 36 , 0 , 78 , 18 , 39 , 36 , 24 , 0 , 30 , 0 , 30 , 30 , 54 , 21 , 66 , 6 , 30 , 21 , 39 , 18 , 60 , 15 , 72 , 0 , 30 , 18 , 45 , 12 , 39 , 18 , 60 , 6 , 66 , 15 , 36 , 30 , 12 , 18 , 60 , 0 , 60 , 0 , 18 , 33 , 57 , 18 , 24 , 24 , 42 , 6 , 66 , 12 , 81 , 42 , 18 , 0 , 36 , 6 , 42 , 18 , 24 , 24 , 72 , 0 , 18 , 0 , 30 , 30 , 87 , 18 , 36 , 0 , 42 , 3 , 45 , 12 , 36 , 42 , 24 , 25 , 30 , 6 , 72 , 24 , 18 , 18 , 60 , 0 , 102 , 12 , 42 , 12 , 90 , 12 , 24 , 27 , 24 , 12 , 69 , 24 , 30 , 18 , 42 , 0 , 48 , 0 , 42 , 45 , 39 , 15 , 60 , 18 , 30 , 12 , 33 , 24 , 72 , 18 , 36 , 0 , 24 , 12 , 51 , 24 , 39 , 36 , 24 , 6 , 120 , 0 , 72 , 24 , 30 , 30 , 30 , 0 , 24 , 12 , 72 , 18 , 54 , 3 , 84 , 30 , 30 , 21 , 42 , 24 , 30 , 18 , 30 , 0 , 54 , 0 , 36 , 30 , 24 , 30 , 72 , 9 , 72 , 6 , 30 , 24 , 36 , 24 , 30 , 0 , 30 , 0 , 90 , 12 , 48 , 27 , 24 , 6 , 54 , 12 , 39 , 36 , 18 , 18 , 78 , 0 , 36 , 12 , 18 , 39 , 66 , 6 , 54 , 18 , 36 , 0 , 54 , 18 , 42 , 12 , 30 , 0 , 78 , 0 , 48 , 45 , 27 , 36 , 36 , 9 , 54 , 15 , 6 , 12 , 99 , 15 , 48 , 0 , 24 , 3 , 60 , 12 , 45 , 36 , 36 , 30 , 24 , 12 , 57 , 30 , 42 , 18 , 54 , 0 , 36 , 6 , 45 , 24 , 63 , 30 , 60 , 12 , 42 , 6 , 102 , 18 , 30 , 33 , 18 , 0 , 84 , 12 , 54 , 24 , 39 , 12 , 42 , 0 , 36 , 0 , 54 , 24 , 60 , 12 , 42 , 0 , 48 , 6 , 30 , 9 , 93 , 24 , 18 , 21 , 60 , 6 , 21 , 36 , 18 , 54 , 102 , 0 , 30 , 18 , 36 , 21 , 48 , 12 , 30 , 27 , 42 , 3 , 54 , 12 , 66 , 36 , 36 , 0 , 48 , 9 , 45 , 33 , 30 , 9 , 84 , 18 , 30 , 12 , 33 , 36 , 51 , 12 , 54 , 0 , 36 , 18 , 42 , 12 , 30 , 36 , 24 , 9 , 72 , 0 , 48 , 30 , 36 , 6 , 78 , 0 , 42 , 0 , 18 , 24 , 63 , 21 , 36 , 18 , 24 , 15 , 66 , 0 , 42 , 27 , 54 , 0 , 30 , 9 , 51 , 45 , 45 , 24 , 48 , 12 , 72 , 12 , 33 , 24 , 39 , 30 , 66 , 0 , 18 , 6 , 69 , 12 , 36 , 24 , 36 , 18 , 90 , 6 , 60 , 24 , 36 , 27 , 36 , 0 , 60 , 18 , 33 , 21 , 84 , 12 , 36 , 30 , 18 , 0 , 33 , 24 , 51 , 30 , 24 , 0 , 84 , 0 , 57 , 33 , 36 , 21 , 84 , 12 , 30 , 12 , 33 , 36 , 63 , 18 , 24 , 0 , 30 , 6 , 90 , 21 , 66 , 30 , 30 , 24 , 36 , 0 , 54 , 12 , 51 , 18 , 78 , 0 , 36 , 0 , 18 , 18 , 54 , 21 , 48 , 12 , 66 , 18 , 21 , 18 , 33 , 21 , 42 , 0 , 66 , 6 , 48 , 54 , 21 , 30 , 66 , 12 , 66 , 0 , 24 , 24 , 63 , 24 , 36 , 0 , 42 , 3 , 60 , 18 , 30 , 6 , 36 , 9 , 54 , 6 , 72 , 48 , 36 , 15 , 54 , 0 , 30 , 27 , 12 , 18 , 60 , 12 , 66 , 15 , 48 , 10 , 84 , 12 , 39 , 42 , 12 , 0 , 66 , 6 , 24 , 18 , 21 , 36 , 54 , 24 , 24 , 12 , 51 , 18 , 66 , 12 , 90 , 0 , 18 , 6 , 87 , 15 , 75 , 24 , 30 , 15 , 60 , 0 , 24 , 42 , 24 , 24 , 48 , 0 , 84 , 6 , 51 , 39 , 60 , 12 , 18 , 30 , 36 , 12 , 60 , 12 , 60 , 48 , 36 , 0 , 54 , 6 , 42 , 12 , 6 , 18 , 78 , 6 , 48 , 12 , 12 , 36 , 84 , 0 , 48 , 0 , 54 , 3 , 48 , 18 , 45 , 51 , 54 , 6 , 72 , 6 , 51 , 30 , 45 , 30 , 48 , 0 , 36 , 6 , 36 , 15 , 78 , 24 , 42 , 24 , 24 , 0 , 90 , 18 , 36 , 24 , 24 , 0 , 36 , 0 , 36 , 30 , 30 , 30 , 66 , 6 , 78 , 21 , 30 , 12 , 21 , 15 , 60 , 0 , 36 , 12 , 66 , 21 , 36 , 24 , 30 , 18 , 60 , 9 , 54 , 48 , 24 , 18 , 48 , 0 , 30 , 6 , 42 , 18 , 81 , 18 , 54 , 27 , 24 , 12 , 30 , 18 , 84 , 30 , 24 , 0 , 102 , 9 , 42 , 42 , 36 , 24 , 90 , 3 , 30 , 0 , 60 , 30 , 42 , 18 , 24 , 0 , 18 , 0 , 78 , 12 , 42 , 27 , 42 , 18 , 66 , 18 , 45 , 18 , 42 , 9 , 84 , 0 , 54 , 6 , 15 , 54 , 63 , 18 , 54 , 24 , 24 , 9 , 57 , 24 , 45 , 54 , 36 , 0 , 60 , 0 , 66 , 27 , 33 , 18 , 30 , 9 , 60 , 24 , 30 , 12 , 54 , 21 , 24 , 0 , 12 , 18 , 108 , 15 , 66 , 12 , 30 , 27 , 66 , 0 , 36 , 30 , 36 , 24 , 66 , 0 , 60 , 0 , 9 , 24 , 54 , 12 , 90 , 15 , 42 , 0 , 51 , 30 , 18 , 30 , 48 , 0 , 84 , 9 , 48 , 21 , 54 , 30 , 24 , 18 , 36 , 12 , 45 , 18 , 96 , 6 , 30 , 0 , 30 , 9 , 30 , 24 , 42 , 24 , 24 , 15 , 66 , 6 , 69 , 36 , 15 , 15 , 84 , 0 , 36 , 15 , 48 , 27 , 45 , 18 , 42 , 30 , 36 , 0 , 66 , 6 , 72 , 30 , 48 , 0 , 42 , 3 , 51 , 39 , 30 , 33 , 78 , 12 , 24 , 18 , 30 , 18 , 105 , 21 , 72 , 0 , 42 , 12 , 39 , 18 , 27 , 42 , 24 , 6 , 66 , 3 , 60 , 42 , 30 , 30 , 60 , 0 , 54 , 6 , 54 , 24 , 57 , 6 , 54 , 6 , 24 , 24 , 54 , 12 , 57 , 27 , 42 , 0 , 48 , 6 , 36 , 27 , 57 , 12 , 84 , 12 , 60 , 0 , 12 , 30 , 54 , 24 , 48 , 0 , 18 , 3 , 105 , 36 , 48 , 42 , 24 , 18 , 48 , 6 , 30 , 36 , 45 , 42 , 42 , 0 , 54 , 9 , 36 , 12 , 48 , 12 , 54 , 30 , 30 , 6 , 48 , 6 , 51 , 18 , 36 , 0 , 102 , 6 , 18 , 30 , 33 , 24 , 48 , 18 , 60 , 12 , 60 , 30 , 45 , 12 , 36 , 0 , 54 , 12 , 60 , 6 , 48 , 54 , 12 , 13 , 60 , 0 , 72 , 18 , 24 , 6 , 90 , 0 , 48 , 12 , 15 , 42 , 96 , 18 , 36 , 18 , 36 , 6 , 78 , 24 , 48 , 18 , 30 , 0 , 48 , 18 , 78 , 42 , 24 , 30 , 60 , 6 , 60 , 12 , 18 , 12 , 42 , 30 , 42 , 0 , 24 , 0 , 81 , 9 , 54 , 18 , 60 , 33 , 48 , 0 , 27 , 54 , 51 , 27 , 90 , 0 , 60 , 18 , 24 , 18 , 54 , 24 , 36 , 12 , 42 , 0 , 87 , 24 , 33 , 18 , 24 , 0 , 96 , 0 , 87 , 36 , 30 , 15 , 42 , 12 , 36 , 24 , 24 , 36 , 42 , 21 , 48 , 0 , 30 , 6 , 42 , 18 , 48 , 24 , 24 , 18 , 84 , 3 , 36 , 42 , 42 , 36 , 72 , 0 , 54 , 6 , 30 , 15 , 60 , 6 , 78 , 30 , 24 , 6 , 72 , 6 , 66 , 45 , 24 , 0 , 42 , 21 , 36 , 30 , 36 , 18 , 48 , 12 , 30 , 0 , 39 , 24 , 102 , 18 , 36 , 0 , 12 , 6 , 54 , 6 , 30 , 33 , 66 , 21 , 90 , 3 , 78 , 36 , 9 , 18 , 36 , 0 , 84 , 0 , 30 , 30 , 93 , 24 , 30 , 24 , 30 , 15 , 63 , 12 , 48 , 30 , 54 , 0 , 48 , 0 , 54 , 42 , 42 , 30 , 78 , 0 , 36 , 24 , 39 , 24 , 60 , 12 , 78 , 0 , 60 , 6 , 51 , 30 , 36 , 36 , 30 , 18 , 60 , 0 , 30 , 30 , 51 , 24 , 60 , 0 , 42 , 3 , 24 , 9 , 54 , 21 , 24 , 33 , 30 , 24 , 66 , 24 , 69 , 18 , 30 , 0 , 102 , 15 , 54 , 24 , 15 , 30 , 120 , 6 , 30 , 3 , 51 , 24 , 54 , 12 , 30 , 0 , 36 , 6 , 36 , 12 , 90 , 42 , 12 , 12 , 60 , 12 , 60 , 24 , 42 , 12 , 90 , 0 , 24 , 12 , 42 , 30 , 30 , 6 , 78 , 21 , 42 , 0 , 54 , 24 , 27 , 54 , 24 , 0 , 66 , 6 , 45 , 30 , 12 , 30 , 42 , 12 , 84 , 15 , 36 , 18 , 84 , 24 , 36 , 0 , 30 , 18 , 72 , 18 , 60 , 24 , 48 , 12 , 54 , 6 , 36 , 54 , 42 , 12 , 42 , 0 , 60 , 0 , 51 , 48 , 54 , 9 , 36 , 27 , 24 , 6 , 84 , 18 , 48 , 30 , 42 , 0 , 78 , 0 , 48 , 27 , 27 , 48 , 42 , 18 , 36 , 0 , 39 , 18 , 99 , 24 , 102 , 0 , 18 , 0 , 48 , 18 , 72 , 15 , 36 , 12 , 84 , 12 , 24 , 12 , 30 , 39 , 84 , 0 , 36 , 12 , 39 , 39 , 63 , 24 , 42 , 24 , 66 , 6 , 72 , 18 , 18 , 24 , 30 , 0 , 60 , 6 , 48 , 42 , 36 , 15 , 78 , 6 , 48 , 30 , 12 , 36 , 54 , 12 , 36 , 0 , 42 , 6 , 45 , 6 , 69 , 24 , 72 , 21 , 48 , 0 , 57 , 48 , 12 , 24 , 48 , 0 , 48 , 3 , 48 , 15 , 78 , 24 , 60 , 18 , 12 , 12 , 111 , 24 , 54 , 24 , 24 , 0 , 48 , 6 , 36 , 33 , 42 , 6 , 54 , 9 , 72 , 18 , 27 , 30 , 30 , 12 , 54 , 0 , 66 , 4 , 78 , 21 , 24 , 54 , 18 , 24 , 54 , 6 , 60 , 24 , 54 , 21 , 78 , 0 , 36 , 18 , 54 , 30 , 66 , 18 , 48 , 30 , 24 , 0 , 42 , 12 , 99 , 36 , 30 , 0 , 90 , 6 , 18 , 30 , 30 , 24 , 78 , 6 , 66 , 9 , 24 , 42 , 78 , 30 , 42 , 0 , 18 , 12 , 102 , 6 , 33 , 24 , 18 , 12 , 66 , 9 , 54 , 24 , 24 , 36 , 84 , 0 , 60 , 6 , 39 , 15 , 78 , 12 , 42 , 21 , 42 , 18 , 42 , 18 , 18 , 42 , 24 , 0 , 48 , 3 , 105 , 51 , 42 , 30 , 42 , 18 , 72 , 0 , 24 , 24 , 102 , 6 , 36 , 0 , 36 , 9 , 99 , 12 , 48 , 21 , 48 , 18 , 42 , 6 , 36 , 42 , 18 , 12 , 78 , 0 , 48 , 30 , 30 , 18 , 36 , 30 , 42 , 9 , 42 , 6 , 60 , 12 , 39 , 30 , 24 , 0 , 78 , 0 , 48 , 30 , 39 , 27 , 102 , 24 , 30 , 12 , 51 , 12 , 66 , 9 , 48 , 0 , 30 , 18 , 45 , 39 , 87 , 30 , 36 , 9 , 72 , 0 , 60 , 24 , 30 , 36 , 54 , 0 , 48 , 0 , 45 , 36 , 45 , 18 , 42 , 27 , 60 , 9 , 66 , 12 , 78 , 42 , 18 , 0 , 60 , 6 , 60 , 33 , 36 , 24 , 96 , 12 , 18 , 12 , 12 , 36 , 72 , 0 , 78 , 0 , 36 , 6 , 60 , 24 , 27 , 51 , 42 , 24 , 84 , 12 , 57 , 48 , 30 , 24 , 42 , 0 , 60 , 12 , 24 , 18 , 96 , 12 , 30 , 30 , 30 , 0 , 93 , 18 , 48 , 18 , 60 , 0 , 48 , 6 , 54 , 36 , 30 , 12 , 42 , 9 , 60 , 18 , 12 , 24 , 69 , 6 , 60 , 0 , 54 , 6 , 33 , 15 , 60 , 36 , 30 , 18 , 90 , 3 , 72 , 24 , 54 , 54 , 42 , 0 , 18 , 9 , 60 , 30 , 84 , 18 , 48 , 24 , 12 , 6 , 66 , 36 , 24 , 27 , 24 , 0 , 42 , 12 , 39 , 42 , 27 , 18 , 108 , 9 , 78 , 0 , 48 , 12 , 54 , 30 , 30 , 0 , 36 , 0 , 48 , 12 , 75 , 39 , 30 , 6 , 42 , 9 , 66 , 30 , 33 , 18 , 96 , 0 , 48 , 18 , 39 , 36 , 102 , 12 , 54 , 18 , 24 , 9 , 45 , 24 , 72 , 30 , 36 , 0 , 78 , 6 , 63 , 36 , 36 , 21 , 60 , 9 , 36 , 12 , 54 , 24 , 78 , 27 , 42 , 0 , 42 , 18 , 60 , 9 , 24 , 24 , 54 , 39 , 84 , 0 , 27 , 36 , 39 , 12 , 84 , 0 , 66 , 0 , 21 , 30 , 30 , 42 , 66 , 18 , 18 , 18 , 78 , 12 , 48 , 42 , 36 , 0 , 90 , 6 , 48 , 33 , 39 , 24 , 48 , 15 , 54 , 15 , 54 , 24 , 48 , 18 , 60 , 0 , 24 , 0 , 48 , 24 , 78 , 24 , 36 , 9 , 90 , 12 , 42 , 24 , 30 , 45 , 54 , 0 , 66 , 12 , 24 , 12 , 60 , 6 , 48 , 33 , 48 , 0 , 60 , 6 , 51 , 54 , 12 , 0 , 30 , 0 , 69 , 21 , 42 , 15 , 72 , 15 , 48 , 21 , 33 , 36 , 96 , 6 , 30 , 0 , 54 , 6 , 87 , 30 , 42 , 30 , 36 , 13 , 42 , 6 , 84 , 48 , 18 , 18 , 72 , 0 , 54 , 12 , 30 , 30 , 75 , 24 , 36 , 24 , 42 , 18 , 78 , 12 , 36 , 30 , 72 , 0 , 48 , 6 , 33 , 36 , 57 , 36 , 66 , 6 , 54 , 0 , 27 , 36 , 66 , 12 , 90 , 0 , 24 , 3 , 96 , 24 , 27 , 24 , 18 , 24 , 108 , 12 , 42 , 48 , 24 , 18 , 30 , 0 , 54 , 18 , 48 , 12 , 75 , 18 , 90 , 21 , 36 , 12 , 72 , 12 , 45 , 24 , 24 , 0 , 114 , 0 , 27 , 30 , 39 , 33 , 48 , 12 , 54 , 12 , 18 , 42 , 45 , 27 , 48 , 0 , 48 , 6 , 90 , 9 , 60 , 42 , 36 , 12 , 48 , 0 , 36 , 42 , 42 , 18 , 78 , 0 , 30 , 6 , 24 , 33 , 78 , 9 , 84 , 30 , 18 , 15 , 63 , 18 , 51 , 30 , 48 , 0 , 72 , 6 , 36 , 51 , 24 , 30 , 48 , 21 , 96 , 6 , 24 , 6 , 93 , 12 , 48 , 0 , 18 , 6 , 69 , 18 , 36 , 18 , 24 , 18 , 24 , 6 , 54 , 36 , 51 , 33 , 96 , 0 , 36 , 15 , 27 , 30 , 54 , 30 , 42 , 12 , 36 , 0 , 117 , 36 , 54 , 36 , 24 , 0 , 96 , 3 , 72 , 36 , 57 , 27 , 54 , 6 , 54 , 21 , 36 , 12 , 66 , 33 , 60 , 0 , 30 , 24 , 24 , 15 , 63 , 30 , 42 , 24 , 78 , 9 , 39 , 30 , 24 , 24 , 138 , 0 , 42 , 0 , 54 , 24 , 57 , 12 , 30 , 24 , 42 , 18 , 54 , 6 , 60 , 33 , 24 , 0 , 72 , 6 , 84 , 24 , 42 , 6 , 66 , 15 , 36 , 0 , 42 , 48 , 51 , 18 , 66 , 0 , 60 , 3 , 60 , 12 , 60 , 57 , 42 , 9 , 72 , 12 , 60 , 42 , 27 , 24 , 60 , 0 , 42 , 18 , 24 , 30 , 48 , 30 , 36 , 18 , 30 , 9 , 78 , 12 , 51 , 18 , 30 , 0 , 60 , 0 , 12 , 57 , 51 , 18 , 78 , 6 , 102 , 12 , 30 , 24 , 48 , 27 , 36 , 0 , 30 , 12 , 126 , 6 , 27 , 36 , 30 , 18 , 66 , 0 , 60 , 30 , 48 , 36 , 48 , 0 , 24 , 6 , 39 , 24 , 96 , 12 , 90 , 33 , 36 , 6 , 39 , 6 , 90 , 27 , 36 , 0 , 60 , 12 , 45 , 42 , 30 , 30 , 72 , 12 , 36 , 9 , 39 , 36 , 69 , 24 , 48 , 0 , 36 , 6 , 66 , 15 , 72 , 39 , 36 , 27 , 54 , 18 , 57 , 30 , 42 , 12 , 60 , 0 , 84 , 24 , 36 , 27 , 72 , 12 , 48 , 21 , 60 , 0 , 51 , 30 , 27 , 30 , 90 , 0 , 78 , 0 , 42 , 57 , 12 , 30 , 48 , 18 , 42 , 6 , 48 , 24 , 90 , 15 , 42 , 0 , 12 , 15 , 84 , 24 , 72 , 18 , 48 , 21 , 66 , 3 , 54 , 42 , 30 , 24 , 48 , 0 , 36 , 18 , 27 , 12 , 42 , 9 , 108 , 18 , 36 , 12 , 96 , 24 , 21 , 30 , 24 , 0 , 96 , 9 , 54 , 18 , 75 , 30 , 54 , 18 , 36 , 0 , 39 , 18 , 84 , 18 , 42 , 0 , 24 , 6 , 54 , 18 , 57 , 42 , 24 , 9 , 84 , 18 , 48 , 42 , 27 , 30 , 78 , 0 , 60 , 0 , 30 , 48 , 36 , 6 , 30 , 36 , 6 , 10 , 78 , 12 , 51 , 48 , 48 , 0 , 90 , 0 , 75 , 9 , 42 , 24 , 48 , 15 , 72 , 12 , 33 , 42 , 108 , 12 , 54 , 0 , 54 , 18 , 51 , 42 , 36 , 48 , 48 , 12 , 72 , 0 , 42 , 18 , 45 , 30 , 66 , 0 , 78 , 3 , 36 , 15 , 78 , 30 , 30 , 30 , 30 , 15 , 102 , 12 , 54 , 18 , 30 , 0 , 36 , 6 , 81 , 48 , 12 , 24 , 108 , 6 , 78 , 18 , 24 , 36 , 33 , 18 , 30 , 0 , 30 , 0 , 108 , 21 , 54 , 42 , 18 , 18 , 90 , 6 , 30 , 48 , 69 , 36 , 48 , 0 , 24 , 15 , 24 , 15 , 84 , 24 , 114 , 6 , 30 , 0 , 48 , 6 , 60 , 42 , 24 , 0 , 102 , 12 , 42 , 42 , 27 , 21 , 78 , 9 , 42 , 24 , 51 , 24 , 42 , 12 , 48 , 0 , 60 , 12 , 66 , 6 , 42 , 24 , 30 , 24 , 42 , 0 , 78 , 24 , 54 , 12 , 66 , 0 , 30 , 6 , 24 , 51 , 99 , 18 , 60 , 24 , 42 , 18 , 54 , 6 , 45 , 60 , 36 , 0 , 54 , 6 , 39 , 39 , 39 , 30 , 66 , 18 , 72 , 0 , 51 , 24 , 102 , 12 , 54 , 0 , 24 , 0 , 102 , 12 , 48 , 24 , 42 , 36 , 60 , 0 , 12 , 48 , 18 , 12 , 54 , 0 , 84 , 18 , 39 , 9 , 84 , 30 , 66 , 18 , 48 , 15 , 72 , 48 , 39 , 42 , 48 , 0 , 60 , 0 , 84 , 30 , 45 , 33 , 54 , 6 , 54 , 30 , 33 , 30 , 90 , 6 , 54 , 0 , 24 , 6 , 72 , 27 , 78 , 12 , 24 , 15 , 66 , 0 , 54 , 36 , 21 , 42 , 114 , 0 , 60 , 3 , 30 , 33 , 54 , 27 , 30 , 33 , 60 , 6 , 54 , 12 , 48 , 33 , 36 , 0 , 42 , 12 , 45 , 39 , 24 , 36 , 96 , 18 , 24 , 12 , 33 , 18 , 99 , 18 , 66 , 0 , 36 , 0 , 51 , 24 , 30 , 30 , 36 , 15 , 84 , 6 , 102 , 48 , 48 , 18 , 60 , 0 , 72 , 12 , 36 , 42 , 60 , 12 , 24 , 21 , 30 , 0 , 54 , 18 , 60 , 18 , 42 , 0 , 66 , 6 , 24 , 24 , 54 , 15 , 78 , 12 , 42 , 27 , 27 , 30 , 51 , 27 , 78 , 0 , 48 , 6 , 120 , 27 , 48 , 42 , 24 , 12 , 54 , 6 , 54 , 24 , 48 , 36 , 66 , 0 , 78 , 9 , 57 , 21 , 48 , 18 , 54 , 33 , 24 , 30 , 84 , 18 , 45 , 33 , 30 , 0 , 126 , 9 , 36 , 30 , 27 , 30 , 66 , 18 , 54 , 0 , 36 , 42 , 48 , 6 , 42 , 0 , 54 , 6 , 57 , 12 , 84 , 54 , 48 , 6 , 60 , 6 , 63 , 18 , 42 , 36 , 78 , 0 , 24 , 24 , 33 , 24 , 105 , 24 , 66 , 27 , 48 , 0 , 48 , 30 , 60 , 30 , 54 , 0 , 42 , 3 , 75 , 48 , 24 , 12 , 66 , 12 , 96 , 6 , 30 , 12 , 87 , 21 , 36 , 0 , 30 , 24 , 69 , 12 , 57 , 30 , 48 , 24 , 54 , 0 , 42 , 54 , 24 , 24 , 72 , 0 , 60 , 0 , 48 , 24 , 69 , 24 , 42 , 18 , 36 , 12 , 66 , 24 , 36 , 42 , 18 , 0 , 78 , 9 , 48 , 36 , 42 , 42 , 36 , 12 , 36 , 21 , 78 , 18 , 48 , 12 , 102 , 0 , 18 , 12 , 54 , 24 , 45 , 27 , 42 , 13 , 108 , 12 , 39 , 24 , 42 , 27 , 102 , 0 , 60 , 6 , 39 , 24 , 54 , 12 , 54 , 24 , 24 , 0 , 114 , 24 , 63 , 48 , 30 , 0 , 48 , 6 , 69 , 36 , 18 , 12 , 72 , 6 , 48 , 18 , 33 , 54 , 117 , 12 , 42 , 0 , 66 , 12 , 48 , 6 , 54 , 36 , 42 , 21 , 102 , 6 , 48 , 54 , 33 , 30 , 48 , 0 , 72 , 0 , 30 , 24 , 75 , 24 , 84 , 30 , 30 , 0 , 72 , 18 , 30 , 42 , 54 , 0 , 60 , 12 , 36 , 45 , 42 , 12 , 96 , 6 , 66 , 0 , 12 , 36 , 78 , 36 , 42 , 0 , 36 , 0 , 78 , 24 , 48 , 24 , 18 , 30 , 90 , 15 , 96 , 18 , 27 , 21 , 54 , 0 , 24 , 21 , 48 , 27 , 84 , 18 , 48 , 42 , 36 , 6 , 66 , 12 , 108 , 12 , 42 , 0 , 48 , 9 , 27 , 60 , 21 , 36 , 84 , 6 , 36 , 18 , 42 , 18 , 54 , 18 , 60 , 0 , 60 , 15 , 72 , 9 , 99 , 42 , 12 , 12 , 60 , 0 , 57 , 42 , 18 , 18 , 78 , 0 , 42 , 6 , 36 , 36 , 63 , 9 , 42 , 15 , 30 , 18 , 78 , 6 , 24 , 48 , 42 , 0 , 102 , 12 , 75 , 45 , 42 , 30 , 84 , 24 , 66 , 9 , 24 , 30 , 90 , 24 , 42 , 0 , 24 , 3 , 84 , 21 , 84 , 33 , 66 , 24 , 36 , 6 , 36 , 48 , 51 , 18 , 72 , 0 , 66 , 18 , 54 , 30 , 24 , 18 , 48 , 18 , 30 , 0 , 102 , 12 , 45 , 36 , 24 , 0 , 102 , 3 , 42 , 15 , 42 , 54 , 54 , 21 , 66 , 24 , 66 , 30 , 102 , 3 , 66 , 0 , 48 , 12 , 24 , 30 , 45 , 36 , 54 , 6 , 78 , 9 , 48 , 24 , 39 , 36 , 96 , 0 , 66 , 6 , 27 , 27 , 60 , 30 , 18 , 30 , 48 , 12 , 90 , 24 , 60 , 36 , 6 , 0 , 42 , 12 , 78 , 36 , 36 , 24 , 114 , 6 , 60 , 0 , 18 , 6 , 69 , 18 , 84 , 0 , 36 , 6 , 48 , 6 , 39 , 24 , 42 , 24 , 54 , 6 , 72 , 48 , 36 , 42 , 60 , 0 , 48 , 0 , 36 , 18 , 138 , 24 , 30 , 30 , 42 , 18 , 75 , 18 , 48 , 18 , 24 , 0 , 78 , 0 , 78 , 57 , 60 , 9 , 48 , 9 , 36 , 30 , 30 , 42 , 42 , 39 , 84 , 0 , 24 , 12 , 87 , 27 , 30 , 42 , 24 , 24 , 90 , 0 , 36 , 24 , 60 , 36 , 84 , 0 , 42 , 0 , 30 , 21 , 87 , 12 , 72 , 24 , 42 , 12 , 60 , 30 , 72 , 21 , 60 , 0 , 96 , 12 , 30 , 42 , 39 , 18 , 66 , 12 , 84 , 12 , 63 , 42 , 42 , 24 , 42 , 0 , 18 , 6 , 78 , 15 , 75 , 45 , 54 , 12 , 54 , 6 , 84 , 30 , 30 , 18 , 54 , 0 , 42 , 24 , 39 , 27 , 96 , 18 , 42 , 21 , 48 , 0 , 54 , 18 , 33 , 36 , 66 , 0 , 84 , 0 , 75 , 48 , 30 , 42 , 54 , 12 , 54 , 15 , 42 , 30 , 96 , 18 , 42 , 0 , 18 , 6 , 123 , 15 , 48 , 24 , 48 , 39 , 42 , 6 , 21 , 54 , 45 , 12 , 60 , 0 , 90 , 12 , 30 , 36 , 45 , 18 , 72 , 21 , 78 , 12 , 30 , 12 , 60 , 30 , 18 , 0 , 78 , 6 , 60 , 36 , 33 , 18 , 60 , 12 , 30 , 0 , 60 , 18 , 90 , 30 , 54 , 0 , 36 , 1 , 78 , 27 , 84 , 30 , 18 , 15 , 102 , 9 , 27 , 30 , 24 , 57 , 90 , 0 , 42 , 9 , 48 , 42 , 42 , 12 , 72 , 27 , 48 , 9 , 108 , 18 , 48 , 48 , 18 , 0 , 84 , 6 , 66 , 24 , 48 , 21 , 114 , 6 , 78 , 24 , 30 , 30 , 42 , 18 , 60 , 0 , 18 , 12 , 63 , 9 , 51 , 66 , 48 , 15 , 54 , 0 , 66 , 60 , 36 , 18 , 48 , 0 , 66 , 6 , 36 , 30 , 96 , 9 , 36 , 30 , 30 , 24 , 93 , 24 , 72 , 24 , 66 , 0 , 60 , 24 , 48 , 30 , 24 , 30 , 72 , 6 , 60 , 12 , 30 , 12 , 93 , 18 , 72 , 0 , 30 , 0 , 81 , 30 , 36 , 48 , 36 , 30 , 90 , 6 , 54 , 24 , 57 , 24 , 36 , 0 , 54 , 18 , 36 , 24 , 78 , 18 , 72 , 33 , 12 , 0 , 51 , 30 , 48 , 24 , 42 , 0 , 90 , 3 , 78 , 30 , 30 , 27 , 138 , 6 , 30 , 18 , 36 , 24 , 75 , 24 , 12 , 0 , 54 , 12 , 42 , 18 , 84 , 36 , 30 , 18 , 66 , 6 , 45 , 36 , 36 , 48 , 114 , 0 , 24 , 6 , 30 , 21 , 108 , 15 , 48 , 18 , 36 , 18 , 57 , 24 , 63 , 42 , 54 , 0 , 78 , 6 , 81 , 36 , 18 , 24 , 42 , 18 , 120 , 0 , 24 , 24 , 66 , 12 , 54 , 0 , 48 , 12 , 66 , 18 , 42 , 36 , 48 , 18 , 72 , 6 , 48 , 48 , 33 , 6 , 102 , 0 , 54 , 24 , 39 , 54 , 60 , 12 , 90 , 18 , 36 , 3 , 111 , 24 , 51 , 48 , 42 , 0 , 90 , 0 , 45 , 36 , 54 , 48 , 54 , 24 , 18 , 18 , 51 , 18 , 72 , 0 , 54 , 0 , 18 , 12 , 54 , 36 , 57 , 18 , 42 , 18 , 120 , 0 , 63 , 42 , 27 , 36 , 48 , 0 , 54 , 6 , 39 , 30 , 81 , 18 , 72 , 33 , 54 , 9 , 72 , 12 , 54 , 54 , 24 , 0 , 54 , 15 , 75 , 24 , 60 , 12 , 78 , 6 , 30 , 12 , 39 , 54 , 72 , 6 , 54 , 0 , 72 , 6 , 78 , 12 , 54 , 39 , 30 , 15 , 48 , 6 , 57 , 48 , 18 , 24 , 90 , 0 , 90 , 18 , 42 , 24 , 39 , 42 , 24 , 30 , 42 , 0 , 84 , 6 , 66 , 30 , 30 , 0 , 30 , 0 , 27 , 42 , 39 , 33 , 90 , 24 , 84 , 18 , 51 , 36 , 69 , 24 , 54 , 0 , 42 , 18 , 87 , 33 , 51 , 18 , 42 , 9 , 126 , 9 , 84 , 36 , 66 , 18 , 54 , 0 , 36 , 0 , 66 , 12 , 48 , 15 , 54 , 30 , 18 , 18 , 60 , 18 , 96 , 54 , 42 , 0 , 102 , 0 , 27 , 36 , 30 , 36 , 108 , 15 , 54 , 0 , 24 , 36 , 60 , 24 , 66 , 0 , 30 , 0 , 54 , 15 , 75 , 48 , 36 , 18 , 48 , 24 , 36 , 36 , 54 , 15 , 108 , 0 , 84 , 18 ] <NEWLINE> len_well_known_i = len ( well_known_i ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i not in available_set ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if ( i < len_well_known_i ) : <NEWLINE> <INDENT> print ( well_known_i [ i ] ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> <COMMENT> <NL> lim = math . floor ( n / 3 ) <NEWLINE> for x in range ( 1 , lim ) : <NEWLINE> <INDENT> powx = pow ( x , 2 ) <NEWLINE> if ( powx > i ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( x , lim ) : <NEWLINE> <INDENT> powy = pow ( y , 2 ) <NEWLINE> if ( powx + powy > i ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for z in range ( y , lim ) : <NEWLINE> <COMMENT> <NL> <INDENT> o = powx + powy + pow ( z , 2 ) + x * y + y * z + z * x <NEWLINE> if ( o > i ) : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> if ( o == i ) : <NEWLINE> <INDENT> tmp = { x , y , z } <NEWLINE> <COMMENT> <NL> if ( len ( tmp ) == 1 ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if ( len ( tmp ) == 2 ) : <NEWLINE> <INDENT> c += 3 <NEWLINE> <DEDENT> if ( len ( tmp ) == 3 ) : <NEWLINE> <INDENT> c += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> mul = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> mul *= A [ i ] <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
patterns = [ None ] * ( 10 ** 5 + 10 ) <NEWLINE> patterns [ 0 ] = 1 <NEWLINE> patterns [ 1 ] = 1 <NEWLINE> calcurated_until = 1 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> def get_patterns ( n ) : <NEWLINE> <INDENT> global calcurated_until , patterns <NEWLINE> if patterns [ n ] is None : <NEWLINE> <INDENT> for i in range ( calcurated_until + 1 , n + 1 ) : <NEWLINE> <INDENT> patterns [ i ] = ( patterns [ i - 1 ] + patterns [ i - 2 ] ) % MOD <NEWLINE> <DEDENT> calcurated_until = n <NEWLINE> <COMMENT> <NL> <DEDENT> return patterns [ n ] <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - 1 ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> A . append ( N + 1 ) <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> for a1 , a2 in zip ( A [ : - 1 ] , A [ 1 : ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a2 == a1 + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans *= get_patterns ( a2 - a1 - 2 ) <NEWLINE> <COMMENT> <NL> ans %= MOD <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> N , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> edges [ l - 1 ] . append ( ( r - 1 , d ) ) <NEWLINE> edges [ r - 1 ] . append ( ( l - 1 , - d ) ) <NEWLINE> <NL> <DEDENT> visited = { } <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i in visited : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> q = deque ( [ ( i , 0 ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> l , c = q . popleft ( ) <NEWLINE> if l in visited : <NEWLINE> <INDENT> if visited [ l ] != c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> visited [ l ] = c <NEWLINE> <COMMENT> <NL> <NL> for r , nd in edges [ l ] : <NEWLINE> <INDENT> q . append ( ( r , c + nd ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> from typing import Iterable , Tuple , Union <NEWLINE> <NL> class nd ( object ) : <NEWLINE> <INDENT> getter = ( <NEWLINE> <INDENT> lambda a , i : a , <NEWLINE> lambda a , i : a [ i [ 0 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] , <NEWLINE> lambda a , i : a [ i [ 0 ] ] [ i [ 1 ] ] [ i [ 2 ] ] [ i [ 3 ] ] [ i [ 4 ] ] [ i [ 5 ] ] , <NEWLINE> <DEDENT> ) <NEWLINE> initializer = ( <NEWLINE> <INDENT> lambda s , v : [ v ] * s , <NEWLINE> lambda s , v : [ v ] * s [ 0 ] , <NEWLINE> lambda s , v : [ [ v ] * s [ 1 ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> lambda s , v : [ [ [ v ] * s [ 2 ] for _ in range ( s [ 1 ] ) ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> lambda s , v : [ [ [ [ v ] * s [ 3 ] for _ in range ( s [ 2 ] ) ] for _ in range ( s [ 1 ] ) ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> lambda s , v : [ [ [ [ [ v ] * s [ 4 ] for _ in range ( s [ 3 ] ) ] for _ in range ( s [ 2 ] ) ] for _ in range ( s [ 1 ] ) ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> lambda s , v : [ [ [ [ [ [ v ] * s [ 5 ] for _ in range ( s [ 4 ] ) ] for _ in range ( s [ 3 ] ) ] for _ in range ( s [ 2 ] ) ] for _ in range ( s [ 1 ] ) ] for _ in range ( s [ 0 ] ) ] , <NEWLINE> <DEDENT> ) <NEWLINE> shape_getter = ( <NEWLINE> <INDENT> lambda a : len ( a ) , <NEWLINE> lambda a : ( len ( a ) , ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) , len ( a [ 0 ] [ 0 ] ) ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) , len ( a [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] ) ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) , len ( a [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] [ 0 ] ) ) , <NEWLINE> lambda a : ( len ( a ) , len ( a [ 0 ] ) , len ( a [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] [ 0 ] ) , len ( a [ 0 ] [ 0 ] [ 0 ] [ 0 ] [ 0 ] ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> indices_iterator = ( <NEWLINE> <INDENT> lambda s : iter ( range ( s ) ) , <NEWLINE> lambda s : ( ( i , ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j , k ) for k in range ( s [ 2 ] ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j , k , l ) for l in range ( s [ 3 ] ) for k in range ( s [ 2 ] ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j , k , l , m ) for m in range ( s [ 4 ] ) for l in range ( s [ 3 ] ) for k in range ( s [ 2 ] ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> lambda s : ( ( i , j , k , l , m , n ) for n in range ( s [ 5 ] ) for m in range ( s [ 4 ] ) for l in range ( s [ 3 ] ) for k in range ( s [ 2 ] ) for j in range ( s [ 1 ] ) for i in range ( s [ 0 ] ) ) , <NEWLINE> <DEDENT> ) <NEWLINE> iterable_product = ( <NEWLINE> <INDENT> lambda s : iter ( s ) , <NEWLINE> lambda s : ( ( i , ) for i in s [ 0 ] ) , <NEWLINE> lambda s : ( ( i , j ) for j in s [ 1 ] for i in s [ 0 ] ) , <NEWLINE> lambda s : ( ( i , j , k ) for k in s [ 2 ] for j in s [ 1 ] for i in s [ 0 ] ) , <NEWLINE> lambda s : ( ( i , j , k , l ) for l in s [ 3 ] for k in s [ 2 ] for j in s [ 1 ] for i in s [ 0 ] ) , <NEWLINE> lambda s : ( ( i , j , k , l , m ) for m in s [ 4 ] for l in s [ 3 ] for k in s [ 2 ] for j in s [ 1 ] for i in s [ 0 ] ) , <NEWLINE> lambda s : ( ( i , j , k , l , m , n ) for n in s [ 5 ] for m in s [ 4 ] for l in s [ 3 ] for k in s [ 2 ] for j in s [ 1 ] for i in s [ 0 ] ) , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> @ classmethod <NEWLINE> def full ( cls , fill_value , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] ) : <NEWLINE> <INDENT> if isinstance ( shape , int ) : <NEWLINE> <INDENT> return cls . initializer [ 0 ] ( shape , fill_value ) <NEWLINE> <DEDENT> elif not isinstance ( shape , tuple ) : <NEWLINE> <INDENT> shape = tuple ( shape ) <NEWLINE> <DEDENT> return cls . initializer [ len ( shape ) ] ( shape , fill_value ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def fromiter ( cls , iterable : Iterable , ndim = 1 ) : <NEWLINE> <INDENT> if ndim == 1 : <NEWLINE> <INDENT> return list ( iterable ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return list ( map ( cls . fromiter , iterable ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def nones ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] ) : <NEWLINE> <INDENT> return cls . full ( None , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def zeros ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] , type = int ) : <NEWLINE> <INDENT> return cls . full ( type ( 0 ) , shape ) <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def ones ( cls , shape : Union [ int , Tuple [ int ] , Iterable [ int ] ] , type = int ) : <NEWLINE> <INDENT> return cls . full ( type ( 1 ) , shape ) <NEWLINE> <NL> <DEDENT> class _range ( object ) : <NEWLINE> <INDENT> def __getitem__ ( self , shape : Union [ int , slice , Tuple [ Union [ int , slice ] ] ] ) : <NEWLINE> <INDENT> if isinstance ( shape , int ) : <NEWLINE> <INDENT> return iter ( range ( shape ) ) <NEWLINE> <DEDENT> elif isinstance ( shape , slice ) : <NEWLINE> <INDENT> return iter ( range ( shape . stop ) [ shape ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shape = tuple ( range ( s . stop ) [ s ] for s in shape ) <NEWLINE> return nd . iterable_product [ len ( shape ) ] ( shape ) <NEWLINE> <DEDENT> <DEDENT> def __call__ ( self , shape : Union [ int , slice , Tuple [ Union [ int , slice ] ] ] ) : <NEWLINE> <INDENT> return self [ shape ] <NEWLINE> <DEDENT> <DEDENT> range = _range ( ) <NEWLINE> <NL> <NL> <DEDENT> def bytes_to_str ( x : bytes ) : <NEWLINE> <INDENT> return x . decode ( <STRING> ) <NEWLINE> <NL> <DEDENT> def inputs ( func = bytes_to_str , sep = None , maxsplit = - 1 ) : <NEWLINE> <INDENT> return map ( func , sys . stdin . buffer . readline ( ) . split ( sep = sep , maxsplit = maxsplit ) ) <NEWLINE> <NL> <DEDENT> def inputs_1d ( func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd ( inputs ( func , ** kwargs ) ) <NEWLINE> <NL> <DEDENT> def inputs_2d ( nrows : int , func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd . fromiter ( <NEWLINE> <INDENT> ( inputs ( func , ** kwargs ) for _ in range ( nrows ) ) , <NEWLINE> ndim = 2 <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def inputs_2d_T ( nrows : int , func = bytes_to_str , ** kwargs ) : <NEWLINE> <INDENT> return nd . fromiter ( <NEWLINE> <INDENT> zip ( * ( inputs ( func , ** kwargs ) for _ in range ( nrows ) ) ) , <NEWLINE> ndim = 2 <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> from typing import Optional <NEWLINE> <NL> <NL> class BreadthFirstSearch ( object ) : <NEWLINE> <INDENT> def __init__ ( self , shape : Union [ int , Iterable [ int ] ] ) : <NEWLINE> <INDENT> self . shape = ( shape , ) if isinstance ( shape , int ) else tuple ( shape ) <NEWLINE> self . pushed = nd . zeros ( self . shape , type = bool ) <NEWLINE> self . _deque = deque ( ) <NEWLINE> self . _getter_getter = nd . getter [ len ( self . shape ) ] <NEWLINE> self . _setter_getter = nd . getter [ len ( self . shape ) - 1 ] <NEWLINE> <NL> <DEDENT> def push ( self , position : Tuple [ int ] ) : <NEWLINE> <INDENT> if not self . _getter_getter ( self . pushed , position ) : <NEWLINE> <INDENT> self . _setter_getter ( self . pushed , position [ : - 1 ] ) [ position [ - 1 ] ] = True <NEWLINE> self . _deque . append ( position ) <NEWLINE> <NL> <DEDENT> <DEDENT> def peek ( self ) -> Optional [ Tuple [ int ] ] : <NEWLINE> <INDENT> return self . _deque [ 0 ] if self . _deque else None <NEWLINE> <NL> <DEDENT> def pop ( self ) -> Optional [ Tuple [ int ] ] : <NEWLINE> <INDENT> return self . _deque . popleft ( ) if self . _deque else None <NEWLINE> <NL> <DEDENT> def __bool__ ( self ) : <NEWLINE> <INDENT> return bool ( self . _deque ) <NEWLINE> <NL> <DEDENT> <DEDENT> from bisect import bisect_left , bisect_right <NEWLINE> <NL> <NL> N , M = inputs ( int ) <NEWLINE> A , B , C = inputs_2d_T ( N , int ) <NEWLINE> D , E , F = inputs_2d_T ( M , int ) <NEWLINE> xs = sorted ( set ( C ) ) <NEWLINE> ys = sorted ( set ( D ) ) <NEWLINE> <NL> x_guard = nd . zeros ( ( len ( xs ) + 1 , len ( ys ) + 1 ) , type = bool ) <NEWLINE> y_guard = nd . zeros ( ( len ( xs ) + 1 , len ( ys ) + 1 ) , type = bool ) <NEWLINE> <NL> for a , b , c in zip ( A , B , C ) : <NEWLINE> <INDENT> c = bisect_right ( xs , c ) <NEWLINE> a = bisect_left ( ys , a ) + 1 <NEWLINE> b = bisect_right ( ys , b ) <NEWLINE> for y in range ( a , b ) : <NEWLINE> <INDENT> x_guard [ c ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for d , e , f in zip ( D , E , F ) : <NEWLINE> <INDENT> d = bisect_right ( ys , d ) <NEWLINE> e = bisect_left ( xs , e ) + 1 <NEWLINE> f = bisect_right ( xs , f ) <NEWLINE> for x in range ( e , f ) : <NEWLINE> <INDENT> y_guard [ x ] [ d ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> cow = ( <NEWLINE> <INDENT> bisect_right ( xs , 0 ) , <NEWLINE> bisect_right ( ys , 0 ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> bfs = BreadthFirstSearch ( shape = ( len ( xs ) + 1 , len ( ys ) + 1 ) ) <NEWLINE> bfs . push ( cow ) <NEWLINE> <NL> area = 0 <NEWLINE> while bfs : <NEWLINE> <INDENT> xi , yi = bfs . pop ( ) <NEWLINE> <NL> if 0 < xi < len ( xs ) and 0 < yi < len ( ys ) : <NEWLINE> <INDENT> area += ( xs [ xi ] - xs [ xi - 1 ] ) * ( ys [ yi ] - ys [ yi - 1 ] ) <NEWLINE> if not x_guard [ xi ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi - 1 , yi ) ) <NEWLINE> <DEDENT> if not x_guard [ xi + 1 ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi + 1 , yi ) ) <NEWLINE> <DEDENT> if not y_guard [ xi ] [ yi ] : <NEWLINE> <INDENT> bfs . push ( ( xi , yi - 1 ) ) <NEWLINE> <DEDENT> if not y_guard [ xi ] [ yi + 1 ] : <NEWLINE> <INDENT> bfs . push ( ( xi , yi + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> area = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( area ) <NEWLINE> <NL>
<NL> import numpy as np <NEWLINE> def resolve ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def check ( X ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = X // F <NEWLINE> diff = np . maximum ( A - a , 0 ) <NEWLINE> cnt = np . sum ( diff ) <NEWLINE> return cnt <= K <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> F . sort ( ) <NEWLINE> F = F [ : : - 1 ] <NEWLINE> <NL> ok = 10 ** 12 <COMMENT> <NEWLINE> ng = - 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> X = ( ok + ng ) // 2 <NEWLINE> if check ( X ) : <NEWLINE> <INDENT> ok = X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = X <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = a [ 0 ] <NEWLINE> M = a [ 1 ] <NEWLINE> K = a [ 2 ] <NEWLINE> <NL> count = 0 <COMMENT> <NEWLINE> count_time = 0 <COMMENT> <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
S = input ( ) [ : : - 1 ] <NEWLINE> <NL> S_mod = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> S_mod [ 0 ] = int ( S [ 0 ] ) <NEWLINE> <NL> mod_count = [ 0 ] * 2019 <NEWLINE> <NL> d = 10 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> S_mod [ i + 1 ] = ( S_mod [ i ] + int ( S [ i + 1 ] ) * d ) % 2019 <NEWLINE> d = d * 10 % 2019 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( len ( S_mod ) ) : <NEWLINE> <INDENT> mod_count [ S_mod [ i ] ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> count += mod_count [ i ] * ( mod_count [ i ] - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( count ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ 0 ] * h <NEWLINE> W = [ 0 ] * w <NEWLINE> L = [ ( 0 , 0 ) ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ i ] = ( a , b ) <NEWLINE> H [ a - 1 ] += 1 <NEWLINE> W [ b - 1 ] += 1 <NEWLINE> <DEDENT> h_max = max ( H ) <NEWLINE> w_max = max ( W ) <NEWLINE> ans = h_max + w_max <NEWLINE> cnt = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> if H [ l [ 0 ] - 1 ] == h_max and W [ l [ 1 ] - 1 ] == w_max : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if H . count ( h_max ) * W . count ( w_max ) == cnt : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = A [ 0 ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for cnt in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ans * A [ cnt + 1 ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> t = 0 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> t += a [ i ] * s % m <NEWLINE> <DEDENT> print ( t % m ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> dd = set ( list ( range ( 10 ) ) ) - set ( d ) <NEWLINE> <NL> x = str ( n ) <NEWLINE> lst = [ ] <NEWLINE> dd = list ( dd ) <NEWLINE> dd . sort ( ) <NEWLINE> sel = [ ] <NEWLINE> for i in dd : <NEWLINE> <INDENT> if int ( x [ 0 ] ) <= i and len ( sel ) < 3 : sel . append ( i * 10 ** ( len ( x ) - 1 ) ) <NEWLINE> <DEDENT> if len ( sel ) < 2 : <NEWLINE> <INDENT> if len ( dd ) == 1 : <NEWLINE> <INDENT> sel . append ( ( dd [ 0 ] * 10 + dd [ 0 ] ) * 10 ** ( len ( x ) - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dd [ 0 ] != 0 : <NEWLINE> <INDENT> sel . append ( ( dd [ 0 ] * 10 + dd [ 0 ] ) * 10 ** ( len ( x ) - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sel . append ( ( dd [ 1 ] * 10 + dd [ 0 ] ) * 10 ** ( len ( x ) - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in sel : <NEWLINE> <INDENT> for l in combinations_with_replacement ( dd , len ( x ) - 1 ) : <NEWLINE> <INDENT> cnt = j <NEWLINE> for i in range ( len ( x ) - 1 ) : <NEWLINE> <INDENT> cnt += 10 ** ( len ( x ) - i - 2 ) * l [ i ] <NEWLINE> <DEDENT> if cnt >= n : lst . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( lst ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> def f ( a , b ) : <NEWLINE> <INDENT> return max ( len ( str ( a ) ) , len ( str ( b ) ) ) <NEWLINE> <DEDENT> m = 10000 <NEWLINE> for a in range ( 1 , 10 ** 10 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> m = min ( f ( a , n // a ) , m ) <NEWLINE> <DEDENT> if n < a or n // a < a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import sys <NEWLINE> def unzip ( instd ) : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> search = <STRING> <NEWLINE> for idx in instd : <NEWLINE> <INDENT> if 97 <= ord ( idx ) <= 122 : <NEWLINE> <INDENT> if ord ( idx ) + i <= 122 : <NEWLINE> <INDENT> search += chr ( ord ( idx ) + i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> search += chr ( ord ( idx ) + i - 26 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> search += idx <NEWLINE> <DEDENT> <DEDENT> if <STRING> in search or <STRING> in search or <STRING> in search : <NEWLINE> <INDENT> return search <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> print ( unzip ( line . rstrip ( ) ) ) <NEWLINE> <DEDENT>
inputStr = input ( ) <NEWLINE> numList = inputStr . split ( <STRING> ) <NEWLINE> numList = [ int ( x ) for x in numList ] <NEWLINE> numList . sort ( ) <NEWLINE> <NL> outputStr = <STRING> <NEWLINE> count = len ( numList ) <NEWLINE> for z in numList : <NEWLINE> <INDENT> outputStr = outputStr + str ( z ) <NEWLINE> count -= 1 <NEWLINE> if count > 0 : <NEWLINE> <INDENT> outputStr += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( outputStr ) <NEWLINE>
def ge ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> f0 = [ ] <NEWLINE> f1 = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> X , Y = ge ( ) <NEWLINE> f0 . append ( X - Y ) <NEWLINE> f1 . append ( X + Y ) <NEWLINE> <DEDENT> ans = max ( max ( f0 ) - min ( f0 ) , max ( f1 ) - min ( f1 ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> def set_char ( data ) : <NEWLINE> <INDENT> if data [ len ( data ) - 1 ] == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> str_line_1 = <STRING> <NEWLINE> str_line_2 = <STRING> <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( W - 1 ) : <NEWLINE> <INDENT> str_line_1 += set_char ( str_line_1 ) <NEWLINE> str_line_2 += set_char ( str_line_2 ) <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if ( i % 2 ) == 0 : <NEWLINE> <INDENT> print ( str_line_1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str_line_2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> cnt = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> cnt [ A [ i - 1 ] - 1 ] = cnt [ A [ i - 1 ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for c in cnt : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
MOD = 2019 <NEWLINE> <NL> S = list ( int ( s ) for s in input ( ) [ : : - 1 ] ) <NEWLINE> T = [ S [ 0 ] ] <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> T . append ( T [ - 1 ] + S [ i ] * pow ( 10 , i , MOD ) ) <NEWLINE> <DEDENT> cnt = { } <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> cnt [ i ] = 0 <NEWLINE> <DEDENT> for t in T : <NEWLINE> <INDENT> cnt [ t % MOD ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> c = cnt [ i ] <NEWLINE> if c >= 2 : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> ans += cnt [ 0 ] <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> ini = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( inm ( ) ) <NEWLINE> ins = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> debug = lambda * a , ** kw : print ( <STRING> , * a , <STRING> , ** dict ( file = sys . stderr , ** kw ) ) <NEWLINE> <NL> N , K = inm ( ) <NEWLINE> A = inl ( ) <NEWLINE> B = [ ( abs ( a ) , a < 0 ) for a in A ] <NEWLINE> B . sort ( reverse = True ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> fs = [ ] <NEWLINE> negmin = posrep = None <NEWLINE> posmin = negrep = None <NEWLINE> negcnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v , neg = B [ i ] <NEWLINE> if len ( fs ) < K : <NEWLINE> <INDENT> fs . append ( v ) <NEWLINE> if neg : <NEWLINE> <INDENT> negcnt += 1 <NEWLINE> negmin = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> posmin = v <NEWLINE> <DEDENT> <DEDENT> elif neg and negrep is None : <NEWLINE> <INDENT> negrep = v <NEWLINE> <DEDENT> elif not neg and posrep is None : <NEWLINE> <INDENT> posrep = v <NEWLINE> <DEDENT> <DEDENT> if negcnt % 2 == 0 : <NEWLINE> <INDENT> a0 = 1 <NEWLINE> for x in fs : <NEWLINE> <INDENT> a0 = ( a0 * x ) % MOD <NEWLINE> <DEDENT> return a0 <NEWLINE> <NL> <DEDENT> a1 = a2 = None <NEWLINE> if negmin is not None and posrep is not None : <NEWLINE> <INDENT> a1 = 1 <NEWLINE> replaced = False <NEWLINE> for x in fs : <NEWLINE> <INDENT> if x == negmin and not replaced : <NEWLINE> <INDENT> a1 = ( a1 * posrep ) % MOD <NEWLINE> replaced = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a1 = ( a1 * x ) % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if posmin is not None and negrep is not None : <NEWLINE> <INDENT> a2 = 1 <NEWLINE> replaced = False <NEWLINE> for x in fs : <NEWLINE> <INDENT> if x == posmin and not replaced : <NEWLINE> <INDENT> a2 = ( a2 * negrep ) % MOD <NEWLINE> replaced = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a2 = ( a2 * x ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if a1 is None and a2 is None : <NEWLINE> <INDENT> a3 = 1 <NEWLINE> sign = 1 <NEWLINE> for x , neg in B [ N - K : ] : <NEWLINE> <INDENT> a3 = ( a3 * x ) % MOD <NEWLINE> if neg : <NEWLINE> <INDENT> sign *= - 1 <NEWLINE> <DEDENT> <DEDENT> return ( MOD + sign * a3 ) % MOD <NEWLINE> <NL> <DEDENT> if a1 is None : <NEWLINE> <INDENT> return a2 <NEWLINE> <DEDENT> if a2 is None : <NEWLINE> <INDENT> return a1 <NEWLINE> <NL> <DEDENT> if posrep * posmin < negrep * negmin : <NEWLINE> <INDENT> return a2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( solve ( ) ) <NEWLINE>
from math import sqrt <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> p = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> c = Counter ( A ) <NEWLINE> <NL> for a in c . keys ( ) : <NEWLINE> <INDENT> tmp = a * 2 <NEWLINE> while tmp <= 10 ** 6 : <NEWLINE> <INDENT> p [ tmp ] = 1 <NEWLINE> tmp += a <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if p [ a ] == 0 and c [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> cnt = [ 0 ] * N <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p - 1 ] += x <NEWLINE> <DEDENT> q = deque ( [ [ 0 , - 1 , cnt [ 0 ] ] ] ) <NEWLINE> d = [ - 1 ] * N <NEWLINE> while q : <NEWLINE> <INDENT> cur , fr , p = q . popleft ( ) <NEWLINE> d [ cur ] = p <NEWLINE> for nex in graph [ cur ] : <NEWLINE> <INDENT> if nex == fr : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( [ nex , cur , p + cnt [ nex ] ] ) <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( d [ i ] ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> func ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 10 ) <NEWLINE> def memo ( v ) : <NEWLINE> <INDENT> if dp [ v ] != - 1 : return dp [ v ] <NEWLINE> ans = 0 <NEWLINE> for next_v in g [ v ] : <NEWLINE> <INDENT> ans = max ( ans , memo ( next_v ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = ans <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for v in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , memo ( v ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in range ( len ( li ) - 1 ) : <NEWLINE> <INDENT> if li [ i ] > li [ i + 1 ] : <NEWLINE> <INDENT> sum += li [ i ] - li [ i + 1 ] <NEWLINE> li [ i + 1 ] = li [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> c = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] + a [ i ] <= k : <NEWLINE> <INDENT> c . append ( c [ i ] + a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if d [ i ] + b [ i ] <= k : <NEWLINE> <INDENT> d . append ( d [ i ] + b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> e = 0 <NEWLINE> f = len ( d ) - 1 <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> for j in range ( f , - 1 , - 1 ) : <NEWLINE> <INDENT> if c [ i ] + d [ j ] <= k : <NEWLINE> <INDENT> if i + j > e : <NEWLINE> <INDENT> e = i + j <NEWLINE> <DEDENT> f = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( e ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 4 <NEWLINE> a [ 0 ] = s // 1000 <NEWLINE> s = s - a [ 0 ] * 1000 <NEWLINE> a [ 1 ] = s // 100 <NEWLINE> s = s - a [ 1 ] * 100 <NEWLINE> a [ 2 ] = s // 10 <NEWLINE> s = s - a [ 2 ] * 10 <NEWLINE> a [ 3 ] = s <NEWLINE> if ( a [ 0 ] == a [ 1 ] or a [ 1 ] == a [ 2 ] or a [ 2 ] == a [ 3 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from bisect import bisect_right , insort_right <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] [ : : - 1 ] <NEWLINE> res = [ A [ 0 ] ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> idx = bisect_right ( res , a ) <NEWLINE> if idx == len ( res ) : <NEWLINE> <INDENT> res . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if res [ idx ] == a : <NEWLINE> <INDENT> insort_right ( res , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res [ idx ] = a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( res ) ) <NEWLINE> <NL>
<NL> roomNum , aisleNum = map ( int , input ( ) . split ( ) ) <NEWLINE> aisles = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( aisleNum ) ] <NEWLINE> <NL> aisleTree = [ [ ] for _ in range ( roomNum + 1 ) ] <NEWLINE> <NL> for roomA , roomB in aisles : <NEWLINE> <INDENT> aisleTree [ roomA ] . append ( roomB ) <NEWLINE> aisleTree [ roomB ] . append ( roomA ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> que = deque ( ) <NEWLINE> distanceFromRoom1 = [ - 1 ] * ( roomNum + 1 ) <NEWLINE> distanceFromRoom1 [ 0 ] = 0 <NEWLINE> distanceFromRoom1 [ 1 ] = 0 <NEWLINE> for room in aisleTree [ 1 ] : <NEWLINE> <INDENT> que . append ( room ) <NEWLINE> distanceFromRoom1 [ room ] = 1 <NEWLINE> <NL> <DEDENT> while que : <NEWLINE> <INDENT> room = que . popleft ( ) <NEWLINE> dist = distanceFromRoom1 [ room ] <NEWLINE> for nextRoom in aisleTree [ room ] : <NEWLINE> <INDENT> if distanceFromRoom1 [ nextRoom ] == - 1 : <NEWLINE> <INDENT> que . append ( nextRoom ) <NEWLINE> distanceFromRoom1 [ nextRoom ] = room <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if min ( distanceFromRoom1 ) == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for ans in distanceFromRoom1 [ 2 : ] : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nn = lambda : list ( stdin . readline ( ) . split ( ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> s = ns ( ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> d [ 0 ] += 1 <NEWLINE> k = 1 <NEWLINE> n = 0 <NEWLINE> for i in range ( len ( s ) ) [ : : - 1 ] : <NEWLINE> <INDENT> n += int ( s [ i ] ) * k % 2019 <NEWLINE> n %= 2019 <NEWLINE> d [ n ] += 1 <NEWLINE> k = ( k * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for j in d . values ( ) : <NEWLINE> <INDENT> if j > 1 : <NEWLINE> <INDENT> ans += j * ( j - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if 2 * j - i < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 ] , [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 ] , [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 ] , [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 ] ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> A [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for a , b in enumerate ( A ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( i ) for i in f ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a != len ( A ) - 1 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
( n , m , l ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> B = [ ] <NEWLINE> for mc in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> product = [ [ 0 for d in range ( l ) ] for dd in range ( n ) ] <NEWLINE> <NL> for nc in range ( n ) : <NEWLINE> <INDENT> for lc in range ( l ) : <NEWLINE> <INDENT> for mc in range ( m ) : <NEWLINE> <INDENT> product [ nc ] [ lc ] += A [ nc ] [ mc ] * B [ mc ] [ lc ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for r in product : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( d ) for d in r ] ) ) <NEWLINE> <DEDENT>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> x = i * r <NEWLINE> if x > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> y = j * g <NEWLINE> z = n - x - y <NEWLINE> if x + y > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if z >= 0 and z % b == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> ans += d [ A [ i ] + i ] <NEWLINE> d [ i - A [ i ] ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
INF = 10 ** 20 <NEWLINE> <NL> def search ( rest , now , goal , dp , edges ) : <NEWLINE> <INDENT> if now == goal : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if rest == ( ) : <NEWLINE> <INDENT> if now == goal : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return INF <NEWLINE> <NL> <DEDENT> <DEDENT> if ( rest , now ) in dp : <NEWLINE> <INDENT> return dp [ ( rest , now ) ] <NEWLINE> <NL> <DEDENT> ret = INF <NEWLINE> for i , t in enumerate ( rest ) : <NEWLINE> <INDENT> for dist , to in edges [ now ] : <NEWLINE> <INDENT> ret = min ( ret , search ( tuple ( v for j , v in enumerate ( rest ) if i != j ) , to , goal , dp , edges ) + dist / t ) <NEWLINE> <DEDENT> <DEDENT> dp [ ( rest , now ) ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , m , p , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> tlst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges = [ [ ] for _ in range ( m ) ] <NEWLINE> for _ in range ( p ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> edges [ x ] . append ( ( z , y ) ) <NEWLINE> edges [ y ] . append ( ( z , x ) ) <NEWLINE> <DEDENT> tlst . sort ( ) <NEWLINE> rest = tuple ( tlst ) <NEWLINE> dp = { } <NEWLINE> ans = search ( rest , a , b , dp , edges ) <NEWLINE> if ans == INF : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> F = [ 0 ] * len ( S ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> F [ i + 1 ] += F [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for l , r in LR : <NEWLINE> <INDENT> print ( F [ r - 1 ] - F [ l - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> <NL> <NL> <NL> nf = math . factorial ( n ) % p <NEWLINE> mf = math . factorial ( m ) % p <NEWLINE> <NL> if abs ( n - m ) > 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> elif n == m : <NEWLINE> <INDENT> ans = nf * mf * 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = nf * mf <NEWLINE> <NL> <DEDENT> print ( ans % p ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pss = [ i for i in range ( - 1000 , 1000 ) ] <NEWLINE> ps = list ( filter ( lambda i : i not in ps , pss ) ) <NEWLINE> ans = x <NEWLINE> <NL> for i , p in enumerate ( ps ) : <NEWLINE> <INDENT> temp = abs ( x - p ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> mins = temp <NEWLINE> ans = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if mins > temp : <NEWLINE> <INDENT> mins = temp <NEWLINE> ans = p <NEWLINE> <DEDENT> elif mins == temp : <NEWLINE> <INDENT> if ans > p : <NEWLINE> <INDENT> ans = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nums = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> for i in a : nums [ i ] += 1 <NEWLINE> <NL> if len ( nums ) <= 2 : <NEWLINE> <INDENT> print ( sum ( nums ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , max ( a ) ) : <NEWLINE> <INDENT> if ans < nums [ i - 1 ] + nums [ i ] + nums [ i + 1 ] : <NEWLINE> <INDENT> ans = nums [ i - 1 ] + nums [ i ] + nums [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> while a [ i ] % 2 == 0 : <NEWLINE> <INDENT> a [ i ] /= 2 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
S = input ( ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> L = [ 0 ] <NEWLINE> i = 0 <NEWLINE> for x in S : <NEWLINE> <INDENT> tmp = L [ - 1 ] + pow ( 10 , i , 2019 ) * int ( x ) <NEWLINE> L . append ( tmp % 2019 ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> L = sorted ( L [ 1 : : ] ) <NEWLINE> def counter ( array ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> return list ( Counter ( array ) . most_common ( ) ) <NEWLINE> <DEDENT> c = counter ( L ) <NEWLINE> from math import factorial <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> if n == 1 : return 0 <NEWLINE> return n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for x in c : <NEWLINE> <INDENT> if x [ 0 ] == 0 : ans += x [ 1 ] <NEWLINE> ans += comb ( x [ 1 ] , 2 ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n >= 1 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sample = list ( range ( 0 , max ( p ) + 2 ) ) <NEWLINE> reject = list ( set ( p ) ) <NEWLINE> <NL> for i in range ( len ( reject ) ) : <NEWLINE> <INDENT> sample . remove ( reject [ i ] ) <NEWLINE> <NL> <DEDENT> champ = abs ( sample [ 0 ] - x ) <NEWLINE> ans = sample [ 0 ] <NEWLINE> for i in range ( 1 , len ( sample ) ) : <NEWLINE> <INDENT> if abs ( sample [ i ] - x ) < champ : <NEWLINE> <INDENT> champ = abs ( sample [ i ] - x ) <NEWLINE> ans = sample [ i ] <NEWLINE> <DEDENT> elif abs ( sample [ i ] - x ) == champ : <NEWLINE> <INDENT> if ans >= sample [ i ] : <NEWLINE> <INDENT> ans = sample [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import math <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> s = int ( input ( ) ) <NEWLINE> a = s // 3 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 10 ** 9 + 7 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 2 , a + 1 ) : <NEWLINE> <INDENT> cnt += comb ( s - 2 * i - 1 , i - 1 ) <NEWLINE> <DEDENT> print ( cnt % m ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> k_pa , k_pb , k_pc = k , 0 , 0 <NEWLINE> <DEDENT> elif k > a and k - a <= b : <NEWLINE> <INDENT> k_pa , k_pb , k_pc = a , b , 0 <NEWLINE> <DEDENT> elif k > a and k - a > b : <NEWLINE> <INDENT> k_pa , k_pb , k_pc = a , b , k - a - b <NEWLINE> <DEDENT> point = k_pa - ( k - k_pa - k_pb ) <NEWLINE> print ( point ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import copy <NEWLINE> <NL> x = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> y = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> z = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <NL> def turn ( dice , direction ) : <NEWLINE> <INDENT> turned_dice = copy . deepcopy ( dice ) <NEWLINE> <COMMENT> <NL> if direction == <STRING> : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> turned_dice [ x [ i ] ] = dice [ x [ ( i + 1 ) % 4 ] ] <NEWLINE> <DEDENT> <DEDENT> if direction == <STRING> : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> turned_dice [ x [ i ] ] = dice [ x [ ( i - 1 ) % 4 ] ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if direction == <STRING> : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> turned_dice [ y [ i ] ] = dice [ y [ ( i + 1 ) % 4 ] ] <NEWLINE> <DEDENT> <DEDENT> if direction == <STRING> : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> turned_dice [ y [ i ] ] = dice [ y [ ( i - 1 ) % 4 ] ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if direction == <STRING> : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> turned_dice [ z [ i ] ] = dice [ z [ ( i + 1 ) % 4 ] ] <NEWLINE> <DEDENT> <DEDENT> if direction == <STRING> : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> turned_dice [ z [ i ] ] = dice [ z [ ( i - 1 ) % 4 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> return turned_dice <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice = { <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <NEWLINE> <INDENT> <STRING> : 4 , <STRING> : 5 , <STRING> : 6 } <NEWLINE> <NL> <DEDENT> ret = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dice = turn ( dice , input ( ) ) <NEWLINE> ret += dice [ <STRING> ] <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> lim = 10 ** 18 <NEWLINE> if not ( 0 in A ) : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > lim : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > lim : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<NL> <NL> <NL> nk = input ( ) . split ( ) <NEWLINE> <NL> n = int ( nk [ 0 ] ) <NEWLINE> k = int ( nk [ 1 ] ) <NEWLINE> <NL> weight = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> def ok ( m ) : <NEWLINE> <INDENT> load = 0 <NEWLINE> track = 1 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> load += weight [ i ] <NEWLINE> if load == m : <NEWLINE> <INDENT> load = 0 <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> track += 1 <NEWLINE> <DEDENT> <DEDENT> elif load > m : <NEWLINE> <INDENT> if weight [ i ] > m : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> load = weight [ i ] <NEWLINE> track += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if track <= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> low = 0 <NEWLINE> high = sum ( weight ) <NEWLINE> while low + 1 < high : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if ok ( mid ) : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( high ) <NEWLINE>
def binary_search ( S , key ) : <NEWLINE> <INDENT> S_len = len ( S ) <NEWLINE> <NL> if S_len == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> mid = S_len // 2 <NEWLINE> <NL> if S [ mid ] == key : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if S [ mid ] >= key : <NEWLINE> <INDENT> return binary_search ( S [ : mid ] , key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return binary_search ( S [ mid + 1 : ] , key ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> T = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> result = 0 <NEWLINE> <NL> for t in T : <NEWLINE> <INDENT> left , right = 0 , n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> if S [ mid ] == t : <NEWLINE> <INDENT> result += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if S [ mid ] > t : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if l . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> if num > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num *= i <NEWLINE> <DEDENT> <DEDENT> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ 0 for i in range ( N ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> num [ i - 1 ] += 1 <NEWLINE> <DEDENT> for l in num : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> ans = ans + gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> ans = ans + 3 * gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + 6 * gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> num = 0 <NEWLINE> cnt = 0 <NEWLINE> ans = - 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> num = num * 10 + 7 <NEWLINE> cnt += 1 <NEWLINE> if num % K != 0 : <NEWLINE> <INDENT> num = num % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = cnt <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> nums [ 0 ] = 1 <NEWLINE> if 1 not in a : nums [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i not in a : nums [ i ] = nums [ i - 1 ] + nums [ i - 2 ] <NEWLINE> <DEDENT> print ( nums [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> price . append ( 0 ) <NEWLINE> stock = 0 <NEWLINE> money = 1000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if price [ i ] <= price [ i + 1 ] : <NEWLINE> <INDENT> times = math . floor ( money / price [ i ] ) <NEWLINE> money -= price [ i ] * times <NEWLINE> stock += times <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> money += price [ i ] * stock <NEWLINE> stock = 0 <NEWLINE> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ <STRING> for _ in range ( N ) ] <NEWLINE> s = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> s = s ^ A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> result [ i ] = str ( s ^ A [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
import math <NEWLINE> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> K = int ( input ( ) ) <NEWLINE> gcd_dic = { } <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> gcd_dic [ ( i , j ) ] = math . gcd ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ij_gcd = gcd_dic [ ( min ( i , j ) , max ( i , j ) ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ij_gcd == 1 : <NEWLINE> <INDENT> ans += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += gcd_dic [ ( min ( ij_gcd , k ) , max ( ij_gcd , k ) ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> tmp = np . arange ( N ) <NEWLINE> X = A - tmp <NEWLINE> Y = A + tmp <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> XX = Counter ( list ( X ) ) <NEWLINE> YY = Counter ( list ( Y ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for number , c in XX . items ( ) : <NEWLINE> <INDENT> count += YY [ - number ] * c <NEWLINE> <COMMENT> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> def mapt ( fn , * args ) : <NEWLINE> <INDENT> return tuple ( map ( fn , * args ) ) <NEWLINE> <NL> <NL> <DEDENT> def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> a = sorted ( [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( k ) ] ) <NEWLINE> d = Counter ( a ) <NEWLINE> return int ( sum ( val * ( val - 1 ) / 2 for val in d . values ( ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> N , K , * XY = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> XY = np . array ( XY , dtype = np . int64 ) . reshape ( ( N , 2 ) ) . T <NEWLINE> X = np . sort ( XY [ 0 ] ) <NEWLINE> Y = np . sort ( XY [ 1 ] ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( XY , X , Y ) : <NEWLINE> <INDENT> v = 4 * 10 ** 18 + 1 <NEWLINE> ans = np . array ( [ 0 , 0 , 0 , 0 ] , dtype = np . int64 ) <NEWLINE> for i1 in range ( N - 1 ) : <NEWLINE> <INDENT> x1 = X [ i1 ] <NEWLINE> for i2 in range ( i1 + 1 , N ) : <NEWLINE> <INDENT> x2 = X [ i2 ] <NEWLINE> for j1 in range ( N - 1 ) : <NEWLINE> <INDENT> y1 = Y [ j1 ] <NEWLINE> for j2 in range ( j1 + 1 , N ) : <NEWLINE> <INDENT> y2 = Y [ j2 ] <NEWLINE> if np . sum ( ( x1 <= XY [ 0 ] ) * ( XY [ 0 ] <= x2 ) * ( y1 <= XY [ 1 ] ) * ( XY [ 1 ] <= y2 ) ) < K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v2 = ( x2 - x1 ) * ( y2 - y1 ) <NEWLINE> v = min ( v , v2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return v <NEWLINE> <NL> <DEDENT> ans = solve ( XY , X , Y ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import jit , void , i8 <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L_INF = int ( 1e17 ) <NEWLINE> dp = np . full ( ( R + 1 , C + 1 , 4 ) , - L_INF , dtype = np . int64 ) <NEWLINE> cell = np . full ( ( R + 1 , C + 1 ) , 0 , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cell [ x - 1 ] [ y - 1 ] = c <NEWLINE> <NL> <DEDENT> f ( dp , cell , R , C ) <NEWLINE> <NL> print ( dp [ R ] [ C ] [ 3 ] ) <NEWLINE> <NL> <DEDENT> @ jit ( void ( i8 [ : , : , : ] , i8 [ : , : ] , i8 , i8 ) ) <NEWLINE> def f ( dp , cell , R , C ) : <NEWLINE> <INDENT> dp [ 0 ] [ 1 ] [ 0 ] = dp [ 1 ] [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> if k > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j ] [ k - 1 ] ) <NEWLINE> <DEDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j - 1 ] [ k ] ) <NEWLINE> if k > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j - 1 ] [ k - 1 ] + cell [ i - 1 ] [ j - 1 ] ) <NEWLINE> <DEDENT> if k == 1 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ 1 ] , dp [ i - 1 ] [ j ] [ 3 ] + cell [ i - 1 ] [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cli = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cli [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> x = int ( args [ 0 ] ) <NEWLINE> <NL> ret = None <NEWLINE> for b in range ( 120 ) : <NEWLINE> <INDENT> for a in range ( b , 120 ) : <NEWLINE> <INDENT> a5 , b5 = pow ( a , 5 ) , pow ( b , 5 ) <NEWLINE> if a5 - b5 == x : <NEWLINE> <INDENT> ret = ( a , b ) <NEWLINE> <DEDENT> elif a5 + b5 == x : <NEWLINE> <INDENT> ret = ( a , - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return <STRING> . join ( map ( str , ret ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> <NL> new = <STRING> <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] != <STRING> : <NEWLINE> <INDENT> new += t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if new == <STRING> : <NEWLINE> <INDENT> new += t [ i ] <NEWLINE> <DEDENT> elif new [ - 1 ] == <STRING> : <NEWLINE> <INDENT> new += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new += t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t = new <NEWLINE> new = <STRING> <NEWLINE> <NL> for i in reversed ( range ( len ( t ) ) ) : <NEWLINE> <INDENT> if t [ i ] != <STRING> : <NEWLINE> <INDENT> new = t [ i ] + new <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if new == <STRING> : <NEWLINE> <INDENT> new = t [ i ] + new <NEWLINE> <DEDENT> elif new [ 0 ] == <STRING> : <NEWLINE> <INDENT> new = <STRING> + new <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new = t [ i ] + new <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t = new <NEWLINE> new = <STRING> <NEWLINE> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] != <STRING> : <NEWLINE> <INDENT> new += t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new += <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( new ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> one = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a & ( 1 << i ) : <NEWLINE> <INDENT> one += 1 <NEWLINE> <DEDENT> <DEDENT> ans = ( ans + one * ( N - one ) * ( 1 << i ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy <NEWLINE> from numpy . core . defchararray import count <NEWLINE> S = numpy . array ( [ 0 if s == <STRING> else 1 for s in input ( ) ] ) <NEWLINE> <NL> count = 0 <NEWLINE> bcount = 0 <NEWLINE> <NL> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> bcount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += bcount <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> M = A [ - 1 ] <NEWLINE> b = [ True ] * ( M + 1 ) <NEWLINE> <NL> count = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if not b [ a ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( a , M + 1 , a ) : <NEWLINE> <INDENT> b [ j ] = False <NEWLINE> <DEDENT> if i < N - 1 and A [ i + 1 ] == a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = sys . stdin . readlines ( ) <NEWLINE> s = <STRING> <NEWLINE> for i in l : <NEWLINE> <INDENT> x , y , z = sorted ( map ( lambda x : x * x , map ( int , i . split ( ) ) ) ) <NEWLINE> if x + y == z : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s , end = <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> TD = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> TD . sort ( key = lambda z : - z [ 1 ] ) <NEWLINE> TD_new = [ [ ] for _ in range ( n ) ] <NEWLINE> for t , d in TD : <NEWLINE> <INDENT> TD_new [ t - 1 ] . append ( [ d , 0 ] if len ( TD_new [ t - 1 ] ) else [ d , 1 ] ) <NEWLINE> <NL> <DEDENT> ALL = [ ] <NEWLINE> for td in TD_new : <NEWLINE> <INDENT> ALL . extend ( td ) <NEWLINE> <DEDENT> ALL . sort ( reverse = True ) <NEWLINE> que = deque ( ALL ) <NEWLINE> <NL> x = y = 0 <NEWLINE> zero = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d , ex = que . popleft ( ) <NEWLINE> x += d <NEWLINE> y += ex <NEWLINE> if ex == 0 : <NEWLINE> <INDENT> heappush ( zero , d ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = x + y ** 2 <NEWLINE> while que : <NEWLINE> <INDENT> d , ex = que . popleft ( ) <NEWLINE> if ex : <NEWLINE> <INDENT> if zero : <NEWLINE> <INDENT> x += d - heappop ( zero ) <NEWLINE> y += 1 <NEWLINE> res = max ( res , x + y ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if p [ N - 1 ] == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> from copy import copy <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> graph [ u ] . append ( v ) <NEWLINE> graph [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> dp = [ float ( <STRING> ) ] * n <NEWLINE> dp [ 0 ] = a [ 0 ] <NEWLINE> <NL> <NL> def dfs ( v , v_p , dp_len ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ v ] = dp_len <NEWLINE> for v_next in graph [ v ] : <NEWLINE> <INDENT> if v_next == v_p : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if a [ v_next ] > dp [ dp_len - 1 ] : <NEWLINE> <INDENT> past = dp [ dp_len ] <NEWLINE> dp [ dp_len ] = a [ v_next ] <NEWLINE> dfs ( v_next , v , dp_len + 1 ) <NEWLINE> dp [ dp_len ] = past <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = bisect_left ( dp , a [ v_next ] ) <NEWLINE> <COMMENT> <NL> past = dp [ idx ] <NEWLINE> dp [ idx ] = a [ v_next ] <NEWLINE> dfs ( v_next , v , dp_len ) <NEWLINE> dp [ idx ] = past <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 1 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> yes = dict ( ) <NEWLINE> for i in range ( 3 , 1000 ) : <NEWLINE> <INDENT> if ( i * ( i - 1 ) ) % 2 == 0 : <NEWLINE> <INDENT> yes [ ( i * ( i - 1 ) ) // 2 ] = [ i , i - 1 ] <NEWLINE> <DEDENT> <DEDENT> tmp = max ( yes ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( 2 ) <NEWLINE> print ( 1 , 1 ) <NEWLINE> print ( 1 , 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> if n not in yes . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> xl , xs = yes [ n ] <NEWLINE> <NL> ans = [ [ ] for _ in range ( xl ) ] <NEWLINE> cnt = 1 <NEWLINE> idx = 0 <NEWLINE> while xs >= 0 : <NEWLINE> <INDENT> tmp = cnt <NEWLINE> for i in range ( idx , min ( xl , idx + 3 ) ) : <NEWLINE> <INDENT> for j in range ( xs ) : <NEWLINE> <INDENT> if cnt == tmp + 3 * ( xs - 1 ) : <NEWLINE> <INDENT> ans [ i ] . append ( tmp ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] . append ( cnt ) <NEWLINE> <NL> <DEDENT> if j != 0 and j != xs - 1 : <NEWLINE> <INDENT> ans [ idx + 2 + j ] . append ( cnt ) <NEWLINE> <DEDENT> if j != xs - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> idx += 3 <NEWLINE> xs -= 3 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> for ansi in ans : <NEWLINE> <INDENT> print ( len ( ansi ) , * ansi , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> import copy <NEWLINE> D = [ ] <NEWLINE> flag = 0 <NEWLINE> ans = 0 <NEWLINE> keisan = 0 <NEWLINE> <NL> for p in range ( N ) : <NEWLINE> <INDENT> if C [ p ] == <STRING> : <NEWLINE> <INDENT> D += [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D += [ <STRING> ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def change ( x , y ) : <NEWLINE> <INDENT> global ans <NEWLINE> hoge = copy . deepcopy ( D [ x ] ) <NEWLINE> D [ x ] = D [ y ] <NEWLINE> D [ y ] = hoge <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> def color ( x ) : <NEWLINE> <INDENT> global ans <NEWLINE> ans += 1 <NEWLINE> if D [ x ] == <STRING> : <NEWLINE> <INDENT> D [ x ] = <STRING> <NEWLINE> <DEDENT> elif D [ x ] == <STRING> : <NEWLINE> <INDENT> D [ x ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> zero = D . count ( <STRING> ) <NEWLINE> ichi = D . count ( <STRING> ) <NEWLINE> <NL> for p in range ( zero ) : <NEWLINE> <INDENT> if D [ p ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> list . sort ( a , reverse = True ) <NEWLINE> ones = a . count ( 1 ) <NEWLINE> for i in range ( len ( a ) - ones ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> r = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> print ( r ) <NEWLINE> <NL>
n = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> line = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> <NL> a = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n = int ( line [ i ] ) <NEWLINE> ans += n <NEWLINE> if n in a : <NEWLINE> <INDENT> a [ n ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ n ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> b = int ( line [ 0 ] ) <NEWLINE> c = int ( line [ 1 ] ) <NEWLINE> <NL> if b in a : <NEWLINE> <INDENT> ab = a [ b ] <NEWLINE> a [ b ] = 0 <NEWLINE> if c in a : <NEWLINE> <INDENT> ac = a [ c ] <NEWLINE> a [ c ] += ab <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ c ] = ab <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ab = 0 <NEWLINE> <NL> <DEDENT> ans -= ab * b <NEWLINE> ans += ab * c <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = 10 ** 18 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> from scipy . special import comb <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = np . cumsum ( a ) <NEWLINE> <NL> <NL> re_list = { } <NEWLINE> re_list [ 0 ] = 1 <NEWLINE> for i in a_sum : <NEWLINE> <INDENT> re = i % m <NEWLINE> if re in re_list : <NEWLINE> <INDENT> re_list [ re ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_list [ re ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for value in re_list . values ( ) : <NEWLINE> <INDENT> ans += comb ( value , 2 , exact = True ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> mul = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> mul *= i <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * ( 1 + n // i ) * ( n // i ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math , bisect <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> from itertools import groupby , accumulate <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from collections import deque , Counter , defaultdict <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def neo ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def Neo ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def dfs ( t ) : <NEWLINE> <INDENT> vis [ t ] = 1 <NEWLINE> for i in G [ t ] : <NEWLINE> <INDENT> if not vis [ i ] : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> N , M = neo ( ) <NEWLINE> G = defaultdict ( list ) <NEWLINE> vis = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = neo ( ) <NEWLINE> G [ x ] += [ y ] <NEWLINE> G [ y ] += [ x ] <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if not vis [ i ] : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c - 1 ) <NEWLINE>
R , G , B , n = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for r in range ( n + 1 ) : <NEWLINE> <INDENT> for g in range ( n + 1 ) : <NEWLINE> <INDENT> bb = n - r * R - g * G <NEWLINE> if bb < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif bb % B == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> print ( ( A * N ) // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> qa , ra = divmod ( A , B ) <NEWLINE> rx = B - 1 <NEWLINE> print ( qa * rx + ( ra * rx ) // B ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> count = [ ] <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( i , i + len ( t ) ) : <NEWLINE> <INDENT> if s [ j ] == t [ j - i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> count . append ( c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( len ( t ) - max ( count ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> k = 0 <NEWLINE> t = <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> if i == len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> t = a [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> if j == len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> t = b [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> if k == len ( c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> t = c [ k ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> [ N , K ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> price = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> price . sort ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> sum += price [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = min ( ans , 10 ** 18 + 1 ) <NEWLINE> <NL> <DEDENT> if ans == 10 ** 18 + 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> al , bl = [ ] , [ ] <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( min ( b - a , k ) ) : <NEWLINE> <INDENT> al . append ( a + i ) <NEWLINE> bl . append ( b - i ) <NEWLINE> ans = list ( set ( al ) | set ( bl ) ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def xxx ( t , memo , ans , kyori ) : <NEWLINE> <INDENT> for a in memo [ t ] : <NEWLINE> <INDENT> if ans [ a ] == - 1 or kyori [ a ] > ( kyori [ t ] + 1 ) : <NEWLINE> <INDENT> ans [ a ] = t <NEWLINE> kyori [ a ] = kyori [ t ] + 1 <NEWLINE> xxx ( a , memo , ans , kyori ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> n , m = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> memo = [ [ ] for i in range ( n ) ] <NEWLINE> ans = [ - 1 ] * n <NEWLINE> kyori = [ - 1 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> kyori [ 0 ] = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> memo [ a - 1 ] . append ( b - 1 ) <NEWLINE> memo [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> tt = [ 0 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> nx = [ ] <NEWLINE> for t in tt : <NEWLINE> <INDENT> for a in memo [ t ] : <NEWLINE> <INDENT> if ans [ a ] == - 1 or kyori [ a ] > ( kyori [ t ] + 1 ) : <NEWLINE> <INDENT> nx . append ( a ) <NEWLINE> ans [ a ] = t <NEWLINE> kyori [ a ] = kyori [ t ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( nx ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tt = nx <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if - 1 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import bisect <NEWLINE> import collections <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> ACMOD = 1000000007 <NEWLINE> INF = 1 << 62 <NEWLINE> <NL> <NL> def lmi ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def llmi ( n ) : <NEWLINE> <INDENT> return [ lmi ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> A , B , N = lmi ( ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> i = min ( B - 1 , N ) <NEWLINE> print ( ( A * ( i % B ) - ( A * i ) % B ) // B ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a , b , c <NEWLINE> x = sorted ( d ) <NEWLINE> print ( x [ 0 ] , x [ 1 ] , x [ 2 ] ) <NEWLINE>
def resolve ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = set ( ) <NEWLINE> cnt1 = [ 0 for i in range ( H ) ] <NEWLINE> cnt2 = [ 0 for i in range ( W ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb . add ( ( h - 1 , w - 1 ) ) <NEWLINE> cnt1 [ h - 1 ] += 1 <NEWLINE> cnt2 [ w - 1 ] += 1 <NEWLINE> <DEDENT> m1 = max ( cnt1 ) <NEWLINE> m2 = max ( cnt2 ) <NEWLINE> hk , wk = [ ] , [ ] <NEWLINE> for i , x in enumerate ( cnt1 ) : <NEWLINE> <INDENT> if x == m1 : <NEWLINE> <INDENT> hk . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i , x in enumerate ( cnt2 ) : <NEWLINE> <INDENT> if x == m2 : <NEWLINE> <INDENT> wk . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = m1 + m2 <NEWLINE> for i in hk : <NEWLINE> <INDENT> for j in wk : <NEWLINE> <INDENT> if ( i , j ) in bomb : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> def main ( ) : <NEWLINE> <NL> <INDENT> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> s = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> d = dict ( ) <NEWLINE> d [ <STRING> ] = A <NEWLINE> d [ <STRING> ] = B <NEWLINE> d [ <STRING> ] = C <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if d [ s [ i ] [ 0 ] ] == 0 and d [ s [ i ] [ 1 ] ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif d [ s [ i ] [ 0 ] ] == 0 : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] += 1 <NEWLINE> d [ s [ i ] [ 1 ] ] -= 1 <NEWLINE> ans += s [ i ] [ 0 ] <NEWLINE> <DEDENT> elif d [ s [ i ] [ 1 ] ] == 0 : <NEWLINE> <INDENT> d [ s [ i ] [ 1 ] ] += 1 <NEWLINE> d [ s [ i ] [ 0 ] ] -= 1 <NEWLINE> ans += s [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if d [ s [ i ] [ 0 ] ] == 1 and d [ s [ i ] [ 1 ] ] == 1 and d [ <STRING> ] + d [ <STRING> ] + d [ <STRING> ] == 2 : <NEWLINE> <INDENT> if i < N - 1 and s [ i ] != s [ i + 1 ] and s [ i ] [ 0 ] in s [ i + 1 ] : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] += 1 <NEWLINE> d [ s [ i ] [ 1 ] ] -= 1 <NEWLINE> ans += s [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s [ i ] [ 1 ] ] += 1 <NEWLINE> d [ s [ i ] [ 0 ] ] -= 1 <NEWLINE> ans += s [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> elif d [ s [ i ] [ 0 ] ] < d [ s [ i ] [ 1 ] ] : <NEWLINE> <INDENT> d [ s [ i ] [ 0 ] ] += 1 <NEWLINE> d [ s [ i ] [ 1 ] ] -= 1 <NEWLINE> ans += s [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s [ i ] [ 1 ] ] += 1 <NEWLINE> d [ s [ i ] [ 0 ] ] -= 1 <NEWLINE> ans += s [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for c in ans : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . par = [ - 1 ] * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <COMMENT> <NL> <DEDENT> self . par [ x ] = self . root ( self . par [ x ] ) <COMMENT> <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> <COMMENT> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> if self . par [ x ] > self . par [ y ] : <COMMENT> <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - 1 * self . par [ self . root ( x ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <COMMENT> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> path = defaultdict ( list ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> path [ A ] . append ( B ) <NEWLINE> path [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> prev = [ 0 ] * N <NEWLINE> dist = [ 0 ] * N <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> <NL> while ( len ( q ) > 0 ) : <NEWLINE> <INDENT> a = q . popleft ( ) <NEWLINE> for b in path [ a ] : <NEWLINE> <INDENT> if dist [ b ] != 0 : continue <NEWLINE> q . append ( b ) <NEWLINE> prev [ b ] = a <NEWLINE> dist [ b ] = dist [ a ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> for a in prev [ 1 : ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if ( T [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += T [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = [ <STRING> ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if num [ s - 1 ] != <STRING> and num [ s - 1 ] != c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ s - 1 ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> if num [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif num [ 0 ] == <STRING> : <NEWLINE> <INDENT> num [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if num [ i ] == <STRING> : <NEWLINE> <INDENT> num [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ i ] = str ( num [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( num ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> a = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> vilist = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> vilist . append ( ( nums [ i ] , i ) ) <NEWLINE> <DEDENT> vilist = sorted ( vilist , key = lambda vi : vi [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> dp = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> dp . append ( [ 0 ] * ( a - i ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for k in range ( a - 1 ) : <NEWLINE> <INDENT> vi = vilist . pop ( ) <NEWLINE> v = vi [ 0 ] <NEWLINE> p = vi [ 1 ] <NEWLINE> vi_z = vilist [ 0 ] <NEWLINE> vz = vi_z [ 0 ] <NEWLINE> pz = vi_z [ 1 ] <NEWLINE> <NL> for i in range ( k + 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> j = k - i + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if k == a - 2 : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + v * abs ( p - i + 1 ) + vz * abs ( pz - i ) <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + v * abs ( a - j - p ) + vz * abs ( a - j - 1 - pz ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] + v * abs ( p - i + 1 ) + vz * abs ( pz - i ) , <NEWLINE> <INDENT> dp [ i ] [ j - 1 ] + v * abs ( a - j - p ) + vz * abs ( pz - i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + v * abs ( p - i + 1 ) <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + v * abs ( a - j - p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] + v * abs ( p - i + 1 ) , <NEWLINE> <INDENT> dp [ i ] [ j - 1 ] + v * abs ( a - j - p ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( [ max ( x ) for x in dp ] ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> if A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = [ 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> rest . append ( min ( rest [ i - 1 ] * 2 - A [ i ] , 10 ** 13 ) ) <NEWLINE> <DEDENT> ans , cnodes = A [ N ] , A [ N ] <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if cnodes // 2 + cnodes % 2 > rest [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnodes = min ( cnodes , rest [ i ] ) + A [ i ] <NEWLINE> ans += cnodes <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <STRING> <NEWLINE> sum_max = 0 <NEWLINE> minus = 0 <NEWLINE> if ( a + b >= k ) : <NEWLINE> <INDENT> if ( a >= k ) : <NEWLINE> <INDENT> sum_max = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_max = a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> minus = k - ( a + b ) <NEWLINE> sum_max = a - minus <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( sum_max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 for i in range ( N ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in B : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> w , v = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w_ , v_ = map ( int , input ( ) . split ( ) ) <NEWLINE> w . append ( w_ ) <NEWLINE> v . append ( v_ ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( ( N + 1 , W + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = np . zeros ( W + 1 , dtype = int ) <NEWLINE> tmp [ w [ i ] : ] = dp [ i ] [ : - w [ i ] ] + v [ i ] <NEWLINE> dp [ i + 1 ] = np . maximum ( dp [ i ] , tmp ) <NEWLINE> <NL> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from collections import deque <NEWLINE> s = input ( ) [ : : - 1 ] <NEWLINE> lsts = [ 0 ] * 2019 <NEWLINE> kai = 1 <NEWLINE> cou = 0 <NEWLINE> st = 0 <NEWLINE> lsts [ 0 ] = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> st += int ( i ) * kai <NEWLINE> st %= 2019 <NEWLINE> cou += lsts [ st ] <NEWLINE> lsts [ st ] += 1 <NEWLINE> kai = kai * 10 % 2019 <NEWLINE> <NL> <DEDENT> print ( cou ) <NEWLINE>
ss = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in ss : <NEWLINE> <INDENT> j = i <NEWLINE> cnt = 0 <NEWLINE> while j < len ( s ) : <NEWLINE> <INDENT> if s [ j ] in ss : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> x = set ( s ) <NEWLINE> print ( len ( x ) ) <NEWLINE>
A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> if N < 1000001 : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c = int ( A * i / B ) - A * int ( i / B ) <NEWLINE> if ans < c : <NEWLINE> <INDENT> ans = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif N < B : <NEWLINE> <INDENT> ans = int ( A * N / B ) - A * int ( N / B ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count = B - 1 <NEWLINE> for i in range ( 10000 ) : <NEWLINE> <INDENT> c = int ( A * count / B ) - A * int ( count / B ) <NEWLINE> if ans < c : <NEWLINE> <INDENT> ans = c <NEWLINE> <DEDENT> count += B <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> data = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> if len ( command ) == 2 : <NEWLINE> <INDENT> command , x = command <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> command = command [ 0 ] <NEWLINE> <DEDENT> if command == <STRING> : <NEWLINE> <INDENT> data . appendleft ( x ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> if x in data : <NEWLINE> <INDENT> data . remove ( x ) <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> data . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> data . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * data ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ 1 ] * N + [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> A [ i ] = A [ 2 * i ] * A [ 2 * i + 1 ] <NEWLINE> <DEDENT> print ( A [ 1 ] if A [ 1 ] <= 10 ** 18 else - 1 ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> gcd_l = [ 0 ] <NEWLINE> gcd_r = [ 0 ] <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> gcd_l . append ( math . gcd ( gcd_l [ i ] , A [ i ] ) ) <NEWLINE> gcd_r . append ( math . gcd ( gcd_r [ i ] , A [ - ( i + 1 ) ] ) ) <NEWLINE> <NL> <DEDENT> gcd_r = gcd_r [ : : - 1 ] <NEWLINE> <NL> max_gcd = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> max_gcd = max ( max_gcd , math . gcd ( gcd_l [ i ] , gcd_r [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> print ( max_gcd ) <NEWLINE>
z = input ( ) <NEWLINE> x , y = z . split ( ) <NEWLINE> a = int ( x ) * int ( y ) <NEWLINE> b = int ( x ) * 2 + int ( y ) * 2 <NEWLINE> print ( <STRING> . format ( a , b ) ) <NEWLINE>
<NL> N = list ( input ( ) ) <NEWLINE> k = 0 <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> N [ i ] = int ( N [ i ] ) <NEWLINE> k += N [ i ] <NEWLINE> <NL> <DEDENT> if k % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 == p [ i ] : <NEWLINE> <INDENT> if i + 1 == n : <NEWLINE> <INDENT> p [ i ] , p [ i - 1 ] = p [ i - 1 ] , p [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ - 1 for _ in range ( n ) ] <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> tree [ u ] . append ( v ) <NEWLINE> tree [ v ] . append ( u ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> dp = [ INF for _i in range ( n + 1 ) ] <NEWLINE> <NL> <NL> def dfs ( p , x ) : <NEWLINE> <INDENT> i = bisect_left ( dp , a [ p ] ) <NEWLINE> old = dp [ i ] <NEWLINE> dp [ i ] = a [ p ] <NEWLINE> result [ p ] = bisect_left ( dp , INF ) <NEWLINE> for j in tree [ p ] : <NEWLINE> <INDENT> if j != x : <NEWLINE> <INDENT> dfs ( j , p ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = old <NEWLINE> <NL> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <NL> for i in result : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S ^= { input ( ) } <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> good = [ True ] * n <NEWLINE> for im in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> good [ b - 1 ] = False <NEWLINE> <DEDENT> elif h [ b - 1 ] > h [ a - 1 ] : <NEWLINE> <INDENT> good [ a - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> good [ a - 1 ] = False <NEWLINE> good [ b - 1 ] = False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( good . count ( True ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> cnt = 0 <NEWLINE> x = math . inf <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if min ( x , i [ j ] ) == i [ j ] : <NEWLINE> <INDENT> x = i [ j ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 998244353 <NEWLINE> <NL> <NL> def do ( ) : <NEWLINE> <NL> <INDENT> def power_func ( a , n , p ) : <NEWLINE> <INDENT> bi = str ( format ( n , <STRING> ) ) <NEWLINE> res = 1 <NEWLINE> for i in range ( len ( bi ) ) : <NEWLINE> <INDENT> res = ( res * res ) % p <NEWLINE> if bi [ i ] == <STRING> : <NEWLINE> <INDENT> res = ( res * a ) % p <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> n , m , k = INTM ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> temp = m <NEWLINE> temp = m * power_func ( m - 1 , n - 1 - i , mod ) % mod <NEWLINE> temp = temp * cmb ( n - 1 , i , mod ) % mod <NEWLINE> <COMMENT> <NL> ans += temp <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> road_max = [ 0 for l in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if road_max [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> road_max [ a - 1 ] = H [ b - 1 ] <NEWLINE> <DEDENT> if road_max [ b - 1 ] < H [ a - 1 ] : <NEWLINE> <INDENT> road_max [ b - 1 ] = H [ a - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> result = [ ( road_max [ p ] < H [ p ] ) * 1 for p in range ( N ) ] <NEWLINE> <NL> print ( sum ( result ) ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> S = set ( [ ] ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + 1 + K ) : <NEWLINE> <COMMENT> <NL> <INDENT> S . add ( s [ i : j ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = sorted ( S ) [ K - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> <NL> result = x + y <NEWLINE> length = len ( str ( result ) ) <NEWLINE> if length > 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import bisect <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uvs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> shortest = [ 10e+10 for _ in range ( N ) ] <NEWLINE> shortest [ 0 ] = 0 <NEWLINE> <NL> routes = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for uv in uvs : <NEWLINE> <INDENT> routes [ uv [ 0 ] - 1 ] . append ( uv [ 1 ] - 1 ) <NEWLINE> routes [ uv [ 1 ] - 1 ] . append ( uv [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> lis = [ 10e+100 for _ in range ( N ) ] <NEWLINE> minimum = [ 10e+100 for _ in range ( N ) ] <NEWLINE> seen = [ False for _ in range ( N ) ] <NEWLINE> seen [ 0 ] = True <NEWLINE> <NL> def function ( checking ) : <NEWLINE> <INDENT> insert_posi = bisect . bisect_left ( lis , a [ checking ] ) <NEWLINE> preserved = lis [ insert_posi ] <NEWLINE> lis [ insert_posi ] = a [ checking ] <NEWLINE> minimum [ checking ] = bisect . bisect_left ( lis , 10e+50 ) <NEWLINE> for route in routes [ checking ] : <NEWLINE> <INDENT> if seen [ route ] == False : <NEWLINE> <INDENT> seen [ route ] = True <NEWLINE> shortest [ route ] = shortest [ checking ] + 1 <NEWLINE> function ( route ) <NEWLINE> <DEDENT> <DEDENT> lis [ insert_posi ] = preserved <NEWLINE> return <NEWLINE> <NL> <DEDENT> function ( 0 ) <NEWLINE> <NL> [ print ( x ) for x in minimum ] <NEWLINE>
<NL> def C ( ) : <NEWLINE> <INDENT> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> counter = 0 <NEWLINE> for i in range ( 1 , 13 ) : <NEWLINE> <INDENT> if int ( 26 * ( pow ( 26 , i - 1 ) ) / ( 26 - 1 ) ) <= n < int ( 26 * ( pow ( 26 , i ) ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> counter = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> kekka = n - int ( 26 * ( pow ( 26 , counter - 1 ) ) / ( 26 - 1 ) ) <NEWLINE> <NL> alplist = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> kekkalist = [ ] <NEWLINE> i = counter - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> sho = int ( kekka / pow ( 26 , i ) ) <NEWLINE> kekka = kekka - pow ( 26 , i ) * sho <NEWLINE> <NL> i -= 1 <NEWLINE> if i >= 0 : <NEWLINE> <INDENT> kekkalist . append ( alplist [ sho ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kekkalist . append ( alplist [ sho ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( kekkalist ) ) <NEWLINE> <NL> <NL> <DEDENT> C ( ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if d - a >= 0 : <NEWLINE> <INDENT> d = d - a <NEWLINE> ans += a <NEWLINE> if d - b > 0 : <NEWLINE> <INDENT> d -= b <NEWLINE> if d - c == 0 : <NEWLINE> <INDENT> ans -= c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans - d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += d <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x * 2 > y : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif x * 4 < y : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif ( y - x * 2 ) % 2 == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> print ( <STRING> if flag == True else <STRING> ) <NEWLINE>
N = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> A = { } <NEWLINE> for a in [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] : <NEWLINE> <INDENT> A . setdefault ( a , 0 ) <NEWLINE> A [ a ] += 1 <NEWLINE> <DEDENT> total = sum ( [ k * v for k , v in A . items ( ) ] ) <NEWLINE> <NL> Q = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> B , C = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> if B in A : <NEWLINE> <INDENT> A . setdefault ( C , 0 ) <NEWLINE> dif = ( C - B ) * A [ B ] <NEWLINE> A [ C ] += A [ B ] <NEWLINE> del A [ B ] <NEWLINE> total += dif <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = [ int ( i ) * ( - 1 ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> import heapq <NEWLINE> <NL> heapq . heapify ( A_list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x = heapq . heappop ( A_list ) <NEWLINE> heapq . heappush ( A_list , ( - 1 ) * ( - x // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A_list ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2000000000 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> import math <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> tobi = [ 0 ] * ( math . ceil ( N / 2 ) ) <NEWLINE> tobi [ 0 ] = l [ 0 ] <NEWLINE> for i in range ( 1 , math . ceil ( N / 2 ) ) : <NEWLINE> <INDENT> tobi [ i ] = tobi [ i - 1 ] + l [ i * 2 ] <NEWLINE> <DEDENT> from functools import lru_cache <NEWLINE> @ lru_cache ( maxsize = 1000000000 ) <NEWLINE> def motomeru ( x , y ) : <NEWLINE> <INDENT> if y == 0 or x == 0 or x == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> return max ( motomeru ( x - 2 , y - 1 ) + l [ x - 1 ] , tobi [ math . floor ( ( x - 1 ) / 2 ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return max ( motomeru ( x - 2 , y - 1 ) + l [ x - 1 ] , motomeru ( x - 1 , y ) ) <NEWLINE> <DEDENT> <DEDENT> print ( motomeru ( N , N // 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> A = [ 0 ] * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> A [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans += i * A [ i ] <NEWLINE> <NL> <DEDENT> for n in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans += ( c * A [ b ] ) - ( b * A [ b ] ) <NEWLINE> A [ c ] += A [ b ] <NEWLINE> A [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> r = 0 <NEWLINE> <DEDENT> for n in A : <NEWLINE> <INDENT> r = r * n <NEWLINE> if r > 10 ** 18 : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
( d , ) , cc , * sstt = [ list ( map ( int , s . split ( ) ) ) for s in open ( 0 ) ] <NEWLINE> <NL> ss = sstt [ : d ] <NEWLINE> <NL> tt = list ( map ( lambda x : x - 1 , sum ( sstt [ d : ] , [ ] ) ) ) <NEWLINE> <NL> comp = [ 0 ] * len ( cc ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> comp = [ sum ( x ) for x in zip ( comp , cc ) ] <NEWLINE> t = tt [ i ] <NEWLINE> ans += ss [ i ] [ t ] <NEWLINE> comp [ t ] = 0 <NEWLINE> ans -= sum ( comp ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n = 0 ) : <NEWLINE> <INDENT> self . d = [ - 1 ] * n <NEWLINE> self . g = set ( ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . d [ x ] < 0 : return x <NEWLINE> self . d [ x ] = self . find ( self . d [ x ] ) <NEWLINE> return self . d [ x ] <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : return False <NEWLINE> if self . d [ x ] > self . d [ y ] : x , y = y , x <NEWLINE> self . d [ x ] += self . d [ y ] <NEWLINE> self . g . add ( x ) <NEWLINE> if y in self . g : self . g . remove ( y ) <NEWLINE> self . d [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : return self . find ( x ) == self . find ( y ) <NEWLINE> def size ( self , x ) : return - self . d [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def comb2 ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> total = comb2 ( N ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> ans = [ total ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> a , b = E [ - i - 1 ] <NEWLINE> if uf . same ( a , b ) : <NEWLINE> <INDENT> ans . append ( ans [ - 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> size1 , size2 = uf . size ( a ) , uf . size ( b ) <NEWLINE> uf . unite ( a , b ) <NEWLINE> size3 = uf . size ( a ) <NEWLINE> tmp = ans [ - 1 ] + comb2 ( size1 ) + comb2 ( size2 ) - comb2 ( size3 ) <NEWLINE> ans . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans [ : : - 1 ] ) <NEWLINE>
num = [ 0 for i in range ( 2019 ) ] <NEWLINE> num [ 0 ] = 1 <NEWLINE> count = 0 <NEWLINE> s = input ( ) <NEWLINE> now = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + int ( s [ i ] ) * p ) % 2019 <NEWLINE> count += num [ now ] <NEWLINE> num [ now ] += 1 <NEWLINE> p = p * 10 % 2019 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
k , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> R = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> minv = R [ 0 ] <NEWLINE> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( maxv , R [ i ] - minv ) <NEWLINE> minv = min ( minv , R [ i ] ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> counter = 0 <NEWLINE> for a , b , c in itertools . product ( range ( 10 ) , repeat = 3 ) : <NEWLINE> <NL> <INDENT> a_ind = S . find ( str ( a ) ) <NEWLINE> if a_ind == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_ind = S [ a_ind + 1 : ] . find ( str ( b ) ) <NEWLINE> if b_ind == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_ind = S [ a_ind + 1 + b_ind + 1 : ] . find ( str ( c ) ) <NEWLINE> if c_ind == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
<COMMENT> <NL> kaisuu = int ( input ( ) ) <NEWLINE> getprizelist = { } <NEWLINE> for i in range ( kaisuu ) : <NEWLINE> <INDENT> keihin = input ( ) <NEWLINE> if keihin not in getprizelist : <NEWLINE> <INDENT> getprizelist [ keihin ] = i <NEWLINE> <DEDENT> <DEDENT> print ( len ( getprizelist ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from collections import namedtuple <NEWLINE> <NL> MAX_N , MAX_V = 100 , 100 <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> dp = [ [ float ( <STRING> ) ] * ( MAX_N * MAX_V + 1 ) for _ in range ( MAX_N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for i , item in enumerate ( item_list ) : <NEWLINE> <INDENT> v , w = item . value , item . weight <NEWLINE> for j in range ( MAX_N * MAX_V + 1 ) : <NEWLINE> <INDENT> if j < v : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = dp [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j - v ] + w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( MAX_N * MAX_V + 1 ) : <NEWLINE> <INDENT> if dp [ c_items ] [ i ] <= real_cp : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> c_items , real_cp = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> items = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> Item = namedtuple ( <STRING> , ( <STRING> , <STRING> ) ) <NEWLINE> item_list = [ Item ( int ( v ) , int ( w ) ) for v , w in items ] <NEWLINE> <NL> print ( solve ( ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> cnt += math . gcd ( math . gcd ( a , b ) , c ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> cnt += math . gcd ( a , b ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cnt += i <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = np . sum ( A ) - np . cumsum ( np . append ( 0 , A [ : len ( A ) - 1 ] ) ) <NEWLINE> v = 0 <NEWLINE> k = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if N == 0 and A [ 0 ] == 1 : <NEWLINE> <INDENT> k = 1 <NEWLINE> <DEDENT> elif A [ 0 ] == 0 : <NEWLINE> <INDENT> k = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif i == N : <NEWLINE> <INDENT> if B [ i ] <= 2 * ( k - A [ i - 1 ] ) : <NEWLINE> <INDENT> k = B [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 0 <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> k = min ( 2 * ( k - A [ i - 1 ] ) , B [ i ] ) <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> v += k <NEWLINE> <DEDENT> if k > 0 : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> D = [ ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> D . append ( X [ i ] - X [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> D . sort ( reverse = True ) <NEWLINE> d = 0 <NEWLINE> if i > 1 : <NEWLINE> <INDENT> for i in range ( min ( n - 1 , m - 1 ) ) : <NEWLINE> <INDENT> d += D [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum ( D ) - d <NEWLINE> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( int ( a * ( x ) / b ) - a * int ( x / b ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> n = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> a_lst = [ int ( x ) for x in stdin . readline ( ) . strip ( ) . split ( ) ] <NEWLINE> <NL> pos = len ( a_lst ) // 2 <NEWLINE> min_diff = 10000000000000000000 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> left = sum ( a_lst [ : pos ] ) <NEWLINE> right = sum ( a_lst [ pos : ] ) <NEWLINE> diff = right - left <NEWLINE> <NL> if min_diff > abs ( diff ) : min_diff = abs ( diff ) <NEWLINE> else : break <NEWLINE> <NL> if diff > 0 : pos += 1 <NEWLINE> elif diff < 0 : pos -= 1 <NEWLINE> <NL> <DEDENT> print ( min_diff ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , i ) <NEWLINE> c = bisect . bisect_right ( C , i ) <NEWLINE> p = a * ( N - c ) <NEWLINE> count += p <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> <NL> <DEDENT> def move_E ( self ) : <NEWLINE> <INDENT> self . copy = self . num . copy ( ) <NEWLINE> for i , j in zip ( [ 0 , 2 , 5 , 3 ] , [ 3 , 0 , 2 , 5 ] ) : <NEWLINE> <INDENT> self . num [ i ] = self . copy [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> def move_W ( self ) : <NEWLINE> <INDENT> self . copy = self . num . copy ( ) <NEWLINE> for i , j in zip ( [ 0 , 3 , 5 , 2 ] , [ 2 , 0 , 3 , 5 ] ) : <NEWLINE> <INDENT> self . num [ i ] = self . copy [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> def move_N ( self ) : <NEWLINE> <INDENT> self . copy = self . num . copy ( ) <NEWLINE> for i , j in zip ( [ 0 , 1 , 5 , 4 ] , [ 1 , 5 , 4 , 0 ] ) : <NEWLINE> <INDENT> self . num [ i ] = self . copy [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> def move_S ( self ) : <NEWLINE> <INDENT> self . copy = self . num . copy ( ) <NEWLINE> for i , j in zip ( [ 0 , 1 , 5 , 4 ] , [ 4 , 0 , 1 , 5 ] ) : <NEWLINE> <INDENT> self . num [ i ] = self . copy [ j ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> number = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dice = Dice ( number ) <NEWLINE> <NL> for order in input ( ) : <NEWLINE> <INDENT> if order == <STRING> : <NEWLINE> <INDENT> dice . move_S ( ) <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> dice . move_N ( ) <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> dice . move_W ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice . move_E ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( dice . num [ 0 ] ) <NEWLINE>
from copy import copy <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> while k : <NEWLINE> <INDENT> if k & 1 : <NEWLINE> <INDENT> ans = a [ ans ] <NEWLINE> <DEDENT> c = [ a [ a [ i ] ] for i in range ( n ) ] <NEWLINE> a = copy ( c ) <NEWLINE> k >>= 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b ) <NEWLINE> graph [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> prev = [ 1 ] <NEWLINE> siru = [ 0 ] * n <NEWLINE> siru [ 0 ] = 1 <NEWLINE> while q : <NEWLINE> <NL> <INDENT> now = q . popleft ( ) <NEWLINE> <NL> next = graph [ now - 1 ] <NEWLINE> <NL> <NL> for n in next : <NEWLINE> <INDENT> if not siru [ n - 1 ] : <NEWLINE> <INDENT> q . append ( n ) <NEWLINE> siru [ n - 1 ] = now <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , siru [ 1 : ] ) ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> G = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> G [ i + 1 ] = [ ] <NEWLINE> <DEDENT> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] += [ [ b , c ] ] <NEWLINE> G [ b ] += [ [ a , c ] ] <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dist = [ - 1 ] * n <NEWLINE> dist [ k - 1 ] = 0 <NEWLINE> que = [ k ] <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> s = que . pop ( 0 ) <NEWLINE> for [ nv , c ] in G [ s ] : <NEWLINE> <INDENT> if dist [ nv - 1 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv - 1 ] = dist [ s - 1 ] + c <NEWLINE> que . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> black = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if black > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> black -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> total *= a [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = 998244353 <NEWLINE> <NL> def comb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <DEDENT> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact . append ( fact [ - 1 ] * i % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ i ] ) % p ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> row = comb ( n - 1 , i , p ) <NEWLINE> column = m * pow ( m - 1 , n - i - 1 , p ) <NEWLINE> ans += row * column <NEWLINE> <NL> <DEDENT> print ( ans % p ) <NEWLINE>
b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( b + w ) <NEWLINE> dp [ 0 ] = 1 / 2 <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <DEDENT> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , b + w + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <DEDENT> t1 , t2 = 0 , 0 <NEWLINE> for i in range ( 1 , 1 + b + w ) : <NEWLINE> <INDENT> t = pow ( 2 , mod - 2 , mod ) <NEWLINE> if i - b > 0 : <NEWLINE> <INDENT> t1 *= 2 <NEWLINE> t1 %= mod <NEWLINE> t1 += cmb ( i - 2 , b - 1 , mod ) <NEWLINE> t1 %= mod <NEWLINE> tmp = t1 * pow ( 2 , mod - 1 - i , mod ) <NEWLINE> tmp %= mod <NEWLINE> t -= tmp <NEWLINE> t %= mod <NEWLINE> <DEDENT> if i - w > 0 : <NEWLINE> <INDENT> t2 *= 2 <NEWLINE> t2 %= mod <NEWLINE> t2 += cmb ( i - 2 , w - 1 , mod ) <NEWLINE> t2 %= mod <NEWLINE> tmp = t2 * pow ( 2 , mod - 1 - i , mod ) <NEWLINE> tmp %= mod <NEWLINE> t += tmp <NEWLINE> t %= mod <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> W , H = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if W == 0 & H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> * H ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> S = input ( ) <NEWLINE> s = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> s += [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> que = [ ] <NEWLINE> que += [ s [ 0 ] ] <NEWLINE> def cube ( i ) : <NEWLINE> <INDENT> global ans <NEWLINE> if i == len ( s ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . append ( s [ i ] ) <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> if len ( que ) == 0 or len ( que ) == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif que [ - 1 ] == que [ - 2 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif que [ - 1 ] != que [ - 2 ] : <NEWLINE> <INDENT> del que [ - 1 ] <NEWLINE> del que [ - 1 ] <NEWLINE> ans += 2 <NEWLINE> <DEDENT> <DEDENT> cube ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> cube ( 1 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def map_int_input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) ) <NEWLINE> <NL> <DEDENT> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def MII_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) ) <NEWLINE> <NL> <DEDENT> def MII_split_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def list_int_inputs ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <DEDENT> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def LII_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> def LII_split_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> N = input_int ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if N < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> rs = [ ] <NEWLINE> gs = [ ] <NEWLINE> bs = [ ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> rs . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> gs . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bs . append ( i ) <NEWLINE> <DEDENT> <DEDENT> count = len ( rs ) * len ( gs ) * len ( bs ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for skip in range ( 1 , N // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if i + 2 * skip > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] == S [ i + skip ] or S [ i + skip ] == S [ i + 2 * skip ] or S [ i ] == S [ i + 2 * skip ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> lcnt = - 1 <NEWLINE> rcnt = - 1 <NEWLINE> <NL> rr = [ 0 ] * n <NEWLINE> ll = [ 0 ] * n <NEWLINE> sim = <STRING> <NEWLINE> for si in s : <NEWLINE> <INDENT> if si == <STRING> and sim == <STRING> : <NEWLINE> <INDENT> rr [ rcnt ] += 1 <NEWLINE> <DEDENT> elif si == <STRING> and sim != <STRING> : <NEWLINE> <INDENT> rcnt += 1 <NEWLINE> rr [ rcnt ] = 1 <NEWLINE> <DEDENT> if si == <STRING> and sim == <STRING> : <NEWLINE> <INDENT> ll [ lcnt ] += 1 <NEWLINE> <DEDENT> elif si == <STRING> and sim != <STRING> : <NEWLINE> <INDENT> lcnt += 1 <NEWLINE> ll [ lcnt ] = 1 <NEWLINE> <DEDENT> sim = si <NEWLINE> <NL> <DEDENT> ll = [ i for i in ll if i != 0 ] <NEWLINE> rr = [ i for i in rr if i != 0 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> minlen = min ( len ( ll ) , len ( rr ) ) <NEWLINE> if minlen <= k : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> ll [ i ] += rr [ i ] <NEWLINE> rr [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( len ( ll ) - 1 ) : <NEWLINE> <INDENT> if i < len ( rr ) and ll [ i ] != 0 and rr [ i ] == 0 : <NEWLINE> <INDENT> ll [ i + 1 ] += ll [ i ] <NEWLINE> ll [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> icnt = 0 <NEWLINE> for i in range ( len ( ll ) ) : <NEWLINE> <INDENT> icnt += max ( ll [ i ] - 1 , 0 ) <NEWLINE> <DEDENT> for i in range ( len ( rr ) ) : <NEWLINE> <INDENT> icnt += max ( rr [ i ] - 1 , 0 ) <NEWLINE> <NL> <DEDENT> print ( icnt ) <NEWLINE>
i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> matrix = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( i ) ] <NEWLINE> vector = [ int ( input ( ) ) for _ in range ( j ) ] <NEWLINE> for x in range ( i ) : <NEWLINE> <INDENT> print ( sum ( [ v * m for v , m in zip ( vector , matrix [ x ] ) ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 20000 ) <NEWLINE> <NL> field = [ ] <NEWLINE> w = 0 <NEWLINE> h = 0 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> global field , w , h <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> field = [ ] <NEWLINE> [ field . append ( list ( input ( ) ) ) for _ in range ( h ) ] <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if field [ y ] [ x ] != - 1 : <NEWLINE> <INDENT> dfs ( field [ y ] [ x ] , x , y ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( kind , x , y ) : <NEWLINE> <INDENT> global field <NEWLINE> field [ y ] [ x ] = - 1 <NEWLINE> for dx , dy in zip ( [ 0 , 0 , - 1 , 1 ] , [ 1 , - 1 , 0 , 0 ] ) : <NEWLINE> <INDENT> next_x = x + dx <NEWLINE> next_y = y + dy <NEWLINE> if next_x < 0 or next_y < 0 or next_x >= w or next_y >= h or field [ next_y ] [ next_x ] != kind : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( field [ next_y ] [ next_x ] , next_x , next_y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> x = int ( input ( ) ) <NEWLINE> lim = 10 ** 3 <NEWLINE> for i in range ( - lim , lim ) : <NEWLINE> <INDENT> for j in range ( - lim , lim ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = ( N * ( N + 1 ) ) // 2 <COMMENT> <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> m = N // i <NEWLINE> ans += i * ( m * ( m + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 or ( i + j ) == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> maxv = 0 <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if maxv > a : <NEWLINE> <INDENT> ans += maxv - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxv = a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> X = input ( ) <NEWLINE> <NL> def popcount ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while 0 < n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> p = <STRING> . format ( n ) . count ( <STRING> ) <NEWLINE> n %= p <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> <DEDENT> n = X . count ( <STRING> ) <NEWLINE> <NL> n1 = n - 1 <NEWLINE> n2 = n + 1 <NEWLINE> <NL> q_1 = [ 0 ] * N <NEWLINE> q_2 = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if n1 != 0 : <NEWLINE> <INDENT> q_1 [ i ] = pow ( 2 , i , n1 ) <NEWLINE> <DEDENT> if n2 != 0 : <NEWLINE> <INDENT> q_2 [ i ] = pow ( 2 , i , n2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> mod_sum_1 = 0 <NEWLINE> mod_sum_2 = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> mod_sum_1 += q_1 [ i ] <NEWLINE> mod_sum_2 += q_2 [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> q_1 = q_1 [ : : - 1 ] <NEWLINE> q_2 = q_2 [ : : - 1 ] <NEWLINE> <NL> <NL> if n1 == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = n2 <NEWLINE> mod_sum = mod_sum_2 + q_2 [ i ] <NEWLINE> print ( popcount ( mod_sum % m ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> m = n1 <NEWLINE> mod_sum = mod_sum_1 - q_1 [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = n2 <NEWLINE> mod_sum = mod_sum_2 + q_2 [ i ] <NEWLINE> <NL> <DEDENT> print ( popcount ( mod_sum % m ) + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> def gcdtriple ( a , b , c ) : <NEWLINE> <INDENT> return math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> ans += gcdtriple ( a , b , c ) <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> ans += gcdtriple ( a , b , c ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcdtriple ( a , b , c ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sub = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( N ) <NEWLINE> for i in sub : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in a : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> l [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . sort ( ) <NEWLINE> if len ( li ) == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x1 = x <NEWLINE> while x1 in li : <NEWLINE> <INDENT> x1 -= 1 <NEWLINE> <DEDENT> x2 = x <NEWLINE> while x2 in li : <NEWLINE> <INDENT> x2 += 1 <NEWLINE> <DEDENT> if x - x1 > x2 - x : <NEWLINE> <INDENT> print ( x2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x1 ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> straight = min ( K , X // D ) <NEWLINE> K -= straight <NEWLINE> X -= straight * D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - X ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( N [ 0 ] ) <NEWLINE> B = int ( N [ 1 ] ) <NEWLINE> H = int ( N [ 2 ] ) <NEWLINE> M = int ( N [ 3 ] ) <NEWLINE> <NL> naga = ( 30 * H ) + ( M / 2 ) <NEWLINE> mizi = 6 * M <NEWLINE> <NL> if naga < mizi : <NEWLINE> <INDENT> deg = mizi - naga <NEWLINE> <DEDENT> elif naga >= mizi : <NEWLINE> <INDENT> deg = naga - mizi <NEWLINE> <DEDENT> if deg >= 180 : <NEWLINE> <INDENT> deg = 360 - deg <NEWLINE> <NL> <DEDENT> s = ( A ** 2 ) + ( B ** 2 ) - ( 2 * A * B * math . cos ( math . radians ( deg ) ) ) <NEWLINE> <NL> s = s ** ( 1 / 2 ) <NEWLINE> print ( <STRING> . format ( s ) ) <NEWLINE>
import sys <NEWLINE> MAX = 1000000 <NEWLINE> <NL> A = tuple ( range ( 2 , MAX ) ) <NEWLINE> B = tuple ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if ( A [ 0 ] ) ** 2 > MAX : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> B = B + ( A [ 0 ] , ) <NEWLINE> A = tuple ( x for x in A if x % A [ 0 ] != 0 ) <NEWLINE> <DEDENT> B = B + A <NEWLINE> <NL> Lines = sys . stdin . readlines ( ) <NEWLINE> for line in Lines : <NEWLINE> <INDENT> print ( len ( [ x for x in B if x <= int ( line ) ] ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> s_odd = [ ] <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> s_odd . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( s_odd ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> li = [ input ( ) for i in range ( N ) ] <NEWLINE> li2 = set ( li ) <NEWLINE> print <NEWLINE> print ( len ( li2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> array = [ ] <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B ^= As [ i ] <NEWLINE> <DEDENT> ans_array = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans_array . append ( B ^ As [ i ] ) <NEWLINE> <DEDENT> print ( * ans_array ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> max = 10 ** 9 + 7 <NEWLINE> <NL> a_list = [ int ( a ) % max for a in input ( ) . split ( <STRING> ) ] <NEWLINE> a_sum = sum ( a_list ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( 0 , len ( a_list ) - 1 ) : <NEWLINE> <INDENT> a_sum -= a_list [ i ] <NEWLINE> total += a_list [ i ] * a_sum <NEWLINE> <DEDENT> total = total % max <NEWLINE> print ( total ) <NEWLINE>
def dfs ( h ) : <NEWLINE> <INDENT> if h == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dfs ( h // 2 ) * 2 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> H = int ( input ( ) ) <NEWLINE> <NL> print ( dfs ( H ) ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> if ( h == 1 ) & ( w == 1 ) : <NEWLINE> <INDENT> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ 0 ] [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( h == 1 ) & ( w != 1 ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> s [ 0 ] [ j ] = s [ 0 ] [ j ] . replace ( <STRING> , str ( s [ 0 ] [ j + 1 ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> s [ 0 ] [ j ] = s [ 0 ] [ j ] . replace ( <STRING> , str ( s [ 0 ] [ j - 1 ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ 0 ] [ j ] = s [ 0 ] [ j ] . replace ( <STRING> , str ( [ s [ 0 ] [ j - 1 ] , s [ 0 ] [ j + 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif ( h != 1 ) & ( w == 1 ) : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> s [ i ] [ 0 ] = s [ i ] [ 0 ] . replace ( <STRING> , str ( s [ i + 1 ] [ 0 ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> s [ i ] [ 0 ] = s [ i ] [ 0 ] . replace ( <STRING> , str ( s [ i - 1 ] [ 0 ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ 0 ] = s [ i ] [ 0 ] . replace ( <STRING> , str ( [ s [ i - 1 ] [ 0 ] , s [ i + 1 ] [ 0 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j + 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i ] [ j + 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] , s [ i + 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j + 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i ] [ j + 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] , s [ i - 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j + 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j - 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i ] [ j + 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] , s [ i - 1 ] [ j - 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] , s [ i + 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k in s : <NEWLINE> <INDENT> print ( <STRING> . join ( k ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> prod2 = functools . partial ( functools . reduce , operator . mul ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> val = 1 <NEWLINE> if 0 in nums : <NEWLINE> <INDENT> val = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for num in nums : <NEWLINE> <INDENT> val *= num <NEWLINE> <NL> if val > 1e18 : <NEWLINE> <INDENT> val = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( val ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> A [ j + 1 ] = v <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> n = int ( math . sqrt ( N ) ) <NEWLINE> <NL> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> i = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if i <= N : <NEWLINE> <INDENT> if x == y == z : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> elif x == y or y == z : <NEWLINE> <INDENT> ans [ i - 1 ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - 1 ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <DEDENT>
from math import floor <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = B - 1 if B <= N else N <NEWLINE> ans = floor ( ( A * x ) / B ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> left = 7 % K <NEWLINE> right = 1 % K <NEWLINE> next_add = 1 <NEWLINE> if not K % 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return None <NEWLINE> <DEDENT> ans = 1 <NEWLINE> right_set = set ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if not left * right % K : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right_set . add ( right ) <NEWLINE> next_add = next_add * 10 % K <NEWLINE> right = ( right + next_add ) % K <NEWLINE> ans += 1 <NEWLINE> if right in right_set : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if len ( a_L ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 0 , len ( a_L ) - 1 ) : <NEWLINE> <INDENT> if a_L [ i ] > a_L [ i + 1 ] : <NEWLINE> <INDENT> ans += abs ( a_L [ i + 1 ] - a_L [ i ] ) <NEWLINE> a_L [ i + 1 ] = a_L [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if a_L [ - 2 ] > a_L [ - 1 ] : <NEWLINE> <INDENT> ans += abs ( a_L [ - 1 ] - a_L [ - 2 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> dp = [ 0 ] * ( w + 1 ) <NEWLINE> for wi , vi in wv : <NEWLINE> <INDENT> for sum_w in range ( w , wi - 1 , - 1 ) : <NEWLINE> <INDENT> v = dp [ sum_w - wi ] + vi <NEWLINE> if dp [ sum_w ] < v : <NEWLINE> <INDENT> dp [ sum_w ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ w ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> time_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> <NL> drink_num_time = [ ] <NEWLINE> drink_time = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> drink_num_time . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> normal_time = sum ( time_list ) <NEWLINE> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> drink_time . append ( normal_time + drink_num_time [ i ] [ 1 ] - time_list [ ( drink_num_time [ i ] [ 0 ] ) - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( drink_time [ i ] ) <NEWLINE> <DEDENT>
l = input ( ) . split ( ) <NEWLINE> l = [ int ( s ) for s in l ] <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> while ( b != 0 and a != 0 ) : <NEWLINE> <INDENT> if ( a < b ) : <NEWLINE> <INDENT> b = b % a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a % b <NEWLINE> <DEDENT> <DEDENT> if ( a == 0 ) : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = { 1 : 1 } <NEWLINE> c = 1 <NEWLINE> for i in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> c = A [ c ] <NEWLINE> K -= 1 <NEWLINE> if c in T : <NEWLINE> <INDENT> l = list ( T . keys ( ) ) [ T [ c ] - 1 : ] <NEWLINE> print ( l [ K % len ( l ) ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : T [ c ] = i <NEWLINE> <DEDENT> else : print ( A [ c ] ) <NEWLINE>
<NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> cnt = 1 <NEWLINE> flg = 0 <NEWLINE> ans = 0 <NEWLINE> prev = s [ 0 ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if prev == s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( cnt ) <NEWLINE> cnt = 1 <NEWLINE> prev = s [ i ] <NEWLINE> flg = 1 <NEWLINE> <DEDENT> <DEDENT> lst . append ( cnt ) <NEWLINE> if len ( lst ) == 1 : <NEWLINE> <INDENT> ans = len ( s ) * k // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += sum ( list ( map ( lambda x : x // 2 , lst [ 1 : len ( lst ) - 1 ] ) ) ) * k <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if s [ - 1 ] == s [ 0 ] : <NEWLINE> <INDENT> ans += ( lst [ 0 ] + lst [ - 1 ] ) // 2 * ( k - 1 ) <NEWLINE> ans += lst [ 0 ] // 2 + lst [ - 1 ] // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( lst [ 0 ] // 2 + lst [ - 1 ] // 2 ) * k <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> limit = 0 <NEWLINE> if n >= b - 1 : <NEWLINE> <INDENT> limit = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> limit = n <NEWLINE> <NL> <DEDENT> floor_sub = int ( limit * a / b ) - int ( limit / b ) * a <NEWLINE> print ( floor_sub ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
o , p , q , r = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( format ( ( ( q - o ) ** 2 + ( r - p ) ** 2 ) ** ( 1 / 2 ) , <STRING> ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t_zero = [ - 1 ] * N <NEWLINE> <NL> t = 0 <NEWLINE> a = 1 <NEWLINE> <NL> while t_zero [ a - 1 ] == - 1 : <NEWLINE> <INDENT> if t == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t_zero [ a - 1 ] = t <NEWLINE> t += 1 <NEWLINE> a = A [ a - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( K - t_zero [ a - 1 ] ) % ( t - t_zero [ a - 1 ] ) <NEWLINE> a = t_zero . index ( t_zero [ a - 1 ] + k ) + 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> target = [ ] <NEWLINE> Height = [ 0 ] * H <NEWLINE> Width = [ 0 ] * W <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> target . append ( ( h , w ) ) <NEWLINE> Height [ h ] += 1 <NEWLINE> Width [ w ] += 1 <NEWLINE> <DEDENT> max_H , max_W = max ( Height ) , max ( Width ) <NEWLINE> <NL> cH , cW = 0 , 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if Height [ i ] == max_H : <NEWLINE> <INDENT> cH += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> if Width [ i ] == max_W : <NEWLINE> <INDENT> cW += 1 <NEWLINE> <DEDENT> <DEDENT> max_cross = cH * cW <NEWLINE> <NL> double_count = 0 <NEWLINE> for h , w in target : <NEWLINE> <INDENT> if Height [ h ] == max_H and Width [ w ] == max_W : <NEWLINE> <INDENT> double_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if double_count == max_cross : <NEWLINE> <INDENT> print ( max_H + max_W - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_H + max_W ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out = 1 <NEWLINE> for n in A : <NEWLINE> <INDENT> out = n * out <NEWLINE> if out > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if out > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( out ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def is_ok ( arg ) : <NEWLINE> <INDENT> return not Alist [ arg ] <= t <NEWLINE> <NL> <NL> <DEDENT> def bisect ( ok , ng ) : <NEWLINE> <INDENT> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Alist = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Alist . append ( Alist [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if Alist [ i ] <= K : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> b = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b += B [ i ] <NEWLINE> t = K - b <NEWLINE> <NL> if t >= 0 : <NEWLINE> <INDENT> res = bisect ( N + 1 , - 1 ) <NEWLINE> ans = max ( ans , i + res ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> p_map = { } <NEWLINE> n_map = { } <NEWLINE> <NL> p_zero_map = 0 <NEWLINE> n_zero_map = 0 <NEWLINE> z_map = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ab = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab_gcd = gcd ( ab [ 0 ] , ab [ 1 ] ) <NEWLINE> if ab_gcd == 0 : <NEWLINE> <INDENT> ab_gcd = 1 <NEWLINE> <DEDENT> a = ab [ 0 ] // ab_gcd <NEWLINE> b = ab [ 1 ] // ab_gcd <NEWLINE> <NL> if ( a > 0 and b > 0 ) or ( a < 0 and b < 0 ) : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> key = <STRING> . format ( a , b ) <NEWLINE> if key not in p_map : <NEWLINE> <INDENT> p_map [ key ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_map [ key ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif a == 0 and b == 0 : <NEWLINE> <INDENT> z_map += 1 <NEWLINE> <DEDENT> elif a == 0 and b != 0 : <NEWLINE> <INDENT> n_zero_map += 1 <NEWLINE> <DEDENT> elif b == 0 and a != 0 : <NEWLINE> <INDENT> p_zero_map += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> key = <STRING> . format ( a , b ) <NEWLINE> if key not in n_map : <NEWLINE> <INDENT> n_map [ key ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_map [ key ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for k , v in p_map . items ( ) : <NEWLINE> <INDENT> a = int ( k . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( k . split ( <STRING> ) [ 1 ] ) <NEWLINE> n_num = 0 <NEWLINE> key_a = <STRING> . format ( - b , a ) <NEWLINE> if key_a in n_map : <NEWLINE> <INDENT> n_num += n_map . pop ( key_a ) <NEWLINE> <DEDENT> res = 0 <NEWLINE> res += pow ( 2 , v , MOD ) - 1 <NEWLINE> if n_num > 0 : <NEWLINE> <INDENT> res += pow ( 2 , n_num , MOD ) - 1 <NEWLINE> <DEDENT> res += 1 <NEWLINE> ans *= res <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> n_num = sum ( n_map . values ( ) ) <NEWLINE> if n_num > 0 : <NEWLINE> <INDENT> ans *= pow ( 2 , n_num , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> if p_zero_map > 0 and n_zero_map > 0 : <NEWLINE> <INDENT> res = pow ( 2 , p_zero_map , MOD ) - 1 + pow ( 2 , n_zero_map , MOD ) - 1 <NEWLINE> res += 1 <NEWLINE> res %= MOD <NEWLINE> <DEDENT> elif p_zero_map > 0 and n_zero_map == 0 : <NEWLINE> <INDENT> res = pow ( 2 , p_zero_map , MOD ) <NEWLINE> <DEDENT> elif p_zero_map == 0 and n_zero_map > 0 : <NEWLINE> <INDENT> res = pow ( 2 , n_zero_map , MOD ) <NEWLINE> <DEDENT> if res > 0 : <NEWLINE> <INDENT> ans *= res <NEWLINE> ans %= MOD <NEWLINE> <NL> <NL> <DEDENT> if z_map > 0 : <NEWLINE> <INDENT> ans += z_map <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if any ( i % 2 == 0 for i in [ A , B , C ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( A * B , B * C , C * A ) ) <NEWLINE> <DEDENT>
N , M , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> li = [ 1 ] * 11 <NEWLINE> ans = 0 <NEWLINE> <NL> def countup ( l , n , m ) : <NEWLINE> <INDENT> l [ n ] += 1 <NEWLINE> if l [ n ] > m : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> countup ( l , n - 1 , m ) <NEWLINE> l [ n ] = l [ n - 1 ] <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> while ( li [ 0 ] == 1 ) : <NEWLINE> <INDENT> pt = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if ( li [ b [ i ] ] - li [ a [ i ] ] == c [ i ] ) : <NEWLINE> <INDENT> pt += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , pt ) <NEWLINE> countup ( li , N , M ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <COMMENT> <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> <NL> <COMMENT> <NL> pre = [ 0 ] * n <NEWLINE> pre [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : pre [ i ] = pre [ i - 1 ] + a [ i ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : ans = ( ans + ( a [ i - 1 ] * ( pre [ n - 1 ] - pre [ i - 1 ] ) ) % mod ) % mod <NEWLINE> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <NEWLINE> L = [ ] <NEWLINE> S = set ( ) <NEWLINE> i = 1 <NEWLINE> cnt = 0 <NEWLINE> while ( not i in S ) and cnt != K : <NEWLINE> <INDENT> S . add ( i ) <NEWLINE> L . append ( i ) <NEWLINE> cnt += 1 <NEWLINE> i = A [ i ] <NEWLINE> <NL> <DEDENT> if cnt == K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = L . index ( i ) <NEWLINE> ans = L [ ( j + ( K - j ) % ( cnt - j ) ) % cnt ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ input ( ) for _ in range ( n ) ] <NEWLINE> if ( a == 0 and b == 0 ) or ( a == 0 and c == 0 ) or ( b == 0 and c == 0 ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif arr [ i ] == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a < c : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a == c : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif arr [ i ] == <STRING> : <NEWLINE> <INDENT> if b == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif b < c : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif b == c : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] == <STRING> : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif arr [ i ] == <STRING> : <NEWLINE> <INDENT> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a < c : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a == c : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif arr [ i ] == <STRING> : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif b < c : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif b == c : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif arr [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) [ : : - 1 ] <NEWLINE> L = len ( S ) <NEWLINE> dp = [ 0 ] * 2019 <NEWLINE> wk = 0 <NEWLINE> r = 1 <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> wk += int ( S [ i ] ) * r <NEWLINE> wk %= 2019 <NEWLINE> r *= 10 <NEWLINE> r %= 2019 <NEWLINE> dp [ wk ] += 1 <NEWLINE> <DEDENT> ret = dp [ 0 ] <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ret += dp [ i ] * ( dp [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> turn = 0 <NEWLINE> while ( turn : = turn + 1 ) and ( ( C : = C - B ) if turn & 1 else ( A : = A - D ) ) > 0 : pass <NEWLINE> print ( <STRING> if turn & 1 else <STRING> ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_cnt = 0 <NEWLINE> <NL> c = collections . Counter ( a_list ) <NEWLINE> <NL> for i in range ( max ( c . keys ( ) ) + 1 ) : <NEWLINE> <INDENT> cnt = c [ i ] + c [ i + 1 ] + c [ i + 2 ] <NEWLINE> <NL> if max_cnt < cnt : <NEWLINE> <INDENT> max_cnt = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_cnt ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> uf . find ( i ) <NEWLINE> <NL> <DEDENT> c = Counter ( uf . par ) <NEWLINE> print ( max ( c . values ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> mx = 10 ** 18 <NEWLINE> for i in li : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > mx : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in li : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> LIMIT = 10 ** 18 <NEWLINE> <NL> zeroflg = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> zeroflg = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if zeroflg == 1 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> res = 0 <NEWLINE> break <NEWLINE> <DEDENT> if res > LIMIT : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> res = res * a <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if res > LIMIT : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> print ( len ( set ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> total = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> total -= A [ i ] <NEWLINE> ans += ( A [ i ] * total ) <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> All = Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( All [ i ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
numlist = [ eval ( item ) for item in input ( ) . split ( ) ] <NEWLINE> numlist . sort ( ) <NEWLINE> numlist . reverse ( ) <NEWLINE> for i in range ( len ( numlist ) ) : <NEWLINE> <INDENT> print ( numlist [ i ] , end = <STRING> ) <NEWLINE> if i != len ( numlist ) - 1 : <NEWLINE> <INDENT> print ( end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> D = [ 0 ] * ( N + 1 ) <NEWLINE> D [ 1 ] = 1 <NEWLINE> <NL> S = dict ( ) <NEWLINE> B = dict ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> S [ i ] = ( L , R ) <NEWLINE> B [ i ] = 0 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> L , R = S [ j ] [ 0 ] , S [ j ] [ 1 ] <NEWLINE> if i - L > 0 : B [ j ] += D [ i - L ] <NEWLINE> if i - R - 1 > 0 : B [ j ] -= D [ i - R - 1 ] <NEWLINE> <NL> D [ i ] += B [ j ] <NEWLINE> <NL> <DEDENT> D [ i ] %= 998244353 <NEWLINE> <NL> <DEDENT> print ( D [ N ] ) <NEWLINE>
from math import sqrt <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = defaultdict ( int ) <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a [ 2 ] += 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a [ f ] += 1 <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a [ n ] += 1 <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ps = prime_factorize ( N ) <NEWLINE> <NL> def func2 ( k ) : <NEWLINE> <INDENT> n = 1 <NEWLINE> count = 1 <NEWLINE> while count * ( count + 1 ) // 2 <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> return count - 1 <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> <NL> for value in ps . values ( ) : <NEWLINE> <INDENT> if value > 0 : <NEWLINE> <INDENT> res += func2 ( value ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from itertools import product <NEWLINE> coins = [ 10 , 50 , 100 , 500 ] <NEWLINE> <NL> def coin_count ( num ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for coin in sorted ( coins , reverse = True ) : <NEWLINE> <INDENT> count += num // coin <NEWLINE> num -= ( num // coin ) * coin <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> while True : <NEWLINE> <INDENT> price = int ( input ( ) ) <NEWLINE> if price == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) <NEWLINE> <NL> <DEDENT> has = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_coins = list ( map ( lambda x : x [ 0 ] * x [ 1 ] , zip ( has , coins ) ) ) <NEWLINE> <NL> <NL> change = ( sum ( sum_coins ) - price ) <NEWLINE> surplus = [ change % 50 // 10 , change % 100 // 50 , change % 500 // 100 , change // 500 ] <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> if has [ i ] > surplus [ i ] : <NEWLINE> <INDENT> print ( coins [ i ] , has [ i ] - surplus [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 100000000000000000000000000000000000000 <NEWLINE> for c in range ( 0 , 100001 ) : <NEWLINE> <INDENT> price = A * max ( 0 , X - c ) + B * max ( 0 , Y - c ) + C * 2 * c <NEWLINE> if price < ans : <NEWLINE> <INDENT> ans = price <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> p = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> s = list ( set ( a ) ) <NEWLINE> for x in s : <NEWLINE> <INDENT> t = x * 2 <NEWLINE> while t <= 10 ** 6 : <NEWLINE> <INDENT> p [ t ] = False <NEWLINE> t += x <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if c [ x ] == 1 and p [ x ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a_sum = 0 <NEWLINE> <NL> A_l = [ i for i in A_l if i != 0 ] <NEWLINE> <NL> sum_l = [ 0 ] * len ( A_l ) <NEWLINE> for i in range ( len ( A_l ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> sum_l [ i ] = A_l [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_l [ i ] = sum_l [ i - 1 ] + A_l [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( A_l ) - 1 ) : <NEWLINE> <INDENT> a_sum = a_sum + sum_l [ i ] * A_l [ i + 1 ] <NEWLINE> <DEDENT> print ( a_sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min_i = 1 <NEWLINE> max_i = n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> min_i = max ( min_i , l ) <NEWLINE> max_i = min ( max_i , r ) <NEWLINE> <NL> <DEDENT> if max_i - min_i >= 0 : <NEWLINE> <INDENT> print ( max_i - min_i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total += L [ i ] <NEWLINE> if total <= X : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
H , W , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ None ] * H <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> c [ i ] = list ( input ( ) ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> <NL> for h in range ( 2 ** H ) : <NEWLINE> <INDENT> for w in range ( 2 ** W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( ( h >> i ) & 1 ) == 0 and ( ( w >> j ) & 1 ) == 0 and c [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
numbers = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> numbers . append ( x ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( numbers ) ) : <NEWLINE> <INDENT> print ( <STRING> , i + 1 , <STRING> , numbers [ i ] , sep = <STRING> ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> curr = [ <STRING> , <STRING> ] <NEWLINE> idx = 0 <NEWLINE> cnt = 0 <NEWLINE> E = [ ] <NEWLINE> for i , ch in enumerate ( S ) : <NEWLINE> <INDENT> if ch != curr [ idx ] : <NEWLINE> <INDENT> E . append ( ( idx , cnt ) ) <NEWLINE> cnt = 1 <NEWLINE> idx = 1 - idx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> E . append ( ( idx , cnt ) ) <NEWLINE> <COMMENT> <NL> <NL> ans = [ ] <NEWLINE> for i in range ( 0 , len ( E ) , 2 ) : <NEWLINE> <INDENT> Rcnt = E [ i ] [ 1 ] <NEWLINE> Lcnt = E [ i + 1 ] [ 1 ] <NEWLINE> Rfill = Lfill = ( Rcnt + Lcnt ) // 2 <NEWLINE> <NL> if ( Rcnt + Lcnt ) % 2 == 1 : <NEWLINE> <INDENT> if Rcnt % 2 == 1 : <NEWLINE> <INDENT> Rfill += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Lfill += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Rcnt - 1 ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <NL> <DEDENT> ans . append ( Rfill ) <NEWLINE> ans . append ( Lfill ) <NEWLINE> <NL> for i in range ( Lcnt - 1 ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = np . zeros ( N + 1 , dtype = <STRING> ) <COMMENT> <NEWLINE> D = { 0 : 1 } <COMMENT> <NEWLINE> for i in range ( 1 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> S [ i ] = S [ i - 1 ] + A [ i - 1 ] <NEWLINE> if S [ i ] in D : D [ S [ i ] ] += 1 <NEWLINE> else : D [ S [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in D : <NEWLINE> <INDENT> ans += int ( D [ i ] * ( D [ i ] - 1 ) / 2 ) <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for i in range ( q ) ) <NEWLINE> add = [ 0 ] * n <NEWLINE> def func ( x ) : <NEWLINE> <INDENT> return k - q + x <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> add [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> point = list ( map ( func , add ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if point [ _ ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> if l [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> fruit_prices = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> fruit_prices . sort ( ) <NEWLINE> <NL> min_price = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> min_price += fruit_prices [ i ] <NEWLINE> <NL> <DEDENT> print ( min_price ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = str ( input ( ) ) <NEWLINE> list = a . split ( ) <NEWLINE> for i in list [ n : 0 : - 1 ] : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> print ( list [ 0 ] ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> F = 11 <NEWLINE> <NL> for i in range ( 1 , int ( ( N + 1 ) ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> F = min ( F , max ( len ( str ( i ) ) , len ( str ( int ( N / i ) ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( F ) <NEWLINE>
S = input ( ) <NEWLINE> i = 0 <NEWLINE> result = [ ] <NEWLINE> for a in S : <NEWLINE> <INDENT> if a == <STRING> or a == <STRING> or a == <STRING> or a == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> i = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> result . append ( i ) <NEWLINE> result . sort ( ) <NEWLINE> print ( result [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> print ( ( a * n ) // b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> num = n // b <NEWLINE> <NL> ans = ( a * ( b - 1 ) ) // b <NEWLINE> print ( max ( ans , ( a * n ) // b - a * ( n // b ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p + a <NEWLINE> k = k - a <NEWLINE> <NL> <DEDENT> if b >= k : <NEWLINE> <INDENT> print ( p ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - b <NEWLINE> <NL> <DEDENT> if c >= k : <NEWLINE> <INDENT> print ( p - k ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p - c <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ [ - 1 for _ in range ( n ) ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> li [ i ] [ x - 1 ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> t = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> t [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> is_contradict = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if t [ j ] : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if li [ j ] [ k ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if li [ j ] [ k ] != t [ k ] : <NEWLINE> <INDENT> is_contradict = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if not is_contradict : <NEWLINE> <INDENT> ans = max ( ans , sum ( t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cnt = N - 1 <NEWLINE> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> cnt = min ( cnt , N // i + i - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( [ a * c , b * c , a * d , b * d ] ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> SENTINEL = 1e9 + 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> dp = [ SENTINEL ] * n <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dp [ bisect_left ( dp , a ) ] = a <NEWLINE> <NL> <DEDENT> print ( bisect_left ( dp , SENTINEL ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ x for x in range ( 1 , N + 1 ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ j ] in l : <NEWLINE> <INDENT> l . remove ( A [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> bi , ci = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B . append ( bi ) <NEWLINE> C . append ( ci ) <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> for i in A : <NEWLINE> <INDENT> dic [ i ] = dic . get ( i , 0 ) + 1 <NEWLINE> <NL> <DEDENT> sum = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> sum += dic . get ( B [ i ] , 0 ) * ( C [ i ] - B [ i ] ) <NEWLINE> dic [ C [ i ] ] = dic . get ( C [ i ] , 0 ) + dic . get ( B [ i ] , 0 ) <NEWLINE> dic [ B [ i ] ] = dic . get ( B [ i ] , 0 ) <NEWLINE> dic [ B [ i ] ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> if s . count ( <STRING> ) == 0 or s . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> clen , flen = 0 , 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if clen == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> clen = i <NEWLINE> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> flen = i <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if flen > clen else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for i in range ( 150 , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i , - 150 , - 1 ) : <NEWLINE> <INDENT> cal = i ** 5 - j ** 5 <NEWLINE> if cal == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> INF = 1e12 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lA = Counter ( A ) <NEWLINE> lB = Counter ( B ) <NEWLINE> if max ( Counter ( A + B ) . values ( ) ) > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> C = [ 0 ] * ( N + 1 ) <NEWLINE> D = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C [ i + 1 ] = lA [ i + 1 ] + C [ i ] <NEWLINE> D [ i + 1 ] = lB [ i + 1 ] + D [ i ] <NEWLINE> <DEDENT> shift = - INF <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> shift = max ( shift , C [ i ] - D [ i - 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> ans = ( B + B + B ) [ N - shift : 2 * N - shift ] <NEWLINE> print ( <STRING> . join ( [ str ( a ) for a in ans ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> l = len ( n ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> n [ i ] = int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> score = 0 <NEWLINE> <NL> if l == 1 : <NEWLINE> <INDENT> print ( n [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n . count ( 9 ) == l : <NEWLINE> <INDENT> score = sum ( n ) <NEWLINE> <DEDENT> elif n . count ( 9 ) == l - 1 : <NEWLINE> <INDENT> if n [ 0 ] != 9 : <NEWLINE> <INDENT> score += sum ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score += 8 + 9 * ( l - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n [ 0 ] != 9 : <NEWLINE> <INDENT> score += n [ 0 ] - 1 + 9 * ( l - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> if n [ j ] != 9 : <NEWLINE> <INDENT> n [ j - 1 ] = 8 <NEWLINE> score += 8 + 9 * ( l - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( score ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans_list = [ ] <NEWLINE> def dfs ( A ) : <NEWLINE> <INDENT> if len ( A ) != 0 and int ( <STRING> . join ( A ) ) <= 10 ** 10 : <NEWLINE> <INDENT> ans_list . append ( int ( <STRING> . join ( A ) ) ) <NEWLINE> <DEDENT> elif len ( A ) != 0 and int ( <STRING> . join ( A ) ) > 10 ** 10 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if len ( A ) == 0 : <NEWLINE> <INDENT> for i in range ( 1 , 10 , 1 ) : <NEWLINE> <INDENT> A . append ( str ( i ) ) <NEWLINE> dfs ( A ) <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( 0 , 10 , 1 ) : <NEWLINE> <INDENT> if abs ( int ( A [ - 1 ] ) - i ) <= 1 : <NEWLINE> <INDENT> A . append ( str ( i ) ) <NEWLINE> dfs ( A ) <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT> dfs ( [ ] ) <NEWLINE> ans_list . sort ( ) <NEWLINE> print ( ans_list [ K - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10500 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if v < 10500 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
mod = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( k ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> lr [ i ] [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> if i == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> for l , r in lr : <NEWLINE> <INDENT> if i - l >= 0 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - l ] <NEWLINE> <DEDENT> if i - r >= 0 : <NEWLINE> <INDENT> dp [ i ] -= dp [ i - r ] <NEWLINE> <DEDENT> dp [ i ] %= mod <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( len ( max ( s . split ( <STRING> ) ) ) ) <NEWLINE>
import sys <NEWLINE> si = sys . stdin . readline <NEWLINE> so = sys . stdout . write <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( si ( ) ) <NEWLINE> s = si ( ) [ : - 1 ] <NEWLINE> cnt = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
DP = { } <NEWLINE> <NL> def solve ( n , a , b , c , d ) : <NEWLINE> <INDENT> if n <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> if n in DP : <NEWLINE> <INDENT> return DP [ n ] <NEWLINE> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( - 3 , 4 ) : <NEWLINE> <INDENT> num = n + i <NEWLINE> trash = abs ( i ) * d <NEWLINE> if num < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num % 5 == 0 and num // 5 < n : <NEWLINE> <INDENT> ans = min ( ans , solve ( num // 5 , a , b , c , d ) + min ( c , d * ( num - ( num // 5 ) ) ) + trash ) <NEWLINE> <DEDENT> if num % 3 == 0 and num // 3 < n : <NEWLINE> <INDENT> ans = min ( ans , solve ( num // 3 , a , b , c , d ) + min ( b , d * ( num - ( num // 3 ) ) ) + trash ) <NEWLINE> <DEDENT> if num % 2 == 0 and num // 2 < n : <NEWLINE> <INDENT> ans = min ( ans , solve ( num // 2 , a , b , c , d ) + min ( a , d * ( num - ( num // 2 ) ) ) + trash ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> DP [ n ] = int ( ans ) <NEWLINE> <NL> return int ( ans ) <NEWLINE> <NL> <DEDENT> def solve2 ( ) : <NEWLINE> <INDENT> DP . clear ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( solve ( n , a , b , c , d ) ) <NEWLINE> <NL> <DEDENT> t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> solve2 ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> A , B , N = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> L = max ( [ 1 , min ( [ B - 1 , N ] ) ] ) <NEWLINE> print ( ( A * L ) // B ) if B != 1 else print ( 0 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : main ( ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 100000000 <NEWLINE> <NL> to = [ [ ] for _ in range ( 100005 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> q = deque ( [ ] ) <NEWLINE> dist = [ INF ] * n <NEWLINE> pre = [ - 1 ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> <NL> while len ( q ) > 0 : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for i in to [ v ] : <NEWLINE> <INDENT> if dist [ i ] != INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] = dist [ v ] + 1 <NEWLINE> pre [ i ] = v <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = pre [ i ] <NEWLINE> ans += 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ij_gcd = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( ij_gcd , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> <NL> def dijkstra ( n ) : <NEWLINE> <INDENT> inf = 10 ** 6 + 1 <NEWLINE> dist = [ 0 ] + [ inf ] * ( n - 1 ) <NEWLINE> q = [ ( 0 , 0 ) ] <NEWLINE> while q : <NEWLINE> <INDENT> u = heapq . heappop ( q ) [ 1 ] <NEWLINE> for ( v , c ) in edge [ u ] : <NEWLINE> <INDENT> alt = dist [ u ] + c <NEWLINE> if dist [ v ] > alt : <NEWLINE> <INDENT> dist [ v ] = alt <NEWLINE> heapq . heappush ( q , ( alt , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> edge = [ [ ] ] * n <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge [ l [ 0 ] ] = ( e for e in zip ( l [ 2 : : 2 ] , l [ 3 : : 2 ] ) ) <NEWLINE> <DEDENT> for i , c in enumerate ( dijkstra ( n ) ) : <NEWLINE> <INDENT> print ( i , c ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> max_count = 0 <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> s_ = s [ i : i + len ( t ) + 1 ] <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s_ [ j ] == t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> max_count = max ( max_count , count ) <NEWLINE> <NL> <DEDENT> print ( len ( t ) - max_count ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> H = [ 0 ] * ( 5 * ( 10 ** 5 ) ) <NEWLINE> L = [ 0 ] * ( 5 * ( 10 ** 5 ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] <= 2 * ( 10 ** 5 ) : <NEWLINE> <INDENT> H [ A [ i ] + i ] += 1 <NEWLINE> <DEDENT> if i - A [ i ] >= 0 : <NEWLINE> <INDENT> L [ i - A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 5 * ( 10 ** 5 ) ) : <NEWLINE> <INDENT> ans += H [ i ] * L [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> ans = int ( x ) + int ( y ) <NEWLINE> if len ( x ) > 80 or len ( y ) > 80 or len ( str ( ans ) ) > 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> N , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> AB = [ tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for ab in AB : <NEWLINE> <INDENT> edge [ ab [ 0 ] - 1 ] += [ ab [ 1 ] - 1 ] <NEWLINE> edge [ ab [ 1 ] - 1 ] += [ ab [ 0 ] - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> L = [ - 1 for i in range ( N ) ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def bfs ( p ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> queue = deque ( [ p ] ) <NEWLINE> L [ p ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> p = queue . popleft ( ) <NEWLINE> for c in edge [ p ] : <NEWLINE> <INDENT> if L [ c ] == - 1 : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> L [ c ] = p + 1 <COMMENT> <NEWLINE> <COMMENT> <NL> queue . append ( c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in L [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> print ( s // 3600 , <STRING> , ( s % 3600 ) // 60 , <STRING> , s % 60 , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> li = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += li [ i - 1 ] <NEWLINE> li . append ( A [ i ] ) <NEWLINE> li . append ( A [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 < a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a <= b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a <= 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list . append ( input ( ) ) <NEWLINE> <DEDENT> a = Counter ( list ) <NEWLINE> print ( len ( a ) ) <NEWLINE>
N , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> cost [ i ] = min ( [ cost [ j ] + abs ( l [ i ] - l [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ] ) <NEWLINE> <DEDENT> print ( cost [ N - 1 ] ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> <NL> heap = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> input_line = sys . stdin . readline ( ) <NEWLINE> input_line = input_line . strip ( ) . split ( <STRING> ) <NEWLINE> if input_line [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( heap , - int ( input_line [ 1 ] ) ) <NEWLINE> <DEDENT> elif input_line [ 0 ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - int ( heapq . heappop ( heap ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> <NL> k_ = min ( k , x // d ) <NEWLINE> k = k - k_ <NEWLINE> x = x - k_ * d <NEWLINE> <NL> if k % 2 != 0 : <NEWLINE> <INDENT> x = abs ( x - d ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> if 1 <= x <= 179 : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if 360 * i % x == 0 : <NEWLINE> <INDENT> print ( int ( 360 * i / x ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
def check ( x , y ) : <NEWLINE> <INDENT> return 0 <= x <= 9 and 0 <= y <= 9 <NEWLINE> <NL> <NL> <DEDENT> def small ( x , y , area ) : <NEWLINE> <INDENT> if check ( x + 1 , y ) : <NEWLINE> <INDENT> area [ x + 1 ] [ y ] += 1 <NEWLINE> <DEDENT> if check ( x , y + 1 ) : <NEWLINE> <INDENT> area [ x ] [ y + 1 ] += 1 <NEWLINE> <DEDENT> if check ( x - 1 , y ) : <NEWLINE> <INDENT> area [ x - 1 ] [ y ] += 1 <NEWLINE> <DEDENT> if check ( x , y - 1 ) : <NEWLINE> <INDENT> area [ x ] [ y - 1 ] += 1 <NEWLINE> <DEDENT> area [ x ] [ y ] += 1 <NEWLINE> return area <NEWLINE> <NL> <NL> <DEDENT> def mediam ( x , y , area ) : <NEWLINE> <INDENT> area = small ( x , y , area ) <NEWLINE> if check ( x + 1 , y + 1 ) : <NEWLINE> <INDENT> area [ x + 1 ] [ y + 1 ] += 1 <NEWLINE> <DEDENT> if check ( x + 1 , y - 1 ) : <NEWLINE> <INDENT> area [ x + 1 ] [ y - 1 ] += 1 <NEWLINE> <DEDENT> if check ( x - 1 , y + 1 ) : <NEWLINE> <INDENT> area [ x - 1 ] [ y + 1 ] += 1 <NEWLINE> <DEDENT> if check ( x - 1 , y - 1 ) : <NEWLINE> <INDENT> area [ x - 1 ] [ y - 1 ] += 1 <NEWLINE> <DEDENT> return area <NEWLINE> <NL> <NL> <DEDENT> def large ( x , y , area ) : <NEWLINE> <INDENT> area = mediam ( x , y , area ) <NEWLINE> if check ( x + 2 , y ) : <NEWLINE> <INDENT> area [ x + 2 ] [ y ] += 1 <NEWLINE> <DEDENT> if check ( x , y + 2 ) : <NEWLINE> <INDENT> area [ x ] [ y + 2 ] += 1 <NEWLINE> <DEDENT> if check ( x - 2 , y ) : <NEWLINE> <INDENT> area [ x - 2 ] [ y ] += 1 <NEWLINE> <DEDENT> if check ( x , y - 2 ) : <NEWLINE> <INDENT> area [ x ] [ y - 2 ] += 1 <NEWLINE> <DEDENT> return area <NEWLINE> <NL> <DEDENT> area = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if s == 1 : <NEWLINE> <INDENT> area = small ( x , y , area ) <NEWLINE> <DEDENT> if s == 2 : <NEWLINE> <INDENT> area = mediam ( x , y , area ) <NEWLINE> <DEDENT> if s == 3 : <NEWLINE> <INDENT> area = large ( x , y , area ) <NEWLINE> <NL> <DEDENT> <DEDENT> max = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> if area [ i ] [ j ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if area [ i ] [ j ] > max : <NEWLINE> <INDENT> max = area [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> print ( max ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> ls = len ( S ) <NEWLINE> lt = len ( T ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> loc = None <NEWLINE> for i in range ( ls - lt , - 1 , - 1 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> if not ( S [ i + j ] == T [ j ] or S [ i + j ] == <STRING> ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> loc = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if loc == None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i < ls : <NEWLINE> <INDENT> if i == loc : <NEWLINE> <INDENT> ans += T <NEWLINE> i += lt <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += S [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a = input ( ) . split ( ) <NEWLINE> <NL> pura = int ( a [ 0 ] ) <COMMENT> <NEWLINE> zero = int ( a [ 1 ] ) <COMMENT> <NEWLINE> mai = int ( a [ 2 ] ) <COMMENT> <NEWLINE> num = int ( a [ 3 ] ) <COMMENT> <NEWLINE> total = 0 <NEWLINE> k = num - pura - zero <NEWLINE> <NL> if pura >= num : <NEWLINE> <INDENT> total = num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = pura <NEWLINE> if zero >= num - pura : <NEWLINE> <INDENT> total = pura <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = pura - ( k ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> one = ord ( <STRING> ) <NEWLINE> two = ord ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> S = in_ . readline ( ) . strip ( ) <NEWLINE> q = collections . deque ( S ) <NEWLINE> <COMMENT> <NL> <NL> reverse_flag = False <NEWLINE> Q = int ( in_ . readline ( ) ) <NEWLINE> for query in itertools . islice ( in_ , Q ) : <NEWLINE> <INDENT> T = query [ 0 ] <NEWLINE> if T == one : <NEWLINE> <INDENT> reverse_flag ^= True <NEWLINE> <COMMENT> <NL> <DEDENT> elif T == two : <NEWLINE> <INDENT> F = query [ 2 ] <NEWLINE> C = query [ 4 ] <NEWLINE> if ( F == one ) ^ reverse_flag : <NEWLINE> <INDENT> q . appendleft ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( C ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if reverse_flag : <NEWLINE> <INDENT> q . reverse ( ) <NEWLINE> reverse_flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> return bytes ( q ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer . decode ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> S = r ** 2 * math . pi <NEWLINE> R = 2 * r * math . pi <NEWLINE> print ( <STRING> . format ( S ) + <STRING> + <STRING> . format ( R ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> result = sum ( list ( map ( int , str ( N ) ) ) ) <NEWLINE> if ( result % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> def expo ( x ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in reversed ( range ( 1 , x + 1 ) ) : <NEWLINE> <INDENT> for j in range ( int ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 2 , int ( math . sqrt ( x ) ) ) : <NEWLINE> <INDENT> if i == j ** k : <NEWLINE> <INDENT> ans = i <NEWLINE> return ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( expo ( X ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> CounterKey = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> inputCount = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( inputCount ) : <NEWLINE> <INDENT> puzzle = [ ] <NEWLINE> mark = [ ] <NEWLINE> <NL> if _ != 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <NL> <DEDENT> for lp in range ( 9 ) : <NEWLINE> <INDENT> puzzle . append ( [ item for item in input ( ) . split ( <STRING> ) ] ) <NEWLINE> mark . append ( [ item for item in <STRING> * 9 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for rowIndex , row in enumerate ( puzzle ) : <NEWLINE> <INDENT> counter = Counter ( row ) <NEWLINE> needNum = [ num for num in CounterKey if 1 < counter [ num ] ] <NEWLINE> <NL> if not needNum : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for colIndex , item in enumerate ( row ) : <NEWLINE> <INDENT> if item in needNum : <NEWLINE> <INDENT> mark [ rowIndex ] [ colIndex ] = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for colIndex , col in enumerate ( <NEWLINE> <INDENT> zip ( puzzle [ 0 ] , puzzle [ 1 ] , puzzle [ 2 ] , puzzle [ 3 ] , puzzle [ 4 ] , puzzle [ 5 ] , puzzle [ 6 ] , puzzle [ 7 ] , puzzle [ 8 ] ) ) : <NEWLINE> counter = Counter ( col ) <NEWLINE> needNum = [ num for num in CounterKey if 1 < counter [ num ] ] <NEWLINE> <NL> if not needNum : <NEWLINE> continue <NEWLINE> <NL> for rowIndex , item in enumerate ( col ) : <NEWLINE> if item in needNum : <NEWLINE> <INDENT> mark [ rowIndex ] [ colIndex ] = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for lp in range ( 3 ) : <NEWLINE> <INDENT> block = [ ] <NEWLINE> <NL> for blockCount , col in enumerate ( zip ( puzzle [ lp * 3 ] , puzzle [ lp * 3 + 1 ] , puzzle [ lp * 3 + 2 ] ) ) : <NEWLINE> <INDENT> block . extend ( col ) <NEWLINE> <NL> if blockCount % 3 - 2 == 0 : <NEWLINE> <NL> <INDENT> counter = Counter ( block ) <NEWLINE> needNum = [ num for num in CounterKey if 1 < counter [ num ] ] <NEWLINE> <NL> if needNum : <NEWLINE> <NL> <INDENT> for index , item in enumerate ( block ) : <NEWLINE> <INDENT> if item in needNum : <NEWLINE> <INDENT> rowIndex , colIndex = lp * 3 + index % 3 , blockCount - 2 + index // 3 <NEWLINE> mark [ rowIndex ] [ colIndex ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> block = [ ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for p , m in zip ( puzzle , mark ) : <NEWLINE> <INDENT> output = [ ] <NEWLINE> <NL> for num , state in zip ( p , m ) : <NEWLINE> <INDENT> output . append ( state ) <NEWLINE> output . append ( num ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( output ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> from collections import Counter <NEWLINE> def Main ( N , A ) : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> amax = A [ - 1 ] + 1 <NEWLINE> d = { } <NEWLINE> for i in range ( 1 , amax ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> i = 1 <NEWLINE> while a * i < amax : <NEWLINE> <INDENT> d [ a * i ] += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if d [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( Main ( N , A ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys ; from decimal import Decimal <NEWLINE> import math ; from itertools import combinations , product <NEWLINE> import bisect ; from collections import Counter , deque , defaultdict <NEWLINE> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def lcm ( a : int , b : int ) -> int : return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import i8 , njit , u1 , b1 <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> @ njit ( i8 ( b1 [ : , : ] , i8 , i8 , i8 , i8 ) , cache = True ) <NEWLINE> def solve ( grid , ch , cw , dh , dw ) : <NEWLINE> <INDENT> h , w = grid . shape <NEWLINE> <NL> dist = np . full ( ( h , w ) , INF , dtype = np . int64 ) <NEWLINE> dist [ ch ] [ cw ] = 0 <NEWLINE> <NL> que = [ ( 0 , ch , cw ) ] <NEWLINE> <NL> while que : <NEWLINE> <INDENT> cnt , y , x = heappop ( que ) <NEWLINE> <NL> if y == dh and x == dw : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for dy in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for dx in range ( - 2 , 3 ) : <NEWLINE> <INDENT> if dx == 0 and dy == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if abs ( dx ) == 2 or abs ( dy ) == 2 or ( abs ( dx ) == 1 and abs ( dy ) == 1 ) : <NEWLINE> <INDENT> warp = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> warp = 0 <NEWLINE> <NL> <DEDENT> nx , ny = x + dx , y + dy <NEWLINE> if nx < 0 or nx >= w or ny < 0 or ny >= h or grid [ ny ] [ nx ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if dist [ ny ] [ nx ] > cnt + warp : <NEWLINE> <INDENT> dist [ ny ] [ nx ] = cnt + warp <NEWLINE> heappush ( que , ( cnt + warp , ny , nx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if dist [ dh ] [ dw ] == INF : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dist [ dh ] [ dw ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> H , W = read_ints ( ) <NEWLINE> ch , cw = read_ints ( ) ; ch -= 1 ; cw -= 1 <NEWLINE> dh , dw = read_ints ( ) ; dh -= 1 ; dw -= 1 <NEWLINE> <NL> grid = np . array ( [ [ g == <STRING> for g in read_str ( ) ] for _ in range ( H ) ] ) <NEWLINE> <NL> print ( solve ( grid , ch , cw , dh , dw ) ) <NEWLINE> <NL> <DEDENT> def cc_export ( config ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> result = [ 0 ] * N <NEWLINE> x = 0 <NEWLINE> for key , i in enumerate ( A ) : <NEWLINE> <INDENT> if key % 2 == 0 : <NEWLINE> <INDENT> x += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= i <NEWLINE> <NL> <DEDENT> <DEDENT> result [ 0 ] = x <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> result [ i ] = 2 * A [ i - 1 ] - result [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( [ str ( x ) for x in result ] ) ) <NEWLINE>
class Union : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . root ( self . parents [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> uni = Union ( n ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uni . unite ( a , b ) <NEWLINE> <DEDENT> print ( - min ( uni . parents ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> o = n // 5 <NEWLINE> if n > 1000 : <NEWLINE> <INDENT> o = n // 100 <NEWLINE> <DEDENT> a = [ 0 ] * n * 2 <NEWLINE> for i in range ( 1 , o ) : <NEWLINE> <INDENT> for j in range ( 1 , o ) : <NEWLINE> <INDENT> for k in range ( 1 , o ) : <NEWLINE> <INDENT> num = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if num > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ num - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n * 2 ) : <NEWLINE> <INDENT> if i >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( a [ i ] ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> g = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for a in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <INDENT> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> g += math . gcd ( math . gcd ( a , b ) , c ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for d in range ( 1 , K ) : <NEWLINE> <INDENT> for e in range ( d + 1 , K + 1 ) : <NEWLINE> <INDENT> g += math . gcd ( d , e ) * 6 <NEWLINE> <DEDENT> <DEDENT> g += K * ( K + 1 ) // 2 <NEWLINE> print ( g ) <NEWLINE>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = np . arange ( N ) + 1 <NEWLINE> <NL> s = A + B <NEWLINE> m = B - A <NEWLINE> <NL> s_ct = Counter ( s ) <NEWLINE> m_ct = Counter ( m ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in s_ct : <NEWLINE> <INDENT> ans += s_ct [ i ] * m_ct [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
<NL> import random <NEWLINE> <NL> <NL> class Node : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . valid = True <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> if self . valid : <NEWLINE> <INDENT> return <STRING> . format ( self . left , self . x , <NEWLINE> <INDENT> self . y , self . right ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> . format ( self . left , self . x , <NEWLINE> <INDENT> self . y , self . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class KdTree : <NEWLINE> <INDENT> MAX = 2 ** 31 - 1 <NEWLINE> <NL> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> self . index = [ None ] * size <NEWLINE> <NL> <DEDENT> def insert ( self , x , y ) : <NEWLINE> <INDENT> self . _delete ( self . index [ x ] ) <NEWLINE> self . root = self . _insert ( self . root , x , y ) <NEWLINE> <NL> <DEDENT> def _insert ( self , node , x , y , level = 0 ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> node = Node ( x , y ) <NEWLINE> self . index [ x ] = node <NEWLINE> return node <NEWLINE> <DEDENT> if level % 2 == 0 : <NEWLINE> <INDENT> if node . x > x : <NEWLINE> <INDENT> node . left = self . _insert ( node . left , x , y , level + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = self . _insert ( node . right , x , y , level + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if node . y > y : <NEWLINE> <INDENT> node . left = self . _insert ( node . left , x , y , level + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = self . _insert ( node . right , x , y , level + 1 ) <NEWLINE> <DEDENT> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def miny ( self , x1 , x2 ) : <NEWLINE> <INDENT> def _miny ( node , y , level ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> left , right = self . MAX , self . MAX <NEWLINE> if level % 2 == 0 : <NEWLINE> <INDENT> if x2 < node . x : <NEWLINE> <INDENT> left = _miny ( node . left , y , level + 1 ) <NEWLINE> <DEDENT> elif x1 > node . x : <NEWLINE> <INDENT> right = _miny ( node . right , y , level + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . _is_valid ( node ) and node . y < y : <NEWLINE> <INDENT> y = node . y <NEWLINE> <DEDENT> left = _miny ( node . left , y , level + 1 ) <NEWLINE> if left < y : <NEWLINE> <INDENT> y = left <NEWLINE> <DEDENT> right = _miny ( node . right , y , level + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if node . y > y : <NEWLINE> <INDENT> left = _miny ( node . left , y , level + 1 ) <NEWLINE> <DEDENT> elif node . y < y : <NEWLINE> <INDENT> if x1 <= node . x <= x2 and self . _is_valid ( node ) : <NEWLINE> <INDENT> left = _miny ( node . left , node . y , level + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = _miny ( node . left , y , level + 1 ) <NEWLINE> if left < y : <NEWLINE> <INDENT> y = left <NEWLINE> <DEDENT> right = _miny ( node . right , y , level + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> left = _miny ( node . left , y , level + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if left < y : <NEWLINE> <INDENT> y = left <NEWLINE> <DEDENT> if right < y : <NEWLINE> <INDENT> y = right <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> assert x1 <= x2 <NEWLINE> return _miny ( self . root , self . MAX , 0 ) <NEWLINE> <NL> <DEDENT> def _delete ( self , node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> node . valid = False <NEWLINE> <NL> <DEDENT> <DEDENT> def _is_valid ( self , node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> return node . valid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n , q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> tree = KdTree ( n ) <NEWLINE> buff = { } <NEWLINE> k = 0 <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> com , u , v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if com == 0 : <NEWLINE> <INDENT> if u not in buff : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> buff [ u ] = v <NEWLINE> <DEDENT> elif com == 1 : <NEWLINE> <INDENT> if k > 0 : <NEWLINE> <INDENT> for x , y in random . sample ( buff . items ( ) , k = k ) : <NEWLINE> <INDENT> tree . insert ( x , y ) <NEWLINE> <DEDENT> buff = { } <NEWLINE> k = 0 <NEWLINE> <DEDENT> print ( tree . miny ( u , v ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( com ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> m = float ( <STRING> ) <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> if abs ( i - x ) < m : <NEWLINE> <INDENT> ans = i <NEWLINE> m = abs ( i - x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> D = collections . Counter ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S += ( C - B ) * D [ B ] <NEWLINE> D [ C ] += D [ B ] <NEWLINE> D [ B ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
class BITmax : <NEWLINE> <INDENT> def __init__ ( self , N , init = 0 ) : <NEWLINE> <INDENT> self . init = init <NEWLINE> self . tree = [ self . init ] * ( N + 1 ) <NEWLINE> <NL> <DEDENT> def set ( self , x , value ) : <NEWLINE> <INDENT> while x < N + 1 : <NEWLINE> <INDENT> old = self . tree [ x ] <NEWLINE> if value <= old : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . tree [ x ] = value <NEWLINE> x += x & - x <NEWLINE> <NL> <DEDENT> <DEDENT> def find_max_to ( self , x ) : <NEWLINE> <INDENT> result = self . init <NEWLINE> while x > 0 : <NEWLINE> <INDENT> result = max ( result , self . tree [ x ] ) <NEWLINE> x -= x & - x <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> dpt = BITmax ( N ) <NEWLINE> <NL> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for h , b in zip ( h_list , b_list ) : <NEWLINE> <INDENT> dpt . set ( h , dpt . find_max_to ( h - 1 ) + b ) <NEWLINE> <NL> <DEDENT> print ( max ( dpt . tree ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> m = 1 <NEWLINE> <DEDENT> t [ i + 1 ] = t [ i ] + m <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> B = [ 0 ] * N <NEWLINE> i = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> sA = sorted ( A ) <NEWLINE> sB = sorted ( B ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> ans = ( ( sB [ ( N // 2 ) - 1 ] + sB [ ( N // 2 ) ] ) - ( sA [ ( N // 2 ) - 1 ] + sA [ ( N // 2 ) ] ) ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( sB [ ( N - 1 ) // 2 ] - sA [ ( N - 1 ) // 2 ] ) + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 0 <NEWLINE> visited = [ 0 ] <NEWLINE> visited_set = set ( [ 0 ] ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> if now in visited_set : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visited . append ( now ) <NEWLINE> visited_set . add ( now ) <NEWLINE> <DEDENT> if len ( visited ) == N : <NEWLINE> <INDENT> print ( visited [ K - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = visited . index ( now ) <NEWLINE> roop = visited [ ind : ] <NEWLINE> print ( roop [ ( K - ind ) % len ( roop ) ] + 1 ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> p = [ 0 ] * ( s + 1 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> p [ 0 ] = 1 <NEWLINE> <NL> if s >= 3 : <NEWLINE> <INDENT> for i in range ( 3 , s + 1 ) : <NEWLINE> <INDENT> p [ i ] = ( sum ( p [ : i - 2 ] ) ) % mod <NEWLINE> <DEDENT> <DEDENT> print ( p [ s ] ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def binary_search ( left , right ) : <NEWLINE> <INDENT> if right - left <= 0.01 : <NEWLINE> <INDENT> return right <NEWLINE> <DEDENT> middle = ( right + left ) / 2 <NEWLINE> if is_can ( middle ) : <NEWLINE> <INDENT> return binary_search ( left , middle ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return binary_search ( middle , right ) <NEWLINE> <DEDENT> <DEDENT> def is_can ( target ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > target : <NEWLINE> <INDENT> count += a [ i ] // target <NEWLINE> <DEDENT> <DEDENT> return count <= k <NEWLINE> <DEDENT> p = binary_search ( 0 , 10 ** 10 ) <NEWLINE> if int ( p ) != 0 and is_can ( int ( p ) ) : <NEWLINE> <INDENT> print ( int ( p ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( p ) + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) - 1 <NEWLINE> ans = ( 1 + n ) * ( n // 2 ) <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> ans += n // 2 + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> S = list ( map ( int , LS ( ) ) ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> ln = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> <NL> times = 1 <NEWLINE> for i in range ( ln ) : <NEWLINE> <INDENT> S [ i ] = S [ i ] * times <NEWLINE> times = times * 10 % mod <NEWLINE> <NL> <DEDENT> R = [ 0 ] * ( ln + 1 ) <NEWLINE> memo = { 0 : 1 } <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , ln + 1 ) : <NEWLINE> <INDENT> tmp = ( R [ i - 1 ] + S [ i - 1 ] ) % mod <NEWLINE> R [ i ] = tmp <NEWLINE> cnt = memo . get ( tmp , 0 ) <NEWLINE> ans = ans + cnt <NEWLINE> memo [ tmp ] = cnt + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def ascend ( a , b ) : <NEWLINE> <INDENT> mini = min ( A [ a : a + L ] ) <NEWLINE> ans [ a ] = mini <NEWLINE> for i in range ( a + 1 , b ) : <NEWLINE> <INDENT> if A [ i + L - 1 ] <= mini : <NEWLINE> <INDENT> mini = A [ i + L - 1 ] <NEWLINE> <DEDENT> elif A [ i - 1 ] == mini : <NEWLINE> <INDENT> mini = min ( A [ i : i + L ] ) <NEWLINE> <DEDENT> ans [ i ] = mini <NEWLINE> <NL> <DEDENT> <DEDENT> def descend ( a , b ) : <NEWLINE> <INDENT> mini = min ( A [ b - 1 : b + L - 1 ] ) <NEWLINE> ans [ b - 1 ] = mini <NEWLINE> for i in range ( b - 2 , a - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] <= mini : <NEWLINE> <INDENT> mini = A [ i ] <NEWLINE> <DEDENT> elif A [ i + L ] == mini : <NEWLINE> <INDENT> mini = min ( A [ i : i + L ] ) <NEWLINE> <DEDENT> ans [ i ] = mini <NEWLINE> <NL> <DEDENT> <DEDENT> [ N , L ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ None ] * ( N - L + 1 ) <NEWLINE> <NL> Pcount = 0 ; <NEWLINE> Mcount = 0 ; <NEWLINE> if N > 10 ** 4 : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> if A [ i + 1 ] > A [ i ] : Pcount += 1 <NEWLINE> if A [ i + 1 ] < A [ i ] : Mcount += 1 <NEWLINE> <DEDENT> if Pcount > 80 : descend ( 0 , N - L + 1 ) <NEWLINE> else : ascend ( 0 , N - L + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ascend ( 0 , N - L + 1 ) <NEWLINE> <DEDENT> for i in ans [ : - 1 ] : print ( i , end = <STRING> ) <NEWLINE> print ( ans [ - 1 ] ) <NEWLINE>
import logging <NEWLINE> <NL> logging . basicConfig ( level = logging . INFO , format = <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA_list = [ list ( map ( int , list ( input ( ) . split ( <STRING> ) ) ) ) for i in range ( N ) ] <NEWLINE> Ci_sum_list = [ ] <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> sum_list = [ 0 for i in range ( M + 1 ) ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> sum_list = [ x + y for ( x , y ) in zip ( sum_list , CA_list [ j ] ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> logging . info ( sum_list ) <NEWLINE> if [ x for x in sum_list [ 1 : ] if x < X ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ci_sum_list . append ( sum_list [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if Ci_sum_list : <NEWLINE> <INDENT> print ( min ( Ci_sum_list ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> li = [ 0 ] * ( N + 1 ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> li [ i ] += 1 <NEWLINE> <DEDENT> for i in li [ 1 : ] : <NEWLINE> <INDENT> total += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> j = li [ i ] <NEWLINE> print ( total - ( j * ( j - 1 ) // 2 ) + ( ( j - 1 ) * ( j - 2 ) // 2 ) ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if ( v == w ) or ( w > v ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if abs ( a - b ) / ( v - w ) <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
C = 10 ** 9 + 7 <NEWLINE> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , C ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <COMMENT> <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n and s [ k ] != s [ i ] and s [ k ] != s [ j ] and s [ i ] != s [ j ] : <COMMENT> <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X = X ^ a [ i ] <NEWLINE> <DEDENT> xor = [ X ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xor [ i ] ^= a [ i ] <NEWLINE> <DEDENT> print ( * xor ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> m = 10 ** 5 + 1 <NEWLINE> nums = [ 0 ] * m <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> nums [ i ] += 1 <NEWLINE> ans += i <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans -= b * nums [ b ] <NEWLINE> ans += c * nums [ b ] <NEWLINE> nums [ c ] += nums [ b ] <NEWLINE> nums [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> links = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> mark = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> links [ a ] . append ( b ) <NEWLINE> links [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for l in links [ now ] : <NEWLINE> <INDENT> if mark [ l ] == - 1 : <NEWLINE> <INDENT> q . append ( l ) <NEWLINE> mark [ l ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in mark [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( [ str ( w ) for w in mark [ 2 : ] ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> c = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = c - a [ i ] <NEWLINE> b = ( a [ i ] * c ) <NEWLINE> ans = ans + b <NEWLINE> <DEDENT> d = ans % ( 1000000007 ) <NEWLINE> print ( d ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <INDENT> que = deque ( [ ] ) <NEWLINE> que . append ( 0 ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> now = que . popleft ( ) <NEWLINE> for next in g [ now ] : <COMMENT> <NEWLINE> <INDENT> if d [ next ] == 0 : <NEWLINE> <INDENT> que . append ( next ) <NEWLINE> d [ next ] = now + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> d = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> bfs ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> <NL> def solve ( e ) : <NEWLINE> <INDENT> k = 2 ** 32 <NEWLINE> for z in range ( 100 , - 1 , - 1 ) : <NEWLINE> <INDENT> z3 = z * z * z <NEWLINE> if z3 > e : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> e2 = e - z3 <NEWLINE> <NL> ylm = int ( math . sqrt ( e2 ) ) <NEWLINE> xzlm = 3 * z * z + 3 * z + 1 <NEWLINE> <NL> for y in range ( ylm , - 1 , - 1 ) : <NEWLINE> <INDENT> y2 = y * y <NEWLINE> if e2 > ( y + 1 ) * ( y + 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> e3 = e2 - y2 <NEWLINE> <NL> xylm = 2 * y + 1 <NEWLINE> x = e3 <NEWLINE> if x > xylm or x > xzlm : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = min ( k , x + y + z ) <NEWLINE> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( solve ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
Big = 10 ** 9 + 7 <NEWLINE> _ = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> N = _ [ 0 ] <NEWLINE> K = _ [ 1 ] <NEWLINE> gcd_list = [ 0 for _ in range ( K ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> s = K - i - 1 <NEWLINE> gcd_list [ s ] = ( pow ( K // ( K - i ) , N , Big ) - ( sum ( gcd_list [ 2 * s + 1 : : s + 1 ] ) ) % Big ) % Big <NEWLINE> <DEDENT> answer = [ ( x + 1 ) * gcd_list [ x ] % Big for x in range ( K ) ] <NEWLINE> print ( sum ( answer ) % Big ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> for c in <STRING> : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == c : <NEWLINE> <INDENT> for j in range ( i + 1 , i + K + 1 ) : <NEWLINE> <INDENT> ans . add ( S [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( list ( ans ) ) [ K - 1 ] ) <NEWLINE>
<NL> def s0 ( ) : return input ( ) <NEWLINE> def s1 ( ) : return input ( ) . split ( ) <NEWLINE> def s2 ( n ) : return [ input ( ) for x in range ( n ) ] <NEWLINE> def s3 ( n ) : return [ [ input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> def n0 ( ) : return int ( input ( ) ) <NEWLINE> def n1 ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def n2 ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def n3 ( n ) : return [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> def t3 ( n ) : return [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> def p0 ( b , yes = <STRING> , no = <STRING> ) : print ( yes ) if b else print ( no ) <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , m = n1 ( ) <NEWLINE> ab = n3 ( m ) <NEWLINE> <NL> node = defaultdict ( list ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> node [ a ] . append ( b ) <NEWLINE> node [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> p = deque ( [ 1 ] ) <NEWLINE> d = [ 0 ] * ( n + 1 ) <NEWLINE> while len ( p ) > 0 : <NEWLINE> <INDENT> c = p . popleft ( ) <NEWLINE> for i in node [ c ] : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> d [ i ] = c <NEWLINE> p . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> si = [ 0 ] * ( len ( s ) + 1 ) <COMMENT> <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <COMMENT> <NEWLINE> <INDENT> tmp += int ( s [ len ( s ) - i ] ) % 2019 * pow ( 10 , i - 1 , 2019 ) <NEWLINE> si [ i ] = tmp % 2019 <NEWLINE> <NL> <DEDENT> c = Counter ( si ) <NEWLINE> ans = 0 <NEWLINE> for b in list ( c . values ( ) ) : <COMMENT> <NEWLINE> <INDENT> ans += b * ( b - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> ans = 1 <NEWLINE> i = 0 <NEWLINE> while ( i <= n - 1 ) : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> pl = min ( p ) - 1 <NEWLINE> pr = max ( p ) + 2 <NEWLINE> npl = list ( range ( pl , pr ) ) <NEWLINE> np = list ( set ( npl ) - set ( p ) ) <NEWLINE> if len ( np ) == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> np . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> mx = x <NEWLINE> res = np [ 0 ] <NEWLINE> for k in np : <NEWLINE> <INDENT> t = abs ( k - x ) <NEWLINE> if t < mx : <NEWLINE> <INDENT> mx = t <NEWLINE> res = k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> <NL> ERROR_INPUT = <STRING> <NEWLINE> OPECODE = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> STACK = [ ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> inp = get_input ( ) <NEWLINE> print ( calc_stack ( li = inp ) ) <NEWLINE> <NL> <NL> <DEDENT> def calc_stack ( li ) : <NEWLINE> <INDENT> if li [ 0 ] in OPECODE : <NEWLINE> <INDENT> ans = calc ( left = STACK [ - 2 ] , right = STACK [ - 1 ] , ope = li [ 0 ] ) <NEWLINE> <NL> del li [ 0 ] <NEWLINE> if not li : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> STACK . pop ( ) <NEWLINE> STACK . pop ( ) <NEWLINE> STACK . append ( ans ) <NEWLINE> <NL> return calc_stack ( li = li ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> STACK . append ( int ( li [ 0 ] ) ) <NEWLINE> del li [ 0 ] <NEWLINE> return calc_stack ( li = li ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calc ( left , right , ope ) : <NEWLINE> <INDENT> if ope == <STRING> : <NEWLINE> <INDENT> return left + right <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> return left - right <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> return left * right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_input ( ) : <NEWLINE> <INDENT> inp = input ( ) . split ( <STRING> ) <NEWLINE> opecode_count = 0 <NEWLINE> operand_count = 0 <NEWLINE> <NL> for i in inp : <NEWLINE> <INDENT> if i in OPECODE : <NEWLINE> <INDENT> opecode_count += 1 <NEWLINE> <DEDENT> elif int ( i ) < 0 or int ( i ) > 10 ** 6 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> operand_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if opecode_count < 1 or opecode_count > 100 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> if operand_count < 2 or operand_count > 100 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> return inp <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if s - ( x + y ) <= k and s - ( x + y ) >= 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
count = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> ODD = defaultdict ( int ) <NEWLINE> EVEN = defaultdict ( int ) <NEWLINE> ALL = set ( [ ] ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ALL . add ( A [ i ] ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> EVEN [ A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ODD [ A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( ALL ) == 1 : <NEWLINE> <INDENT> ans = N // 2 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> modd = max ( ODD . values ( ) ) <NEWLINE> meven = max ( EVEN . values ( ) ) <NEWLINE> mlodd = [ ] ; mleven = [ ] <NEWLINE> dicodd = sorted ( ODD . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> diceven = sorted ( EVEN . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ans = N <NEWLINE> if len ( dicodd ) > 1 : <NEWLINE> <INDENT> X = [ dicodd [ 0 ] , dicodd [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = [ dicodd [ 0 ] ] <NEWLINE> <DEDENT> if len ( diceven ) > 1 : <NEWLINE> <INDENT> Y = [ diceven [ 0 ] , diceven [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y = [ diceven [ 0 ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for x , v in X : <NEWLINE> <INDENT> for y , w in Y : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> temp = N - ( v + w ) <NEWLINE> ans = min ( ans , temp ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> l = set ( ) <NEWLINE> num = 0 <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> l . add ( i ) <NEWLINE> <DEDENT> print ( len ( l ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> X = input ( ) <NEWLINE> stack = deque ( [ X [ 0 ] ] ) <NEWLINE> for i in range ( 1 , len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> stack . appendleft ( X [ i ] ) <NEWLINE> <NL> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if stack : <NEWLINE> <INDENT> check = stack . popleft ( ) <NEWLINE> if check == <STRING> : <NEWLINE> <INDENT> stack . appendleft ( check ) <NEWLINE> stack . appendleft ( X [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> stack . appendleft ( X [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( stack ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d [ arr [ i ] ] = d [ arr [ i ] ] + 1 <NEWLINE> <DEDENT> sumi = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sumi = sumi + arr [ i ] <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> a , b = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> e1 = d [ a ] <NEWLINE> d [ b ] = d [ b ] + e1 <NEWLINE> sumi = sumi + ( e1 ) * ( b - a ) <NEWLINE> print ( sumi ) <NEWLINE> d [ a ] = 0 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> from queue import Queue <NEWLINE> g = defaultdict ( list ) <NEWLINE> visted = defaultdict ( bool ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ A ] . append ( B ) <NEWLINE> g [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> h = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> h2 = defaultdict ( list ) <NEWLINE> def solve ( v ) : <NEWLINE> <INDENT> visited = set ( ) <NEWLINE> q = Queue ( ) <NEWLINE> visited . add ( v ) <NEWLINE> h [ v ] = 0 <NEWLINE> h2 [ 0 ] . append ( v ) <NEWLINE> q . put ( v ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> v = q . get ( ) <NEWLINE> for c in g [ v ] : <NEWLINE> <INDENT> if not c in visited : <NEWLINE> <INDENT> visited . add ( c ) <NEWLINE> h [ c ] = h [ v ] + 1 <NEWLINE> h2 [ h [ v ] + 1 ] . append ( c ) <NEWLINE> q . put ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> solve ( 1 ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for v in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> i = h [ v ] <NEWLINE> <NL> for c in g [ v ] : <NEWLINE> <INDENT> if h [ c ] == i - 1 : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = 0 <NEWLINE> r = max ( A ) <NEWLINE> for _ in range ( 30 ) : <NEWLINE> <INDENT> mid = ( r + l + 1 ) // 2 <NEWLINE> count = 0 <NEWLINE> for log in A : <NEWLINE> <INDENT> if log > mid : <NEWLINE> <INDENT> count += ( log + mid - 1 ) // mid - 1 <NEWLINE> <DEDENT> <DEDENT> if count <= K : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import sys <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list , w_list = [ 0 ] * H , [ 0 ] * W <NEWLINE> check = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> check . add ( ( h - 1 , w - 1 ) ) <NEWLINE> h_list [ h - 1 ] += 1 <NEWLINE> w_list [ w - 1 ] += 1 <NEWLINE> <DEDENT> h_max , w_max = max ( h_list ) , max ( w_list ) <NEWLINE> h_bom = [ i for i in range ( H ) if h_list [ i ] == h_max ] <NEWLINE> w_bom = [ i for i in range ( W ) if w_list [ i ] == w_max ] <NEWLINE> for h in h_bom : <NEWLINE> <INDENT> for w in w_bom : <NEWLINE> <INDENT> if not ( h , w ) in check : <NEWLINE> <INDENT> print ( h_max + w_max ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max - 1 ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> dp = [ True ] + [ False ] * ( n + 1 ) <NEWLINE> way = [ 1 ] + [ 6 ** i for i in range ( 1 , 9 ) if 6 ** i <= n ] + [ 9 ** i for i in range ( 1 , 7 ) if 9 ** i <= n ] <NEWLINE> loop_counter = 0 <NEWLINE> while True : <NEWLINE> <INDENT> loop_counter += 1 <NEWLINE> newdp = [ False ] * ( n + 1 ) <NEWLINE> for w in way : <NEWLINE> <INDENT> for i in range ( w , n + 1 ) : <NEWLINE> <INDENT> if newdp [ i ] : continue <NEWLINE> if dp [ i - w ] : newdp [ i ] = True <NEWLINE> if newdp [ n ] : <NEWLINE> <INDENT> return loop_counter <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp = [ x for x in newdp ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( solve ( ) ) <NEWLINE>
def listseki ( A , start , end ) : <NEWLINE> <INDENT> ans = A [ end ] / A [ start - 1 ] <NEWLINE> return ans <NEWLINE> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> nowseki = listseki ( A , i , i + K - 1 ) <NEWLINE> if nowseki > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> V = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( V [ i ] - C [ i ] ) > 0 : <NEWLINE> <INDENT> m = m + V [ i ] - C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> d = { <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 , <STRING> : 5 , <STRING> : 6 } <NEWLINE> <NL> rot = ( ( 0 , 1 , 2 , 3 , 4 , 5 , 6 ) , ( 0 , 2 , 6 , 3 , 4 , 1 , 5 ) , ( 0 , 4 , 2 , 1 , 6 , 5 , 3 ) , ( 0 , 3 , 2 , 6 , 1 , 5 , 4 ) , ( 0 , 5 , 1 , 3 , 4 , 6 , 2 ) , ( 0 , 1 , 3 , 5 , 2 , 4 , 6 ) , ( 0 , 1 , 4 , 2 , 5 , 3 , 6 ) ) <NEWLINE> <NL> import sys <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> dice = [ [ j for j in range ( 7 ) ] for i in range ( 2 ) ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = d [ input ( ) . strip ( ) ] <NEWLINE> for k in range ( 1 , 7 ) : dice [ 1 - ( i & 1 ) ] [ k ] = dice [ i & 1 ] [ rot [ j ] [ k ] ] <NEWLINE> ans += dice [ 1 - ( i & 1 ) ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> Num = 7 % K <NEWLINE> while cnt <= K : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if Num % K == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Num = ( 10 * Num + 7 ) % K <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import heapq <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> TA = [ 0 ] <NEWLINE> TB = [ 0 ] <NEWLINE> na = 0 <NEWLINE> nb = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n = TA [ - 1 ] + A [ i ] <NEWLINE> if n > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> TA . append ( n ) <NEWLINE> na = i + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> n = TB [ - 1 ] + B [ i ] <NEWLINE> if n > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> TB . append ( n ) <NEWLINE> nb = i + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> a = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for b in range ( nb , - 1 , - 1 ) : <NEWLINE> <INDENT> while TB [ b ] + TA [ a ] <= K : <NEWLINE> <INDENT> ans = max ( ans , a + b ) <NEWLINE> a += 1 <NEWLINE> if a > na : <NEWLINE> <INDENT> a -= 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 998244353 <COMMENT> <NEWLINE> N = 2 * 10 ** 5 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <NL> <NL> <DEDENT> kk = n - k <NEWLINE> <COMMENT> <NL> color = m * ( m - 1 ) ** ( kk - 1 ) % mod <NEWLINE> <COMMENT> <NL> while kk <= n : <NEWLINE> <INDENT> now = color <NEWLINE> color = color * ( m - 1 ) % mod <NEWLINE> now = now * ( cmb ( ( n - 1 ) , ( n - kk ) , mod ) ) % mod <NEWLINE> kk += 1 <NEWLINE> ans += now <NEWLINE> ans = ans % mod <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import itertools <NEWLINE> a = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a . append ( input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> suma = sum ( [ int ( aa [ 3 ] ) for aa in a ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> l = [ i for i in range ( m ) ] <NEWLINE> for v in itertools . combinations_with_replacement ( l , n - 1 ) : <NEWLINE> <INDENT> ans_ = 0 <NEWLINE> v = [ 0 ] + list ( v ) <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if v [ int ( a [ j ] [ 1 ] ) - 1 ] - v [ int ( a [ j ] [ 0 ] ) - 1 ] == int ( a [ j ] [ 2 ] ) : <NEWLINE> <INDENT> ans_ += int ( a [ j ] [ 3 ] ) <NEWLINE> <DEDENT> <DEDENT> if ans_ > ans : <NEWLINE> <INDENT> ans = ans_ <NEWLINE> if ans == suma : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from subprocess import * <NEWLINE> from collections import * <NEWLINE> n = int ( input ( ) ) <NEWLINE> p = Counter ( map ( int , Popen ( [ <STRING> , str ( n ) ] , stdout = PIPE ) . communicate ( ) [ 0 ] . decode ( ) . split ( ) [ 1 : ] ) ) <NEWLINE> a = n <NEWLINE> for i in p : <NEWLINE> <INDENT> a = a // i * ~ - i <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 100005 ) ] <NEWLINE> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> tmp = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if tmp < 10005 : <NEWLINE> <INDENT> ans [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> mod = K <NEWLINE> if K == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif K % 7 != 0 : <NEWLINE> <INDENT> x = 10 % mod <NEWLINE> X = [ 1 ] * K <NEWLINE> S = [ 1 ] * K <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> X [ i ] = ( X [ i - 1 ] * x ) % mod <NEWLINE> S [ i ] = S [ i - 1 ] + X [ i ] <NEWLINE> if S [ i ] % mod == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = K // 7 <NEWLINE> if mod == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 10 % mod <NEWLINE> y = 1 % mod <NEWLINE> X = [ y ] * K <NEWLINE> S = [ y ] * K <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> X [ i ] = ( X [ i - 1 ] * x ) % mod <NEWLINE> S [ i ] = S [ i - 1 ] + X [ i ] <NEWLINE> if S [ i ] % mod == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> aa = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> lista = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lista += [ int ( aa [ i ] ) ] <NEWLINE> <DEDENT> lista . sort ( ) <NEWLINE> listtf = [ ] <NEWLINE> s = 0 <NEWLINE> for i in range ( lista [ n - 1 ] ) : <NEWLINE> <INDENT> listtf += [ True ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <NL> <INDENT> if ( listtf [ lista [ i ] - 1 ] ) : <NEWLINE> <INDENT> if ( i < n - 1 and lista [ i ] == lista [ i + 1 ] ) : <NEWLINE> <INDENT> s -= 1 <NEWLINE> <DEDENT> s += 1 <NEWLINE> t = 1 <NEWLINE> while ( t * lista [ i ] <= lista [ n - 1 ] ) : <NEWLINE> <INDENT> listtf [ lista [ i ] * t - 1 ] = False <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> emplist = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = Counter ( emplist ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> alph = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> seq = [ ] <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> s = N % 26 <NEWLINE> N = ( N - 1 ) // 26 <NEWLINE> seq . append ( s ) <NEWLINE> <DEDENT> L = len ( seq ) <NEWLINE> <NL> name = <STRING> <NEWLINE> <NL> for i in range ( L ) : <NEWLINE> <INDENT> name = alph [ seq [ i ] ] + name <NEWLINE> <NL> <DEDENT> print ( name ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> roots = [ 1 ] <NEWLINE> position = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> position = A [ roots [ - 1 ] - 1 ] <NEWLINE> A [ roots [ - 1 ] - 1 ] = - position <NEWLINE> if position < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> roots . append ( position ) <NEWLINE> <NL> <DEDENT> x = roots . index ( - position ) <NEWLINE> y = len ( roots ) - x <NEWLINE> <NL> if k <= x : <NEWLINE> <INDENT> print ( roots [ k ] ) <NEWLINE> <DEDENT> elif k > x : <NEWLINE> <INDENT> print ( roots [ x + ( ( k - x ) % y ) ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> al = [ ] <NEWLINE> bl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> al . append ( [ a , b ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> bl . append ( [ c , d ] ) <NEWLINE> <NL> <DEDENT> def check ( a , b ) : <NEWLINE> <INDENT> x = a [ 0 ] - b [ 0 ] <NEWLINE> y = a [ 1 ] - b [ 1 ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x = - x <NEWLINE> <DEDENT> if y < 0 : <NEWLINE> <INDENT> y = - y <NEWLINE> <DEDENT> return x + y <NEWLINE> <NL> <DEDENT> for a in al : <NEWLINE> <INDENT> min = 1000000000 <NEWLINE> cnt = 1 <NEWLINE> for b in bl : <NEWLINE> <INDENT> tmp = check ( a , b ) <NEWLINE> if tmp < min : <NEWLINE> <INDENT> ans = cnt <NEWLINE> min = tmp <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 0 ] == S [ 1 ] == S [ 2 ] or S [ 1 ] == S [ 2 ] == S [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> taro , hanako = 0 , 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> lst = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> while 1 : <NEWLINE> <INDENT> if lst [ 0 ] == lst [ 1 ] : <NEWLINE> <INDENT> taro = taro + 1 <NEWLINE> hanako = hanako + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> length = min ( len ( lst [ 0 ] ) , len ( lst [ 1 ] ) ) <NEWLINE> for j in range ( length ) : <NEWLINE> <INDENT> first = ord ( lst [ 0 ] [ j : j + 1 ] ) <NEWLINE> second = ord ( lst [ 1 ] [ j : j + 1 ] ) <NEWLINE> if first > second : <NEWLINE> <INDENT> taro = taro + 3 <NEWLINE> break <NEWLINE> <DEDENT> elif first < second : <NEWLINE> <INDENT> hanako = hanako + 3 <NEWLINE> break <NEWLINE> <DEDENT> elif j == length - 1 : <NEWLINE> <INDENT> if len ( lst [ 0 ] ) > len ( lst [ 1 ] ) : <NEWLINE> <INDENT> taro = taro + 3 <NEWLINE> <DEDENT> elif len ( lst [ 0 ] ) < len ( lst [ 1 ] ) : <NEWLINE> <INDENT> hanako = hanako + 3 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( str ( taro ) + <STRING> + str ( hanako ) ) <NEWLINE>
<NL> import time <NEWLINE> <NL> start_time = time . time ( ) <NEWLINE> <NL> <COMMENT> <NL> D = int ( input ( ) ) <NEWLINE> c_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s_grid = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> array = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> s_grid . append ( array ) <NEWLINE> <NL> <DEDENT> t_list = [ ( i % 26 ) for i in range ( D ) ] <COMMENT> <NEWLINE> <NL> def calculate_score ( t_list , score_list , last_grid , change_query_number ) : <NEWLINE> <INDENT> score_list = score_list [ : change_query_number ] <NEWLINE> last_grid = last_grid [ : change_query_number ] <NEWLINE> <NL> if len ( score_list ) > 1 : <NEWLINE> <INDENT> score = score_list [ change_query_number - 1 ] <NEWLINE> last_list = last_grid [ change_query_number - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = 0 <NEWLINE> last_list = [ 0 for i in range ( 26 ) ] <NEWLINE> <NL> <DEDENT> for d in range ( change_query_number , D ) : <NEWLINE> <INDENT> score += s_grid [ d ] [ t_list [ d ] ] <NEWLINE> last_list = [ n + 1 for n in last_list ] <NEWLINE> last_list [ t_list [ d ] ] = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> score -= c_list [ i ] * last_list [ i ] <NEWLINE> <DEDENT> score_list . append ( score ) <NEWLINE> last_grid . append ( last_list ) <NEWLINE> <DEDENT> return score_list , last_grid <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> previous_s , previous_l = calculate_score ( t_list , [ ] , [ [ 0 for i in range ( 26 ) ] ] , 0 ) <NEWLINE> score = previous_s [ - 1 ] <NEWLINE> <NL> for k in range ( 1 , D ) : <NEWLINE> <INDENT> X = - 1 <COMMENT> <NEWLINE> t_list_loop = t_list <NEWLINE> for i in range ( 26 ) : <COMMENT> <NEWLINE> <INDENT> t_list_loop [ k ] = i <NEWLINE> score_list_k , last_grid_k = calculate_score ( t_list_loop , previous_s , previous_l , k ) <NEWLINE> if score_list_k [ - 1 ] > score : <NEWLINE> <INDENT> X = i <NEWLINE> score = score_list_k [ - 1 ] <NEWLINE> score_list_t = score_list_k <NEWLINE> last_grid_t = last_grid_k <NEWLINE> <NL> <DEDENT> <DEDENT> if X != - 1 : <NEWLINE> <INDENT> t_list [ k ] = X <NEWLINE> previous_s = score_list_t <NEWLINE> previous_l = last_grid_t <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if time . time ( ) - start_time > 1.9 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( len ( t_list ) ) : <NEWLINE> <INDENT> print ( int ( t_list [ j ] ) + 1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 1 <NEWLINE> while k * i < a : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if k * i <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def g ( n ) : <NEWLINE> <INDENT> return ( ( n ** 2 ) + n ) // 2 <NEWLINE> <NL> <DEDENT> goukei = 0 <NEWLINE> half = N // 2 <NEWLINE> for i in range ( 1 , half + 1 ) : <NEWLINE> <INDENT> goukei += i * g ( N // i ) <NEWLINE> <NL> <DEDENT> add = list ( range ( half + 1 , N + 1 ) ) <NEWLINE> goukei += sum ( add ) <NEWLINE> print ( goukei ) <NEWLINE>
import numpy <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = numpy . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 0 : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> while True : <NEWLINE> <INDENT> if x % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x / 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if ( x , y ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( x < y ) : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = p [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> if i <= l : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in a : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> m = 1 <NEWLINE> flag = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> m *= i <NEWLINE> if m > 1e+18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : print ( m ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] = 1 <NEWLINE> num , d = 0 , 1 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> num += int ( i ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> count [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in count : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( int ( M ) ) ] <NEWLINE> <NL> <NL> Flags = [ 1 ] * N <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> if ( H [ AB [ j ] [ 0 ] - 1 ] <= H [ AB [ j ] [ 1 ] - 1 ] ) : <NEWLINE> <INDENT> Flags [ AB [ j ] [ 0 ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> if ( H [ AB [ j ] [ 1 ] - 1 ] <= H [ AB [ j ] [ 0 ] - 1 ] ) : <NEWLINE> <INDENT> Flags [ AB [ j ] [ 1 ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> count += Flags [ i ] <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = <STRING> <NEWLINE> <NL> def bite ( X ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> t = 0 <NEWLINE> while t < X : <NEWLINE> <INDENT> t = t + 26 ** ( s + 1 ) <NEWLINE> s = s + 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> B = bite ( N ) <NEWLINE> X = N <NEWLINE> L = [ ] <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> if X % 26 != 0 : <NEWLINE> <INDENT> L . append ( X % 26 ) <NEWLINE> X = ( X - X % 26 ) // 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( 26 ) <NEWLINE> X = ( X - 26 ) // 26 <NEWLINE> <NL> <DEDENT> <DEDENT> L . reverse ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> ans = ans + S [ L [ i ] - 1 ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n_num , m_num = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> c_map = [ ] <NEWLINE> for _ in range ( n_num ) : <NEWLINE> <INDENT> c_map . append ( [ ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for _ in range ( m_num ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <COMMENT> <NL> <DEDENT> c_map [ a - 1 ] . append ( b - 1 ) <NEWLINE> c_map [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> city_info = np . zeros ( n_num , dtype = <STRING> ) <NEWLINE> land_city = 0 <NEWLINE> <NL> def move ( a , b ) : <NEWLINE> <INDENT> if a in c_map [ b ] : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def recr ( c ) : <NEWLINE> <INDENT> city_info [ c ] = 1 <NEWLINE> for n in c_map [ c ] : <NEWLINE> <INDENT> if city_info [ n ] == 0 : <NEWLINE> <INDENT> if move ( c , n ) == 1 : <NEWLINE> <INDENT> recr ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( n_num ) : <NEWLINE> <INDENT> if city_info [ n ] == 0 : <NEWLINE> <INDENT> land_city += 1 <NEWLINE> recr ( n ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( land_city - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> x = np . arange ( 1 , K + 1 ) <NEWLINE> nums = np . gcd . outer ( np . gcd . outer ( x , x ) , x ) <NEWLINE> ans = nums . sum ( ) <NEWLINE> print ( ans ) <NEWLINE>
c = [ s + <STRING> + str ( i ) for s in <STRING> for i in range ( 1 , 14 ) ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> c . remove ( input ( ) ) <NEWLINE> <DEDENT> if [ ] != c : print ( * c , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ A [ N - 1 ] ] <NEWLINE> <COMMENT> <NL> for i in range ( len ( A ) - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> b = B [ i ] + A [ N - 2 - i ] <NEWLINE> B . append ( b ) <NEWLINE> <COMMENT> <NL> <DEDENT> total = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> total += A [ i ] * B [ len ( B ) - 1 - i ] <NEWLINE> <NL> <DEDENT> print ( total % ( 10 ** 9 + 7 ) ) <NEWLINE>
def iteraccumulate ( l ) : <NEWLINE> <INDENT> from itertools import accumulate <NEWLINE> return list ( accumulate ( l ) ) <NEWLINE> <NL> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> from bisect import bisect_right <NEWLINE> inf = 10 ** 10 <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = [ 0 ] + iteraccumulate ( a ) + [ inf ] <NEWLINE> bb = iteraccumulate ( b ) + [ inf ] <NEWLINE> lbb = len ( bb ) <NEWLINE> ans = 0 <NEWLINE> for index , i in enumerate ( aa ) : <NEWLINE> <INDENT> j = bisect_right ( bb , k - i ) <NEWLINE> if j == 0 and i <= k : <NEWLINE> <INDENT> ans = max ( ans , index ) <NEWLINE> <DEDENT> elif j > 0 and i + bb [ j - 1 ] <= k : <NEWLINE> <INDENT> ans = max ( ans , index + j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from collections import Counter , deque <NEWLINE> from scipy import special <NEWLINE> S = input ( ) <NEWLINE> l = [ int ( n ) for n in S ] <NEWLINE> a = [ 0 ] <NEWLINE> t = 0 <NEWLINE> m = 1 <NEWLINE> d = deque ( l ) <NEWLINE> mod = 2019 <NEWLINE> while d : <NEWLINE> <INDENT> temp = d . pop ( ) <NEWLINE> t = ( t + ( temp * m ) ) % mod <NEWLINE> m = ( m * 10 ) % mod <NEWLINE> a . append ( t % mod ) <NEWLINE> <DEDENT> b = [ special . comb ( kv , 2 , exact = True ) for kv in Counter ( a ) . values ( ) if kv > 1 ] <NEWLINE> print ( sum ( b ) ) <NEWLINE>
class Node : <NEWLINE> <INDENT> def __init__ ( self , num , left , right ) : <NEWLINE> <INDENT> self . id = num <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> self . parent = - 1 <NEWLINE> self . brother = - 1 <NEWLINE> if self . left == - 1 and self . right == - 1 : <NEWLINE> <INDENT> self . child = 0 <NEWLINE> <DEDENT> elif self . left != - 1 and self . right != - 1 : <NEWLINE> <INDENT> self . child = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . child = 1 <NEWLINE> <DEDENT> self . depth = 0 <NEWLINE> self . height = 0 <NEWLINE> self . type = None <NEWLINE> <NL> <DEDENT> def show_info ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . id , self . parent , self . brother , self . child , self . depth , self . height , self . type ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def SetNode ( I_Line ) : <NEWLINE> <INDENT> L = list ( map ( int , I_Line . split ( ) ) ) <NEWLINE> num = L [ 0 ] <NEWLINE> left = L [ 1 ] <NEWLINE> right = L [ 2 ] <NEWLINE> node = Node ( num , left , right ) <NEWLINE> T [ num ] = node <NEWLINE> if left != - 1 : <NEWLINE> <INDENT> T [ - 1 ] -= left <NEWLINE> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> T [ - 1 ] -= right <NEWLINE> <NL> <DEDENT> <DEDENT> def setPBD ( i , p , b , d ) : <COMMENT> <NEWLINE> <INDENT> node = T [ i ] <NEWLINE> node . parent = p <NEWLINE> node . brother = b <NEWLINE> node . depth = d <NEWLINE> if node . parent == - 1 : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <DEDENT> elif node . child == 0 : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <DEDENT> if node . left != - 1 : <NEWLINE> <INDENT> setPBD ( node . left , i , node . right , node . depth + 1 ) <NEWLINE> <DEDENT> if node . right != - 1 : <NEWLINE> <INDENT> setPBD ( node . right , i , node . left , node . depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def setH ( i ) : <COMMENT> <NEWLINE> <INDENT> node = T [ i ] <NEWLINE> if node . left == - 1 : <NEWLINE> <INDENT> leftheight = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> leftheight = setH ( node . left ) + 1 <NEWLINE> <DEDENT> if node . right == - 1 : <NEWLINE> <INDENT> rightheight = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rightheight = setH ( node . right ) + 1 <NEWLINE> <DEDENT> node . height = max ( leftheight , rightheight ) <NEWLINE> return node . height <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> T = [ None ] * n <NEWLINE> T . append ( int ( n * ( n - 1 ) / 2 ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> SetNode ( x ) <NEWLINE> <NL> <DEDENT> root = T [ - 1 ] <NEWLINE> setPBD ( root , - 1 , - 1 , 0 ) <NEWLINE> setH ( root ) <NEWLINE> T . pop ( ) <NEWLINE> for i in T : <NEWLINE> <INDENT> i . show_info ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> <NL> MOD = 998244353 <NEWLINE> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> dp = np . zeros ( s + 1 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> t = dp . copy ( ) * 2 <NEWLINE> t [ a : ] += dp [ : - a ] <NEWLINE> t %= MOD <NEWLINE> dp = t <NEWLINE> <DEDENT> ans = dp [ s ] <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> import statistics <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( c , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y != 0 : <NEWLINE> <INDENT> org_x = x <NEWLINE> x = y <NEWLINE> y = org_x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd_ab = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd_ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> gcds = [ [ 0 for _ in range ( K + 1 ) ] for _ in range ( K + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcds [ i ] [ j ] = gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s += gcds [ gcds [ i ] [ j ] ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = { } <NEWLINE> R = { } <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> x = i + 1 + a <NEWLINE> L [ x ] = L [ x ] + 1 if x in L else 1 <NEWLINE> <NL> x = i + 1 - a <NEWLINE> R [ x ] = R [ x ] + 1 if x in R else 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for x in L . keys ( ) : <NEWLINE> <INDENT> ans += L [ x ] * ( R [ x ] if x in R else 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for tmp in a : <NEWLINE> <INDENT> ans *= tmp <NEWLINE> if ( ans > 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def SL ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x , y = IL ( ) <NEWLINE> if 4 * x < y or y % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if 4 * i + 2 * ( x - i ) == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> res *= a <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( 0 if 0 in A else res ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> ans += int ( s [ i ] ) <NEWLINE> <NL> <DEDENT> if ans % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> As = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> <NL> cumsum = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> cumsum [ i - 1 ] = abs ( As [ i ] - As [ i - 1 ] ) <NEWLINE> <DEDENT> cumsum_sum = sum ( cumsum ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = cumsum_sum - cumsum [ i - 1 ] - cumsum [ i ] + abs ( As [ i + 1 ] - As [ i - 1 ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> print ( ( ( n - 1 ) * n ) // 2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> maxi = arr [ - 1 ] <NEWLINE> booll = [ True ] * ( maxi + 1 ) <NEWLINE> r = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a = arr [ i ] <NEWLINE> if ( booll [ a ] == True ) : <NEWLINE> <INDENT> for j in range ( a , maxi + 1 , a ) : <NEWLINE> <INDENT> booll [ j ] = False <NEWLINE> <DEDENT> if ( a < arr [ i + 1 ] ) : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( booll [ arr [ n - 1 ] ] == True ) : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n , k = input2 ( ) <NEWLINE> A = input_array ( ) <NEWLINE> <NL> <COMMENT> <NL> judge = [ True ] * n <NEWLINE> tmps = [ 1 ] <COMMENT> <NEWLINE> count = 0 <COMMENT> <NEWLINE> <NL> for i in range ( 2 * ( 10 ** 5 ) + 1 ) : <NEWLINE> <INDENT> if judge [ count ] == True : <NEWLINE> <INDENT> judge [ count ] = False <NEWLINE> count = A [ count ] - 1 <NEWLINE> tmps . append ( count + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> loop_st = tmps . index ( tmps [ - 1 ] ) <NEWLINE> loops = tmps [ loop_st : - 1 ] <NEWLINE> <NL> <NL> if k < loop_st : <NEWLINE> <INDENT> print ( tmps [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - loop_st <NEWLINE> k %= len ( loops ) <NEWLINE> print ( loops [ k ] ) <NEWLINE> <DEDENT>
def resolver ( N , A , Q , BC ) : <NEWLINE> <INDENT> total = sum ( A ) <NEWLINE> counter = dict ( ) <NEWLINE> ans = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> counter [ a ] = counter . get ( a , 0 ) + 1 <NEWLINE> <NL> <DEDENT> for ( b , c ) in BC : <NEWLINE> <INDENT> c0 = counter . pop ( b ) if b in counter else 0 <NEWLINE> counter [ c ] = counter . get ( c , 0 ) + c0 <NEWLINE> total -= c0 * b <NEWLINE> total += c0 * c <NEWLINE> ans . append ( total ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <COMMENT> <NL> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> bc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC . append ( bc ) <NEWLINE> <NL> <DEDENT> ans = resolver ( N , A , Q , BC ) <NEWLINE> <NL> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = [ A [ i ] + i for i in range ( N ) ] <NEWLINE> Y = [ j - A [ j ] for j in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> Y . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += bisect . bisect_right ( Y , X [ i ] ) - bisect . bisect_left ( Y , X [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <STRING> <NEWLINE>
<COMMENT> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> RGB = [ 0 , 0 , 0 ] <NEWLINE> subcnt = 0 <NEWLINE> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> if c == <STRING> : RGB [ 0 ] += 1 <NEWLINE> if c == <STRING> : RGB [ 1 ] += 1 <NEWLINE> if c == <STRING> : RGB [ 2 ] += 1 <NEWLINE> <NL> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> s = S [ j ] <NEWLINE> k = j * 2 - i <NEWLINE> if k < N : <NEWLINE> <INDENT> x = S [ k ] <NEWLINE> if x != s and s != c and x != c : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> subcnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> A = RGB [ 0 ] * RGB [ 1 ] * RGB [ 2 ] <NEWLINE> print ( A - subcnt ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> resolve ( ) <NEWLINE>
N , M , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ n ] + A [ n ] ) <NEWLINE> <DEDENT> for m in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ m ] + B [ m ] ) <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> bmax = M + 1 <NEWLINE> for n in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ n ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for m in reversed ( range ( bmax ) ) : <NEWLINE> <INDENT> if b [ m ] <= K - a [ n ] : <NEWLINE> <INDENT> num = max ( num , n + m ) <NEWLINE> bmax = m + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] == A [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <NL> <DEDENT> if cnt == 2 : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> b = A [ i ] <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> <NL> if a * b != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a * b ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> e_s = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> e = ( p [ i ] + 1 ) / 2 <NEWLINE> e_s [ i + 1 ] = e_s [ i ] + e <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , e_s [ j + K ] - e_s [ j ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> mod = 2019 <NEWLINE> <NL> S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> <COMMENT> <NL> <NL> a , b = [ ] , [ 0 ] <NEWLINE> s = 0 <NEWLINE> xx = [ 0 for _ in range ( 2019 ) ] <NEWLINE> xx [ 0 ] += 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> s += int ( S [ - i - 1 ] ) * pow ( 10 , i , mod ) <NEWLINE> s %= mod <NEWLINE> <COMMENT> <NL> xx [ s ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> def a ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( len ( xx ) ) : <NEWLINE> <INDENT> if xx [ i ] > 1 : <NEWLINE> <INDENT> ans += a ( xx [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> order = int ( input ( ) ) <NEWLINE> llist = [ input ( ) . split ( ) for _ in range ( order ) ] <NEWLINE> ans = deque ( [ ] ) <NEWLINE> count = 0 <NEWLINE> for lst in llist : <NEWLINE> <INDENT> if lst [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . appendleft ( lst [ 1 ] ) <NEWLINE> <NL> <DEDENT> elif lst [ 0 ] == <STRING> : <NEWLINE> <INDENT> if lst [ 1 ] in ans : <NEWLINE> <INDENT> ans . remove ( lst [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif lst [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . popleft ( ) <NEWLINE> <NL> <DEDENT> elif lst [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <NL> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 500 ) : <NEWLINE> <INDENT> for b in range ( - 500 , 500 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == n : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> list = input ( ) . split ( <STRING> ) <NEWLINE> x = 1 <NEWLINE> <NL> if <STRING> in list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in list : <NEWLINE> <INDENT> x *= int ( i ) <NEWLINE> if x > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
from sys import stdin , stderr <NEWLINE> from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def rec ( i , m ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return m == 0 or A [ i ] == m <NEWLINE> <NL> <DEDENT> return rec ( i - 1 , m ) or rec ( i - 1 , m - A [ i ] ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for m in M : <NEWLINE> <INDENT> if rec ( n - 1 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> def memoize ( f ) : <NEWLINE> <INDENT> memo = { } <NEWLINE> <NL> def main ( * args ) : <NEWLINE> <INDENT> if args in memo : <NEWLINE> <INDENT> return memo [ args ] <NEWLINE> <DEDENT> result = memo [ args ] = f ( * args ) <NEWLINE> return result <NEWLINE> <NL> <DEDENT> return main <NEWLINE> <NL> <NL> <DEDENT> def get_num ( remains ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while remains : <NEWLINE> <INDENT> if remains & 1 : <NEWLINE> <INDENT> yield i <NEWLINE> <DEDENT> i += 1 <NEWLINE> remains >>= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ memoize <NEWLINE> def calc ( n , s , remains ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> if remains & ( 1 << s ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> if s <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> return sum ( calc ( n - 1 , s - n * m , remains ^ ( 1 << m ) ) for m in get_num ( remains ) if s - n * m >= 0 ) <NEWLINE> <NL> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n , s = map ( int , line . split ( ) ) <NEWLINE> print ( calc ( n , s , ( 1 << 10 ) - 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( A ) <NEWLINE> list . sort ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import bisect_right <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> fr = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> fr [ a ] . append ( b ) <NEWLINE> fr [ b ] . append ( a ) <NEWLINE> <DEDENT> used = [ - 1 ] * N <NEWLINE> MAX = 0 <NEWLINE> def dfs ( fr , cur , parent ) : <NEWLINE> <INDENT> global cnt <NEWLINE> children = fr [ cur ] <NEWLINE> for chi in children : <NEWLINE> <INDENT> if used [ chi ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if chi == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ chi ] = 0 <NEWLINE> cnt += 1 <NEWLINE> dfs ( fr , chi , cur ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> if used [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ i ] = 0 <NEWLINE> dfs ( fr , i , - 1 ) <NEWLINE> MAX = max ( MAX , cnt ) <NEWLINE> <DEDENT> print ( MAX ) <NEWLINE> <NL> <NL>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> res = <STRING> <NEWLINE> d = 1 <NEWLINE> base = [ ] <NEWLINE> alp = <STRING> <NEWLINE> for b in range ( 12 ) : <NEWLINE> <INDENT> mod = n % 26 <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> mod = 26 <NEWLINE> <DEDENT> res = alp [ mod - 1 ] + res <NEWLINE> if n - mod == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( ( n - mod ) / 26 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( int ( i ) for i in input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> b = Counter ( a ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> Edges = list ( [ ] for _ in range ( N ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> Edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> P = [ 0 for _ in range ( N ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> P [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> gone = [ False for _ in range ( N ) ] <NEWLINE> <NL> def dfs ( counter , count , cur_node ) : <NEWLINE> <INDENT> count += P [ cur_node ] <NEWLINE> gone [ cur_node ] = True <NEWLINE> counter [ cur_node ] += count <NEWLINE> for next_node in Edges [ cur_node ] : <NEWLINE> <INDENT> if gone [ next_node ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( counter , count , next_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> counter = [ 0 for _ in range ( N ) ] <NEWLINE> dfs ( counter , 0 , 0 ) <NEWLINE> <NL> for c in counter : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> li [ a [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> li = li [ 1 : ] <NEWLINE> print ( * li , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> su = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N + 1 ) : <NEWLINE> <INDENT> su += gcd ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> su *= 6 <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if x != y : <NEWLINE> <INDENT> su += 3 * ( gcd ( x , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> su += x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( su ) <NEWLINE>
import sys <NEWLINE> import decimal <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> C2 = np . array ( [ [ 0 for j in range ( 30 ) ] for i in range ( 14 ) ] ) <COMMENT> <NEWLINE> C5 = np . array ( [ [ 0 for j in range ( 30 ) ] for i in range ( 14 ) ] ) <NEWLINE> C10 = np . zeros ( 14 ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> i = decimal . Decimal ( input ( ) ) <NEWLINE> c10 , c2 , c5 = 0 , 0 , 0 <NEWLINE> while i % 1 != 0 : <NEWLINE> <INDENT> c10 -= 1 <NEWLINE> i *= 10 <NEWLINE> <DEDENT> while i % 10 == 0 : <NEWLINE> <INDENT> c10 += 1 <NEWLINE> i /= 10 <NEWLINE> <DEDENT> while i % 2 == 0 : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> i /= 2 <NEWLINE> <DEDENT> while i % 5 == 0 : <NEWLINE> <INDENT> c5 += 1 <NEWLINE> i /= 5 <NEWLINE> <DEDENT> c2 = min ( c2 , 30 ) <NEWLINE> c5 = min ( c5 , 30 ) <NEWLINE> A . append ( ( c10 , c2 , c5 ) ) <NEWLINE> C2 [ c10 + 9 ] [ c2 ] += 1 <NEWLINE> C5 [ c10 + 9 ] [ c5 ] += 1 <NEWLINE> C10 [ c10 + 9 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 14 ) : <NEWLINE> <INDENT> ans += C10 [ i ] * np . sum ( C10 [ 18 - i : ] ) <NEWLINE> if i >= 9 : <NEWLINE> <INDENT> ans -= C10 [ i ] <NEWLINE> <DEDENT> for j in range ( 18 - i ) : <NEWLINE> <INDENT> if j >= 14 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 1 , 30 ) : <NEWLINE> <INDENT> shouldhave = 18 - i - j <NEWLINE> if k >= shouldhave : <NEWLINE> <INDENT> ans += C2 [ i ] [ k ] * np . sum ( C5 [ j ] [ shouldhave : ] ) <NEWLINE> ans += C5 [ i ] [ k ] * np . sum ( C2 [ j ] [ shouldhave : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans // 2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> d [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , len ( d ) ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
def lcs ( x , y ) : <NEWLINE> <INDENT> a = len ( x ) <NEWLINE> b = len ( y ) <NEWLINE> c1 = [ 0 ] * ( b + 1 ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = x [ i ] <NEWLINE> c2 = c1 [ : ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> ret = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = input ( ) . rstrip ( ) <NEWLINE> s2 = input ( ) . rstrip ( ) <NEWLINE> ret . append ( lcs ( s1 , s2 ) ) <NEWLINE> <DEDENT> print ( * ret , sep = <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> t = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if t % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> t = ( t * 10 + 7 ) % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> rc = S . count ( <STRING> ) <NEWLINE> gc = S . count ( <STRING> ) <NEWLINE> bc = S . count ( <STRING> ) <NEWLINE> ns = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for k in range ( i + 2 , N ) : <NEWLINE> <INDENT> if ( i + k ) % 2 == 0 and S [ i ] != S [ k ] : <NEWLINE> <INDENT> j = ( i + k ) // 2 <NEWLINE> ns += 1 if S [ j ] != S [ i ] and S [ j ] != S [ k ] else 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( rc * gc * bc - ns ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> route = [ ] <NEWLINE> lower = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ s [ 0 ] - 1 ] > h [ s [ 1 ] - 1 ] : <NEWLINE> <INDENT> lower . append ( s [ 1 ] ) <NEWLINE> <DEDENT> elif h [ s [ 1 ] - 1 ] > h [ s [ 0 ] - 1 ] : <NEWLINE> <INDENT> lower . append ( s [ 0 ] ) <NEWLINE> <DEDENT> elif h [ s [ 1 ] - 1 ] == h [ s [ 0 ] - 1 ] : <NEWLINE> <INDENT> lower . append ( s [ 0 ] ) <NEWLINE> lower . append ( s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> low = list ( set ( lower ) ) <NEWLINE> cnt = n - len ( low ) <NEWLINE> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> self . left , self . right = None , None <NEWLINE> <NL> <DEDENT> def insert ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if data < self . data : <NEWLINE> <INDENT> if self . left is None : <NEWLINE> <INDENT> self . left = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . left . insert ( data ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if self . right is None : <NEWLINE> <INDENT> self . right = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . right . insert ( data ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def pre_order ( self , node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> self . pre_order ( node . left ) <NEWLINE> self . pre_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def in_order ( self , node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> self . in_order ( node . left ) <NEWLINE> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> self . in_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def action ( command , content ) : <NEWLINE> <INDENT> if command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root . insert ( data = int ( content ) ) <NEWLINE> <NL> <DEDENT> if command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root . in_order ( node = tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> tree_root . pre_order ( node = tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> command_list = list ( map ( lambda x : x . split ( ) , _input [ 1 : ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> flag , tree_root = False , None <NEWLINE> for each in command_list : <NEWLINE> <INDENT> command , content = each [ 0 ] , each [ - 1 ] <NEWLINE> if ( not flag ) and command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root = Node ( data = int ( content ) ) <NEWLINE> flag = True <NEWLINE> continue <NEWLINE> <DEDENT> action ( command = command , content = content ) <NEWLINE> <DEDENT> <DEDENT>
name = input ( ) <NEWLINE> print ( name [ 0 : 3 ] ) <NEWLINE>
D , G = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> score_table = [ ] <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> p , c = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> score_table . append ( [ i * 100 , p , c ] ) <NEWLINE> <NL> <DEDENT> min_count = sum ( [ l [ 1 ] for l in score_table ] ) <NEWLINE> <COMMENT> <NL> <NL> for bit in range ( 1 << D ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> score += score_table [ i ] [ 0 ] * score_table [ i ] [ 1 ] + score_table [ i ] [ 2 ] <NEWLINE> count += score_table [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if score >= G : <NEWLINE> <INDENT> min_count = min ( min_count , count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> additional = [ ] <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if not bit & ( 1 << j ) : <NEWLINE> <INDENT> additional . append ( score_table [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> additional_ = sorted ( additional , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> for k in range ( additional_ [ 0 ] [ 1 ] - 1 ) : <NEWLINE> <INDENT> score += additional_ [ 0 ] [ 0 ] <NEWLINE> count += 1 <NEWLINE> if score >= G : <NEWLINE> <INDENT> min_count = min ( min_count , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min_count ) <NEWLINE>
input ( ) <NEWLINE> l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = 1 <NEWLINE> lim = 10 ** 18 <NEWLINE> for e in l : <NEWLINE> <INDENT> n *= e <NEWLINE> if n > lim : <NEWLINE> <INDENT> print ( 0 if 0 in l else - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> total = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> total *= a <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if total <= 10 ** 18 : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> m = A [ 0 ] <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> if m < A [ i + 1 ] : <NEWLINE> <INDENT> m = A [ i + 1 ] <NEWLINE> <DEDENT> if m > A [ i + 1 ] : <NEWLINE> <INDENT> d = m - A [ i + 1 ] <NEWLINE> c += d <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
def solve ( dp , a , i , m ) : <NEWLINE> <INDENT> if m in dp [ i ] : <NEWLINE> <INDENT> return dp [ i ] [ m ] <NEWLINE> <NL> <DEDENT> if m == 0 : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> elif i >= len ( a ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = False <NEWLINE> <DEDENT> elif solve ( dp , a , i + 1 , m ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> elif solve ( dp , a , i + 1 , m - a [ i ] ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ m ] = False <NEWLINE> <NL> <DEDENT> return dp [ i ] [ m ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = { } <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> dp [ i ] = { } <NEWLINE> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( dp , A , 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L1 = list ( ) <NEWLINE> D2 = dict ( ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> num1 = i + 1 - A [ i ] <NEWLINE> num2 = i + 1 + A [ i ] <NEWLINE> L1 . append ( num1 ) <NEWLINE> if num2 not in D2 : <NEWLINE> <INDENT> D2 [ num2 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D2 [ num2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ret = 0 <NEWLINE> retlist = dict ( ) <NEWLINE> for l in L1 : <NEWLINE> <INDENT> if l in D2 . keys ( ) : <NEWLINE> <INDENT> ret += D2 [ l ] <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += str ( b [ i ] ) + <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> pt = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> ans = collections . Counter ( pt ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if k - q + ans [ i + 1 ] >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> lim = 10 ** 18 <NEWLINE> flag = True <NEWLINE> <NL> ans = a [ 0 ] <NEWLINE> <NL> if a . count ( 0 ) >= 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > lim : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> bc = B // C <NEWLINE> ac = ( A - 1 ) // C <NEWLINE> cnum = bc - ac <NEWLINE> <NL> bd = B // D <NEWLINE> ad = ( A - 1 ) // D <NEWLINE> dnum = bd - ad <NEWLINE> <NL> <NL> lcmcd = lcm ( C , D ) <NEWLINE> blcmcd = B // lcmcd <NEWLINE> alcmcd = ( A - 1 ) // lcmcd <NEWLINE> lcmcdnum = blcmcd - alcmcd <NEWLINE> <NL> <NL> print ( B - A - cnum - dnum + lcmcdnum + 1 ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t , u = a [ 0 ] , a [ 1 ] <NEWLINE> <NL> def c ( x , y ) : <NEWLINE> <INDENT> if x % y : <NEWLINE> <INDENT> return ( c ( y , x % y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ( t , u ) ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 2 , int ( p ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while p % i == 0 : <NEWLINE> <INDENT> p /= i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> l . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if p != 1 : <NEWLINE> <INDENT> l . append ( [ p , 1 ] ) <NEWLINE> <NL> <DEDENT> for i , j in l : <NEWLINE> <INDENT> while j >= n : <NEWLINE> <INDENT> ans *= i <NEWLINE> j -= n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ tuple ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> c = Counter ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Co = Counter ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> ans = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = BC [ i ] <NEWLINE> ans += ( ( C - B ) * Co [ B ] ) <NEWLINE> print ( ans ) <NEWLINE> Co [ C ] += Co [ B ] <NEWLINE> Co [ B ] = 0 <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> length = len ( s ) <NEWLINE> count_dict = { } <NEWLINE> <NL> <STRING> <NEWLINE> <NL> num = int ( s ) % 2019 <NEWLINE> count_dict [ num ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 1 , length ) : <NEWLINE> <INDENT> num = ( num - int ( s [ - i ] ) * pow ( 10 , ( i - 1 ) , 2019 ) ) % 2019 <NEWLINE> <COMMENT> <NL> if num not in count_dict : <NEWLINE> <INDENT> count_dict [ num ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count_dict [ num ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for k , v in count_dict . items ( ) : <NEWLINE> <INDENT> count += v * ( v - 1 ) / 2 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> count += v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( count ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> ans = [ str ( i ) for i in range ( 10 ** ( N - 1 ) , 10 ** N ) ] <NEWLINE> check = [ 1 for i in range ( 10 ** ( N - 1 ) , 10 ** N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> ans . insert ( 0 , <STRING> ) <NEWLINE> check . insert ( 0 , 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> for idx , j in enumerate ( ans ) : <NEWLINE> <INDENT> if j [ s ] != str ( c ) : <NEWLINE> <INDENT> check [ idx ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for idx , i in enumerate ( check ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> print ( ans [ idx ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <NL>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> a = [ ] <NEWLINE> for i , ai in enumerate ( a_ ) : <NEWLINE> <INDENT> a . append ( [ 1 + i , ai ] ) <NEWLINE> <DEDENT> a . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> dp = np . zeros ( ( n + 1 , n + 1 ) , np . int64 ) <COMMENT> <NEWLINE> dp [ 1 , 1 ] = a [ 0 ] [ 1 ] * ( n - a [ 0 ] [ 0 ] ) <NEWLINE> dp [ 1 , 0 ] = a [ 0 ] [ 1 ] * ( a [ 0 ] [ 0 ] - 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> dp [ i , 0 ] = dp [ i - 1 , 0 ] + a [ i - 1 ] [ 1 ] * abs ( ( a [ i - 1 ] [ 0 ] - 1 - ( i - 1 ) ) ) <COMMENT> <NEWLINE> dp [ i , i ] = dp [ i - 1 , i - 1 ] + a [ i - 1 ] [ 1 ] * abs ( ( n - a [ i - 1 ] [ 0 ] - ( i - 1 ) ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> l = dp [ i - 1 , 1 : i ] + [ a [ i - 1 ] [ 1 ] * abs ( ( a [ i - 1 ] [ 0 ] - 1 - j ) ) for j in range ( i - 2 , - 1 , - 1 ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> r = dp [ i - 1 , : i - 1 ] + [ a [ i - 1 ] [ 1 ] * abs ( ( n - a [ i - 1 ] [ 0 ] - j ) ) for j in range ( i - 1 ) ] <COMMENT> <NEWLINE> dp [ i , 1 : i ] = np . maximum ( l , r ) <NEWLINE> <DEDENT> print ( max ( dp [ n ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 30 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> def dfs ( x , score ) : <NEWLINE> <INDENT> for y in Tree [ x ] : <NEWLINE> <INDENT> if Parent [ x ] != y : <NEWLINE> <INDENT> Parent [ y ] = x <NEWLINE> score [ y ] += score [ x ] <NEWLINE> dfs ( y , score ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Tree = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> Parent = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Tree [ a ] . append ( b ) <NEWLINE> Tree [ b ] . append ( a ) <NEWLINE> <DEDENT> score = [ 0 ] * ( N + 1 ) <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p ] += x <NEWLINE> <DEDENT> dfs ( 1 , score ) <NEWLINE> print ( * score [ 1 : ] , end = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = set ( A ) <NEWLINE> M = max ( A ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> pre_a = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == pre_a : <NEWLINE> <INDENT> S . discard ( a ) <NEWLINE> <DEDENT> if a in S : <NEWLINE> <INDENT> j = a * 2 <NEWLINE> while j <= M : <NEWLINE> <INDENT> S . discard ( j ) <NEWLINE> j += a <NEWLINE> <DEDENT> <DEDENT> pre_a = a <NEWLINE> <NL> <DEDENT> print ( len ( S ) ) <NEWLINE>
s = [ int ( j ) for j in input ( ) ] [ : : - 1 ] <NEWLINE> c = [ 0 ] * 2019 <NEWLINE> tmp = 0 <NEWLINE> c [ 0 ] += 1 <NEWLINE> t = 1 <NEWLINE> import numpy as np <NEWLINE> for i in s : <NEWLINE> <INDENT> tmp += t * i <NEWLINE> c [ tmp % 2019 ] += 1 <NEWLINE> t = t * 10 % 2019 <NEWLINE> <DEDENT> c = np . array ( c ) <NEWLINE> ans = c * ( c - 1 ) // 2 <NEWLINE> print ( ans . sum ( ) ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lis = [ 1 ] * ( 201 ) <NEWLINE> for p in P : lis [ p + 99 ] -= 1 <NEWLINE> <NL> for i in range ( 100 + 1 ) : <NEWLINE> <INDENT> up = X + i <NEWLINE> down = X - i <NEWLINE> if lis [ 100 + down - 1 ] == 1 : <NEWLINE> <INDENT> print ( down ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif lis [ 100 + up - 1 ] == 1 : <NEWLINE> <INDENT> print ( up ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<NL> from heapq import heappop , heappush <NEWLINE> from functools import lru_cache <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def manhattan ( size , i , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dn , mn = divmod ( n - 1 , size ) <NEWLINE> di , mi = divmod ( i , size ) <NEWLINE> return abs ( dn - di ) + abs ( mn - mi ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Board : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , size , nums , code = None ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . nums = nums <NEWLINE> self . _hash = hash ( nums ) <NEWLINE> if code is None : <NEWLINE> <INDENT> self . code = sum ( [ manhattan ( self . size , i , n ) <NEWLINE> <INDENT> for i , n in enumerate ( self . nums ) if n != i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . code = code <NEWLINE> <NL> <DEDENT> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> return self . code == other . code <NEWLINE> <NL> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . code < other . code <NEWLINE> <NL> <DEDENT> def __gt__ ( self , other ) : <NEWLINE> <INDENT> return self . code > other . code <NEWLINE> <NL> <DEDENT> def __hash__ ( self ) : <NEWLINE> <INDENT> return self . _hash <NEWLINE> <NL> <DEDENT> def same ( self , other ) : <NEWLINE> <INDENT> if other is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . __class__ != other . __class__ : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( self . size * self . size ) : <NEWLINE> <INDENT> if self . nums [ i ] != other . nums [ i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solved ( self ) : <NEWLINE> <INDENT> for i in range ( self . size * self . size ) : <NEWLINE> <INDENT> if self . nums [ i ] > 0 and self . nums [ i ] - 1 != i : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def find ( self , num ) : <NEWLINE> <INDENT> for i in range ( self . size * self . size ) : <NEWLINE> <INDENT> if self . nums [ i ] == num : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> raise IndexError ( ) <NEWLINE> <NL> <DEDENT> def move ( self , p1 , p2 ) : <NEWLINE> <INDENT> nums = list ( self . nums ) <NEWLINE> v1 , v2 = nums [ p1 ] , nums [ p2 ] <NEWLINE> code = ( self . code - manhattan ( self . size , p1 , v1 ) <NEWLINE> <INDENT> - manhattan ( self . size , p2 , v2 ) <NEWLINE> + manhattan ( self . size , p2 , v1 ) <NEWLINE> + manhattan ( self . size , p1 , v2 ) ) <NEWLINE> <DEDENT> nums [ p1 ] , nums [ p2 ] = v2 , v1 <NEWLINE> return self . __class__ ( self . size , tuple ( nums ) , code ) <NEWLINE> <NL> <DEDENT> def moves ( self ) : <NEWLINE> <INDENT> i = self . find ( 0 ) <NEWLINE> if i > self . size - 1 : <NEWLINE> <INDENT> yield self . move ( i , i - self . size ) <NEWLINE> <DEDENT> if i % self . size > 0 : <NEWLINE> <INDENT> yield self . move ( i , i - 1 ) <NEWLINE> <DEDENT> if i < self . size * ( self . size - 1 ) : <NEWLINE> <INDENT> yield self . move ( i , i + self . size ) <NEWLINE> <DEDENT> if ( i + 1 ) % self . size > 0 : <NEWLINE> <INDENT> yield self . move ( i , i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for i in range ( self . size * self . size ) : <NEWLINE> <INDENT> s += <STRING> . format ( self . nums [ i ] ) <NEWLINE> if ( i + 1 ) % self . size == 0 : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <DEDENT> <DEDENT> class FifteenPuzzle : <NEWLINE> <INDENT> def __init__ ( self , board , maxmove ) : <NEWLINE> <INDENT> self . board = board <NEWLINE> self . maxmove = maxmove <NEWLINE> if not board . solved ( ) : <NEWLINE> <INDENT> self . steps = self . _solve ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . steps = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def _solve ( self ) : <NEWLINE> <INDENT> bs = [ ] <NEWLINE> checked = set ( ) <NEWLINE> i = 0 <NEWLINE> heappush ( bs , ( self . board . code , self . board . code , i , self . board , 0 ) ) <NEWLINE> <NL> while len ( bs ) > 0 : <NEWLINE> <INDENT> w , _ , _ , b , step = heappop ( bs ) <NEWLINE> checked . add ( b ) <NEWLINE> step += 1 <NEWLINE> for nb in b . moves ( ) : <NEWLINE> <INDENT> if nb . solved ( ) : <NEWLINE> <INDENT> return step <NEWLINE> <DEDENT> elif self . maxmove < nb . code + step : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif nb in checked : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> heappush ( bs , ( nb . code + step , nb . code , i , nb , step ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> ns = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> ns . extend ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> board = Board ( 4 , tuple ( ns ) ) <NEWLINE> puzzle = FifteenPuzzle ( board , 45 ) <NEWLINE> print ( puzzle . steps ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
D , G = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> score_table = [ ] <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> p , c = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> score_table . append ( [ i * 100 , p , c ] ) <NEWLINE> <NL> <DEDENT> min_count = sum ( [ l [ 1 ] for l in score_table ] ) <NEWLINE> <COMMENT> <NL> <NL> for bit in range ( 1 << D ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> score += score_table [ i ] [ 0 ] * score_table [ i ] [ 1 ] + score_table [ i ] [ 2 ] <NEWLINE> count += score_table [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if score >= G : <NEWLINE> <INDENT> min_count = min ( min_count , count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> additional = [ ] <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if not bit & ( 1 << j ) : <NEWLINE> <INDENT> additional . append ( score_table [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> additional_ = sorted ( additional , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> add_score = additional_ [ 0 ] <NEWLINE> <NL> for k in range ( add_score [ 1 ] - 1 ) : <NEWLINE> <INDENT> score += add_score [ 0 ] <NEWLINE> count += 1 <NEWLINE> if score >= G : <NEWLINE> <INDENT> min_count = min ( min_count , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min_count ) <NEWLINE>
import numpy as np <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> N , S = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = ( 0 , * map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> dp = np . zeros ( shape = ( N + 1 , S + 1 ) , dtype = int ) <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> dp [ i ] = 2 * dp [ i - 1 ] % MOD <NEWLINE> dp [ i ] [ a : ] += dp [ i - 1 ] [ : - a ] <NEWLINE> dp [ i ] %= MOD <NEWLINE> <NL> <DEDENT> print ( dp [ N ] [ S ] ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p_int_list = [ ] <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_int_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> p_int_set = set ( p_int_list ) <NEWLINE> <NL> if X not in p_int_set : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 10000 ) : <NEWLINE> <INDENT> if X - i not in p_int_set : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif X + i not in p_int_set : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( n , m , h , a , b ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> a [ j ] -= 1 <NEWLINE> b [ j ] -= 1 <NEWLINE> <DEDENT> E = { i : [ ] for i in range ( n ) } <NEWLINE> for x , y in zip ( a , b ) : <NEWLINE> <INDENT> E [ x ] . append ( y ) <NEWLINE> E [ y ] . append ( x ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ok = True <NEWLINE> for j in E [ i ] : <NEWLINE> <INDENT> if h [ i ] <= h [ j ] : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> ans += ok <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a [ j ] , b [ j ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( solve ( n , m , h , a , b ) ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> W , H = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if not W : break <NEWLINE> tx , ty = map ( int , input ( ) . split ( ) ) <NEWLINE> kx , ky = map ( int , input ( ) . split ( ) ) <NEWLINE> ma = [ [ False ] * ( W + 2 ) for _ in range ( H + 2 ) ] <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j , a in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> ma [ i ] [ j + 1 ] = bool ( 1 - int ( a ) ) <NEWLINE> <DEDENT> <DEDENT> from pprint import pprint <NEWLINE> que = deque ( [ [ tx , ty , kx , ky , 0 ] ] ) <NEWLINE> <COMMENT> <NL> pas = set ( ) <NEWLINE> ans = <STRING> <NEWLINE> while ( que ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> tx , ty , kx , ky , c = que . popleft ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if c > 100 : break <NEWLINE> if tx == kx and ty == ky : <NEWLINE> <INDENT> ans = c <NEWLINE> break <NEWLINE> <DEDENT> for dx , dy in [ [ - 1 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> tdx , tdy = [ dx , dy ] if ma [ ty + dy ] [ tx + dx ] else [ 0 , 0 ] <NEWLINE> kdx , kdy = [ - dx , - dy ] if ma [ ky - dy ] [ kx - dx ] else [ 0 , 0 ] <NEWLINE> <COMMENT> <NL> if ( tx + tdx , ty + tdy , kx + kdx , ky + kdy ) in pas : continue <NEWLINE> que . append ( [ tx + tdx , ty + tdy , kx + kdx , ky + kdy , c + 1 ] ) <NEWLINE> <COMMENT> <NL> pas . add ( ( tx + tdx , ty + tdy , kx + kdx , ky + kdy ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> r [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> [ print ( r [ i ] ) for i in range ( n ) ] <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = { } <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> ans [ str ( b ) ] = 1 <NEWLINE> <DEDENT> elif H [ b - 1 ] > H [ a - 1 ] : <NEWLINE> <INDENT> ans [ str ( a ) ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ str ( a ) ] = 1 <NEWLINE> ans [ str ( b ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - len ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> num = [ 0 ] * 10 ** 5 <NEWLINE> a = sum ( A ) <NEWLINE> <NL> for i in A : <COMMENT> <NEWLINE> <INDENT> num [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = a + ( - num [ b - 1 ] * b + c * num [ b - 1 ] ) <NEWLINE> num [ c - 1 ] += num [ b - 1 ] <NEWLINE> num [ b - 1 ] -= num [ b - 1 ] <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <INDENT> cnt = gcd ( i , j , k ) <NEWLINE> if i == j and j == k : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <DEDENT> elif ( i == j and i != k ) or ( i == k and i != j ) or ( j == k and j != i ) : <NEWLINE> <INDENT> ans += cnt * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> box = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> box [ a - 1 ] . append ( b - 1 ) <NEWLINE> box [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> ans = [ None ] * ( N ) <NEWLINE> ans [ 0 ] = 0 <NEWLINE> que = [ 0 ] <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> index = que . pop ( 0 ) <NEWLINE> for x in box [ index ] : <NEWLINE> <INDENT> if ans [ x ] == None : <NEWLINE> <INDENT> ans [ x ] = index + 1 <NEWLINE> que . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import time <NEWLINE> start = time . time ( ) <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = [ 1 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if hs [ a ] < hs [ b ] : <NEWLINE> <INDENT> ans [ a ] = 0 <NEWLINE> <DEDENT> elif hs [ a ] == hs [ b ] : <NEWLINE> <INDENT> ans [ a ] = 0 <NEWLINE> ans [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ABmap = [ [ ] for i in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda x : x - 1 , map ( int , input ( ) . split ( ) ) ) <NEWLINE> ABmap [ A ] . append ( H [ B ] ) <NEWLINE> ABmap [ B ] . append ( H [ A ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if len ( ABmap [ i ] ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif max ( ABmap [ i ] ) < H [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> r , g , b = [ 0 ] * 3 <NEWLINE> for c in input ( ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> s . append ( 0 ) <NEWLINE> r += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> s . append ( 1 ) <NEWLINE> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( 2 ) <NEWLINE> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> c = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> L = defaultdict ( int ) <NEWLINE> R = defaultdict ( int ) <NEWLINE> <NL> for i , height in enumerate ( heights ) : <NEWLINE> <INDENT> L [ i + height ] += 1 <NEWLINE> R [ i - height ] += 1 <NEWLINE> <NL> <DEDENT> total_count = 0 <NEWLINE> for x , count_l in L . items ( ) : <NEWLINE> <INDENT> if x in R : <NEWLINE> <INDENT> count_r = R [ x ] <NEWLINE> total_count += count_l * count_r <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total_count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections , heapq , itertools , math , functools <NEWLINE> groupby = itertools . groupby <NEWLINE> rs = lambda : input ( ) <NEWLINE> ri = lambda : int ( input ( ) ) <NEWLINE> rm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> rai = lambda : [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = ri ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += i * n * ( n + 1 ) // 2 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in S : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= S [ i - 1 ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> AA = [ 0 ] <NEWLINE> BB = [ 0 ] <NEWLINE> r = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> r += i <NEWLINE> AA . append ( r ) <NEWLINE> <DEDENT> r = 0 <NEWLINE> for i in B : <NEWLINE> <INDENT> r += i <NEWLINE> BB . append ( r ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> a = N <NEWLINE> b = 0 <NEWLINE> while AA [ a ] + BB [ b ] > K : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> ans = a + b <NEWLINE> <NL> while a >= 0 : <NEWLINE> <INDENT> while b < M : <NEWLINE> <INDENT> if AA [ a ] + BB [ b + 1 ] <= K : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans < a + b : <NEWLINE> <INDENT> ans = a + b <NEWLINE> <DEDENT> if b == M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> import bisect <NEWLINE> <NL> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> b = [ 0 ] + b <NEWLINE> <COMMENT> <NL> a_accum = list ( accumulate ( a ) ) <NEWLINE> b_accum = list ( accumulate ( b ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in range ( len ( a_accum ) ) : <NEWLINE> <INDENT> nokori = k - a_accum [ i ] <NEWLINE> if nokori < 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> b_pos = bisect . bisect ( b_accum , nokori ) - 1 <NEWLINE> ans = max ( ans , i + b_pos ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> l = [ A [ 0 ] ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> l . append ( l [ - 1 ] + A [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += l [ i ] * A [ i + 1 ] % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , W = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> bagage = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> weight = [ ] <NEWLINE> value = [ ] <NEWLINE> for b in bagage : <NEWLINE> <INDENT> value . append ( b [ 0 ] ) <NEWLINE> weight . append ( b [ 1 ] ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * 10010 for i in range ( 110 ) ] <NEWLINE> <NL> for j in range ( W ) : <NEWLINE> <INDENT> dp [ N ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , W + 1 , 1 ) : <NEWLINE> <INDENT> if j < weight [ i ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i + 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - weight [ i ] ] + value [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ 0 ] [ W ] ) <NEWLINE>
A = <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while n - 26 ** i > 0 : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> i += 1 <NEWLINE> <DEDENT> name = [ ] <NEWLINE> n -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> temp = n % 26 <NEWLINE> name . append ( A [ temp ] ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> for k in name [ : : - 1 ] : print ( k , end = <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> r = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> pm = np . array ( [ 1 , - 1 ] * ( n // 2 ) + [ 1 ] ) <NEWLINE> <NL> <NL> d = [ ] <NEWLINE> tmp = sum ( r * pm ) <NEWLINE> d . append ( str ( tmp ) ) <NEWLINE> tmp -= r [ 0 ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tmp = r [ i ] - tmp <NEWLINE> d . append ( str ( tmp ) ) <NEWLINE> tmp -= r [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( d ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 12 <NEWLINE> dp = [ INF ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) for j in range ( 1 , min ( K , i ) + 1 ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> it = lambda : list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N , X , M = it ( ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> return X % M <NEWLINE> <DEDENT> value = defaultdict ( int ) <NEWLINE> history = defaultdict ( int ) <NEWLINE> cur = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X in history : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> value [ X ] = cur <NEWLINE> history [ X ] = i <NEWLINE> cnt += 1 <NEWLINE> cur += X <NEWLINE> X = X * X % M <NEWLINE> <DEDENT> period = i - history [ X ] <NEWLINE> cur += ( N - cnt ) // period * ( cur - value [ X ] ) <NEWLINE> for i in range ( ( N - cnt ) % period ) : <NEWLINE> <INDENT> cur += X <NEWLINE> X = X * X % M <NEWLINE> <DEDENT> return cur <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = collections . Counter ( A ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if A [ i ] == 1 : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C . append ( i ) <NEWLINE> <DEDENT> <DEDENT> B = sorted ( B ) <NEWLINE> if len ( B ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mb = 1000000 <NEWLINE> ok = [ True ] * ( mb + 1 ) <NEWLINE> <NL> if len ( C ) > 0 : <NEWLINE> <INDENT> C = sorted ( C ) <NEWLINE> for c in C : <NEWLINE> <INDENT> if not ok [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 <NEWLINE> while k * c <= mb : <NEWLINE> <INDENT> ok [ k * c ] = False <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for b in B : <NEWLINE> <INDENT> if not ok [ b ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 <NEWLINE> while k * b <= mb : <NEWLINE> <INDENT> ok [ k * b ] = False <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> if ok [ b ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> bs = M <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( bs , - 1 , - 1 ) : <NEWLINE> <INDENT> if b [ j ] + a [ i ] <= K : <NEWLINE> <INDENT> bs = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , i + bs ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> cnt_init = X . count ( <STRING> ) <NEWLINE> x_init = int ( X , 2 ) <NEWLINE> a = x_init % ( cnt_init + 1 ) <NEWLINE> if cnt_init - 1 != 0 : <NEWLINE> <INDENT> b = x_init % ( cnt_init - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> cnt = cnt_init + 1 <NEWLINE> x = ( a + pow ( 2 , ( n - i - 1 ) , cnt ) ) % cnt <NEWLINE> res = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = cnt_init - 1 <NEWLINE> if cnt != 0 : <NEWLINE> <INDENT> x = ( b - pow ( 2 , ( n - i - 1 ) , cnt ) ) % cnt <NEWLINE> res = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 0 <NEWLINE> res = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> while x : <NEWLINE> <INDENT> cnt = bin ( x ) . count ( <STRING> ) <NEWLINE> x %= cnt <NEWLINE> res += 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> sumAcol = 0 <NEWLINE> sumA = 0 <NEWLINE> sumtr = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sumtr += A [ i ] ** 2 <NEWLINE> sumAcol += A [ i ] <NEWLINE> sumtr = sumtr % ( 10 ** 9 + 7 ) <NEWLINE> sumAcol = sumAcol % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> sumA += ( sumAcol * A [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> sumA = ( sumA - sumtr ) + 10 ** 9 + 7 <NEWLINE> <NL> print ( sumA * ( 5 * 10 ** 8 + 4 ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> roads = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> city = 1 <NEWLINE> route = [ ] <NEWLINE> cnt = [ 0 ] * n <NEWLINE> cnt [ 0 ] += 1 <NEWLINE> route . append ( 1 ) <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> city = roads [ city - 1 ] <NEWLINE> cnt [ city - 1 ] += 1 <NEWLINE> if cnt [ city - 1 ] == 2 : <NEWLINE> <INDENT> st = route . index ( city ) <NEWLINE> length = len ( route ) - st <NEWLINE> break <NEWLINE> <DEDENT> route . append ( city ) <NEWLINE> <NL> <NL> <DEDENT> if k < len ( route ) : <NEWLINE> <INDENT> print ( route [ k ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> amari = ( k + 1 - st ) % length <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> print ( route [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( route [ amari + st - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = collections . Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( int ( input ( ) ) - 1 ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if now == 1 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> if c >= n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> now = arr [ now ] <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if <STRING> in str ( N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nums = [ 0 ] * n <NEWLINE> nums [ k - 1 ] = sum ( a [ : k ] ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> nums [ i ] = nums [ i - 1 ] + a [ i ] - a [ i - k ] <NEWLINE> <NL> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> if nums [ i - 1 ] < nums [ i ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> class Unionfind : <NEWLINE> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . uf = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . uf [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . uf [ x ] = self . find ( self . uf [ x ] ) <NEWLINE> return self . uf [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . uf [ x ] > self . uf [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . uf [ x ] += self . uf [ y ] <NEWLINE> self . uf [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> return - self . uf [ x ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> d = Unionfind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> L = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = d . find ( i ) <NEWLINE> L . append ( c ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( len ( set ( L ) ) - 1 ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( accumulate ( a ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> sum += a [ i ] * ( b [ - 1 ] - b [ i ] ) <NEWLINE> sum %= 10 ** 9 + 7 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
a , b = [ ] , [ ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a += [ x - y ] <NEWLINE> b += [ x + y ] <NEWLINE> <DEDENT> print ( max ( max ( a ) - min ( a ) , max ( b ) - min ( b ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <NL> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n . count ( n [ 0 ] ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> while n != <STRING> : <NEWLINE> <INDENT> n , l = sorted ( list ( n ) ) , sorted ( list ( n ) , reverse = True ) <NEWLINE> n = str ( int ( <STRING> . join ( l ) ) - int ( <STRING> . join ( n ) ) ) . zfill ( 4 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
def solve ( s ) : <NEWLINE> <INDENT> dp = [ 0 ] * 2019 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> r = 0 <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> r += int ( s [ - i ] ) * pow ( 10 , i - 1 , 2019 ) <NEWLINE> r %= 2019 <NEWLINE> dp [ r ] += 1 <NEWLINE> <DEDENT> res = 0 <NEWLINE> for r in range ( 2019 ) : <NEWLINE> <INDENT> res += dp [ r ] * ( dp [ r ] - 1 ) // 2 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> res = solve ( s ) <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> assert solve ( <STRING> ) == 3 <NEWLINE> assert solve ( <STRING> ) == 2 <NEWLINE> assert solve ( <STRING> ) == 0 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> if s [ 1 ] - s [ 3 ] == 0 or s [ 5 ] - s [ 7 ] == 0 : <NEWLINE> <INDENT> if s [ 1 ] - s [ 3 ] == s [ 5 ] - s [ 7 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif abs ( ( s [ 0 ] - s [ 2 ] ) / ( s [ 1 ] - s [ 3 ] ) - ( s [ 4 ] - s [ 6 ] ) / ( s [ 5 ] - s [ 7 ] ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for x in ls : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ a - 1 ] = max ( A [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> A [ b - 1 ] = max ( A [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> res = sum ( [ H [ i ] > A [ i ] for i in range ( N ) ] ) <NEWLINE> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s in ans . keys ( ) : <NEWLINE> <INDENT> ans [ s ] = 1 <NEWLINE> <DEDENT> ans [ s ] += 1 <NEWLINE> <DEDENT> print ( len ( ans . keys ( ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> m = i * ( i - 1 ) // 2 <NEWLINE> M = i * n - ( i * ( i - 1 ) ) // 2 <NEWLINE> total += M - m + 1 <NEWLINE> <DEDENT> print ( total % ( 10 ** 9 + 7 ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> S = ( input ( ) ) . split ( ) <NEWLINE> n = int ( S [ 0 ] ) <NEWLINE> q = int ( S [ 1 ] ) <NEWLINE> head = 0 <NEWLINE> tail = n - 1 <NEWLINE> que = [ ] <NEWLINE> runtime = 0 <NEWLINE> fin = [ ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> que . append ( ( input ( ) ) . split ( ) ) <NEWLINE> <NL> <DEDENT> while head <= tail : <NEWLINE> <INDENT> nowjob = que [ head ] <NEWLINE> jobtime = int ( nowjob [ 1 ] ) <NEWLINE> if jobtime > q : <NEWLINE> <INDENT> jobtime = jobtime - q <NEWLINE> jobname = nowjob [ 0 ] <NEWLINE> que . append ( [ jobname , jobtime ] ) <NEWLINE> runtime = runtime + q <NEWLINE> head = head + 1 <NEWLINE> tail = tail + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> runtime = runtime + jobtime <NEWLINE> fin . append ( [ ( que [ head ] ) [ 0 ] , runtime ] ) <NEWLINE> head = head + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> print ( <STRING> . format ( ( fin [ i ] ) [ 0 ] , ( fin [ i ] ) [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> from collections import Counter <NEWLINE> cx = Counter ( x ) <NEWLINE> cxmod = { } <NEWLINE> for k in cx : <NEWLINE> <INDENT> if k % m in cxmod : <NEWLINE> <INDENT> cxmod [ k % m ] += cx [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cxmod [ k % m ] = cx [ k ] <NEWLINE> <DEDENT> <DEDENT> keys = cxmod . keys ( ) <NEWLINE> ans1 , ans2 = 0 , 0 <COMMENT> <NEWLINE> for k in keys : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k == m - k : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> elif m - k in keys : <NEWLINE> <INDENT> tmp = min ( cxmod [ k ] , cxmod [ m - k ] ) <NEWLINE> ans1 += tmp <NEWLINE> cxmod [ k ] -= tmp <NEWLINE> cxmod [ m - k ] -= tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in cx : <NEWLINE> <INDENT> v = cx [ k ] <NEWLINE> if v >= 2 and cxmod [ k % m ] >= 2 : <NEWLINE> <INDENT> tmp = min ( v // 2 , cxmod [ k % m ] // 2 ) <NEWLINE> ans2 += tmp <NEWLINE> cxmod [ k % m ] -= tmp * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans1 + ans2 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
cnt = 0 <NEWLINE> def merge ( S , left , right , mid ) : <NEWLINE> <INDENT> a = mid - left <NEWLINE> b = right - mid <NEWLINE> L = S [ left : left + a ] + [ float ( <STRING> ) ] <NEWLINE> R = S [ mid : mid + b ] + [ float ( <STRING> ) ] <NEWLINE> j = 0 <NEWLINE> k = 0 <NEWLINE> for i in range ( left , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt += 1 <NEWLINE> if L [ j ] <= R [ k ] : <NEWLINE> <INDENT> S [ i ] = L [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ i ] = R [ k ] <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( S , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( int ) ( ( left + right ) / 2 ) <NEWLINE> mergeSort ( S , left , mid ) <NEWLINE> mergeSort ( S , mid , right ) <NEWLINE> merge ( S , left , right , mid ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( S , 0 , n ) <NEWLINE> print ( * S ) <NEWLINE> print ( cnt ) <NEWLINE>
<NL> x , k , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if x >= 0 : <NEWLINE> <INDENT> capa_iter = x // d <NEWLINE> if capa_iter < k : <NEWLINE> <INDENT> if ( k - capa_iter ) % 2 == 0 : <NEWLINE> <INDENT> print ( x - capa_iter * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( [ abs ( x - capa_iter * d - d ) , x - capa_iter * d + d ] ) ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> ans = x - d * k <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if x < 0 : <NEWLINE> <INDENT> capa_iter = abs ( - x // d ) <NEWLINE> if capa_iter < k : <NEWLINE> <INDENT> if ( k - capa_iter ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x + capa_iter * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( [ abs ( x + capa_iter * d + d ) , abs ( x + capa_iter * d - d ) ] ) ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> ans = abs ( x + d * k ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> sum_a = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_a -= a [ i ] <NEWLINE> ans += sum_a * a [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> v_even = [ 0 ] * 100000 <NEWLINE> v_odd = [ 0 ] * 100000 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> v_even [ v [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v_odd [ v [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res1 = max ( v_even ) <NEWLINE> res2 = max ( v_odd ) <NEWLINE> if v_even . index ( res1 ) == v_odd . index ( res2 ) : <NEWLINE> <INDENT> if res1 > res2 : <NEWLINE> <INDENT> v_odd [ v_odd . index ( res2 ) ] = 0 <NEWLINE> res2 = max ( v_odd ) <NEWLINE> <DEDENT> elif res2 > res1 : <NEWLINE> <INDENT> v_even [ v_even . index ( res1 ) ] = 0 <NEWLINE> res1 = max ( v_even ) <NEWLINE> <DEDENT> elif res1 == res2 : <NEWLINE> <INDENT> v_odd [ v_odd . index ( res2 ) ] = 0 <NEWLINE> v_even [ v_even . index ( res1 ) ] = 0 <NEWLINE> res3 = max ( v_even ) <NEWLINE> res4 = max ( v_odd ) <NEWLINE> if res3 > res4 : <NEWLINE> <INDENT> res1 = res3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res2 = res4 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n // 2 - res1 + n // 2 - res2 ) <NEWLINE>
N , M = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> H = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> paths = [ ] <NEWLINE> max_neighbor = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for _m in range ( M ) : <NEWLINE> <INDENT> path = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> path = int ( path [ 0 ] ) , int ( path [ 1 ] ) <NEWLINE> max_neighbor [ path [ 0 ] - 1 ] = max ( max_neighbor [ path [ 0 ] - 1 ] , H [ path [ 1 ] - 1 ] ) <NEWLINE> max_neighbor [ path [ 1 ] - 1 ] = max ( max_neighbor [ path [ 1 ] - 1 ] , H [ path [ 0 ] - 1 ] ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if max_neighbor [ n ] < H [ n ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
T = int ( input ( ) ) <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> dp = [ ] <NEWLINE> for j in reversed ( range ( n ) ) : <NEWLINE> <INDENT> a = A [ j ] <NEWLINE> for x in dp : <NEWLINE> <INDENT> a = min ( a , a ^ x ) <NEWLINE> <DEDENT> if a > 0 : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> dp . append ( a ) <NEWLINE> <DEDENT> elif not A [ j ] in dp : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> s = input ( ) <NEWLINE> slen = len ( s ) <NEWLINE> <NL> sl = collections . deque ( list ( s ) ) <NEWLINE> sl_inv = collections . deque ( list ( s [ : : - 1 ] ) ) <NEWLINE> cnt = 0 <NEWLINE> while len ( sl ) > 0 : <NEWLINE> <INDENT> if sl [ 0 ] == sl_inv [ 0 ] : <NEWLINE> <INDENT> sl . popleft ( ) <NEWLINE> sl_inv . popleft ( ) <NEWLINE> <DEDENT> elif sl [ 0 ] == <STRING> and sl_inv [ 0 ] != <STRING> : <NEWLINE> <INDENT> sl . popleft ( ) <NEWLINE> <DEDENT> elif sl [ 0 ] != <STRING> and sl_inv [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> sl_inv . popleft ( ) <NEWLINE> <DEDENT> elif sl [ 0 ] != <STRING> and sl_inv [ 0 ] != <STRING> and sl [ 0 ] != sl_inv [ 0 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( sl_inv ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( cnt + len ( sl_inv ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> move = 1 <NEWLINE> l = [ 1 ] <NEWLINE> flag = [ False ] * ( N + 1 ) <NEWLINE> flag [ 1 ] = True <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> move = A [ move - 1 ] <NEWLINE> if flag [ move ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> flag [ move ] = True <NEWLINE> l . append ( move ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ind = l . index ( move ) <NEWLINE> <COMMENT> <NL> rest = ( K - ind ) % ( len ( l ) - ind ) + ind <NEWLINE> <NL> <COMMENT> <NL> print ( l [ rest ] ) <NEWLINE>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = [ ] <NEWLINE> if a + b + c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b + c == 1 : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> current = 0 <NEWLINE> <DEDENT> if b == 1 : <NEWLINE> <INDENT> current = 1 <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> current = 2 <NEWLINE> <DEDENT> breakflag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if current == 2 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current = 1 - current <NEWLINE> k . append ( current ) <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if current == 1 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current = 2 - current <NEWLINE> k . append ( current ) <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if current == 0 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current = 3 - current <NEWLINE> k . append ( current ) <NEWLINE> <DEDENT> <DEDENT> if breakflag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if k [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k [ j ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif a + b + c == 2 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> breakflag = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s2 = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> elif b > a : <NEWLINE> <INDENT> b -= 1 <NEWLINE> a += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s2 == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> elif a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> elif c > a : <NEWLINE> <INDENT> c -= 1 <NEWLINE> a += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s2 == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if b == 0 and c == 0 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> elif b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> elif c > b : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s2 == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if breakflag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> s = s2 <NEWLINE> <DEDENT> if breakflag == 0 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> breakflag = 1 <NEWLINE> <DEDENT> elif a >= b : <NEWLINE> <INDENT> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> breakflag = 1 <NEWLINE> <DEDENT> elif a >= c : <NEWLINE> <INDENT> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> breakflag = 1 <NEWLINE> <DEDENT> elif b >= c : <NEWLINE> <INDENT> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if breakflag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> breakflag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> a -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> elif a < c : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> a -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if b == 0 and c == 0 : <NEWLINE> <INDENT> breakflag = 1 <NEWLINE> <DEDENT> elif b < c : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> k . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if breakflag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if breakflag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> <DEDENT> cnt = min ( k , x // d + 1 ) <NEWLINE> x -= cnt * d <NEWLINE> if abs ( x ) < x + d : <NEWLINE> <INDENT> x += d <NEWLINE> cnt -= 1 <NEWLINE> x -= d * ( ( k - cnt ) % 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += d * ( ( k - cnt ) % 2 ) <NEWLINE> <DEDENT> print ( abs ( x ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_sum = 0 <NEWLINE> temp_sum_num = sum ( A ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> temp_sum_num -= A [ i ] <NEWLINE> num_sum += A [ i ] * temp_sum_num <NEWLINE> <NL> <NL> <DEDENT> num_sum = num_sum % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( num_sum ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 0 , 200 ) : <NEWLINE> <INDENT> a5 = a ** 5 <NEWLINE> b5 = a5 - x <NEWLINE> if b5 >= 0 : <NEWLINE> <INDENT> b = int ( float ( b5 ) ** 0.2 ) <NEWLINE> if b ** 5 == b5 : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b5 = - b5 <NEWLINE> b = int ( float ( b5 ) ** 0.2 ) <NEWLINE> if b ** 5 == b5 : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT>
def reduce ( arr , n ) : <NEWLINE> <INDENT> count = len ( arr ) * ( len ( arr ) - 1 ) * ( n - len ( arr ) ) / 2 + len ( arr ) * ( len ( arr ) - 1 ) * ( len ( arr ) - 2 ) / 6 <NEWLINE> return count <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r , g , b = [ ] , [ ] , [ ] <NEWLINE> <NL> for i , j in enumerate ( s ) : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif j == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = n * ( n - 1 ) * ( n - 2 ) / 6 <NEWLINE> count -= reduce ( r , n ) <NEWLINE> count -= reduce ( g , n ) <NEWLINE> count -= reduce ( b , n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if j + ( j - i ) < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ j + ( j - i ) ] and s [ i ] != s [ j + ( j - i ) ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( count ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> from math import gcd <NEWLINE> from operator import add , itemgetter , mul , xor <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> bunshi = 1 <NEWLINE> bunbo = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> bunbo = bunbo * ( i + 1 ) % mod <NEWLINE> bunshi = bunshi * ( n - i ) % mod <NEWLINE> <DEDENT> return ( bunshi * pow ( bunbo , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = MI ( ) <NEWLINE> a = LI ( ) <NEWLINE> <NL> def cutting_isOK ( x , li , k ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += math . ceil ( li [ i ] / x ) - 1 <NEWLINE> <DEDENT> if ans <= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> left = 0 <NEWLINE> right = 10 ** 9 + 1 <NEWLINE> <COMMENT> <NL> while right != left + 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if cutting_isOK ( mid , a , k ) : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> print ( right ) <NEWLINE> <NL>
S = str ( input ( ) ) <NEWLINE> <NL> _sum = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <NL> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> _sum += 1 <NEWLINE> <NL> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> ans += _sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> cy , cx = map ( int , input ( ) . split ( ) ) <NEWLINE> dy , dx = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> M = [ <STRING> + input ( ) + <STRING> for x in range ( h ) ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> M . insert ( 0 , <STRING> * ( w + 4 ) ) <NEWLINE> M . append ( <STRING> * ( w + 4 ) ) <NEWLINE> <NL> <DEDENT> C = [ [ - 1 if M [ j ] [ i ] == <STRING> else - 2 for i in range ( w + 4 ) ] for j in range ( h + 4 ) ] <NEWLINE> C [ - ~ cy ] [ - ~ cx ] = 0 <NEWLINE> QA , QB = deque ( ) , deque ( ) <NEWLINE> QA . append ( ( - ~ cy , - ~ cx , 0 ) ) <NEWLINE> W = [ [ i , j ] for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) if abs ( i ) + abs ( j ) > 1 ] <NEWLINE> <NL> while QA : <NEWLINE> <INDENT> h , w , c = QA . popleft ( ) <NEWLINE> QB . append ( ( h , w , c ) ) <NEWLINE> <NL> for i , j in [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> dh , dw = h + i , w + j <NEWLINE> if C [ dh ] [ dw ] == - 1 : <NEWLINE> <INDENT> C [ dh ] [ dw ] = c <NEWLINE> QA . appendleft ( ( dh , dw , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if QA : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> while QB : <NEWLINE> <INDENT> h , w , c = QB . popleft ( ) <NEWLINE> for i , j in W : <NEWLINE> <INDENT> dh , dw = h + i , w + j <NEWLINE> if C [ dh ] [ dw ] == - 1 : <NEWLINE> <INDENT> C [ dh ] [ dw ] = - ~ c <NEWLINE> QA . append ( ( dh , dw , - ~ c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( C [ - ~ dy ] [ - ~ dx ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> pq = { } <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> a1 , b1 = ab [ i ] <NEWLINE> a2 , b2 = ab [ j ] <NEWLINE> p = a1 - a2 <NEWLINE> q = b1 - b2 <NEWLINE> if p < 0 or p == 0 and q < 0 : <NEWLINE> <INDENT> p = - p <NEWLINE> q = - q <NEWLINE> <DEDENT> if ( p , q ) in pq : <NEWLINE> <INDENT> pq [ ( p , q ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pq [ ( p , q ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n - max ( pq . values ( ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = N * [ 0 ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> B [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * B , sep = <STRING> ) <NEWLINE>
s = <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while ( n > 0 ) : <NEWLINE> <INDENT> r = n % 26 <NEWLINE> if r == 0 : <NEWLINE> <INDENT> r = 26 <NEWLINE> <DEDENT> ans = s [ r ] + ans <NEWLINE> n -= r <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> alis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if ( alis [ i ] < alis [ i + k ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> A_dict = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> A_dict [ a ] += 1 <NEWLINE> <NL> <DEDENT> A_sum = sum ( A ) <NEWLINE> for b , c in zip ( B , C ) : <NEWLINE> <INDENT> n = A_dict [ b ] <NEWLINE> A_dict [ b ] = 0 <NEWLINE> A_dict [ c ] += n <NEWLINE> A_sum += ( c - b ) * n <NEWLINE> print ( A_sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> zoro = 0 <NEWLINE> aru = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == y [ i ] : <NEWLINE> <INDENT> zoro += 1 <NEWLINE> if zoro == 3 : <NEWLINE> <INDENT> aru = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> zoro = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if aru == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( a - 1 ) : <NEWLINE> <INDENT> if b [ i ] > b [ i + 1 ] : <NEWLINE> <INDENT> c = c + b [ i ] - b [ i + 1 ] <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cntR , cntG , cntB = S . count ( <STRING> ) , S . count ( <STRING> ) , S . count ( <STRING> ) <NEWLINE> <NL> ans = cntR * cntG * cntB <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ k ] != S [ i ] and S [ k ] != S [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ 0 ] * K <NEWLINE> R = [ 0 ] * K <NEWLINE> for i in range ( 0 , K ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> moves = [ 0 ] * N <NEWLINE> moves [ 0 ] = 1 <NEWLINE> <NL> rui_wa = [ 0 ] * N <NEWLINE> rui_wa [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( 0 , K ) : <NEWLINE> <INDENT> l = max ( i - L [ j ] , 0 ) <NEWLINE> r = max ( i - R [ j ] , 0 ) <NEWLINE> if i - L [ j ] < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> moves [ i ] += ( rui_wa [ l ] - rui_wa [ r - 1 ] ) % 998244353 <NEWLINE> <NL> <DEDENT> rui_wa [ i ] = ( moves [ i ] + rui_wa [ i - 1 ] ) % 998244353 <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( moves [ N - 1 ] % 998244353 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B . sort ( reverse = True ) <NEWLINE> Arev = sorted ( A , reverse = True ) <NEWLINE> Brev = sorted ( B ) <NEWLINE> atai = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] == B [ i ] : <NEWLINE> <INDENT> atai = A [ i ] <NEWLINE> s += 1 <NEWLINE> <DEDENT> <DEDENT> C = [ ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> C . append ( A [ i ] - B [ i ] ) <NEWLINE> <DEDENT> if s > 0 : <NEWLINE> <INDENT> hajime = C . index ( 0 ) <NEWLINE> <DEDENT> if s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Acount = A . count ( atai ) <NEWLINE> Bcount = B . count ( atai ) <NEWLINE> if N - Acount < Bcount : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> afirst = A . index ( atai ) <NEWLINE> alast = N - 1 - Arev . index ( atai ) <NEWLINE> bfirst = B . index ( atai ) <NEWLINE> blast = N - 1 - Brev . index ( atai ) <NEWLINE> t = min ( afirst , bfirst ) <NEWLINE> if t >= s : <NEWLINE> <INDENT> for i in range ( 0 , s ) : <NEWLINE> <INDENT> B [ hajime + i ] = B [ i ] <NEWLINE> B [ i ] = atai <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , t ) : <NEWLINE> <INDENT> B [ hajime + i ] = B [ i ] <NEWLINE> B [ i ] = atai <NEWLINE> <DEDENT> ss = s - t <NEWLINE> for i in range ( 0 , ss ) : <NEWLINE> <INDENT> B [ hajime + t + i ] = B [ - i - 1 ] <NEWLINE> B [ - i - 1 ] = atai <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * B ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Graph [ a ] . append ( b ) <NEWLINE> Graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * ( N + 1 ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> dist [ 1 ] = 0 <NEWLINE> <NL> pre = [ - 1 ] * ( N + 1 ) <NEWLINE> pre [ 0 ] = 0 <NEWLINE> pre [ 1 ] = 1 <NEWLINE> <NL> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> for i in Graph [ v ] : <NEWLINE> <INDENT> if dist [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] = dist [ v ] + 1 <NEWLINE> pre [ i ] = v <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = dist [ 0 : ] <NEWLINE> print ( <STRING> ) <NEWLINE> for j in range ( 2 , len ( pre ) ) : <NEWLINE> <INDENT> print ( pre [ j ] ) <NEWLINE> <DEDENT>
N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def f ( N , S , A ) : <NEWLINE> <INDENT> MOD = 998244353 <NEWLINE> dp = [ 0 ] * ( S + 1 ) <NEWLINE> dp [ 0 ] = pow ( 2 , N , MOD ) <NEWLINE> div = pow ( 2 , MOD - 2 , MOD ) <NEWLINE> m = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> m += a <NEWLINE> for i in range ( min ( m , S ) , a - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i ] + dp [ i - a ] * div ) % MOD <NEWLINE> <DEDENT> <DEDENT> return dp [ S ] <NEWLINE> <NL> <DEDENT> print ( f ( N , S , A ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> p = s . count ( <STRING> ) <NEWLINE> q = s . count ( <STRING> ) <NEWLINE> print ( 2 * min ( p , q ) ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> S_len = len ( S ) <NEWLINE> ans = set ( ) <NEWLINE> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , S_len ) : <NEWLINE> <INDENT> if j + i <= S_len : <NEWLINE> <INDENT> t = S [ j : j + i ] <NEWLINE> if t != <STRING> : <NEWLINE> <INDENT> ans . add ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = list ( ans ) <NEWLINE> ans . sort ( ) <NEWLINE> print ( ans [ K - 1 ] ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( num + 1 ) <NEWLINE> for x in list : <NEWLINE> <INDENT> ans [ x ] += 1 <NEWLINE> <DEDENT> for x in range ( num ) : <NEWLINE> <INDENT> print ( ans [ x + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if s < k : <NEWLINE> <INDENT> ans = ( s + 1 ) * ( s + 2 ) / 2 <NEWLINE> <DEDENT> elif s <= 2 * k : <NEWLINE> <INDENT> t = 2 * k - s <NEWLINE> a = ( k + 1 ) * ( k + 2 ) / 2 <NEWLINE> b = t * ( t + 1 ) / 2 <NEWLINE> c = t * ( 2 * k - ( t - 1 ) ) / 2 <NEWLINE> ans = a - b + c <NEWLINE> <DEDENT> elif s <= 3 * k : <NEWLINE> <INDENT> t = 3 * k - s + 1 <NEWLINE> ans = t * ( t + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_n = np . array ( a ) <NEWLINE> cnt_np = np . zeros ( n ) <NEWLINE> <NL> for an in a : <NEWLINE> <INDENT> cnt_np [ an - 1 ] += 1 <NEWLINE> <DEDENT> for cnt in cnt_np : <NEWLINE> <INDENT> print ( int ( cnt ) ) <NEWLINE> <DEDENT>
from collections import defaultdict , deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> count = [ 0 ] * N <NEWLINE> parent = defaultdict ( int ) <NEWLINE> t = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ a - 1 ] . append ( b ) <NEWLINE> t [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ p - 1 ] += x <NEWLINE> <NL> <NL> <DEDENT> f = [ False ] * N <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> while ( q ) : <NEWLINE> <INDENT> n = q . popleft ( ) <NEWLINE> f [ n - 1 ] = True <NEWLINE> for i in t [ n - 1 ] : <NEWLINE> <INDENT> if f [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( i ) <NEWLINE> count [ i - 1 ] += count [ n - 1 ] <NEWLINE> f [ i - 1 ] = True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( * count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p [ i ] != i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> list1 = [ ] <NEWLINE> for x in s : <NEWLINE> <INDENT> if x == <STRING> or x == <STRING> or x == <STRING> or x == <STRING> : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> list1 . append ( count ) <NEWLINE> if x != <STRING> and x != <STRING> and x != <STRING> and x != <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ( list1 ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SR ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> ascii_lowercase = <STRING> <NEWLINE> ascii_uppercase = <STRING> <NEWLINE> ascii_uppercase2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> p2E = lambda x : print ( <STRING> . join ( x ) ) <NEWLINE> p2S = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> A , B , N = MI ( ) <NEWLINE> <NL> mini = min ( B - 1 , N ) <NEWLINE> s = math . floor ( A * mini / B ) - A * math . floor ( mini / B ) <NEWLINE> print ( s ) <NEWLINE>
n , m , l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> matrix_a = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> matrix_b = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> matrix_ab = [ [ 0 for a in range ( l ) ] for b in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> matrix_ab [ i ] [ j ] += matrix_a [ i ] [ k ] * matrix_b [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> if j < l - 1 : <NEWLINE> <INDENT> print ( matrix_ab [ i ] [ j ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif j == l - 1 : <NEWLINE> <INDENT> print ( matrix_ab [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> __author__ = <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> T = input ( ) <NEWLINE> <NL> <COMMENT> <NL> S = T . replace ( <STRING> , <STRING> ) <NEWLINE> print ( S ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> def fibonacci ( n ) : <NEWLINE> <INDENT> fib = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> fib . append ( fib [ i - 2 ] + fib [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> return fib [ n - 1 ] <NEWLINE> <DEDENT> print ( fibonacci ( n + 1 ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> def generate_n_bit ( n ) : <NEWLINE> <INDENT> bins = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> bins . append ( list ( str ( format ( i , <STRING> ) . zfill ( n ) ) ) ) <NEWLINE> <NL> <DEDENT> return bins <NEWLINE> <NL> <DEDENT> min_price = 10 ** 9 <NEWLINE> bins = generate_n_bit ( n ) <NEWLINE> bins = bins [ 1 : ] <NEWLINE> <NL> for bin in bins : <NEWLINE> <INDENT> a = [ 0 for k in range ( m ) ] <NEWLINE> price = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if bin [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> a [ j ] += l [ i ] [ j + 1 ] <NEWLINE> <NL> <DEDENT> price += l [ i ] [ 0 ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if min ( a ) >= x : <NEWLINE> <INDENT> min_price = min ( price , min_price ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if min_price == 10 ** 9 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( min_price ) <NEWLINE>
import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import decimal <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> import functools <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import decimal <NEWLINE> import statistics <NEWLINE> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = ns ( ) <NEWLINE> a = na ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> print ( <STRING> if a [ i ] > a [ i - k ] else <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> connect = { } <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> try : <NEWLINE> <INDENT> connect [ a ] . append ( b ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> connect [ a ] = [ b ] <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> connect [ b ] . append ( a ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> connect [ b ] = [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> queue = [ 1 ] <NEWLINE> guide = [ - 1 ] * ( n + 1 ) <NEWLINE> visited = [ False ] * ( n + 1 ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> x = queue . pop ( 0 ) <NEWLINE> for y in connect [ x ] : <NEWLINE> <INDENT> if visited [ y ] == False : <NEWLINE> <INDENT> queue . append ( y ) <NEWLINE> guide [ y ] = x <NEWLINE> visited [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( guide [ x ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i , j in enumerate ( A ) : <NEWLINE> <INDENT> l . append ( i + j ) <NEWLINE> r . append ( i - j ) <NEWLINE> <NL> <DEDENT> b = Counter ( r ) <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += b . get ( i , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> seat = [ 0 ] * 100000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , list ( input ( ) . split ( ) ) ) <NEWLINE> for j in range ( a , b + 1 ) : <NEWLINE> <INDENT> seat [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( seat ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_lst . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ans += a_lst [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> cnt = [ 0 ] * 100001 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( cnt ) - 2 ) : <NEWLINE> <INDENT> ans = max ( ans , cnt [ i ] + cnt [ i + 1 ] + cnt [ i + 2 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> Ind_A = bisect . bisect_left ( A , B [ i ] ) <NEWLINE> if A [ Ind_A - 1 ] == B [ i ] : <NEWLINE> <INDENT> Ind_A -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> Ind_C = bisect . bisect_right ( C , B [ i ] ) <NEWLINE> num_C = len ( C ) - Ind_C <NEWLINE> counter += round ( Ind_A * num_C ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( counter ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = input ( ) . split ( ) <NEWLINE> good = [ 1 ] * N <NEWLINE> import collections <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if int ( H [ a - 1 ] ) > int ( H [ b - 1 ] ) : <NEWLINE> <INDENT> good [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif int ( H [ a - 1 ] ) < int ( H [ b - 1 ] ) : <NEWLINE> <INDENT> good [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> good [ a - 1 ] = 0 <NEWLINE> good [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> c = collections . Counter ( good ) <NEWLINE> print ( c [ 1 ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def I2 ( ) : return map ( int , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> def S ( ) : return str ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def L ( ) : return list ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def Intl ( ) : return [ int ( k ) for k in sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ] <NEWLINE> def Lx ( k ) : return list ( map ( lambda x : int ( x ) * - k , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> x , n = I2 ( ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = Intl ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> if not x in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b , e = 0 , n - 1 <NEWLINE> r = [ ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( min ( p ) - 1 , max ( p ) + 2 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> s . append ( abs ( x - i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( r [ s . index ( min ( s ) ) ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , cnt [ i ] [ j ] ) ) ) <NEWLINE> <NL> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> s = rr ( ) <NEWLINE> q = ri ( ) <NEWLINE> front = <STRING> <NEWLINE> end = <STRING> <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> query = list ( rs ( ) ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag = not flag <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( query [ 1 ] ) <NEWLINE> c = query [ - 1 ] <NEWLINE> if flag == True : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> end += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> front = c + front <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> front = c + front <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end += c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ( front + s + end ) [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( front + s + end ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> <NL> a = x // d <NEWLINE> b = x % d <NEWLINE> if a > k : <NEWLINE> <INDENT> ans = x - ( k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - a ) % 2 == 0 : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = d - b <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> s = len ( S ) <NEWLINE> t = len ( T ) <NEWLINE> if s < t : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( s - t + 1 ) : <NEWLINE> <INDENT> num = s - t - i <NEWLINE> tmp = S [ num : num + t ] <NEWLINE> flag = True <NEWLINE> for j in range ( t ) : <NEWLINE> <INDENT> if ( tmp [ j ] != <STRING> ) and ( T [ j ] != tmp [ j ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> if 0 < num < s - t : <NEWLINE> <INDENT> ans = S [ : num ] + T + S [ num + t : ] <NEWLINE> <DEDENT> elif num == 0 : <NEWLINE> <INDENT> ans = T + S [ num + t : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = S [ : num ] + T <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> def solve ( N , h ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while ( np . any ( h > 0 ) ) : <NEWLINE> <INDENT> w = np . where ( h > 0 ) [ 0 ] <NEWLINE> l = w [ 0 ] <NEWLINE> r = w [ 0 ] <NEWLINE> i = 1 <NEWLINE> while ( i < len ( w ) ) : <NEWLINE> <INDENT> if ( w [ i ] == r + 1 ) : <NEWLINE> <INDENT> r = w [ i ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> h = np . concatenate ( [ h [ : l ] , h [ l : r + 1 ] - 1 , h [ r + 1 : ] ] ) <NEWLINE> s += 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> print ( solve ( N , h ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ret = 0 <NEWLINE> now_sum = sum ( A_list ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( len ( A_list ) ) : <NEWLINE> <INDENT> now_sum -= A_list [ i ] <NEWLINE> multiple_base = A_list [ i ] <NEWLINE> <COMMENT> <NL> before_total = 0 <NEWLINE> <COMMENT> <NL> ret += multiple_base * now_sum <NEWLINE> <NL> <DEDENT> print ( ret % 1000000007 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sum += ( ( N // j ) * ( N // j + 1 ) // 2 ) * j <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > Q - K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> E = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ s ] . add ( ( t , d ) ) <NEWLINE> E [ t ] . add ( ( s , d ) ) <NEWLINE> <NL> <DEDENT> Q = deque ( ) <NEWLINE> <NL> def bfs ( s ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * n <NEWLINE> Q . append ( s ) <NEWLINE> d [ s ] = 0 <NEWLINE> while Q : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> for v , w in E [ u ] : <NEWLINE> <INDENT> if d [ v ] == float ( <STRING> ) : <NEWLINE> <INDENT> d [ v ] = d [ u ] + w <NEWLINE> Q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> d = bfs ( 0 ) <NEWLINE> tgt = d . index ( max ( d ) ) <NEWLINE> d = bfs ( tgt ) <NEWLINE> print ( max ( d ) ) <NEWLINE> <NL> <DEDENT>
a , b , c , d = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( pow ( ( c - a ) ** 2 + ( d - b ) ** 2 , 0.5 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> e , w = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> w [ i ] += w [ i - 1 ] + ( 1 if S [ i - 1 ] == <STRING> else 0 ) <NEWLINE> e [ i ] += e [ i - 1 ] + ( 1 if S [ i - 1 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> ans = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = min ( ans , w [ i ] + e [ - 1 ] - e [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_B = [ ] <NEWLINE> mod = 1000000007 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( A == 0 ) and ( B == 0 ) : <NEWLINE> <INDENT> A_B . append ( ( A , B ) ) <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> A_B . append ( ( 0 , - 1 ) ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> A_B . append ( ( 1 , 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A < 0 : <NEWLINE> <INDENT> A = - A <NEWLINE> B = - B <NEWLINE> <DEDENT> C = math . gcd ( abs ( A ) , abs ( B ) ) <NEWLINE> A_B . append ( ( A // C , B // C ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> A_B_C = Counter ( A_B ) <NEWLINE> <NL> <NL> ans = 1 <NEWLINE> Done = set ( [ ] ) <NEWLINE> Done . add ( ( 0 , 0 ) ) <NEWLINE> for key , value in A_B_C . items ( ) : <NEWLINE> <INDENT> if key in Done : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> keya , keyb = key <NEWLINE> a = 0 <NEWLINE> if keya == 0 and keyb == 0 : <NEWLINE> <INDENT> a = value + 1 <NEWLINE> Done . add ( ( 0 , 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if keyb < 0 : <NEWLINE> <INDENT> keya = - keya <NEWLINE> keyb = - keyb <NEWLINE> <DEDENT> if ( keyb , - keya ) not in A_B_C : <NEWLINE> <INDENT> a = pow ( 2 , value , mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( pow ( 2 , value , mod ) - 1 ) + ( pow ( 2 , A_B_C [ ( keyb , - keya ) ] , mod ) - 1 ) + 1 <NEWLINE> Done . add ( ( keyb , - keya ) ) <NEWLINE> <DEDENT> <DEDENT> ans *= a <NEWLINE> ans %= mod <NEWLINE> Done . add ( key ) <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> ans += A_B_C [ ( 0 , 0 ) ] <NEWLINE> <NL> print ( ans % mod ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( x [ - k ] ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> w = <STRING> <NEWLINE> l = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> w += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( len ( w ) ) <NEWLINE> w = <STRING> <NEWLINE> <DEDENT> <DEDENT> l . append ( len ( w ) ) <NEWLINE> print ( max ( l ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ [ ] for i in range ( N ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> def dfs ( v , p = - 1 ) : <NEWLINE> <INDENT> for to in path [ v ] : <NEWLINE> <INDENT> if to == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ to ] += ans [ v ] <NEWLINE> dfs ( to , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> P , X = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ P - 1 ] += X <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > n : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> print ( int ( a * x / b ) - a * int ( x / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> <NL> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if ( s [ i ] != s [ j ] ) & ( s [ i ] != s [ k ] ) & ( s [ j ] != s [ k ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> T = A [ - 1 ] + 1 <NEWLINE> <NL> dp = [ True ] * T <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> if dp [ a ] : <NEWLINE> <INDENT> for j in range ( 2 * a , T , a ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if d [ a ] == 1 and dp [ a ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> check = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if check <= N : <NEWLINE> <INDENT> cnt [ check ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> arr . append ( a ) <NEWLINE> <DEDENT> c = collections . Counter ( arr ) <NEWLINE> ans = 0 <NEWLINE> for j in c . values ( ) : <NEWLINE> <INDENT> if j % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i - A [ i ] > 0 : <NEWLINE> <INDENT> if str ( i - A [ i ] ) in d : <NEWLINE> <INDENT> d [ str ( i - A [ i ] ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ str ( i - A [ i ] ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if str ( j + A [ j ] ) in d : <NEWLINE> <INDENT> ans += d [ str ( j + A [ j ] ) ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_max = max ( A ) <NEWLINE> L = [ 0 ] * ( A_max + 1 ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> temp = a <NEWLINE> while temp < A_max + 1 : <NEWLINE> <INDENT> L [ temp ] += 1 <NEWLINE> temp += a <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if L [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> numbers = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> ans = [ ] <NEWLINE> <NL> def check_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in numbers : <NEWLINE> <INDENT> ans . append ( check_prime ( n ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> color = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nodes = [ [ ] for i in range ( n ) ] <NEWLINE> cut = [ [ 0 ] for i in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes [ a - 1 ] . append ( b - 1 ) <NEWLINE> nodes [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> def num ( p , parent ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for child in nodes [ p ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cut [ color [ p ] ] . append ( 0 ) <NEWLINE> nc = num ( child , p ) <NEWLINE> group = nc - cut [ color [ p ] ] . pop ( ) <NEWLINE> ans [ color [ p ] ] += group * ( group + 1 ) // 2 <NEWLINE> s += nc <NEWLINE> <DEDENT> s += 1 <NEWLINE> cut [ color [ p ] ] [ - 1 ] += s <NEWLINE> return s <NEWLINE> <DEDENT> num ( 0 , - 1 ) <NEWLINE> for a , c in zip ( ans [ 1 : ] , cut [ 1 : ] ) : <NEWLINE> <INDENT> group = n - c [ 0 ] <NEWLINE> c = group * ( group + 1 ) // 2 <NEWLINE> print ( n * ( n + 1 ) // 2 - c - a ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> menseki = r * r * math . pi <NEWLINE> syuu = r * 2 * math . pi <NEWLINE> print ( <STRING> % ( menseki ) , end = <STRING> ) <NEWLINE> print ( <STRING> % ( syuu ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> list10 = [ ] <NEWLINE> head = S [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> <COMMENT> <NL> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> list10 . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == head : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list10 . append ( cnt ) <NEWLINE> cnt = 1 <NEWLINE> head = S [ i ] <NEWLINE> <NL> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> list10 . append ( cnt ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> list10 . append ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> cumsum = [ 0 ] <NEWLINE> for li in list10 : <NEWLINE> <INDENT> cumsum . append ( cumsum [ - 1 ] + li ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for j in range ( 1 , len ( cumsum ) , 2 ) : <NEWLINE> <INDENT> h = j <NEWLINE> t = min ( j + 2 * K , len ( cumsum ) - 1 ) <NEWLINE> ans = max ( ans , cumsum [ t ] - cumsum [ max ( h - 1 , 0 ) ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> A = [ i ** 5 for i in range ( 200 ) ] <NEWLINE> B = [ i ** 5 for i in range ( 200 ) ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 200 ) : <NEWLINE> <INDENT> for j in range ( 200 ) : <NEWLINE> <INDENT> if A [ i ] + B [ j ] == X : <NEWLINE> <INDENT> print ( int ( A [ i ] ** ( 1 / 5 ) ) , int ( B [ j ] ** ( 1 / 5 ) * ( - 1 ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A [ i ] - B [ j ] == X : <NEWLINE> <INDENT> print ( int ( A [ i ] ** ( 1 / 5 ) ) , int ( B [ j ] ** ( 1 / 5 ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> def get_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def get_ints ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> import math <NEWLINE> <COMMENT> <NL> def choose2 ( n ) : <NEWLINE> <INDENT> return math . floor ( n * ( n - 1 ) / 2 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N = get_int ( ) <NEWLINE> An = get_ints ( ) <NEWLINE> <STRING> <NEWLINE> uni = [ 0 ] * ( N + 1 ) <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> uni [ An [ i ] ] += 1 <NEWLINE> <DEDENT> sumWay = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> sumWay += choose2 ( uni [ i ] ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( sumWay - choose2 ( uni [ An [ i ] ] ) + choose2 ( uni [ An [ i ] ] - 1 ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> rdict = { } <NEWLINE> gdict = { } <NEWLINE> bdict = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> rdict [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> gdict [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> bdict [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> <DEDENT> ans = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> if i + j in bdict : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in g : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> if i + j in rdict : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in b : <NEWLINE> <INDENT> for j in r : <NEWLINE> <INDENT> if i + j in gdict : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 ; <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> x = x * i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> def Word ( i , a , b ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + a ] and S [ i ] != S [ i + a + b ] and S [ i + a ] != S [ i + a + b ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> ans = R * G * B <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> for a in range ( 1 , math . ceil ( N / 2 ) ) : <NEWLINE> <INDENT> if i + a * 2 >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ i + a ] and S [ i ] != S [ i + a * 2 ] and S [ i + a ] != S [ i + a * 2 ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = Counter ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> max_s = max ( s . values ( ) ) <NEWLINE> print ( * sorted ( [ k for k , v in s . items ( ) if v == max_s ] ) , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> Acnt , Aprob = { } , { } <NEWLINE> for a in A : <NEWLINE> <INDENT> Acnt [ a ] = Acnt . get ( a , 0 ) + 1 <NEWLINE> <DEDENT> sumA = 0 <NEWLINE> for k , a in Acnt . items ( ) : <NEWLINE> <INDENT> Aprob [ k ] = a * ( a - 1 ) // 2 <NEWLINE> sumA += Aprob [ k ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans = ( Acnt [ a ] - 1 ) * ( Acnt [ a ] - 2 ) // 2 <NEWLINE> print ( ans + sumA - Aprob [ a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> from itertools import accumulate <NEWLINE> <NL> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = [ * map ( int , readline ( ) . split ( ) ) ] <NEWLINE> for _ in range ( min ( k , 41 ) ) : <NEWLINE> <INDENT> memo = [ 0 ] * n <NEWLINE> for i , aa in enumerate ( a ) : <NEWLINE> <INDENT> if i > aa : <NEWLINE> <INDENT> memo [ i - aa ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ 0 ] += 1 <NEWLINE> <DEDENT> j = i - ~ aa <NEWLINE> if j < n : <NEWLINE> <INDENT> memo [ j ] -= 1 <NEWLINE> <DEDENT> <DEDENT> a = [ * accumulate ( memo ) ] <NEWLINE> <DEDENT> print ( * a ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
m = 10000000019 <NEWLINE> x = 0 <NEWLINE> def mod ( x ) : return ( x % m + m ) % m <NEWLINE> def pow ( x , a ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> while a : <NEWLINE> <INDENT> if ( a & 1 ) : ret = mod ( x * ret ) <NEWLINE> x = mod ( x * x ) <NEWLINE> a >>= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> o , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if o == 1 : x = ( x + y ) % m <NEWLINE> elif o == 2 : x = ( x - y ) % m <NEWLINE> elif o == 3 : x = mod ( x * y ) <NEWLINE> else : x = mod ( x * pow ( y , m - 2 ) ) <NEWLINE> <DEDENT> print ( x if x < ( 1 << 31 ) else x - m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mod = ( 10 ** 9 ) + 7 <NEWLINE> ans = ( 10 ** n ) - 2 * ( 9 ** n ) + 8 ** n <NEWLINE> print ( ans % mod ) <NEWLINE>
s_inv = str ( input ( ) ) [ : : - 1 ] <NEWLINE> dp = [ 1 ] + [ 0 ] * 2018 <NEWLINE> MOD = 0 <NEWLINE> ans = 0 <NEWLINE> num = 0 <NEWLINE> k = 1 <NEWLINE> <NL> for i in range ( len ( s_inv ) ) : <NEWLINE> <INDENT> num += int ( s_inv [ i ] ) * k <NEWLINE> MOD = num % 2019 <NEWLINE> dp [ MOD ] += 1 <NEWLINE> k = k * 10 <NEWLINE> k %= 2019 <NEWLINE> <DEDENT> for i in dp : <NEWLINE> <INDENT> ans += i * ( i - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for k in range ( K , N ) : <NEWLINE> <INDENT> if A [ k ] > A [ cnt ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> tempi = [ 0 ] * n <NEWLINE> tempj = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tempi [ i ] = a [ i ] + i + 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tempj [ i ] = - a [ i ] + i + 1 <NEWLINE> <DEDENT> import collections <NEWLINE> tempid = collections . Counter ( tempi ) <NEWLINE> tempjd = collections . Counter ( tempj ) <NEWLINE> for k in tempid . keys ( ) : <NEWLINE> <INDENT> a = tempid [ k ] <NEWLINE> b = tempjd [ k ] <NEWLINE> ans = ans + a * b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : return 0 <NEWLINE> l = Counter ( a ) <NEWLINE> ans = 1 <NEWLINE> for i , j in l . items ( ) : <NEWLINE> <INDENT> ans *= i ** j <NEWLINE> if ans > int ( 1e18 ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e6 ) ) <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> v_from , v_to = map ( int , v_detail ) <NEWLINE> init_adj_table [ v_from ] . append ( v_to ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def graph_dfs ( u , low , disc , stack_member , st ) : <NEWLINE> <INDENT> global Time <NEWLINE> <COMMENT> <NL> disc [ u ] = Time <NEWLINE> low [ u ] = Time <NEWLINE> Time += 1 <NEWLINE> stack_member [ u ] = True <NEWLINE> st . append ( u ) <NEWLINE> scc_set = set ( ) <NEWLINE> <NL> <COMMENT> <NL> for v in adj_table [ u ] : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if disc [ v ] == - 1 : <NEWLINE> <NL> <INDENT> graph_dfs ( v , low , disc , stack_member , st ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> low [ u ] = min ( low [ u ] , low [ v ] ) <NEWLINE> <NL> <DEDENT> elif stack_member [ v ] : <NEWLINE> <NL> <INDENT> <STRING> <NEWLINE> low [ u ] = min ( low [ u ] , disc [ v ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> w = - 1 <COMMENT> <NEWLINE> if low [ u ] == disc [ u ] : <NEWLINE> <INDENT> while w != u : <NEWLINE> <INDENT> w = st . pop ( ) <NEWLINE> scc_set . add ( w ) <NEWLINE> stack_member [ w ] = False <NEWLINE> <DEDENT> ans . append ( scc_set ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def scc ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> disc = [ - 1 ] * vertices <NEWLINE> low = [ - 1 ] * vertices <NEWLINE> stack_member = [ False ] * vertices <NEWLINE> st = [ ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for v in range ( vertices ) : <NEWLINE> <INDENT> if disc [ v ] == - 1 : <NEWLINE> <INDENT> graph_dfs ( v , low , disc , stack_member , st ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> for question in q_list : <NEWLINE> <INDENT> flag = False <NEWLINE> ele1 , ele2 = map ( int , question ) <NEWLINE> for each in scc_sets : <NEWLINE> <INDENT> if ( ele1 in each ) and ( ele2 in each ) : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : edges + 1 ] ) <NEWLINE> q_num = int ( _input [ edges + 1 ] ) <NEWLINE> q_list = map ( lambda x : x . split ( ) , _input [ edges + 2 : ] ) <NEWLINE> <NL> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> Time = 0 <NEWLINE> ans = [ ] <NEWLINE> scc_sets = scc ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> class WeightedUnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <COMMENT> <NL> self . weight = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = self . find ( self . parents [ x ] ) <NEWLINE> <COMMENT> <NL> self . weight [ x ] += self . weight [ self . parents [ x ] ] <NEWLINE> self . parents [ x ] = y <NEWLINE> return y <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y , w ) : <NEWLINE> <INDENT> rx = self . find ( x ) <NEWLINE> ry = self . find ( y ) <NEWLINE> <COMMENT> <NL> if self . rank [ rx ] < self . rank [ ry ] : <NEWLINE> <INDENT> self . parents [ rx ] = ry <NEWLINE> self . weight [ rx ] = w - self . weight [ x ] + self . weight [ y ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ ry ] = rx <NEWLINE> self . weight [ ry ] = - w - self . weight [ y ] + self . weight [ x ] <NEWLINE> <COMMENT> <NL> if self . rank [ rx ] == self . rank [ ry ] : <NEWLINE> <INDENT> self . rank [ rx ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def diff ( self , x , y ) : <NEWLINE> <INDENT> return self . weight [ x ] - self . weight [ y ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> uf = WeightedUnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> if uf . same ( l , r ) : <NEWLINE> <INDENT> if uf . diff ( l , r ) != d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> uf . union ( l , r , d ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> flag = [ True ] * ( n + 1 ) <NEWLINE> flag [ 0 ] = flag [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> for j in range ( i ** 2 , n + 1 , i ) : <NEWLINE> <INDENT> flag [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( flag . count ( True ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> list_P = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> list_P [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if list_P [ i ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import floor <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( floor ( a * x / b ) - a * floor ( x / b ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> S1 = 0 <NEWLINE> S2 = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S1 += A [ i ] <NEWLINE> S2 += A [ i ] <NEWLINE> if i & 1 : <NEWLINE> <INDENT> if S1 >= 0 : <NEWLINE> <INDENT> ans1 += S1 + 1 <NEWLINE> S1 = - 1 <NEWLINE> <DEDENT> if S2 <= 0 : <NEWLINE> <INDENT> ans2 += 1 - S2 <NEWLINE> S2 = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S1 <= 0 : <NEWLINE> <INDENT> ans1 += 1 - S1 <NEWLINE> S1 = 1 <NEWLINE> <DEDENT> if S2 >= 0 : <NEWLINE> <INDENT> ans2 += S2 + 1 <NEWLINE> S2 = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min ( ans1 , ans2 ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def dfs ( n , seq ) : <NEWLINE> <INDENT> if seq [ n : ] in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if seq [ n : n + 7 ] == <STRING> : <NEWLINE> <INDENT> if dfs ( n + 5 , seq ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif dfs ( n + 7 , seq ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> elif seq [ n : n + 5 ] == <STRING> : <NEWLINE> <INDENT> return dfs ( n + 5 , seq ) <NEWLINE> <NL> <DEDENT> elif seq [ n : n + 6 ] == <STRING> : <NEWLINE> <INDENT> return dfs ( n + 6 , seq ) <NEWLINE> <NL> <DEDENT> elif seq [ n : n + 5 ] == <STRING> : <NEWLINE> <INDENT> return dfs ( n + 5 , seq ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if dfs ( 0 , S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a_max = A [ - 1 ] <NEWLINE> dp = [ 0 ] * ( a_max + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for a in A : <NEWLINE> <INDENT> if dp [ a ] != 0 : <NEWLINE> <INDENT> dp [ a ] = 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> i = a <NEWLINE> while i < a_max + 1 : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> i += a <NEWLINE> <NL> <DEDENT> <DEDENT> r = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> O = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> o_1 , o_2 = map ( int , input ( ) . split ( ) ) <NEWLINE> B [ o_1 - 1 ] . append ( o_2 - 1 ) <NEWLINE> B [ o_2 - 1 ] . append ( o_1 - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for node in range ( N ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> for l in B [ node ] : <NEWLINE> <INDENT> if O [ node ] <= O [ l ] : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 3 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , n // i + 1 ) : <NEWLINE> <INDENT> if i * j < n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt + n - 1 + ( n - 1 ) // 2 ) <NEWLINE>
N = input ( ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> now_mini = 1 << 20 <NEWLINE> for i in P : <NEWLINE> <INDENT> if i < now_mini : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> now_mini = i <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> s = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) + s [ i ] ) <NEWLINE> <NL> <DEDENT> m = - 100000 * 5000 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> m = max ( m , s [ j ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
def Fib ( n ) : <NEWLINE> <INDENT> a , b = 0 , 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> if m > 1 : <NEWLINE> <INDENT> for i in range ( m - 1 ) : <NEWLINE> <INDENT> if a [ i + 1 ] - a [ i ] <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> return Fib ( n + 2 ) % 1000000007 <NEWLINE> <NL> <NL> <DEDENT> a = a + [ n ] <NEWLINE> l = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> l . append ( a [ i ] - a [ i - 1 ] - 1 ) <NEWLINE> <DEDENT> l = l + [ a [ - 1 ] - a [ - 2 ] ] <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= Fib ( i + 1 ) <NEWLINE> <NL> <DEDENT> return ans % 1000000007 <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pre = sum ( plist [ : K ] ) <NEWLINE> ans = pre <NEWLINE> for i in range ( 0 , N - K ) : <NEWLINE> <INDENT> pre = pre - plist [ i ] + plist [ i + K ] <NEWLINE> ans = max ( ans , pre ) <NEWLINE> <NL> <DEDENT> print ( ( ans + K ) / 2 ) <NEWLINE>
from sys import stdin <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> <NL> a , b , n = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> if ( b > n ) : <NEWLINE> <INDENT> print ( int ( a * n / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a * ( b - 1 ) / b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> q = int ( 1e9 + 7 ) <NEWLINE> <NL> print ( ( pow ( 10 , N , q ) - 2 * pow ( 9 , N , q ) + pow ( 8 , N , q ) ) % q ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> if s in S : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . add ( s ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( S ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ansl = [ ] <NEWLINE> dic = { i : 0 for i in range ( a ) } <NEWLINE> aans = [ ] <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if True : <NEWLINE> <INDENT> ch = h [ c - 1 ] <NEWLINE> dh = h [ d - 1 ] <NEWLINE> if ch == dh : <NEWLINE> <INDENT> if dic [ c - 1 ] == 0 : <NEWLINE> <INDENT> ansl . append ( c - 1 ) <NEWLINE> dic [ c - 1 ] += 1 <NEWLINE> <DEDENT> if dic [ d - 1 ] == 0 : <NEWLINE> <INDENT> ansl . append ( d - 1 ) <NEWLINE> dic [ d - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ch < dh : <NEWLINE> <INDENT> if dic [ c - 1 ] == 0 : <NEWLINE> <INDENT> ansl . append ( c - 1 ) <NEWLINE> dic [ c - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dic [ d - 1 ] == 0 : <NEWLINE> <INDENT> ansl . append ( d - 1 ) <NEWLINE> dic [ d - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> aans . append ( [ c , d ] ) <NEWLINE> <DEDENT> <DEDENT> print ( a - len ( ansl ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( sorted ( input ( ) ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> flg = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ flg ] != a [ i ] : <NEWLINE> <INDENT> z = i - 1 - flg <NEWLINE> ans += ( 1 + z ) * z // 2 <NEWLINE> flg = i <NEWLINE> <DEDENT> <DEDENT> z = n - 1 - flg <NEWLINE> ans += ( 1 + z ) * z // 2 <NEWLINE> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if S <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> max_items = S // 3 <NEWLINE> <NL> <COMMENT> <NL> <NL> for item in range ( 1 , max_items + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = S - 3 * item <NEWLINE> <COMMENT> <NL> if n == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> modinv_table = [ - 1 ] * ( n + 1 ) <NEWLINE> modinv_table [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> modinv_table [ i ] = ( - modinv_table [ mod % i ] * ( mod // i ) ) % mod <NEWLINE> <NL> <DEDENT> add = 1 <NEWLINE> for p in range ( n ) : <NEWLINE> <INDENT> add *= ( n + item - 1 ) - p <NEWLINE> add *= modinv_table [ p + 1 ] <NEWLINE> add %= mod <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> ans += add <NEWLINE> ans %= mod <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> def RN ( n , a ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> ans += a [ int ( n ) - 1 - i ] + <STRING> <NEWLINE> <DEDENT> print ( ans [ : - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> a = input ( ) <NEWLINE> List = a . split ( <STRING> ) <NEWLINE> RN ( n , List ) <NEWLINE> <DEDENT>
line1 = input ( ) <NEWLINE> line2 = input ( ) <NEWLINE> <NL> n , k = tuple ( [ int ( val ) for val in line1 . split ( ) ] ) <NEWLINE> a_list = [ int ( val ) for val in line2 . split ( ) ] <NEWLINE> <NL> prev_sum = sum ( a_list [ 0 : k ] ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> current_sum = prev_sum - a_list [ i - k ] + a_list [ i ] <NEWLINE> if current_sum > prev_sum : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> prev_sum = current_sum <NEWLINE> <DEDENT>
L , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * L <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( b ) <NEWLINE> y . append ( c ) <NEWLINE> <DEDENT> if max ( x ) <= min ( y ) : <NEWLINE> <INDENT> print ( - max ( x ) + min ( y ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n * ( 100 ** d ) if n < 100 else ( n + 1 ) * ( 100 ** d ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ls = len ( S ) <NEWLINE> lt = len ( T ) <NEWLINE> ans = lt <NEWLINE> for i in range ( 0 , ls - lt + 1 ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> if S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , lt - a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> count = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> val = 0 <NEWLINE> sum_val = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b . append ( a [ i ] * sum_val ) <NEWLINE> sum_val += a [ i ] <NEWLINE> <DEDENT> val = sum ( b ) <NEWLINE> print ( val % ( 10 ** 9 + 7 ) ) <NEWLINE>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = [ <STRING> if A [ i ] > A [ i - K ] else <STRING> for i in range ( K , N ) ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
from itertools import combinations <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = 1 << 62 <NEWLINE> for t in combinations ( P , min ( 4 , K ) ) : <NEWLINE> <INDENT> xs , ys = zip ( * t ) <NEWLINE> xmin = min ( xs ) <NEWLINE> xmax = max ( xs ) <NEWLINE> ymin = min ( ys ) <NEWLINE> ymax = max ( ys ) <NEWLINE> area = ( xmax - xmin ) * ( ymax - ymin ) <NEWLINE> if ans < area : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 0 <NEWLINE> for x , y in P : <NEWLINE> <INDENT> if xmin <= x <= xmax and ymin <= y <= ymax : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> if k >= K : <NEWLINE> <INDENT> ans = area <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l += [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> <DEDENT> a = 1 << ( n ) <NEWLINE> r = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> li = np . array ( [ 0 for _ in range ( m + 1 ) ] ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i & ( 1 << j ) : <NEWLINE> <INDENT> li += l [ j ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if li [ k ] < x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if k == m : <NEWLINE> <INDENT> r += [ li [ 0 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( r ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( r ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min = p [ 0 ] <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if p [ i ] <= min : <NEWLINE> <INDENT> count += 1 <NEWLINE> min = p [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 100000 <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> ans [ x * x + y * y + z * z + x * y + y * z + z * x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( h * w + 1 ) <NEWLINE> <NL> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> s = ab [ i ] [ j ] <NEWLINE> dp [ s ] = [ i , j ] <NEWLINE> <NL> <DEDENT> <DEDENT> dpp = [ 0 ] * ( h * w + 1 ) <NEWLINE> <NL> for k in range ( d + 1 , h * w + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> dpp [ k ] = dpp [ k - d ] + abs ( dp [ k ] [ 0 ] - dp [ k - d ] [ 0 ] ) + abs ( dp [ k ] [ 1 ] - dp [ k - d ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for x in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dpp [ b ] - dpp [ a ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> import math <NEWLINE> from math import gcd <NEWLINE> def lcm ( a , b ) : return a * b // gcd ( a , b ) <NEWLINE> from itertools import count , permutations , chain , product <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque , defaultdict <NEWLINE> from pprint import pprint <NEWLINE> ii = lambda : int ( input ( ) ) <NEWLINE> mis = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lmis = lambda : list ( mis ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> N1097 = 10 ** 9 + 7 <NEWLINE> <NL> def meg ( f , ok , ng ) : <NEWLINE> <INDENT> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if f ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> def get_inv ( n , modp ) : <NEWLINE> <INDENT> return pow ( n , modp - 2 , modp ) <NEWLINE> <NL> <DEDENT> def factorials_list ( n , modp ) : <COMMENT> <NEWLINE> <INDENT> fs = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fs . append ( fs [ - 1 ] * i % modp ) <NEWLINE> <DEDENT> return fs <NEWLINE> <NL> <DEDENT> def invs_list ( n , fs , modp ) : <COMMENT> <NEWLINE> <INDENT> invs = [ get_inv ( fs [ - 1 ] , modp ) ] <NEWLINE> for i in range ( n , 1 - 1 , - 1 ) : <NEWLINE> <INDENT> invs . append ( invs [ - 1 ] * i % modp ) <NEWLINE> <DEDENT> invs . reverse ( ) <NEWLINE> return invs <NEWLINE> <NL> <DEDENT> def comb ( n , k , modp ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in range ( n , n - k , - 1 ) : <NEWLINE> <INDENT> num = num * i % modp <NEWLINE> <DEDENT> den = 1 <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> den = den * i % modp <NEWLINE> <DEDENT> return num * get_inv ( den , modp ) % modp <NEWLINE> <NL> <DEDENT> def comb_from_list ( n , k , modp , fs , invs ) : <NEWLINE> <INDENT> return fs [ n ] * invs [ n - k ] * invs [ k ] % modp <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> class UnionFindEx : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . roots = [ - 1 ] * size <NEWLINE> <DEDENT> def getRootID ( self , i ) : <NEWLINE> <INDENT> r = self . roots [ i ] <NEWLINE> if r < 0 : <COMMENT> <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = self . getRootID ( r ) <NEWLINE> self . roots [ i ] = r <NEWLINE> return r <NEWLINE> <DEDENT> <DEDENT> def getGroupSize ( self , i ) : <NEWLINE> <INDENT> return - self . roots [ self . getRootID ( i ) ] <NEWLINE> <DEDENT> def connect ( self , i , j ) : <NEWLINE> <INDENT> r1 , r2 = self . getRootID ( i ) , self . getRootID ( j ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . getGroupSize ( r1 ) < self . getGroupSize ( r2 ) : <NEWLINE> <INDENT> r1 , r2 = r2 , r1 <NEWLINE> <DEDENT> self . roots [ r1 ] += self . roots [ r2 ] <COMMENT> <NEWLINE> self . roots [ r2 ] = r1 <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> Yes = <STRING> <NEWLINE> No = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = ii ( ) <NEWLINE> X = input ( ) <NEWLINE> X_POP = X . count ( <STRING> ) <NEWLINE> X_POP_P = X_POP + 1 <NEWLINE> X_POP_N = X_POP - 1 <NEWLINE> FX_P = 0 <NEWLINE> FX_N = 0 <NEWLINE> for i , b in enumerate ( X ) : <NEWLINE> <INDENT> FX_P <<= 1 <NEWLINE> FX_N <<= 1 <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> FX_P += 1 <NEWLINE> FX_N += 1 <NEWLINE> <DEDENT> FX_P %= X_POP_P <NEWLINE> FX_N %= X_POP_N or 1 <NEWLINE> <COMMENT> <NL> <DEDENT> def popcount ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( n % popcount ( n ) ) + 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i , b in enumerate ( reversed ( X ) ) : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> fx = f ( ( FX_P + pow ( 2 , i , X_POP_P ) ) % X_POP_P ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X_POP_N == 0 : <NEWLINE> <INDENT> fx = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fx = f ( ( FX_N - pow ( 2 , i , X_POP_N ) ) % X_POP_N ) + 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( fx ) <NEWLINE> <DEDENT> print ( * reversed ( ans ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> a = r * r * math . pi <NEWLINE> b = 2 * r * math . pi <NEWLINE> print ( a , b ) <NEWLINE>
<NL> a = input ( ) . split ( ) <NEWLINE> b = input ( ) . split ( ) <NEWLINE> c = input ( ) <NEWLINE> <NL> A = int ( a [ 0 ] ) <NEWLINE> V = int ( a [ 1 ] ) <NEWLINE> B = int ( b [ 0 ] ) <NEWLINE> W = int ( b [ 1 ] ) <NEWLINE> T = int ( c ) <NEWLINE> <NL> if ( B > A ) : <NEWLINE> <INDENT> if ( W >= V ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> times = ( B - A ) / ( V - W ) <NEWLINE> if ( times <= T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( W >= V ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> times = ( A - B ) / ( V - W ) <NEWLINE> if ( abs ( times ) <= T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> n , m = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> <NL> H = input ( ) . split ( <STRING> ) <NEWLINE> H = np . array ( [ int ( h ) for h in H ] ) <NEWLINE> Hs = np . zeros ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) - 1 <NEWLINE> b = int ( b ) - 1 <NEWLINE> Hs [ a ] = np . max ( [ Hs [ a ] , H [ b ] ] ) <NEWLINE> Hs [ b ] = np . max ( [ Hs [ b ] , H [ a ] ] ) <NEWLINE> <NL> <DEDENT> G = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if Hs [ i ] < H [ i ] : <NEWLINE> <INDENT> G += [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( G ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = a + ai <NEWLINE> <NL> <DEDENT> print ( n - len ( set ( a ) ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if a < b : print ( <STRING> ) <NEWLINE> elif a > b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> for l in range ( k ) : <NEWLINE> <INDENT> ans += gcd ( i + 1 , gcd ( j + 1 , l + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> route = [ 1 ] <NEWLINE> route_set = set ( ) <NEWLINE> start = 1 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if cnt == K : <NEWLINE> <INDENT> print ( route [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif A [ start ] in route_set : <NEWLINE> <INDENT> index = route . index ( A [ start ] ) <NEWLINE> loop = len ( route ) - index <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> route . append ( A [ start ] ) <NEWLINE> route_set . add ( A [ start ] ) <NEWLINE> start = A [ start ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> K -= index <NEWLINE> K = K % loop <NEWLINE> print ( route [ index : ] [ K ] ) <NEWLINE>
input ( ) <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 not in b : <NEWLINE> <INDENT> last = 1 <NEWLINE> for i in b : <NEWLINE> <INDENT> last *= i <NEWLINE> if last > 10 ** 18 : <NEWLINE> <INDENT> last = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> last = 0 <NEWLINE> <NL> <DEDENT> print ( last ) <NEWLINE>
import copy <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ [ 0 for j in range ( 26 ) ] for i in range ( D ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> s [ i ] [ j ] = tmp [ j ] <NEWLINE> <DEDENT> <DEDENT> t = [ ] <NEWLINE> v = [ 0 ] * D <NEWLINE> last = [ [ 0 for j in range ( 26 ) ] for i in range ( D ) ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> max = - 10000 <NEWLINE> tmp_last = copy . deepcopy ( last ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> tmp_sum = sum <NEWLINE> if j != 0 : <NEWLINE> <INDENT> tmp_last [ i ] [ j - 1 ] = last [ i ] [ j - 1 ] <NEWLINE> <DEDENT> tmp_sum += s [ i ] [ j ] <NEWLINE> tmp_last [ i ] [ j ] = i + 1 <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> tmp_sum -= c [ k ] * ( ( i + 1 ) - tmp_last [ i ] [ j ] ) <NEWLINE> <DEDENT> if tmp_sum > max : <NEWLINE> <INDENT> max_j = j <NEWLINE> max = tmp_sum <NEWLINE> last [ i ] [ j ] = i + 1 <NEWLINE> <DEDENT> <DEDENT> sum = max <NEWLINE> t . append ( max_j + 1 ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
date = [ [ ] , [ ] , [ ] ] <NEWLINE> a , b , c = 0 , 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> if a < 0 and b < 0 and c < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> date [ 0 ] . append ( a ) <NEWLINE> date [ 1 ] . append ( b ) <NEWLINE> date [ 2 ] . append ( c ) <NEWLINE> <DEDENT> <DEDENT> for h in range ( 0 , len ( date [ 0 ] ) - 1 ) : <NEWLINE> <INDENT> if date [ 0 ] [ h ] == - 1 or date [ 1 ] [ h ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif date [ 0 ] [ h ] == date [ 1 ] [ h ] == date [ 2 ] [ h ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if date [ 0 ] [ h ] + date [ 1 ] [ h ] >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if date [ 0 ] [ h ] + date [ 1 ] [ h ] >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if date [ 0 ] [ h ] + date [ 1 ] [ h ] >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if date [ 0 ] [ h ] + date [ 1 ] [ h ] >= 30 : <NEWLINE> <INDENT> if date [ 2 ] [ h ] >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format ( data [ 0 ] , data [ 1 ] , data [ 2 ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from bisect import bisect_left , bisect_right <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> a = A [ - 1 ] <NEWLINE> mid = a / 2 <NEWLINE> diff = INF <NEWLINE> b = - 1 <NEWLINE> for j in A [ : - 1 ] : <NEWLINE> <INDENT> d = abs ( j - mid ) <NEWLINE> if d < diff : <NEWLINE> <INDENT> b = j <NEWLINE> diff = d <NEWLINE> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> fac_inv2 = pow ( 2 , MOD - 2 , MOD ) <NEWLINE> <NL> dp = np . zeros ( s , <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> newdp = dp . copy ( ) <NEWLINE> if a [ i ] < s : <NEWLINE> <INDENT> newdp [ a [ i ] : ] += dp [ : s - a [ i ] ] * fac_inv2 % MOD <NEWLINE> <DEDENT> if a [ i ] <= s : <NEWLINE> <INDENT> newdp [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> dp = newdp % MOD <NEWLINE> <NL> <DEDENT> ans = dp [ - 1 ] <NEWLINE> ans *= pow ( 2 , n - 1 , MOD ) <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n >= b - 1 : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <NL> <DEDENT> ans = ( a * x ) // b - a * ( x // b ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> TO_K = [ ] <NEWLINE> TREE = [ ] <NEWLINE> <NL> def dfs ( parent , distance ) : <NEWLINE> <INDENT> for i_node in TREE [ parent ] : <NEWLINE> <INDENT> child , dd = i_node <NEWLINE> if TO_K [ child ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> next_dt = distance + dd <NEWLINE> TO_K [ child ] = next_dt <NEWLINE> dfs ( child , next_dt ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> abc = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( n - 1 ) ] <NEWLINE> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( q ) ] <NEWLINE> <NL> global TO_K <NEWLINE> <COMMENT> <NL> TO_K = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> global TREE <NEWLINE> <COMMENT> <NL> TREE = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for a , b , c in abc : <NEWLINE> <INDENT> TREE [ a ] . append ( [ b , c ] ) <NEWLINE> TREE [ b ] . append ( [ a , c ] ) <NEWLINE> <NL> <DEDENT> TO_K [ k ] = 0 <NEWLINE> dfs ( k , 0 ) <NEWLINE> <NL> for x , y in xy : <NEWLINE> <INDENT> print ( TO_K [ x ] + TO_K [ y ] ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> s += int ( n [ i : i + 1 ] ) <NEWLINE> <NL> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sub = n // i <NEWLINE> result += ( sub + 1 ) * sub * i / 2 <NEWLINE> <NL> <NL> <DEDENT> print ( int ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , list ( input ( ) . split ( ) ) ) ) <NEWLINE> ds = set ( arr ) <NEWLINE> <COMMENT> <NL> <NL> allxor = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> allxor = allxor ^ arr [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( allxor ^ arr [ i ] , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def DFS ( i ) : <NEWLINE> <INDENT> if done [ i ] : <NEWLINE> <INDENT> ans [ - 1 ] += 1 <NEWLINE> done [ i ] = False <NEWLINE> for g in G [ i ] : <NEWLINE> <INDENT> if done [ g ] : <NEWLINE> <INDENT> DFS ( g ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return p <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> done = [ True for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> if done [ j ] : <NEWLINE> <INDENT> DFS ( j ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ab = [ input ( ) . split ( ) for i in range ( m ) ] <NEWLINE> tmp = [ ] <NEWLINE> for i in ab : <NEWLINE> <INDENT> tmp . append ( [ int ( i [ 0 ] ) , int ( i [ 1 ] ) ] ) <NEWLINE> <DEDENT> ab = tmp <NEWLINE> <NL> ans = [ 0 for i in h ] <NEWLINE> <NL> for j in ab : <NEWLINE> <INDENT> if h [ j [ 0 ] - 1 ] <= h [ j [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ j [ 0 ] - 1 ] = - 1 <NEWLINE> <DEDENT> if h [ j [ 0 ] - 1 ] >= h [ j [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ j [ 1 ] - 1 ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans1 = 0 <NEWLINE> for i in ans : <NEWLINE> <INDENT> if i > - 1 : <NEWLINE> <INDENT> ans1 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if A . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( 0 , b - ( k - a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> wlist = [ ] <NEWLINE> rlist = [ ] <NEWLINE> cntw = 0 <NEWLINE> cntr = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> rlist . append ( i ) <NEWLINE> cntr += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wlist . append ( i ) <NEWLINE> cntw += 1 <NEWLINE> <DEDENT> <DEDENT> rlist . sort ( reverse = True ) <NEWLINE> cnt = 0 <NEWLINE> for j in range ( min ( cntw , cntr ) ) : <NEWLINE> <INDENT> if rlist == [ ] or wlist == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif rlist [ j ] > wlist [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> zenkai = a [ i - k ] <NEWLINE> konkai = a [ i ] <NEWLINE> if zenkai < konkai : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X = dict ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L = i + A [ i ] <NEWLINE> if L not in X : <NEWLINE> <INDENT> X [ L ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ L ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> R = j - A [ j ] <NEWLINE> if R in X : <NEWLINE> <INDENT> ans += X [ R ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = s [ 0 ] <NEWLINE> b = s [ 1 ] <NEWLINE> c = s [ 2 ] <NEWLINE> k = s [ 3 ] <NEWLINE> m = 0 <NEWLINE> <NL> if k > a : <NEWLINE> <INDENT> m += a <NEWLINE> k -= a <NEWLINE> if k > b : <NEWLINE> <INDENT> k -= b <NEWLINE> if k > c : <NEWLINE> <INDENT> m -= c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m -= k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = k <NEWLINE> <NL> <NL> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sth , stw , glh , glw = map ( int , input ( ) . split ( ) ) <NEWLINE> sth , stw = sth - 1 , stw - 1 <NEWLINE> glh , glw = glh - 1 , glw - 1 <NEWLINE> <NL> INF = - 1 <NEWLINE> Gmap = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> Seen = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> direc = { ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) } <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> def bfs ( sth , stw , glh , glw ) : <NEWLINE> <INDENT> next_q = deque ( [ ] ) <NEWLINE> next_q . append ( ( sth , stw , 0 ) ) <NEWLINE> Seen [ sth ] [ stw ] = 0 <NEWLINE> <NL> while len ( next_q ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> h , w , c = next_q . popleft ( ) <NEWLINE> for dh , dw in direc : <NEWLINE> <INDENT> for sk in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> hs , ws = h + dh * sk , w + dw * sk <NEWLINE> if not ( 0 <= hs < H and 0 <= ws < W ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if Gmap [ hs ] [ ws ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if Seen [ hs ] [ ws ] == INF : <NEWLINE> <INDENT> next_q . append ( ( hs , ws , c + 1 ) ) <NEWLINE> Seen [ hs ] [ ws ] = c + 1 <NEWLINE> <DEDENT> elif Seen [ hs ] [ ws ] <= c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if hs == glh and ws == glw : <NEWLINE> <INDENT> return c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ret = bfs ( sth , stw , glh , glw ) <NEWLINE> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
count = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> sum = sum ( a ) <NEWLINE> <NL> for i in range ( count ) : <NEWLINE> <INDENT> sum = sum - a [ i ] <NEWLINE> ans += sum * a [ i ] <NEWLINE> <NL> <DEDENT> answer = ans % mod <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> import sys <NEWLINE> if sys . version_info [ 0 ] >= 3 : raw_input = input <NEWLINE> <NL> def insertionSort ( a , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , len ( a ) ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def shellSort ( a ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> g = [ ] <NEWLINE> h = 1 <NEWLINE> while h <= len ( a ) : <NEWLINE> <INDENT> g . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( a , g [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ int ( raw_input ( ) ) for i in range ( int ( raw_input ( ) ) ) ] <NEWLINE> shellSort ( a ) <NEWLINE> print ( cnt ) <NEWLINE> for e in a : print ( e ) <NEWLINE>
<COMMENT> <NL> import string <NEWLINE> import sys <NEWLINE> from itertools import chain , dropwhile , takewhile <NEWLINE> <NL> <NL> def read ( <NEWLINE> <INDENT> * shape , f = int , it = chain . from_iterable ( sys . stdin ) , whitespaces = set ( string . whitespace ) <NEWLINE> <DEDENT> ) : <NEWLINE> <INDENT> def read_word ( ) : <NEWLINE> <INDENT> w = lambda c : c in whitespaces <NEWLINE> nw = lambda c : c not in whitespaces <NEWLINE> return f ( <STRING> . join ( takewhile ( nw , dropwhile ( w , it ) ) ) ) <NEWLINE> <NL> <DEDENT> if not shape : <NEWLINE> <INDENT> return read_word ( ) <NEWLINE> <DEDENT> elif len ( shape ) == 1 : <NEWLINE> <INDENT> return [ read_word ( ) for _ in range ( shape [ 0 ] ) ] <NEWLINE> <DEDENT> elif len ( shape ) == 2 : <NEWLINE> <INDENT> return [ [ read_word ( ) for _ in range ( shape [ 1 ] ) ] for _ in range ( shape [ 0 ] ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def readi ( * shape ) : <NEWLINE> <INDENT> return read ( * shape ) <NEWLINE> <NL> <NL> <DEDENT> def readi1 ( * shape ) : <NEWLINE> <INDENT> return [ i - 1 for i in read ( * shape ) ] <NEWLINE> <NL> <NL> <DEDENT> def readf ( * shape ) : <NEWLINE> <INDENT> return read ( * shape , f = float ) <NEWLINE> <NL> <NL> <DEDENT> def reads ( * shape ) : <NEWLINE> <INDENT> return read ( * shape , f = str ) <NEWLINE> <NL> <NL> <DEDENT> def arr ( * shape , fill_value = 0 ) : <NEWLINE> <INDENT> if len ( shape ) == 1 : <NEWLINE> <INDENT> return [ fill_value ] * shape [ fill_value ] <NEWLINE> <DEDENT> elif len ( shape ) == 2 : <NEWLINE> <INDENT> return [ [ fill_value ] * shape [ 1 ] for _ in range ( shape [ 0 ] ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dbg ( ** kwargs ) : <NEWLINE> <INDENT> print ( <NEWLINE> <INDENT> <STRING> . join ( <STRING> . format ( k , repr ( v ) ) for k , v in kwargs . items ( ) ) , <NEWLINE> file = sys . stderr , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , k = readi ( 2 ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> a = readi ( n ) <NEWLINE> tmp = sum ( a [ : k ] ) <NEWLINE> ans = tmp <NEWLINE> for i in range ( k , len ( a ) ) : <NEWLINE> <INDENT> tmp += a [ i ] - a [ i - k ] <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_bool = [ False ] * n <NEWLINE> ne_p = 1 <NEWLINE> p_bool [ ne_p - 1 ] = True <NEWLINE> step = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ne_p = a [ ne_p - 1 ] <NEWLINE> step += 1 <NEWLINE> if p_bool [ ne_p - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_bool [ ne_p - 1 ] = True <NEWLINE> <DEDENT> if step == k : <NEWLINE> <INDENT> print ( ne_p ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> p_list = [ ] <NEWLINE> sta = ne_p <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ne_p = a [ ne_p - 1 ] <NEWLINE> step += 1 <NEWLINE> p_list . append ( ne_p ) <NEWLINE> if ne_p == sta : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if step == k : <NEWLINE> <INDENT> print ( ne_p ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> len_l = len ( p_list ) <NEWLINE> left = k - step <NEWLINE> left -= ( left // len_l ) * len_l <NEWLINE> print ( p_list [ left - 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( S ) ) , end = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> input_org = input ( ) <NEWLINE> keta = input_org . replace ( <STRING> , <STRING> ) <NEWLINE> input_list = list ( map ( int , input_org . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( 0 in input_list ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif len ( keta ) - N > 20 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for input in input_list : <NEWLINE> <INDENT> ans = ans * input <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> res *= a <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
mod = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> index_list = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> index_list . append ( [ l , r ] ) <NEWLINE> <NL> <DEDENT> dp = [ 0 for _ in range ( n ) ] <NEWLINE> dpsum = [ 0 for _ in range ( n ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dpsum [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for l , r in index_list : <NEWLINE> <INDENT> l_index = max ( i - r - 1 , - 1 ) <NEWLINE> r_index = i - l <NEWLINE> if r_index >= 0 : <NEWLINE> <INDENT> dp [ i ] += dpsum [ r_index ] <NEWLINE> if ( r_index > l_index ) & ( l_index >= 0 ) : <NEWLINE> <INDENT> dp [ i ] -= dpsum [ l_index ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp [ i ] = dp [ i ] % mod <NEWLINE> dpsum [ i ] = ( dp [ i ] + dpsum [ i - 1 ] ) % mod <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> from sys import stdin <NEWLINE> from operator import itemgetter <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import math <NEWLINE> import pprint <NEWLINE> from functools import reduce <NEWLINE> <COMMENT> <NL> <NL> def keta ( kazu ) : <NEWLINE> <INDENT> kazu_str = str ( kazu ) <NEWLINE> kazu_list = [ int ( kazu_str [ i ] ) for i in range ( 0 , len ( kazu_str ) ) ] <NEWLINE> return kazu_list <NEWLINE> <NL> <DEDENT> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] ) ) <NEWLINE> <NL> A_ = Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( A_ [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> b = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> remainder = 0 <NEWLINE> ans = - 1 <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> remainder = ( remainder * 10 + 7 ) % K <NEWLINE> if remainder == 0 : <NEWLINE> <INDENT> ans = n <NEWLINE> break <NEWLINE> <DEDENT> if n == 10 ** 6 - 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> r = [ ] <NEWLINE> b = [ ] <NEWLINE> g = [ ] <NEWLINE> for i , si in enumerate ( s ) : <NEWLINE> <INDENT> if si == <STRING> : <NEWLINE> <INDENT> r . append ( i + 1 ) <NEWLINE> <DEDENT> elif si == <STRING> : <NEWLINE> <INDENT> g . append ( i + 1 ) <NEWLINE> <DEDENT> elif si == <STRING> : <NEWLINE> <INDENT> b . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( r ) * len ( g ) * len ( b ) - count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> port = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ 1 ] <NEWLINE> flag = [ False for i in range ( n ) ] <NEWLINE> current = 1 <NEWLINE> <NL> t = k <NEWLINE> <NL> while flag [ port [ current - 1 ] - 1 ] == False and t > 0 : <NEWLINE> <INDENT> visited . append ( port [ current - 1 ] ) <NEWLINE> flag [ port [ current - 1 ] - 1 ] = True <NEWLINE> current = port [ current - 1 ] <NEWLINE> t -= 1 <NEWLINE> <NL> <DEDENT> if t > 0 : <NEWLINE> <INDENT> s = visited . index ( port [ current - 1 ] ) <NEWLINE> bubun = visited [ s : ] <NEWLINE> g = ( k - s ) % len ( bubun ) <NEWLINE> print ( bubun [ g ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( current ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r * r , 2 * math . pi * r ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minX = min ( X ) <NEWLINE> maxX = max ( X ) <NEWLINE> if minX == maxX : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> HP = [ ] <NEWLINE> for p in range ( minX , maxX ) : <NEWLINE> <INDENT> hp = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> hp += ( x - p ) ** 2 <NEWLINE> <DEDENT> HP . append ( hp ) <NEWLINE> <NL> <DEDENT> print ( min ( HP ) ) <NEWLINE>
import bisect <NEWLINE> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> s = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( q ) ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] + s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for l , r in lr : <NEWLINE> <INDENT> print ( bisect . bisect ( a , r - 1 ) - bisect . bisect ( a , l - 0.1 ) ) <NEWLINE> <DEDENT>
text = <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> text += x <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> text_new = text . lower ( ) <NEWLINE> alphabet = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in alphabet : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in text_new : <NEWLINE> <INDENT> if j == i : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i + <STRING> + str ( tmp ) ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m , l = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> matA = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] <NEWLINE> matB = [ [ 0 for k in range ( l ) ] for j in range ( m ) ] <NEWLINE> matC = [ [ 0 for k in range ( l ) ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> matA [ i ] [ j ] = tmp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( l ) : <NEWLINE> <INDENT> matB [ j ] [ k ] = tmp [ k ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( l ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> matC [ i ] [ k ] += matA [ i ] [ j ] * matB [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( l ) : <NEWLINE> <INDENT> if k == l - 1 : <NEWLINE> <INDENT> print ( matC [ i ] [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( matC [ i ] [ k ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> P [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( P [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minp = [ p [ 0 ] ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> minp . append ( min ( minp [ i - 1 ] , p [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minp [ i ] == p [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> items = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = str ( input ( ) ) <NEWLINE> items [ a ] = 0 <NEWLINE> <DEDENT> print ( len ( items ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 , 10001 , 1000 ) : <NEWLINE> <INDENT> if i - N == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if i - N > 0 : <NEWLINE> <INDENT> ans = i - N <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> while 1 : <NEWLINE> <INDENT> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> dp = [ [ 0 for _ in range ( s + 1 ) ] for _ in range ( n * n + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i , j in itertools . product ( range ( 1 , n * n + 1 ) , range ( s + 1 ) ) : <NEWLINE> <INDENT> if j >= i : dp [ i ] [ j ] += dp [ i - 1 ] [ j - i ] + dp [ i ] [ j - i ] <NEWLINE> if j - m >= 1 : dp [ i ] [ j ] += 100000 - dp [ i - 1 ] [ j - m - 1 ] <NEWLINE> dp [ i ] [ j ] %= 100000 <NEWLINE> <DEDENT> print ( dp [ n * n ] [ s ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> k = 0 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a *= A [ i ] <NEWLINE> if a > 10 ** ( 18 ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if k == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = str ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> riron_sum = b . count ( <STRING> ) * b . count ( <STRING> ) * b . count ( <STRING> ) <NEWLINE> <NL> for i in range ( 0 , a ) : <NEWLINE> <INDENT> for n in range ( 0 , a + 1 ) : <NEWLINE> <INDENT> j = i + n <NEWLINE> k = j + n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if k >= a : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if b [ i ] != b [ j ] and b [ j ] != b [ k ] and b [ k ] != b [ i ] : <NEWLINE> <INDENT> riron_sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( riron_sum ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = sum ( b ) <NEWLINE> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while j > 0 and t > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> t -= b [ j ] <NEWLINE> <DEDENT> if t > k : break <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> if i == n : break <NEWLINE> t += a [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> mark = False <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> mark = True <NEWLINE> <DEDENT> if mark == False : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> mark = True <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not mark : print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = str ( i ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = float ( input ( ) ) <NEWLINE> if a <= 48 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 48 and a <= 51 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 51 and a <= 54 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 54 and a <= 57 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 57 and a <= 60 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 60 and a <= 64 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 64 and a <= 69 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 69 and a <= 75 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 75 and a <= 81 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 81 and a <= 91 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 91 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : break <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = min ( B , N ) <NEWLINE> <NL> if a == B : <NEWLINE> <INDENT> print ( math . floor ( A * ( B - 1 ) / B ) - A * math . floor ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) - A * math . floor ( N / B ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> from bisect import bisect_left <NEWLINE> from collections import deque <NEWLINE> <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edges [ u ] . append ( v ) <NEWLINE> edges [ v ] . append ( u ) <NEWLINE> <NL> <NL> <DEDENT> INF = 10 ** 10 <NEWLINE> dp = [ ] <NEWLINE> pos = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> q = deque ( [ ] ) <NEWLINE> def dfs ( v , p ) : <NEWLINE> <INDENT> global pos <NEWLINE> <COMMENT> <NL> a = As [ v ] <NEWLINE> ind = bisect_left ( dp , a ) <NEWLINE> if ind == len ( dp ) : <NEWLINE> <INDENT> dp . append ( a ) <NEWLINE> <COMMENT> <NL> q . append ( ( True , - 1 , - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = dp [ ind ] <NEWLINE> dp [ ind ] = a <NEWLINE> q . append ( ( False , ind , tmp ) ) <NEWLINE> <NL> <DEDENT> ans [ v ] = len ( dp ) <NEWLINE> for u in edges [ v ] : <NEWLINE> <INDENT> if u == p : continue <NEWLINE> dfs ( u , v ) <NEWLINE> <COMMENT> <NL> isappend , ind , tmp = q . pop ( ) <NEWLINE> if isappend : <NEWLINE> <INDENT> dp . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ ind ] = tmp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> l = set ( [ 1 ] ) <NEWLINE> i = 1 <NEWLINE> while i < x : <NEWLINE> <INDENT> j = 2 <NEWLINE> while j < 10 : <NEWLINE> <INDENT> if i ** j <= x : <NEWLINE> <INDENT> l . add ( i ** j ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
from sys import stdin <NEWLINE> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> while n // 26 >= 1 : <NEWLINE> <INDENT> if n % 26 == 0 : <NEWLINE> <INDENT> a . insert ( 0 , 26 ) <NEWLINE> n = ( n - 26 ) // 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . insert ( 0 , n % 26 ) <NEWLINE> n = ( n - n % 26 ) // 26 <NEWLINE> <DEDENT> <DEDENT> if n > 0 : <NEWLINE> <INDENT> a . insert ( 0 , n ) <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> while i <= len ( a ) : <NEWLINE> <INDENT> t = a [ i - 1 ] <NEWLINE> if t == 1 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 3 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 4 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 5 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 6 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 7 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 8 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 9 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 10 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 11 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 12 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 13 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 14 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 15 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 16 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 17 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 18 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 19 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 20 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 21 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 22 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 23 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 24 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 25 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> elif t == 26 : <NEWLINE> <INDENT> a [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> for a , b in ab : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for c , d in cd : <NEWLINE> <INDENT> ans . append ( abs ( a - c ) + abs ( b - d ) ) <NEWLINE> <DEDENT> print ( ans . index ( min ( ans ) ) + 1 ) <NEWLINE> <DEDENT>
def func ( x ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> for b in range ( 1 , n ) : <NEWLINE> <INDENT> c = n - a * b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( func ( n ) ) <NEWLINE>
import itertools <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> <NL> num_list = [ a , b , c , d , e ] <NEWLINE> factorial = list ( itertools . permutations ( num_list , 5 ) ) <NEWLINE> ans_list = [ ] <NEWLINE> for list in factorial : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in list : <NEWLINE> <INDENT> if tmp % 10 == 0 : <NEWLINE> <INDENT> tmp += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 10 - tmp % 10 <NEWLINE> tmp += i <NEWLINE> <DEDENT> <DEDENT> ans_list . append ( tmp ) <NEWLINE> <NL> <DEDENT> ans_list . sort ( ) <NEWLINE> ans = ans_list [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = deque ( ) <NEWLINE> <NL> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 != 0 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <NL> <DEDENT> print ( * b ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> c = collections . Counter ( x ) <NEWLINE> cc = list ( c . values ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( cc ) ) : <NEWLINE> <INDENT> if cc [ i ] % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ ( a [ i ] - 1 ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> DP = [ 0 , 0 , 0 ] <NEWLINE> m = N // 2 * 2 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , m , 2 ) : <NEWLINE> <INDENT> DP [ 0 ] += A [ i ] <NEWLINE> DP [ 1 ] += A [ i + 1 ] <NEWLINE> DP [ 1 ] = max ( DP [ 0 ] , DP [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( DP [ 1 ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , m , 2 ) : <NEWLINE> <INDENT> DP [ 0 ] += A [ i ] <NEWLINE> DP [ 1 ] += A [ i + 1 ] <NEWLINE> DP [ 2 ] += A [ i + 2 ] <NEWLINE> <NL> DP [ 1 ] = max ( DP [ 0 ] , DP [ 1 ] ) <NEWLINE> DP [ 2 ] = max ( DP [ 1 ] , DP [ 2 ] ) <NEWLINE> <NL> <DEDENT> print ( DP [ 2 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> stock = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> stock = money // A [ i ] <NEWLINE> money -= stock * A [ i ] <NEWLINE> money += stock * A [ i + 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ [ c == <STRING> for c in input ( ) ] for _ in range ( H ) ] <NEWLINE> field = np . array ( field , dtype = np . int16 ) <NEWLINE> <NL> u = field . copy ( ) <NEWLINE> d = field . copy ( ) <NEWLINE> l = field . copy ( ) <NEWLINE> r = field . copy ( ) <NEWLINE> <NL> for i in range ( 1 , H ) : <NEWLINE> <INDENT> u [ i ] = ( u [ i - 1 ] + 1 ) * u [ i ] <NEWLINE> d [ - i - 1 ] = ( d [ - i ] + 1 ) * d [ - i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 1 , W ) : <NEWLINE> <INDENT> l [ : , j ] = ( l [ : , j - 1 ] + 1 ) * l [ : , j ] <NEWLINE> r [ : , - j - 1 ] = ( r [ : , - j ] + 1 ) * r [ : , - j - 1 ] <NEWLINE> <NL> <DEDENT> print ( ( u + d + l + r - 3 ) . max ( ) ) <NEWLINE>
import numpy as np <NEWLINE> mod = 998244353 <NEWLINE> <NL> def poly_mul ( f , g ) : <NEWLINE> <COMMENT> <NL> <INDENT> Lf = len ( f ) ; Lg = len ( g ) ; L = Lf + Lg - 1 <NEWLINE> if Lf <= 16 or Lg <= 16 : <NEWLINE> <INDENT> if Lf == 0 or Lg == 0 : <NEWLINE> <INDENT> return np . zeros ( ( 0 , ) , dtype = np . int64 ) <NEWLINE> <DEDENT> return ( np . convolve ( f . astype ( np . uint64 ) , g . astype ( np . uint64 ) ) % mod ) . astype ( np . int64 ) <NEWLINE> <DEDENT> fft = np . fft . rfft ; ifft = np . fft . irfft <NEWLINE> fft_len = 1 << L . bit_length ( ) <NEWLINE> fl = f & ( 1 << 15 ) - 1 ; fh = f >> 15 <NEWLINE> gl = g & ( 1 << 15 ) - 1 ; gh = g >> 15 <NEWLINE> x = ( ifft ( fft ( fl , fft_len ) * fft ( gl , fft_len ) ) [ : L ] + 0.5 ) . astype ( np . int64 ) % mod <NEWLINE> y = ( ifft ( fft ( fl + fh , fft_len ) * fft ( gl + gh , fft_len ) ) [ : L ] + 0.5 ) . astype ( np . int64 ) % mod <NEWLINE> z = ( ifft ( fft ( fh , fft_len ) * fft ( gh , fft_len ) ) [ : L ] + 0.5 ) . astype ( np . int64 ) % mod <NEWLINE> return ( x + ( ( y - x - z ) << 15 ) + ( z << 30 ) ) % mod <NEWLINE> <NL> <DEDENT> def poly_inv ( fps , n = None ) : <NEWLINE> <INDENT> assert fps [ 0 ] != 0 <NEWLINE> if n is None : <NEWLINE> <INDENT> n = len ( fps ) <NEWLINE> <DEDENT> res = np . zeros ( 1 << ( n - 1 ) . bit_length ( ) , dtype = np . int64 ) <NEWLINE> res [ 0 ] = pow ( int ( fps [ 0 ] ) , mod - 2 , mod ) <NEWLINE> i = 1 <NEWLINE> while i < n : <NEWLINE> <INDENT> i <<= 1 <NEWLINE> res [ : i ] = ( ( res [ : i ] << 1 ) - poly_mul ( poly_mul ( res [ : i >> 1 ] , res [ : i >> 1 ] ) , fps [ : i ] ) [ : i ] ) % mod <NEWLINE> <DEDENT> return res [ : n ] <NEWLINE> <NL> <DEDENT> def poly_div ( fps1 , fps2 ) : <NEWLINE> <INDENT> n1 , n2 = len ( fps1 ) , len ( fps2 ) <NEWLINE> if n1 < n2 : <NEWLINE> <INDENT> return np . zeros ( ( 0 , ) , dtype = np . int64 ) <NEWLINE> <DEDENT> n = n1 - n2 + 1 <NEWLINE> res = poly_mul ( fps1 [ - 1 : - n - 1 : - 1 ] , poly_inv ( fps2 [ : : - 1 ] , n ) ) [ n - 1 : : - 1 ] <NEWLINE> return res <NEWLINE> <NL> <DEDENT> def poly_mod ( fps1 , fps2 ) : <NEWLINE> <INDENT> n1 , n2 = len ( fps1 ) , len ( fps2 ) <NEWLINE> if n1 < n2 : <NEWLINE> <INDENT> return fps1 <NEWLINE> <DEDENT> res = fps1 [ : n2 - 1 ] - poly_mul ( poly_div ( fps1 , fps2 ) , fps2 ) [ : n2 - 1 ] <NEWLINE> return res % mod <NEWLINE> <NL> <DEDENT> def multipoint_evaluation ( fps , xs ) : <NEWLINE> <INDENT> threshold = 8 <NEWLINE> n_xs = len ( xs ) <NEWLINE> bit = ( n_xs - 1 ) . bit_length ( ) <NEWLINE> if bit <= threshold : <NEWLINE> <INDENT> res = np . zeros_like ( xs ) <NEWLINE> xs_cumprod = np . ones_like ( xs ) <NEWLINE> for coef in fps : <NEWLINE> <INDENT> res += xs_cumprod * coef <NEWLINE> xs_cumprod *= xs <NEWLINE> xs_cumprod %= mod <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> k = 1 << bit <NEWLINE> fpss = np . zeros ( ( bit + 1 , k + 1 ) , dtype = fps . dtype ) <NEWLINE> fpss [ 0 , : n_xs ] = - xs % mod <NEWLINE> fpss [ 1 , : k : 2 ] = fpss [ 0 , : k : 2 ] * fpss [ 0 , 1 : : 2 ] % mod <NEWLINE> fpss [ 1 , 1 : : 2 ] = ( fpss [ 0 , : k : 2 ] + fpss [ 0 , 1 : : 2 ] ) % mod <NEWLINE> for i in range ( 1 , bit ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , k , step ) : <NEWLINE> <INDENT> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : j + step + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> f = poly_mul ( f1 , f2 ) <NEWLINE> fpss [ i + 1 , j : j + step ] = f [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT> f = poly_mod ( fps , f ) <NEWLINE> fpss [ - 1 , : len ( f ) ] = f <NEWLINE> fpss [ - 1 , len ( f ) : ] = 0 <NEWLINE> for i in range ( bit - 1 , threshold - 1 , - 1 ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , k , step ) : <NEWLINE> <INDENT> f = fpss [ i + 1 , j : j + step ] <NEWLINE> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : j + step + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> fpss [ i , j : j + half ] = poly_mod ( f , f1 ) <NEWLINE> fpss [ i , j + half : j + step ] = poly_mod ( f , f2 ) <NEWLINE> <DEDENT> <DEDENT> xs = ( - fpss [ 0 , : k ] % mod ) . reshape ( - 1 , 1 << threshold ) <NEWLINE> xs_cumprod = np . ones_like ( xs ) <NEWLINE> res = np . zeros_like ( xs ) <NEWLINE> for i in range ( 1 << threshold ) : <NEWLINE> <INDENT> res += fpss [ threshold , i : k : 1 << threshold , None ] * xs_cumprod % mod <NEWLINE> xs_cumprod *= xs <NEWLINE> xs_cumprod %= mod <NEWLINE> <DEDENT> return res . reshape ( - 1 ) [ : n_xs ] % mod <NEWLINE> <NL> <DEDENT> def poly_differential ( fps ) : <NEWLINE> <INDENT> return fps [ 1 : ] * np . arange ( 1 , len ( fps ) ) % mod <NEWLINE> <NL> <DEDENT> def lagrange_interpolation ( X , Y , mod ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = len ( X ) <NEWLINE> g = [ 0 ] * ( n + 1 ) <NEWLINE> g [ 0 ] = 1 <NEWLINE> for i , x in enumerate ( X ) : <NEWLINE> <INDENT> for j in range ( i , - 1 , - 1 ) : <NEWLINE> <INDENT> g [ j + 1 ] += g [ j ] * ( - x ) % mod <NEWLINE> <DEDENT> <DEDENT> res = [ 0 ] * n <NEWLINE> for x , y in zip ( X , Y ) : <NEWLINE> <INDENT> f = g [ : ] <NEWLINE> denom = 0 <NEWLINE> v = 1 <NEWLINE> pow_x = [ 1 ] <COMMENT> <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> v = v * x % mod <NEWLINE> pow_x . append ( v ) <NEWLINE> <DEDENT> pow_x . reverse ( ) <COMMENT> <NEWLINE> for i , po in enumerate ( pow_x ) : <NEWLINE> <INDENT> f_i = f [ i ] <NEWLINE> f [ i + 1 ] += f_i * x % mod <COMMENT> <NEWLINE> denom = ( denom + f_i * po ) % mod <NEWLINE> <DEDENT> denom_inv = pow ( denom , mod - 2 , mod ) <NEWLINE> for i , f_i in enumerate ( f [ : n ] ) : <NEWLINE> <INDENT> res [ i ] += ( f_i * y * denom_inv ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return [ v % mod for v in res ] <NEWLINE> <NL> <DEDENT> def polynomial_interpolation ( xs , ys ) : <NEWLINE> <COMMENT> <NL> <INDENT> assert len ( xs ) == len ( ys ) <NEWLINE> threshold = 8 <NEWLINE> as_strided = np . lib . stride_tricks . as_strided <NEWLINE> n = len ( xs ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return ys . copy ( ) <NEWLINE> <DEDENT> bit = ( n - 1 ) . bit_length ( ) <NEWLINE> if bit <= threshold : <NEWLINE> <INDENT> res = lagrange_interpolation ( xs . tolist ( ) , ys . tolist ( ) , mod ) <NEWLINE> return np . array ( res [ : : - 1 ] , dtype = np . int64 ) <NEWLINE> <DEDENT> k = 1 << bit <NEWLINE> fpss = np . zeros ( ( bit + 1 , n + 1 ) , dtype = np . int64 ) <NEWLINE> fpss [ 0 , : n ] = - xs % mod <NEWLINE> for i in range ( bit ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , n , step ) : <NEWLINE> <INDENT> if j + half >= n : <NEWLINE> <INDENT> fpss [ i + 1 , j : n ] = fpss [ i , j : n ] <NEWLINE> continue <NEWLINE> <DEDENT> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : j + step + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> f = poly_mul ( f1 , f2 ) <NEWLINE> fpss [ i + 1 , j : j + len ( f ) - 1 ] = f [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT> fpss2 = np . zeros ( ( bit + 1 , k + 1 ) , dtype = np . int64 ) <NEWLINE> fpss2 [ bit , : n ] = poly_differential ( f ) <NEWLINE> for i in range ( bit - 1 , threshold - 1 , - 1 ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , n , step ) : <NEWLINE> <INDENT> if j + half >= n : <NEWLINE> <INDENT> fpss2 [ i , j : n ] = fpss2 [ i + 1 , j : n ] <NEWLINE> continue <NEWLINE> <DEDENT> f = fpss2 [ i + 1 , j : min ( j + step , n ) ] <NEWLINE> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : min ( j + step , n ) + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> fpss2 [ i , j : j + half ] = poly_mod ( f , f1 ) <NEWLINE> fpss2 [ i , j + half : min ( j + step , n ) ] = poly_mod ( f , f2 ) <NEWLINE> <DEDENT> <DEDENT> xs = as_strided ( xs , ( k >> threshold , 1 << threshold ) , ( 8 << threshold , 8 ) ) <NEWLINE> xs_cumprod = np . ones_like ( xs ) <NEWLINE> f = np . zeros_like ( xs ) <NEWLINE> for i in range ( 1 << threshold ) : <NEWLINE> <INDENT> f += fpss2 [ threshold , i : k : 1 << threshold , None ] * xs_cumprod % mod <NEWLINE> xs_cumprod *= xs <NEWLINE> xs_cumprod %= mod <NEWLINE> <DEDENT> f = f . ravel ( ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> fpss2 [ 0 , j ] = ys [ j ] * pow ( int ( f [ j ] ) , mod - 2 , mod ) % mod <NEWLINE> <DEDENT> for i in range ( bit ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , k , step ) : <NEWLINE> <INDENT> if j + half >= n : <NEWLINE> <INDENT> fpss2 [ i + 1 , j : n ] = fpss2 [ i , j : n ] <NEWLINE> continue <NEWLINE> <DEDENT> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : j + step + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> fpss2 [ i + 1 , j : min ( j + step , n ) ] = ( <NEWLINE> <INDENT> poly_mul ( fpss2 [ i , j : j + half ] , f2 ) <NEWLINE> + poly_mul ( fpss2 [ i , j + half : min ( j + step , n ) ] , f1 ) <NEWLINE> <DEDENT> ) % mod <NEWLINE> <DEDENT> <DEDENT> return fpss2 [ bit , : n ] <NEWLINE> <NL> <DEDENT> mod = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> X = np . arange ( mod , dtype = np . int64 ) <NEWLINE> Ans = polynomial_interpolation ( X , A ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans . tolist ( ) ) ) ) <NEWLINE>
def conv ( s ) : <NEWLINE> <INDENT> if s . find ( <STRING> ) == - 1 : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> s = s . rstrip ( <STRING> ) <NEWLINE> t = len ( s ) - s . find ( <STRING> ) - 1 <NEWLINE> a = int ( s . replace ( <STRING> , <STRING> ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> return ( 0 , 0 ) <NEWLINE> <DEDENT> x , y = - t , - t <NEWLINE> while a % 5 == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> a //= 5 <NEWLINE> <DEDENT> while a % 2 == 0 : <NEWLINE> <INDENT> y += 1 <NEWLINE> a //= 2 <NEWLINE> <DEDENT> return ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> N , * A = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> <NL> d = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> t = conv ( a ) <NEWLINE> d . setdefault ( t , 0 ) <NEWLINE> d [ t ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> xs = list ( d . keys ( ) ) <NEWLINE> for i in range ( len ( xs ) ) : <NEWLINE> <INDENT> x , y = xs [ i ] <NEWLINE> t = d [ xs [ i ] ] <NEWLINE> if x >= 0 and y >= 0 : <NEWLINE> <INDENT> result += t * ( t - 1 ) // 2 <NEWLINE> <DEDENT> for j in range ( i + 1 , len ( xs ) ) : <NEWLINE> <INDENT> m , n = xs [ j ] <NEWLINE> if x + m >= 0 and y + n >= 0 : <NEWLINE> <INDENT> result += t * d [ xs [ j ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in p : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> p [ i + 1 ] = p [ i ] * p [ i + 1 ] <NEWLINE> if p [ i + 1 ] > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p [ i + 1 ] ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> if <STRING> in s and <STRING> in s : <NEWLINE> <INDENT> if s . find ( <STRING> ) < s . rfind ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n , k = map ( int , args [ 0 ] . split ( ) ) <NEWLINE> A = tuple ( map ( int , args [ 1 ] . split ( ) ) ) <NEWLINE> <NL> l , r = 1 , max ( A ) <NEWLINE> while 0.1 < r - l : <NEWLINE> <INDENT> m = ( l + r ) / 2 <NEWLINE> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt += - int ( - a // m ) - 1 <NEWLINE> <NL> <DEDENT> if k < cnt : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <NL> <DEDENT> <DEDENT> return str ( - int ( - l // 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = Counter ( a ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in count . values ( ) : ans += i * ( i - 1 ) // 2 <NEWLINE> for i in a : print ( ans - ( count [ i ] - 1 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> MOD = 2019 <NEWLINE> r = [ 0 ] * MOD <NEWLINE> r [ 0 ] = 1 <NEWLINE> z = 0 <NEWLINE> t = 1 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> z = int ( i ) * t + z <NEWLINE> z %= MOD <NEWLINE> t *= 10 <NEWLINE> t %= MOD <NEWLINE> r [ z ] += 1 <NEWLINE> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in r ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> dp = np . zeros ( ( n + 1 , n + 1 , 3001 ) ) . astype ( np . int64 ) <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> _x = x [ i ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> dp [ i + 1 , j + 1 , _x : ] += dp [ i , j , : - _x ] <NEWLINE> dp [ i + 1 , j , : ] += dp [ i , j , : ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += dp [ n , j , j * a ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 998244353 <NEWLINE> ans = ( M * pow ( M - 1 , N - 1 , m ) ) % m <NEWLINE> alpha = 1 <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> alpha = ( alpha * ( N - k ) * pow ( k , m - 2 , m ) ) % m <NEWLINE> ans = ( ans + M * alpha * pow ( M - 1 , N - k - 1 , m ) ) % m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 100010 ) <NEWLINE> lst = [ 100 , 101 , 102 , 103 , 104 , 105 ] <NEWLINE> for i in range ( 100 , 106 ) : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for v in range ( 100 , X + 1 ) : <NEWLINE> <INDENT> for w in range ( 6 ) : <NEWLINE> <INDENT> n = lst [ w ] <NEWLINE> if dp [ v - n ] == 1 : <NEWLINE> <INDENT> dp [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ X ] ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = a [ 0 ] <NEWLINE> K = a [ 1 ] <NEWLINE> <NL> a = [ 0 ] * K <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for x in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> a [ x - 1 ] = pow ( K // x , N , mod ) <NEWLINE> for t in range ( 2 , K // x + 1 ) : <NEWLINE> <INDENT> a [ x - 1 ] -= a [ t * x - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> s += ( i + 1 ) * a [ i ] <NEWLINE> <NL> <DEDENT> ans = s % mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> from functools import lru_cache , cmp_to_key <NEWLINE> from heapq import merge , heapify , heappop , heappush <NEWLINE> from math import * <NEWLINE> from collections import defaultdict as dd , deque , Counter as C <NEWLINE> from itertools import combinations as comb , permutations as perm <NEWLINE> from bisect import bisect_left as bl , bisect_right as br , bisect <NEWLINE> from time import perf_counter <NEWLINE> from fractions import Fraction <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> mod = int ( pow ( 10 , 9 ) + 7 ) <NEWLINE> mod2 = 998244353 <NEWLINE> def data ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def out ( * var , end = <STRING> ) : sys . stdout . write ( <STRING> . join ( map ( str , var ) ) + end ) <NEWLINE> def l ( ) : return list ( sp ( ) ) <NEWLINE> def sl ( ) : return list ( ssp ( ) ) <NEWLINE> def sp ( ) : return map ( int , data ( ) . split ( ) ) <NEWLINE> def ssp ( ) : return map ( str , data ( ) . split ( ) ) <NEWLINE> def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] <NEWLINE> def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] <NEWLINE> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = l ( ) [ 0 ] <NEWLINE> A = l ( ) <NEWLINE> ans = 1 <NEWLINE> if ( 0 in A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A . sort ( reverse = True ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
b = input ( ) <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> total = R * G * B <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = j + ( j - i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if k >= N or S [ i ] == S [ j ] or S [ i ] == S [ k ] or S [ j ] == S [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> total -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = { 1 : 0 } <NEWLINE> index = 0 <NEWLINE> last = 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> t = A [ last - 1 ] <NEWLINE> index += 1 <NEWLINE> if t in visited : <NEWLINE> <INDENT> z = K - i - 1 <NEWLINE> l = index - visited [ t ] <NEWLINE> print ( [ k for k , v in visited . items ( ) if v == visited [ t ] + ( z % l ) ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ t ] = index <NEWLINE> last = t <NEWLINE> <NL> <DEDENT> <DEDENT> print ( last ) <NEWLINE> <NL>
class Factorial ( ) : <NEWLINE> <INDENT> def __init__ ( self , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . _factorial = [ 1 ] <NEWLINE> self . _size = 1 <NEWLINE> self . _factorial_inv = [ 1 ] <NEWLINE> self . _size_inv = 1 <NEWLINE> <NL> <DEDENT> def __call__ ( self , n ) : <NEWLINE> <INDENT> return self . fact ( n ) <NEWLINE> <NL> <DEDENT> def fact ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n >= self . mod : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> self . _make ( n ) <NEWLINE> return self . _factorial [ n ] <NEWLINE> <NL> <DEDENT> def _make ( self , n ) : <NEWLINE> <INDENT> if n >= self . mod : <NEWLINE> <INDENT> n = self . mod <NEWLINE> <DEDENT> if self . _size < n + 1 : <NEWLINE> <INDENT> for i in range ( self . _size , n + 1 ) : <NEWLINE> <INDENT> self . _factorial . append ( self . _factorial [ i - 1 ] * i % self . mod ) <NEWLINE> <DEDENT> self . _size = n + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def fact_inv ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n >= self . mod : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( n ) ) <NEWLINE> <DEDENT> if self . _size_inv < n + 1 : <NEWLINE> <INDENT> self . _factorial_inv += [ - 1 ] * ( n + 1 - self . _size_inv ) <NEWLINE> self . _size_inv = n + 1 <NEWLINE> <DEDENT> if self . _factorial_inv [ n ] == - 1 : <NEWLINE> <INDENT> self . _factorial_inv [ n ] = self . modinv ( self . fact ( n ) ) <NEWLINE> <DEDENT> return self . _factorial_inv [ n ] <NEWLINE> <NL> <DEDENT> def _make_inv ( self , n , r = 2 ) : <NEWLINE> <INDENT> if n >= self . mod : <NEWLINE> <INDENT> n = self . mod - 1 <NEWLINE> <DEDENT> if self . _size_inv < n + 1 : <NEWLINE> <INDENT> self . _factorial_inv += [ - 1 ] * ( n + 1 - self . _size_inv ) <NEWLINE> self . _size_inv = n + 1 <NEWLINE> <DEDENT> self . _factorial_inv [ n ] = self . modinv ( self . fact ( n ) ) <NEWLINE> for i in range ( n , r , - 1 ) : <NEWLINE> <INDENT> self . _factorial_inv [ i - 1 ] = self . _factorial_inv [ i ] * i % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> @ staticmethod <NEWLINE> def xgcd ( a , b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x0 , x1 , y0 , y1 = 0 , 1 , 1 , 0 <NEWLINE> while a != 0 : <NEWLINE> <INDENT> ( q , a ) , b = divmod ( b , a ) , a <NEWLINE> y0 , y1 = y1 , y0 - q * y1 <NEWLINE> x0 , x1 = x1 , x0 - q * x1 <NEWLINE> <DEDENT> return b , x0 , y0 <NEWLINE> <NL> <DEDENT> def modinv ( self , n ) : <NEWLINE> <INDENT> g , x , _ = self . xgcd ( n , self . mod ) <NEWLINE> if g != 1 : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( n ) ) <NEWLINE> <DEDENT> return x % self . mod <NEWLINE> <NL> <DEDENT> def comb ( self , n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> t = self ( n ) * self . fact_inv ( n - r ) % self . mod <NEWLINE> return t * self . fact_inv ( r ) % self . mod <NEWLINE> <NL> <DEDENT> def comb_ ( self , n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = 1 <NEWLINE> for i in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> c *= ( n - i + 1 ) * self . fact_inv ( i ) <NEWLINE> c %= self . mod <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def comb_with_repetition ( self , n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> t = self ( n + r - 1 ) * self . fact_inv ( n - 1 ) % self . mod <NEWLINE> return t * self . fact_inv ( r ) % self . mod <NEWLINE> <NL> <DEDENT> def perm ( self , n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self ( n ) * self . fact_inv ( n - r ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> f = Factorial ( mod ) <NEWLINE> f . _make_inv ( n - 1 ) <NEWLINE> comb = f . comb <NEWLINE> s = 0 <NEWLINE> for i in range ( k + 1 , n ) : <NEWLINE> <INDENT> t = comb ( n - 1 , i ) * m % mod <NEWLINE> t = t * pow ( m - 1 , n - 1 - i , mod ) % mod <NEWLINE> s = ( s + t ) % mod <NEWLINE> <DEDENT> ans = ( pow ( m , n , mod ) - s ) % mod <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> sw = True <NEWLINE> b = sorted ( a , reverse = True ) <NEWLINE> <NL> if b [ 0 ] > b [ 1 ] : <NEWLINE> <INDENT> max2 = b [ 1 ] <NEWLINE> max1 = b [ 0 ] <NEWLINE> sw = False <NEWLINE> <NL> <DEDENT> if sw == True : <NEWLINE> <INDENT> max1 = b [ 0 ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if a [ k ] == max1 : <NEWLINE> <INDENT> print ( max2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . rank = [ 0 ] * n <NEWLINE> self . parent = [ i for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = self . find ( self . parent [ x ] ) <NEWLINE> return self . parent [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . parent [ x ] = y <NEWLINE> <DEDENT> elif self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> self . parent [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = y <NEWLINE> self . rank [ y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if com == 0 : <NEWLINE> <INDENT> uf . merge ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 if uf . same ( x , y ) else 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> adds = dict ( ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> sub = j - a [ j ] <NEWLINE> if sub in adds . keys ( ) : <NEWLINE> <INDENT> ans += adds [ sub ] <NEWLINE> <NL> <DEDENT> add = j + a [ j ] <NEWLINE> if add in adds . keys ( ) : <NEWLINE> <INDENT> adds [ add ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> adds [ add ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def combi ( n , r ) : <NEWLINE> <INDENT> x , y = 1 , 1 <NEWLINE> for i in range ( n - r + 1 , n + 1 ) : <NEWLINE> <INDENT> x *= i <NEWLINE> x %= mod <NEWLINE> <NL> <DEDENT> for j in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> y *= j <NEWLINE> y %= mod <NEWLINE> <DEDENT> yinv = pow ( y , mod - 2 , mod ) <NEWLINE> <NL> return x * yinv % mod <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> nca = combi ( n , a ) <NEWLINE> ncb = combi ( n , b ) <NEWLINE> ans = pow ( 2 , n , mod ) - 1 - ( nca + ncb ) <NEWLINE> <NL> print ( ans % mod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> circumference = math . pi * r ** 2 <NEWLINE> area = 2 * math . pi * r <NEWLINE> print ( <STRING> . format ( circumference , area ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = sorted ( A ) <NEWLINE> <NL> def histogram_sorted ( data ) : <NEWLINE> <INDENT> table = [ ] <NEWLINE> prev = data [ 0 ] <NEWLINE> c = 1 <NEWLINE> for i in range ( 1 , len ( data ) ) : <NEWLINE> <INDENT> if prev == data [ i ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table . append ( [ prev , c ] ) <NEWLINE> prev = data [ i ] <NEWLINE> c = 1 <NEWLINE> <DEDENT> <DEDENT> table . append ( [ prev , c ] ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> X = histogram_sorted ( B ) <NEWLINE> <NL> X . append ( [ 0 , 0 ] ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if X [ c ] [ 0 ] == i : <NEWLINE> <INDENT> print ( X [ c ] [ 1 ] ) <NEWLINE> c = c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
INF = float ( <STRING> ) <NEWLINE> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * ( N + 1 ) <NEWLINE> b = [ 0 ] * ( M + 1 ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + x <NEWLINE> <NL> <DEDENT> for i , x in enumerate ( B ) : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + x <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i , va in enumerate ( a ) : <NEWLINE> <INDENT> if va > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while va + b [ j ] > K : <NEWLINE> <COMMENT> <NL> <INDENT> j -= 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( i + j , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( i , k ) : <NEWLINE> <INDENT> for h in range ( j , k ) : <NEWLINE> <INDENT> if i == j == h : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i + 1 , j + 1 ) , h + 1 ) <NEWLINE> <DEDENT> elif ( i != j ) and ( j != h ) and ( i != h ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i + 1 , j + 1 ) , h + 1 ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i + 1 , j + 1 ) , h + 1 ) * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> lon = len ( S ) <NEWLINE> for i in range ( lon ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> T = <STRING> . join ( S ) <NEWLINE> <COMMENT> <NL> print ( T ) <NEWLINE>
from numpy import * <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = array ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> nega = A [ A < 0 ] <NEWLINE> zera = A [ A == 0 ] <NEWLINE> posa = A [ 0 < A ] <NEWLINE> <NL> def cnt ( x ) : <NEWLINE> <INDENT> y = 0 <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> y += N * len ( zera ) <NEWLINE> <DEDENT> y += searchsorted ( A , x // posa , side = <STRING> ) . sum ( ) <NEWLINE> y += N * len ( nega ) - searchsorted ( A , - ( - x // nega ) ) . sum ( ) <NEWLINE> y -= len ( A [ A * A <= x ] ) <NEWLINE> return y // 2 <NEWLINE> <NL> <DEDENT> r = 10 ** 18 <NEWLINE> l = - r - 1 <NEWLINE> <NL> while r - l > 1 : <NEWLINE> <INDENT> c = ( r + l ) // 2 <NEWLINE> if K <= cnt ( c ) : <NEWLINE> <INDENT> r = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = c <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import numpy as np <NEWLINE> <NL> s = input ( ) [ : : - 1 ] <NEWLINE> length = len ( s ) <NEWLINE> a = np . zeros ( length , dtype = int ) <NEWLINE> d = np . zeros ( length , dtype = int ) <NEWLINE> ans = np . zeros ( 2019 , dtype = int ) <NEWLINE> x = 10 <NEWLINE> <NL> a [ 0 ] = int ( s [ 0 ] ) <NEWLINE> d [ 0 ] = a [ 0 ] <NEWLINE> ans [ d [ 0 ] ] += 1 <NEWLINE> <NL> for i in range ( 1 , length ) : <NEWLINE> <INDENT> a [ i ] = int ( s [ i ] ) * x % 2019 <NEWLINE> d [ i ] = ( d [ i - 1 ] + a [ i ] ) % 2019 <NEWLINE> ans [ d [ i ] ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <NL> <DEDENT> ans_c = ans [ np . nonzero ( ans ) ] <NEWLINE> <NL> print ( int ( sum ( [ ans_c [ i ] * ( ans_c [ i ] - 1 ) for i in range ( ans_c . shape [ 0 ] ) ] ) / 2 ) + ans [ 0 ] ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> arr . append ( math . gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( len ( arr ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a += math . gcd ( arr [ j ] , k ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( a ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = Counter ( a ) <NEWLINE> ans = [ 0 ] * 2 <NEWLINE> t = 0 <NEWLINE> for i in sorted ( count . items ( ) , reverse = True ) : <NEWLINE> <INDENT> if i [ 1 ] >= 4 : <NEWLINE> <INDENT> if t == 0 : <NEWLINE> <INDENT> ans [ 0 ] , ans [ 1 ] = i [ 0 ] , i [ 0 ] <NEWLINE> t = 2 <NEWLINE> <DEDENT> elif t == 1 : <NEWLINE> <INDENT> ans [ t ] = i [ 0 ] <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> elif i [ 1 ] >= 2 : <NEWLINE> <INDENT> ans [ t ] = i [ 0 ] <NEWLINE> t += 1 <NEWLINE> <DEDENT> if t == 2 : break <NEWLINE> <DEDENT> print ( ans [ 0 ] * ans [ 1 ] ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> e = 0 <NEWLINE> for a in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for b in range ( a - 140 , a + 140 ) : <NEWLINE> <INDENT> if ( a ** 5 ) - ( b ** 5 ) == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> e = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if e == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mn = min ( n , m ) <NEWLINE> P = [ ] <COMMENT> <NEWLINE> sum_p = 0 <COMMENT> <NEWLINE> X = [ - 1 ] * m <COMMENT> <NEWLINE> for i in range ( mn ) : <NEWLINE> <INDENT> if X [ x ] > - 1 : <NEWLINE> <INDENT> cyc_len = len ( P ) - X [ x ] <NEWLINE> n -= X [ x ] <NEWLINE> cyc = ( sum_p - P [ X [ x ] ] ) * ( n // cyc_len ) <NEWLINE> remain = P [ X [ x ] + n % cyc_len ] <NEWLINE> print ( cyc + remain ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P . append ( sum_p ) <NEWLINE> sum_p += x <NEWLINE> X [ x ] = i <NEWLINE> x = x * x % m <NEWLINE> <DEDENT> print ( sum_p ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> A = input ( ) <NEWLINE> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> max = 10 ** 18 <NEWLINE> if 0 in N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans = ans * N [ i ] <NEWLINE> if ans > max : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ i for i in range ( 1 , n + 1 ) if ( i % 3 == 0 or <STRING> in list ( str ( i ) ) ) ] <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * a , sep = <STRING> ) <NEWLINE>
def judge ( s ) : <NEWLINE> <INDENT> if len ( s ) == 0 : return True <NEWLINE> si = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if t == s [ si ] : <NEWLINE> <INDENT> si += 1 <NEWLINE> if si == len ( s ) : return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> S , T = input ( ) , input ( ) <NEWLINE> N = len ( S ) <NEWLINE> print ( <STRING> if judge ( S [ : : 2 ] ) or judge ( S [ 1 : : 2 ] ) else <STRING> ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> if i != n // i : <NEWLINE> <INDENT> divisors . append ( [ i , n // i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> divisors . append ( [ i , i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <DEDENT> l = make_divisors ( x ) <NEWLINE> for x , y in l : <NEWLINE> <INDENT> for i in range ( 10 ** 4 ) : <NEWLINE> <INDENT> p = i - x <NEWLINE> if i ** 4 + ( i ** 3 ) * p + ( i ** 2 ) * ( p ** 2 ) + i * ( p ** 3 ) + p ** 4 == y : <NEWLINE> <INDENT> print ( i , p ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> if sum ( S ) % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = sorted ( S ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if ( sum ( S ) - i ) % 10 != 0 : <NEWLINE> <INDENT> print ( sum ( S ) - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> <NL> dic = { } <NEWLINE> for a in range ( len ( A ) ) : <NEWLINE> <INDENT> tmp = A [ a ] <NEWLINE> if not tmp in dic : <NEWLINE> <INDENT> dic [ tmp ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> values = sorted ( dic . values ( ) ) <NEWLINE> ans = 0 <NEWLINE> if len ( values ) <= K : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = len ( values ) - K <NEWLINE> values = values [ : tmp ] <NEWLINE> ans = sum ( values ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> ans = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a != 2 and a % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = True <NEWLINE> for j in range ( 3 , int ( math . sqrt ( a ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if a % j == 0 : <NEWLINE> <INDENT> b = False <NEWLINE> <DEDENT> <DEDENT> if b : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = deque ( [ ] ) <NEWLINE> for i in range ( a [ 0 ] ) : q . append ( deque ( [ ] ) ) <NEWLINE> <NL> for i in range ( a [ 1 ] ) : <NEWLINE> <INDENT> cmd = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if cmd [ 0 ] == 0 : <NEWLINE> <INDENT> q [ cmd [ 1 ] ] . append ( cmd [ 2 ] ) <NEWLINE> <NL> <DEDENT> elif cmd [ 0 ] == 1 : <NEWLINE> <INDENT> if q [ cmd [ 1 ] ] != deque ( [ ] ) : print ( q [ cmd [ 1 ] ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> elif cmd [ 0 ] == 2 : <NEWLINE> <INDENT> if q [ cmd [ 1 ] ] != deque ( [ ] ) : q [ cmd [ 1 ] ] . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> checked_list = [ 0 for _ in range ( N ) ] <NEWLINE> min_INF = - 1 * 10 ** 10 <NEWLINE> max_score = min_INF <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if checked_list [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> posit = i <NEWLINE> loop_list = [ posit ] <NEWLINE> score_list = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> posit = P_list [ posit ] - 1 <NEWLINE> if j == 0 : <NEWLINE> <INDENT> score_list . append ( C_list [ posit ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score_list . append ( score_list [ - 1 ] + C_list [ posit ] ) <NEWLINE> <DEDENT> if posit in loop_list : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> loop_list . append ( posit ) <NEWLINE> <NL> <DEDENT> len_loop = len ( loop_list ) <NEWLINE> max_score_list = max ( score_list ) <NEWLINE> around_score = score_list [ - 1 ] <NEWLINE> temp_score_base = 0 <NEWLINE> if around_score > 0 and K // len_loop > 0 : <NEWLINE> <INDENT> temp_score_base += ( K // len_loop - 1 ) * around_score <NEWLINE> <DEDENT> for k in range ( len_loop ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> checked_list [ loop_list [ k ] ] = 1 <NEWLINE> temp_max_score = temp_score_base <NEWLINE> rest_score = min_INF <NEWLINE> if around_score > 0 and K // len_loop > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> rest_score = max ( max_score_list , max ( score_list [ : K % len_loop ] , default = min_INF ) + around_score ) <NEWLINE> <COMMENT> <NL> <DEDENT> rest_score = max ( max ( score_list [ : min ( K , len_loop ) ] ) , rest_score ) <NEWLINE> temp_max_score = temp_max_score + rest_score <NEWLINE> <COMMENT> <NL> max_score = max ( max_score , temp_max_score ) <NEWLINE> <COMMENT> <NL> now_score = score_list . pop ( 0 ) <NEWLINE> len_score = len ( score_list ) <NEWLINE> score_list = [ score_list [ l ] - now_score for l in range ( len_score ) ] <NEWLINE> score_list . append ( score_list [ - 1 ] + now_score ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_score ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bombX = [ 0 ] * h <NEWLINE> bombY = [ 0 ] * w <NEWLINE> bomb = set ( ) <NEWLINE> maxX = maxY = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> i , j = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> bomb . add ( ( i , j ) ) <NEWLINE> bombX [ i ] += 1 <NEWLINE> bombY [ j ] += 1 <NEWLINE> maxX = max ( maxX , bombX [ i ] ) <NEWLINE> maxY = max ( maxY , bombY [ j ] ) <NEWLINE> <DEDENT> maxX_index = list ( i for i in range ( h ) if bombX [ i ] == maxX ) <NEWLINE> maxY_index = list ( i for i in range ( w ) if bombY [ i ] == maxY ) <NEWLINE> for i in maxX_index : <NEWLINE> <INDENT> for j in maxY_index : <NEWLINE> <INDENT> if ( i , j ) in bomb : continue <NEWLINE> print ( maxX + maxY ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( maxX + maxY - 1 ) <NEWLINE>
def N ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def L ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def NL ( n ) : <NEWLINE> <INDENT> return [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <DEDENT> mod = pow ( 10 , 9 ) + 7 <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> import math <NEWLINE> md = 998244353 <NEWLINE> <NL> n , k = L ( ) <NEWLINE> lr = NL ( k ) <NEWLINE> s = set ( ) <NEWLINE> <NL> for l , r in lr : <NEWLINE> <INDENT> s |= set ( range ( l , r + 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <COMMENT> <NL> c = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i ] + dp [ i - 1 ] ) % md <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> if i + l < n + 1 : <NEWLINE> <INDENT> dp [ i + l ] += dp [ i ] <NEWLINE> dp [ i + l ] %= md <NEWLINE> if i + r + 1 < n + 1 : <NEWLINE> <INDENT> dp [ i + r + 1 ] -= dp [ i ] <NEWLINE> dp [ i + r + 1 ] %= md <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ( dp [ n ] - dp [ n - 1 ] ) % md ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 0 <NEWLINE> if B <= N : <NEWLINE> <INDENT> x = ( N // B ) * B - 1 <NEWLINE> result = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <DEDENT> if B > N : <NEWLINE> <INDENT> result = math . floor ( A * N / B ) - A * math . floor ( N / B ) <NEWLINE> <DEDENT> if B == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
from sys import stdin , stdout <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( stdin . readline ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> prefix = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] , prefix [ 1 ] = 0 , A [ 1 ] <NEWLINE> for i in range ( 3 , N , 2 ) : <NEWLINE> <INDENT> prefix [ i ] = prefix [ i - 2 ] + A [ i ] <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i & 1 : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i - 1 ] , A [ i ] + dp [ i - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i - 2 ] + A [ i ] , prefix [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> stdout . write ( str ( dp [ N ] ) + <STRING> ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( sum ( a [ b - 1 ] == e + 1 for e , b in enumerate ( a ) ) // 2 ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> r = x % d <NEWLINE> q = ( x - r ) // d <NEWLINE> if abs ( x ) >= k * d : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> ans = x - k * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( x + k * d ) <NEWLINE> <DEDENT> <DEDENT> elif k % 2 == q % 2 : <NEWLINE> <INDENT> ans = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = d - r <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , Q = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> P = [ tuple ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> for pair in combinations_with_replacement ( [ i for i in range ( 1 , M + 1 ) ] , N ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for a , b , c , d in P : <NEWLINE> <INDENT> if pair [ b - 1 ] - pair [ a - 1 ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> left = 0 <NEWLINE> right = k <NEWLINE> while right < n : <NEWLINE> <INDENT> if A [ right ] > A [ left ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> left += 1 <NEWLINE> right += 1 <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> H , W , M = LI ( ) <NEWLINE> hw = [ LI ( ) for _ in range ( M ) ] <NEWLINE> hw_set = set ( [ ( h , w ) for h , w in hw ] ) <NEWLINE> <NL> cnt_h = collections . Counter ( [ h for h , w in hw ] ) <NEWLINE> cnt_w = collections . Counter ( [ w for h , w in hw ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> max_h = max ( cnt_h . values ( ) ) <NEWLINE> max_w = max ( cnt_w . values ( ) ) <NEWLINE> max_h_k = [ k for k , v in cnt_h . items ( ) if v == max_h ] <NEWLINE> max_w_k = [ k for k , v in cnt_w . items ( ) if v == max_w ] <NEWLINE> is_on_target = True <NEWLINE> for i , j in itertools . product ( max_h_k , max_w_k ) : <NEWLINE> <INDENT> if ( i , j ) not in hw_set : <NEWLINE> <INDENT> is_on_target = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_on_target : <NEWLINE> <INDENT> ans = max_h + max_w - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max_h + max_w <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N < B - 1 : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <NL> <DEDENT> a = ( A * x ) / B <NEWLINE> aa = math . floor ( a ) <NEWLINE> print ( aa ) <NEWLINE>
import math <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( i , j ) <NEWLINE> if j == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( i , math . gcd ( j , k ) ) * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( len ( list ( set ( S ) ) ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . num = [ 1 for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = self . root ( self . parent [ x ] ) <NEWLINE> return self . parent [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . parent [ x ] = y <NEWLINE> self . num [ y ] += self . num [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> def count ( self , x ) : <NEWLINE> <INDENT> return self . num [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> un = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> un . unite ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , un . count ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <DEDENT> x = int ( input ( ) ) <NEWLINE> l = make_divisors ( x ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> answer = [ 0 , 0 ] <NEWLINE> <DEDENT> for i in range ( math . ceil ( 2 * pow ( x , 0.2 ) ) ) : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> if pow ( i , 5 ) - pow ( i - j , 5 ) == x : <NEWLINE> <INDENT> answer = [ i , i - j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer [ 0 ] , answer [ 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> w_series = [ 0 ] <NEWLINE> e_series = [ 0 ] <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> w_series . append ( w_series [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w_series . append ( w_series [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for c in s [ : : - 1 ] : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> e_series . append ( e_series [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e_series . append ( e_series [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> e_series = e_series [ : : - 1 ] <NEWLINE> <NL> ans = n <NEWLINE> for x in zip ( w_series [ 1 : ] , e_series [ : - 1 ] ) : <NEWLINE> <INDENT> ans = min ( sum ( x ) - 1 , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from functools import reduce <NEWLINE> import functools <NEWLINE> import fractions <NEWLINE> <NL> @ functools . lru_cache ( maxsize = None ) <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( gcd_ , numbers ) <NEWLINE> <NL> <DEDENT> @ functools . lru_cache ( maxsize = None ) <NEWLINE> def gcd_ ( a , b ) : <NEWLINE> <INDENT> if ( b == 0 ) : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if ( i == j ) & ( j == k ) : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif ( i == j ) & ( j != k ) : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) * 3 <NEWLINE> <DEDENT> elif ( i != j ) & ( j == k ) : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) * 3 <NEWLINE> <DEDENT> elif ( i != j ) & ( j != k ) : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def modconb ( n , mod ) : <NEWLINE> <COMMENT> <NL> <INDENT> fac = [ 0 ] * ( n + 1 ) <NEWLINE> finv = [ 0 ] * ( n + 1 ) <NEWLINE> inv = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <COMMENT> <NL> <DEDENT> if n < k : return 0 <NEWLINE> if n < 0 or k < 0 : return 0 <NEWLINE> return fac , finv <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> fac , finv = modconb ( n , mod ) <NEWLINE> As . sort ( ) <NEWLINE> acc = list ( accumulate ( As ) ) <NEWLINE> As . sort ( reverse = True ) <NEWLINE> acc_r = list ( accumulate ( As ) ) <NEWLINE> ans = 0 <NEWLINE> for d in range ( 1 , n ) : <NEWLINE> <INDENT> if d - 1 < k - 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if k - 2 <= 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = fac [ d - 1 ] * ( finv [ k - 2 ] * finv [ d - 1 - ( k - 2 ) ] % mod ) % mod <NEWLINE> <COMMENT> <NL> <DEDENT> ind = min ( d - 1 , n - d - 1 ) <NEWLINE> mn = acc [ ind ] <NEWLINE> mx = acc_r [ ind ] <NEWLINE> ans += ( mx - mn ) * c <NEWLINE> <COMMENT> <NL> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import * <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = ( N + 1 ) * [ 0 ] <NEWLINE> R = ( N + 1 ) * [ 0 ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> L [ n ] = gcd ( L [ n - 1 ] , A [ n ] ) <NEWLINE> <NL> <DEDENT> for n in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> R [ n ] = gcd ( R [ n + 1 ] , A [ n ] ) <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> ans += [ gcd ( L [ n - 1 ] , R [ n + 1 ] ) ] <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ ] <NEWLINE> m = 0 <NEWLINE> arr = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m += ( p [ i ] + 1 ) / 2 <NEWLINE> e . append ( m ) <NEWLINE> <DEDENT> arr . append ( e [ k - 1 ] ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> arr . append ( e [ i + k ] - e [ i ] ) <NEWLINE> <DEDENT> ans = max ( arr ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> all = r * g * b <NEWLINE> ho = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] == s [ k ] or s [ j ] == s [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ho += 1 <NEWLINE> <DEDENT> <DEDENT> print ( all - ho ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
def root ( x ) : <NEWLINE> <INDENT> if F [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> F [ x ] = root ( F [ x ] ) <NEWLINE> return F [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = root ( x ) <NEWLINE> y = root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> F [ x ] += F [ y ] <NEWLINE> F [ y ] = x <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> F = [ - 1 ] * N <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for f in F : <NEWLINE> <INDENT> ans = min ( ans , f ) <NEWLINE> <DEDENT> print ( - ans ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> list = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> list [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if list [ i ] >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> num += int ( c ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> cnt [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for t in cnt : <NEWLINE> <INDENT> ans += t * ( t - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <COMMENT> <NEWLINE> S = list ( input ( ) ) <COMMENT> <NEWLINE> <NL> cou = 0 <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while i + ( 2 * j ) <= N - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ i + j ] and S [ i + j ] != S [ i + ( 2 * j ) ] and S [ i ] != S [ i + ( 2 * j ) ] : <NEWLINE> <INDENT> cou += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) - cou ) <NEWLINE>
while True : <NEWLINE> <INDENT> m , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if m == n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * n ) <NEWLINE> for i in range ( m - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( n - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * n ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
from math import gcd <NEWLINE> <NL> mysum = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> mysum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( mysum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ 0 for i in range ( n ) ] <NEWLINE> visit = [ 0 ] <NEWLINE> visited [ 0 ] = 1 <NEWLINE> s = 0 <NEWLINE> while True : <NEWLINE> <INDENT> s = a [ s ] - 1 <NEWLINE> if visited [ s ] == 1 : <NEWLINE> <INDENT> x = visit [ 0 : visit . index ( s ) ] <NEWLINE> y = visit [ visit . index ( s ) : ] <NEWLINE> break <NEWLINE> <DEDENT> visit . append ( s ) <NEWLINE> visited [ s ] = 1 <NEWLINE> <NL> <DEDENT> if k < len ( x ) : <NEWLINE> <INDENT> print ( x [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - len ( x ) <NEWLINE> print ( y [ k % len ( y ) ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = A [ 0 ] + A [ 1 ] <NEWLINE> X = 0 <NEWLINE> for a in A [ 2 : ] : <NEWLINE> <INDENT> X ^= a <NEWLINE> <NL> <DEDENT> D = ( S - X ) >> 1 <NEWLINE> if S != X + ( D << 1 ) or D > A [ 0 ] or ( X & D ) != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> b = 2 ** 64 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if ( D & b ) != 0 : <NEWLINE> <INDENT> a |= b <NEWLINE> <DEDENT> elif ( X & b ) != 0 : <NEWLINE> <INDENT> if ( a | b | D & ( b - 1 ) ) <= A [ 0 ] : <NEWLINE> <INDENT> a |= b <NEWLINE> <DEDENT> <DEDENT> b >>= 1 <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> print ( A [ 0 ] - a ) <NEWLINE>
a , b , c , d = map ( float , input ( ) . split ( ) ) <NEWLINE> dx = a - c <NEWLINE> dy = b - d <NEWLINE> dd = ( dx * dx + dy * dy ) ** .5 <NEWLINE> print ( dd ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 1 , min ( n , 100 ) ) : <NEWLINE> <INDENT> for j in range ( 1 , min ( n , 100 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , min ( n , 100 ) ) : <NEWLINE> <INDENT> if i + j + k <= 150 : <NEWLINE> <INDENT> p = ( i + j + k ) ** 2 - ( i * j ) - ( j * k ) - ( i * k ) <NEWLINE> d [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( i ** 5 <= x ) : <NEWLINE> <INDENT> s = ( x - i ** 5 ) ** 0.2 <NEWLINE> s = math . floor ( s * ( 10 ** 7 ) ) / ( 10 ** 7 ) <NEWLINE> <DEDENT> t = ( x + i ** 5 ) ** 0.2 <NEWLINE> t = math . floor ( t * ( 10 ** 7 ) ) / ( 10 ** 7 ) <NEWLINE> if s . is_integer ( ) and i ** 5 <= x : <NEWLINE> <INDENT> print ( int ( s ) , - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif t . is_integer ( ) : <NEWLINE> <INDENT> print ( int ( t ) , i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( sum ( [ ( ( N - 1 ) // 1 ) // i for i in range ( 1 , N ) ] ) ) <NEWLINE>
from itertools import groupby <NEWLINE> from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> def fast_prime_factorization_many ( lst ) : <NEWLINE> <COMMENT> <NL> <INDENT> from subprocess import Popen , PIPE <NEWLINE> res = Popen ( [ <STRING> ] + list ( map ( str , lst ) ) , stdout = PIPE ) . communicate ( ) [ 0 ] . split ( <STRING> ) [ : - 1 ] <NEWLINE> return [ Counter ( list ( map ( int , r . split ( ) [ 1 : ] ) ) ) for r in res ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> mod = int ( 1e9 + 7 ) <NEWLINE> Factors = fast_prime_factorization_many ( A ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> lcm = 1 <NEWLINE> max_factor = [ 0 ] * ( 1000010 ) <NEWLINE> for f in Factors : <NEWLINE> <INDENT> for k , v in f . items ( ) : <NEWLINE> <INDENT> v_prev = max_factor [ k ] <NEWLINE> if v_prev < v : <NEWLINE> <INDENT> for i in range ( v - v_prev ) : <NEWLINE> <INDENT> lcm = lcm * k % mod <NEWLINE> <DEDENT> max_factor [ k ] = v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> wk = lcm * pow ( a , mod - 2 , mod ) <NEWLINE> <COMMENT> <NL> ans += wk <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> S = sum ( a ) <NEWLINE> S2 = sum ( map ( lambda x : x * x , a ) ) <NEWLINE> print ( ( S * S - S2 ) // 2 % mod ) <NEWLINE>
result = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> my_value = input ( ) <NEWLINE> my_value_list = [ ] <NEWLINE> my_value_list = ( [ int ( x ) for x in my_value . split ( ) ] ) <NEWLINE> my_value_list . sort ( ) <NEWLINE> result . append ( my_value_list ) <NEWLINE> if my_value_list [ 0 ] == 0 and my_value_list [ 1 ] == 0 : <NEWLINE> <INDENT> result . pop ( ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( result ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( result [ i ] [ 0 ] , result [ i ] [ 1 ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> array = input ( ) . split ( ) <NEWLINE> <NL> intarr = [ int ( x ) for x in array ] <NEWLINE> for x in intarr : <NEWLINE> <INDENT> if x == intarr [ - 1 ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for c in range ( 1 , n ) : <NEWLINE> <INDENT> v = intarr [ c ] <NEWLINE> j = c - 1 <NEWLINE> while j >= 0 and intarr [ j ] > v : <NEWLINE> <INDENT> intarr [ j + 1 ] = intarr [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> intarr [ j + 1 ] = v <NEWLINE> for x in intarr : <NEWLINE> <INDENT> if x == intarr [ - 1 ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> total = 0 <NEWLINE> result = 0 <NEWLINE> MOD = pow ( 10 , 9 ) + 7 <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> total += A [ i ] <NEWLINE> l . append ( total ) <COMMENT> <NEWLINE> <NL> <DEDENT> for i , num in enumerate ( l ) : <NEWLINE> <INDENT> temp = total - num <COMMENT> <NEWLINE> result += temp * A [ i ] <COMMENT> <NEWLINE> <NL> <DEDENT> print ( result % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> b = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for e in a : <NEWLINE> <INDENT> b [ e ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> m = a [ - 1 ] + 1 <NEWLINE> dp = [ True ] * m <NEWLINE> c = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if dp [ x ] and c [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> for j in range ( 2 * x , m , x ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 <= n : <NEWLINE> <INDENT> i = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = n <NEWLINE> <DEDENT> print ( a * i // b - a * ( i // b ) ) <NEWLINE>
<COMMENT> <NL> <NL> def set_color ( i , ci , e , color ) : <NEWLINE> <INDENT> color [ i ] = ci <NEWLINE> next_i = set ( e [ i ] ) <NEWLINE> while len ( next_i ) : <NEWLINE> <INDENT> s = next_i . pop ( ) <NEWLINE> if color [ s ] != ci : <NEWLINE> <INDENT> color [ s ] = ci <NEWLINE> next_i . update ( e [ s ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> e = [ set ( ) for i in range ( n ) ] <NEWLINE> color = [ None ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ s ] . add ( t ) <NEWLINE> e [ t ] . add ( s ) <NEWLINE> <NL> <DEDENT> ci = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] == None : <NEWLINE> <INDENT> set_color ( i , ci , e , color ) <NEWLINE> ci += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if color [ s ] == color [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> points = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if points [ i - k ] < points [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lst [ i ] not in dic : <NEWLINE> <INDENT> dic [ lst [ i ] ] = [ 1 , 0 , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ lst [ i ] ] [ 0 ] += 1 <NEWLINE> dic [ lst [ i ] ] [ 1 ] = dic [ lst [ i ] ] [ 0 ] * ( dic [ lst [ i ] ] [ 0 ] - 1 ) // 2 <NEWLINE> dic [ lst [ i ] ] [ 2 ] = ( dic [ lst [ i ] ] [ 0 ] - 1 ) * ( dic [ lst [ i ] ] [ 0 ] - 2 ) // 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for value in dic . values ( ) : <NEWLINE> <INDENT> count += value [ 1 ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> m = lst [ i ] <NEWLINE> count -= dic [ m ] [ 1 ] <NEWLINE> count += dic [ m ] [ 2 ] <NEWLINE> print ( count ) <NEWLINE> count += dic [ m ] [ 1 ] <NEWLINE> count -= dic [ m ] [ 2 ] <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Ai = dict ( ) <NEWLINE> ans = 0 <NEWLINE> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> ai = i + v <NEWLINE> if ai in Ai : <NEWLINE> <INDENT> Ai [ ai ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ai [ ai ] = [ i ] <NEWLINE> <DEDENT> <DEDENT> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> aj = i - v <NEWLINE> if aj in Ai : <NEWLINE> <INDENT> ans += len ( Ai [ aj ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> a_sum = sum ( A ) <NEWLINE> a_sum_list = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> a_sum_list += [ a_sum - a - cnt ] <NEWLINE> cnt += a <NEWLINE> <DEDENT> mylist = [ a_sum_list [ i ] * a for i , a in enumerate ( A ) ] <NEWLINE> ans = sum ( mylist ) % mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
def merge_jibun ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] + [ 1000000 ] <NEWLINE> R = A [ mid : right ] + [ 1000000 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> global count <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_hoka ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> inf = 10 ** 9 <NEWLINE> L = A [ left : mid ] + [ inf ] <NEWLINE> R = A [ mid : right ] + [ inf ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> <COMMENT> <NL> merge_hoka ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> <NL> print ( <STRING> . join ( list ( map ( str , A ) ) ) ) <NEWLINE> print ( count ) <NEWLINE>
n = input ( ) <NEWLINE> s = 1 <NEWLINE> <NL> int_list = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> if 0 in int_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in int_list : <NEWLINE> <INDENT> s = s * int ( i ) <NEWLINE> if s > 1e+18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list . sort ( ) <NEWLINE> a_counter = { } <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> if a in a_counter . keys ( ) : <NEWLINE> <INDENT> a_counter [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_counter [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> data_error = False <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> if i not in a_counter . keys ( ) : <NEWLINE> <INDENT> data_error = True <NEWLINE> break <NEWLINE> <DEDENT> if a_counter [ i ] != 2 : <NEWLINE> <INDENT> data_error = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if i not in a_counter . keys ( ) : <NEWLINE> <INDENT> data_error = True <NEWLINE> <DEDENT> if a_counter [ i ] != 2 : <NEWLINE> <INDENT> if i == 0 and a_counter [ 0 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> data_error = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if data_error : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2 ** ( int ( n / 2 ) ) <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) <NEWLINE> ans = 0 <NEWLINE> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if A [ i ] != A [ j ] and A [ j ] != A [ k ] and A [ k ] != A [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 0 <NEWLINE> while K < N : <NEWLINE> <INDENT> if A [ a ] < A [ K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> K += 1 <NEWLINE> a += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> W , H = map ( int , input ( ) . split ( ) ) <NEWLINE> m = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( H ) ] <NEWLINE> dx = [ [ 1 , 1 , 1 , 0 , - 1 , 0 ] , [ 0 , 1 , 0 , - 1 , - 1 , - 1 ] ] <NEWLINE> dy = [ - 1 , 0 , 1 , 1 , 0 , - 1 ] <NEWLINE> def dfs ( x , y ) : <NEWLINE> <INDENT> if m [ y ] [ x ] != 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> m [ y ] [ x ] = 2 <NEWLINE> for xx , yy in zip ( dx [ y % 2 ] , dy ) : <NEWLINE> <INDENT> tx , ty = x + xx , y + yy <NEWLINE> if 0 <= tx < W and 0 <= ty < H : <NEWLINE> <INDENT> dfs ( tx , ty ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( W ) : <NEWLINE> <INDENT> dfs ( x , 0 ) <NEWLINE> dfs ( x , H - 1 ) <NEWLINE> <DEDENT> for y in range ( H ) : <NEWLINE> <INDENT> dfs ( 0 , y ) <NEWLINE> dfs ( W - 1 , y ) <NEWLINE> <NL> <DEDENT> from itertools import product <NEWLINE> n = 0 <NEWLINE> for x , y in product ( range ( W ) , range ( H ) ) : <NEWLINE> <INDENT> if m [ y ] [ x ] != 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> fn = n <NEWLINE> for xx , yy in zip ( dx [ y % 2 ] , dy ) : <NEWLINE> <INDENT> tx , ty = x + xx , y + yy <NEWLINE> if 0 <= tx < W and 0 <= ty < H : <NEWLINE> <INDENT> if m [ ty ] [ tx ] == 2 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A = list ( input ( ) ) <NEWLINE> n = len ( A ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> numa = A [ 0 ] == <STRING> <NEWLINE> numa_ = A [ 0 ] == <STRING> <NEWLINE> numc = A [ 2 : ] . count ( <STRING> ) <NEWLINE> numc_ = A [ 2 : ] . count ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> apro = cpro = 0 <NEWLINE> if A [ i ] == <STRING> or A [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> apro = ( ( 3 * numa + numa_ ) * pow ( 3 , ( numa_ - 1 ) , mod ) ) % mod <NEWLINE> cpro = ( ( 3 * numc + numc_ ) * pow ( 3 , ( numc_ - 1 ) , mod ) ) % mod <NEWLINE> ans += ( apro * cpro ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> numa += 1 <NEWLINE> <DEDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> numa_ += 1 <NEWLINE> <DEDENT> if A [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> numc -= 1 <NEWLINE> <DEDENT> if A [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> numc_ -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( float ( ( abs ( x1 - x2 ) ** 2 ) + abs ( y1 - y2 ) ** 2 ) ** ( 1 / 2 ) ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 for i in range ( c + 1 ) ] for j in range ( r + 1 ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> for line in input ( ) . split ( ) : <NEWLINE> <INDENT> a [ i ] [ j ] = int ( line ) <NEWLINE> a [ i ] [ c ] += a [ i ] [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( c + 1 ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> a [ r ] [ i ] += a [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if j == c : <NEWLINE> <INDENT> print ( a [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import functools <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> s = A [ 0 ] <NEWLINE> for num in A [ 1 : ] : <NEWLINE> <INDENT> s ^= num <NEWLINE> <NL> <DEDENT> res = [ 0 ] * N <NEWLINE> for i , num in enumerate ( A ) : <NEWLINE> <INDENT> res [ i ] = s ^ num <NEWLINE> <DEDENT> print ( * res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> numbers = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = set ( ) <NEWLINE> s = set ( ) <NEWLINE> <NL> for n in numbers : <NEWLINE> <INDENT> if n in s : <NEWLINE> <INDENT> d . add ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> M = max ( s ) <NEWLINE> <NL> X = [ 1 for _ in range ( M + 1 ) ] <NEWLINE> <NL> for a in s : <NEWLINE> <INDENT> if a in d : <NEWLINE> <INDENT> X [ a ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 * a , M + 1 , a ) : <NEWLINE> <INDENT> X [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> output = 0 <NEWLINE> <NL> for n in numbers : <NEWLINE> <INDENT> if X [ n ] == 1 : <NEWLINE> <INDENT> output += 1 <NEWLINE> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> m = [ 0 ] * 2019 <NEWLINE> m [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> t = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> t += int ( i ) * d <NEWLINE> t %= 2019 <NEWLINE> m [ t ] += 1 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> <NL> <NL> <DEDENT> def c2 ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( sum ( [ c2 ( i ) for i in m ] ) ) <NEWLINE>
a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ int ( input ( ) ) for i in range ( a ) ] <NEWLINE> t = [ int ( input ( ) ) for i in range ( b ) ] <NEWLINE> <NL> import bisect <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s2 = 10 ** 12 <NEWLINE> t2 = 10 ** 12 <NEWLINE> qq = int ( input ( ) ) <NEWLINE> sp = bisect . bisect ( s , qq ) <NEWLINE> tp = bisect . bisect ( t , qq ) <NEWLINE> s1 = s [ sp - 1 ] <NEWLINE> if sp < a : <NEWLINE> <INDENT> s2 = s [ sp ] <NEWLINE> <NL> <DEDENT> t1 = t [ tp - 1 ] <NEWLINE> if tp < b : <NEWLINE> <INDENT> t2 = t [ tp ] <NEWLINE> <DEDENT> print ( min ( abs ( qq - s1 ) + abs ( s1 - t1 ) , abs ( qq - s1 ) + abs ( s1 - t2 ) , <NEWLINE> <INDENT> abs ( qq - s2 ) + abs ( s2 - t1 ) , abs ( qq - s2 ) + abs ( s2 - t2 ) , <NEWLINE> abs ( qq - t1 ) + abs ( t1 - s1 ) , abs ( qq - t1 ) + abs ( t1 - s2 ) , <NEWLINE> abs ( qq - t2 ) + abs ( t2 - s1 ) , abs ( qq - t2 ) + abs ( t2 - s2 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> y = sorted ( x ) <NEWLINE> a = y [ len ( x ) // 2 ] <NEWLINE> b = y [ ( len ( x ) // 2 ) - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] <= b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> n = 7 <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( n * 10 + 7 ) % k <NEWLINE> ans += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> X = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> X = sorted ( X ) <NEWLINE> dis = [ 0 for x in range ( M - 1 ) ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> dis [ i ] = X [ i + 1 ] - X [ i ] <NEWLINE> <DEDENT> dis . sort ( ) <NEWLINE> dis . reverse ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> dis [ i ] = 0 <NEWLINE> <DEDENT> print ( sum ( dis ) ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Hdst = [ 0 ] * H <NEWLINE> Wdst = [ 0 ] * W <NEWLINE> DST = [ [ 0 ] * M for i in range ( 2 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> hi , wi = map ( int , input ( ) . split ( ) ) <NEWLINE> Hdst [ hi - 1 ] += 1 <NEWLINE> Wdst [ wi - 1 ] += 1 <NEWLINE> DST [ 0 ] [ i ] = hi - 1 <NEWLINE> DST [ 1 ] [ i ] = wi - 1 <NEWLINE> <NL> <DEDENT> Hdstmax = max ( Hdst ) <NEWLINE> Wdstmax = max ( Wdst ) <NEWLINE> Hbomb = [ i for i , x in enumerate ( Hdst ) if x == Hdstmax ] <NEWLINE> Wbomb = [ i for i , x in enumerate ( Wdst ) if x == Wdstmax ] <NEWLINE> <NL> Hchk = [ False ] * H <NEWLINE> Wchk = [ False ] * W <NEWLINE> for i in Hbomb : <NEWLINE> <INDENT> Hchk [ i ] = True <NEWLINE> <DEDENT> for i in Wbomb : <NEWLINE> <INDENT> Wchk [ i ] = True <NEWLINE> <NL> <DEDENT> tmp = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if Hchk [ DST [ 0 ] [ i ] ] and Wchk [ DST [ 1 ] [ i ] ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( Hbomb ) * len ( Wbomb ) == tmp : <NEWLINE> <INDENT> print ( Hdstmax + Wdstmax - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Hdstmax + Wdstmax ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> c = s . count ( <STRING> ) <NEWLINE> z = a * b * c <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <DEDENT> <DEDENT> x = 0 <NEWLINE> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> if 0 <= 2 * j - i <= n - 1 and s [ 2 * j - i ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> if 0 <= 2 * i - j <= n - 1 and s [ 2 * i - j ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> if ( i + j ) % 2 == 0 and s [ ( i + j ) // 2 ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( z - x ) <NEWLINE>
import math <NEWLINE> <NL> def main ( X ) : <NEWLINE> <INDENT> lst = f ( X ) <NEWLINE> for L in lst : <NEWLINE> <INDENT> for l in L : <NEWLINE> <INDENT> for B in range ( - 120 , 120 , 1 ) : <NEWLINE> <INDENT> A = B + l [ 0 ] <NEWLINE> if g ( A , B ) : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def f ( X ) : <NEWLINE> <INDENT> return [ [ [ X // i , i ] , [ i , X // i ] ] for i in range ( 1 , math . floor ( X ** 0.5 ) + 1 ) if X % i == 0 ] <NEWLINE> <NL> <DEDENT> def g ( A , B ) : <NEWLINE> <INDENT> return A ** 5 - B ** 5 == X <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> main ( X ) <NEWLINE> <DEDENT>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> <NL> temp1 = a * c <NEWLINE> temp2 = a * d <NEWLINE> temp3 = b * c <NEWLINE> temp4 = b * d <NEWLINE> <NL> answer = max ( temp1 , temp2 , temp3 , temp4 ) <NEWLINE> <NL> print ( answer ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> d = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> print ( d ) <NEWLINE>
import bisect <NEWLINE> import math <NEWLINE> <NL> D = 120 <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - D , D ) : <NEWLINE> <INDENT> for b in range ( - D - 1 , D - 1 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> print ( a , b ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ x [ i ] for i in range ( n ) if x [ i ] < 0 ] <NEWLINE> b = [ x [ i ] for i in range ( n ) if x [ i ] >= 0 ] <NEWLINE> na = len ( a ) <NEWLINE> nb = len ( b ) <NEWLINE> if 0 in x : <NEWLINE> <INDENT> k -= 1 <NEWLINE> b = [ x [ i ] for i in range ( n ) if x [ i ] > 0 ] <NEWLINE> nb = nb - 1 <NEWLINE> <NL> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 10 ** 10 <NEWLINE> if na >= k : <NEWLINE> <INDENT> ans = - a [ - k ] <NEWLINE> <NL> <DEDENT> if nb >= k : <NEWLINE> <INDENT> ans = min ( ans , b [ k - 1 ] ) <NEWLINE> <NL> <DEDENT> if nb == 0 : <NEWLINE> <INDENT> print ( - a [ - k ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if na == 0 : <NEWLINE> <INDENT> print ( b [ k - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , nb + 1 ) : <NEWLINE> <INDENT> m = k - i <NEWLINE> if m > na or m < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif 0 < m <= na : <NEWLINE> <INDENT> ans = min ( ans , min ( b [ i - 1 ] - 2 * a [ - m ] , 2 * b [ i - 1 ] - a [ - m ] ) ) <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> ans = min ( ans , b [ k - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans if k != 0 else 0 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if m % 2 == 0 : <NEWLINE> <INDENT> gu_max , ki_max = m , m - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gu_max , ki_max = m - 1 , m <NEWLINE> <DEDENT> gu_start = 1 <NEWLINE> ki_start = 1 + gu_max + 1 <NEWLINE> <NL> for sa in range ( m ) [ : : - 1 ] : <NEWLINE> <INDENT> sa += 1 <NEWLINE> if sa % 2 == 0 : <NEWLINE> <INDENT> print ( gu_start , gu_start + sa ) <NEWLINE> gu_start += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ki_start , ki_start + sa ) <NEWLINE> ki_start += 1 <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( ( r ** 2 ) * math . pi , r * 2 * math . pi ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> roots = uf . roots ( ) <NEWLINE> cnt = [ ] <NEWLINE> for r in roots : <NEWLINE> <INDENT> cnt . append ( uf . size ( r ) ) <NEWLINE> <DEDENT> cnt . sort ( reverse = True ) <NEWLINE> ans = cnt [ 0 ] <NEWLINE> print ( ans ) <NEWLINE>
def BFS ( G ) : <NEWLINE> <INDENT> ans = [ 0 ] + [ [ i + 1 , - 1 ] for i in range ( len ( G ) ) ] <NEWLINE> def main ( G , i , d ) : <NEWLINE> <INDENT> if - 1 < ans [ i ] [ 1 ] <= d : return <NEWLINE> ans [ i ] = [ i , d ] <NEWLINE> for j in G [ i - 1 ] [ 2 : ] : main ( G , j , d + 1 ) <NEWLINE> <DEDENT> main ( G , 1 , 0 ) <NEWLINE> return ans [ 1 : ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> G = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for out in BFS ( G ) : print ( * out ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import bisect <NEWLINE> INF = 2 ** 31 - 1 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> T [ u ] . append ( v ) <NEWLINE> T [ v ] . append ( u ) <NEWLINE> <DEDENT> stack = [ ] <NEWLINE> L = [ INF ] * n <NEWLINE> ans = [ 0 ] * n <NEWLINE> def dfs ( v , par = - 1 ) : <NEWLINE> <INDENT> a = A [ v ] <NEWLINE> idx = bisect . bisect_left ( L , a ) <NEWLINE> stack . append ( ( idx , L [ idx ] ) ) <NEWLINE> L [ idx ] = a <NEWLINE> ans [ v ] = bisect . bisect_left ( L , INF ) <NEWLINE> for nv in T [ v ] : <NEWLINE> <INDENT> if nv != par : <NEWLINE> <INDENT> dfs ( nv , v ) <NEWLINE> <DEDENT> <DEDENT> b , c = stack . pop ( ) <NEWLINE> L [ b ] = c <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> product = 1 <NEWLINE> flag = 0 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> product *= A [ i ] <NEWLINE> if product > 1000000000000000000 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
data = [ ] <NEWLINE> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> data . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> data . sort ( ) <NEWLINE> data . reverse ( ) <NEWLINE> <NL> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> print ( data [ i ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def prime_factorization ( N ) : <NEWLINE> <INDENT> n = int ( N ** 0.5 ) + 1 <NEWLINE> numList = [ i if i != 1 else 2 for i in range ( 1 , n , 2 ) ] <NEWLINE> primeList = [ 2 ] <NEWLINE> ansDict = { } <NEWLINE> idx = 0 <NEWLINE> for data in numList : <NEWLINE> <INDENT> for x in primeList : <NEWLINE> <INDENT> if ( data % x != 0 or x == 2 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while N % data == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> N //= data <NEWLINE> <DEDENT> if count > 0 : <NEWLINE> <INDENT> ansDict [ data ] = count <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> return ansDict <NEWLINE> <DEDENT> if x != 2 : <NEWLINE> <INDENT> primeList . append ( data ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if N != 1 : <NEWLINE> <INDENT> ansDict [ N ] = 1 <NEWLINE> <NL> <DEDENT> return ansDict <NEWLINE> <NL> <DEDENT> if N <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ansDict = prime_factorization ( N ) <NEWLINE> ansCount = 0 <NEWLINE> for p , v in ansDict . items ( ) : <NEWLINE> <INDENT> e = 1 <NEWLINE> while e <= v : <NEWLINE> <INDENT> ansCount += 1 <NEWLINE> v -= e <NEWLINE> e += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ansCount ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> from scipy . sparse . csgraph import breadth_first_order , depth_first_order , shortest_path , floyd_warshall , dijkstra , bellman_ford , johnson <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> nf = lambda : float ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nb = lambda : list ( map ( float , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> N , M = na ( ) <NEWLINE> edge = np . array ( [ na ( ) + [ 1 ] for _ in range ( M ) ] , dtype = np . int64 ) . T <NEWLINE> g = csr_matrix ( ( edge [ 2 ] , ( edge [ : 2 ] - 1 ) ) , ( N , N ) ) <NEWLINE> d , root = breadth_first_order ( g , directed = False , return_predecessors = True , i_start = 0 ) <NEWLINE> if - 9999 not in d [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( root [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def postorder ( binary_tree , target_index , result ) : <NEWLINE> <NL> <INDENT> left = binary_tree [ target_index ] [ <STRING> ] <NEWLINE> right = binary_tree [ target_index ] [ <STRING> ] <NEWLINE> <NL> if not left == - 1 : <NEWLINE> <INDENT> postorder ( binary_tree , left , result ) <NEWLINE> <DEDENT> if not right == - 1 : <NEWLINE> <INDENT> postorder ( binary_tree , right , result ) <NEWLINE> <NL> <DEDENT> result . append ( target_index ) <NEWLINE> <NL> <DEDENT> def solve ( preorder_list , inorder_list , result ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( inorder_list ) == 1 : <NEWLINE> <INDENT> return inorder_list [ 0 ] <NEWLINE> <NL> <DEDENT> parent = preorder_list [ 0 ] <NEWLINE> left_trees = inorder_list [ : inorder_list . index ( parent ) ] <NEWLINE> right_tree_index = 1 <NEWLINE> if left_trees : <NEWLINE> <INDENT> result [ parent ] [ <STRING> ] = solve ( preorder_list [ 1 : ] , left_trees , result ) <NEWLINE> right_tree_index = len ( left_trees ) + 1 <NEWLINE> <NL> <DEDENT> right_trees = inorder_list [ inorder_list . index ( parent ) + 1 : ] <NEWLINE> if right_trees : <NEWLINE> <INDENT> result [ parent ] [ <STRING> ] = solve ( preorder_list [ right_tree_index : ] , right_trees , result ) <NEWLINE> <NL> <DEDENT> return parent <NEWLINE> <NL> <DEDENT> def reconstruction ( preorder_list , inorder_list , node_num ) : <NEWLINE> <INDENT> result = [ { <STRING> : - 1 , <STRING> : - 1 } for i in range ( node_num + 1 ) ] <NEWLINE> solve ( preorder_list , inorder_list , result ) <NEWLINE> return result <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> node_num = int ( input ( ) ) <NEWLINE> preorder_list = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> inorder_list = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> binary_tree = reconstruction ( preorder_list , inorder_list , node_num ) <NEWLINE> postorder_list = [ ] <NEWLINE> postorder ( binary_tree , preorder_list [ 0 ] , postorder_list ) <NEWLINE> print ( * postorder_list ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> def dfs ( nl ) : <NEWLINE> <INDENT> if len ( nl ) == n : <NEWLINE> <INDENT> global ans <NEWLINE> t_ans = 0 <NEWLINE> for a , b , c , d in l : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if nl [ b ] - nl [ a ] == c : <NEWLINE> <INDENT> t_ans += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , t_ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( nl [ - 1 ] , m + 1 ) : <NEWLINE> <INDENT> dfs ( nl + [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> dfs ( [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> def Is_prime ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i < int ( n ** ( 0.5 ) ) + 1 : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for j in n : <NEWLINE> <INDENT> if Is_prime ( j ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> result = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> a = ( i - 1 ) * i / 2 <NEWLINE> b = ( 2 * N - i + 1 ) * i / 2 <NEWLINE> result += b - a + 1 <NEWLINE> result %= 1000000007 <NEWLINE> <NL> <DEDENT> print ( int ( result ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < B : m = N <NEWLINE> else : m = B - 1 <NEWLINE> <NL> l = int ( A * m / B ) - A * int ( m / B ) <NEWLINE> print ( l ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 998244353 <NEWLINE> r = range <NEWLINE> f = [ 1 ] <NEWLINE> for i in r ( k ) : f += [ - ~ i * f [ i ] % p ] <NEWLINE> a = 0 <NEWLINE> for i in r ( n - 1 , k ) : a += f [ k - 1 ] * pow ( f [ i ] * f [ k - 1 - i ] , - 1 , p ) <NEWLINE> print ( a % p ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> lcm = C * D // math . gcd ( C , D ) <NEWLINE> a = B - A + 1 <NEWLINE> b = B // C - ( A - 1 ) // C <NEWLINE> c = B // D - ( A - 1 ) // D <NEWLINE> d = B // lcm - ( A - 1 ) // lcm <NEWLINE> <NL> print ( a - b - c + d ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sq = a * b <NEWLINE> ci = a * 2 + b * 2 <NEWLINE> <NL> print ( sq , ci ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def sol ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> t = [ ] <NEWLINE> for a , b in tmp : <NEWLINE> <INDENT> t += [ b ] * a <NEWLINE> <NL> if len ( t ) >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += t <NEWLINE> A . sort ( reverse = 1 ) <NEWLINE> print ( sum ( A [ : N ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sol ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> def cmb ( R , B ) : <NEWLINE> <INDENT> numerator = reduce ( lambda x , y : x * y % mod , [ R + B - k for k in range ( B ) ] ) <NEWLINE> denominator = reduce ( lambda x , y : x * y % mod , [ B - k for k in range ( B ) ] ) <NEWLINE> return numerator * pow ( denominator , mod - 2 , mod ) % mod <NEWLINE> <NL> <NL> <DEDENT> S = int ( input ( ) ) <NEWLINE> p = S // 3 <NEWLINE> A = 0 <NEWLINE> <NL> for b in range ( p ) : <NEWLINE> <NL> <INDENT> r = S - 3 * ( b + 1 ) <NEWLINE> <NL> if b == 0 : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += cmb ( r , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A % mod ) <NEWLINE> <NL> <NL> <NL>
def find ( n ) : <NEWLINE> <INDENT> if parent [ n ] < 0 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ n ] = find ( parent [ n ] ) <NEWLINE> return parent [ n ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> root_x = find ( x ) <NEWLINE> root_y = find ( y ) <NEWLINE> if root_x == root_y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if parent [ root_x ] > parent [ root_y ] : <NEWLINE> <INDENT> root_x , root_y = root_y , root_x <NEWLINE> <DEDENT> parent [ root_x ] += parent [ root_y ] <NEWLINE> parent [ root_y ] = root_x <NEWLINE> <NL> <NL> <DEDENT> def get_size ( x ) : <NEWLINE> <INDENT> return - parent [ find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> parent = [ - 1 for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> union ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , get_size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> while n > 1000 : <NEWLINE> <INDENT> n -= 1000 <NEWLINE> <DEDENT> print ( 1000 - n ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( k ) : <NEWLINE> <INDENT> for b in range ( k ) : <NEWLINE> <INDENT> gcd_ab = gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( k ) : <NEWLINE> <INDENT> sum += gcd ( gcd_ab , c + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> <NL> if 1 <= a and a <= 100 and 1 <= b and b <= 100 : <NEWLINE> <INDENT> area = a * b <NEWLINE> cir = ( a + b ) * 2 <NEWLINE> print ( area , cir ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> ans = set ( ) <NEWLINE> <NL> def point ( x ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = abcd [ i ] <NEWLINE> if x [ b - 1 ] - x [ a - 1 ] == c : <NEWLINE> <INDENT> temp += d <NEWLINE> <DEDENT> <DEDENT> return temp <NEWLINE> <NL> <DEDENT> def maker ( x ) : <NEWLINE> <INDENT> dig = len ( x ) <NEWLINE> if dig == N : <NEWLINE> <INDENT> ans . add ( point ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x [ - 1 ] , M + 1 ) : <NEWLINE> <INDENT> maker ( x + [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> maker ( [ i ] ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sweet = [ 0 for i in range ( N + 1 ) ] <NEWLINE> <NL> d = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> for j in range ( d [ i ] ) : <NEWLINE> <INDENT> sweet [ A [ i ] [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> num = 0 <NEWLINE> for i in range ( 1 , len ( sweet ) ) : <NEWLINE> <INDENT> if sweet [ i ] == 0 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> diff = A [ i ] - A [ i + 1 ] <NEWLINE> A [ i + 1 ] += diff <NEWLINE> ans += diff <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> p = [ ] <NEWLINE> q = [ ] <NEWLINE> ans = [ 0 for i in range ( len ( s ) ) ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if len ( p ) > 0 : <NEWLINE> <INDENT> if ( p [ 0 ] - q [ 0 ] ) % 2 == 0 : <NEWLINE> <INDENT> ans [ q [ 0 ] ] = - ( - ( p [ 0 ] + 1 ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ q [ 0 ] ] = ( p [ 0 ] + 1 ) // 2 <NEWLINE> <DEDENT> ans [ q [ 0 ] + 1 ] = p [ 0 ] + 1 - ans [ q [ 0 ] ] <NEWLINE> for i in range ( len ( p ) - 1 ) : <NEWLINE> <INDENT> if ( p [ i + 1 ] - q [ i + 1 ] ) % 2 == 0 : <NEWLINE> <INDENT> ans [ q [ i + 1 ] ] = - ( - ( p [ i + 1 ] - p [ i ] ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ q [ i + 1 ] ] = ( p [ i + 1 ] - p [ i ] ) // 2 <NEWLINE> <DEDENT> ans [ q [ i + 1 ] + 1 ] = p [ i + 1 ] - p [ i ] - ans [ q [ i + 1 ] ] <NEWLINE> <DEDENT> if ( len ( s ) + 1 - q [ - 1 ] ) % 2 == 0 : <NEWLINE> <INDENT> ans [ q [ - 1 ] ] = - ( - ( len ( s ) - p [ - 1 ] - 1 ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ q [ - 1 ] ] = ( len ( s ) - p [ - 1 ] - 1 ) // 2 <NEWLINE> <DEDENT> ans [ q [ - 1 ] + 1 ] = len ( s ) - p [ - 1 ] - 1 - ans [ q [ - 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( len ( s ) + 1 - q [ - 1 ] ) % 2 == 0 : <NEWLINE> <INDENT> ans [ q [ - 1 ] ] = - ( - ( len ( s ) ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ q [ - 1 ] ] = ( len ( s ) ) // 2 <NEWLINE> <DEDENT> ans [ q [ - 1 ] + 1 ] = len ( s ) - ans [ q [ - 1 ] ] <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> numbers = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in numbers : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> <NL> max = 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result *= numbers [ i ] <NEWLINE> if result > max : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if result > max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= list [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> ans = ans % ( 10 ** 18 ) <NEWLINE> <DEDENT> if list [ i ] == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def Input ( b , f , rn , h ) : <NEWLINE> <INDENT> A [ b ] [ f ] [ rn ] += h <NEWLINE> <NL> <DEDENT> def Output ( ) : <NEWLINE> <INDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 4 ) : <NEWLINE> <INDENT> for rn in range ( 10 ) : <NEWLINE> <INDENT> if f < 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( A [ b ] [ f ] [ rn ] ) , end = <STRING> ) <NEWLINE> <DEDENT> if f == 3 and b != 3 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if b == 3 and f == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> A = [ [ [ 0 for rn in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> for idx in range ( n ) : <NEWLINE> <INDENT> R = input ( ) . split ( ) <NEWLINE> B = int ( R [ 0 ] ) - 1 <NEWLINE> F = int ( R [ 1 ] ) - 1 <NEWLINE> RN = int ( R [ 2 ] ) - 1 <NEWLINE> H = int ( R [ 3 ] ) <NEWLINE> Input ( B , F , RN , H ) <NEWLINE> <DEDENT> Output ( ) <NEWLINE>
mod = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> a_sum = sum ( a ) <NEWLINE> a_total = a_sum * a_sum <NEWLINE> lat = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> lat = lat + i * i <NEWLINE> <DEDENT> ans = ( a_total - lat ) // 2 <NEWLINE> ans = ans % mod <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> H , W , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> h = { } <NEWLINE> w = { } <NEWLINE> m = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> hi , wi = map ( int , readline ( ) . split ( ) ) <NEWLINE> if hi not in h : <NEWLINE> <INDENT> h [ hi ] = 1 <NEWLINE> m [ hi ] = set ( ) <NEWLINE> m [ hi ] . add ( wi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h [ hi ] += 1 <NEWLINE> m [ hi ] . add ( wi ) <NEWLINE> <DEDENT> if wi not in w : <NEWLINE> <INDENT> w [ wi ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w [ wi ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> max_h = max ( h . values ( ) ) <NEWLINE> max_w = max ( w . values ( ) ) <NEWLINE> max_h_list = [ kv [ 0 ] for kv in h . items ( ) if kv [ 1 ] == max_h ] <NEWLINE> max_w_list = [ kv [ 0 ] for kv in w . items ( ) if kv [ 1 ] == max_w ] <NEWLINE> <NL> for i in max_h_list : <NEWLINE> <INDENT> for j in max_w_list : <NEWLINE> <INDENT> if j not in m [ i ] : <NEWLINE> <INDENT> print ( max_h + max_w ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_h + max_w - 1 ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> <NL> l = <STRING> <NEWLINE> <NL> ss = <STRING> . join ( sorted ( s ) ) <NEWLINE> st = <STRING> . join ( sorted ( t ) ) <NEWLINE> str = <STRING> . join ( sorted ( t , reverse = True ) ) <NEWLINE> <NL> if l . index ( str [ 0 ] ) > l . index ( ss [ 0 ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif len ( t ) > len ( s ) and ss in st : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> <NL> manhattan = [ [ abs ( ( i % 4 ) - ( j % 4 ) ) + abs ( ( i // 4 ) - ( j // 4 ) ) for j in range ( 16 ) ] for i in range ( 16 ) ] <NEWLINE> movables = [ { 1 , 4 } , { 0 , 2 , 5 } , { 1 , 3 , 6 } , { 2 , 7 } , { 0 , 5 , 8 } , { 1 , 4 , 6 , 9 } , { 2 , 5 , 7 , 10 } , { 3 , 6 , 11 } , <NEWLINE> <INDENT> { 4 , 9 , 12 } , { 5 , 8 , 10 , 13 } , { 6 , 9 , 11 , 14 } , { 7 , 10 , 15 } , { 8 , 13 } , { 9 , 12 , 14 } , { 10 , 13 , 15 } , { 11 , 14 } ] <NEWLINE> <DEDENT> swap_cache = [ [ ( 1 << mf ) - ( 1 << mt ) for mt in range ( 0 , 64 , 4 ) ] for mf in range ( 0 , 64 , 4 ) ] <NEWLINE> destination = 0xfedcba9876543210 <NEWLINE> <NL> <NL> def swap ( board , move_from , move_to ) : <NEWLINE> <INDENT> return board + swap_cache [ move_from ] [ move_to ] * ( 15 - ( ( board >> ( 4 * move_from ) ) & 15 ) ) <NEWLINE> <NL> <NL> <DEDENT> i = 0 <NEWLINE> board_init = 0 <NEWLINE> blank_init = 0 <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> for n in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 15 <NEWLINE> blank_init = i <NEWLINE> <DEDENT> board_init += n * 16 ** i <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> estimation_init = sum ( manhattan [ i ] [ ( ( board_init >> ( 4 * i ) ) & 15 ) ] for i in range ( 16 ) if i != blank_init ) <NEWLINE> <NL> queue = [ ( estimation_init , board_init , blank_init ) ] <NEWLINE> visited = set ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> estimation , board , blank = heappop ( queue ) <NEWLINE> if board in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif board == destination : <NEWLINE> <INDENT> print ( estimation ) <NEWLINE> break <NEWLINE> <DEDENT> visited . add ( board ) <NEWLINE> for new_blank in movables [ blank ] : <NEWLINE> <INDENT> new_board = swap ( board , new_blank , blank ) <NEWLINE> if new_board in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num = ( board >> ( 4 * new_blank ) ) & 15 <NEWLINE> new_estimation = estimation + 1 - manhattan [ new_blank ] [ num ] + manhattan [ blank ] [ num ] <NEWLINE> if new_estimation > 45 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> heappush ( queue , ( new_estimation , new_board , new_blank ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> distance = ( <NEWLINE> <INDENT> ( ) , <NEWLINE> ( 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 , 3 , 4 , 5 , 6 ) , <NEWLINE> ( 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 , 4 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 , 5 , 4 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 , 6 , 5 , 4 , 3 ) , <NEWLINE> ( 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 ) , <NEWLINE> ( 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 ) , <NEWLINE> ( 3 , 4 , 5 , 6 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 4 , 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> def get_distance ( board ) : <NEWLINE> <INDENT> sd = 0 <NEWLINE> for i in range ( 16 ) : <NEWLINE> <INDENT> p = board [ i ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sd += distance [ p ] [ i ] <NEWLINE> <DEDENT> return sd <NEWLINE> <NL> <DEDENT> adjacent = ( <NEWLINE> <INDENT> ( 1 , 4 ) , <COMMENT> <NEWLINE> ( 0 , 2 , 5 ) , <COMMENT> <NEWLINE> ( 1 , 3 , 6 ) , <COMMENT> <NEWLINE> ( 2 , 7 ) , <COMMENT> <NEWLINE> ( 0 , 5 , 8 ) , <COMMENT> <NEWLINE> ( 1 , 4 , 6 , 9 ) , <COMMENT> <NEWLINE> ( 2 , 5 , 7 , 10 ) , <COMMENT> <NEWLINE> ( 3 , 6 , 11 ) , <COMMENT> <NEWLINE> ( 4 , 9 , 12 ) , <COMMENT> <NEWLINE> ( 5 , 8 , 10 , 13 ) , <COMMENT> <NEWLINE> ( 6 , 9 , 11 , 14 ) , <COMMENT> <NEWLINE> ( 7 , 10 , 15 ) , <COMMENT> <NEWLINE> ( 8 , 13 ) , <COMMENT> <NEWLINE> ( 9 , 12 , 14 ) , <COMMENT> <NEWLINE> ( 10 , 13 , 15 ) , <COMMENT> <NEWLINE> ( 11 , 14 ) <COMMENT> <NEWLINE> <DEDENT> ) <NEWLINE> <NL> GOAL = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 0 ] <NEWLINE> <NL> import sys <NEWLINE> import heapq <NEWLINE> <NL> <COMMENT> <NL> def solve ( ) : <NEWLINE> <INDENT> board = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) <NEWLINE> h_cost = get_distance ( board ) <NEWLINE> state = [ h_cost , board ] <NEWLINE> <NL> q = [ state ] <COMMENT> <NEWLINE> d = { tuple ( board ) : True } <NEWLINE> <NL> while q : <NEWLINE> <INDENT> state1 = heapq . heappop ( q ) <NEWLINE> h_cost , board = state1 <NEWLINE> if board == GOAL : <NEWLINE> <INDENT> return h_cost <NEWLINE> <DEDENT> space = board . index ( 0 ) <NEWLINE> for i in adjacent [ space ] : <NEWLINE> <INDENT> p = board [ i ] <NEWLINE> new_board = board [ : ] <NEWLINE> new_board [ space ] , new_board [ i ] = p , 0 <NEWLINE> new_h_cost = h_cost + 1 - distance [ p ] [ i ] + distance [ p ] [ space ] <NEWLINE> <NL> key = tuple ( new_board ) <NEWLINE> if key not in d and new_h_cost <= 45 : <NEWLINE> <INDENT> new_state = [ new_h_cost , new_board ] <NEWLINE> heapq . heappush ( q , new_state ) <NEWLINE> d [ key ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( solve ( ) ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> ans1 = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans1 = math . gcd ( i , j ) <NEWLINE> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ans1 , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <NL> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <NL> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> s3 = 0 <NEWLINE> rl = len ( r ) <NEWLINE> gl = len ( g ) <NEWLINE> bl = len ( b ) <NEWLINE> <NL> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> n2 = int ( ( n + i ) / 2 ) + 1 <NEWLINE> for j in range ( i , n2 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= n - 1 : <NEWLINE> <NL> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> s3 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> s2 = rl * gl * bl - s3 <NEWLINE> print ( s2 ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> s -= i <NEWLINE> s %= mod <NEWLINE> ans += i * s <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> cntNode = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> cntNode [ a ] += 1 <NEWLINE> cntNode [ b ] += 1 <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( cntNode [ i ] % 2 != 0 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
C1 = str ( input ( ) ) <NEWLINE> C2 = str ( input ( ) ) <NEWLINE> <NL> if C1 [ 0 ] == C2 [ - 1 ] and C1 [ 1 ] == C2 [ - 2 ] and C1 [ 2 ] == C2 [ - 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_books = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b_books = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> time = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> time += a_books [ i ] <NEWLINE> if time > k : <NEWLINE> <INDENT> time -= a_books [ i ] <NEWLINE> i -= 1 <NEWLINE> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> time += b_books [ j ] <NEWLINE> if time > k : <NEWLINE> <INDENT> time -= b_books [ j ] <NEWLINE> j -= 1 <NEWLINE> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> max_count = count <NEWLINE> <COMMENT> <NL> while j < m and i >= 0 : <NEWLINE> <INDENT> time -= a_books [ i ] <NEWLINE> i -= 1 <NEWLINE> count -= 1 <NEWLINE> j += 1 <NEWLINE> while j < m : <NEWLINE> <INDENT> time += b_books [ j ] <NEWLINE> if time > k : <NEWLINE> <INDENT> time -= b_books [ j ] <NEWLINE> j -= 1 <NEWLINE> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> if count > max_count : <NEWLINE> <INDENT> max_count = count <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( max_count ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = [ 0 ] * n <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> ans = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ans <= n : <NEWLINE> <INDENT> arr [ ans - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in aa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for a in aa : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
c = [ 0 ] * 52 <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> c [ i ] = <STRING> . format ( i + 1 ) <NEWLINE> c [ 13 + i ] = <STRING> . format ( i + 1 ) <NEWLINE> c [ 26 + i ] = <STRING> . format ( i + 1 ) <NEWLINE> c [ 39 + i ] = <STRING> . format ( i + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> c . remove ( input ( ) ) <NEWLINE> <NL> <DEDENT> if c : print ( <STRING> . join ( c ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> answer = - 1 <NEWLINE> x = 7 <NEWLINE> for index in range ( k ) : <NEWLINE> <INDENT> if x % k == 0 : <NEWLINE> <INDENT> answer = index + 1 <NEWLINE> break <NEWLINE> <DEDENT> x = ( 10 * x + 7 ) % k <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ls = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> dicA = { } <NEWLINE> dicB = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = i + ls [ i ] <NEWLINE> if a in dicA : <NEWLINE> <INDENT> dicA [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dicA [ a ] = 1 <NEWLINE> <DEDENT> b = i - ls [ i ] <NEWLINE> if b in dicB : <NEWLINE> <INDENT> dicB [ b ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dicB [ b ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a , na in dicA . items ( ) : <NEWLINE> <INDENT> if a in dicB : <NEWLINE> <INDENT> ans += na * dicB [ a ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def is_cuttable ( N ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> i = a // N <NEWLINE> if a % N == 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> n += int ( i ) <NEWLINE> if n > K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n_max = 10 ** 10 <NEWLINE> n_min = 0 <NEWLINE> <NL> while n_max - n_min > 1 : <NEWLINE> <INDENT> n = ( n_max + n_min ) // 2 <NEWLINE> if is_cuttable ( n ) : <NEWLINE> <INDENT> n_max = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_min = n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n_max ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while a % b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> x = gcd ( N , M ) <NEWLINE> n = N // x <NEWLINE> m = M // x <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if S [ n * i ] != T [ m * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( N * M // x ) <NEWLINE>
import math <NEWLINE> g = math . gcd <NEWLINE> r = range ( 1 , int ( input ( ) ) + 1 ) <NEWLINE> print ( sum ( g ( g ( a , b ) , c ) for a in r for b in r for c in r ) ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if ( ( b - a ) > 0 ) : <NEWLINE> <INDENT> a = a + v * t <NEWLINE> b = b + w * t <NEWLINE> if ( a >= b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( ( b - a ) < 0 ) : <NEWLINE> <INDENT> a = a - v * t <NEWLINE> b = b - w * t <NEWLINE> if ( a <= b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> mylist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mylist . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> if mylist [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> myans = 1 <NEWLINE> for m in mylist : <NEWLINE> <INDENT> myans *= m <NEWLINE> if myans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( myans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> n1 = [ ] <NEWLINE> num1 = 10 ** 9 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n1 . append ( num [ i ] [ 0 ] + num [ i ] [ 1 ] ) <NEWLINE> <DEDENT> ans = max ( ans , max ( n1 ) - min ( n1 ) ) <NEWLINE> n1 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n1 . append ( num1 - num [ i ] [ 0 ] + num [ i ] [ 1 ] ) <NEWLINE> <DEDENT> ans = max ( ans , max ( n1 ) - min ( n1 ) ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def is_able ( n , m , k ) : <NEWLINE> <INDENT> res = defaultdict ( bool ) <NEWLINE> res [ 0 ] = True <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> count += i * j <NEWLINE> count += ( n - i ) * ( m - j ) <NEWLINE> res [ count ] = True <NEWLINE> <DEDENT> <DEDENT> return res [ k ] <NEWLINE> <NL> <NL> <DEDENT> if is_able ( n , m , k ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum = 0 <NEWLINE> s = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_sum += a [ i ] <NEWLINE> s . append ( a_sum ) <NEWLINE> <NL> <DEDENT> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> ans += j * ( s [ n - 1 ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
s = input ( ) <NEWLINE> s_reverse = <STRING> . join ( list ( reversed ( s ) ) ) <NEWLINE> t = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = len ( t ) <NEWLINE> if s_reverse == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if len ( s ) <= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if s_reverse [ n ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> . join ( list ( reversed ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif s_reverse [ n ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> . join ( list ( reversed ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif s_reverse [ n : n + 3 ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> . join ( list ( reversed ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif s_reverse [ n : n + 3 ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> . join ( list ( reversed ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
NIL = None <NEWLINE> class Tree : <NEWLINE> <INDENT> def __init__ ( self , key = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . p = NIL <NEWLINE> self . left = NIL <NEWLINE> self . right = NIL <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = { <STRING> : NIL } <NEWLINE> def insert ( T , z ) : <NEWLINE> <INDENT> y = NIL <NEWLINE> x = T [ <STRING> ] <NEWLINE> while x != NIL : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> if y == NIL : <NEWLINE> <INDENT> T [ <STRING> ] = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> <DEDENT> def preorder_tree_walk ( T ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if T . left != NIL : <NEWLINE> <INDENT> preorder_tree_walk ( T . left ) <NEWLINE> <DEDENT> if T . right != NIL : <NEWLINE> <INDENT> preorder_tree_walk ( T . right ) <NEWLINE> <DEDENT> <DEDENT> def inorder_tree_walk ( T ) : <NEWLINE> <INDENT> if T . left != NIL : <NEWLINE> <INDENT> inorder_tree_walk ( T . left ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if T . right != NIL : <NEWLINE> <INDENT> inorder_tree_walk ( T . right ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> ss = input ( ) <NEWLINE> if ss [ 0 ] == <STRING> : <NEWLINE> <INDENT> s , v = ss . split ( ) <NEWLINE> insert ( tree , Tree ( int ( v ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inorder_tree_walk ( tree [ <STRING> ] ) <NEWLINE> print ( ) <NEWLINE> preorder_tree_walk ( tree [ <STRING> ] ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> H , W , A , B = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i < B : <NEWLINE> <INDENT> if j < A : <NEWLINE> <INDENT> print ( 0 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j < A : <NEWLINE> <INDENT> print ( 1 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> score = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = abcd [ i ] [ 0 ] <NEWLINE> b = abcd [ i ] [ 1 ] <NEWLINE> c = abcd [ i ] [ 2 ] <NEWLINE> d = abcd [ i ] [ 3 ] <NEWLINE> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> score . append ( d ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , sum ( score ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> sflag = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> sflag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if sflag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if sflag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif sflag == 1 and flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def solve ( pick , idx ) : <NEWLINE> <NL> <INDENT> if pick == 0 : return 0 <NEWLINE> if idx >= n : return - float ( <STRING> ) <NEWLINE> if ( pick , idx ) in dp : return dp [ pick , idx ] <NEWLINE> if n - idx + 2 < pick * 2 : return - float ( <STRING> ) <NEWLINE> total = max ( A [ idx ] + solve ( pick - 1 , idx + 2 ) , solve ( pick , idx + 1 ) ) <NEWLINE> <NL> dp [ ( pick , idx ) ] = total <NEWLINE> return total <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = { } <NEWLINE> pick = n // 2 <NEWLINE> <NL> print ( solve ( pick , 0 ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> l . append ( s ) <NEWLINE> <NL> <DEDENT> l = set ( l ) <NEWLINE> count = len ( l ) <NEWLINE> print ( <STRING> . format ( count ) ) <NEWLINE>
from functools import reduce <NEWLINE> from math import log10 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mul = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> mul *= a <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> dp = [ True for i in range ( a [ - 1 ] + 1 ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> for j in range ( 1 , n - i ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif j == 1 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> dp [ a [ i + j ] ] = False <NEWLINE> <DEDENT> for j in range ( a [ i ] , a [ - 1 ] + 1 , a [ i ] ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> import sys <NEWLINE> for j in range ( 1 , H - 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> if s [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ j ] [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ j - 1 ] [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ j ] [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ j + 1 ] [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> WALL = 100 <NEWLINE> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ [ WALL ] + list ( map ( int , input ( ) . split ( ) ) ) + [ WALL ] for i in range ( h ) ] <NEWLINE> lst . insert ( 0 , [ WALL ] * ( w + 2 ) ) <NEWLINE> lst . append ( [ WALL ] * ( w + 2 ) ) <NEWLINE> <NL> visited = [ [ 0 ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> hold = [ ] <NEWLINE> <NL> def search ( x , y ) : <NEWLINE> <NL> <INDENT> if lst [ x ] [ y ] == WALL : <NEWLINE> <INDENT> visited [ x ] [ y ] = 3 <NEWLINE> return 3 <NEWLINE> <NL> <DEDENT> if lst [ x ] [ y ] == 1 : <NEWLINE> <INDENT> visited [ x ] [ y ] = 2 <NEWLINE> return 2 <NEWLINE> <NL> <DEDENT> visited [ x ] [ y ] = 1 <NEWLINE> hold . append ( ( x , y ) ) <NEWLINE> <NL> if not x % 2 : <NEWLINE> <INDENT> pairs = [ ( x - 1 , y - 1 ) , ( x - 1 , y ) , ( x , y - 1 ) , ( x , y + 1 ) , ( x + 1 , y - 1 ) , ( x + 1 , y ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pairs = [ ( x - 1 , y ) , ( x - 1 , y + 1 ) , ( x , y - 1 ) , ( x , y + 1 ) , ( x + 1 , y ) , ( x + 1 , y + 1 ) ] <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for t in pairs : <NEWLINE> <INDENT> tx , ty = t [ 0 ] , t [ 1 ] <NEWLINE> a = 0 <NEWLINE> if not visited [ tx ] [ ty ] : <NEWLINE> <INDENT> a = search ( tx , ty ) <NEWLINE> <DEDENT> elif visited [ tx ] [ ty ] == 3 : <NEWLINE> <INDENT> a = 3 <NEWLINE> <DEDENT> elif visited [ tx ] [ ty ] == 2 : <NEWLINE> <INDENT> a = 2 <NEWLINE> <DEDENT> if a > ret : <NEWLINE> <INDENT> ret = a <NEWLINE> <NL> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> for x in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if not visited [ x ] [ y ] and not lst [ x ] [ y ] : <NEWLINE> <INDENT> stat = search ( x , y ) <NEWLINE> for point in hold : <NEWLINE> <INDENT> visited [ point [ 0 ] ] [ point [ 1 ] ] = stat <NEWLINE> <DEDENT> hold . clear ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if lst [ x ] [ y ] : <NEWLINE> <INDENT> if not x % 2 : <NEWLINE> <INDENT> pairs = [ ( x - 1 , y - 1 ) , ( x - 1 , y ) , ( x , y - 1 ) , ( x , y + 1 ) , ( x + 1 , y - 1 ) , ( x + 1 , y ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pairs = [ ( x - 1 , y ) , ( x - 1 , y + 1 ) , ( x , y - 1 ) , ( x , y + 1 ) , ( x + 1 , y ) , ( x + 1 , y + 1 ) ] <NEWLINE> <DEDENT> for t in pairs : <NEWLINE> <INDENT> tx , ty = t [ 0 ] , t [ 1 ] <NEWLINE> if ( visited [ tx ] [ ty ] in [ 0 , 3 ] ) and ( lst [ tx ] [ ty ] in [ WALL , 0 ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> nn = int ( ( n - 1 ) // 2 ) + 1 <NEWLINE> for i in range ( 2 , nn ) : <NEWLINE> <INDENT> for j in range ( i , nn ) : <NEWLINE> <INDENT> if i * j > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans += ( n - 1 - 1 ) * 2 <NEWLINE> print ( ans + 1 ) <NEWLINE>
n = input ( ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> flag0 = False <NEWLINE> flag = True <NEWLINE> for i in s : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 1000000000000000000 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> flag0 = True <NEWLINE> <DEDENT> <DEDENT> if flag0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif flag : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> d_1 = defaultdict ( int ) <NEWLINE> d_2 = defaultdict ( int ) <NEWLINE> zeros = 0 <NEWLINE> <NL> def to_irreducible ( a , b ) : <NEWLINE> <INDENT> GCD = gcd ( a , b ) <NEWLINE> return list ( map ( lambda x : x // GCD , [ a , b ] ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <DEDENT> elif a * b >= 0 and b != 0 : <NEWLINE> <INDENT> a , b = to_irreducible ( abs ( a ) , abs ( b ) ) <NEWLINE> d_1 [ ( a , b ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = to_irreducible ( abs ( b ) , abs ( a ) ) <NEWLINE> d_1 [ ( a , b ) ] += 0 <NEWLINE> d_2 [ ( a , b ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> <NL> for k , v_1 in d_1 . items ( ) : <NEWLINE> <INDENT> v_2 = d_2 [ k ] <NEWLINE> ans *= ( pow ( 2 , v_1 , mod ) + pow ( 2 , v_2 , mod ) - 1 ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ( ans + zeros - 1 ) % mod ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> nR = S . count ( <STRING> ) <NEWLINE> nG = S . count ( <STRING> ) <NEWLINE> nB = S . count ( <STRING> ) <NEWLINE> ans = nR * nG * nB <NEWLINE> for i in range ( N ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( 1 , N // 2 + 1 ) : <COMMENT> <NEWLINE> <INDENT> if i + 2 * j >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , b , c = S [ i ] , S [ i + j ] , S [ i + 2 * j ] <NEWLINE> if a != b and b != c and c != a : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , 1000001 ) : <NEWLINE> <INDENT> count += ( N - 1 ) // a <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> B = [ ] <NEWLINE> x = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x += A [ i ] <NEWLINE> x %= mod <NEWLINE> B . append ( x ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += A [ i ] * B [ i - 1 ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a = [ input ( ) for i in range ( 2 ) ] <NEWLINE> <NL> a_num = a [ 1 ] <NEWLINE> a_num = a_num . split ( ) <NEWLINE> a_list = [ int ( n ) for n in a_num ] <NEWLINE> <NL> a_mul = 1 <NEWLINE> <NL> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in a_list : <NEWLINE> <INDENT> a_mul *= i <NEWLINE> <NL> if a_mul > 10 ** 18 : <NEWLINE> <INDENT> a_mul = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a_mul ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( read ( ) ) <NEWLINE> <NL> def main ( N ) : <NEWLINE> <INDENT> A = [ 1 ] <NEWLINE> for _ in range ( 100 ) : <NEWLINE> <INDENT> A . append ( A [ - 1 ] * 26 ) <NEWLINE> <DEDENT> for n in range ( 1 , 100 ) : <NEWLINE> <INDENT> if N > A [ n ] : <NEWLINE> <INDENT> N -= A [ n ] <NEWLINE> continue <NEWLINE> <NL> <DEDENT> N -= 1 <NEWLINE> ret = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> N , r = divmod ( N , 26 ) <NEWLINE> ret . append ( r ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> ret = [ chr ( ord ( <STRING> ) + x ) for x in ret ] <NEWLINE> return <STRING> . join ( reversed ( ret ) ) <NEWLINE> <NL> <DEDENT> print ( main ( N ) ) <NEWLINE>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> tmp = [ 0 ] * 1000 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> tmp [ i ] = i ** 5 <NEWLINE> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> a = x + tmp [ i ] <NEWLINE> if abs ( a ) in tmp : <NEWLINE> <NL> <INDENT> print ( int ( a ** 0.2 ) , i ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> a = x - tmp [ i ] <NEWLINE> if abs ( a ) in tmp : <NEWLINE> <NL> <INDENT> print ( int ( a ** 0.2 ) , - i ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> a , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in x [ : : - 1 ] : <NEWLINE> <INDENT> if i [ 0 ] == 1 : <NEWLINE> <INDENT> if i [ 1 ] == k : <NEWLINE> <INDENT> k = i [ 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i [ 1 ] == k : <NEWLINE> <INDENT> k = i [ 2 ] <NEWLINE> <DEDENT> elif i [ 2 ] == k : <NEWLINE> <INDENT> k = i [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a + d * ( k - 1 ) ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> d = min ( n , b - 1 ) <NEWLINE> c = math . floor ( ( a * d ) / b ) - ( a * math . floor ( d / b ) ) <NEWLINE> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( S ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a_list [ i ] < a_list [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
r = float ( input ( ) ) <NEWLINE> p = 3.141592653589 <NEWLINE> print ( <STRING> ) <NEWLINE>
from heapq import heappop as pop <NEWLINE> from heapq import heappush as push <NEWLINE> INF = 10 ** 20 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> clst = [ ] <NEWLINE> rlst = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c , r = map ( int , input ( ) . split ( ) ) <NEWLINE> clst . append ( c ) <NEWLINE> rlst . append ( r ) <NEWLINE> <NL> <DEDENT> edges = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] [ b ] = edges [ b ] [ a ] = 1 <NEWLINE> <NL> <DEDENT> costs = [ INF for i in range ( n ) ] <NEWLINE> costs [ 0 ] = 0 <NEWLINE> <NL> used = [ False for i in range ( n ) ] <NEWLINE> def make_to_lst ( s_num ) : <NEWLINE> <INDENT> loop = rlst [ s_num ] <NEWLINE> temp = { i for i in range ( n ) if edges [ s_num ] [ i ] } <NEWLINE> ret = { i for i in temp } <NEWLINE> while loop : <NEWLINE> <INDENT> new = set ( ) <NEWLINE> for p in temp : <NEWLINE> <INDENT> pto = { i for i in range ( n ) if edges [ p ] [ i ] } <NEWLINE> new = new | pto <NEWLINE> <DEDENT> ret = ret | temp <NEWLINE> temp = new - ret <NEWLINE> if not temp : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> loop -= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> used [ 0 ] = True <NEWLINE> costs [ 0 ] = 0 <NEWLINE> break_flag = 0 <NEWLINE> que = [ ( clst [ 0 ] , 0 ) ] <NEWLINE> <NL> while que and not break_flag : <NEWLINE> <INDENT> next_cost , s_num = pop ( que ) <NEWLINE> to_lst = make_to_lst ( s_num ) <NEWLINE> for num in to_lst : <NEWLINE> <INDENT> costs [ num ] = next_cost <NEWLINE> if num == n - 1 : <NEWLINE> <INDENT> break_flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if not used [ num ] : <NEWLINE> <INDENT> push ( que , ( costs [ num ] + clst [ num ] , num ) ) <NEWLINE> used [ num ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( costs [ n - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> th = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > th : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans <= th else - 1 ) <NEWLINE> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> a . sort ( ) <NEWLINE> b = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> b |= b << i <NEWLINE> <NL> <DEDENT> b &= 2 ** ( s + 1 ) - 2 ** ( ( s - 1 ) // 2 ) <NEWLINE> while True : <NEWLINE> <INDENT> t = b & ( - b ) <NEWLINE> T = t . bit_length ( ) - 1 <NEWLINE> if ( s + 1 ) // 2 <= T <= s : <NEWLINE> <INDENT> print ( T ) <NEWLINE> break <NEWLINE> <DEDENT> b ^= t <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def solve ( h , w , a ) : <NEWLINE> <INDENT> used = [ [ True ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> que = deque ( ) <NEWLINE> for r in range ( h ) : <NEWLINE> <INDENT> used [ r + 1 ] [ 1 : - 1 ] = map ( lambda _ : _ == <STRING> , a [ r ] ) <NEWLINE> for c in range ( w ) : <NEWLINE> <INDENT> if a [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> que . append ( ( r + 1 , c + 1 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> neighbors = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> while que : <NEWLINE> <INDENT> r , c , k = que . popleft ( ) <NEWLINE> for dr , dc in neighbors : <NEWLINE> <INDENT> nr , nc = r + dr , c + dc <NEWLINE> if not used [ nr ] [ nc ] : <NEWLINE> <INDENT> que . append ( ( nr , nc , k + 1 ) ) <NEWLINE> used [ nr ] [ nc ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> print ( solve ( h , w , a ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp_b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + tmp_a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + tmp_b [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> mult = 1 <NEWLINE> <NL> for i in lst : <NEWLINE> <INDENT> mult *= i <NEWLINE> if 10 ** 18 < mult : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( mult ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <DEDENT> <DEDENT> answer = len ( R ) * len ( G ) * len ( B ) <NEWLINE> hiku = 0 <NEWLINE> <NL> for i in range ( ( N - 1 ) // 2 ) : <NEWLINE> <INDENT> for j in range ( N - i - i - 2 ) : <NEWLINE> <INDENT> if S [ j ] != S [ j + i + 1 ] and S [ j + i + 1 ] != S [ j + i + i + 2 ] and S [ j ] != S [ j + i + i + 2 ] : <NEWLINE> <INDENT> hiku += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> answer -= hiku <NEWLINE> print ( answer ) <NEWLINE>
<COMMENT> <NL> def osa_k ( a ) : <NEWLINE> <INDENT> tmp = set ( ) <NEWLINE> while a > 1 : <NEWLINE> <INDENT> tmp . add ( sieve [ a ] ) <NEWLINE> a //= sieve [ a ] <NEWLINE> <DEDENT> return tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import math <NEWLINE> import sys <NEWLINE> from bisect import bisect_left <NEWLINE> from functools import reduce <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> used = set ( ) <NEWLINE> <NL> <COMMENT> <NL> gcd_a = reduce ( math . gcd , A ) <NEWLINE> if gcd_a != 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> MAXN = 10 ** 6 + 10 <NEWLINE> <COMMENT> <NL> sieve = [ i for i in range ( MAXN + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while p * p <= MAXN : <NEWLINE> <INDENT> if sieve [ p ] == p : <NEWLINE> <INDENT> for q in range ( 2 * p , MAXN + 1 , p ) : <NEWLINE> <INDENT> if sieve [ q ] == q : <NEWLINE> <INDENT> sieve [ q ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for a in A : <NEWLINE> <INDENT> aa = osa_k ( a ) <NEWLINE> if used & aa : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <COMMENT> <NEWLINE> <DEDENT> used |= aa <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from itertools import accumulate <NEWLINE> from collections import deque <NEWLINE> import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> a_c = list ( accumulate ( list ( a ) ) ) <NEWLINE> b_c = list ( accumulate ( list ( b ) ) ) <NEWLINE> result = [ ] <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_c [ i ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b_idx = bisect . bisect_left ( b_c , k - a_c [ i ] + 1 ) <NEWLINE> result . append ( i + b_idx - 1 ) <NEWLINE> <NL> <DEDENT> print ( max ( result ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> count = len ( t ) <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> str_ = s [ i : i + len ( t ) ] <NEWLINE> temp = 0 <NEWLINE> for i in range ( len ( str_ ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if str_ [ i ] != t [ i ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> count = min ( count , temp ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> s = sum ( num ) <NEWLINE> num_dict = { } <NEWLINE> for i in num : <NEWLINE> <INDENT> if i in num_dict : <NEWLINE> <INDENT> num_dict [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_dict [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> if c in num_dict : <NEWLINE> <INDENT> if b in num_dict : <NEWLINE> <INDENT> k = num_dict [ b ] <NEWLINE> num_dict [ c ] += num_dict [ b ] <NEWLINE> del num_dict [ b ] <NEWLINE> if b > c : <NEWLINE> <INDENT> s = s - ( b - c ) * k <NEWLINE> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + ( c - b ) * k <NEWLINE> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b in num_dict : <NEWLINE> <INDENT> k = num_dict [ b ] <NEWLINE> num_dict [ c ] = num_dict [ b ] <NEWLINE> del num_dict [ b ] <NEWLINE> if b > c : <NEWLINE> <INDENT> s = s - ( b - c ) * k <NEWLINE> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + ( c - b ) * k <NEWLINE> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ j + i ] == t [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> l . append ( c ) <NEWLINE> <DEDENT> print ( len ( t ) - max ( l ) ) <NEWLINE>
import bisect <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N * M == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> P = [ 0 ] + [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> k = [ P [ i ] + P [ j ] for i in range ( N ) for j in range ( i , N ) ] <NEWLINE> k = sorted ( k ) <NEWLINE> <NL> ret = 0 <NEWLINE> for tmp in k : <NEWLINE> <INDENT> if tmp > M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = M - tmp <NEWLINE> l = bisect . bisect_right ( k , r ) <NEWLINE> if l >= len ( k ) : <NEWLINE> <INDENT> tmp += k [ - 1 ] <NEWLINE> <DEDENT> elif l != 0 : <NEWLINE> <INDENT> tmp += k [ l - 1 ] <NEWLINE> <DEDENT> ret = max ( ret , tmp ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> ret = solve ( ) <NEWLINE> if ret : <NEWLINE> <INDENT> ans . append ( ret ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> <NL> mods = [ 0 for _ in range ( 2019 ) ] <NEWLINE> mods [ 0 ] = 1 <NEWLINE> t = 0 <NEWLINE> mod10 = 1 <NEWLINE> for s in reversed ( S ) : <NEWLINE> <INDENT> t += int ( s ) * mod10 <NEWLINE> t = t % 2019 <NEWLINE> mod10 *= 10 <NEWLINE> mod10 %= 2019 <NEWLINE> mods [ t ] += 1 <NEWLINE> <NL> <DEDENT> cnt = sum ( [ m * ( m - 1 ) / 2 for m in mods ] ) <NEWLINE> print ( int ( cnt ) ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> if x - k * d >= 0 : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ok , ng = k , 0 <NEWLINE> while ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if x - mid * d <= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> rest = k - ok <NEWLINE> if rest % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( abs ( x - ok * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( x - ( ok - 1 ) * d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x + k * d <= 0 : <NEWLINE> <INDENT> print ( abs ( x + k * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ok , ng = k , 0 <NEWLINE> while ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ng + ok ) // 2 <NEWLINE> if x + mid * d >= 0 : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> rest = k - ok <NEWLINE> if rest % 2 == 0 : <NEWLINE> <INDENT> print ( x + ok * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x + ok * d - d ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> list = [ 0 ] * 100001 <NEWLINE> sum = sum ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> list [ i ] += 1 <NEWLINE> <NL> <DEDENT> for bc in BC : <NEWLINE> <INDENT> x = list [ bc [ 0 ] ] <NEWLINE> sum += ( bc [ 1 ] - bc [ 0 ] ) * x <NEWLINE> print ( sum ) <NEWLINE> list [ bc [ 0 ] ] -= x <NEWLINE> list [ bc [ 1 ] ] += x <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> array = [ 0 ] * 201 <NEWLINE> <NL> for X in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> array [ X ] += gcd ( X , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> X = gcd ( a , b ) <NEWLINE> ans += array [ X ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if n == 1 : print ( 0 ) ; exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> from math import sqrt <NEWLINE> from collections import deque <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> sys . setrecursionlimit ( 11451419 ) <NEWLINE> from functools import lru_cache <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from math import sqrt <NEWLINE> def eratosu ( n ) : <NEWLINE> <INDENT> if not isinstance ( n , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> prime = [ ] <NEWLINE> limit = sqrt ( n ) <NEWLINE> data = [ i + 1 for i in range ( 1 , n ) ] <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> p = data [ 0 ] <NEWLINE> if limit <= p : <NEWLINE> <INDENT> return prime + data <NEWLINE> <DEDENT> prime . append ( p ) <NEWLINE> data = [ e for e in data if e % p != 0 ] <NEWLINE> <DEDENT> <DEDENT> def bunkai ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return [ [ 2 , 1 ] ] <NEWLINE> <DEDENT> if n == 3 : <NEWLINE> <INDENT> return [ [ 3 , 1 ] ] <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> temp = n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> primelist = eratosu ( int ( sqrt ( n ) ) ) <NEWLINE> for i in primelist : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> ji = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> ji += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> ans . append ( [ i , ji ] ) <NEWLINE> <DEDENT> <DEDENT> if ans == [ ] : return ( [ [ n , 1 ] ] ) <COMMENT> <NEWLINE> if temp != 1 : <NEWLINE> <INDENT> ans . append ( [ temp , 1 ] ) <COMMENT> <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> a = bunkai ( n ) <NEWLINE> <NL> ans = 0 <NEWLINE> import bisect as bi <NEWLINE> p = [ 1 , 3 , 6 , 10 , 15 , 21 , 28 , 36 , 45 , 55 ] <NEWLINE> for l in a : <NEWLINE> <INDENT> q = l [ 1 ] <NEWLINE> ans += bi . bisect_right ( p , q ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num_limit = b - a + 1 <NEWLINE> if num_limit <= k * 2 : <NEWLINE> <INDENT> ans_list = [ i for i in range ( a , b + 1 , 1 ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list = [ ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> low = a + j <NEWLINE> high = b - j <NEWLINE> ans_list . append ( low ) <NEWLINE> ans_list . append ( high ) <NEWLINE> <DEDENT> ans_list . sort ( ) <NEWLINE> <NL> <DEDENT> for l in ans_list : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> n , m = LI ( ) <NEWLINE> <NL> root = [ - 1 ] * n <NEWLINE> <NL> <NL> def r ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = r ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> y = r ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> x = r ( x ) <NEWLINE> return - root [ x ] <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = LI ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = max ( map ( size , range ( n ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> import itertools <NEWLINE> <NL> N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ [ 0 ] * C for _ in range ( C ) ] <NEWLINE> for i in range ( C ) : <NEWLINE> <INDENT> D [ i ] = list ( int ( d ) for d in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dict_c = [ defaultdict ( int ) for _ in range ( 3 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> dict_c [ ( i + j ) % 3 ] [ c [ j ] - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> list_C = list ( range ( C ) ) <NEWLINE> ans = 10 ** 18 <NEWLINE> for ( p , q , r ) in itertools . permutations ( list_C , 3 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i , j in enumerate ( ( p , q , r ) ) : <NEWLINE> <INDENT> for m , n in dict_c [ i ] . items ( ) : <NEWLINE> <INDENT> tmp += D [ m ] [ j ] * n <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 1000000000000000000 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> ans *= A [ n ] <NEWLINE> if ans > INF : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans_dict = { i : set ( ) for i in range ( 1 , N + 1 ) } <NEWLINE> <NL> if N != 1 : <NEWLINE> <INDENT> for i in range ( 1 , 1 + math . floor ( - 1 + math . sqrt ( N - 2 ) ) ) : <NEWLINE> <INDENT> for j in range ( 1 , 1 + math . floor ( - 1 + math . sqrt ( N - 2 ) ) ) : <NEWLINE> <INDENT> for k in range ( 1 , 1 + math . floor ( - 1 + math . sqrt ( N - 2 ) ) ) : <NEWLINE> <INDENT> n = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if 1 <= n <= N : <NEWLINE> <INDENT> ans_dict [ n ] . add ( ( i , j , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( len ( ans_dict [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> list = [ b for b in input ( ) . split ( ) ] <NEWLINE> a = 1 <NEWLINE> if <STRING> in list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in range ( N ) : <NEWLINE> <INDENT> a = a * int ( list [ l ] ) <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import shortest_path <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> from scipy . sparse . csgraph import csgraph_from_dense <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> G = [ [ INF ] * ( N + 1 ) for n in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] [ b ] = c <NEWLINE> G [ b ] [ a ] = c <NEWLINE> <DEDENT> G = csgraph_from_dense ( G , null_value = INF ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> Queries = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> Queries . append ( ( s , t ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> cost = floyd_warshall ( G ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> no_refuel = [ [ 1 if x <= L else INF for x in c ] for c in cost ] <NEWLINE> no_refuel = csgraph_from_dense ( no_refuel , null_value = INF ) <NEWLINE> refuel_count = floyd_warshall ( no_refuel ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for s , t in Queries : <NEWLINE> <INDENT> d = refuel_count [ s ] [ t ] <NEWLINE> ans . append ( int ( d - 1 ) if d != INF else - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def get_digits_sum ( val_str ) : <NEWLINE> <INDENT> digits_sum = 0 <NEWLINE> for i in range ( len ( val_str ) ) : <NEWLINE> <INDENT> digits_sum += int ( val_str [ i ] ) <NEWLINE> <NL> <DEDENT> return digits_sum <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> sum_min = 2 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N , 1 ) : <NEWLINE> <INDENT> A = i <NEWLINE> B = N - i <NEWLINE> a_sum = get_digits_sum ( str ( A ) ) <NEWLINE> b_sum = get_digits_sum ( str ( B ) ) <NEWLINE> if i == 2 : <NEWLINE> <INDENT> sum_min = a_sum + b_sum <NEWLINE> <DEDENT> elif sum_min > a_sum + b_sum : <NEWLINE> <INDENT> sum_min = a_sum + b_sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_min ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rad = 0 <NEWLINE> deg_long = M * 6 <NEWLINE> deg_short = 30 * H + M / 2 <NEWLINE> <NL> if abs ( deg_long - deg_short ) > 180 : <NEWLINE> <INDENT> rad = math . radians ( 360 - abs ( deg_long - deg_short ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rad = math . radians ( abs ( deg_long - deg_short ) ) <NEWLINE> <NL> <DEDENT> print ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( rad ) ) ) <NEWLINE>
dbg = False <NEWLINE> <NL> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> x , y = a , b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = b , a <NEWLINE> <NL> <DEDENT> divs = [ 1 ] <NEWLINE> for i in range ( 1 , int ( ( y + 1 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> gcd_tmp = int ( y / i ) <NEWLINE> if dbg : print ( <STRING> % ( i , gcd_tmp ) ) <NEWLINE> if i > gcd_tmp : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if y % i == 0 : <NEWLINE> <INDENT> if x % gcd_tmp == 0 : <NEWLINE> <INDENT> print ( gcd_tmp ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif x % i == 0 : <NEWLINE> <INDENT> divs . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( divs ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> power = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power = power * i % mod <NEWLINE> <NL> <DEDENT> print ( power ) <NEWLINE>
Suits = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> Taro = [ ] <NEWLINE> Missing = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Taro . append ( input ( ) ) <NEWLINE> <DEDENT> for j in range ( 52 ) : <NEWLINE> <INDENT> card = Suits [ j // 13 ] + <STRING> + str ( j % 13 + 1 ) <NEWLINE> if card not in Taro : <NEWLINE> <INDENT> Missing . append ( card ) <NEWLINE> <DEDENT> <DEDENT> if Missing != [ ] : <NEWLINE> <INDENT> print ( <STRING> . join ( Missing ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = sum ( i ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> ans += ( i [ k ] * ( m - i [ k ] ) ) <NEWLINE> <DEDENT> ans = ans // 2 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> n = 7 <NEWLINE> c = 0 <NEWLINE> while c <= K : <NEWLINE> <INDENT> n %= K <NEWLINE> c += 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = n * 10 + 7 <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> ans = 1 <NEWLINE> if M == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = max ( uf . union ( x , y ) , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> st_n = a [ 0 ] <NEWLINE> st_r = a [ 1 ] <NEWLINE> m = st_r * ( st_n - st_r ) <NEWLINE> for r in range ( 2 , N ) : <NEWLINE> <INDENT> cn = a [ r ] * ( st_n - a [ r ] ) <NEWLINE> if m < cn : <NEWLINE> <INDENT> st_r = a [ r ] <NEWLINE> m = cn <NEWLINE> <DEDENT> <DEDENT> print ( st_n , st_r ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> N = len ( s ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , min ( N , i + K ) ) : <NEWLINE> <INDENT> sub = s [ i : j + 1 ] <NEWLINE> if d . get ( sub ) == None : <NEWLINE> <INDENT> d [ sub ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> d2 = sorted ( d . items ( ) ) <NEWLINE> print ( d2 [ K - 1 ] [ 0 ] ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> dis = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) <NEWLINE> print ( dis ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab_gcd = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ab_gcd , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> li1 = [ ] <NEWLINE> li2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li1 . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> b = <STRING> * ( n - len ( bin ( i ) ) + 2 ) + bin ( i ) [ 2 : ] <NEWLINE> total = 0 <NEWLINE> li3 = [ 0 ] * m <NEWLINE> f = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if b [ j ] == <STRING> : <NEWLINE> <INDENT> total += li1 [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> li3 [ k ] += li1 [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if li3 [ j ] < x : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> li2 . append ( total ) <NEWLINE> <DEDENT> <DEDENT> if len ( li2 ) >= 1 : <NEWLINE> <INDENT> print ( min ( li2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> den = int ( 1e9 + 7 ) <NEWLINE> sum_a = [ 0 for i in range ( len ( a ) ) ] <NEWLINE> sum_a [ - 1 ] = a [ - 1 ] <NEWLINE> for i in range ( len ( a ) - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> sum_a [ i - 1 ] = sum_a [ i ] + a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> ans = ( ans + a [ i ] * sum_a [ i + 1 ] ) % den <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> maxi = 10 ** 6 + 1 <NEWLINE> dp = [ 0 ] * maxi <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> if dp [ tmp ] != 0 : <NEWLINE> <INDENT> dp [ tmp ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( tmp , maxi , tmp ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> if dp [ tmp ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> class Solve : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . N , self . K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> self . W = [ int ( input ( ) ) for i in range ( self . N ) ] <NEWLINE> <NL> self . a = max ( self . W ) - 1 <COMMENT> <NEWLINE> self . b = sum ( self . W ) <COMMENT> <NEWLINE> <NL> <DEDENT> def check ( self , P ) : <NEWLINE> <INDENT> k , p , W = 1 , P , [ w for w in self . W ] <NEWLINE> for w in W : <NEWLINE> <INDENT> if p >= w : <NEWLINE> <INDENT> p -= w <NEWLINE> <DEDENT> elif P >= w and k < self . K : <NEWLINE> <INDENT> k , p = k + 1 , P - w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> while self . b - self . a > 1 : <NEWLINE> <INDENT> m = ( self . a + self . b ) // 2 <NEWLINE> if self . check ( m ) : <NEWLINE> <INDENT> self . b = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . a = m <NEWLINE> <DEDENT> <DEDENT> return self . b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Solve ( ) . solve ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> if s in d : <NEWLINE> <INDENT> ans += d [ s ] <NEWLINE> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for A in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for B in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> AB = math . gcd ( A , B ) <NEWLINE> for C in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( AB , C ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> k -= 1 <NEWLINE> s = input ( ) <NEWLINE> print ( s [ : k ] + s [ k ] . lower ( ) + s [ k + 1 : ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> ans = r * b * g <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for s in range ( N ) : <NEWLINE> <INDENT> j = i + s <NEWLINE> k = j + s <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> gacha_list = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> input_line = input ( ) <NEWLINE> if input_line not in gacha_list : <NEWLINE> <INDENT> gacha_list . add ( input_line ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( gacha_list ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> S . append ( [ <STRING> for _ in range ( W + 2 ) ] ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s = <STRING> + s + <STRING> <NEWLINE> S . append ( [ ] ) <NEWLINE> for k in range ( W + 2 ) : <NEWLINE> <INDENT> S [ - 1 ] . append ( s [ k ] ) <NEWLINE> <DEDENT> <DEDENT> S . append ( [ <STRING> for _ in range ( W + 2 ) ] ) <NEWLINE> b = 0 <NEWLINE> start = [ ] <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> c = 0 <NEWLINE> b += 1 <NEWLINE> if S [ h + 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h - 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> start . append ( [ h , w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( start ) == 0 : <NEWLINE> <INDENT> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> c = 0 <NEWLINE> if S [ h + 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h - 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S [ h ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if c == 2 : <NEWLINE> <INDENT> start . append ( [ h , w ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> def solve ( now , point ) : <NEWLINE> <INDENT> nextlist = [ ] <NEWLINE> for n in now : <NEWLINE> <INDENT> if counter [ n [ 0 ] + 1 ] [ n [ 1 ] ] > point + 1 : <NEWLINE> <INDENT> counter [ n [ 0 ] + 1 ] [ n [ 1 ] ] = point + 1 <NEWLINE> nextlist . append ( [ n [ 0 ] + 1 , n [ 1 ] ] ) <NEWLINE> <DEDENT> if counter [ n [ 0 ] ] [ n [ 1 ] + 1 ] > point + 1 : <NEWLINE> <INDENT> nextlist . append ( [ n [ 0 ] , n [ 1 ] + 1 ] ) <NEWLINE> counter [ n [ 0 ] ] [ n [ 1 ] + 1 ] = point + 1 <NEWLINE> <DEDENT> if counter [ n [ 0 ] - 1 ] [ n [ 1 ] ] > point + 1 : <NEWLINE> <INDENT> nextlist . append ( [ n [ 0 ] - 1 , n [ 1 ] ] ) <NEWLINE> counter [ n [ 0 ] - 1 ] [ n [ 1 ] ] = point + 1 <NEWLINE> <DEDENT> if counter [ n [ 0 ] ] [ n [ 1 ] - 1 ] > point + 1 : <NEWLINE> <INDENT> nextlist . append ( [ n [ 0 ] , n [ 1 ] - 1 ] ) <NEWLINE> counter [ n [ 0 ] ] [ n [ 1 ] - 1 ] = point + 1 <NEWLINE> <DEDENT> <DEDENT> if len ( nextlist ) == 0 : <NEWLINE> <INDENT> anskouho . append ( point ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solve ( nextlist , point + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> anskouho = [ ] <NEWLINE> for item in start : <NEWLINE> <INDENT> original_counter = [ [ b for _ in range ( W + 2 ) ] for _ in range ( H + 2 ) ] <NEWLINE> for k in range ( H + 2 ) : <NEWLINE> <INDENT> for j in range ( W + 2 ) : <NEWLINE> <INDENT> if S [ k ] [ j ] == <STRING> : <NEWLINE> <INDENT> original_counter [ k ] [ j ] = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> counter = original_counter <NEWLINE> counter [ item [ 0 ] ] [ item [ 1 ] ] = 0 <NEWLINE> solve ( [ item ] , 0 ) <NEWLINE> <DEDENT> print ( max ( anskouho ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> S = stdin . readline ( ) . rstrip ( ) <NEWLINE> r_count , g_count , b_count = [ S . count ( x ) for x in <STRING> ] <NEWLINE> ans = r_count * g_count * b_count <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < N and ( S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prev_a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> prev_a . append ( alist [ i ] ) <NEWLINE> if i >= k : <NEWLINE> <NL> <INDENT> if prev_a . pop ( 0 ) < alist [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort_lis = sorted ( lis ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> fac_lis = [ [ 0 ] for i in range ( N ) ] <NEWLINE> fac_lis [ 0 ] = 1 <NEWLINE> max_ans = 0 <NEWLINE> min_ans = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> fac_lis [ i ] = fac_lis [ i - 1 ] * ( i + 1 ) % p <NEWLINE> <NL> <DEDENT> def combi ( n , k ) : <NEWLINE> <INDENT> if n == k : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fac_lis [ n - 1 ] * pow ( fac_lis [ k - 1 ] , p - 2 , p ) * pow ( fac_lis [ n - k - 1 ] , p - 2 , p ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K - 1 , N ) : <NEWLINE> <INDENT> max_ans += sort_lis [ i ] * combi ( i , K - 1 ) <NEWLINE> max_ans %= p <NEWLINE> <NL> <DEDENT> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> min_ans += sort_lis [ i ] * combi ( N - ( i + 1 ) , K - 1 ) <NEWLINE> min_ans %= p <NEWLINE> <NL> <DEDENT> ans = ( max_ans - min_ans ) % p <NEWLINE> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> <NL> result = 1 <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for x in a : <NEWLINE> <INDENT> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> result *= x <NEWLINE> <NL> <DEDENT> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> Y = int ( <STRING> + X , 0 ) <NEWLINE> X = np . array ( list ( X ) , int ) <NEWLINE> <NL> p = int ( X . sum ( ) ) <NEWLINE> m1 = Y % ( p + 1 ) <NEWLINE> m2 = Y % max ( 1 , p - 1 ) <NEWLINE> <NL> <NL> count = np . zeros ( ( N + 1 , ) ) <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> i = np . array ( list ( bin ( n ) ) [ 2 : ] , int ) . sum ( ) <NEWLINE> count [ n ] = 1 + count [ n % i ] <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> if X [ n - 1 ] : <NEWLINE> <INDENT> z = m2 - pow ( 2 , N - n , max ( 1 , p - 1 ) ) <NEWLINE> z %= max ( 1 , p - 1 ) <NEWLINE> if p - 1 == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> z = pow ( 2 , N - n , p + 1 ) + m1 <NEWLINE> z %= p + 1 <NEWLINE> if p == 0 : <NEWLINE> <INDENT> z = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ n - 1 ] = int ( count [ z ] + 1 ) <NEWLINE> if z == 0 and flag : <NEWLINE> <INDENT> ans [ n - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list_S = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> print ( len ( list ( set ( list_S ) ) ) ) <NEWLINE>
import math <NEWLINE> gcd1 = 0 <NEWLINE> gcd3 = 0 <NEWLINE> gcd6 = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if a < b < c : <NEWLINE> <INDENT> gcd6 += math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <DEDENT> elif a == b < c or a < b == c : <NEWLINE> <INDENT> gcd3 += math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <DEDENT> elif a == b == c : <NEWLINE> <INDENT> gcd1 += math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( 6 * gcd6 + 3 * gcd3 + gcd1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . sort ( ) <NEWLINE> a = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = a * s [ i ] <NEWLINE> if a > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> pc_memo = defaultdict ( int ) <NEWLINE> memo = defaultdict ( int ) <NEWLINE> <NL> <NL> def to_next ( x ) : <NEWLINE> <INDENT> if x not in pc_memo . keys ( ) : <NEWLINE> <INDENT> pc_memo [ x ] = x % <STRING> . format ( x ) . count ( <STRING> ) <NEWLINE> <DEDENT> return pc_memo [ x ] <NEWLINE> <NL> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if x not in memo . keys ( ) : <NEWLINE> <INDENT> memo [ x ] = f ( to_next ( x ) ) + 1 <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 2 * 10 ** 5 ) : <NEWLINE> <INDENT> f ( i ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) . rstrip ( ) <NEWLINE> one_cnt = x . count ( <STRING> ) <NEWLINE> <NL> mod_minus = 0 <NEWLINE> mod_plus = 0 <NEWLINE> for i , a in enumerate ( reversed ( x ) ) : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> if 0 < one_cnt - 1 : <NEWLINE> <INDENT> mod_minus += pow ( 2 , i , one_cnt - 1 ) <NEWLINE> mod_minus %= one_cnt - 1 <NEWLINE> <DEDENT> mod_plus += pow ( 2 , i , one_cnt + 1 ) <NEWLINE> mod_plus %= one_cnt + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> nx = mod_plus + pow ( 2 , n - i - 1 , one_cnt + 1 ) <NEWLINE> nx %= one_cnt + 1 <NEWLINE> print ( f ( nx ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 0 < one_cnt - 1 : <NEWLINE> <INDENT> nx = mod_minus - pow ( 2 , n - i - 1 , one_cnt - 1 ) <NEWLINE> nx %= one_cnt - 1 <NEWLINE> print ( f ( nx ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> lr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> a = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> a [ l - 1 ] [ r - 1 ] += 1 <NEWLINE> <NL> <DEDENT> cnt = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for y in range ( n ) : <NEWLINE> <INDENT> v = 0 <NEWLINE> for x in range ( y , - 1 , - 1 ) : <NEWLINE> <INDENT> v += a [ x ] [ y ] <NEWLINE> cnt [ x ] [ y ] = cnt [ x ] [ y - 1 ] + v <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cnt [ p - 1 ] [ q - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = n // i <NEWLINE> ans += i * ( k * ( k + 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def analyze_map ( data ) : <NEWLINE> <INDENT> S1 = [ ] <COMMENT> <NEWLINE> S2 = [ ] <COMMENT> <NEWLINE> <NL> area = 0 <NEWLINE> for i , p in enumerate ( data ) : <NEWLINE> <INDENT> if p == <STRING> : <NEWLINE> <INDENT> S1 . append ( i ) <COMMENT> <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> if S1 : <NEWLINE> <INDENT> pos = S1 . pop ( ) <NEWLINE> area = ( i - pos ) <NEWLINE> while S2 and S2 [ - 1 ] [ 0 ] > pos : <NEWLINE> <INDENT> sub_pos , sub_area = S2 . pop ( ) <NEWLINE> area += sub_area <NEWLINE> <DEDENT> S2 . append ( ( pos , area ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return S2 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> data = input ( ) <NEWLINE> <NL> <COMMENT> <NL> results = analyze_map ( data ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> total_area = sum ( [ area for pos , area in results ] ) <NEWLINE> if total_area : <NEWLINE> <INDENT> print ( total_area ) <NEWLINE> valid_areas = [ area for start , area in results if area > 0 ] <NEWLINE> print ( <STRING> . format ( len ( valid_areas ) , <STRING> . join ( map ( str , valid_areas ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A . sort ( ) <NEWLINE> B = [ True ] * ( A [ - 1 ] + 1 ) <NEWLINE> i = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i < N - 1 and A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> B [ A [ i ] ] = False <NEWLINE> <DEDENT> if A [ - 1 ] < 2 * A [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> M = A [ - 1 ] // A [ i ] + 1 <NEWLINE> for j in range ( 2 , M ) : <NEWLINE> <INDENT> B [ j * A [ i ] ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if B [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for l in range ( Q ) ] <NEWLINE> b = [ 1 ] * N <NEWLINE> c = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if b [ a [ i ] [ 1 ] - 1 ] - b [ a [ i ] [ 0 ] - 1 ] == a [ i ] [ 2 ] : <NEWLINE> <INDENT> c += a [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> C = c <NEWLINE> for k in range ( 1 , M ) : <NEWLINE> <INDENT> nums = [ i for i in range ( N - 1 ) ] <NEWLINE> for balls in itertools . combinations_with_replacement ( nums , k ) : <NEWLINE> <INDENT> b = [ 1 ] * N <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> b [ i ] = b [ i - 1 ] + balls . count ( i - 1 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if b [ a [ i ] [ 1 ] - 1 ] - b [ a [ i ] [ 0 ] - 1 ] == a [ i ] [ 2 ] : <NEWLINE> <INDENT> c += a [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> C = max ( C , c ) <NEWLINE> <DEDENT> <DEDENT> print ( C ) <NEWLINE>
def replace ( str ) : <NEWLINE> <INDENT> for i , c in enumerate ( command [ 3 ] , command [ 1 ] ) : <NEWLINE> <INDENT> str [ i ] = c <NEWLINE> <DEDENT> return str <NEWLINE> <NL> <DEDENT> def reverse ( str ) : <NEWLINE> <INDENT> for i , c in enumerate ( reversed ( str [ command [ 1 ] : command [ 2 ] + 1 ] ) , command [ 1 ] ) : <NEWLINE> <INDENT> str [ i ] = c <NEWLINE> <DEDENT> return str <NEWLINE> <NL> <DEDENT> def str_print ( str ) : <NEWLINE> <INDENT> str = <STRING> . join ( str ) <NEWLINE> print ( str [ command [ 1 ] : command [ 2 ] + 1 ] ) <NEWLINE> str = list ( str ) <NEWLINE> return str <NEWLINE> <NL> <DEDENT> str = list ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> command [ 1 ] , command [ 2 ] = int ( command [ 1 ] ) , int ( command [ 2 ] ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> str = replace ( str ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> str = reverse ( str ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> str = str_print ( str ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from numba import jit <NEWLINE> @ jit <NEWLINE> def Sum_divisors ( ) : <NEWLINE> <INDENT> n , ans = int ( input ( ) ) , 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : ans += j <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> Sum_divisors ( ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> import numpy as np <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def sieve ( n ) : <NEWLINE> <INDENT> res = [ i for i in range ( n ) ] <NEWLINE> <NL> i = 2 <NEWLINE> while i * i < n : <NEWLINE> <INDENT> if res [ i ] < i : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> j = i * i <NEWLINE> while j < n : <NEWLINE> <INDENT> if res [ j ] == j : <NEWLINE> <INDENT> res [ j ] = i <NEWLINE> <DEDENT> j += i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def factor ( n , min_factor ) : <NEWLINE> <INDENT> res = set ( ) <NEWLINE> while n > 1 : <NEWLINE> <INDENT> res . add ( min_factor [ n ] ) <NEWLINE> n //= min_factor [ n ] <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = ii ( ) <NEWLINE> A = np . array ( list ( mi ( ) ) ) <NEWLINE> <NL> m = max ( A ) <NEWLINE> s = sieve ( m + 1 ) <NEWLINE> d = defaultdict ( bool ) <NEWLINE> <NL> g = np . gcd . reduce ( A ) <NEWLINE> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> f = factor ( a , s ) <NEWLINE> for v in f : <NEWLINE> <INDENT> if d [ v ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> d [ v ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> ans = n * ( n - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a , d , b , e , c , f = map ( float , input ( ) . split ( ) ) <NEWLINE> z = 2 * ( b * f - c * e + c * d - a * f + a * e - b * d ) <NEWLINE> x = ( ( e - f ) * ( a ** 2 + d ** 2 ) + ( f - d ) * ( b ** 2 + e ** 2 ) + ( d - e ) * ( c ** 2 + f ** 2 ) ) / z <NEWLINE> y = ( ( c - b ) * ( a ** 2 + d ** 2 ) + ( a - c ) * ( b ** 2 + e ** 2 ) + ( b - a ) * ( c ** 2 + f ** 2 ) ) / z <NEWLINE> print ( <STRING> . format ( x , y , ( ( a - x ) ** 2 + ( d - y ) ** 2 ) ** 0.5 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ ] <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( * result , sep = <STRING> ) <NEWLINE>
<NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> <NL> cnt = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= N - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> x1 , y1 , x2 , y2 = [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_input = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp_i = [ a_input [ i ] - i for i in range ( n ) ] <NEWLINE> tmp_j = [ - a_input [ i ] - i for i in range ( n ) ] <NEWLINE> <NL> count_i = Counter ( tmp_i ) <NEWLINE> count_j = Counter ( tmp_j ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k , v in count_i . items ( ) : <NEWLINE> <INDENT> ans += v * count_j . get ( k , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ls = [ 0 ] * ( N + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ls [ a ] += 1 <NEWLINE> <NL> <DEDENT> C = 0 <NEWLINE> for i in set ( A ) : <NEWLINE> <INDENT> n = ls [ i ] <NEWLINE> C += n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> n = ls [ a ] <NEWLINE> print ( C - ( n - 1 ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dict_A = Counter ( A ) <NEWLINE> sum_comb = 0 <NEWLINE> for v in dict_A . values ( ) : <NEWLINE> <INDENT> sum_comb += int ( ( v * ( v - 1 ) ) / 2 ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( sum_comb - dict_A [ a ] + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . sort ( ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = [ abs ( x [ i ] - x [ i + 1 ] ) for i in range ( m - 1 ) ] <NEWLINE> diff . sort ( reverse = True ) <NEWLINE> ans = sum ( diff ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans -= diff [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for d in range ( len ( S ) ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> dic = { } <NEWLINE> n , w , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if n == 0 and w == 0 and d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dic [ 1 ] = ( w , d ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> W , H = dic [ p ] <NEWLINE> for j in range ( p , i + 1 ) : <NEWLINE> <INDENT> dic [ j ] = dic [ j + 1 ] <NEWLINE> <DEDENT> cycle = 2 * ( H + W ) <NEWLINE> s %= cycle <NEWLINE> if s < W or ( ( H + W ) < s and s < ( W + H + W ) ) : <NEWLINE> <INDENT> if W < s : <NEWLINE> <INDENT> s -= ( H + W ) <NEWLINE> <DEDENT> dic [ i + 1 ] = ( min ( s , W - s ) , H ) <NEWLINE> dic [ i + 2 ] = ( max ( s , W - s ) , H ) <NEWLINE> <NL> <DEDENT> elif ( W < s and s < ( H + W ) ) or ( ( W + H + W ) < s ) : <NEWLINE> <INDENT> if s > ( H + W ) : <NEWLINE> <INDENT> s -= ( W + H + W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= W <NEWLINE> <DEDENT> dic [ i + 1 ] = ( W , min ( s , H - s ) ) <NEWLINE> dic [ i + 2 ] = ( W , max ( s , H - s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> sq = list ( dic . values ( ) ) <NEWLINE> sq . sort ( key = lambda x : x [ 0 ] * x [ 1 ] ) <NEWLINE> for i in range ( len ( sq ) - 1 ) : <NEWLINE> <INDENT> print ( sq [ i ] [ 0 ] * sq [ i ] [ 1 ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( sq [ len ( sq ) - 1 ] [ 0 ] * sq [ len ( sq ) - 1 ] [ 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( pi * ( r ** 2 ) , 2 * pi * r ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> it = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> N = next ( it ) <NEWLINE> A = [ next ( it ) for i in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> ax = max ( A ) + 1 <NEWLINE> dp = [ 0 ] * ax <NEWLINE> for ai in A : <NEWLINE> <INDENT> da = dp [ ai ] <NEWLINE> if da > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ ai ] += 1 <NEWLINE> if da == 0 : <NEWLINE> <INDENT> for aj in range ( 2 * ai , ax , ai ) : <NEWLINE> <INDENT> dp [ aj ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ai in A : <NEWLINE> <INDENT> if dp [ ai ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif ( a + b ) >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
import decimal <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> N , K = LI ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> d = list ( reversed ( c ) ) + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = list ( reversed ( b ) ) + c <NEWLINE> <DEDENT> print ( * d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> count += ( n - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <COMMENT> <NEWLINE> Amax = A [ - 1 ] <NEWLINE> dp = [ 1 ] * ( Amax + 1 ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> p = A [ i ] <NEWLINE> if dp [ p ] == 1 : <COMMENT> <NEWLINE> <INDENT> for q in range ( Amax // p + 1 ) : <NEWLINE> <INDENT> dp [ p * q ] = 0 <COMMENT> <NEWLINE> <DEDENT> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ Amax ] == 1 : <COMMENT> <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <COMMENT> <NEWLINE> t = input ( ) <COMMENT> <NEWLINE> <NL> s_len = len ( s ) <NEWLINE> t_len = len ( t ) <NEWLINE> flg = False <NEWLINE> <NL> for i in range ( s_len - t_len , - 1 , - 1 ) : <NEWLINE> <INDENT> flg = True <NEWLINE> for j in range ( t_len ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] and s [ i + j ] != <STRING> : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == True : <NEWLINE> <INDENT> trial = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in s [ : trial ] : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <DEDENT> <DEDENT> ans = ans + t <NEWLINE> <NL> for i in s [ ( trial + t_len ) : ] : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> w = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans += i - w <NEWLINE> w += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for A in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b - 1 : <NEWLINE> <INDENT> print ( a * ( n % b ) // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * ( ( b - 1 ) % b ) // b ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> total_a = a + v * t <NEWLINE> total_b = b + w * t <NEWLINE> if total_a >= total_b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> total_a = a - v * t <NEWLINE> total_b = b - w * t <NEWLINE> if total_a <= total_b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> fac = [ 1 for _ in range ( n + 1 ) ] <NEWLINE> inv = [ 1 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i <NEWLINE> fac [ i ] %= mod <NEWLINE> inv [ i ] = inv [ i - 1 ] * pow ( i , - 1 , mod ) <NEWLINE> inv [ i ] %= mod <NEWLINE> <NL> <DEDENT> def comb ( a , b , mod ) : <NEWLINE> <INDENT> return ( fac [ a ] * inv [ b ] * inv [ a - b ] ) % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> nck = comb ( i , k - 1 , mod ) <NEWLINE> ans += nck * a [ i ] <NEWLINE> ans -= nck * a [ n - i - 1 ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k_a = collections . Counter ( l_a ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( k_a [ i + 1 ] ) <NEWLINE> <DEDENT>
S = input ( ) . rstrip ( ) <NEWLINE> Q = int ( input ( ) . rstrip ( ) ) <NEWLINE> a = - 1 <NEWLINE> before = [ ] <NEWLINE> after = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> stdin = input ( ) . rstrip ( ) <NEWLINE> if int ( stdin [ 0 ] ) == 1 : <NEWLINE> <INDENT> a = ~ a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T , F , C = stdin . split ( ) <NEWLINE> if int ( F ) == 2 + a : <NEWLINE> <INDENT> before . append ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> after . append ( C ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> S = <STRING> . join ( before ) [ : : - 1 ] + S + <STRING> . join ( after ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import collections <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> a , b = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> af = factorization ( a ) <NEWLINE> bf = factorization ( b ) <NEWLINE> <NL> c = collections . Counter ( ) <NEWLINE> c [ 1 ] = 2 <NEWLINE> for x in af : <NEWLINE> <INDENT> c [ x [ 0 ] ] += 1 <NEWLINE> <DEDENT> for x in bf : <NEWLINE> <INDENT> c [ x [ 0 ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for k in c . keys ( ) : <NEWLINE> <INDENT> if c [ k ] >= 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> AA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = AA [ 0 ] <NEWLINE> if 0 in AA : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in AA [ 1 : ] : <NEWLINE> <INDENT> res = res * a <NEWLINE> if res > 1e18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = list ( [ 0 ] * N ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> ans [ tmp - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while a >= b : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> j = 0 <NEWLINE> while b >= c : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> if i + j <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def mul2 ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( mul2 ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = int ( n / i ) <NEWLINE> ans += i * tmp * ( tmp + 1 ) <NEWLINE> <NL> <DEDENT> print ( int ( ans / 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> slist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> slist . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> first_list = [ ] <NEWLINE> last_list = [ ] <NEWLINE> first = <STRING> <NEWLINE> last = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = slist [ i ] <NEWLINE> <NL> a_count = 0 <NEWLINE> b_count = 0 <NEWLINE> min_s = <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> b_count -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_count += 1 <NEWLINE> <DEDENT> if b_count < 0 : <NEWLINE> <INDENT> b_count = 0 <NEWLINE> a_count += 1 <NEWLINE> <DEDENT> <DEDENT> min_s = <STRING> * a_count + <STRING> * b_count <NEWLINE> <NL> ai = a_count <NEWLINE> bi = b_count <NEWLINE> <NL> if ai == 0 : <NEWLINE> <INDENT> first += min_s <NEWLINE> <DEDENT> elif bi == 0 : <NEWLINE> <INDENT> last += min_s <NEWLINE> <DEDENT> elif bi - ai >= 0 : <NEWLINE> <INDENT> first_list . append ( [ min_s , ai ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last_list . append ( [ min_s , bi ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> first_list = sorted ( first_list , key = lambda s : s [ 1 ] ) <NEWLINE> last_list = sorted ( last_list , key = lambda s : s [ 1 ] , reverse = True ) <NEWLINE> <NL> ans = first <NEWLINE> for i in range ( len ( first_list ) ) : <NEWLINE> <INDENT> ans += first_list [ i ] [ 0 ] <NEWLINE> <DEDENT> for i in range ( len ( last_list ) ) : <NEWLINE> <INDENT> ans += last_list [ i ] [ 0 ] <NEWLINE> <DEDENT> ans += last <NEWLINE> <NL> a_count = 0 <NEWLINE> b_count = 0 <NEWLINE> min_s = <STRING> <NEWLINE> for c in ans : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> b_count -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_count += 1 <NEWLINE> <DEDENT> if b_count < 0 : <NEWLINE> <INDENT> b_count = 0 <NEWLINE> a_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a_count == 0 and b_count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for x in range ( N - K ) : <NEWLINE> <INDENT> if A [ x ] < A [ K + x ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> def is_capable ( n , k , w , P ) : <NEWLINE> <INDENT> track = 0 <NEWLINE> cnt = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while cnt < k : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if track + w [ i ] > P : <NEWLINE> <INDENT> track = 0 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> track += w [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> pass <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w . append ( int ( sys . stdin . readline ( ) . strip ( ) ) ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <NL> if k == 1 : <NEWLINE> <INDENT> ans = sum ( w ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> ans = w [ 0 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_p = sum ( w ) <NEWLINE> min_p = math . ceil ( max_p / k ) - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> capable = { min_p : False , max_p : True } <NEWLINE> <NL> <COMMENT> <NL> <NL> bottom = min_p <NEWLINE> top = max_p <NEWLINE> <NL> while bottom < top : <NEWLINE> <INDENT> mid = ( bottom + top ) // 2 <NEWLINE> <NL> if mid not in capable : <NEWLINE> <INDENT> capable [ mid ] = is_capable ( n , k , w , mid ) <NEWLINE> <NL> <DEDENT> if capable [ mid ] == True : <NEWLINE> <INDENT> if ( mid - 1 ) not in capable : <NEWLINE> <INDENT> capable [ mid - 1 ] = is_capable ( n , k , w , mid - 1 ) <NEWLINE> <NL> <DEDENT> if capable [ mid - 1 ] == False : <NEWLINE> <INDENT> ans = mid <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> top = mid <NEWLINE> <DEDENT> <DEDENT> elif capable [ mid ] == False : <NEWLINE> <INDENT> if ( mid + 1 ) not in capable : <NEWLINE> <INDENT> capable [ mid + 1 ] = is_capable ( n , k , w , mid + 1 ) <NEWLINE> <NL> <DEDENT> if capable [ mid + 1 ] == True : <NEWLINE> <INDENT> ans = mid + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bottom = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> q = set ( tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( M ) ) <NEWLINE> <NL> X = [ 0 ] * H <NEWLINE> Y = [ 0 ] * W <NEWLINE> <NL> for i , j in q : <NEWLINE> <INDENT> X [ i ] += 1 <NEWLINE> Y [ j ] += 1 <NEWLINE> <NL> <DEDENT> def my_index_multi ( l , x ) : <NEWLINE> <INDENT> return [ i for i , _x in enumerate ( l ) if _x == x ] <NEWLINE> <NL> <DEDENT> xm = max ( X ) <NEWLINE> ym = max ( Y ) <NEWLINE> xms = my_index_multi ( X , xm ) <NEWLINE> yms = my_index_multi ( Y , ym ) <NEWLINE> <NL> ans = xm + ym - 1 <NEWLINE> <NL> bl = False <NEWLINE> for i in xms : <NEWLINE> <INDENT> for j in yms : <NEWLINE> <INDENT> if not ( i , j ) in q : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> bl = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( [ - 1 , 1 ] [ a [ 0 ] == 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a [ 0 ] > 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> s = sum ( a ) <NEWLINE> ans = 1 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( s , 2 * dp [ i ] ) <NEWLINE> ans += dp [ i + 1 ] <NEWLINE> dp [ i + 1 ] -= a [ i + 1 ] <NEWLINE> s -= a [ i + 1 ] <NEWLINE> if dp [ i ] <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if dp [ - 1 ] < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> dp = [ [ 0 ] * 19 for _ in range ( 19 ) ] <NEWLINE> dq = [ [ 0 ] * 19 for _ in range ( 19 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> x = s . find ( <STRING> ) <NEWLINE> if x == - 1 : <NEWLINE> <INDENT> s = s + <STRING> * 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> ) + <STRING> * ( 10 - ( len ( s ) - x ) ) <NEWLINE> <DEDENT> s = int ( s ) <NEWLINE> d2 = 0 <NEWLINE> d5 = 0 <NEWLINE> for _ in range ( 18 ) : <NEWLINE> <INDENT> if s % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = s // 2 <NEWLINE> d2 += 1 <NEWLINE> <DEDENT> for _ in range ( 18 ) : <NEWLINE> <INDENT> if s % 5 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = s // 5 <NEWLINE> d5 += 1 <NEWLINE> <DEDENT> dp [ d2 ] [ d5 ] += 1 <NEWLINE> dq [ d2 ] [ d5 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 18 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 18 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j - 1 ] += dp [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( 18 , - 1 , - 1 ) : <NEWLINE> <INDENT> for i in range ( 18 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i - 1 ] [ j ] += dp [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for i in range ( 19 ) : <NEWLINE> <INDENT> for j in range ( 19 ) : <NEWLINE> <INDENT> if dq [ i ] [ j ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret += dq [ i ] [ j ] * dp [ 18 - i ] [ 18 - j ] <NEWLINE> <DEDENT> <DEDENT> ret -= dp [ 9 ] [ 9 ] <NEWLINE> print ( ret // 2 ) <NEWLINE>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x_i = x - i <NEWLINE> x_j = x + i <NEWLINE> <NL> if x_i not in p_list : <NEWLINE> <INDENT> print ( x_i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x_j not in p_list : <NEWLINE> <INDENT> print ( x_j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B - 1 : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> c = ( A * x ) // B - A * ( x // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> c = ( A * x ) // B - A * ( x // B ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> dp = [ ] <NEWLINE> for y in range ( len ( Y ) ) : <NEWLINE> <INDENT> now = 0 <NEWLINE> for i in range ( len ( dp ) ) : <NEWLINE> <INDENT> d = dp [ i ] <NEWLINE> if Y [ y ] in X [ now : d ] : <NEWLINE> <INDENT> dp [ i ] = now + X [ now : d ] . index ( Y [ y ] ) <NEWLINE> <DEDENT> now = d + 1 <NEWLINE> <DEDENT> if Y [ y ] in X [ now : ] : <NEWLINE> <INDENT> dp . append ( now + X [ now : ] . index ( Y [ y ] ) ) <NEWLINE> <DEDENT> <DEDENT> return len ( dp ) <NEWLINE> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <NL> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * m ] <NEWLINE> g = [ [ ] for _ in [ 0 ] * n ] <NEWLINE> [ g [ a - 1 ] . append ( b - 1 ) for a , b in ab ] <NEWLINE> [ g [ b - 1 ] . append ( a - 1 ) for a , b in ab ] <NEWLINE> <NL> import heapq <NEWLINE> h = [ ( 0 , 0 ) ] <NEWLINE> heapq . heapify ( h ) <NEWLINE> d = [ 10 ** 10 ] * n <NEWLINE> while h : <NEWLINE> <INDENT> dis , i = heapq . heappop ( h ) <NEWLINE> if d [ i ] == 10 ** 10 : <NEWLINE> <INDENT> d [ i ] = dis <NEWLINE> for j in g [ i ] : <NEWLINE> <INDENT> if d [ j ] == 10 ** 10 : <NEWLINE> <INDENT> heapq . heappush ( h , ( dis + 1 , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> minimum = 10 ** 9 <NEWLINE> dire = None <NEWLINE> for j in g [ i ] : <NEWLINE> <INDENT> if d [ j ] < minimum : <NEWLINE> <INDENT> minimum = d [ j ] <NEWLINE> dire = j <NEWLINE> <DEDENT> <DEDENT> print ( dire + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ [ 0 for i in range ( 4 ) ] for j in range ( Q ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> inputS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S [ i ] [ 0 ] = inputS [ 0 ] <NEWLINE> S [ i ] [ 1 ] = inputS [ 1 ] <NEWLINE> S [ i ] [ 2 ] = inputS [ 2 ] <NEWLINE> S [ i ] [ 3 ] = inputS [ 3 ] <NEWLINE> <DEDENT> S2 = [ ] <NEWLINE> maxNum = 0 <NEWLINE> for a in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for b in range ( a , M + 1 ) : <NEWLINE> <INDENT> for c in range ( b , M + 1 ) : <NEWLINE> <INDENT> for d in range ( c , M + 1 ) : <NEWLINE> <INDENT> for e in range ( d , M + 1 ) : <NEWLINE> <INDENT> for f in range ( e , M + 1 ) : <NEWLINE> <INDENT> for g in range ( f , M + 1 ) : <NEWLINE> <INDENT> for h in range ( g , M + 1 ) : <NEWLINE> <INDENT> for i in range ( h , M + 1 ) : <NEWLINE> <INDENT> for j in range ( i , M + 1 ) : <NEWLINE> <INDENT> S2 = [ a , b , c , d , e , f , g , h , i , j ] <NEWLINE> count = 0 <NEWLINE> for k in range ( Q ) : <NEWLINE> <INDENT> if S2 [ S [ k ] [ 1 ] - 1 ] - S2 [ S [ k ] [ 0 ] - 1 ] == S [ k ] [ 2 ] : <NEWLINE> <INDENT> count += S [ k ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> maxNum = max ( maxNum , count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( maxNum ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : break <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : print ( <STRING> * w ) <NEWLINE> else : print ( <STRING> + ( <STRING> * ( w - 2 ) ) + <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d [ i ] = [ ] <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d [ A ] . append ( B ) <NEWLINE> d [ B ] . append ( A ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in d [ i ] : <NEWLINE> <INDENT> if H [ j - 1 ] >= H [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> n = int ( input ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> l = [ INF ] * n <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> for i in a [ : : - 1 ] : <NEWLINE> <INDENT> l [ bisect_right ( l , i ) ] = i <NEWLINE> <DEDENT> print ( bisect_left ( l , INF ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : break <NEWLINE> for i in range ( h ) : print ( ( <STRING> * w ) [ i % 2 : ] [ : w ] ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> <NL> <COMMENT> <NL> element = set ( A [ 0 ] + A [ 1 ] ) <NEWLINE> if len ( element ) == 1 : <NEWLINE> <INDENT> print ( list ( element ) [ 0 ] * ( N + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 0 <NEWLINE> for d in range ( N ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> sum_num = A [ 0 ] [ 0 ] + sum ( A [ 1 ] ) <NEWLINE> <DEDENT> elif d == N - 1 : <NEWLINE> <INDENT> sum_num = sum ( A [ 0 ] ) + A [ 1 ] [ N - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_num = sum ( A [ 0 ] [ : d + 1 ] ) + sum ( A [ 1 ] [ d : ] ) <NEWLINE> <DEDENT> if res < sum_num : <NEWLINE> <INDENT> res = sum_num <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N , * S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> C = collections . Counter ( S ) <NEWLINE> <NL> i = C . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> print ( * sorted ( [ k for k , v in C . most_common ( ) if v == i ] ) , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def euc ( n , m ) : <NEWLINE> <INDENT> if max ( n , m ) % min ( n , m ) == 0 : <NEWLINE> <INDENT> return min ( n , m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return euc ( min ( n , m ) , max ( n , m ) % min ( n , m ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in line . split ( ) ] <NEWLINE> print ( euc ( a , b ) , int ( a * b / euc ( a , b ) ) ) <NEWLINE> <NL> <DEDENT>
def palindrome ( S ) : <NEWLINE> <INDENT> for i in range ( len ( S ) // 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ i ] != S [ - ( i + 1 ) ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> S = input ( ) <NEWLINE> S1 = S [ : ( len ( S ) - 1 ) // 2 ] <NEWLINE> S2 = S [ ( len ( S ) + 1 ) // 2 : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if palindrome ( S ) == 1 : <NEWLINE> <INDENT> if palindrome ( S1 ) == 1 : <NEWLINE> <INDENT> if palindrome ( S2 ) == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
 = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n += k <NEWLINE> if n >= a and n <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if n > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> prev = [ - 1 ] * n <NEWLINE> visited = [ False ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def bfs ( v ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> visited [ v ] = True <NEWLINE> q . append ( v ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for child in edges [ v ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> visited [ child ] = True <NEWLINE> prev [ child ] = v <NEWLINE> q . append ( child ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( prev [ i ] + 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> l . append ( i + j ) <NEWLINE> r . append ( i - j ) <NEWLINE> <NL> <DEDENT> b = Counter ( r ) <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += b . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> cnt = { } <NEWLINE> cnt [ <STRING> ] = 0 <NEWLINE> cnt [ <STRING> ] = 0 <NEWLINE> cnt [ <STRING> ] = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> ans = cnt [ <STRING> ] * cnt [ <STRING> ] * cnt [ <STRING> ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for gap in range ( 1 , ( n - i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + gap ] and s [ i + 2 * gap ] != s [ i + gap ] and s [ i + 2 * gap ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> a = set ( s ) <NEWLINE> print ( len ( a ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> import bisect <NEWLINE> n = i_input ( ) <NEWLINE> l = sorted ( i_list ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( n - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> ans += bisect . bisect ( l , l [ a ] + l [ b ] - 1 ) - b - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prime = list ( range ( max ( A ) + 1 ) ) <NEWLINE> <NL> for i in range ( 2 , len ( prime ) ) : <NEWLINE> <INDENT> if prime [ i ] != i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i , len ( prime ) , i ) : <NEWLINE> <INDENT> if prime [ j ] != j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prime [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> used = set ( ) <NEWLINE> pc = True <NEWLINE> for a in A : <NEWLINE> <INDENT> used_this = set ( ) <NEWLINE> while a != 1 : <NEWLINE> <INDENT> div = prime [ a ] <NEWLINE> if div in used : <NEWLINE> <INDENT> pc = False <NEWLINE> break <NEWLINE> <DEDENT> used_this . add ( div ) <NEWLINE> a //= div <NEWLINE> <DEDENT> used . update ( used_this ) <NEWLINE> <NL> <DEDENT> if pc : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> buf = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> buf = gcd ( buf , a ) <NEWLINE> <DEDENT> if buf == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = int ( l [ 0 ] ) <NEWLINE> K = int ( l [ 1 ] ) <NEWLINE> D = int ( l [ 2 ] ) <NEWLINE> <NL> if D * K <= abs ( X ) : <NEWLINE> <INDENT> minVal = abs ( X ) - D * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = math . floor ( abs ( X ) / D ) + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if ( K - n ) % 2 == 0 : <NEWLINE> <INDENT> minVal = abs ( abs ( X ) - D * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minVal = abs ( abs ( X ) - D * ( n - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minVal ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> result_score = 0 <NEWLINE> for score , i in [ ( 1 , A ) , ( 0 , B ) , ( - 1 , C ) ] : <NEWLINE> <INDENT> if K <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if K >= i : <NEWLINE> <INDENT> result_score += score * i <NEWLINE> K -= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result_score += score * K <NEWLINE> K = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result_score ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> a = a * i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def get_result ( data ) : <NEWLINE> <INDENT> A = sorted ( data [ 1 ] ) <NEWLINE> ans = 1 <NEWLINE> for val in A : <NEWLINE> <INDENT> ans = ans * val <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> raw_data = [ val . rstrip ( ) for val in stdin . readlines ( ) ] <NEWLINE> data = [ list ( map ( int , val . split ( <STRING> ) ) ) for val in raw_data ] <NEWLINE> result = get_result ( data ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> sv = 7 <NEWLINE> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if sv % k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sv = ( sv * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> f = False <NEWLINE> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> answer = answer * A [ i ] <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ls = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> for j in range ( int ( tmp [ 1 ] ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> ls [ i ] [ int ( tmp [ j + 2 ] ) - 1 ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( j != n - 1 ) : <NEWLINE> <INDENT> print ( int ( ls [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ls [ i ] [ j ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> nums = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if nums [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> ans *= nums [ k ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = lambda x : x * ( x - 1 ) // 2 <NEWLINE> s = 0 <NEWLINE> D = Counter ( A ) <NEWLINE> for i , j in D . items ( ) : <NEWLINE> <INDENT> s += C ( j ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> print ( s - D [ i ] + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ab = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = math . gcd ( a , b ) <NEWLINE> a //= gcd <NEWLINE> b //= gcd <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> <DEDENT> num = ( a , b ) <NEWLINE> ab . setdefault ( num , 0 ) <NEWLINE> ab [ num ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if ( 0 , 0 ) in ab . keys ( ) : <NEWLINE> <INDENT> temp2 = ab [ ( 0 , 0 ) ] <NEWLINE> ans += temp2 <NEWLINE> n -= temp2 <NEWLINE> <DEDENT> s = set ( ab . keys ( ) ) <NEWLINE> pairs = [ ] <NEWLINE> for i in ab . keys ( ) : <NEWLINE> <INDENT> if i == ( 0 , 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = i [ 0 ] , i [ 1 ] <NEWLINE> if ( - b , a ) in s : <NEWLINE> <INDENT> pairs . append ( [ ab [ ( a , b ) ] , ab [ ( - b , a ) ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> temp3 = 1 <NEWLINE> for i in range ( len ( pairs ) ) : <NEWLINE> <INDENT> num2 = pairs [ i ] [ 0 ] <NEWLINE> num3 = pairs [ i ] [ 1 ] <NEWLINE> temp3 *= ( pow ( 2 , num2 , mod ) + pow ( 2 , num3 , mod ) - 1 ) <NEWLINE> n = n - num2 - num3 <NEWLINE> temp3 %= mod <NEWLINE> <DEDENT> temp3 *= pow ( 2 , n , mod ) <NEWLINE> temp3 -= 1 <NEWLINE> temp3 %= mod <NEWLINE> ans += temp3 <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> x = math . gcd ( A , B ) <NEWLINE> <NL> def prime_decomposition ( x ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> ls = [ ] <NEWLINE> while i * i <= x : <NEWLINE> <INDENT> while x % i == 0 : <NEWLINE> <INDENT> x /= i <NEWLINE> ls . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if x > 1 : <NEWLINE> <INDENT> ls . append ( x ) <NEWLINE> <DEDENT> return ls <NEWLINE> <NL> <DEDENT> cnt = len ( set ( prime_decomposition ( x ) ) ) <NEWLINE> <NL> print ( cnt + 1 ) <NEWLINE>
input ( ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list1 . reverse ( ) <NEWLINE> result = <STRING> <NEWLINE> for i in range ( 0 , len ( list1 ) ) : <NEWLINE> <INDENT> result += str ( list1 [ i ] ) <NEWLINE> if len ( list1 ) - 1 == i : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
p = 2019 <NEWLINE> s = [ int ( i ) for i in input ( ) ] <NEWLINE> p_cnt = 0 <NEWLINE> <NL> s = s [ : : - 1 ] <NEWLINE> div_dic = dict ( zip ( range ( p ) , [ 0 ] * p ) ) <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> tmp += s [ i ] * pow ( 10 , i , p ) <NEWLINE> tmp %= p <NEWLINE> div_dic [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> for v in div_dic . values ( ) : <NEWLINE> <INDENT> p_cnt += v * ( v - 1 ) <NEWLINE> <DEDENT> p_cnt //= 2 <NEWLINE> p_cnt += div_dic . get ( 0 ) <NEWLINE> <NL> print ( p_cnt ) <NEWLINE>
s1 = input ( ) <NEWLINE> s2 = input ( ) <NEWLINE> s1_len = len ( s1 ) <NEWLINE> s2_len = len ( s2 ) <NEWLINE> dp = [ [ i if j == 0 else j if i == 0 else None for j in range ( s2_len + 1 ) ] for i in range ( s1_len + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , s1_len + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , s2_len + 1 ) : <NEWLINE> <INDENT> n1 = dp [ i - 1 ] [ j - 1 ] if s1 [ i - 1 ] == s2 [ j - 1 ] else dp [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> n2 = dp [ i - 1 ] [ j ] + 1 <NEWLINE> n3 = dp [ i ] [ j - 1 ] + 1 <NEWLINE> dp [ i ] [ j ] = min ( n1 , n2 , n3 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ s1_len ] [ s2_len ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for num , i in enumerate ( range ( k , n ) ) : <NEWLINE> <INDENT> if a [ num ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin , stdout <NEWLINE> <NL> <NL> def solve ( S , N ) : <NEWLINE> <INDENT> color = [ [ ] for _ in range ( 3 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : color [ 0 ] . append ( i ) <NEWLINE> elif S [ i ] == <STRING> : color [ 1 ] . append ( i ) <NEWLINE> else : color [ 2 ] . append ( i ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> total = len ( color [ 0 ] ) * len ( color [ 1 ] ) * len ( color [ 2 ] ) <NEWLINE> <NL> remain = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : break <NEWLINE> <NL> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> remain += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return total - remain <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> S = stdin . readline ( ) . rstrip ( ) <NEWLINE> stdout . write ( str ( solve ( S , N ) ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> X = [ [ ] for _ in range ( 200005 ) ] <NEWLINE> Y = [ [ ] for _ in range ( 200005 ) ] <NEWLINE> A = [ [ ] for _ in range ( 200005 * 2 + 1 ) ] <NEWLINE> B = [ [ ] for _ in range ( 200005 * 2 + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , y , u = sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> X [ x ] . append ( ( y , u ) ) <COMMENT> <NEWLINE> Y [ y ] . append ( ( x , u ) ) <NEWLINE> A [ x + y ] . append ( ( x , u ) ) <NEWLINE> B [ x - y + 200005 ] . append ( ( x , u ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> length = 10000000 <NEWLINE> for xs in X : <NEWLINE> <INDENT> if len ( xs ) >= 2 : <NEWLINE> <INDENT> xs . sort ( ) <NEWLINE> <NL> is_count = False <NEWLINE> tmp_y = 0 <NEWLINE> for y , u in xs : <NEWLINE> <INDENT> if is_count and u == <STRING> : <NEWLINE> <INDENT> length = min ( abs ( y - tmp_y ) * 5 , length ) <NEWLINE> is_count = False <NEWLINE> <DEDENT> if u == <STRING> : <NEWLINE> <INDENT> tmp_y = y <NEWLINE> is_count = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for xs in Y : <NEWLINE> <INDENT> if len ( xs ) >= 2 : <NEWLINE> <INDENT> xs . sort ( ) <NEWLINE> <NL> is_count = False <NEWLINE> tmp_y = 0 <NEWLINE> for y , u in xs : <NEWLINE> <INDENT> if is_count and u == <STRING> : <NEWLINE> <INDENT> length = min ( abs ( y - tmp_y ) * 5 , length ) <NEWLINE> is_count = False <NEWLINE> <DEDENT> if u == <STRING> : <NEWLINE> <INDENT> tmp_y = y <NEWLINE> is_count = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for xs in A : <NEWLINE> <INDENT> if len ( xs ) >= 2 : <NEWLINE> <INDENT> xs . sort ( ) <NEWLINE> <NL> is_count = False <NEWLINE> tmp_y = 0 <NEWLINE> for y , u in xs : <NEWLINE> <INDENT> if is_count and u == <STRING> : <NEWLINE> <INDENT> length = min ( abs ( y - tmp_y ) * 10 , length ) <NEWLINE> is_count = False <NEWLINE> <DEDENT> if u == <STRING> : <NEWLINE> <INDENT> tmp_y = y <NEWLINE> is_count = True <NEWLINE> <NL> <DEDENT> <DEDENT> is_count = False <NEWLINE> tmp_y = 0 <NEWLINE> for y , u in xs : <NEWLINE> <INDENT> if is_count and u == <STRING> : <NEWLINE> <INDENT> length = min ( abs ( y - tmp_y ) * 10 , length ) <NEWLINE> is_count = False <NEWLINE> <DEDENT> if u == <STRING> : <NEWLINE> <INDENT> tmp_y = y <NEWLINE> is_count = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for xs in B : <NEWLINE> <INDENT> if len ( xs ) >= 2 : <NEWLINE> <INDENT> xs . sort ( ) <NEWLINE> <NL> is_count = False <NEWLINE> tmp_y = 0 <NEWLINE> for y , u in xs : <NEWLINE> <INDENT> if is_count and u == <STRING> : <NEWLINE> <INDENT> length = min ( abs ( y - tmp_y ) * 10 , length ) <NEWLINE> is_count = False <NEWLINE> <DEDENT> if u == <STRING> : <NEWLINE> <INDENT> tmp_y = y <NEWLINE> is_count = True <NEWLINE> <NL> <DEDENT> <DEDENT> is_count = False <NEWLINE> tmp_y = 0 <NEWLINE> for y , u in xs : <NEWLINE> <INDENT> if is_count and u == <STRING> : <NEWLINE> <INDENT> length = min ( abs ( y - tmp_y ) * 10 , length ) <NEWLINE> is_count = False <NEWLINE> <DEDENT> if u == <STRING> : <NEWLINE> <INDENT> tmp_y = y <NEWLINE> is_count = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if length == 10000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( length ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if ( a == 0 ) : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a // gcd ( a , b ) * b <NEWLINE> <DEDENT> t = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> while ( t != 0 ) : <NEWLINE> <INDENT> t -= 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = lcm ( ans , n ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> <STRING> <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> S [ i ] = int ( S [ i ] ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> mergeSort ( S , 0 , n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <COMMENT> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . a = [ - 1 ] * n <NEWLINE> self . siz = n <NEWLINE> <DEDENT> def root_find ( self , x ) : <NEWLINE> <INDENT> if self . a [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . a [ x ] = self . root_find ( self . a [ x ] ) <NEWLINE> return self . a [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root_find ( x ) <NEWLINE> y = self . root_find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif self . a [ x ] < self . a [ y ] : <NEWLINE> <INDENT> self . a [ x ] += self . a [ y ] <NEWLINE> self . a [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . a [ y ] += self . a [ x ] <NEWLINE> self . a [ x ] = y <NEWLINE> <DEDENT> self . siz -= 1 <NEWLINE> <DEDENT> def root_same ( self , x , y ) : <NEWLINE> <INDENT> return self . root_find ( x ) == self . root_find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> u = UnionFind ( n ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> u . unite ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( u . root_same ( a , b ) + 0 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> r0 = int ( input ( ) ) <NEWLINE> r1 = int ( input ( ) ) <NEWLINE> mx = r1 - r0 <NEWLINE> mn = min ( r1 , r0 ) <NEWLINE> <NL> for i in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> if mx < i - mn : <NEWLINE> <INDENT> mx = i - mn <NEWLINE> <DEDENT> if mn > i : <NEWLINE> <INDENT> mn = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
li = input ( ) . split ( ) <NEWLINE> <NL> if li [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( li [ 0 ] ) + int ( li [ 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( li [ 0 ] ) - int ( li [ 2 ] ) ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> <NL> h = S // 3600 <NEWLINE> m = ( S % 3600 ) // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> t = 1 <NEWLINE> for t in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> total = t * ( t + 1 ) / 2 <NEWLINE> if total >= X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dict_ichi = { } <NEWLINE> dict_H = { key : 0 for key in range ( 1 , H + 1 , 1 ) } <NEWLINE> dict_W = { key : 0 for key in range ( 1 , W + 1 , 1 ) } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> dict_H [ h ] += 1 <NEWLINE> dict_W [ w ] += 1 <NEWLINE> dict_ichi [ ( h , w ) ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> maxH = max ( dict_H . values ( ) ) <NEWLINE> maxW = max ( dict_W . values ( ) ) <NEWLINE> wi = [ i for i in range ( 1 , W + 1 , 1 ) if dict_W [ i ] == maxW ] <NEWLINE> <COMMENT> <NL> for h in [ i for i in range ( 1 , H + 1 , 1 ) if dict_H [ i ] == maxH ] : <NEWLINE> <INDENT> for w in wi : <NEWLINE> <INDENT> if ( h , w ) not in dict_ichi : <NEWLINE> <INDENT> return maxH + maxW <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return maxH + maxW - 1 <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import itertools <NEWLINE> import decimal <NEWLINE> import math <NEWLINE> import collections <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def iskaijo ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( n == 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( n % i == 0 ) : <NEWLINE> <INDENT> n = n / i <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> <NL> ng = False <NEWLINE> ans = 0 <NEWLINE> List = factorization ( N ) <NEWLINE> <COMMENT> <NL> for i in range ( len ( List ) ) : <NEWLINE> <INDENT> test = List [ i ] [ 1 ] <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> test = test - i <NEWLINE> i = i + 1 <NEWLINE> ans = ans + 1 <NEWLINE> if ( test == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( test < 0 ) : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if N != 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
def cut ( cake , s ) : <NEWLINE> <INDENT> ret_cake = [ ( - 1 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> w = cake [ 2 ] <NEWLINE> h = cake [ 1 ] <NEWLINE> <NL> s %= 2 * ( w + h ) <NEWLINE> <NL> if w > s : <NEWLINE> <INDENT> ret_cake = [ ( h , s ) , ( h , w - s ) ] <NEWLINE> <DEDENT> elif w + h > s : <NEWLINE> <INDENT> ret_cake = [ ( s - w , w ) , ( w + h - s , w ) ] <NEWLINE> <DEDENT> elif 2 * w + h > s : <NEWLINE> <INDENT> ret_cake = [ ( h , s - w - h ) , ( h , 2 * w + h - s ) ] <NEWLINE> <DEDENT> elif 2 * w + 2 * h > s : <NEWLINE> <INDENT> ret_cake = [ ( s - 2 * w - h , w ) , ( 2 * w + 2 * h - s , w ) ] <NEWLINE> <NL> <DEDENT> ret_cake = [ ( c [ 0 ] * c [ 1 ] , c [ 0 ] , c [ 1 ] ) for c in ret_cake ] <NEWLINE> ret_cake . sort ( ) <NEWLINE> return ret_cake <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and w == 0 and d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ 0 ] * n <NEWLINE> s = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p [ i ] , s [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> cake = [ ( w * d , d , w ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cake = cake [ : p [ i ] - 1 ] + cake [ p [ i ] : ] + cut ( cake [ p [ i ] - 1 ] , s [ i ] ) <NEWLINE> <DEDENT> cake . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( str , [ c [ 0 ] for c in cake ] ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = 2 <NEWLINE> l2 = 1 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( l2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> l = l + l2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 = l + l2 <NEWLINE> <NL> <DEDENT> <DEDENT> if i % 2 == 1 : <NEWLINE> <INDENT> print ( l2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> n = len ( S ) <NEWLINE> <NL> medalist = [ 0 ] * 2019 <NEWLINE> medalist [ 0 ] = 1 <NEWLINE> num = 0 <NEWLINE> mods = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> fig = int ( S [ n - i - 1 ] ) <NEWLINE> num = ( num + fig * mods ) % 2019 <NEWLINE> medalist [ num ] = medalist [ num ] + 1 <NEWLINE> mods = ( mods * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> <NL> for i in range ( 2019 ) : <NEWLINE> <INDENT> m = medalist [ i ] <NEWLINE> if m != 0 : <NEWLINE> <INDENT> result += m * ( m - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a_s = input ( ) . split ( <STRING> ) <NEWLINE> a_s = list ( map ( int , a_s ) ) <NEWLINE> asum = sum ( a_s ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a_s ) - 1 ) : <NEWLINE> <INDENT> asum -= a_s [ i ] <NEWLINE> ans += ( asum * a_s [ i ] ) % mod <NEWLINE> if ans > mod : <NEWLINE> <INDENT> ans = ans % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import math <NEWLINE> <NL> f_i = sys . stdin <NEWLINE> <NL> n , q = map ( int , f_i . readline ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> n = 2 ** math . ceil ( math . log ( n , 2 ) ) <NEWLINE> <NL> A = [ 0 for i in range ( 2 * n - 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> def add ( i , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> i += n - 2 <NEWLINE> A [ i ] += x <NEWLINE> <NL> while i > 0 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> A [ i ] += x <NEWLINE> <NL> <DEDENT> <DEDENT> def getSum ( s , t , k , l , r ) : <NEWLINE> <INDENT> if r < s or t < l : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif s <= l and r <= t : <NEWLINE> <INDENT> return A [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> lsum = getSum ( s , t , k * 2 + 1 , l , mid ) <NEWLINE> rsum = getSum ( s , t , k * 2 + 2 , mid + 1 , r ) <NEWLINE> return lsum + rsum <NEWLINE> <NL> <DEDENT> <DEDENT> for s_i in f_i : <NEWLINE> <INDENT> com , x , y = map ( int , s_i . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> add ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = getSum ( x , y , 0 , 1 , n ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ( ans > x ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a = a * ( n + 1 ) % mod <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
S = input ( ) <NEWLINE> lmax = len ( S ) <NEWLINE> modulo = list ( [ 0 ] * 2019 ) <NEWLINE> mod10 = 10 % 2019 <NEWLINE> mod = int ( S [ - 1 ] ) % 2019 <NEWLINE> modulo [ mod ] += 1 <NEWLINE> for s in reversed ( S [ : - 1 ] ) : <NEWLINE> <INDENT> mod = ( mod + mod10 * int ( s ) ) % 2019 <NEWLINE> modulo [ mod ] += 1 <NEWLINE> mod10 = ( mod10 * 10 ) % 2019 <NEWLINE> <DEDENT> ans = sum ( list ( map ( lambda x : x * ( x - 1 ) // 2 , modulo ) ) ) + modulo [ 0 ] <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ANS = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ANS *= A [ i ] <NEWLINE> if ANS > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ANS ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> req = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> count = [ 0 ] * 100001 <NEWLINE> sum = sum ( a ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <NL> <DEDENT> for k in range ( q ) : <NEWLINE> <INDENT> sum += ( req [ k ] [ 1 ] - req [ k ] [ 0 ] ) * count [ req [ k ] [ 0 ] ] <NEWLINE> count [ req [ k ] [ 1 ] ] += count [ req [ k ] [ 0 ] ] <NEWLINE> count [ req [ k ] [ 0 ] ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
<NL> class Chess_board : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . board = [ [ 0 ] * 8 for i in range ( 8 ) ] <NEWLINE> self . queen_array = [ ] <NEWLINE> self . queen_row = [ ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def copy_board ( chess_board ) : <NEWLINE> <INDENT> new_board = Chess_board ( ) <NEWLINE> new_board . board = [ chess_board . board [ i ] [ : ] for i in range ( 8 ) ] <NEWLINE> new_board . queen_array = chess_board . queen_array [ : ] <NEWLINE> new_board . queen_row = chess_board . queen_row [ : ] <NEWLINE> return new_board <NEWLINE> <NL> <NL> <DEDENT> def mk_board ( chess_board , queen_array ) : <NEWLINE> <INDENT> for queen in queen_array : <NEWLINE> <INDENT> row = queen [ 0 ] <NEWLINE> col = queen [ 1 ] <NEWLINE> if ( chess_board . board [ row ] [ col ] == 0 ) : <NEWLINE> <INDENT> chess_board . queen_array . append ( queen ) <NEWLINE> chess_board . queen_row . append ( row ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> chess_board . board [ row ] [ i ] = 1 <NEWLINE> <DEDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> chess_board . board [ i ] [ col ] = 1 <NEWLINE> <DEDENT> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> if ( row - i >= 0 and col - i >= 0 ) : <NEWLINE> <INDENT> chess_board . board [ row - i ] [ col - i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> if ( 8 > row + i >= 0 and col - i >= 0 ) : <NEWLINE> <INDENT> chess_board . board [ row + i ] [ col - i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> if ( row - i >= 0 and 8 > col + i >= 0 ) : <NEWLINE> <INDENT> chess_board . board [ row - i ] [ col + i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> if ( 8 > row + i >= 0 and 8 > col + i >= 0 ) : <NEWLINE> <INDENT> chess_board . board [ row + i ] [ col + i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> def find_queen ( chess_board ) : <NEWLINE> <NL> <INDENT> for tmp_row in range ( 8 ) : <NEWLINE> <INDENT> if ( tmp_row in chess_board . queen_row ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for col in range ( 8 ) : <NEWLINE> <INDENT> new_board = copy_board ( chess_board ) <NEWLINE> if ( mk_board ( new_board , [ [ tmp_row , col ] ] ) == 1 ) : <NEWLINE> <INDENT> if ( len ( new_board . queen_row ) == 8 ) : <NEWLINE> <INDENT> return new_board <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = find_queen ( new_board ) <NEWLINE> if ( result is not None ) : <NEWLINE> <INDENT> return result <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> queen_array = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> queen_array . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> board = Chess_board ( ) <NEWLINE> mk_board ( board , queen_array ) <NEWLINE> if ( n != 8 ) : <NEWLINE> <INDENT> result_board = find_queen ( board ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result_board = board <NEWLINE> <NL> <DEDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> for queen in result_board . queen_array : <NEWLINE> <INDENT> if ( queen [ 0 ] == i ) : <NEWLINE> <INDENT> str1 = <STRING> * queen [ 1 ] <NEWLINE> str2 = <STRING> * ( 7 - queen [ 1 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> nums = [ 1000 for i in range ( 26 ) ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> nums [ i ] = min ( nums [ i ] , s [ j ] . count ( ( chr ) ( 97 + i ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> while nums [ i ] > 0 : <NEWLINE> <INDENT> print ( ( chr ) ( 97 + i ) , end = <STRING> ) <NEWLINE> nums [ i ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 if 0 not in a else 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> def getGreatestCommonDivisor ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return getGreatestCommonDivisor ( y , x % y ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> fishes = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> fishes . append ( [ int ( s ) for s in input ( ) . split ( ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> slopeCount = collections . defaultdict ( int ) <NEWLINE> for x , y in fishes : <NEWLINE> <INDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> y = 1 <NEWLINE> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> x = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcl = getGreatestCommonDivisor ( abs ( x ) , abs ( y ) ) <NEWLINE> x //= gcl <NEWLINE> y //= gcl <NEWLINE> <DEDENT> if x < 0 : <NEWLINE> <INDENT> x = - x <NEWLINE> y = - y <NEWLINE> <DEDENT> slopeCount [ ( x , y ) ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> reversedPairs = dict ( ) <NEWLINE> independentCount = 0 <NEWLINE> zeroCount = 0 <NEWLINE> for slope , count in slopeCount . items ( ) : <NEWLINE> <INDENT> x , y = slope <NEWLINE> if ( x , y ) == ( 0 , 0 ) : <NEWLINE> <INDENT> zeroCount += count <NEWLINE> continue <NEWLINE> <DEDENT> if x == 0 : <NEWLINE> <INDENT> rx , ry = 1 , 0 <NEWLINE> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> rx , ry = 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rx , ry = ( y , - x ) if y >= 0 else ( - y , x ) <NEWLINE> <DEDENT> if ( x , y ) in reversedPairs or ( rx , ry ) in reversedPairs : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( rx , ry ) not in slopeCount : <NEWLINE> <INDENT> independentCount += count <NEWLINE> continue <NEWLINE> <DEDENT> reversedPairs [ ( x , y ) ] = ( count , slopeCount [ ( rx , ry ) ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> M = 1000000007 <NEWLINE> def subsetNum ( count ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> for _ in range ( count ) : <NEWLINE> <INDENT> r *= 2 <NEWLINE> r %= M <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> result = subsetNum ( independentCount ) <NEWLINE> for c1 , c2 in reversedPairs . values ( ) : <NEWLINE> <INDENT> result *= ( subsetNum ( c1 ) - 1 + subsetNum ( c2 ) - 1 + 1 ) <NEWLINE> result %= M <NEWLINE> <DEDENT> if zeroCount > 0 : <NEWLINE> <INDENT> result += zeroCount <NEWLINE> <DEDENT> result -= 1 <NEWLINE> result %= M <NEWLINE> print ( result ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m , a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n + m + a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> lines = list ( sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] ) ) <NEWLINE> <NL> replace = list ( range ( 1 , n + 1 ) ) <NEWLINE> <NL> for l in lines : <NEWLINE> <NL> <INDENT> _ , p , q = l <NEWLINE> <NL> p -= 1 <NEWLINE> q -= 1 <NEWLINE> <NL> replace [ p ] , replace [ q ] = replace [ q ] , replace [ p ] <NEWLINE> <NL> <DEDENT> print ( replace [ a - 1 ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> class MF_graph ( object ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . g = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> self . pos = [ ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , frm , to , cap ) : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> self . pos . append ( ( frm , len ( self . g [ frm ] ) ) ) <NEWLINE> self . g [ frm ] . append ( [ to , len ( self . g [ to ] ) , cap ] ) <NEWLINE> self . g [ to ] . append ( [ frm , len ( self . g [ frm ] ) - 1 , 0 ] ) <NEWLINE> return m <NEWLINE> <NL> <DEDENT> def get_edge ( self , i ) : <NEWLINE> <INDENT> e_to , e_rev , e_cap = self . g [ self . pos [ i ] [ 0 ] ] [ self . pos [ i ] [ 1 ] ] <NEWLINE> re_to , _ , re_cap = self . g [ e_to ] [ e_rev ] <NEWLINE> <COMMENT> <NL> return ( re_to , e_to , e_cap + re_cap , re_cap ) <NEWLINE> <NL> <DEDENT> def edges ( self ) : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> yield self . get_edge ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def change_edge ( self , i , new_cap , new_flow ) : <NEWLINE> <INDENT> f , s = self . pos [ i ] <NEWLINE> rf , rs , _ = self . g [ f ] [ s ] <NEWLINE> self . g [ f ] [ s ] [ 2 ] = new_cap - new_flow <NEWLINE> self . g [ rf ] [ rs ] [ 2 ] = new_flow <NEWLINE> return <NEWLINE> <NL> <DEDENT> def dfs ( self , s , v , up ) : <NEWLINE> <INDENT> if v == s : <NEWLINE> <INDENT> return up <NEWLINE> <DEDENT> res = 0 <NEWLINE> level_v = self . level [ v ] <NEWLINE> for i in range ( self . iter [ v ] , len ( self . g [ v ] ) ) : <NEWLINE> <INDENT> u_to , u_rev , _ = self . g [ v ] [ i ] <NEWLINE> if level_v <= self . level [ u_to ] or self . g [ u_to ] [ u_rev ] [ 2 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d = self . dfs ( s , u_to , min ( up - res , self . g [ u_to ] [ u_rev ] [ 2 ] ) ) <NEWLINE> if d <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> self . g [ v ] [ i ] [ 2 ] += d <NEWLINE> self . g [ u_to ] [ u_rev ] [ 2 ] -= d <NEWLINE> res += d <NEWLINE> if res == up : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def flow ( self , s , t , flow_limit = 10 ** 18 ) : <NEWLINE> <INDENT> self . iter = [ 0 ] * self . n <NEWLINE> <NL> flow = 0 <NEWLINE> while flow < flow_limit : <NEWLINE> <INDENT> self . level = [ - 1 ] * self . n <NEWLINE> self . level [ s ] = 0 <NEWLINE> que = deque ( [ s ] ) <NEWLINE> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> for u_to , _ , u_cap in self . g [ v ] : <NEWLINE> <INDENT> if u_cap == 0 or self . level [ u_to ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> self . level [ u_to ] = self . level [ v ] + 1 <NEWLINE> if u_to == t : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> que . append ( u_to ) <NEWLINE> <NL> <DEDENT> <DEDENT> if self . level [ t ] == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . iter = [ 0 ] * self . n <NEWLINE> while flow < flow_limit : <NEWLINE> <INDENT> f = self . dfs ( s , t , flow_limit - flow ) <NEWLINE> if not f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flow += f <NEWLINE> <DEDENT> <DEDENT> return flow <NEWLINE> <NL> <DEDENT> def min_cut ( self , s ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> que = deque ( [ s ] ) <NEWLINE> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> visited [ v ] = True <NEWLINE> for u_to , _ , u_cap in self . g [ v ] : <NEWLINE> <INDENT> if u_cap and ( not visited [ u_to ] ) : <NEWLINE> <INDENT> visited [ u_to ] = True <NEWLINE> que . append ( u_to ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ list ( input ( ) . rstrip ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> g = MF_graph ( N * M + 2 ) <NEWLINE> source = N * M <NEWLINE> sink = N * M + 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = i * M + j <NEWLINE> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> g . add_edge ( source , v , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g . add_edge ( v , sink , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if ( i + j ) % 2 or grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v0 = i * M + j <NEWLINE> if i and grid [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> v1 = ( i - 1 ) * M + j <NEWLINE> g . add_edge ( v0 , v1 , 1 ) <NEWLINE> <DEDENT> if j and grid [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> v1 = i * M + j - 1 <NEWLINE> g . add_edge ( v0 , v1 , 1 ) <NEWLINE> <DEDENT> if i + 1 < N and grid [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> v1 = ( i + 1 ) * M + j <NEWLINE> g . add_edge ( v0 , v1 , 1 ) <NEWLINE> <DEDENT> if j + 1 < M and grid [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> v1 = i * M + j + 1 <NEWLINE> g . add_edge ( v0 , v1 , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = g . flow ( source , sink ) <NEWLINE> <NL> for frm , to , cap , flow in g . edges ( ) : <NEWLINE> <INDENT> if frm == source or to == sink or flow == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i0 , j0 = divmod ( frm , M ) <NEWLINE> i1 , j1 = divmod ( to , M ) <NEWLINE> if i0 == i1 + 1 : <NEWLINE> <INDENT> grid [ i1 ] [ j1 ] = <STRING> <NEWLINE> grid [ i0 ] [ j0 ] = <STRING> <NEWLINE> <DEDENT> elif j0 == j1 + 1 : <NEWLINE> <INDENT> grid [ i1 ] [ j1 ] = <STRING> <NEWLINE> grid [ i0 ] [ j0 ] = <STRING> <NEWLINE> <DEDENT> elif i0 == i1 - 1 : <NEWLINE> <INDENT> grid [ i1 ] [ j1 ] = <STRING> <NEWLINE> grid [ i0 ] [ j0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> grid [ i1 ] [ j1 ] = <STRING> <NEWLINE> grid [ i0 ] [ j0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> for g in grid : <NEWLINE> <INDENT> print ( <STRING> . join ( g ) ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( map ( int , list ( input ( ) ) ) ) [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> chk = [ 0 ] * 2019 <NEWLINE> chk [ 0 ] = 1 <NEWLINE> t , m , ans = 1 , 0 , 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> m = ( m + t * i ) % 2019 <NEWLINE> ans += chk [ m ] <NEWLINE> chk [ m ] += 1 <NEWLINE> t = t * 10 % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import queue <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> route = [ [ ] for _ in range ( n ) ] <NEWLINE> vals = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> route [ a - 1 ] . append ( b - 1 ) <NEWLINE> route [ b - 1 ] . append ( a - 1 ) <NEWLINE> vals . append ( [ a - 1 , b - 1 ] ) <NEWLINE> <DEDENT> ans = m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> route2 = set ( ) <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> route [ vals [ i ] [ 0 ] ] . remove ( vals [ i ] [ 1 ] ) <NEWLINE> route [ vals [ i ] [ 1 ] ] . remove ( vals [ i ] [ 0 ] ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> a = q . get ( ) <NEWLINE> if not a in route2 : <NEWLINE> <INDENT> route2 . add ( a ) <NEWLINE> for j in route [ a ] : <NEWLINE> <INDENT> q . put ( j ) <NEWLINE> <DEDENT> <DEDENT> if len ( route2 ) == n : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> route [ vals [ i ] [ 0 ] ] . append ( vals [ i ] [ 1 ] ) <NEWLINE> route [ vals [ i ] [ 1 ] ] . append ( vals [ i ] [ 0 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b - 1 : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <NL> <DEDENT> m = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( m ) <NEWLINE>
import sys <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> INF = 1 << 60 <NEWLINE> cost = [ - INF ] * ( N + 1 ) <NEWLINE> cost [ 1 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for n , nn , c in edge : <NEWLINE> <INDENT> if cost [ nn ] < cost [ n ] + c : <NEWLINE> <COMMENT> <NL> <INDENT> if i == N - 1 and nn == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> cost [ nn ] = cost [ n ] + c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cost [ N ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> marks = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> cards = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) <NEWLINE> elements = line . split ( <STRING> ) <NEWLINE> if ( elements [ 0 ] in marks ) : <NEWLINE> <INDENT> elements [ 1 ] = int ( elements [ 1 ] ) <NEWLINE> cards . append ( elements ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> result = <STRING> <NEWLINE> for mark in marks : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( [ mark , i ] not in cards ) : <NEWLINE> <INDENT> result += mark + <STRING> + str ( i ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( len ( result ) > 0 ) : <NEWLINE> <INDENT> print ( result . rstrip ( ) ) <NEWLINE> <DEDENT> <DEDENT> func ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> i = 1 <NEWLINE> while N >= 2 ** i : <NEWLINE> <INDENT> ans += 2 ** i <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( N - 1 - i ) == i : <NEWLINE> <INDENT> if 0 not in c or c [ 0 ] != 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = abs ( ( N - 1 - i ) - i ) <NEWLINE> if p not in c or c [ p ] != 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = pow ( 2 , N // 2 , mod ) <NEWLINE> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> answer += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import math <NEWLINE> <NL> N , K = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> A_list = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( A_list ) ) : <NEWLINE> <INDENT> A_list [ i ] = math . log10 ( A_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> point_K = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> point_K += A_list [ i ] <NEWLINE> <NL> <NL> <DEDENT> prev = point_K <NEWLINE> <NL> for i in range ( K , len ( A_list ) ) : <NEWLINE> <INDENT> current = prev - A_list [ i - K ] + A_list [ i ] <NEWLINE> <NL> if current > prev : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> prev = current <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> l = [ a , b , c ] <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if k < a : <NEWLINE> <INDENT> ans = k <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> k -= a <NEWLINE> a -= a <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if k > b : <NEWLINE> <INDENT> k -= b <NEWLINE> b -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= k <NEWLINE> b -= k <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if k < c : <NEWLINE> <INDENT> ans += - k <NEWLINE> k -= k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += - c <NEWLINE> k -= c <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
cnt = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> L = A [ left : mid ] + [ 10 ** 10 ] <NEWLINE> R = A [ mid : right ] + [ 10 ** 10 ] <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <COMMENT> <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * merge_sort ( A , 0 , n ) ) <NEWLINE> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> total = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total += a_list [ i ] <NEWLINE> if total >= mod : <NEWLINE> <INDENT> total = total % mod <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> total -= a_list [ i ] <NEWLINE> if total < 0 : <NEWLINE> <INDENT> total += mod <NEWLINE> <DEDENT> ans += a_list [ i ] * total <NEWLINE> if ans >= mod : <NEWLINE> <INDENT> ans = ans % mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> i = min ( b - 1 , n ) <NEWLINE> m = a * i // b - a * ( i // b ) <NEWLINE> <NL> print ( m ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> t [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> k -= 1 <NEWLINE> l = [ 0 ] * n <NEWLINE> def dfs ( a , b , c ) : <NEWLINE> <INDENT> for i , j in t [ b ] : <NEWLINE> <INDENT> if i != a : <NEWLINE> <INDENT> l [ i ] = c + j <NEWLINE> dfs ( b , i , c + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( - 1 , k , 0 ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> print ( l [ x ] + l [ y ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> x = int ( n ** 0.5 ) <NEWLINE> while n % x != 0 : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> print ( max ( len ( str ( x ) ) , len ( str ( n // x ) ) ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist = [ ] <NEWLINE> gcd1 = a [ 0 ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( gcd1 , a [ i ] ) <NEWLINE> alist . append ( gcd1 ) <NEWLINE> <DEDENT> blist = [ ] <NEWLINE> gcd2 = a [ n - 1 ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> gcd2 = math . gcd ( gcd2 , a [ i ] ) <NEWLINE> blist . append ( gcd2 ) <NEWLINE> <DEDENT> clist = [ alist [ n - 2 ] , blist [ n - 2 ] ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> clist . append ( math . gcd ( alist [ i ] , blist [ n - i - 3 ] ) ) <NEWLINE> <DEDENT> print ( max ( clist ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> dp = { i } <NEWLINE> xs = [ ] <NEWLINE> ys = [ ] <NEWLINE> now = 0 <NEWLINE> xy = <STRING> <NEWLINE> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> if j < n and s [ j ] == <STRING> : <NEWLINE> <INDENT> now += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if xy == <STRING> : <NEWLINE> <INDENT> if now > 0 : <NEWLINE> <INDENT> xs . append ( now ) <NEWLINE> <DEDENT> xy = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now > 0 : <NEWLINE> <INDENT> ys . append ( now ) <NEWLINE> <DEDENT> xy = <STRING> <NEWLINE> <DEDENT> now = 0 <NEWLINE> <NL> <DEDENT> for i in xs : <NEWLINE> <INDENT> newdp = set ( ) <NEWLINE> for j in dp : <NEWLINE> <INDENT> newdp . add ( j + i ) <NEWLINE> newdp . add ( j - i ) <NEWLINE> <DEDENT> dp = newdp <NEWLINE> <DEDENT> if x not in dp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> dp = { 0 } <NEWLINE> for i in ys : <NEWLINE> <INDENT> newdp = set ( ) <NEWLINE> for j in dp : <NEWLINE> <INDENT> newdp . add ( j + i ) <NEWLINE> newdp . add ( j - i ) <NEWLINE> <DEDENT> dp = newdp <NEWLINE> <DEDENT> if y in dp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> fin = sys . stdin <NEWLINE> <NL> str = fin . readline ( ) <NEWLINE> <NL> print ( str . swapcase ( ) , end = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> import copy <NEWLINE> alist_copy = copy . copy ( alist ) <NEWLINE> <NL> alist_copy . sort ( ) <NEWLINE> max_value = alist_copy [ - 1 ] <NEWLINE> next_value = alist_copy [ - 2 ] <NEWLINE> for a in alist : <NEWLINE> <INDENT> if a == max_value : <NEWLINE> <INDENT> print ( next_value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_value ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ap = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ap [ i - a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += ap [ a [ i ] + i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H . sort ( ) <NEWLINE> H . reverse ( ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> c += H [ i ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , 1000000007 ) ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import unittest <NEWLINE> <NL> def top_face_after_rolling_dice ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> faces = [ int ( num ) for num in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> rollings = input ( ) . rstrip ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return __input_error ( ) <NEWLINE> <NL> <DEDENT> dice = CubicArbitraryValueDice ( faces [ 0 ] , faces [ 1 ] , faces [ 2 ] , faces [ 3 ] , faces [ 4 ] , faces [ 5 ] ) <NEWLINE> dice . put ( dice . TOP , dice . SOUTH , dice . EAST , dice . WEST , dice . NORTH , dice . BOTTOM ) <NEWLINE> <NL> for direction in rollings : <NEWLINE> <INDENT> dice . roll ( direction ) <NEWLINE> <NL> <DEDENT> print ( dice . faces [ dice . direction [ dice . TOP ] ] ) <NEWLINE> <NL> <DEDENT> class CubicArbitraryValueDice ( ) : <NEWLINE> <INDENT> TOP = <STRING> <NEWLINE> BOTTOM = <STRING> <NEWLINE> EAST = <STRING> <NEWLINE> WEST = <STRING> <NEWLINE> SOUTH = <STRING> <NEWLINE> NORTH = <STRING> <NEWLINE> OPOSITE_DIRECTION_PAIRS = ( ( EAST , WEST ) , ( SOUTH , NORTH ) ) <NEWLINE> <NL> <COMMENT> <NL> def __init__ ( self , n_f0 , n_f1 , n_f2 , n_f3 , n_f4 , n_f5 ) : <NEWLINE> <INDENT> self . faces = [ n_f0 , n_f1 , n_f2 , n_f3 , n_f4 , n_f5 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def put ( self , dir_f0 , dir_f1 , dir_f2 , dir_f3 , dir_f4 , dir_f5 ) : <COMMENT> <NEWLINE> <INDENT> self . direction = { dir_fi : i for i , dir_fi in enumerate ( [ dir_f0 , dir_f1 , dir_f2 , dir_f3 , dir_f4 , dir_f5 ] ) } <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def roll ( self , direction ) : <COMMENT> <NEWLINE> <INDENT> for pair in self . OPOSITE_DIRECTION_PAIRS : <NEWLINE> <INDENT> if direction in pair : <NEWLINE> <INDENT> oposite = pair [ 0 ] if ( pair [ 1 ] == direction ) else pair [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> current = { } <NEWLINE> for direct in ( self . TOP , self . BOTTOM , direction , oposite ) : <NEWLINE> <INDENT> current . update ( { direct : self . direction [ direct ] } ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for pair in ( ( direction , self . BOTTOM ) , ( self . BOTTOM , oposite ) , ( oposite , self . TOP ) , ( self . TOP , direction ) ) : <NEWLINE> <INDENT> self . direction [ pair [ 1 ] ] = current [ pair [ 0 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def __input_error ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> class __TestValueClass ( unittest . TestCase ) : <NEWLINE> <COMMENT> <NL> <INDENT> def testEqual ( self , func , tuples , eff_digit = None , print_success = False ) : <NEWLINE> <INDENT> self . testFunction ( self . assertEqual , func , tuples , eff_digit , print_success ) <NEWLINE> <NL> <DEDENT> def testFunction ( self , assertfunc , func , tuples , eff_digit , print_success ) : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> top_face_after_rolling_dice ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 3 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> N , M = MI ( ) <NEWLINE> links = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> links [ a ] . append ( b ) <NEWLINE> links [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * N <NEWLINE> ans [ 0 ] = 0 <NEWLINE> q = deque ( [ ( 0 , 0 ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> room , prev = q . popleft ( ) <NEWLINE> for next_ in links [ room ] : <NEWLINE> <INDENT> if ans [ next_ ] < 0 : <NEWLINE> <INDENT> ans [ next_ ] = room + 1 <NEWLINE> q . append ( ( next_ , room ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> INFTY = sys . maxsize <NEWLINE> <NL> def readinput ( ) : <NEWLINE> <INDENT> n , x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , x , y <NEWLINE> <NL> <DEDENT> def dijkstra ( s , n , nList ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> color = [ WHITE ] * n <NEWLINE> d = [ INFTY ] * n <NEWLINE> <NL> HQ = [ ] <NEWLINE> <NL> d [ s ] = 0 <NEWLINE> heappush ( HQ , ( d [ s ] , s ) ) <NEWLINE> <NL> while ( len ( HQ ) > 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> du , u = heappop ( HQ ) <NEWLINE> color [ u ] = BLACK <NEWLINE> <NL> if d [ u ] < du : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for v in nList [ u ] : <NEWLINE> <INDENT> vw = 1 <NEWLINE> if color [ v ] != BLACK : <NEWLINE> <INDENT> if d [ u ] + vw < d [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u ] + vw <NEWLINE> color [ v ] = GRAY <NEWLINE> heappush ( HQ , ( d [ v ] , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def main ( n , x , y ) : <NEWLINE> <INDENT> nList = [ ] <NEWLINE> <COMMENT> <NL> nList . append ( [ 1 ] ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> nList . append ( [ i - 1 , i + 1 ] ) <NEWLINE> <DEDENT> nList . append ( [ n - 2 ] ) <NEWLINE> nList [ x - 1 ] . append ( y - 1 ) <NEWLINE> nList [ y - 1 ] . append ( x - 1 ) <NEWLINE> <COMMENT> <NL> <NL> dList = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dList . append ( dijkstra ( i , n , nList ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> hist = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> hist [ dList [ i ] [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( hist [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main2 ( n , x , y ) : <NEWLINE> <INDENT> hist = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> if i <= x : <NEWLINE> <INDENT> if j <= x : <NEWLINE> <INDENT> d = j - i <NEWLINE> <DEDENT> elif x < j and j <= y : <NEWLINE> <INDENT> d = min ( j - i , x - i + 1 + y - j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = x - i + 1 + j - y <NEWLINE> <DEDENT> <DEDENT> elif x < i and i <= y : <NEWLINE> <INDENT> if j <= y : <NEWLINE> <INDENT> d = min ( j - i , i - x + 1 + y - j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = min ( j - i , i - x + 1 + j - y ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d = j - i <NEWLINE> <COMMENT> <NL> <DEDENT> hist [ d ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( hist [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , x , y = readinput ( ) <NEWLINE> main2 ( n , x , y ) <NEWLINE> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> dp = [ 0 ] * N <NEWLINE> L = max ( l ) <NEWLINE> R = min ( r ) <NEWLINE> if L <= R : <NEWLINE> <INDENT> i = list ( range ( L , R + 1 ) ) <NEWLINE> ans = len ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> l , r = [ 0 ] * M , [ 0 ] * M <NEWLINE> for c in range ( M ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l [ c ] = tmp [ 0 ] <NEWLINE> r [ c ] = tmp [ 1 ] <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> B = A [ : : - 1 ] <NEWLINE> C = N - 1 <NEWLINE> ans = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> ans += B [ 0 ] <NEWLINE> for i in range ( N // 2 - 1 ) : <NEWLINE> <INDENT> ans += 2 * B [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += B [ 0 ] <NEWLINE> ans += B [ N // 2 ] <NEWLINE> for i in range ( N // 2 - 1 ) : <NEWLINE> <INDENT> ans += 2 * B [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> ln = itertools . product ( range ( 1 , 100 ) , repeat = 3 ) <NEWLINE> <COMMENT> <NL> line = [ 0 for i in range ( 10000 ) ] <NEWLINE> <COMMENT> <NL> for i in ln : <NEWLINE> <INDENT> x , y , z = i <NEWLINE> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n <= 10000 : <NEWLINE> <INDENT> line [ n - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( line [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from copy import deepcopy <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import product , permutations , combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> S = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( A [ i ] + S [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> s += A [ i ] * S [ i ] <NEWLINE> <NL> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE> exit ( ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for a in range ( k ) : <NEWLINE> <INDENT> for b in range ( k ) : <NEWLINE> <INDENT> aandb = math . gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( k ) : <NEWLINE> <INDENT> sum += math . gcd ( aandb , c + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> <NL> import bisect <NEWLINE> <NL> import math <NEWLINE> <NL> def st ( ) : <NEWLINE> <INDENT> return list ( stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <DEDENT> def inp ( ) : <NEWLINE> <INDENT> return int ( stdin . readline ( ) ) <NEWLINE> <NL> <DEDENT> def li ( ) : <NEWLINE> <INDENT> return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def mp ( ) : <NEWLINE> <INDENT> return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def pr ( n ) : <NEWLINE> <INDENT> stdout . write ( str ( n ) + <STRING> ) <NEWLINE> <NL> <DEDENT> def soe ( limit ) : <NEWLINE> <INDENT> l = [ 1 ] * ( limit + 1 ) <NEWLINE> prime = [ ] <NEWLINE> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , limit + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def segsoe ( low , high ) : <NEWLINE> <INDENT> limit = int ( high ** 0.5 ) + 1 <NEWLINE> prime = soe ( limit ) <NEWLINE> n = high - low + 1 <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> lowlimit = ( low // prime [ i ] ) * prime [ i ] <NEWLINE> if lowlimit < low : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> if lowlimit == prime [ i ] : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> for j in range ( lowlimit , high + 1 , prime [ i ] ) : <NEWLINE> <INDENT> l [ j - low ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( low , high + 1 ) : <NEWLINE> <INDENT> if not l [ i - low ] : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def power ( a , n ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> r = ( r * a ) <NEWLINE> <DEDENT> a *= a <NEWLINE> n = n >> 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> l = soe ( 10 ** 6 + 100 ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = inp ( ) <NEWLINE> a = bisect . bisect_left ( l , n ) <NEWLINE> <NL> print ( l [ a ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for _ in range ( 1 ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
vs = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for v in vs : <NEWLINE> <INDENT> end = <STRING> if v == vs [ - 1 ] else <STRING> <NEWLINE> print ( v , end = end ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> List = [ 0 for _ in range ( 10000 ) ] <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> k = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if k <= N : <NEWLINE> <INDENT> List [ k - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( List [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in list : <NEWLINE> <INDENT> if i not in dic : <NEWLINE> <INDENT> dic [ i ] = 0 <NEWLINE> <DEDENT> dic [ i ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> ans = sum ( list ) <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> b , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if b not in dic : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c not in dic : <NEWLINE> <INDENT> dic [ c ] = dic [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] += dic [ b ] <NEWLINE> <DEDENT> <DEDENT> ans = ans + ( c - b ) * dic [ b ] <NEWLINE> dic [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] <NEWLINE> def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] <NEWLINE> def Yes ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> def YES ( ) : print ( <STRING> ) <NEWLINE> def NO ( ) : print ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 19 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> EPS = 10 ** - 10 <NEWLINE> <NL> def factorize ( num : int ) -> dict : <NEWLINE> <INDENT> from math import sqrt <NEWLINE> from collections import Counter <NEWLINE> <NL> d = Counter ( ) <NEWLINE> for i in range ( 2 , int ( sqrt ( num ) ) + 1 ) : <NEWLINE> <INDENT> while num % i == 0 : <NEWLINE> <INDENT> num //= i <NEWLINE> d [ i ] += 1 <NEWLINE> <DEDENT> if num == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if num != 1 : <NEWLINE> <INDENT> d [ num ] += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> N = INT ( ) <NEWLINE> <NL> L = [ 0 , 493438984 , 2111951377 , 4934219787 , 9001617396 , 14343475240 , 20983549232 , 28938411754 , 38222337945 , 48855592736 , 60838190672 , 74193687476 , 88921806577 , 105036084674 , 122543360219 , 141448665788 , 161762066784 , 183487293576 , 206644111130 , 231208670456 , 257212470774 , 284661691691 , 313538542845 , 343862458416 , 375639765395 , 408875452660 , 443559968601 , 479723200366 , 517333062431 , 556419507715 , 596981215450 , 639007377350 , 682529770555 , 727538683373 , 774009411906 , 821990325762 , 871476277626 , 922424492974 , 974880028674 , 1028856951678 , 1084296609104 , 1141266683482 , 1199769931446 , 1259717167514 , 1321237832726 , 1384261675499 , 1448776778605 , 1514816915551 , 1582401743782 , 1651519869360 , 1722125036282 , 1794261310039 , 1867938145253 , 1943162263556 , 2019919516903 , 2098185047461 , 2177990752180 , 2259356996967 , 2342246760421 , 2426683306008 , 2512661322551 , 2600202380059 , 2689253635198 , 2779911682839 , 2872076940842 , 2965792104633 , 3061088597282 , 3157923865183 , 3256297470052 , 3356283349093 , 3457770622390 , 3560833491555 , 3665505698976 , 3771665000331 , 3879451580190 , 3988800240289 , 4099689915648 , 4212156072325 , 4326227368544 , 4441788452022 , 4558987534475 , 4677840157734 , 4798099997041 , 4920000663900 , 5043552008724 , 5168559295617 , 5295214000044 , 5423487803310 , 5553301601415 , 5684679342328 , 5817729717828 , 5952248621195 , 6088428461000 , 6226149254802 , 6365487771753 , 6506418585007 , 6648988032736 , 6793042552516 , 6938843502589 , 7086136299955 , 7235062807366 , 7385497922168 , 7537595029369 , 7691272542181 , 7846594285002 , 8003510992854 , 8162003209593 , 8322065666301 , 8483854862004 , 8647160290700 , 8812039622862 , 8978549345553 , 9146706496165 , 9316419043328 , 9487781973018 , 9660719955296 , 9835269787927 , 10011553756671 , 10189253411315 , 10368667669769 , 10549659220862 , 10732401846534 , 10916579731860 , 11102453274617 , 11289904537263 , 11479011688245 , 11669830174971 , 11862029769733 , 12056063349904 , 12251617620346 , 12448845177256 , 12647680629690 , 12848171370860 , 13050254462297 , 13253960158691 , 13459323658561 , 13666226110773 , 13874834196455 , 14085094521507 , 14296814468805 , 14510332007222 , 14725429439492 , 14942131234656 , 15160521193552 , 15380588954554 , 15602136739002 , 15825403657376 , 16050451660910 , 16276847020856 , 16505115662434 , 16734924755096 , 16966264626222 , 17199447614438 , 17434170056672 , 17670514459840 , 17908481787130 , 18148241497132 , 18389471243932 , 18632333327852 , 18877006937424 , 19123138141378 , 19371049907390 , 19620742818748 , 19871685989154 , 20124476869606 , 20379057733244 , 20634980880846 , 20892786409876 , 21152210987700 , 21413258654304 , 21675833225770 , 21940306512852 , 22206142281006 , 22473855635042 , 22743180271196 , 23013964372551 , 23286698574789 , 23560888221575 , 23836769564907 , 24114378406399 , 24393634293809 , 24674416929987 , 24956947315787 , 25241193314980 , 25526998756870 , 25814409354826 , 26103616946734 , 26394550063000 , 26686893099848 , 26981155333407 , 27276821356759 , 27574386655175 , 27873535407821 , 28174159348173 , 28476594164494 , 28780788606772 , 29086633471688 , 29393966055558 , 29703149003024 , 30013792137851 , 30326413365285 , 30640395292273 , 30956069654443 , 31273523102626 , 31592664449728 , 31913376078550 , 32235842932848 , 32560029990049 , 32885785039643 , 33213220430143 , 33542358268005 , 33873031165364 , 34205581585566 , 34539604444304 , 34875425263721 , 35212812420453 , 35552154166961 , 35892886791151 , 36235517412420 , 36579557281204 , 36925459066686 , 37272877068179 , 37622167432867 , 37972983625527 , 38325669456310 , 38679944926812 , 39035687683706 , 39393229506853 , 39752627629789 , 40113337934391 , 40476248899052 , 40840525066648 , 41206411398402 , 41574140883741 , 41943676682207 , 42314367955206 , 42687136285026 , 43061485153064 , 43437687786881 , 43815302669763 , 44194833598353 , 44575932486140 , 44959075432376 , 45343572745399 , 45729521171181 , 46117511559977 , 46507039889452 , 46898189118372 , 47291122961301 , 47685728865579 , 48081994935671 , 48480082300526 , 48879970671808 , 49281110607237 , 49684086992257 , 50088943167842 , 50495479917520 , 50903466600692 , 51313347525789 , 51724975620189 , 52138123487538 , 52553108327972 , 52969581501827 , 53387767611137 , 53807963320230 , 54229542299288 , 54653198694933 , 55078208662363 , 55504960390211 , 55933215747316 , 56363615930452 , 56795212776465 , 57228909958313 , 57664215816822 , 58101239718024 , 58539707599783 , 58980252241083 , 59421892348898 , 59865706329526 , 60311259225171 , 60758384185743 , 61207170466520 , 61657753740090 , 62110005557983 , 62563875183571 , 63019567631040 , 63476896129040 , 63935958271999 , 64396829979171 , 64859270285018 , 65323182791149 , 65789089604569 , 66256629418190 , 66725831508196 , 67197154766221 , 67669778128369 , 68143846134308 , 68620152785028 , 69098036648615 , 69577694425039 , 70058785460280 , 70541587609951 , 71025938505929 , 71512452345322 , 72000611436936 , 72490226710653 , 72981712491617 , 73474739478198 , 73969802569251 , 74466324672669 , 74964555109988 , 75464743316958 , 75966455520027 , 76469922185833 , 76974918304364 , 77481786106093 , 77990116976087 , 78500489297008 , 79012557024984 , 79526167516159 , 80041527790312 , 80558645237098 , 81077594980197 , 81598055713779 , 82120713079294 , 82644353395127 , 83169941989863 , 83697504542732 , 84226394594512 , 84757231028297 , 85290161753688 , 85823956198104 , 86359994965751 , 86897880537014 , 87437307393462 , 87978318105507 , 88521402624739 , 89065833437896 , 89612148645041 , 90160177388367 , 90709780843282 , 91261462998831 , 91814670146287 , 92369737296000 , 92925795939321 , 93484427284737 , 94044459497514 , 94605692593587 , 95169619029369 , 95734736626700 , 96301520878991 , 96871003843775 , 97440790250114 , 98012538259925 , 98586604492967 , 99162032503100 , 99739464176165 , 100318795327755 , 100899258277840 , 101481591756225 , 102065855149715 , 102652068778038 , 103239275746737 , 103829147617875 , 104419705255676 , 105012670748303 , 105607087655847 , 106203258904286 , 106801251505039 , 107401147943134 , 108002269398516 , 108605669699699 , 109210412671028 , 109816898593848 , 110425621805189 , 111035349416856 , 111647260553880 , 112260978633767 , 112876414074318 , 113493082165965 , 114111807921375 , 114732129627940 , 115354581555727 , 115978374551469 , 116604201140710 , 117231448199853 , 117860345420030 , 118491457697962 , 119123896922237 , 119758228396194 , 120394329084663 , 121032207586387 , 121671762836798 , 122312774834877 , 122955612335878 , 123600339753238 , 124247228070109 , 124895026488944 , 125544979006721 , 126196993528335 , 126850549017804 , 127505199391685 , 128162238812474 , 128820653080288 , 129480852076751 , 130143314566922 , 130806818828029 , 131472491663433 , 132139863485890 , 132808680912837 , 133479467089246 , 134152010492156 , 134826295251391 , 135502107129054 , 136180066055547 , 136859038394801 , 137540475359704 , 138223390236401 , 138908157808408 , 139594113155195 , 140282617787827 , 140971935053758 , 141664050636387 , 142357602038586 , 143052689302720 , 143749192448739 , 144447897755264 , 145148497213081 , 145850281904976 , 146554080642842 , 147259491582477 , 147967040134080 , 148676185176293 , 149386679322656 , 150099453429042 , 150813537261139 , 151529826444886 , 152247135978549 , 152966937395338 , 153688169519778 , 154411235469265 , 155136321517588 , 155862218888277 , 156590458911006 , 157320579912726 , 158052520943755 , 158785663003084 , 159521080147969 , 160258283568446 , 160996569067233 , 161737467121483 , 162479234078350 , 163223256696949 , 163968850251200 , 164716254597751 , 165465511572167 , 166216722634706 , 166969089792981 , 167723475231634 , 168479936246421 , 169238102781982 , 169997490957786 , 170759095684543 , 171522119425146 , 172287112634491 , 173053807479870 , 173822301914317 , 174592676086419 , 175364856374134 , 176138491780787 , 176913242475822 , 177690692049615 , 178469553728962 , 179250407544097 , 180032530244167 , 180816973674988 , 181603061170895 , 182390930796476 , 183179904404611 , 183971218922672 , 184764302482181 , 185559352780607 , 186355484716640 , 187154167627305 , 187954463112172 , 188755167873661 , 189559787774578 , 190364265283477 , 191171258442543 , 191980195355334 , 192790925674795 , 193602556410512 , 194417016305967 , 195232645987818 , 196050188214189 , 196869911666370 , 197690504888822 , 198513424115241 , 199337980967136 , 200164364728679 , 200992441246692 , 201822370836189 , 202653868317500 , 203487295124995 , 204322582138612 , 205159280851458 , 205997845055705 , 206838686419778 , 207680223459897 , 208524389546180 , 209370037656611 , 210217713280204 , 211066783506201 , 211918221290312 , 212770051652978 , 213624780221079 , 214480891817874 , 215339170446071 , 216198966217860 , 217060656926613 , 217923890158764 , 218789180815693 , 219655779282864 , 220523735657387 , 221394090749349 , 222266481117362 , 223140061833265 , 224016558533452 , 224893676139605 , 225772746863650 , 226653316365413 , 227536174732100 , 228421314666947 , 229306948564404 , 230195066828025 , 231084619915589 , 231976153079776 , 232869522913489 , 233764396646712 , 234661096550023 , 235560022983960 , 236459761443283 , 237361938411048 , 238265786958041 , 239171714912618 , 240079430075503 , 240988397832690 , 241898812660791 , 242812185647676 , 243726278270952 , 244642548171917 , 245560254111198 , 246480586961269 , 247401317616792 , 248324577480015 , 249249827129502 , 250176645559885 , 251105483218834 , 252035928916781 , 252967864735060 , 253902107151677 , 254838098382990 , 255774984445791 , 256713920805122 , 257655416928771 , 258598042267722 , 259542772930910 , 260489350267409 , 261436917320998 , 262386403483379 , 263338334303632 , 264291434634157 , 265246857118052 , 266204009065415 , 267162706932416 , 268122443879733 , 269085526198458 , 270049088960461 , 271015374238472 , 271982522915917 , 272951354222680 , 273922507156707 , 274895612421442 , 275870379762381 , 276846598740350 , 277825672031685 , 278804570050134 , 279786370749447 , 280770739235134 , 281755465246921 , 282742772106696 , 283731559078148 , 284721682929865 , 285714250695616 , 286708743387977 , 287704245795420 , 288702721195441 , 289702014807874 , 290703569309949 , 291706201453858 , 292711324081941 , 293717366474056 , 294725901925083 , 295736053976404 , 296747592638013 , 297762174014958 , 298776908022377 , 299794469887084 , 300813564019813 , 301834201727288 , 302856699362737 , 303880788840754 , 304907289654363 , 305934819862268 , 306964702346215 , 307996718856936 , 309029824258801 , 310064151223148 , 311101637905109 , 312139951524896 , 313180253381239 , 314222805621412 , 315266553457537 , 316312042620248 , 317360134362523 , 318409439232054 , 319460499426217 , 320513384122962 , 321567622851745 , 322623930942812 , 323682486495499 , 324741853391528 , 325803695787761 , 326867219740652 , 327932450455477 , 328999565677832 , 330068744316709 , 331139300028798 , 332211422630039 , 333285673740620 , 334361760892115 , 335439825691086 , 336519086109011 , 337600169846864 , 338683695663679 , 339768196320246 , 340854960383245 , 341943058696612 , 343034472400869 , 344126288365936 , 345219904513529 , 346315581629252 , 347412434557053 , 348511792968136 , 349613032606555 , 350715682647270 , 351819912216247 , 352926548527444 , 354034344501769 , 355144048864876 , 356256480873339 , 357369113508715 , 358484442195342 , 359601854797041 , 360720410076300 , 361841581744271 , 362963722150674 , 364088108554029 , 365213714591214 , 366341568308709 , 367470747430202 , 368602095664463 , 369735789749694 , 370870069207777 , 372007153176608 , 373145655996233 , 374286076547576 , 375427962091615 , 376571542044574 , 377716999592043 , 378864539458650 , 380013795473175 , 381165217740896 , 382317332922921 , 383472680967630 , 384628186031971 , 385787504467500 , 386946111242933 , 388108089327077 , 389271682033460 , 390437889429971 , 391604283066184 , 392773416637483 , 393944435287130 , 395115604641767 , 396290295634134 , 397466595094813 , 398644056408120 , 399823884730061 , 401005593478536 , 402188826344049 , 403373694633520 , 404561981047791 , 405749179528776 , 406939431685005 , 408131530592604 , 409324954308067 , 410521348475975 , 411718608508472 , 412917829716085 , 414118956306590 , 415322188137827 , 416527085300694 , 417733433700427 , 418942331716724 , 420152374263135 , 421364002783104 , 422577395980403 , 423792898623764 , 425010124061273 , 426229374669116 , 427450147002323 , 428673624289944 , 429897374046936 , 431123533288353 , 432351372593538 , 433582822947449 , 434813006623636 , 436046483157627 , 437282894500928 , 438519040875971 , 439757019372828 , 440997965038867 , 442240079785140 , 443484462291313 , 444731555754762 , 445978339255250 , 447227855605997 , 448480086797544 , 449733248446751 , 450987322450746 , 452244765673393 , 453503381019818 , 454763522811227 , 456025584592066 , 457290058813673 , 458555247324046 , 459822864161615 , 461092949514555 , 462363708727082 , 463635895079489 , 464911820422952 , 466187687663221 , 467466366121452 , 468746616002817 , 470028210141922 , 471312757314047 , 472598203288748 , 473885272432371 , 475174594334501 , 476465015795706 , 477757744330055 , 479052416466724 , 480348819350435 , 481647182202860 , 482947253439277 , 484248512083034 , 485552313622173 , 486857969964978 , 488164574198429 , 489473701762655 , 490784291733168 , 492096644148075 , 493411300179502 , 494727689317357 , 496045307801936 , 497365255568609 , 498687449477284 , 500010568862547 , 501335747966526 , 502662434241804 , 503991704580965 , 505322052981958 , 506654432172067 , 507989000109970 , 509324212044955 , 510661840177448 , 512001532956817 , 513342503635826 , 514686036546604 , 516031076204871 , 517377724607508 , 518727343474553 , 520078145300410 , 521429056074467 , 522783440474442 , 524139131959187 , 525496543337174 , 526857422190838 , 528217444408577 , 529581632274134 , 530946662693627 , 532311834614760 , 533680546735483 , 535051704371342 , 536423313695403 , 537796691803370 , 539172201925316 , 540549877857205 , 541928823207352 , 543311223215741 , 544693475279016 , 546077959708393 , 547464036046802 , 548853348040761 , 550242029951411 , 551635523926500 , 553028620646503 , 554424387913560 , 555822264061929 , 557220889209512 , 558621696505469 , 560025230061866 , 561428802276184 , 562836065508759 , 564243999095306 , 565654085968561 , 567065128422242 , 568480038230125 , 569893956799790 , 571311613610574 , 572730240277725 , 574152005590562 , 575575248534959 , 576999225949768 , 578425754453253 , 579853875598684 , 581283722724127 , 582714549978061 , 584148485672108 , 585584064718129 , 587022127750674 , 588459065212505 , 589900936512440 , 591343575167211 , 592787459417657 , 594234550140282 , 595682150650359 , 597132206946714 , 598583745209687 , 600036645526326 , 601492242580143 , 602949321421683 , 604407846945578 , 605869107689303 , 607331619426194 , 608795868334189 , 610261785848438 , 611729774917537 , 613198814493223 , 614670553358276 , 616144676283965 , 617619625265780 , 619096104738785 , 620575746952334 , 622055857989353 , 623538035545969 , 625023113070734 , 626509523416503 , 627996839401640 , 629486032479553 , 630977512484618 , 632471202833598 , 633966389221247 , 635463114501108 , 636961255455435 , 638462431547104 , 639964402087269 , 641469367558646 , 642974633730974 , 644482906053419 , 645993122794254 , 647505205272109 , 649017299537750 , 650532361117315 , 652049535718977 , 653567690469176 , 655088215385491 , 656610553120008 , 658134774989261 , 659661281999214 , 661189158190086 , 662718348756195 , 664249968506936 , 665783385006535 , 667318419340188 , 668855510173177 , 670395367176565 , 671933916759436 , 673476282039307 , 675021515919670 , 676567144364893 , 678113830344156 , 679664533401168 , 681214994169811 , 682768038722362 , 684323080911191 , 685880774547598 , 687438716491527 , 688999801428499 , 690561394962114 , 692125743196273 , 693692366054624 , 695260333986021 , 696829289232270 , 698400976891086 , 699973824671271 , 701549673831838 , 703126187535455 , 704705200232828 , 706285619557381 , 707867195732873 , 709451438872926 , 711037992008427 , 712625794349158 , 714214048734419 , 715806001244514 , 717399924658778 , 718994316345727 , 720590677150446 , 722190402701363 , 723790621480140 , 725392923121004 , 726998055073987 , 728603228142062 , 730211681284985 , 731821322759290 , 733432010195075 , 735045851805207 , 736661443613214 , 738276491989247 , 739895882758532 , 741516581592161 , 743138445553167 , 744762322406730 , 746388997301993 , 748016553170068 , 749646313071567 , 751277273517719 , 752911159922144 , 754546104527913 , 756183236791540 , 757822044025127 , 759461429975294 , 761105197442634 , 762748254977255 , 764394705633220 , 766043425272075 , 767692336656182 , 769344916049218 , 770997444637057 , 772653366761276 , 774309714924197 , 775968333981206 , 777628415754614 , 779290962936659 , 780956682898140 , 782621238201333 , 784290892463104 , 785959628811126 , 787630213195247 , 789303762499222 , 790981165033981 , 792656355727226 , 794335711756712 , 796016413077051 , 797698155805268 , 799382276287517 , 801069050223796 , 802756444093190 , 804447590347769 , 806139404970524 , 807831658746729 , 809526235046184 , 811224631223428 , 812923504620281 , 814624418991302 , 816327543076999 , 818031317116686 , 819737557578338 , 821446543739323 , 823156207463724 , 824866912441477 , 826581337675850 , 828296149193646 , 830013193599069 , 831732352764316 , 833453767340721 , 835175712259152 , 836900951119010 , 838627288460105 ] <NEWLINE> <NL> d = N // 10000 <NEWLINE> ans = L [ d ] <NEWLINE> for i in range ( d * 10000 + 1 , N + 1 ) : <NEWLINE> <INDENT> res = factorize ( i ) <NEWLINE> cnt = 1 <NEWLINE> for v in res . values ( ) : <NEWLINE> <INDENT> cnt *= v + 1 <NEWLINE> <DEDENT> ans += cnt * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> NIL = None <NEWLINE> class Tree : <NEWLINE> <INDENT> def __init__ ( self , key = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . p = NIL <NEWLINE> self . left = NIL <NEWLINE> self . right = NIL <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = { <STRING> : NIL } <NEWLINE> def insert ( T , z ) : <NEWLINE> <INDENT> y = NIL <NEWLINE> x = T [ <STRING> ] <NEWLINE> while x != NIL : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> if y == NIL : <NEWLINE> <INDENT> T [ <STRING> ] = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> <DEDENT> def preorder_tree_walk ( T ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if T . left != NIL : <NEWLINE> <INDENT> preorder_tree_walk ( T . left ) <NEWLINE> <DEDENT> if T . right != NIL : <NEWLINE> <INDENT> preorder_tree_walk ( T . right ) <NEWLINE> <DEDENT> <DEDENT> def inorder_tree_walk ( T ) : <NEWLINE> <INDENT> if T . left != NIL : <NEWLINE> <INDENT> inorder_tree_walk ( T . left ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if T . right != NIL : <NEWLINE> <INDENT> inorder_tree_walk ( T . right ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> ss = readline ( ) <NEWLINE> if ss [ 0 ] == <STRING> : <NEWLINE> <INDENT> s , v = ss . split ( ) <NEWLINE> insert ( tree , Tree ( int ( v ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inorder_tree_walk ( tree [ <STRING> ] ) <NEWLINE> print ( ) <NEWLINE> preorder_tree_walk ( tree [ <STRING> ] ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> w = 0 <NEWLINE> r = c . count ( <STRING> ) <NEWLINE> ans = r <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> if ans > max ( w , r ) : <NEWLINE> <INDENT> ans = max ( w , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> p = 1 <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in reversed ( arr ) : <NEWLINE> <INDENT> p *= i <NEWLINE> if p > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> max_score = 0 <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = min ( u - 1 , v - 1 ) , max ( u - 1 , v - 1 ) <NEWLINE> ans -= ( u + 1 ) * ( N - v ) <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * ( i + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> if all ( [ x == 0 for x in arr ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if n % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> c = Counter ( arr ) <NEWLINE> <NL> <COMMENT> <NL> if len ( c ) == 2 : <NEWLINE> <INDENT> if c [ 0 ] == n // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> elif len ( c ) == 3 : <NEWLINE> <INDENT> result = list ( c . values ( ) ) <NEWLINE> if result [ 0 ] == result [ 1 ] == result [ 2 ] : <NEWLINE> <INDENT> ans1 = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> result = list ( c . keys ( ) ) <NEWLINE> ans2 = result [ 0 ] == result [ 1 ] ^ result [ 2 ] and result [ 1 ] == result [ 0 ] ^ result [ 2 ] and result [ 2 ] == result [ 0 ] ^ result [ 1 ] <NEWLINE> <NL> print ( <STRING> if ans1 and ans2 else <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> nk = n % k <NEWLINE> print ( min ( nk , abs ( nk - k ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> answer = sum ( A ) <NEWLINE> setA = set ( A ) <NEWLINE> numNumberList = [ 0 ] * 100001 <NEWLINE> <NL> for Ai in A : <NEWLINE> <INDENT> numNumberList [ Ai ] = numNumberList [ Ai ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> answer = answer + ( int ( C ) - int ( B ) ) * numNumberList [ B ] <NEWLINE> <NL> numNumberList [ C ] = numNumberList [ C ] + numNumberList [ B ] <NEWLINE> numNumberList [ B ] = 0 <NEWLINE> <NL> print ( answer ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( input ( ) ) <NEWLINE> <NL> if <STRING> not in l or <STRING> not in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> i = 0 <NEWLINE> k = n - 1 <NEWLINE> <NL> while i < k : <NEWLINE> <INDENT> if l [ i ] == <STRING> and l [ k ] == <STRING> : <NEWLINE> <INDENT> l [ i ] , l [ k ] = l [ k ] , l [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if l [ k ] == <STRING> : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . split ( <STRING> ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . appendleft ( int ( s [ 1 ] ) ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if int ( s [ 1 ] ) in a : <NEWLINE> <INDENT> a . remove ( int ( s [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> b = list ( a ) <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if i == len ( b ) - 1 : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> trees = [ list ( input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> <NL> class BinaryTree : <NEWLINE> <INDENT> def __init__ ( self , key , p = None , l = None , r = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . p = p <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> <NL> <DEDENT> <DEDENT> def Insert ( root , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . r <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . l = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . r = z <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def preOrder ( root ) : <NEWLINE> <INDENT> x = root <NEWLINE> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> global preList <NEWLINE> preList . append ( x . key ) <NEWLINE> <NL> preOrder ( x . l ) <NEWLINE> preOrder ( x . r ) <NEWLINE> <NL> <DEDENT> def inOrder ( root ) : <NEWLINE> <INDENT> x = root <NEWLINE> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inOrder ( x . l ) <NEWLINE> <NL> global inList <NEWLINE> inList . append ( x . key ) <NEWLINE> <NL> inOrder ( x . r ) <NEWLINE> <NL> <DEDENT> root = None <NEWLINE> for data in trees : <NEWLINE> <INDENT> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> z = BinaryTree ( int ( data [ 1 ] ) ) <NEWLINE> root = Insert ( root , z ) <NEWLINE> <DEDENT> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> inList = [ ] <NEWLINE> preList = [ ] <NEWLINE> inOrder ( root ) <NEWLINE> a = <STRING> + <STRING> . join ( [ str ( num ) for num in inList ] ) <NEWLINE> print ( a ) <NEWLINE> <NL> preOrder ( root ) <NEWLINE> a = <STRING> + <STRING> . join ( [ str ( num ) for num in preList ] ) <NEWLINE> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> allcount = 0 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> vans = i <NEWLINE> while True : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> i //= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if count > allcount : <NEWLINE> <INDENT> allcount = count <NEWLINE> ans = vans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> cnt = collections . Counter ( a ) <NEWLINE> max_i = a [ - 1 ] + 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if cnt [ i ] >= 2 : <NEWLINE> <INDENT> del cnt [ i ] <NEWLINE> <DEDENT> for j in range ( i * 2 , max_i , i ) : <NEWLINE> <INDENT> del cnt [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( len ( cnt ) ) <NEWLINE>
x = [ ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> inp = int ( input ( ) ) <NEWLINE> if inp != 0 : <NEWLINE> <INDENT> x . append ( inp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . append ( inp ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> j = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if ( x [ j ] != 0 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( j + 1 , x [ j ] ) ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> n , m , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> matrixA , matrixB = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> matrixA . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> matrixB . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> matrix = [ ] <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> mtr = [ ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> mtr . append ( matrixB [ j ] [ i ] ) <NEWLINE> <DEDENT> matrix . append ( mtr ) <NEWLINE> <NL> <DEDENT> matrixC = [ ] <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> mtr = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> num_sum = 0 <NEWLINE> <COMMENT> <NL> for a , b in zip ( matrixA [ j ] , matrix [ i ] ) : <NEWLINE> <INDENT> num_sum += a * b <NEWLINE> <DEDENT> mtr . append ( num_sum ) <NEWLINE> <DEDENT> matrixC . append ( mtr ) <NEWLINE> <NL> <DEDENT> matrix = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> out += str ( matrixC [ j ] [ i ] ) + <STRING> <NEWLINE> <DEDENT> print ( out [ : - 1 ] ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> tmp1 = i <NEWLINE> tmp2 = j <NEWLINE> while tmp1 % tmp2 != 0 : <NEWLINE> <INDENT> tmp = tmp1 % tmp2 <NEWLINE> tmp1 = tmp2 <NEWLINE> tmp2 = tmp <NEWLINE> <DEDENT> for k in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> tmp1 = k <NEWLINE> tmp3 = tmp2 <NEWLINE> while tmp1 % tmp3 != 0 : <NEWLINE> <INDENT> tmp = tmp1 % tmp3 <NEWLINE> tmp1 = tmp3 <NEWLINE> tmp3 = tmp <NEWLINE> <DEDENT> total += tmp3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> dp = [ [ 0 ] * 2 for _ in range ( n ) ] <NEWLINE> dp [ 0 ] = [ 1 , 0 ] <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 < n : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = max ( dp [ i + 1 ] [ 1 ] , dp [ i ] [ 1 ] + 1 ) <NEWLINE> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = max ( dp [ i + 1 ] [ 0 ] , dp [ i ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> if i + 2 < n : <NEWLINE> <INDENT> dp [ i + 2 ] [ 1 ] = max ( dp [ i + 2 ] [ 0 ] , dp [ i ] [ 0 ] + 1 ) <NEWLINE> if s [ i - 1 : i + 1 ] != s [ i + 1 : i + 3 ] : <NEWLINE> <INDENT> dp [ i + 2 ] [ 1 ] = max ( dp [ i + 2 ] [ 1 ] , dp [ i ] [ 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( dp [ - 1 ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if ( A [ K + i ] > A [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K / 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <NL> <DEDENT> if L % 2 == 0 or L % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = 1 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> rest *= 10 <NEWLINE> ans += 1 <NEWLINE> rest = rest % L <NEWLINE> if rest == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> sumA = 0 <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> sumA += a <NEWLINE> <DEDENT> print ( sumA ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> def factorization ( n ) : <COMMENT> <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> z = factorization ( n ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( z ) ) : <NEWLINE> <INDENT> for j in range ( 1 , z [ i ] + 1 ) : <NEWLINE> <INDENT> if ( z [ i ] - j ) >= 0 : <NEWLINE> <INDENT> z [ i ] -= j <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> <NL> pi = 3.141592653589793 <NEWLINE> print ( pi * r ** 2 , 2 * pi * r ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ca . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( len ( ca ) ) : <NEWLINE> <INDENT> c . append ( ca [ i ] [ 0 ] ) <NEWLINE> a . append ( ca [ i ] ) <NEWLINE> del a [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> ans = 12345678 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> level = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> cost += c [ j ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> level [ k ] += a [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> flag = True <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> if ( level [ k ] < x ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> <DEDENT> if ( ans == 12345678 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> k = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( k ) ) ) <NEWLINE>
from itertools import product <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in product ( range ( 10 ) , repeat = 3 ) : <NEWLINE> <INDENT> a = s . find ( str ( i [ 0 ] ) ) <NEWLINE> if a != - 1 and a != n - 1 : <NEWLINE> <INDENT> b = s [ a + 1 : ] . find ( str ( i [ 1 ] ) ) <NEWLINE> if b != - 1 : <NEWLINE> <INDENT> b += a + 1 <NEWLINE> if b != n - 1 : <NEWLINE> <INDENT> c = s [ b + 1 : ] . find ( str ( i [ 2 ] ) ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> a = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if a [ 0 ] == 0 and a [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( a [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> visited = set ( ) <NEWLINE> <NL> cur = 0 <NEWLINE> visited . add ( 0 ) <NEWLINE> ans = 0 <NEWLINE> while cur != 1 : <NEWLINE> <INDENT> if a [ cur ] not in visited : <NEWLINE> <INDENT> visited . add ( a [ cur ] ) <NEWLINE> cur = a [ cur ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( len ( set ( List ) ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> mods = [ 0 ] * ( len ( s ) ) <NEWLINE> countRemainder = [ 0 ] * 2019 <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> m = 1 <NEWLINE> mod = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> mod += int ( s [ len ( s ) - i - 1 ] ) * m <NEWLINE> <NL> mod %= 2019 <NEWLINE> m *= 10 <NEWLINE> m %= 2019 <NEWLINE> <NL> countRemainder [ mod ] += 1 <NEWLINE> <NL> <DEDENT> countRemainder [ 0 ] += 1 <NEWLINE> <NL> for i in range ( 2019 ) : <NEWLINE> <INDENT> cnt += int ( countRemainder [ i ] * ( countRemainder [ i ] - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) [ : : - 1 ] <NEWLINE> l = len ( s ) <NEWLINE> n = 2019 <NEWLINE> dp = [ 0 ] * n <NEWLINE> wk = 0 <NEWLINE> r = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> wk += int ( s [ i ] ) * r <NEWLINE> wk %= n <NEWLINE> dp [ wk ] += 1 <NEWLINE> r *= 10 <NEWLINE> r %= n <NEWLINE> <DEDENT> print ( dp [ 0 ] + sum ( [ i * ( i - 1 ) // 2 for i in dp ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> x = ni ( ) <NEWLINE> s = [ [ [ ] for j in range ( 26 ) ] for i in range ( 26 ) ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> si = ns ( ) <NEWLINE> sn1 = ord ( si [ 0 : 1 ] ) - 97 <NEWLINE> if len ( si ) == 1 : <NEWLINE> <INDENT> sn2 = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sn2 = ord ( si [ 1 : 2 ] ) - 97 <NEWLINE> <DEDENT> if si not in s [ sn1 ] [ sn2 ] : <NEWLINE> <INDENT> s [ sn1 ] [ sn2 ] . append ( si ) <NEWLINE> <DEDENT> <DEDENT> for s1 in s : <NEWLINE> <INDENT> for s2 in s1 : <NEWLINE> <INDENT> sum += len ( s2 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> amari = [ x ] <NEWLINE> amariset = { x } <NEWLINE> cnt = 0 <NEWLINE> p = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a = amari [ - 1 ] ** 2 % m <NEWLINE> if a in amariset : <NEWLINE> <INDENT> p = amari . index ( a ) <NEWLINE> cnt = i + 1 - p <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari . append ( a ) <NEWLINE> amariset . add ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( sum ( amari ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> n -= len ( amari ) <NEWLINE> a = n // cnt <NEWLINE> b = n % cnt <NEWLINE> print ( sum ( amari ) + a * sum ( amari [ p : ] ) + sum ( amari [ p : ( p + b ) ] ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> move = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> move . append ( ( L , R ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = - 1 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> for l , r in move : <NEWLINE> <INDENT> if i - l >= 0 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - l ] <NEWLINE> <DEDENT> if i - r - 1 >= 0 : <NEWLINE> <INDENT> dp [ i ] -= dp [ i - r - 1 ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] %= MOD <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> N = ir ( ) <NEWLINE> A = lr ( ) <NEWLINE> A . sort ( ) <NEWLINE> bl = np . array ( [ True ] * ( A [ - 1 ] + 1 ) , dtype = np . bool ) <NEWLINE> answer = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i < N - 1 and A [ i + 1 ] == a : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif bl [ a ] : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> if bl [ a ] : <NEWLINE> <INDENT> bl [ a : : a ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * ( n ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if ( self . parents [ x ] < 0 ) : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if ( x == y ) : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if ( self . parents [ x ] > self . parents [ y ] ) : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = Unionfind ( n ) <NEWLINE> <NL> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> from bisect import bisect_left <NEWLINE> ans = 0 <NEWLINE> for i1 in range ( N - 2 ) : <NEWLINE> <INDENT> for i2 in range ( i1 + 1 , N - 1 ) : <NEWLINE> <INDENT> l1 , l2 = L [ i1 ] , L [ i2 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> th = bisect_left ( L , l1 + l2 ) <NEWLINE> ans += max ( th - i2 - 1 , 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ a [ i ] , 1 ] ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( [ c , b ] ) <NEWLINE> <NL> <DEDENT> A . extend ( l ) <NEWLINE> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> B = [ ] <NEWLINE> <NL> j = 0 <NEWLINE> cnt = - 1 <NEWLINE> while cnt < n : <NEWLINE> <INDENT> B . extend ( [ A [ j ] [ 0 ] ] * A [ j ] [ 1 ] ) <NEWLINE> cnt = cnt + A [ j ] [ 1 ] <NEWLINE> if cnt >= n : <NEWLINE> <INDENT> del B [ n : ] <NEWLINE> <DEDENT> j = j + 1 <NEWLINE> <NL> <DEDENT> print ( sum ( B ) ) <NEWLINE>
from itertools import combinations <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> zen = sum ( A ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> part = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> part += A [ i ] <NEWLINE> ans += A [ i ] * ( zen - part ) <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> dx = abs ( x1 - x2 ) <NEWLINE> dy = abs ( y1 - y2 ) <NEWLINE> print ( math . sqrt ( dx * dx + dy * dy ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list1 = alist [ 1 : : 2 ] <NEWLINE> list2 = alist [ 0 : : 2 ] <NEWLINE> from collections import Counter <NEWLINE> dic1 = Counter ( list1 ) . most_common ( ) <NEWLINE> dic2 = Counter ( list2 ) . most_common ( ) <NEWLINE> dic1 . append ( [ 0 , 0 ] ) <NEWLINE> dic2 . append ( [ 0 , 0 ] ) <NEWLINE> if dic1 [ 0 ] [ 0 ] != dic2 [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( n - dic1 [ 0 ] [ 1 ] - dic2 [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n - dic1 [ 0 ] [ 1 ] - dic2 [ 1 ] [ 1 ] , n - dic1 [ 1 ] [ 1 ] - dic2 [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import ChainMap <NEWLINE> input ( ) <NEWLINE> rp = sys . stdin . readlines ( ) <NEWLINE> cm = ChainMap ( ) <NEWLINE> <NL> for i in rp : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> cm [ i [ 7 : ] ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i [ 5 : ] in cm : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> ans = [ 0 ] * 10001 <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a <= 10000 : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> quo = n // ( a + b ) <NEWLINE> <NL> <COMMENT> <NL> if n % ( a + b ) == 0 : <NEWLINE> <INDENT> rem = 0 <NEWLINE> <DEDENT> elif 1 <= n % ( a + b ) <= a : <NEWLINE> <INDENT> rem = n % ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rem = a <NEWLINE> <NL> <DEDENT> print ( quo * a + rem ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> T = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> t = x <NEWLINE> x = y <NEWLINE> y = t <NEWLINE> <NL> <DEDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( T [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = T [ 0 ] * T [ 1 ] // gcd ( T [ 0 ] , T [ 1 ] ) <NEWLINE> <NL> if N > 2 : <NEWLINE> <INDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> r = res * T [ i ] // gcd ( res , T [ i ] ) <NEWLINE> res = max ( r , res ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( a == 1 ) : <NEWLINE> <INDENT> ans += K * K <NEWLINE> continue <NEWLINE> <DEDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = gcd ( a , b ) <NEWLINE> if ( t == 1 ) : <NEWLINE> <INDENT> ans += K <NEWLINE> continue <NEWLINE> <DEDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> for x in range ( 1000 + 1 ) : <NEWLINE> <INDENT> if int ( x * ( 8 / 100 ) ) == A and int ( x * ( 10 / 100 ) ) == B : <NEWLINE> <INDENT> ans = x <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if k == 1 : exit ( print ( A [ 0 ] ) ) <NEWLINE> t = 0 <NEWLINE> dp = [ - 1 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> flg = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = A [ t ] - 1 <NEWLINE> if dp [ t ] != - 1 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> dp [ t ] = i <NEWLINE> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> exit ( print ( t + 1 ) ) <NEWLINE> <DEDENT> elif k == 2 : <NEWLINE> <INDENT> exit ( print ( t + 1 ) ) <NEWLINE> <NL> <DEDENT> l = i - dp [ t ] <NEWLINE> K = ( k - dp [ t ] ) % l + dp [ t ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ i ] == K : exit ( print ( i + 1 ) ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n + sum ( n // i * ( i + n - n % i ) // 2 for i in range ( 1 , n ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( int ( x / 3600 ) , int ( ( x % 3600 ) / 60 ) , x % 60 , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = 7 <NEWLINE> plus = 7 <NEWLINE> amari = set ( ) <NEWLINE> r = 1 <NEWLINE> while ( p % k ) != 0 : <NEWLINE> <INDENT> if p in amari : <NEWLINE> <INDENT> print ( r , - 1 , p ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari . add ( p ) <NEWLINE> plus = ( plus * 10 ) % k <NEWLINE> p += plus <NEWLINE> p = p % k <NEWLINE> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m_s = [ ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> m_s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> mini = min ( a_s ) + min ( b_s ) <NEWLINE> <NL> for am , bm , sale in m_s : <NEWLINE> <INDENT> mini = min ( mini , a_s [ am - 1 ] + b_s [ bm - 1 ] - sale ) <NEWLINE> <NL> <DEDENT> print ( mini ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ma = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ma [ a - 1 ] = max ( h [ b - 1 ] , ma [ a - 1 ] ) <NEWLINE> ma [ b - 1 ] = max ( h [ a - 1 ] , ma [ b - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > ma [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from decimal import Decimal <NEWLINE> <NL> INF = 1 << 50 <NEWLINE> <NL> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( sysread ( ) ) <NEWLINE> A = [ Decimal ( input ( ) ) for _ in range ( N ) ] <NEWLINE> M = [ [ 0 ] * 19 for _ in range ( 19 ) ] <NEWLINE> <COMMENT> <NL> minus = 0 <NEWLINE> <NL> MULT = 10 ** 9 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a == int ( a ) : <NEWLINE> <INDENT> minus += 1 <NEWLINE> <DEDENT> a *= MULT <NEWLINE> a = int ( a ) <NEWLINE> <NL> <COMMENT> <NL> f2 = 0 <NEWLINE> f5 = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if not a % 2 : <NEWLINE> <INDENT> f2 += 1 <NEWLINE> a = a // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> if not a % 5 : <NEWLINE> <INDENT> f5 += 1 <NEWLINE> a = a // 5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> A [ i ] = ( min ( f2 , 18 ) , min ( f5 , 18 ) ) <NEWLINE> M [ min ( f2 , 18 ) ] [ min ( f5 , 18 ) ] += 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 18 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 18 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> M [ i - 1 ] [ j ] += M [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 18 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 18 , - 1 , - 1 ) : <NEWLINE> <INDENT> if j > 0 : <NEWLINE> <INDENT> M [ i ] [ j - 1 ] += M [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for f2 , f5 in A : <NEWLINE> <INDENT> ans += M [ max ( 18 - f2 , 0 ) ] [ max ( 18 - f5 , 0 ) ] <NEWLINE> <NL> <DEDENT> print ( ( ans - minus ) // 2 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> from fractions import gcd <NEWLINE> [ print ( <STRING> . format ( gcd ( k [ 0 ] , k [ 1 ] ) , ( k [ 0 ] * k [ 1 ] ) // gcd ( k [ 0 ] , k [ 1 ] ) ) ) for i in sys . stdin for k in [ [ int ( j ) for j in i . split ( ) ] ] ] <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> class Edge : <NEWLINE> <INDENT> def __init__ ( self , inputs ) : <NEWLINE> <INDENT> start , end , self . dist = [ int ( i ) for i in inputs ] <NEWLINE> self . nodes = [ start , end ] <NEWLINE> <NL> <DEDENT> def isConnect ( self , node ) : <NEWLINE> <INDENT> return node in self . nodes <NEWLINE> <NL> <DEDENT> def other_side ( self , node ) : <NEWLINE> <INDENT> if self . nodes [ 0 ] == node : <NEWLINE> <INDENT> return self . nodes [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . nodes [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . nodes [ 0 ] , self . nodes [ 1 ] , self . dist ) <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_cost ( list , tickets ) : <NEWLINE> <INDENT> s_list = sorted ( list , reverse = True ) <NEWLINE> return sum ( c / t for c , t in zip ( s_list , tickets ) ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , m , p , a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> if n == m == p == a == b == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <NL> <DEDENT> tickets = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> <NL> e = defaultdict ( list ) <NEWLINE> <NL> for i in range ( p ) : <NEWLINE> <INDENT> start , end , cost = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> e [ start ] . append ( ( end , cost ) ) <NEWLINE> e [ end ] . append ( ( start , cost ) ) <NEWLINE> <NL> <DEDENT> m_cost = defaultdict ( lambda : float ( <STRING> ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> result = ( a , [ a ] , [ ] , float ( <STRING> ) ) <NEWLINE> <NL> if p == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> q = [ ( e [ 0 ] , [ a , e [ 0 ] ] , [ e [ 1 ] ] , calc_cost ( [ e [ 1 ] ] , tickets ) ) for e in e [ a ] ] <NEWLINE> <NL> while len ( q ) != 0 : <NEWLINE> <INDENT> now = q . pop ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if len ( now [ 1 ] ) - 1 > n : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if m_cost [ now [ 0 ] ] < now [ 3 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_cost [ now [ 0 ] ] = now [ 3 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if now [ 0 ] == b and now [ 3 ] < result [ 3 ] : <NEWLINE> <INDENT> result = now <NEWLINE> <NL> <DEDENT> q . extend ( [ ( e [ 0 ] , now [ 1 ] + [ e [ 0 ] ] , now [ 2 ] + [ e [ 1 ] ] , calc_cost ( now [ 2 ] + [ e [ 1 ] ] , tickets ) ) <NEWLINE> <INDENT> for e in e [ now [ 0 ] ] if e [ 0 ] not in now [ 1 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if result [ 0 ] == b : <NEWLINE> <INDENT> print ( result [ 3 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> X = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H [ A [ 0 ] - 1 ] < H [ A [ 1 ] - 1 ] : <NEWLINE> <INDENT> X . append ( A [ 0 ] ) <NEWLINE> <DEDENT> elif H [ A [ 0 ] - 1 ] > H [ A [ 1 ] - 1 ] : <NEWLINE> <INDENT> X . append ( A [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X . append ( A [ 0 ] ) <NEWLINE> X . append ( A [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - len ( set ( X ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> dd = 0 , 1 , 0 , - 1 <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> def dist ( sr , sc ) : <NEWLINE> <INDENT> if G [ sr ] [ sc ] == <STRING> : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> memo = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> <NL> dq = deque ( ) <NEWLINE> dq . append ( ( sr , sc , 0 ) ) <NEWLINE> memo [ sr ] [ sc ] = 0 <NEWLINE> while dq : <NEWLINE> <INDENT> r , c , d = dq . popleft ( ) <NEWLINE> nd = d + 1 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nr = r + dd [ i ] <NEWLINE> nc = c + dd [ i ^ 1 ] <NEWLINE> if not ( 0 <= nr < H and 0 <= nc < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ~ memo [ nr ] [ nc ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if G [ nr ] [ nc ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dq . append ( ( nr , nc , nd ) ) <NEWLINE> memo [ nr ] [ nc ] = nd <NEWLINE> <NL> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for sr in range ( H ) : <NEWLINE> <INDENT> for sc in range ( W ) : <NEWLINE> <INDENT> ans = max ( ans , dist ( sr , sc ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> dq = deque ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> order = input ( ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( order [ 7 : ] ) <NEWLINE> <DEDENT> elif order [ 6 ] == <STRING> : <NEWLINE> <INDENT> key = order . split ( ) [ 1 ] <NEWLINE> if not key in dq : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( len ( dq ) ) : <NEWLINE> <INDENT> if dq [ i ] == key : <NEWLINE> <INDENT> dq . remove ( key ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif order [ 6 ] == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> elif order [ 6 ] == <STRING> : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( dq ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <NL> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if A > K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A <= K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - 1 * ( K - A - B ) ) <NEWLINE> <DEDENT> <DEDENT>
n , X = open ( 0 ) . read ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> x = int ( X , 2 ) <NEWLINE> X = list ( map ( int , X ) ) <NEWLINE> <NL> def popcount ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> ma = 2 * 10 ** 5 + 1 <NEWLINE> dp = [ 0 ] * ma <NEWLINE> for i in range ( 1 , ma ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i % popcount ( i ) ] + 1 <NEWLINE> <NL> <DEDENT> c = popcount ( x ) <NEWLINE> a = x % ( c + 1 ) <NEWLINE> if c == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ ( a + pow ( 2 , n - i - 1 , c + 1 ) ) % ( c + 1 ) ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b = x % ( c - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] : <NEWLINE> <INDENT> print ( dp [ ( b - pow ( 2 , n - i - 1 , c - 1 ) ) % ( c - 1 ) ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ ( a + pow ( 2 , n - i - 1 , c + 1 ) ) % ( c + 1 ) ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n_max = 10 ** 5 + 10 <NEWLINE> sieve = [ 0 , 0 ] + [ 1 ] * n_max <NEWLINE> m = 2 <NEWLINE> while m * m <= n_max : <NEWLINE> <INDENT> if sieve [ m ] : <NEWLINE> <INDENT> for n in range ( 2 * m , n_max , m ) : <NEWLINE> <INDENT> sieve [ n ] = 0 <NEWLINE> <DEDENT> <DEDENT> m += 1 <NEWLINE> <NL> <DEDENT> ok = [ 0 ] * n_max <NEWLINE> cums = [ 0 ] <NEWLINE> for n in range ( n_max ) : <NEWLINE> <INDENT> if sieve [ n ] and sieve [ ( n + 1 ) // 2 ] : <NEWLINE> <INDENT> ok [ n ] = 1 <NEWLINE> <DEDENT> cums . append ( cums [ - 1 ] + ok [ n ] ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cums [ r + 1 ] - cums [ l ] ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> search_max = int ( sqrt ( N ) ) <NEWLINE> <NL> min_number = 10 ** 12 <NEWLINE> for x in range ( 1 , search_max + 1 ) : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> y = N // x <NEWLINE> if x + y < min_number : <NEWLINE> <INDENT> min_number = x + y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min_number - 2 ) <NEWLINE>
times = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> <NL> rem = float ( <STRING> ) <NEWLINE> last = 0 <NEWLINE> for time in times : <NEWLINE> <INDENT> if time % 10 < rem and time % 10 != 0 : <NEWLINE> <INDENT> rem = time % 10 <NEWLINE> last = time <NEWLINE> <DEDENT> <DEDENT> if last : <NEWLINE> <INDENT> times . remove ( last ) <NEWLINE> <NL> <DEDENT> total_time = 0 <NEWLINE> for time in times : <NEWLINE> <INDENT> if time % 10 == 0 : <NEWLINE> <INDENT> total_time += time <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total_time += time + ( 10 - time % 10 ) <NEWLINE> <DEDENT> <DEDENT> total_time += last <NEWLINE> <NL> print ( total_time ) <NEWLINE>
LIMIT = 10000000 <NEWLINE> <NL> isPrime = [ True for _ in range ( LIMIT ) ] <NEWLINE> <NL> isPrime [ 0 ] = isPrime [ 1 ] = False <NEWLINE> <NL> for i in range ( 2 , int ( LIMIT ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if isPrime [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , LIMIT , i ) : <NEWLINE> <INDENT> isPrime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> count = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if isPrime [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if a [ 0 ] == a [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * a [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if abs ( ans ) > 10 ** 9 + 7 : <NEWLINE> <INDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif all ( i <= 0 for i in a ) and k % 2 == 1 : <NEWLINE> <INDENT> a . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if abs ( ans ) > 10 ** 9 + 7 : <NEWLINE> <INDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> am = [ ] <NEWLINE> ap = [ ] <NEWLINE> <NL> a . sort ( key = abs , reverse = True ) <NEWLINE> amax = a [ : k ] <NEWLINE> amin = a [ k : ] <NEWLINE> c = 1 <NEWLINE> if 0 in amax : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in amax : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> am . append ( i ) <NEWLINE> c *= - 1 <NEWLINE> <DEDENT> elif i > 0 : <NEWLINE> <INDENT> ap . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> for i in amax : <NEWLINE> <INDENT> ans *= i <NEWLINE> if abs ( ans ) > 10 ** 9 + 7 : <NEWLINE> <INDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ap == [ ] : <NEWLINE> <INDENT> amax . remove ( max ( am ) ) <NEWLINE> amax . append ( max ( amin ) ) <NEWLINE> <NL> <DEDENT> elif max ( am ) * min ( amin ) < min ( ap ) * max ( amin ) : <NEWLINE> <INDENT> amax . remove ( max ( am ) ) <NEWLINE> amax . append ( max ( amin ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amax . remove ( min ( ap ) ) <NEWLINE> amax . append ( min ( amin ) ) <NEWLINE> <DEDENT> for i in amax : <NEWLINE> <INDENT> ans *= i <NEWLINE> if abs ( ans ) > 10 ** 9 + 7 : <NEWLINE> <INDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> vmax = sum ( [ a [ i ] [ 1 ] for i in range ( N ) ] ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> dp = np . full ( vmax + 1 , INF ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = a [ i - 1 ] <NEWLINE> dp [ v : ] = np . minimum ( dp [ v : ] , dp [ : - v ] + w ) <NEWLINE> <DEDENT> print ( max ( [ i for i in range ( vmax + 1 ) if dp [ i ] <= W ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a *= A [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dict = { } <NEWLINE> for num in range ( a ) : <NEWLINE> <INDENT> dict [ num ] = 0 <NEWLINE> <NL> <DEDENT> for num2 in range ( len ( i ) ) : <NEWLINE> <INDENT> dict [ i [ num2 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for num in range ( a ) : <NEWLINE> <INDENT> print ( dict [ num ] ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ x * ( - 1 ) for x in a ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> c = ( heapq . heappop ( a ) * ( - 1 ) // 2 ) * ( - 1 ) <NEWLINE> heapq . heappush ( a , c ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE> <NL>
count = [ [ [ 0 ] * 11 for j in range ( 4 ) ] for i in range ( 5 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 1 , 5 ) : <NEWLINE> <INDENT> if b >= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for f in range ( 1 , 4 ) : <NEWLINE> <INDENT> for r in range ( 1 , 11 ) : <NEWLINE> <INDENT> print ( <STRING> , count [ b ] [ f ] [ r ] , end = <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for p in range ( 10 ) : <NEWLINE> <INDENT> s = S . find ( str ( p ) ) <NEWLINE> if s == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for q in range ( 10 ) : <NEWLINE> <INDENT> t = S . find ( str ( q ) , s + 1 ) <NEWLINE> if t == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> u = S . find ( str ( r ) , t + 1 ) <NEWLINE> if u != - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> rgb_idx = { <NEWLINE> <INDENT> <STRING> : [ ] , <NEWLINE> <STRING> : [ ] , <NEWLINE> <STRING> : [ ] , <NEWLINE> <DEDENT> } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rgb_idx [ <STRING> ] . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> rgb_idx [ <STRING> ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rgb_idx [ <STRING> ] . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( rgb_idx [ <STRING> ] ) ) : <NEWLINE> <INDENT> for j in range ( len ( rgb_idx [ <STRING> ] ) ) : <NEWLINE> <INDENT> ans += len ( rgb_idx [ <STRING> ] ) <NEWLINE> <NL> rnum = rgb_idx [ <STRING> ] [ i ] <NEWLINE> gnum = rgb_idx [ <STRING> ] [ j ] <NEWLINE> if gnum - rnum > 0 : <NEWLINE> <INDENT> g = gnum <NEWLINE> l = rnum <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = rnum <NEWLINE> l = gnum <NEWLINE> <DEDENT> dist = abs ( gnum - rnum ) <NEWLINE> if n > g + dist and s [ g + dist ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 0 <= l - dist and s [ l - dist ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ( g + l ) % 2 == 0 and s [ int ( ( g + l ) / 2 ) ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <NL> class Board : <NEWLINE> <INDENT> def __init__ ( self , size , nums ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . nums = nums <NEWLINE> self . code = self . _code ( ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> return self . code == other . code <NEWLINE> <NL> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . code < other . code <NEWLINE> <NL> <DEDENT> def __gt__ ( self , other ) : <NEWLINE> <INDENT> return self . code > other . code <NEWLINE> <NL> <DEDENT> def __hash__ ( self ) : <NEWLINE> <INDENT> nums = tuple ( self . nums [ i ] [ j ] <NEWLINE> <INDENT> for i in range ( self . size ) <NEWLINE> for j in range ( self . size ) ) <NEWLINE> <DEDENT> return hash ( nums ) <NEWLINE> <NL> <DEDENT> def same ( self , other ) : <NEWLINE> <INDENT> if other is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . __class__ != other . __class__ : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( self . size ) : <NEWLINE> <INDENT> for j in range ( self . size ) : <NEWLINE> <INDENT> if self . nums [ i ] [ j ] != other . nums [ i ] [ j ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solved ( self ) : <NEWLINE> <INDENT> for i in range ( self . size ) : <NEWLINE> <INDENT> for j in range ( self . size ) : <NEWLINE> <INDENT> if ( i , j ) != self . _validpos ( self . nums [ i ] [ j ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def _validpos ( self , num ) : <NEWLINE> <INDENT> if num > 0 : <NEWLINE> <INDENT> return ( ( num - 1 ) // self . size , ( num - 1 ) % self . size ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( self . size - 1 , self . size - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def _code ( self ) : <NEWLINE> <INDENT> code = 0 <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> for j in range ( self . size ) : <NEWLINE> <INDENT> if self . nums [ i ] [ j ] != 0 : <NEWLINE> <INDENT> vi , vj = self . _validpos ( self . nums [ i ] [ j ] ) <NEWLINE> code += abs ( vi - i ) + abs ( vj - j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return code <NEWLINE> <NL> <DEDENT> def find ( self , num ) : <NEWLINE> <INDENT> for i in range ( self . size ) : <NEWLINE> <INDENT> for j in range ( self . size ) : <NEWLINE> <INDENT> if self . nums [ i ] [ j ] == num : <NEWLINE> <INDENT> return ( i , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> raise IndexError ( ) <NEWLINE> <NL> <DEDENT> def move ( self , p1 , p2 ) : <NEWLINE> <INDENT> i1 , j1 = p1 <NEWLINE> i2 , j2 = p2 <NEWLINE> nums = deepcopy ( self . nums ) <NEWLINE> nums [ i1 ] [ j1 ] , nums [ i2 ] [ j2 ] = nums [ i2 ] [ j2 ] , nums [ i1 ] [ j1 ] <NEWLINE> return self . __class__ ( self . size , nums ) <NEWLINE> <NL> <DEDENT> def moves ( self ) : <NEWLINE> <INDENT> i , j = self . find ( 0 ) <NEWLINE> if i > 0 : <NEWLINE> <INDENT> yield self . move ( ( i , j ) , ( i - 1 , j ) ) <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> yield self . move ( ( i , j ) , ( i , j - 1 ) ) <NEWLINE> <DEDENT> if i < self . size - 1 : <NEWLINE> <INDENT> yield self . move ( ( i , j ) , ( i + 1 , j ) ) <NEWLINE> <DEDENT> if j < self . size - 1 : <NEWLINE> <INDENT> yield self . move ( ( i , j ) , ( i , j + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> for j in range ( self . size ) : <NEWLINE> <INDENT> s += <STRING> . format ( self . nums [ i ] [ j ] ) <NEWLINE> <DEDENT> s += <STRING> <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class EightPuzzle : <NEWLINE> <INDENT> def __init__ ( self , board ) : <NEWLINE> <INDENT> self . board = Board ( 3 , board ) <NEWLINE> self . steps = 0 <NEWLINE> <NL> if not self . board . solved ( ) : <NEWLINE> <INDENT> self . _solve ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def _solve ( self ) : <NEWLINE> <INDENT> bs = [ ] <NEWLINE> checked = { } <NEWLINE> heappush ( bs , ( self . board . code , self . board , 0 ) ) <NEWLINE> <NL> while len ( bs ) > 0 : <NEWLINE> <INDENT> w , b , step = heappop ( bs ) <NEWLINE> if 0 < self . steps <= step : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> checked [ b ] = step <NEWLINE> for nb in b . moves ( ) : <NEWLINE> <INDENT> if nb . solved ( ) : <NEWLINE> <INDENT> self . steps = step + 1 <NEWLINE> return <NEWLINE> <DEDENT> elif nb in checked and checked [ nb ] <= step : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heappush ( bs , ( nb . code + step + 1 , nb , step + 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> board = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> board . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> eight_puzzle = EightPuzzle ( board ) <NEWLINE> print ( eight_puzzle . steps ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> m *= a <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if min ( A ) == 0 : <NEWLINE> <INDENT> m = 0 <NEWLINE> <DEDENT> print ( m if m <= 10 ** 18 else - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> S = SS ( ) <NEWLINE> <NL> <COMMENT> <NL> l = [ ] <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> l . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> l . append ( i + 1 ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> l . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> l . append ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( N ) <NEWLINE> l . append ( N ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> if len ( l ) // 2 - 1 < K : <NEWLINE> <INDENT> ans = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( l ) // 2 - K ) : <NEWLINE> <INDENT> ans = max ( l [ 2 * i + 2 * K + 1 ] - l [ 2 * i ] , ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = int ( 1e9 ) + 7 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = pow ( 10 , n , mod ) - ( 2 * pow ( 9 , n , mod ) - pow ( 8 , n , mod ) ) <NEWLINE> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = 0 <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp += A [ i ] <NEWLINE> sum_a += tmp * A [ i + 1 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = sum_a % 1000000007 <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> dic = set ( ) <NEWLINE> pos = defaultdict ( lambda : [ ] ) <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> heappush ( pos [ s ] , S [ i : ] ) <NEWLINE> <DEDENT> base = <STRING> <NEWLINE> <NL> for l in base : <NEWLINE> <INDENT> while pos [ l ] : <NEWLINE> <INDENT> sub = heappop ( pos [ l ] ) <NEWLINE> for i in range ( 1 , len ( sub ) + 1 ) : <NEWLINE> <INDENT> dic . add ( sub [ : i ] ) <NEWLINE> <NL> <DEDENT> if len ( dic ) >= K : <NEWLINE> <INDENT> dic = sorted ( list ( dic ) ) <NEWLINE> print ( dic [ K - 1 ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ap = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ap [ i - a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += ap [ a [ i ] + i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> r = [ ] <NEWLINE> check = [ 0 ] * len ( a ) <NEWLINE> now = 1 <NEWLINE> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> r . append ( now ) <NEWLINE> now = a [ now - 1 ] <NEWLINE> <NL> if check [ now - 1 ] == 1 : <NEWLINE> <INDENT> roop = r [ r . index ( now ) : ] <NEWLINE> break <NEWLINE> <DEDENT> check [ now - 1 ] += 1 <NEWLINE> <NL> <DEDENT> if len ( r ) - 1 >= k : <COMMENT> <NEWLINE> <INDENT> print ( r [ k ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> print ( roop [ ( k - len ( r ) ) % len ( roop ) ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> group = [ [ ] ] <NEWLINE> g = [ ] <NEWLINE> l = [ ] <NEWLINE> init = 0 <NEWLINE> indice = 0 <NEWLINE> group_num = 0 <NEWLINE> ind = [ - 1 ] * N <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if S [ k ] == <STRING> : <NEWLINE> <INDENT> group [ group_num ] . append ( k ) <NEWLINE> ind [ k ] = indice <NEWLINE> indice += 1 <NEWLINE> g . append ( group_num ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not init : <NEWLINE> <INDENT> l . append ( indice - 1 ) <NEWLINE> init = 1 <NEWLINE> <DEDENT> if k < N - 1 and S [ k + 1 ] == <STRING> : <NEWLINE> <INDENT> group [ group_num ] . append ( k ) <NEWLINE> g . append ( group_num ) <NEWLINE> group_num += 1 <NEWLINE> group . append ( [ ] ) <NEWLINE> init = 0 <NEWLINE> ind [ k ] = indice <NEWLINE> indice = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> group [ group_num ] . append ( k ) <NEWLINE> g . append ( group_num ) <NEWLINE> ind [ k ] = indice <NEWLINE> indice += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ret = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> _l = l [ g [ i ] ] <NEWLINE> indice = ind [ i ] <NEWLINE> if indice <= _l : <NEWLINE> <INDENT> tmp = group [ g [ i ] ] [ _l + ( _l - indice ) % 2 ] <NEWLINE> ret [ tmp ] += 1 <NEWLINE> <DEDENT> if indice >= _l + 1 : <NEWLINE> <INDENT> tmp = group [ g [ i ] ] [ _l + ( _l - indice ) % 2 ] <NEWLINE> ret [ tmp ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in ret ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> Sum = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Sum = Sum - a [ i ] <NEWLINE> ans = ans + a [ i ] * Sum <NEWLINE> <DEDENT> if ans > 10 ** 9 : <NEWLINE> <INDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> li = [ ] <NEWLINE> ans = 100000000000000000000000000000000 <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . append ( a ) <NEWLINE> <NL> <DEDENT> for k in range ( 2 ** N ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> skill = [ 0 ] * M <NEWLINE> k = str ( bin ( k ) ) <NEWLINE> k = k [ 2 : ] <NEWLINE> while len ( k ) != N : <NEWLINE> <INDENT> k = <STRING> + k <NEWLINE> <DEDENT> for l in range ( N ) : <NEWLINE> <INDENT> if k [ l ] == <STRING> : <NEWLINE> <INDENT> temp += li [ l ] [ 0 ] <NEWLINE> for m in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> skill [ m - 1 ] += li [ l ] [ m ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( skill ) >= X : <NEWLINE> <INDENT> if ans > temp : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 100000000000000000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
[ n , q ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> max_idx = 0 <NEWLINE> max_val = 0 <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> [ a , v ] = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ a - 1 ] += v <NEWLINE> <NL> if max_idx == a - 1 : <NEWLINE> <INDENT> if v > 0 : <NEWLINE> <INDENT> max_val = t [ a - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_val = max ( t ) <NEWLINE> max_idx = t . index ( max_val ) <NEWLINE> <DEDENT> <DEDENT> elif t [ a - 1 ] > max_val : <NEWLINE> <INDENT> max_val = t [ a - 1 ] <NEWLINE> max_idx = a - 1 <NEWLINE> <DEDENT> elif t [ a - 1 ] == max_val : <NEWLINE> <INDENT> if a - 1 < max_idx : <NEWLINE> <INDENT> max_val = t [ a - 1 ] <NEWLINE> max_idx = a - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( max_idx + 1 , max_val ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> LineData = np . int64 ( sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> <NL> LineData = LineData . reshape ( - 1 , 3 ) <NEWLINE> A , B , C = LineData [ : N ] . T <NEWLINE> D , E , F = LineData [ N : ] . T <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> X = np . unique ( np . concatenate ( [ D , [ - INF , INF ] ] ) ) <NEWLINE> Y = np . unique ( np . concatenate ( [ C , [ - INF , INF ] ] ) ) <NEWLINE> A = np . searchsorted ( X , A ) <NEWLINE> B = np . searchsorted ( X , B , <STRING> ) - 1 <NEWLINE> C = np . searchsorted ( Y , C ) <NEWLINE> D = np . searchsorted ( X , D ) <NEWLINE> E = np . searchsorted ( Y , E ) <NEWLINE> F = np . searchsorted ( Y , F , <STRING> ) - 1 <NEWLINE> <NL> area = cal_area ( A , B , C , D , E , F , X , Y ) <NEWLINE> <NL> if area == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( area ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def cal_area ( A , B , C , D , E , F , X , Y ) : <NEWLINE> <INDENT> x = np . searchsorted ( X , 0 , <STRING> ) - 1 <NEWLINE> y = np . searchsorted ( Y , 0 , <STRING> ) - 1 <NEWLINE> <NL> DX = X [ 1 : ] - X [ : - 1 ] <NEWLINE> DY = Y [ 1 : ] - Y [ : - 1 ] <NEWLINE> <NL> A = A . tolist ( ) <NEWLINE> B = B . tolist ( ) <NEWLINE> C = C . tolist ( ) <NEWLINE> D = D . tolist ( ) <NEWLINE> E = E . tolist ( ) <NEWLINE> F = F . tolist ( ) <NEWLINE> X = X . tolist ( ) <NEWLINE> Y = Y . tolist ( ) <NEWLINE> DX = DX . tolist ( ) <NEWLINE> DY = DY . tolist ( ) <NEWLINE> <NL> LenX = len ( X ) <NEWLINE> LenY = len ( Y ) <NEWLINE> <NL> visit = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> visit [ x ] [ y ] = True <NEWLINE> area = 0 <NEWLINE> queue = [ ( x , y ) ] <NEWLINE> <NL> LineX = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> LineY = [ [ False ] * LenY for _ in range ( LenX ) ] <NEWLINE> <NL> for x1 , x2 , y in zip ( A , B , C ) : <NEWLINE> <INDENT> for x in range ( x1 , x2 ) : <NEWLINE> <INDENT> LineY [ x ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for x , y1 , y2 in zip ( D , E , F ) : <NEWLINE> <INDENT> for y in range ( y1 , y2 ) : <NEWLINE> <INDENT> LineX [ x ] [ y ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> while queue : <NEWLINE> <INDENT> x , y = queue . pop ( ) <NEWLINE> <NL> if x == 0 or x == LenX - 1 or y == 0 or y == LenY - 1 : <NEWLINE> <INDENT> area = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> area += DX [ x ] * DY [ y ] <NEWLINE> <NL> if not LineX [ x ] [ y ] and not visit [ x - 1 ] [ y ] : <NEWLINE> <INDENT> visit [ x - 1 ] [ y ] = True <NEWLINE> queue . append ( ( x - 1 , y ) ) <NEWLINE> <DEDENT> if not LineY [ x ] [ y ] and not visit [ x ] [ y - 1 ] : <NEWLINE> <INDENT> visit [ x ] [ y - 1 ] = True <NEWLINE> queue . append ( ( x , y - 1 ) ) <NEWLINE> <DEDENT> if not LineX [ x + 1 ] [ y ] and not visit [ x + 1 ] [ y ] : <NEWLINE> <INDENT> visit [ x + 1 ] [ y ] = True <NEWLINE> queue . append ( ( x + 1 , y ) ) <NEWLINE> <DEDENT> if not LineY [ x ] [ y + 1 ] and not visit [ x ] [ y + 1 ] : <NEWLINE> <INDENT> visit [ x ] [ y + 1 ] = True <NEWLINE> queue . append ( ( x , y + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return area <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> sys . exit ( ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> tmp = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> cnt += math . gcd ( tmp , c ) <NEWLINE> <DEDENT> elif a != b != c != a : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> cnt += 6 * math . gcd ( tmp , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> cnt += 3 * math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> comb = [ 1 ] * ( n - k + 1 ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> comb [ i + 1 ] = ( comb [ i ] * ( k + i ) * pow ( i + 1 , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> f = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> f = ( f + a [ k + i - 1 ] * comb [ i ] % mod ) % mod <NEWLINE> f = ( f - a [ i ] * comb [ - 1 - i ] % mod ) % mod <NEWLINE> <DEDENT> print ( f ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> lst = [ 0 for i in range ( 2019 ) ] <NEWLINE> lst [ 0 ] = 1 <NEWLINE> <NL> amari = 0 <NEWLINE> tmp = 1 <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> amari = ( amari + int ( s [ - i ] ) * tmp ) % 2019 <NEWLINE> lst [ amari ] += 1 <NEWLINE> tmp = ( tmp * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> num = lst [ i ] <NEWLINE> ans += num * ( num - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> from dataclasses import dataclass , field <NEWLINE> from typing import List <NEWLINE> <NL> <NL> @ dataclass <NEWLINE> class Cell : <NEWLINE> <INDENT> i : int <NEWLINE> j : int <NEWLINE> color : str <NEWLINE> <NL> def to_red ( self ) : <NEWLINE> <INDENT> return Cell ( self . i , self . j , color = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ dataclass <NEWLINE> class Board : <NEWLINE> <INDENT> cells : List [ Cell ] = field ( default_factory = list ) <NEWLINE> count : int = 0 <NEWLINE> <NL> @ classmethod <NEWLINE> def create ( cls , H : int , W : int , C : List [ List [ str ] ] ) : <NEWLINE> <INDENT> cells = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> cell = Cell ( i + 1 , j + 1 , C [ i ] [ j ] ) <NEWLINE> cells . append ( cell ) <NEWLINE> <NL> <DEDENT> <DEDENT> return Board ( cells ) <NEWLINE> <NL> <DEDENT> def count_black ( self ) -> int : <NEWLINE> <INDENT> return len ( [ c for c in self . cells if c . color == <STRING> ] ) <NEWLINE> <NL> <DEDENT> def paint_row ( self , row : int ) : <NEWLINE> <INDENT> new_cells = [ ] <NEWLINE> <NL> for cell in self . cells : <NEWLINE> <INDENT> if cell . i == row : <NEWLINE> <INDENT> new_cells . append ( cell . to_red ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_cells . append ( cell ) <NEWLINE> <NL> <DEDENT> <DEDENT> return Board ( new_cells ) <NEWLINE> <NL> <DEDENT> def paint_col ( self , col : int ) : <NEWLINE> <INDENT> new_cells = [ ] <NEWLINE> <NL> for cell in self . cells : <NEWLINE> <INDENT> if cell . j == col : <NEWLINE> <INDENT> new_cells . append ( cell . to_red ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_cells . append ( cell ) <NEWLINE> <NL> <DEDENT> <DEDENT> return Board ( new_cells ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def actual ( H , W , K , C ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> patterns = list ( itertools . product ( range ( 2 ) , repeat = H + W ) ) <NEWLINE> <NL> for pattern in patterns : <NEWLINE> <INDENT> board = Board . create ( H , W , C ) <NEWLINE> <NL> row_info = pattern [ : H ] <NEWLINE> col_info = pattern [ H : ] <NEWLINE> <NL> for row_idx , row in enumerate ( row_info , start = 1 ) : <NEWLINE> <INDENT> if row == 1 : <NEWLINE> <INDENT> board = board . paint_row ( row_idx ) <NEWLINE> <NL> <DEDENT> <DEDENT> for col_idx , col in enumerate ( col_info , start = 1 ) : <NEWLINE> <INDENT> if col == 1 : <NEWLINE> <INDENT> board = board . paint_col ( col_idx ) <NEWLINE> <NL> <DEDENT> <DEDENT> if board . count_black ( ) == K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> print ( actual ( H , W , K , C ) ) <NEWLINE>
import math , sys <NEWLINE> <NL> def loadable ( w , n , k , p , wsum ) : <NEWLINE> <INDENT> wait = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> wait += w [ i ] <NEWLINE> wsum -= w [ i ] <NEWLINE> if wait > p : <NEWLINE> <INDENT> k -= 1 <NEWLINE> wait = w [ i ] <NEWLINE> if k == 0 or p < wsum / k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> w = [ int ( sys . stdin . readline ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> wsum = sum ( w ) <NEWLINE> <NL> p = max ( int ( math . ceil ( wsum / k ) ) , max ( w ) ) <NEWLINE> pre_f = p - 1 <NEWLINE> pre_s = None <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if loadable ( w , n , k , p , wsum ) : <NEWLINE> <INDENT> pre_s = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pre_f = p <NEWLINE> <NL> <DEDENT> if pre_s != None and pre_s - pre_f == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if pre_s : <NEWLINE> <INDENT> p = int ( ( pre_s + pre_f ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = math . ceil ( p * 1.01 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( pre_s ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> answer = 0 <NEWLINE> <NL> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> answer += math . gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hhh = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nice = [ 1 ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> ha = hhh [ a ] <NEWLINE> hb = hhh [ b ] <NEWLINE> if ha <= hb : <NEWLINE> <INDENT> nice [ a ] = False <NEWLINE> <DEDENT> if ha >= hb : <NEWLINE> <INDENT> nice [ b ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( nice ) ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> <NL> def _sum_ob_divisors ( n ) : <NEWLINE> <INDENT> def f ( n , x ) : <NEWLINE> <INDENT> y = n // x <NEWLINE> return y * ( y + 1 ) * x // 2 <NEWLINE> <DEDENT> return sum ( f ( n , i ) for i in range ( 1 , n + 1 ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def sum_ob_divisors ( f ) : <NEWLINE> <INDENT> n = int ( f . read ( ) ) <NEWLINE> <NL> return _sum_ob_divisors ( n ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = sum_ob_divisors ( sys . stdin . buffer ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> <NL> ans = int ( N [ - 3 : ] ) <NEWLINE> <NL> ans = 1000 - ans <NEWLINE> <NL> if ans == 1000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> l = list ( ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> l . append ( x ) <NEWLINE> <NL> <DEDENT> l = set ( l ) <NEWLINE> print ( len ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = [ 0 ] * n <NEWLINE> for a in A : <NEWLINE> <INDENT> N [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in N : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 1 ] <NEWLINE> di = { } <NEWLINE> di [ 1 ] = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> b = a [ l [ - 1 ] - 1 ] <NEWLINE> if b in di : <NEWLINE> <INDENT> x = b <NEWLINE> break <NEWLINE> <DEDENT> l . append ( b ) <NEWLINE> di [ b ] = 1 <NEWLINE> <DEDENT> t1 = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> if j == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t1 += 1 <NEWLINE> <DEDENT> <DEDENT> t2 = len ( l ) - t1 <NEWLINE> if k <= t1 : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( k - t1 ) % t2 <NEWLINE> print ( l [ t1 + num ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if ans <= 1000000000000000000 : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans <= 1000000000000000000 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
print ( <STRING> if sum ( list ( map ( int , list ( input ( ) ) ) ) ) % 9 == 0 else <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : break <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> s = max ( min ( a [ i ] ) for i in range ( n ) ) <NEWLINE> c = [ max ( a [ i ] [ j ] for i in range ( n ) ) for j in range ( n ) ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if c [ j ] == s : <NEWLINE> <INDENT> print ( s ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> ops = [ ] <NEWLINE> words = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> op , word = input ( ) . split ( ) <NEWLINE> ops . append ( op ) <NEWLINE> words . append ( word ) <NEWLINE> <NL> <DEDENT> db = set ( ) <NEWLINE> for op , word in zip ( ops , words ) : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> db . add ( word ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if word in db : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> data = input ( ) <NEWLINE> <NL> w = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> if data [ i ] == <STRING> : <NEWLINE> <INDENT> w . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if len ( w ) == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif len ( r ) == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = r [ : : - 1 ] <NEWLINE> for i in range ( min ( len ( w ) , len ( r ) ) ) : <NEWLINE> <INDENT> tmp_w = w [ i ] <NEWLINE> tmp_r = r [ i ] <NEWLINE> if tmp_w <= tmp_r : <NEWLINE> <INDENT> r . append ( tmp_w ) <NEWLINE> w . append ( tmp_r ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> arr = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> arr [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> Mx = 10 ** 5 + 1 <NEWLINE> sch = [ [ 0 ] * Mx for _ in range ( C ) ] <NEWLINE> scht = [ 0 ] * Mx <NEWLINE> plist = [ [ ] for _ in range ( C ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s , t , c = map ( int , input ( ) . split ( ) ) <NEWLINE> plist [ c - 1 ] . append ( ( s , t ) ) <NEWLINE> <DEDENT> for c , p in enumerate ( plist ) : <NEWLINE> <INDENT> p . sort ( ) <NEWLINE> prevt = 0 <NEWLINE> for s , t in p : <NEWLINE> <INDENT> if prevt == s : <NEWLINE> <INDENT> sch [ c ] [ prevt ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sch [ c ] [ s ] = 1 <NEWLINE> <DEDENT> sch [ c ] [ t ] = - 1 <NEWLINE> prevt = t <NEWLINE> <DEDENT> for i in range ( 1 , Mx ) : <NEWLINE> <INDENT> if sch [ c ] [ i ] == 1 : <NEWLINE> <INDENT> scht [ i - 1 ] += 1 <NEWLINE> <DEDENT> if sch [ c ] [ i ] == - 1 : <NEWLINE> <INDENT> scht [ i ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , Mx ) : <NEWLINE> <INDENT> scht [ i ] += scht [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( max ( scht ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> for i in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = list ( map ( float , i . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> y = ( f - ( d * c ) / a ) / ( ( a * e - d * b ) / a ) <NEWLINE> x = ( c - b * y ) / a <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A . add ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> if 1 in A : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if i + 2 in A : <NEWLINE> <INDENT> dp [ i + 2 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 2 ] = ( dp [ i ] + dp [ i + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> a , b = int ( x [ 0 ] ) , int ( x [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> pq = [ ] <NEWLINE> <NL> def insert ( S , k ) : <NEWLINE> <INDENT> heapq . heappush ( pq , - k ) <NEWLINE> <NL> <DEDENT> def extractMax ( S ) : <NEWLINE> <INDENT> a = - heapq . heappop ( S ) <NEWLINE> print ( str ( a ) ) <NEWLINE> <NL> <DEDENT> L = input ( ) <NEWLINE> while L != <STRING> : <NEWLINE> <INDENT> if L == <STRING> : <NEWLINE> <INDENT> extractMax ( pq ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = L . split ( ) <NEWLINE> insert ( pq , int ( L [ 1 ] ) ) <NEWLINE> <DEDENT> L = input ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from sys import stdin , stdout <NEWLINE> import sys <NEWLINE> from math import gcd , ceil , sqrt <NEWLINE> from collections import Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> ii1 = lambda : int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> is1 = lambda : stdin . readline ( ) . strip ( ) <NEWLINE> iia = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> isa = lambda : stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> mod = 1000000007 <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> n , m = iia ( ) <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> d = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = iia ( ) <NEWLINE> d . setdefault ( a , [ ] ) . append ( b ) <NEWLINE> <NL> <DEDENT> def dfs ( cur ) : <NEWLINE> <INDENT> if dp [ cur ] != - 1 : <NEWLINE> <INDENT> return dp [ cur ] <NEWLINE> <DEDENT> t = 0 <NEWLINE> for i in d . get ( cur , [ ] ) : <NEWLINE> <INDENT> t = max ( 1 + dfs ( i ) , t ) <NEWLINE> <DEDENT> dp [ cur ] = t <NEWLINE> return dp [ cur ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res = max ( res , dfs ( i ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> al = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for k in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> l = k + ( k - i ) <NEWLINE> if l >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ k ] and s [ i ] != s [ l ] and s [ k ] != s [ l ] : <NEWLINE> <INDENT> al -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( al ) <NEWLINE>
A , B , N = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> min ( B - 1 , N ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( ( ( A * x ) // B - A * ( x // B ) ) ) <NEWLINE>
from typing import List <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> m = xyz ( n ) <NEWLINE> for i in m : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def f ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <NL> <DEDENT> def xyz ( n : int ) -> List [ int ] : <NEWLINE> <INDENT> result = [ 0 ] * n <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> m = f ( x , y , z ) <NEWLINE> if m > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result [ m - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r = float ( input ( ) ) <NEWLINE> p = 3.141592653589793 <NEWLINE> print ( p * r * r , p * r * 2 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ - 1 ] * ( n + 1 ) <NEWLINE> now = 1 <NEWLINE> history = [ ] <NEWLINE> <NL> while b [ now ] == - 1 : <NEWLINE> <INDENT> b [ now ] = len ( history ) <NEWLINE> history . append ( now ) <NEWLINE> now = a [ now - 1 ] <NEWLINE> <NL> <DEDENT> c = len ( history ) - b [ now ] <NEWLINE> l = b [ now ] <NEWLINE> <NL> if k < l : <NEWLINE> <INDENT> print ( history [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( history [ l + k ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N : <NEWLINE> <COMMENT> <NL> <INDENT> N -= 1 <NEWLINE> <NL> <COMMENT> <NL> alphabet = chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> ans += alphabet <NEWLINE> N //= 26 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = sorted ( D ) [ : : - 1 ] <NEWLINE> import math <NEWLINE> from math import comb <NEWLINE> print ( sum ( D [ : A ] ) / A ) <NEWLINE> ans = 0 <NEWLINE> if D [ 0 ] != D [ A - 1 ] : <NEWLINE> <INDENT> n = D . count ( D [ A - 1 ] ) <NEWLINE> k = D [ : A ] . count ( D [ A - 1 ] ) <NEWLINE> print ( comb ( n , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = D . count ( D [ A - 1 ] ) <NEWLINE> for i in range ( A , min ( n , B ) + 1 ) : <NEWLINE> <INDENT> ans += comb ( n , i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = dict ( zip ( A , B ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> j = 1 <NEWLINE> C = [ - 1 for i in range ( n ) ] <NEWLINE> dp = dict ( zip ( A , C ) ) <NEWLINE> dp [ 1 ] = 0 <NEWLINE> num = 0 <NEWLINE> while dp [ j ] != k - 1 : <NEWLINE> <INDENT> j = road [ j ] <NEWLINE> num = num + 1 <NEWLINE> if dp [ j ] == - 1 : <NEWLINE> <INDENT> dp [ j ] = num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = num - dp [ j ] <NEWLINE> pre = dp [ j ] <NEWLINE> itti = j <NEWLINE> break <NEWLINE> <DEDENT> if num == k - 1 : <NEWLINE> <INDENT> print ( road [ j ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> mod = ( k - pre ) % t <NEWLINE> <NL> for i in range ( mod ) : <NEWLINE> <INDENT> itti = road [ itti ] <NEWLINE> <DEDENT> print ( itti ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <NL> S = input ( ) [ : : - 1 ] <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> num += int ( i ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in counts : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( temp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> MOD = 1000000007 <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> N = int ( readline ( ) ) <NEWLINE> <NL> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> if A . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res *= A [ i ] <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> stairs = [ 1 ] * ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> stairs [ int ( input ( ) ) ] = - 1 <NEWLINE> <NL> <DEDENT> flg = False <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if stairs [ i ] == - 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif stairs [ i - 1 ] == - 1 and stairs [ i - 2 ] == - 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> elif stairs [ i - 1 ] == - 1 : <NEWLINE> <INDENT> stairs [ i ] = stairs [ i - 2 ] <NEWLINE> <DEDENT> elif stairs [ i - 2 ] == - 1 : <NEWLINE> <INDENT> stairs [ i ] = stairs [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stairs [ i ] = stairs [ i - 1 ] + stairs [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( stairs [ - 1 ] % 1000000007 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] == H [ b - 1 ] : <NEWLINE> <INDENT> g += [ a , b ] <NEWLINE> <DEDENT> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> g += [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g += [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> g = set ( g ) <NEWLINE> r = N - len ( g ) <NEWLINE> print ( r ) <NEWLINE>
n = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for divisor in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += divisor * ( n // divisor * ( n // divisor + 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
flag = [ False ] * 100001 <NEWLINE> c = [ 0 ] * 100002 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 2 , 100000 ) : <NEWLINE> <INDENT> if ( not ( flag [ i ] ) ) : <NEWLINE> <INDENT> for j in range ( i + i , 100000 , i ) : <NEWLINE> <INDENT> flag [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 , 100000 , 2 ) : <NEWLINE> <INDENT> if ( not ( flag [ i ] ) and not ( flag [ ( i + 1 ) // 2 ] ) ) : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 , 100000 ) : <NEWLINE> <INDENT> c [ i ] += c [ i - 1 ] <NEWLINE> <NL> <DEDENT> while ( n ) : <NEWLINE> <INDENT> n -= 1 <NEWLINE> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( c [ r ] - c [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> dp = [ [ 0 ] * 7 for i in range ( 4001 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] + 1 <NEWLINE> dp [ i + 1 ] [ 1 ] = dp [ i ] [ 1 ] <NEWLINE> dp [ i + 1 ] [ 2 ] = dp [ i ] [ 2 ] <NEWLINE> dp [ i + 1 ] [ 3 ] = dp [ i ] [ 1 ] + dp [ i ] [ 3 ] <NEWLINE> dp [ i + 1 ] [ 4 ] = dp [ i ] [ 4 ] <NEWLINE> dp [ i + 1 ] [ 5 ] = dp [ i ] [ 2 ] + dp [ i ] [ 5 ] <NEWLINE> dp [ i + 1 ] [ 6 ] = dp [ i ] [ 6 ] + dp [ i ] [ 4 ] <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] <NEWLINE> dp [ i + 1 ] [ 1 ] = dp [ i ] [ 1 ] + 1 <NEWLINE> dp [ i + 1 ] [ 2 ] = dp [ i ] [ 2 ] <NEWLINE> dp [ i + 1 ] [ 3 ] = dp [ i ] [ 0 ] + dp [ i ] [ 3 ] <NEWLINE> dp [ i + 1 ] [ 4 ] = dp [ i ] [ 2 ] + dp [ i ] [ 4 ] <NEWLINE> dp [ i + 1 ] [ 5 ] = dp [ i ] [ 5 ] <NEWLINE> dp [ i + 1 ] [ 6 ] = dp [ i ] [ 6 ] + dp [ i ] [ 5 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] <NEWLINE> dp [ i + 1 ] [ 1 ] = dp [ i ] [ 1 ] <NEWLINE> dp [ i + 1 ] [ 2 ] = dp [ i ] [ 2 ] + 1 <NEWLINE> dp [ i + 1 ] [ 3 ] = dp [ i ] [ 3 ] <NEWLINE> dp [ i + 1 ] [ 4 ] = dp [ i ] [ 1 ] + dp [ i ] [ 4 ] <NEWLINE> dp [ i + 1 ] [ 5 ] = dp [ i ] [ 0 ] + dp [ i ] [ 5 ] <NEWLINE> dp [ i + 1 ] [ 6 ] = dp [ i ] [ 6 ] + dp [ i ] [ 3 ] <NEWLINE> <DEDENT> for j in range ( 1 , i // 2 + 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i - j * 2 ] and s [ i - j ] != s [ i - 2 * j ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ 6 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] [ 6 ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> data . append ( [ 0 for i in range ( n + 1 ) ] ) <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i != n : <NEWLINE> <INDENT> data [ i ] . append ( sum ( data [ i ] ) ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> data [ n ] [ i ] = data [ n ] [ i ] + data [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> if j != n : <NEWLINE> <INDENT> string = str ( <STRING> . format ( data [ i ] [ j ] ) ) <NEWLINE> sys . stdout . write ( string ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( data [ i ] [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> l = range ( 1 , m + 1 ) <NEWLINE> point = 0 <NEWLINE> for v in itertools . combinations_with_replacement ( l , n ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if v [ b - 1 ] - v [ a - 1 ] == c : <NEWLINE> <INDENT> p += d <NEWLINE> <DEDENT> <DEDENT> if p > point : point = p <NEWLINE> <DEDENT> print ( point ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if H [ i - 1 ] >= H [ i ] : <NEWLINE> <INDENT> now += 1 <NEWLINE> ans = max ( ans , now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i == j and i == k : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or j == k or i == k : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) * 6 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for key in T : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if S [ mid ] == key : <NEWLINE> <INDENT> res += 1 <NEWLINE> right = - 1 <NEWLINE> <DEDENT> elif key < S [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
s = input ( ) <NEWLINE> List = list ( s ) + [ <STRING> ] <NEWLINE> n = len ( List ) <NEWLINE> R = 0 <NEWLINE> L = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if List [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> if L > 0 : <NEWLINE> <INDENT> ans [ i - L ] += ( L + 1 ) // 2 <NEWLINE> ans [ i - L - 1 ] += L // 2 <NEWLINE> L = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L += 1 <NEWLINE> if R > 0 : <NEWLINE> <INDENT> ans [ i ] += R // 2 <NEWLINE> ans [ i - 1 ] += ( R + 1 ) // 2 <NEWLINE> R = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ : - 1 ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> MOD = 1000000007 <NEWLINE> N = int ( readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> d_S = defaultdict ( int ) <NEWLINE> d_T = defaultdict ( int ) <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y % x , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> pow2_mod = [ 1 ] + [ 0 ] * ( N + 10 ) <NEWLINE> for i in range ( 1 , N + 10 ) : <NEWLINE> <INDENT> pow2_mod [ i ] = pow2_mod [ i - 1 ] * 2 % MOD <NEWLINE> <NL> <DEDENT> zeros = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if A == 0 and B == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> d_S [ ( 1 , 0 ) ] += 0 <NEWLINE> d_T [ ( 0 , - 1 ) ] += 1 <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> d_S [ ( 1 , 0 ) ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( A , B ) <NEWLINE> A //= g <NEWLINE> B //= g <NEWLINE> <COMMENT> <NL> if A < 0 and B < 0 : <NEWLINE> <INDENT> A *= - 1 <NEWLINE> B *= - 1 <NEWLINE> <DEDENT> if A * B > 0 : <NEWLINE> <INDENT> d_S [ ( A , B ) ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> d_S [ ( - A , B ) ] += 0 <NEWLINE> d_T [ ( B , A ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for ( si , sj ) , s_cnt in d_S . items ( ) : <NEWLINE> <INDENT> t_cnt = d_T [ ( sj , - 1 * si ) ] <NEWLINE> tmp = 0 <NEWLINE> tmp += pow2_mod [ s_cnt ] - 1 <COMMENT> <NEWLINE> tmp += pow2_mod [ t_cnt ] - 1 <COMMENT> <NEWLINE> tmp += 1 <COMMENT> <NEWLINE> ans = ( ans * tmp ) % MOD <NEWLINE> <NL> <DEDENT> ans -= 1 <COMMENT> <NEWLINE> ans += zeros <COMMENT> <NEWLINE> <NL> print ( ans % MOD ) <NEWLINE>
T = input ( ) <NEWLINE> D = T . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> print ( D ) <NEWLINE>
val = input ( ) <NEWLINE> print ( val [ 0 : 3 ] ) <NEWLINE>
import numpy as np <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pt = np . array ( list ( combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) ) <NEWLINE> score = np . zeros ( len ( pt ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> flg = pt [ : , b - 1 ] - pt [ : , a - 1 ] == c <NEWLINE> score += flg * d <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( int ( score . max ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> t = sorted ( s ) <NEWLINE> <NL> if t [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> count = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> count = count * t [ i ] <NEWLINE> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> inp = iter ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> <NL> H , W , D = next ( inp ) , next ( inp ) , next ( inp ) <NEWLINE> addr = [ None ] * ( H * W + 1 ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> v = next ( inp ) <NEWLINE> addr [ v ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> cost = [ ] <NEWLINE> for m in range ( D ) : <NEWLINE> <INDENT> arr = [ 0 ] <NEWLINE> for x in range ( ( H * W - m ) // D ) : <NEWLINE> <INDENT> if m + x * D == 0 : <NEWLINE> <INDENT> arr . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> r , c = addr [ m + x * D ] <NEWLINE> nr , nc = addr [ m + ( x + 1 ) * D ] <NEWLINE> arr . append ( arr [ - 1 ] + abs ( nr - r ) + abs ( nc - c ) ) <NEWLINE> <DEDENT> cost . append ( arr ) <NEWLINE> <NL> <DEDENT> Q = next ( inp ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> s , t = next ( inp ) , next ( inp ) <NEWLINE> m = s % D <NEWLINE> ans = cost [ m ] [ t // D ] - cost [ m ] [ s // D ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> def hantei ( u ) : <NEWLINE> <INDENT> if u == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> for i in range ( 1 , u + 1 ) : <NEWLINE> <INDENT> if ( 1 / 2 ) * i ** 2 + ( 1 / 2 ) * i > u : <NEWLINE> <INDENT> return int ( i - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a = [ 0 ] * int ( math . sqrt ( N ) ) <NEWLINE> for i in range ( 2 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> while N % i == 0 : <NEWLINE> <INDENT> N = N // i <NEWLINE> a [ i - 1 ] = a [ i - 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> if N != 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> for t in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ t ] != 0 : <NEWLINE> <INDENT> c += hantei ( a [ t ] ) <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
import sys , math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> T = input ( ) . rstrip ( ) <NEWLINE> <NL> L = N * M // math . gcd ( N , M ) <NEWLINE> <NL> sn = L // M <NEWLINE> tm = L // N <NEWLINE> <NL> for i in range ( N // sn ) : <NEWLINE> <INDENT> if S [ i * sn ] == T [ i * tm ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( L ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( ans ) == 0 or ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . insert ( 0 , 0 ) <NEWLINE> b . insert ( 0 , 0 ) <NEWLINE> <NL> sum_a = [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum_a . append ( sum_a [ i - 1 ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> sum_b = [ 0 ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> sum_b . append ( sum_b [ i - 1 ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if sum_a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( m , - 1 , - 1 ) : <NEWLINE> <INDENT> if sum_a [ i ] + sum_b [ j ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> m = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> a = math . pi * r * r <NEWLINE> l = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( a ) , <STRING> . format ( l ) ) <NEWLINE>
from time import perf_counter <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> from bisect import bisect_right <NEWLINE> from functools import lru_cache <NEWLINE> <NL> <NL> def solve1 ( darts , scores , point , target ) : <NEWLINE> <INDENT> if darts == 3 or point > target : <NEWLINE> <INDENT> if point > target : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos = bisect_right ( scores , target - point ) <NEWLINE> return point + scores [ pos - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> max_score = 0 <NEWLINE> for s in scores : <NEWLINE> <INDENT> result1 = solve1 ( darts + 1 , scores , point + s , target ) <COMMENT> <NEWLINE> <COMMENT> <NL> max_score = max ( max_score , result1 ) <NEWLINE> <DEDENT> return max_score <NEWLINE> <NL> <NL> <DEDENT> def solve2 ( darts , scores , point , target ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> combi = combinations_with_replacement ( scores , 4 ) <NEWLINE> max_score = 0 <NEWLINE> max_combi = [ ] <NEWLINE> for s in combi : <NEWLINE> <INDENT> score = sum ( s ) <NEWLINE> if score <= target and score > max_score : <NEWLINE> <INDENT> max_score = score <NEWLINE> max_combi = s <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( max_combi ) ) <NEWLINE> return max_score <NEWLINE> <NL> <NL> <DEDENT> Target = 0 <NEWLINE> def solve3 ( darts , scores , point , target ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global Target <NEWLINE> Target = target <NEWLINE> return cache_solve3 ( darts , tuple ( scores ) , point ) <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def cache_solve3 ( darts , scores , point ) : <NEWLINE> <INDENT> if darts == 4 or point > Target : <NEWLINE> <INDENT> if point > Target : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos = bisect_right ( scores , Target - point ) <NEWLINE> return point + scores [ pos - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> max_score = 0 <NEWLINE> for s in scores : <NEWLINE> <INDENT> result1 = cache_solve3 ( darts + 1 , scores , point + s ) <NEWLINE> max_score = max ( max_score , result1 ) <NEWLINE> <DEDENT> return max_score <NEWLINE> <NL> <NL> <DEDENT> def solve4 ( darts , scores , point , target ) : <NEWLINE> <INDENT> if darts == 3 or point > target : <NEWLINE> <INDENT> if point > target : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos = bisect_right ( scores , target - point ) <NEWLINE> return point + scores [ pos - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> max_score = 0 <NEWLINE> t = ( target - point ) // ( 4 - darts ) <NEWLINE> min_lim = bisect_right ( scores , t ) <NEWLINE> for s in range ( min_lim - 1 , len ( scores ) ) : <NEWLINE> <INDENT> result1 = solve4 ( darts + 1 , scores , point + scores [ s ] , target ) <COMMENT> <NEWLINE> max_score = max ( max_score , result1 ) <NEWLINE> <DEDENT> return max_score <NEWLINE> <NL> <NL> <DEDENT> def solve5 ( darts , scores , point , target ) : <NEWLINE> <INDENT> combi = combinations_with_replacement ( scores , 2 ) <NEWLINE> i_scores = [ sum ( x ) for x in combi if sum ( x ) < target ] <NEWLINE> i_scores . sort ( ) <NEWLINE> <NL> results = [ x + find_le ( i_scores , target - x ) for x in i_scores ] <NEWLINE> return max ( results ) <NEWLINE> <NL> <NL> <DEDENT> def find_le ( a , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i = bisect_right ( a , x ) <NEWLINE> if i : <NEWLINE> <INDENT> return a [ i - 1 ] <NEWLINE> <DEDENT> raise ValueError <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> while True : <NEWLINE> <INDENT> N , M = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> scores = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> if N == 0 and M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> scores . append ( 0 ) <COMMENT> <NEWLINE> scores . sort ( ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> ans = solve5 ( 0 , scores , 0 , M ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ 0 ] + [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> s_b = 0 <NEWLINE> for i in range ( M + 1 ) : <NEWLINE> <INDENT> s_b += B [ i ] <NEWLINE> if s_b > K : <NEWLINE> <INDENT> s_b -= B [ i ] <NEWLINE> best = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> best = M <NEWLINE> <DEDENT> res = best <NEWLINE> <COMMENT> <NL> s_a = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> s_a += A [ i ] <NEWLINE> if s_a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in reversed ( range ( best + 1 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s_b <= K - s_a : <NEWLINE> <INDENT> if i + j > res : <NEWLINE> <INDENT> res = i + j <NEWLINE> <DEDENT> best = j <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_b -= B [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) ; <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sum ( A ) <NEWLINE> new_A = A . reverse ( ) <NEWLINE> n = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> n += A [ i ] * ( B - A [ i ] ) <NEWLINE> B = B - A [ i ] <NEWLINE> <NL> <DEDENT> print ( n % ( 10 ** 9 + 7 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * m <NEWLINE> c = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> ans = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if n != 1 and s [ i ] == 1 and c [ i ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ans [ s [ i ] - 1 ] == 0 or ans [ s [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> ans [ s [ i ] - 1 ] = c [ i ] <NEWLINE> <DEDENT> elif ans [ s [ i ] - 1 ] != 0 and ans [ s [ i ] - 1 ] != c [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> if ans [ 0 ] == 0 : <NEWLINE> <INDENT> ans [ 0 ] = 1 <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = list ( itertools . accumulate ( a ) ) <NEWLINE> bb = list ( itertools . accumulate ( b ) ) <NEWLINE> r = 0 <NEWLINE> for i , ax in enumerate ( aa ) : <NEWLINE> <INDENT> bis = bisect . bisect_right ( bb , k - ax ) <NEWLINE> if bis == 0 and ax > k : continue <NEWLINE> r = max ( r , i + bis ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if D >= X and K % 2 == 0 : <NEWLINE> <INDENT> ans = X <NEWLINE> <DEDENT> elif D >= X and K % 2 == 1 : <NEWLINE> <INDENT> ans = D - X <NEWLINE> <DEDENT> elif D < X and K * D < X : <NEWLINE> <INDENT> ans = X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = X % D <NEWLINE> if ( X - ans ) % 2 != K % 2 : <NEWLINE> <INDENT> ans = D - ans <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> S . sort ( ) <NEWLINE> import bisect <NEWLINE> a_uni = ord ( <STRING> ) <NEWLINE> <NL> Search = S <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> char = chr ( a_uni + i ) <NEWLINE> <NL> if Search and Search [ 0 ] == char : <NEWLINE> <INDENT> ind = bisect . bisect_right ( S , char ) <NEWLINE> Search = S [ ind : ] <NEWLINE> continue <NEWLINE> <DEDENT> print ( char ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL>
def make_divisors ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i != n // i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <DEDENT> numbers = [ 1 , 10 , 100 , 1000 , 10000 , 100000 , 150000 , 200000 , 250000 , 300000 , 350000 , 400000 , 450000 , 500000 , 550000 , 600000 , 630000 , 675000 , 700000 , 720000 , 750000 , 800000 , 825000 , 850000 , 875000 , 900000 , 912500 , 925000 , 950000 , 975000 , 987500 , 1000000 ] <NEWLINE> datas = [ 0 , 23 , 473 , 7053 , 93643 , 1166714 , 1810893 , 2472071 , 3145923 , 3829761 , 4522005 , 5221424 , 5927120 , 6638407 , 7354651 , 8075420 , 8509899 , 9164377 , 9529244 , 9821778 , 10261678 , 10997400 , 11366472 , 11736253 , 12106789 , 12478098 , 12664043 , 12850013 , 13222660 , 13595947 , 13782871 , 13969985 ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ttl = 0 <NEWLINE> numPin = 0 <NEWLINE> <NL> for i in range ( len ( numbers ) ) : <NEWLINE> <INDENT> if N == 1000000 : <NEWLINE> <INDENT> numPin = len ( numbers ) - 1 <NEWLINE> break <NEWLINE> <DEDENT> if numbers [ i ] <= N < numbers [ i + 1 ] : <NEWLINE> <INDENT> numPin = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if numPin != len ( numbers ) - 1 : <NEWLINE> <INDENT> if N - numbers [ numPin ] < numbers [ numPin + 1 ] - N : <NEWLINE> <INDENT> for i in range ( numbers [ numPin ] , N ) : <NEWLINE> <INDENT> ttl += make_divisors ( i ) <NEWLINE> <DEDENT> print ( ttl + datas [ numPin ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N , numbers [ numPin + 1 ] ) : <NEWLINE> <INDENT> ttl -= make_divisors ( i ) <NEWLINE> <DEDENT> print ( ttl + datas [ numPin + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( datas [ numPin ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> ab = { } <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> if tmp not in ab : <NEWLINE> <INDENT> ab [ tmp ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ab [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for d in ab . keys ( ) : <NEWLINE> <INDENT> ans += math . gcd ( c , d ) * ab [ d ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( s ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> n = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> n = n * A [ i ] <NEWLINE> if n > 10 ** 18 : <NEWLINE> <INDENT> n = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> if ( a [ 0 ] == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> ans = ans * a [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) ; a . sort ( ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) ; b . sort ( ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) ; c . sort ( ) <NEWLINE> ab = [ 0 for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ab [ i ] = ab [ i - 1 ] + bisect . bisect_left ( a , b [ i ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = bisect . bisect_left ( b , c [ i ] ) <NEWLINE> if tmp != 0 : <NEWLINE> <INDENT> ans += ab [ tmp - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ball_count = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ball_count [ i ] += 1 <NEWLINE> <DEDENT> def nCr ( i ) : <NEWLINE> <INDENT> if i <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> def get_total ( ball_count ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in ball_count : <NEWLINE> <INDENT> ans += nCr ( i ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> total = get_total ( ball_count ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = ball_count [ a [ i - 1 ] ] <NEWLINE> ans = total - nCr ( num ) + nCr ( num - 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> An . sort ( ) <NEWLINE> max_n = max ( An ) <NEWLINE> dp = [ 0 ] * ( max_n + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ An [ i ] ] != 0 : <NEWLINE> <INDENT> dp [ An [ i ] ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( 1 , max_n // An [ i ] + 1 ) : <NEWLINE> <INDENT> dp [ An [ i ] * j ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in An : <NEWLINE> <INDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nList = [ ] <NEWLINE> for _ in range ( n + 1 ) : <NEWLINE> <INDENT> nList . append ( [ ] ) <NEWLINE> <DEDENT> edges = [ ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges . append ( ( a , b ) ) <NEWLINE> nList [ a ] . append ( b ) <NEWLINE> <COMMENT> <NL> <DEDENT> return n , nList , edges <NEWLINE> <NL> <DEDENT> def bfs ( s , nList ) : <NEWLINE> <COMMENT> <NL> <INDENT> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> status = [ WHITE ] * ( n + 1 ) <NEWLINE> parent = [ 0 ] * ( n + 1 ) <NEWLINE> color = [ 0 ] * ( n + 1 ) <NEWLINE> maxcolor = 0 <NEWLINE> Q = deque ( [ ] ) <NEWLINE> Q . append ( s ) <NEWLINE> while ( len ( Q ) > 0 ) : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> usedcolor = color [ u ] <NEWLINE> col = 1 <NEWLINE> for t in nList [ u ] : <NEWLINE> <INDENT> if status [ t ] == WHITE : <NEWLINE> <INDENT> status [ t ] = GRAY <NEWLINE> parent [ t ] = u <NEWLINE> if col == usedcolor : <NEWLINE> <INDENT> col += 1 <NEWLINE> <DEDENT> color [ t ] = col <NEWLINE> Q . append ( t ) <NEWLINE> col += 1 <NEWLINE> <DEDENT> <DEDENT> maxcolor = max ( maxcolor , col - 1 ) <NEWLINE> status [ u ] = BLACK <NEWLINE> <COMMENT> <NL> <DEDENT> return color , maxcolor <NEWLINE> <NL> <NL> <DEDENT> def main ( n , nList , edges ) : <NEWLINE> <INDENT> color , maxcolor = bfs ( 1 , nList ) <NEWLINE> print ( maxcolor ) <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> print ( color [ b ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , nList , edges = readinput ( ) <NEWLINE> main ( n , nList , edges ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> all = set ( range ( - 100 , 102 ) ) <NEWLINE> s_p = set ( p ) <NEWLINE> kouho = sorted ( all - s_p ) <NEWLINE> <NL> min_dis = 201 <NEWLINE> for i in kouho : <NEWLINE> <INDENT> dis = abs ( i - x ) <NEWLINE> if min_dis > dis : <NEWLINE> <INDENT> min_i = i <NEWLINE> min_dis = dis <NEWLINE> <DEDENT> <DEDENT> print ( min_i ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> cnt_list = [ 0 ] * n <NEWLINE> a = int ( ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if num_list [ i - 1 ] > num_list [ i ] : <NEWLINE> <INDENT> cnt_list [ i ] = - 1 <NEWLINE> <DEDENT> if num_list [ i - 1 ] < num_list [ i ] : <NEWLINE> <INDENT> cnt_list [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 in cnt_list and - 1 in cnt_list : <NEWLINE> <INDENT> del cnt_list [ : max ( cnt_list . index ( 1 ) , cnt_list . index ( - 1 ) ) ] <NEWLINE> cnt_list [ 0 ] = 0 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> def calc_double ( nn ) : <NEWLINE> <INDENT> return nn - x <NEWLINE> <NL> <DEDENT> x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p_all = list ( range ( - 200 , 200 , 1 ) ) <NEWLINE> <NL> l_in = [ s for s in p_all if s not in p ] <NEWLINE> <NL> data2 = [ ] <NEWLINE> for val in l_in : <NEWLINE> <INDENT> data2 . append ( abs ( calc_double ( val ) ) ) <NEWLINE> <NL> <DEDENT> min_index = np . argmin ( data2 ) <NEWLINE> print ( l_in [ min_index ] ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = x // 100 <NEWLINE> z = x % 100 <NEWLINE> if z <= y * 5 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> <NL> ans = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
def phi ( n ) : <NEWLINE> <INDENT> r = n <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> r -= r / i <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : r -= r / n <NEWLINE> return r <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( int ( phi ( n ) ) ) <NEWLINE>
a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> x = min ( n , b - 1 ) <NEWLINE> print ( ( a * x // b ) - ( x // b ) * a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> counter = [ 0 ] * 10001 <NEWLINE> for x in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> n1 = x * x <NEWLINE> if n1 >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for y in range ( x , 100 + 1 ) : <NEWLINE> <INDENT> n2 = n1 + y * y + x * y <NEWLINE> if n2 >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for z in range ( y , 100 + 1 ) : <NEWLINE> <INDENT> n = n2 + z * z + y * z + z * x <NEWLINE> if 1 <= n <= 10000 : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> counter [ n ] += 1 <NEWLINE> <DEDENT> elif x == y or y == z : <NEWLINE> <INDENT> counter [ n ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter [ n ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( counter [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def solve ( L , N ) : <NEWLINE> <INDENT> if L == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif N <= 2 ** ( L + 1 ) - 2 : <NEWLINE> <INDENT> return solve ( L - 1 , N - 1 ) <NEWLINE> <DEDENT> elif N == int ( 2 ** ( L + 1 ) - 1 ) : <NEWLINE> <INDENT> return 2 ** L <NEWLINE> <DEDENT> return solve ( L - 1 , N - 2 ** ( L + 1 ) + 1 ) + 2 ** L <NEWLINE> <NL> <NL> <DEDENT> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( N , X ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> num = sum ( a ) % mod <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> num -= a [ i ] <NEWLINE> num %= mod <NEWLINE> ans += a [ i ] * num <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> base = [ <STRING> * ( w + 4 ) ] <NEWLINE> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> for n in range ( h ) : <NEWLINE> <INDENT> base . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> base . append ( <STRING> * ( w + 4 ) ) <NEWLINE> ans = [ [ - 1 ] * ( w + 4 ) for _ in range ( h + 4 ) ] <NEWLINE> for i in range ( h + 4 ) : <NEWLINE> <INDENT> for j in range ( w + 4 ) : <NEWLINE> <INDENT> if base [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ch += 1 <NEWLINE> cw += 1 <NEWLINE> dh += 1 <NEWLINE> dw += 1 <NEWLINE> <NL> ans [ ch ] [ cw ] = 0 <NEWLINE> move1 = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> move2 = [ <NEWLINE> <INDENT> [ - 2 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 2 , 2 ] , [ - 1 , - 2 ] , [ - 1 , - 1 ] , <NEWLINE> [ - 1 , 1 ] , [ - 1 , 2 ] , [ 0 , - 2 ] , [ 0 , 2 ] , [ 1 , - 2 ] , [ 1 , - 1 ] , [ 1 , 1 ] , <NEWLINE> [ 1 , 2 ] , [ 2 , - 2 ] , [ 2 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] <NEWLINE> <DEDENT> ] <NEWLINE> q1 = deque ( [ [ ch , cw ] ] ) <NEWLINE> q2 = deque ( [ ] ) <NEWLINE> <NL> while q1 : <NEWLINE> <INDENT> x1 , y1 = q1 . popleft ( ) <NEWLINE> q2 . append ( [ x1 , y1 ] ) <NEWLINE> for i , j in move1 : <NEWLINE> <INDENT> nx , ny = x1 + i , y1 + j <NEWLINE> <STRING> <NEWLINE> if ans [ nx ] [ ny ] == - 1 : <NEWLINE> <INDENT> ans [ nx ] [ ny ] = ans [ x1 ] [ y1 ] <NEWLINE> q1 . append ( [ nx , ny ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( q1 ) == 0 : <NEWLINE> <INDENT> while q2 : <NEWLINE> <INDENT> x2 , y2 = q2 . popleft ( ) <NEWLINE> for i , j in move2 : <NEWLINE> <INDENT> mx , my = x2 + i , y2 + j <NEWLINE> <STRING> <NEWLINE> if ans [ mx ] [ my ] == - 1 : <NEWLINE> <INDENT> ans [ mx ] [ my ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> q1 . append ( [ mx , my ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ dh ] [ dw ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 2018 <NEWLINE> i = L <NEWLINE> while i < R : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> while j <= R : <NEWLINE> <INDENT> if i * j % 2019 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asum_li = [ 0 ] <NEWLINE> Asum = 0 <NEWLINE> Bsum_li = [ 0 ] <NEWLINE> Bsum = 0 <NEWLINE> <NL> for A_ in A : <NEWLINE> <INDENT> Asum = Asum + A_ <NEWLINE> Asum_li . append ( Asum ) <NEWLINE> <NL> <DEDENT> for B_ in B : <NEWLINE> <INDENT> Bsum = Bsum + B_ <NEWLINE> Bsum_li . append ( Bsum ) <NEWLINE> <NL> <DEDENT> cnt_max = 0 <NEWLINE> cnt_b = M <NEWLINE> <NL> for cnt_a in range ( N + 1 ) : <NEWLINE> <NL> <INDENT> if Asum_li [ cnt_a ] > K : break <NEWLINE> <NL> while ( Bsum_li [ cnt_b ] + Asum_li [ cnt_a ] ) > K : <NEWLINE> <INDENT> cnt_b = cnt_b - 1 <NEWLINE> if cnt_b < 0 : break <NEWLINE> <NL> <DEDENT> if ( cnt_max < cnt_a + cnt_b ) : cnt_max = cnt_a + cnt_b <NEWLINE> <NL> <NL> <DEDENT> print ( cnt_max ) <NEWLINE> <NL>
a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> a_x = a * math . cos ( math . radians ( 30 * h + 0.5 * m ) ) <NEWLINE> a_y = a * math . sin ( math . radians ( 30 * h + 0.5 * m ) ) <NEWLINE> b_x = b * math . cos ( math . radians ( 6 * m ) ) <NEWLINE> b_y = b * math . sin ( math . radians ( 6 * m ) ) <NEWLINE> <NL> ans = math . sqrt ( abs ( a_x - b_x ) ** 2 + abs ( a_y - b_y ) ** 2 ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s not in S : <NEWLINE> <INDENT> S . update ( { s : 0 } ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( S ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += i * ( n * ( n + 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> while ( ( x - 1 ) ** 4 ) * 5 < X : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> for j in range ( - x , i ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> a = [ i , j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a ) <NEWLINE>
h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> G = defaultdict ( list ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for n , item in enumerate ( l ) : <NEWLINE> <INDENT> G [ item ] = [ n , i ] <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> dp = [ 0 for i in range ( h * w + 1 ) ] <NEWLINE> for i in range ( d ) : <COMMENT> <NEWLINE> <INDENT> current_place = i + 1 <NEWLINE> while current_place + d <= h * w : <NEWLINE> <INDENT> x , y = G [ current_place ] <NEWLINE> next_place = current_place + d <NEWLINE> x1 , y1 = G [ next_place ] <NEWLINE> magic = abs ( x - x1 ) + abs ( y - y1 ) <NEWLINE> dp [ next_place ] = magic + dp [ current_place ] <NEWLINE> current_place = next_place <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dp [ r ] - dp [ l ] , flush = True ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for t in T : <NEWLINE> <INDENT> if t in d and d [ t ] > 0 : <NEWLINE> <INDENT> d [ t ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> U = 10 ** 6 + 1 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> dp = [ 0 ] * U <NEWLINE> <NL> ans = 0 <NEWLINE> for k in sorted ( C . keys ( ) ) : <NEWLINE> <INDENT> if dp [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if C [ k ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in range ( k , U , k ) : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> h , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> print ( out ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> count = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> li . append ( i ) <NEWLINE> <DEDENT> print ( len ( set ( li ) ) ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for s in N : <NEWLINE> <INDENT> cnt += int ( s ) <NEWLINE> <NL> <DEDENT> if cnt % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> m = 1000000007 <NEWLINE> <NL> result = 0 <NEWLINE> t = pow ( 26 , K , m ) <NEWLINE> u = pow ( 26 , - 1 , m ) * 25 % m <NEWLINE> l = len ( S ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> result = ( result + t ) % m <NEWLINE> t = ( t * u ) % m * ( l + i ) * pow ( i + 1 , - 1 , m ) % m <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
large_second = int ( input ( ) ) <NEWLINE> hour = large_second // 3600 <NEWLINE> minute = ( large_second - hour * 3600 ) // 60 <NEWLINE> second = large_second % 60 <NEWLINE> print ( hour , <STRING> , minute , <STRING> , second , sep = <STRING> ) <NEWLINE>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> B = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if len ( B ) >= 1 : <NEWLINE> <INDENT> ans += B [ len ( B ) // 2 ] <NEWLINE> <DEDENT> B . append ( i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> import numpy as np <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a_ = int ( input ( ) ) <NEWLINE> a . append ( a_ ) <NEWLINE> <NL> <NL> <DEDENT> listn_ = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> listn_ . append ( k ) <NEWLINE> <DEDENT> listn = np . array ( listn_ ) <NEWLINE> listn = listn - q <NEWLINE> s = Counter ( a ) <NEWLINE> for i in s . keys ( ) : <NEWLINE> <INDENT> listn [ i - 1 ] += s [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in listn : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> if 0 in line : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> total *= line [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> <DEDENT> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( n , m , q , arrays ) : <NEWLINE> <INDENT> from itertools import combinations_with_replacement <NEWLINE> pattern = list ( combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <NL> maxp = 0 <NEWLINE> for x in pattern : <NEWLINE> <INDENT> get = 0 <NEWLINE> for array in arrays : <NEWLINE> <INDENT> if x [ array [ 1 ] - 1 ] - x [ array [ 0 ] - 1 ] == array [ 2 ] : <NEWLINE> <INDENT> get += array [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> maxp = max ( maxp , get ) <NEWLINE> <NL> <DEDENT> print ( maxp ) <NEWLINE> <NL> <DEDENT> n , m , q , * aa = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> arrays = [ ] <NEWLINE> loop = 0 <NEWLINE> array = [ ] <NEWLINE> for x in aa : <NEWLINE> <INDENT> array . append ( x ) <NEWLINE> loop += 1 <NEWLINE> if loop % 4 == 0 : <NEWLINE> <INDENT> arrays . append ( array ) <NEWLINE> array = [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( n , m , q , arrays ) <NEWLINE>
text = input ( ) <NEWLINE> ab = text . split ( ) <NEWLINE> a = int ( ab [ 0 ] ) <NEWLINE> b = int ( ab [ 1 ] ) <NEWLINE> if ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> b = int ( input ( ) ) - 1 <NEWLINE> ary = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( ary [ b ] ) <NEWLINE>
A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> if B - 1 < N : <NEWLINE> <INDENT> print ( math . floor ( A * ( B - 1 ) / B ) - A * math . floor ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) - A * math . floor ( N / B ) ) <NEWLINE> <DEDENT>
d , e = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 2 ) ] ; e [ 3 ] , e [ 4 ] = e [ 4 ] , e [ 3 ] <NEWLINE> t = 0 <NEWLINE> m = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> f = [ d [ int ( j ) ] for j in m [ i ] ] ; f [ 3 ] , f [ 4 ] = f [ 4 ] , f [ 3 ] <NEWLINE> if f [ 0 ] == e [ 0 ] : <NEWLINE> <INDENT> f = f [ 1 : 5 ] * 2 <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> if f [ j : j + 4 ] == e [ 1 : 5 ] : t = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ( <STRING> , <STRING> ) [ t == 1 ] ) <NEWLINE>
<COMMENT> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = prime_factorize ( a ) <NEWLINE> bb = prime_factorize ( b ) <NEWLINE> ab = list ( set ( aa ) & set ( bb ) ) <NEWLINE> ab . sort ( ) <NEWLINE> print ( len ( ab ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m = 10 <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> while m <= n : <NEWLINE> <INDENT> a . append ( n // m ) <NEWLINE> m *= 5 <NEWLINE> if len ( a ) > 1 : <NEWLINE> <INDENT> b . append ( a [ - 2 ] - a [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> b . append ( a [ - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> ans += ( i + 1 ) * b [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tens = [ ] <NEWLINE> others = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> if s % 10 == 0 : <NEWLINE> <INDENT> tens . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> others . append ( s ) <NEWLINE> <DEDENT> <DEDENT> tens . sort ( reverse = True ) <NEWLINE> others . sort ( reverse = True ) <NEWLINE> <NL> score = sum ( tens ) + sum ( others ) <NEWLINE> if score % 10 == 0 : <NEWLINE> <INDENT> if len ( others ) != 0 : <NEWLINE> <INDENT> print ( score - min ( others ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( score ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K -= 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> index = 0 <NEWLINE> left = A [ index ] <NEWLINE> <NL> for i in range ( K + 1 , N ) : <NEWLINE> <NL> <INDENT> if A [ index ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> index += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) . strip ( ) ) <NEWLINE> count = 0 <NEWLINE> j = N - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> while i < j : <NEWLINE> <INDENT> if C [ j ] == <STRING> : <NEWLINE> <INDENT> C [ i ] , C [ j ] = C [ j ] , C [ i ] <NEWLINE> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> if N >= 1000 : <NEWLINE> <INDENT> a = N - 1000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = N <NEWLINE> <DEDENT> while a >= 1000 : <NEWLINE> <INDENT> a = a - 1000 <NEWLINE> <DEDENT> if a != 0 : <NEWLINE> <INDENT> a = 1000 - a <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def longest_common_subsequence ( s , t ) : <NEWLINE> <INDENT> dp = [ [ 0 ] * ( len ( t ) + 1 ) for _ in range ( len ( s ) + 1 ) ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ j ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def longest_common_subsequence2 ( s , t ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( len ( t ) + 1 ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> si = s [ i ] <NEWLINE> tmp = dp [ : ] <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if si == t [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = tmp [ j ] + 1 <NEWLINE> <DEDENT> elif dp [ j + 1 ] < dp [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = dp [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> X , Y = input ( ) , input ( ) <NEWLINE> print ( longest_common_subsequence2 ( X , Y ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import numpy as np <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( P ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i <= P ** ( 1 / 2 ) : <NEWLINE> <INDENT> if P % i == 0 : <NEWLINE> <INDENT> P //= i <NEWLINE> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> d [ P ] += 1 <NEWLINE> g = np . prod ( [ k ** ( v // N ) for k , v in d . items ( ) ] ) <NEWLINE> print ( g ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * ( max ( A ) + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> for x in range ( a , len ( dp ) , a ) : <NEWLINE> <INDENT> dp [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if ( S - K ) <= ( i + j ) <= S : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> from numba import b1 , i8 , njit , types <NEWLINE> <NL> <NL> @ njit ( types . Tuple ( ( i8 [ : ] , b1 ) ) ( i8 [ : ] ) , cache = True ) <NEWLINE> def f ( A ) : <NEWLINE> <INDENT> n = len ( A ) <NEWLINE> ret = np . zeros_like ( A ) <NEWLINE> for x , p in enumerate ( A ) : <NEWLINE> <INDENT> ret [ max ( 0 , x - p ) ] += 1 <NEWLINE> if x + p + 1 < n : <NEWLINE> <INDENT> ret [ x + p + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> ret = ret . cumsum ( ) <NEWLINE> return ret , np . all ( A == n ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n , k = map ( int , args [ 0 ] . split ( ) ) <NEWLINE> A = np . array ( tuple ( map ( int , args [ 1 ] . split ( ) ) ) , int ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> A , satulated = f ( A ) <NEWLINE> if satulated : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> . join ( map ( str , A ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> ans += t <NEWLINE> s . append ( t ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> <NL> if ans % 10 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> ans -= s [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans % 10 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def partition ( A , p , n ) : <NEWLINE> <INDENT> x = A [ n - 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ n - 1 ] = A [ n - 1 ] , A [ i + 1 ] <NEWLINE> <NL> A [ i + 1 ] = <STRING> . format ( A [ i + 1 ] ) <NEWLINE> <NL> print ( * A ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> partition ( A , 0 , n ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = False <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 - i ) : <NEWLINE> <INDENT> if Y == 10000 * i + 5000 * j + 1000 * ( N - i - j ) : <NEWLINE> <INDENT> a = [ str ( i ) , str ( j ) , str ( N - i - j ) ] <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE> c = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> sgn = 1 <NEWLINE> Q = int ( input ( ) ) <NEWLINE> L = <STRING> <COMMENT> <NEWLINE> R = <STRING> <COMMENT> <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> sgn *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i [ 2 ] == <STRING> : <NEWLINE> <INDENT> if sgn == 1 : <NEWLINE> <INDENT> L += i [ 4 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R += i [ 4 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sgn == 1 : <NEWLINE> <INDENT> R += i [ 4 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L += i [ 4 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if sgn == - 1 : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> R = R [ : : - 1 ] <NEWLINE> print ( R + s + L ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> L = L [ : : - 1 ] <NEWLINE> print ( L + s + R ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> if <STRING> in S and <STRING> in S and <STRING> in S : <NEWLINE> <INDENT> count = collections . Counter ( S ) <NEWLINE> c_value = list ( count . values ( ) ) <NEWLINE> con = c_value [ 0 ] * c_value [ 1 ] * c_value [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> con = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , int ( math . ceil ( ( N + i ) / 2 ) ) ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> if S [ i ] != S [ j + ( j - i ) ] and S [ j ] != S [ j + ( j - i ) ] : <NEWLINE> <INDENT> con -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( con ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( ( a * x ) // b - a * ( x // b ) ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> temp_list = [ ] <NEWLINE> <NL> <NL> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> temp_list . append ( math . gcd ( i + 1 , j + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> temp_set = list ( set ( temp_list ) ) <NEWLINE> <NL> memo = [ 0 ] * len ( temp_set ) <NEWLINE> <NL> for i in temp_list : <NEWLINE> <INDENT> for j in range ( len ( temp_set ) ) : <NEWLINE> <INDENT> if i == temp_set [ j ] : <NEWLINE> <INDENT> memo [ j ] += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( len ( temp_set ) ) : <NEWLINE> <INDENT> ans += memo [ j ] * math . gcd ( temp_set [ j ] , i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> dp = [ - 1 ] * N <NEWLINE> dp [ N - 1 ] = A [ 0 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> target_index = bisect . bisect_left ( dp , A [ i ] ) <NEWLINE> dp [ target_index - 1 ] = A [ i ] <NEWLINE> <NL> <DEDENT> print ( N - dp . count ( - 1 ) ) <NEWLINE>
<COMMENT> <NL> card_num , gate_num = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax , rmin = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> for i in range ( 1 , gate_num ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = max ( lmax , l ) <COMMENT> <NEWLINE> rmin = min ( rmin , r ) <COMMENT> <NEWLINE> <DEDENT> print ( max ( 0 , rmin - lmax + 1 ) ) <COMMENT> <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N >= B - 1 ) : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> if ( N < B - 1 ) : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> ans = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while 1 : <NEWLINE> <INDENT> c -= b <NEWLINE> if a <= 0 or c <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 or c <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if a > 0 else <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> q = [ 7 ] <NEWLINE> Q = [ 0 ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> q . append ( ( q [ i ] * 10 ) % k ) <NEWLINE> if ( q [ i ] + Q [ i ] ) % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> Q . append ( ( q [ i ] + Q [ i ] ) % k ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> T = int ( input ( ) ) <NEWLINE> for _ in range ( T ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> L = max ( A ) . bit_length ( ) <NEWLINE> s = [ 0 ] * L <NEWLINE> ID = A . index ( max ( A ) ) <NEWLINE> <NL> def check ( x ) : <NEWLINE> <INDENT> for i in range ( L - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if ( x >> i ) % 2 : <NEWLINE> <INDENT> x ^= s [ i ] <NEWLINE> <DEDENT> <DEDENT> return ( x == 0 ) <NEWLINE> <NL> <DEDENT> def update ( x ) : <NEWLINE> <INDENT> flag = False <NEWLINE> if x . bit_length ( ) == 60 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> for i in range ( L - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if ( x >> i ) % 2 : <NEWLINE> <INDENT> x ^= s [ i ] <NEWLINE> <DEDENT> <DEDENT> id = x . bit_length ( ) - 1 <NEWLINE> if id >= 0 : <NEWLINE> <INDENT> s [ id ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> L2 = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> k = int ( S [ i ] ) <NEWLINE> if k : <NEWLINE> <INDENT> if check ( A [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L2 = max ( L2 , A [ i ] . bit_length ( ) ) <NEWLINE> update ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> S_l = len ( S ) <NEWLINE> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= S_l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( S [ i ] != S [ j ] ) and ( S [ i ] != S [ k ] ) and ( S [ j ] != S [ k ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> ans = max ( ans , d [ i - 1 ] + d [ i ] + d [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> k = input ( ) . split ( ) <NEWLINE> n = int ( k [ 0 ] ) <NEWLINE> x = int ( k [ 1 ] ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = 0 <NEWLINE> for i1 in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for i2 in range ( i1 + 1 , n ) : <NEWLINE> <INDENT> for i3 in range ( i2 + 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i1 != i2 and i2 != i3 ) and ( i3 != i1 and x == i1 + i2 + i3 ) : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) [ : 2 ] ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) [ : N ] ) ) <NEWLINE> <NL> <NL> def pos ( X ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> sum += int ( i / X ) <NEWLINE> if i % X == 0 : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> <DEDENT> return sum <= K <NEWLINE> <NL> <NL> <DEDENT> low = 1 <NEWLINE> high = 10 ** 9 <NEWLINE> mid = 0 <NEWLINE> ans = 10 ** 9 <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = int ( ( low + high ) / 2 ) <NEWLINE> <COMMENT> <NL> if pos ( mid ) : <NEWLINE> <INDENT> ans = mid <NEWLINE> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> a = r * r * math . pi <NEWLINE> c = 2 * r * math . pi <NEWLINE> print ( <STRING> % ( a , c ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> S = input ( ) <NEWLINE> dct = defaultdict ( int ) <NEWLINE> for s in S : <NEWLINE> <INDENT> dct [ s ] += 1 <NEWLINE> <DEDENT> for key , val in dct . items ( ) : <NEWLINE> <INDENT> if not val == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def cusum ( array ) : <NEWLINE> <INDENT> for i in range ( len ( array ) - 1 ) : <NEWLINE> <INDENT> array [ i + 1 ] += array [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> cusum ( A ) <NEWLINE> cusum ( B ) <NEWLINE> A = [ 0 ] + A <NEWLINE> B = [ 0 ] + B <NEWLINE> tsundoku = 0 <NEWLINE> ia = 0 <NEWLINE> ib = M <NEWLINE> <NL> for ia in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ ia ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ ia ] + B [ ib ] > K and ib >= 0 : <NEWLINE> <INDENT> ib -= 1 <NEWLINE> <DEDENT> tsundoku = max ( ia + ib , tsundoku ) <NEWLINE> <NL> <DEDENT> print ( tsundoku ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> sum = 0 <NEWLINE> <NL> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> c = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( c , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> h , w = MAP ( ) <NEWLINE> a = [ [ 0 ] * ( w + 1 ) ] <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> a . append ( [ 0 ] + LIST ( ) ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> flag = False <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] % 2 == 1 : <NEWLINE> <INDENT> flag = not flag <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> ans . append ( [ i , j , i , j + 1 ] ) <NEWLINE> <DEDENT> elif i < h : <NEWLINE> <INDENT> ans . append ( [ i , j , i + 1 , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w , 0 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] % 2 == 1 : <NEWLINE> <INDENT> flag = not flag <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> if j > 1 : <NEWLINE> <INDENT> ans . append ( [ i , j , i , j - 1 ] ) <NEWLINE> <DEDENT> elif i < h : <NEWLINE> <INDENT> ans . append ( [ i , j , i + 1 , j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ 0 ] * n <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> res [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> [ print ( j ) for j in res ] <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> b = [ int ( i ) for i in a ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c = math . sqrt ( b [ i ] ) <NEWLINE> c = int ( c ) <NEWLINE> if b [ i ] == 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> for j in range ( 2 , b [ i ] ) : <NEWLINE> <INDENT> if b [ i ] % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if math . sqrt ( b [ i ] ) < j : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) [ : : - 1 ] <NEWLINE> cnt = s . count ( <STRING> ) <NEWLINE> <NL> p1 = sum ( pow ( 2 , i , cnt + 1 ) * ( s [ i ] == <STRING> ) for i in range ( n ) ) <NEWLINE> if cnt > 1 : <NEWLINE> <INDENT> m1 = sum ( pow ( 2 , i , cnt - 1 ) * ( s [ i ] == <STRING> ) for i in range ( n ) ) <NEWLINE> <NL> <DEDENT> def op ( n ) : <NEWLINE> <INDENT> popcnt = bin ( n ) . count ( <STRING> ) <NEWLINE> return n % popcnt <NEWLINE> <NL> <DEDENT> pre = [ 0 ] * 1000000 <NEWLINE> for i in range ( 1 , 1000000 ) : <NEWLINE> <INDENT> pre [ i ] = pre [ op ( i ) ] + 1 <NEWLINE> <NL> <DEDENT> def solve ( i ) : <NEWLINE> <INDENT> if s [ - i ] == <STRING> : <NEWLINE> <INDENT> r = ( p1 + pow ( 2 , n - i , cnt + 1 ) ) % ( cnt + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = ( m1 - pow ( 2 , n - i , cnt - 1 ) ) % ( cnt - 1 ) <NEWLINE> <DEDENT> return 1 + pre [ r ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( solve ( i + 1 ) ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> if p == 2 or p == 5 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if int ( s [ i ] ) % p == 0 : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> M = [ 0 ] * p <NEWLINE> M [ 0 ] = 1 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp += ( int ( s [ - i - 1 ] ) * pow ( 10 , i , p ) ) <NEWLINE> tmp %= p <NEWLINE> ans += M [ tmp ] <NEWLINE> M [ tmp ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( gcd ( a , b ) , lcm ( a , b ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> if a [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( a [ 0 ] ) <NEWLINE> <DEDENT> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> and a [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c >= b : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ c ] ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import combinations <NEWLINE> import sys <NEWLINE> <NL> <COMMENT> <NL> dp = [ [ [ 0 ] * 331 for _ in [ 0 ] * 2048 ] for _ in [ 0 ] * 11 ] <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> dp [ 1 ] [ 2 ** i ] [ i ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , 11 ) : <NEWLINE> <INDENT> for used in ( sum ( comb ) for comb in combinations ( [ 2 ** n for n in range ( 10 ) ] , i - 1 ) ) : <NEWLINE> <INDENT> for j in filter ( lambda x : used & 2 ** x == 0 , range ( 10 ) ) : <NEWLINE> <INDENT> for total , count in filter ( lambda p : p [ 1 ] > 0 , enumerate ( dp [ i - 1 ] [ used ] ) ) : <NEWLINE> <INDENT> dp [ i ] [ used | 2 ** j ] [ total + j * i ] += count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n , s in ( map ( int , l . rstrip ( ) . split ( ) ) for l in sys . stdin ) : <NEWLINE> <INDENT> print ( sum ( a [ s ] for a in dp [ n ] if a [ s ] ) if s < 331 else 0 ) <NEWLINE> <DEDENT>
def z_alg ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> Z = [ 0 ] * N <NEWLINE> Z [ 0 ] = N <NEWLINE> i , j = 1 , 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> while i + j < N and S [ j ] == S [ i + j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> Z [ i ] = j <NEWLINE> if j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> k = 1 <NEWLINE> while i + k < N and k + Z [ k ] < j : <NEWLINE> <INDENT> Z [ i + k ] = Z [ k ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> i += k <NEWLINE> j -= k <NEWLINE> <DEDENT> return Z <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> REP_S = <STRING> <NEWLINE> target_len = len ( S ) + len ( T ) - 1 <NEWLINE> while len ( REP_S ) < target_len : <NEWLINE> <INDENT> REP_S += S <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> T_REP_S = T + REP_S <NEWLINE> z = z_alg ( T_REP_S ) <NEWLINE> location_list = list ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if z [ i + len ( T ) ] >= len ( T ) : <NEWLINE> <INDENT> location_list . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( location_list ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> node_flag_list = [ 0 ] * len ( S ) <NEWLINE> for n in location_list : <NEWLINE> <INDENT> node_flag_list [ n ] = 1 <NEWLINE> <DEDENT> depth_list = [ - 1 ] * len ( S ) <NEWLINE> for n in location_list : <NEWLINE> <INDENT> if depth_list [ n ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cur_node = n <NEWLINE> d , has_loop = 0 , False <NEWLINE> while node_flag_list [ cur_node ] == 1 : <NEWLINE> <INDENT> depth_list [ cur_node ] = d <NEWLINE> d += 1 <NEWLINE> cur_node = ( cur_node + len ( T ) ) % len ( S ) <NEWLINE> if cur_node == n : <NEWLINE> <INDENT> has_loop = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if has_loop : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( depth_list ) + 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and k >= 0 : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - tmp ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> digits = 1 <NEWLINE> num , ans = 0 , 0 <NEWLINE> mod_list = [ 0 ] * 2019 <NEWLINE> mod_list [ 0 ] = 1 <NEWLINE> <NL> for c in S : <NEWLINE> <INDENT> num += int ( c ) * digits <NEWLINE> mod_list [ num % 2019 ] += 1 <NEWLINE> digits *= 10 <NEWLINE> digits %= 2019 <NEWLINE> <NL> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += mod_list [ i ] * ( mod_list [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> dx12 , dx34 , dy12 , dy34 = x1 - x2 , x3 - x4 , y1 - y2 , y3 - y4 <NEWLINE> print ( <STRING> if abs ( dx12 * dy34 - dy12 * dx34 ) < 1e-10 else <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <COMMENT> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def getPrime ( n ) : <NEWLINE> <INDENT> n_sqrt = int ( math . sqrt ( n ) ) <NEWLINE> array = [ True ] * ( n_sqrt + 1 ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( 2 , n_sqrt + 1 ) : <NEWLINE> <INDENT> if array [ i ] : <NEWLINE> <INDENT> array [ i ] = False <NEWLINE> result . append ( i ) <NEWLINE> for j in range ( i * 2 , n_sqrt + 1 , i ) : <NEWLINE> <INDENT> array [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> n = N <NEWLINE> prime = getPrime ( n ) <NEWLINE> prime_exp = [ ] <NEWLINE> <COMMENT> <NL> for p in prime : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> n = int ( n / p ) <NEWLINE> <COMMENT> <NL> cnt += 1 <NEWLINE> <DEDENT> if cnt != 0 : <NEWLINE> <INDENT> prime_exp . append ( [ p , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if is_prime ( n ) and n != 1 : <NEWLINE> <INDENT> prime_exp . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for pe in prime_exp : <NEWLINE> <INDENT> ans += int ( ( - 1 + math . sqrt ( 1 + 8 * pe [ 1 ] ) ) / 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> if A [ - 1 ] != 0 : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : ans = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
from numpy import * <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = log ( array ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> B = [ sum ( A [ : K ] ) ] <NEWLINE> <NL> for n in range ( N - K ) : <NEWLINE> <INDENT> B += [ B [ - 1 ] + A [ n + K ] - A [ n ] ] <NEWLINE> <NL> if B [ n ] < B [ n + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def is_valid ( ) : <NEWLINE> <INDENT> x_removed_S = S . replace ( <STRING> , <STRING> ) <NEWLINE> M = len ( x_removed_S ) <NEWLINE> for i in range ( M // 2 ) : <NEWLINE> <INDENT> if x_removed_S [ i ] != x_removed_S [ M - i - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> if is_valid ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> left , right = 0 , N - 1 <NEWLINE> while left < right : <NEWLINE> <INDENT> if S [ left ] == S [ right ] : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif S [ left ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> left += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> inint = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inintm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inintl = lambda : list ( inintm ( ) ) <NEWLINE> instrm = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> instrl = lambda : list ( instrm ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> q = inint ( ) <NEWLINE> <NL> S = deque ( ) <NEWLINE> f = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> S . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> Q = instrl ( ) <NEWLINE> if Q [ 0 ] == <STRING> : <NEWLINE> <INDENT> f = f [ : : - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if f [ 0 ] == 0 : <NEWLINE> <INDENT> if Q [ 1 ] == <STRING> : <NEWLINE> <INDENT> S . appendleft ( Q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( Q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Q [ 1 ] == <STRING> : <NEWLINE> <INDENT> S . append ( Q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . appendleft ( Q [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if f [ 0 ] == 1 : <NEWLINE> <INDENT> S . reverse ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def search ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> pos = deque ( [ ] ) <NEWLINE> <NL> D = [ [ True ] * ( W + 2 ) ] <COMMENT> <NEWLINE> D += [ [ True ] + [ False ] * W + [ True ] for i in range ( H ) ] <COMMENT> <NEWLINE> D . append ( [ True ] * ( W + 2 ) ) <COMMENT> <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> maze = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if maze [ j ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ i + 1 , j + 1 , 0 ] ) <NEWLINE> D [ i + 1 ] [ j + 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while len ( pos ) > 0 : <NEWLINE> <INDENT> h , w , depth = pos . popleft ( ) <NEWLINE> if not D [ h + 1 ] [ w ] : <NEWLINE> <INDENT> pos . append ( [ h + 1 , w , depth + 1 ] ) <NEWLINE> D [ h + 1 ] [ w ] = True <NEWLINE> <NL> <DEDENT> if not D [ h - 1 ] [ w ] : <NEWLINE> <INDENT> pos . append ( [ h - 1 , w , depth + 1 ] ) <NEWLINE> D [ h - 1 ] [ w ] = True <NEWLINE> <NL> <DEDENT> if not D [ h ] [ w + 1 ] : <NEWLINE> <INDENT> pos . append ( [ h , w + 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w + 1 ] = True <NEWLINE> <NL> <DEDENT> if not D [ h ] [ w - 1 ] : <NEWLINE> <INDENT> pos . append ( [ h , w - 1 , depth + 1 ] ) <NEWLINE> D [ h ] [ w - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> print ( search ( ) ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> lst = [ ] <NEWLINE> num = 1 <NEWLINE> pow10 = [ 1 ] <NEWLINE> for _ in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> num = num * 10 % 2019 <NEWLINE> pow10 . append ( num ) <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> for s_num , p10 in zip ( s , pow10 ) : <NEWLINE> <INDENT> num = ( num + ( int ( s_num ) * p10 ) ) % 2019 <NEWLINE> lst . append ( num ) <NEWLINE> <DEDENT> lst . sort ( ) <NEWLINE> <NL> total = 0 <NEWLINE> cnt = 1 <NEWLINE> before = 0 <NEWLINE> for num in lst : <NEWLINE> <INDENT> if before == num : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += cnt * ( cnt - 1 ) // 2 <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> before = num <NEWLINE> <DEDENT> total += cnt * ( cnt - 1 ) // 2 <NEWLINE> print ( total ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> adj_matrix = [ [ 0 ] * N for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj_matrix [ a - 1 ] [ b - 1 ] = 1 <NEWLINE> adj_matrix [ b - 1 ] [ a - 1 ] = 1 <NEWLINE> <NL> <DEDENT> def dfs ( v , used ) : <NEWLINE> <INDENT> if not False in used : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not adj_matrix [ v ] [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if used [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> used [ i ] = True <NEWLINE> ans += dfs ( i , used ) <NEWLINE> used [ i ] = False <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> used = [ False ] * N <NEWLINE> used [ 0 ] = True <NEWLINE> <NL> print ( dfs ( 0 , used ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> head_prob_table = [ [ 0.0 ] * ( N + 1 ) for i in range ( N ) ] <NEWLINE> head_prob = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> head_prob_table [ 0 ] [ 1 ] = head_prob [ 0 ] <NEWLINE> head_prob_table [ 0 ] [ 0 ] = 1 - head_prob [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i + 2 ) : <NEWLINE> <INDENT> head_prob_table [ i ] [ j ] += head_prob_table [ i - 1 ] [ j ] * ( 1 - head_prob [ i ] ) <NEWLINE> if j > 0 : <NEWLINE> <INDENT> head_prob_table [ i ] [ j ] += head_prob_table [ i - 1 ] [ j - 1 ] * head_prob [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( head_prob_table [ N - 1 ] [ ( N + 1 ) // 2 : ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> seq = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> seq . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> seq . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if seq == [ ] : <NEWLINE> <INDENT> seq . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return seq <NEWLINE> <NL> <DEDENT> so = factorization ( n ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( so ) ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> mun = so [ i ] [ 1 ] <NEWLINE> while mun >= j : <NEWLINE> <INDENT> if mun - j >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> mun -= j <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n , a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ [ 0 ] * 2 for _ in range ( n ) ] <NEWLINE> S = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> S += X <NEWLINE> cnt = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> s [ i ] [ cnt ] = 0 <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> s [ i ] [ cnt ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ cnt ] = 2 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( a + b + c ) == 0 : exit ( print ( <STRING> ) ) <NEWLINE> abc = [ a , b , c ] <NEWLINE> ABC = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <NL> ans = [ 0 ] * n <NEWLINE> <NL> def zero ( xy ) : <NEWLINE> <INDENT> x = xy [ 0 ] <NEWLINE> y = xy [ 1 ] <NEWLINE> if abc [ x ] == 0 and abc [ y ] == 0 : <NEWLINE> <INDENT> return - 1 , - 1 <NEWLINE> <DEDENT> elif abc [ x ] == 0 : <NEWLINE> <INDENT> return x , y <NEWLINE> <DEDENT> elif abc [ y ] == 0 : <NEWLINE> <INDENT> return y , x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 3 , 3 <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global ans <NEWLINE> global abc <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = zero ( s [ i ] ) <NEWLINE> if x == - 1 : exit ( print ( <STRING> ) ) <NEWLINE> if x == 3 : <NEWLINE> <INDENT> if i < n - 1 : <NEWLINE> <INDENT> if s [ i ] [ 1 ] in s [ i + 1 ] : <NEWLINE> <INDENT> x = s [ i ] [ 1 ] <NEWLINE> y = s [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s [ i ] [ 0 ] <NEWLINE> y = s [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = s [ i ] [ 0 ] <NEWLINE> y = s [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = x <NEWLINE> abc [ x ] += 1 <NEWLINE> abc [ y ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ABC [ ans [ i ] ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> max_number = height [ 0 ] <NEWLINE> <NL> for i in range ( 1 , height . index ( max ( height ) ) ) : <NEWLINE> <INDENT> if height [ i ] > max_number : <NEWLINE> <INDENT> max_number = height [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += ( max_number - height [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> total += ( max ( height ) * ( N - 1 - height . index ( max ( height ) ) ) - sum ( height [ height . index ( max ( height ) ) + 1 : N ] ) ) <NEWLINE> <NL> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> pwr = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pwr *= 1 * ( i + 1 ) <NEWLINE> pwr = pwr % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( pwr ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> vertex = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> p -= 1 <NEWLINE> vertex [ p ] += x <NEWLINE> <NL> <NL> <DEDENT> def dfs ( n , parent ) : <NEWLINE> <INDENT> for to in edge [ n ] : <NEWLINE> <INDENT> if to == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> vertex [ to ] += vertex [ n ] <NEWLINE> dfs ( to , n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * vertex ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mx = max ( A ) <NEWLINE> f = [ True ] * ( mx + 1 ) <NEWLINE> chk = [ 0 ] * ( mx + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> chk [ a ] += 1 <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> cnt = 2 <NEWLINE> while a * cnt <= mx : <NEWLINE> <INDENT> f [ a * cnt ] = False <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if f [ a ] == True and chk [ a ] <= 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> sss = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( a , b ) <NEWLINE> sss += 6 * tmp <NEWLINE> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> sss += 6 * gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sss += k * ( k + 1 ) // 2 <NEWLINE> print ( sss ) <NEWLINE>
def sort_cmp ( x , y ) : <NEWLINE> <INDENT> if x [ 2 ] == y [ 2 ] : <NEWLINE> <INDENT> return x [ 3 ] < y [ 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x [ 2 ] > x [ 2 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> teams = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> teams . append ( list ( map ( int , raw_input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> teams = sorted ( teams , key = lambda x : - 1e12 * x [ 2 ] + x [ 3 ] * 1e6 + x [ 0 ] ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> threshold = 3 <NEWLINE> for team in teams : <NEWLINE> <INDENT> if len ( A ) == 10 : <NEWLINE> <INDENT> threshold = 2 <NEWLINE> <DEDENT> elif len ( A ) == 20 : <NEWLINE> <INDENT> threshold = 1 <NEWLINE> <NL> <DEDENT> if B . count ( team [ 1 ] ) < threshold : <NEWLINE> <INDENT> A . append ( team [ 0 ] ) <NEWLINE> B . append ( team [ 1 ] ) <NEWLINE> <NL> <DEDENT> if len ( A ) == 26 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> solve ( n ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> output = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_ij = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> output += math . gcd ( gcd_ij , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> com = [ 0 ] <NEWLINE> a = 0 <NEWLINE> v = 0 <NEWLINE> j = 0 <NEWLINE> str1 = <STRING> <NEWLINE> <NL> if N < 27 : <NEWLINE> <INDENT> print ( str1 [ N - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 13 ) : <NEWLINE> <INDENT> a += 26 ** i <NEWLINE> com . append ( a ) <NEWLINE> <DEDENT> for i in range ( 13 ) : <NEWLINE> <INDENT> if N < com [ i ] + 1 : <NEWLINE> <INDENT> v = com [ i - 1 ] <NEWLINE> j = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> N = N - v - 1 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( j - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans . append ( str1 [ N // ( 26 ** i ) ] ) <NEWLINE> if N >= 26 ** i : <NEWLINE> <INDENT> N = N - N // ( 26 ** i ) * ( 26 ** i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
A , B , N = input ( ) . split ( ) <NEWLINE> f = 0 <NEWLINE> if int ( N ) >= int ( B ) : <NEWLINE> <INDENT> f = ( int ( B ) - 1 ) / int ( B ) <NEWLINE> f = f - int ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( N ) / int ( B ) <NEWLINE> f = f - int ( f ) <NEWLINE> <NL> <DEDENT> print ( int ( f * int ( A ) ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( x , k + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z > k or z < y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == y and y == z : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif x == y or y == z or x == z : <NEWLINE> <INDENT> ans += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> dict = { } <NEWLINE> <NL> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> dict [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> dict [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if dict [ i ] != 0 : <NEWLINE> <INDENT> sum += dict [ i ] * i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> sum = sum + ( dict [ B [ i ] [ 0 ] ] * B [ i ] [ 1 ] - dict [ B [ i ] [ 0 ] ] * B [ i ] [ 0 ] ) <NEWLINE> <NL> dict [ B [ i ] [ 1 ] ] += dict [ B [ i ] [ 0 ] ] <NEWLINE> dict [ B [ i ] [ 0 ] ] = 0 <NEWLINE> <COMMENT> <NL> print ( sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = 0 <NEWLINE> a = [ 0 ] + a + [ 0 ] <NEWLINE> for j in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> d += abs ( a [ j ] - a [ j + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i - 1 ] <= a [ i ] <= a [ i + 1 ] or a [ i - 1 ] >= a [ i ] >= a [ i + 1 ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - abs ( a [ i - 1 ] - a [ i ] ) - abs ( a [ i + 1 ] - a [ i ] ) + abs ( a [ i - 1 ] - a [ i + 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ - 1 for i in range ( N + 1 ) ] <NEWLINE> B [ 1 ] = 0 <NEWLINE> n = 1 <NEWLINE> m = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> n = A [ n ] <NEWLINE> m += 1 <NEWLINE> if m == K : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> if B [ n ] == - 1 : <NEWLINE> <INDENT> B [ n ] = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( K - m ) % ( m - B [ n ] ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> n = A [ n ] <NEWLINE> <DEDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def f ( x , y ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> x , y = y , x % y <NEWLINE> return f ( x , y ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += a <NEWLINE> <DEDENT> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += 6 * f ( a , b ) <NEWLINE> <DEDENT> <DEDENT> for a in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <INDENT> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += f ( a , f ( b , c ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> memo = { 0 : 0 } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> j = i <NEWLINE> a = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if j in memo : <NEWLINE> <INDENT> memo [ i ] = memo [ j ] + a <NEWLINE> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 0 <NEWLINE> k = j <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> k //= 2 <NEWLINE> <DEDENT> j %= b <NEWLINE> a += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n1 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> n1 += 1 <NEWLINE> <DEDENT> <DEDENT> if n1 > 1 : <NEWLINE> <INDENT> mup = [ 1 ] <NEWLINE> mdown = [ 1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> mup . append ( mup [ - 1 ] * 2 % ( n1 + 1 ) ) <NEWLINE> mdown . append ( mdown [ - 1 ] * 2 % ( n1 - 1 ) ) <NEWLINE> <DEDENT> mup . reverse ( ) <NEWLINE> mdown . reverse ( ) <NEWLINE> mmup = 0 <NEWLINE> mmdown = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mmup = ( mmup + mup [ i ] * int ( x [ i ] ) ) % ( n1 + 1 ) <NEWLINE> mmdown = ( mmdown + mdown [ i ] * int ( x [ i ] ) ) % ( n1 - 1 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> state = <STRING> <NEWLINE> n1i = n1 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state = <STRING> <NEWLINE> n1i = n1 - 1 <NEWLINE> <DEDENT> if state == <STRING> : <NEWLINE> <INDENT> mm = ( mmup + mup [ i ] ) % n1i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mm = ( mmdown - mdown [ i ] ) % n1i <NEWLINE> <DEDENT> print ( memo [ mm ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> elif n1 == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x [ - 1 ] == <STRING> and i != n - 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if b > n : <NEWLINE> <INDENT> x = n <NEWLINE> ans = int ( a * x // b ) - int ( a * ( x // b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> ans1 = int ( a * x // b ) - int ( a * ( x // b ) ) <NEWLINE> x = ( n // b ) * b - 1 <NEWLINE> ans2 = int ( a * x // b ) - int ( a * ( x // b ) ) <NEWLINE> ans = max ( ans1 , ans2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if W <= 2 : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> for s in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for s in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for s in range ( W - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> for s in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> * c , = map ( int , input ( ) . split ( ) ) <NEWLINE> c = np . array ( c ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> * x , = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( x ) <NEWLINE> <NL> <DEDENT> s = np . array ( s ) . reshape ( ( D , 26 ) ) <NEWLINE> tmps = s * 1 <NEWLINE> dt = [ ] <NEWLINE> cnt = np . array ( [ 0 ] * 26 ) <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <INDENT> x = tmps [ d ] - c * ( d - cnt ) <NEWLINE> y = np . argmax ( x ) <NEWLINE> cnt [ y ] = d + 1 <NEWLINE> dt . append ( y + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( dt [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + str ( x ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> UF = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> _a , _b = map ( int , input ( ) . split ( ) ) <NEWLINE> UF . union ( _a - 1 , _b - 1 ) <NEWLINE> <DEDENT> rt_l = UF . roots ( ) <NEWLINE> ans = 0 <NEWLINE> for _rt in rt_l : <NEWLINE> <INDENT> _len = UF . size ( _rt ) <NEWLINE> if ans < _len : <NEWLINE> <INDENT> ans = _len <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 ; <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> import string <NEWLINE> <NL> OFFSET = ord ( <STRING> ) <NEWLINE> <NL> def to_gamma ( c ) : <NEWLINE> <INDENT> return ord ( c ) - OFFSET <NEWLINE> <NL> <DEDENT> def from_gamma ( gamma , alpha , beta ) : <NEWLINE> <INDENT> return chr ( ( alpha * gamma + beta ) % 26 + OFFSET ) <NEWLINE> <NL> <DEDENT> def affine ( c , alpha , beta ) : <NEWLINE> <INDENT> return from_gamma ( to_gamma ( c ) , alpha , beta ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def search_that ( w ) : <NEWLINE> <INDENT> b = to_gamma ( w [ 2 ] ) <NEWLINE> for a in range ( 26 ) : <NEWLINE> <INDENT> if w [ 0 ] == affine ( <STRING> , a , b ) and w [ 1 ] == affine ( <STRING> , a , b ) : <NEWLINE> <INDENT> return a , b <NEWLINE> <DEDENT> <DEDENT> return - 1 , - 1 <NEWLINE> <NL> <DEDENT> def search_this ( w ) : <NEWLINE> <INDENT> a = ( to_gamma ( w [ 0 ] ) - to_gamma ( w [ 3 ] ) + 26 ) % 26 <NEWLINE> for b in range ( 26 ) : <NEWLINE> <INDENT> if w [ 0 ] == affine ( <STRING> , a , b ) and w [ 1 ] == affine ( <STRING> , a , b ) and w [ 2 ] == affine ( <STRING> , a , b ) and w [ 3 ] == affine ( <STRING> , a , b ) : <NEWLINE> <INDENT> return a , b <NEWLINE> <DEDENT> <DEDENT> return - 1 , - 1 <NEWLINE> <NL> <DEDENT> def search ( w ) : <NEWLINE> <INDENT> if w [ 0 ] == w [ 3 ] : <NEWLINE> <INDENT> return search_that ( w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return search_this ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( f . readline ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = f . readline ( ) . strip ( ) <NEWLINE> words = [ word for word in line . split ( ) if len ( word ) == 4 ] <NEWLINE> for word in words : <NEWLINE> <INDENT> a , b = search ( word ) <NEWLINE> if a != - 1 : <NEWLINE> <INDENT> print ( line . translate ( str . maketrans ( <STRING> . join ( [ affine ( c , a , b ) for c in string . ascii_lowercase ] ) , string . ascii_lowercase ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in line . split ( ) ] <NEWLINE> print ( int ( math . log10 ( a + b ) + 1 ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> print ( <STRING> . format ( cnt , a ) ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> dp = [ - 1 ] * N <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> idx = bisect . bisect_left ( dp , a ) <NEWLINE> dp [ idx - 1 ] = a <NEWLINE> <DEDENT> print ( len ( dp [ bisect . bisect_left ( dp , 0 ) : ] ) ) <NEWLINE>
<NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> check = [ True ] * N <NEWLINE> <NL> for ab in AB : <NEWLINE> <COMMENT> <NL> <INDENT> if H [ ab [ 0 ] - 1 ] < H [ ab [ 1 ] - 1 ] : <NEWLINE> <INDENT> check [ ab [ 0 ] - 1 ] = False <NEWLINE> <NL> <DEDENT> elif H [ ab [ 1 ] - 1 ] < H [ ab [ 0 ] - 1 ] : <NEWLINE> <INDENT> check [ ab [ 1 ] - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check [ ab [ 0 ] - 1 ] = False <NEWLINE> check [ ab [ 1 ] - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( check ) ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> result = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if a in result : <NEWLINE> <INDENT> result [ a ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ a ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> result = sorted ( result . items ( ) ) <NEWLINE> <NL> now = 0 <NEWLINE> for key , value in result : <NEWLINE> <INDENT> now += value <NEWLINE> <NL> if now >= K : <NEWLINE> <INDENT> print ( key ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> m = min ( B - 1 , N ) <NEWLINE> num = math . floor ( ( A * m ) / B ) - A * math . floor ( m / B ) <NEWLINE> print ( num ) <NEWLINE>
def counting_sort ( a , b , k ) : <NEWLINE> <INDENT> c = [ 0 ] * ( k + 1 ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> c [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i ] + c [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> num = a [ i ] <NEWLINE> b [ c [ num ] - 1 ] = num <NEWLINE> c [ num ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> k = max ( a ) <NEWLINE> counting_sort ( a , b , k ) <NEWLINE> print ( b [ 0 ] , end = <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( <STRING> + str ( b [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans_ = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( ans_ , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_list_min = sorted ( p_list ) <NEWLINE> ans = sum ( p_list_min [ 0 : k ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ N - i - 1 ] = A [ N - i - 1 ] + B [ N - i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] * B [ i + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> b = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> asum = a . cumsum ( ) <NEWLINE> bsum = b . cumsum ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for ind , i in enumerate ( asum ) : <NEWLINE> <INDENT> if i > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> mx = np . searchsorted ( bsum , K - i , side = <STRING> ) - 1 <NEWLINE> ans = max ( ans , ind + mx , ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
from math import pi <NEWLINE> <NL> instr = input ( ) <NEWLINE> instrSp = instr . split ( ) <NEWLINE> <NL> a = float ( instrSp [ 0 ] ) <NEWLINE> <NL> print ( <STRING> . format ( a = a * a * pi , b = 2 * a * pi ) ) <NEWLINE> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> h , w , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x1 , y1 , x2 , y2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x1 , y1 , x2 , y2 = x1 - 1 , y1 - 1 , x2 - 1 , y2 - 1 <NEWLINE> dp = [ [ - 1 ] * w for _ in range ( h ) ] <NEWLINE> <COMMENT> <NL> que = deque ( ) <NEWLINE> c = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> dp [ x1 ] [ y1 ] = 0 <NEWLINE> <COMMENT> <NL> que . append ( ( x1 , y1 ) ) <NEWLINE> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> while que : <NEWLINE> <INDENT> x , y = que . popleft ( ) <NEWLINE> if x == x2 and y == y2 : <NEWLINE> <INDENT> exit ( print ( dp [ x ] [ y ] ) ) <NEWLINE> <DEDENT> for dx , dy in [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> xx = x + dx * i <NEWLINE> yy = y + dy * i <NEWLINE> if not ( 0 <= xx < h and 0 <= yy < w ) or c [ xx ] [ yy ] == <STRING> : break <NEWLINE> if 0 <= dp [ xx ] [ yy ] <= dp [ x ] [ y ] : break <NEWLINE> if dp [ xx ] [ yy ] == - 1 : que . append ( ( xx , yy ) ) <NEWLINE> dp [ xx ] [ yy ] = dp [ x ] [ y ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> target = 7 ; ans = - 1 <NEWLINE> if not k % 2 == 0 : <NEWLINE> <NL> <INDENT> for i in range ( 1 , k + 10 ) : <NEWLINE> <INDENT> if target % k == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> target = ( target * 10 + 7 ) % k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> multiples = [ 1 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> bucket = Counter ( A ) <NEWLINE> res = 0 <NEWLINE> <NL> for num in A : <NEWLINE> <INDENT> if bucket [ num ] == 1 and multiples [ num ] == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> if multiples [ num ] == 1 : <NEWLINE> <INDENT> for i in range ( num , 10 ** 6 + 1 , num ) : <NEWLINE> <INDENT> multiples [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> from collections import deque <NEWLINE> <NL> h , w = nii ( ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> <NL> def BFS ( sy , sx , ans ) : <NEWLINE> <INDENT> s [ sy ] [ sx ] = <STRING> <NEWLINE> <NL> que = deque ( ) <NEWLINE> que . append ( ( sy , sx ) ) <NEWLINE> <NL> b_cnt = 1 <NEWLINE> w_cnt = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> y , x = que . popleft ( ) <NEWLINE> for dy , dx in [ [ - 1 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if 0 <= ny < h and 0 <= nx < w : <NEWLINE> <INDENT> if s [ y ] [ x ] == <STRING> and s [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> w_cnt += 1 <NEWLINE> s [ ny ] [ nx ] = <STRING> <NEWLINE> que . append ( ( ny , nx ) ) <NEWLINE> <DEDENT> if s [ y ] [ x ] == <STRING> and s [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> b_cnt += 1 <NEWLINE> s [ ny ] [ nx ] = <STRING> <NEWLINE> que . append ( ( ny , nx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans += b_cnt * w_cnt <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans = BFS ( i , j , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] >= a [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step = a [ i - 1 ] - a [ i ] <NEWLINE> a [ i ] += step <NEWLINE> ans += step <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P . sort ( ) <NEWLINE> print ( sum ( P [ : K ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> for a , b in ab : <NEWLINE> <INDENT> distance = [ abs ( a - c ) + abs ( b - d ) for c , d in cd ] <NEWLINE> print ( distance . index ( min ( distance ) ) + 1 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> plus = [ i ** 5 for i in range ( 1000 ) ] <NEWLINE> <NL> for num in plus : <NEWLINE> <INDENT> if abs ( X - num ) in plus : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( X - num ) in plus : <NEWLINE> <INDENT> print ( plus . index ( num ) , - 1 * plus . index ( X - num ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( plus . index ( num ) , plus . index ( num - X ) ) <NEWLINE> <DEDENT>
n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> values = [ ] <NEWLINE> weights = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v , weight = map ( int , input ( ) . split ( ) ) <NEWLINE> values . append ( v ) <NEWLINE> weights . append ( weight ) <NEWLINE> <NL> <DEDENT> dp = [ 0 for i in range ( w + 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( weights [ i ] , w + 1 ) : <NEWLINE> <INDENT> dp [ j ] = max ( dp [ j ] , dp [ j - weights [ i ] ] + values [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ w ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> point = A [ i ] <NEWLINE> point_ = A [ i + K ] <NEWLINE> if point < point_ : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ - 1 for _ in range ( n ) ] <NEWLINE> V = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> V [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if dp [ x ] != - 1 : <NEWLINE> <INDENT> return dp [ x ] <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> for v in V [ x ] : <NEWLINE> <INDENT> t = max ( t , f ( v ) + 1 ) <NEWLINE> <NL> <DEDENT> dp [ x ] = t <NEWLINE> return dp [ x ] <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = max ( t , f ( i ) ) <NEWLINE> <NL> <DEDENT> print ( t ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> check_id = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> check_id = a [ check_id - 1 ] <NEWLINE> if check_id == 2 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check_id != 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k <= b + a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif k > a + b : <NEWLINE> <INDENT> print ( a + ( - 1 ) * ( k - a - b ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for num in range ( n ) : <NEWLINE> <INDENT> x *= a [ num ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 6 ) <NEWLINE> <NL> <NL> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . strip ( ) [ : : - 1 ] <NEWLINE> MOD = 2019 <NEWLINE> T = [ 0 , int ( S [ 0 ] ) ] <NEWLINE> t10 = 1 <NEWLINE> for s in S [ 1 : ] : <NEWLINE> <INDENT> t10 *= 10 <NEWLINE> t10 %= MOD <NEWLINE> T . append ( ( T [ - 1 ] + int ( s ) * t10 ) % MOD ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> cT = Counter ( T ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for k in T : <NEWLINE> <INDENT> cT [ k ] -= 1 <NEWLINE> ans += cT [ k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> v *= i <NEWLINE> if v > 10 ** 18 : <NEWLINE> <INDENT> v = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( v ) <NEWLINE>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> <NL> L . append ( 10e10 ) <NEWLINE> R . append ( 10e10 ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> print ( * A ) <NEWLINE> print ( count ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( n // i ) * ( n // i + 1 ) * i // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> d = collections . defaultdict ( set ) <NEWLINE> i = 0 <NEWLINE> ans2 = 0 <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans2 += 1 <NEWLINE> continue <NEWLINE> <DEDENT> g = math . gcd ( a , b ) <NEWLINE> if g != 0 : <NEWLINE> <INDENT> a = a // g <NEWLINE> b = b // g <NEWLINE> <NL> <DEDENT> d [ ( a , b ) ] . add ( i ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> r = set ( ) <NEWLINE> <NL> dd = [ 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dd . append ( dd [ i - 1 ] * 2 % mod ) <NEWLINE> <NL> <DEDENT> r = set ( ) <NEWLINE> ans = 1 <NEWLINE> for a , b in d : <NEWLINE> <INDENT> if ( a , b ) in r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s1 = d [ ( a , b ) ] <NEWLINE> if ( - a , - b ) in d : <NEWLINE> <INDENT> s1 |= d [ ( - a , - b ) ] <NEWLINE> <DEDENT> l1 = len ( s1 ) <NEWLINE> r . add ( ( - a , - b ) ) <NEWLINE> if l1 : <NEWLINE> <INDENT> s2 = set ( ) <NEWLINE> if ( - b , a ) in d : <NEWLINE> <INDENT> s2 |= d [ ( - b , a ) ] <NEWLINE> <DEDENT> if ( b , - a ) in d : <NEWLINE> <INDENT> s2 |= d [ ( b , - a ) ] <NEWLINE> <DEDENT> s2 -= s1 <NEWLINE> l2 = len ( s2 ) <NEWLINE> if l2 : <NEWLINE> <INDENT> ans *= dd [ l1 ] + dd [ l2 ] - 1 <NEWLINE> N -= l1 + l2 <NEWLINE> ans %= mod <NEWLINE> r . add ( ( - b , a ) ) <NEWLINE> r . add ( ( b , - a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if N : <NEWLINE> <INDENT> ans *= dd [ N ] <NEWLINE> <DEDENT> ans += ans2 <NEWLINE> ans -= 1 <NEWLINE> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = list ( input ( ) ) <NEWLINE> sumN = 0 <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> sumN += int ( N [ i ] ) <NEWLINE> <NL> <DEDENT> if sumN % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) . strip ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in array : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in array : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> def func ( i , j , k ) : <NEWLINE> <INDENT> return ( i * k ) // j - i * ( k // j ) <NEWLINE> <DEDENT> m = min ( n , b - 1 ) <NEWLINE> r = ( a * min ( n , b - 1 ) ) // b <NEWLINE> while ( ( a * m ) // b ) == r : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> print ( func ( a , b , m + 1 ) ) <NEWLINE>
import heapq <NEWLINE> N , M , init_silver = map ( int , input ( ) . split ( ) ) <NEWLINE> MAX_COST = 2500 <NEWLINE> init_silver = min ( init_silver , MAX_COST ) <NEWLINE> <NL> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> u , v , silver_cost , time_cost = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> G [ u ] . append ( [ v , silver_cost , time_cost ] ) <NEWLINE> G [ v ] . append ( [ u , silver_cost , time_cost ] ) <NEWLINE> <NL> <DEDENT> change_rate , change_cost = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> rate , cost = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ i ] . append ( [ i , - rate , cost ] ) <COMMENT> <NEWLINE> change_rate . append ( rate ) <NEWLINE> change_cost . append ( cost ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> dp = [ [ float ( <STRING> ) ] * ( MAX_COST + 1 ) for _ in range ( N ) ] <NEWLINE> dp [ 0 ] [ init_silver ] = 0 <NEWLINE> <NL> <COMMENT> <NL> hq = [ ( 0 , 0 , init_silver ) ] <NEWLINE> while hq : <NEWLINE> <INDENT> time , node , silver = heapq . heappop ( hq ) <NEWLINE> <NL> for to , silver_cost , time_cost in G [ node ] : <NEWLINE> <INDENT> remain_silver = min ( silver - silver_cost , MAX_COST ) <NEWLINE> if remain_silver < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dp_next_value = time + time_cost <NEWLINE> if dp [ to ] [ remain_silver ] <= dp_next_value : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dp [ to ] [ remain_silver ] = dp_next_value <NEWLINE> heapq . heappush ( hq , ( dp_next_value , to , remain_silver ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * [ min ( d ) for d in dp [ 1 : ] ] , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 1 ] * ( N + 1 ) <NEWLINE> d [ 0 ] -= A [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ i + 1 ] = d [ i ] * 2 - A [ i + 1 ] <NEWLINE> <NL> <DEDENT> if d [ - 1 ] < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ - 1 ] = A [ - 1 ] <NEWLINE> <DEDENT> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> x = d [ i ] <NEWLINE> x += A [ i - 1 ] <NEWLINE> if d [ i - 1 ] * 2 < x : <NEWLINE> <INDENT> y = x - A [ i - 1 ] <NEWLINE> if ( y + 1 ) // 2 + A [ i - 1 ] <= d [ i - 1 ] * 2 : <NEWLINE> <INDENT> x = d [ i - 1 ] * 2 <NEWLINE> <DEDENT> <DEDENT> d [ i - 1 ] = min ( x , d [ i - 1 ] + A [ i - 1 ] ) <NEWLINE> <DEDENT> print ( sum ( d ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = c . count ( <STRING> ) <NEWLINE> ans = c [ N - cnt : ] . count ( <STRING> ) <NEWLINE> if cnt != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> stocks = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> money += ( A [ i ] * stocks ) <NEWLINE> stocks = 0 <NEWLINE> <DEDENT> elif A [ i + 1 ] > A [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> plus_stock , money = divmod ( money , A [ i ] ) <NEWLINE> stocks += plus_stock <NEWLINE> <DEDENT> elif A [ i + 1 ] < A [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> money += ( A [ i ] * stocks ) <NEWLINE> stocks = 0 <NEWLINE> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
n = input ( ) <NEWLINE> a = [ int ( num ) for num in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> mod_value = 10 ** 9 + 7 <NEWLINE> <NL> sum = 0 <NEWLINE> total = 0 <NEWLINE> for i in reversed ( range ( 1 , len ( a ) ) ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> total += a [ i - 1 ] * sum <NEWLINE> <NL> <DEDENT> print ( total % mod_value ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> ans = [ None ] * Q <NEWLINE> Asum = sum ( A ) <NEWLINE> A_Counter = Counter ( A ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> Asum = Asum + ( C - B ) * A_Counter [ B ] <NEWLINE> A_Counter [ C ] += A_Counter [ B ] <NEWLINE> A_Counter [ B ] = 0 <NEWLINE> <NL> ans [ q ] = Asum <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> dic = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> dic [ s ] = dic . get ( s , 0 ) + 1 <NEWLINE> <NL> <DEDENT> print ( len ( dic . keys ( ) ) ) <NEWLINE>
import bisect <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> import queue <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def read_values ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def read_index ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def read_list ( ) : return list ( read_values ( ) ) <NEWLINE> def read_lists ( N ) : return [ read_list ( ) for n in range ( N ) ] <NEWLINE> def init_dp1 ( init , N ) : return [ init for _ in range ( N ) ] <NEWLINE> def init_dp2 ( init , N , M ) : return [ [ init for _ in range ( M ) ] for _ in range ( N ) ] <NEWLINE> <NL> <NL> class V : <NEWLINE> <INDENT> def __init__ ( self , f , v = None ) : <NEWLINE> <INDENT> self . f = f <NEWLINE> self . v = v <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . v ) <NEWLINE> <NL> <DEDENT> def ud ( self , n ) : <NEWLINE> <INDENT> if n is None : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . v is None : <NEWLINE> <INDENT> self . v = n <NEWLINE> return <NEWLINE> <DEDENT> self . v = self . f ( self . v , n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = read_values ( ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> L = N // 2 <NEWLINE> R = L + 1 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> print ( L , R ) <NEWLINE> L -= 1 <NEWLINE> R += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L = 1 <NEWLINE> R = M + 1 <NEWLINE> for _ in range ( M , 0 , - 2 ) : <NEWLINE> <INDENT> print ( L , R ) <NEWLINE> L += 1 <NEWLINE> R -= 1 <NEWLINE> <NL> <DEDENT> L = M + 2 <NEWLINE> R = 2 * M + 1 <NEWLINE> for _ in range ( M - 1 , 0 , - 2 ) : <NEWLINE> <INDENT> print ( L , R ) <NEWLINE> L += 1 <NEWLINE> R -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 1 or W == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( H * W ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( H * W ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( H * W + 1 ) // 2 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n , d , a = MAP ( ) <NEWLINE> xh = [ LIST ( ) for i in range ( n ) ] <NEWLINE> <NL> xh = sorted ( xh , key = lambda x : ( x [ 0 ] ) ) <NEWLINE> q = deque ( ) <NEWLINE> ca = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cx , ch = xh [ i ] [ 0 ] , xh [ i ] [ 1 ] <NEWLINE> <NL> while q and q [ 0 ] [ 0 ] < cx : <NEWLINE> <INDENT> qx , qa = q . popleft ( ) <NEWLINE> ca -= qa <NEWLINE> <NL> <DEDENT> if ch - ca <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cn = ( ch - ca + a - 1 ) // a <NEWLINE> cnt += cn <NEWLINE> ca += cn * a <NEWLINE> q . append ( [ cx + 2 * d , cn * a ] ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N , K = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> A = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> scorerange = N - K <NEWLINE> for semester in range ( scorerange ) : <NEWLINE> <INDENT> if ( A [ semester ] < A [ semester + K ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
mod = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> <NL> S = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> S [ 1 ] = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> S [ i + 1 ] = S [ i ] <NEWLINE> for l , r in A : <NEWLINE> <INDENT> S [ i + 1 ] += S [ max ( 0 , i - l + 1 ) ] - S [ max ( 0 , i - r ) ] <NEWLINE> <DEDENT> S [ i + 1 ] %= mod <NEWLINE> <DEDENT> print ( ( S [ N ] - S [ N - 1 ] ) % mod ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> j = 0 <NEWLINE> st = 0 <COMMENT> <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < W : <NEWLINE> <INDENT> while 0 < a [ st ] and j < W : <NEWLINE> <INDENT> res . append ( str ( st + 1 ) ) <NEWLINE> j += 1 <NEWLINE> a [ st ] -= 1 <NEWLINE> <DEDENT> if a [ st ] == 0 : <NEWLINE> <INDENT> st += 1 <NEWLINE> <DEDENT> <DEDENT> if i % 2 == 1 : <NEWLINE> <INDENT> res . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( res ) ) <NEWLINE> res = [ ] <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( input ( ) ) <NEWLINE> <NL> R = li . count ( <STRING> ) <NEWLINE> G = li . count ( <STRING> ) <NEWLINE> B = li . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if 2 * j - i > n - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if li [ i ] != li [ j ] : <NEWLINE> <INDENT> if li [ 2 * j - i ] != li [ i ] and li [ 2 * j - i ] != li [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( R * G * B - cnt ) <NEWLINE>
<COMMENT> <NL> import numpy <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> answer = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> answer . append ( uf . size ( i ) ) <NEWLINE> <DEDENT> print ( max ( answer ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= i + 1 <NEWLINE> ans %= 1000000007 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> <NL> ls = len ( s ) <NEWLINE> t = [ 0 ] <NEWLINE> j = 1 <NEWLINE> for i in range ( ls ) : <NEWLINE> <INDENT> u = ( int ( s [ ls - 1 - i ] ) * j + t [ - 1 ] ) % 2019 <NEWLINE> t . append ( u ) <NEWLINE> j = ( j * 10 ) % 2019 <NEWLINE> <DEDENT> c = Counter ( t ) <NEWLINE> k = list ( c . keys ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in k : <NEWLINE> <INDENT> ans += c [ i ] * ( c [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> answer = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> answer *= A [ i ] <NEWLINE> if answer > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) - 1 <NEWLINE> <NL> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> or i == k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s [ i ] ) <NEWLINE>
<COMMENT> <NL> <NL> n , m , l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> mat_sum = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> mat_sum += a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> if j == l - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( mat_sum ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( mat_sum ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> <NL> print ( len ( set ( S ) ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = input ( ) <NEWLINE> i = 0 <NEWLINE> while i < a and i < len ( b ) : <NEWLINE> <INDENT> print ( end = b [ i ] ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> if a < len ( b ) : <NEWLINE> <INDENT> print ( end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if a [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> req = [ 0 ] * n <NEWLINE> req [ - 1 ] = a [ - 1 ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> req [ - i ] = req [ - ( i - 1 ) ] + a [ - i ] <NEWLINE> <DEDENT> l = [ 0 ] * ( n + 1 ) <NEWLINE> l [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> M = ( l [ i - 1 ] - a [ i - 1 ] ) * 2 <NEWLINE> l [ i ] = min ( M , req [ i - 1 ] ) <NEWLINE> <DEDENT> if l [ - 1 ] < a [ - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( l ) ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> answer = float ( <STRING> ) <NEWLINE> for s in range ( len ( S ) ) : <NEWLINE> <INDENT> if len ( S ) - s < len ( T ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <NL> <INDENT> if S [ s + i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> answer = min ( answer , count ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
ryou = [ 0 ] * 4 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> ryou [ i ] = [ 0 ] * 3 <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> ryou [ i ] [ j ] = [ 0 ] * 10 <NEWLINE> <DEDENT> <DEDENT> sep = <STRING> * 20 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ryou [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> s += <STRING> . join ( map ( str , ryou [ i ] [ j ] ) ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT> if not i == 3 : <NEWLINE> <INDENT> print ( sep ) <NEWLINE> <DEDENT> <DEDENT>
r = float ( input ( ) ) <NEWLINE> area = r ** 2 * 3.141592653589 <NEWLINE> enshuu = r * 2 * 3.141592653589 <NEWLINE> print ( <STRING> . format ( area , enshuu ) ) <NEWLINE>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ [ 0 for i in range ( c + 1 ) ] for j in range ( r + 1 ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> a [ i ] = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> rowSum = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> rowSum += a [ i ] [ j ] <NEWLINE> <DEDENT> a [ i ] . append ( rowSum ) <NEWLINE> <DEDENT> for i in range ( c + 1 ) : <NEWLINE> <INDENT> columnSum = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> columnSum += a [ j ] [ i ] <NEWLINE> <DEDENT> a [ r ] [ i ] = columnSum <NEWLINE> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> print ( a [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ i ] [ c ] ) <NEWLINE> <DEDENT>
from heapq import heappop , heappush <NEWLINE> import sys <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> tree_height = [ 0 ] + [ int ( sys . stdin . readline ( ) ) for _ in [ 0 ] * N ] <NEWLINE> edges = [ [ ] for _ in [ 0 ] * ( N + 1 ) ] <NEWLINE> for a , b , t in ( map ( int , l . split ( ) ) for l in sys . stdin ) : <NEWLINE> <INDENT> edges [ a ] . append ( ( b , t ) ) <NEWLINE> edges [ b ] . append ( ( a , t ) ) <NEWLINE> <NL> <DEDENT> vertices = [ float ( <STRING> ) ] * ( N + 1 ) <NEWLINE> pq = [ ( 0 , 1 , X ) ] <NEWLINE> while pq : <NEWLINE> <INDENT> time , v , height = heappop ( pq ) <NEWLINE> if v == N : <NEWLINE> <INDENT> print ( time + ( tree_height [ v ] - height ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if time > vertices [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> max_height = tree_height [ v ] <NEWLINE> for to , dist in edges [ v ] : <NEWLINE> <INDENT> if max_height - dist < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> new_height = height - dist <NEWLINE> new_time = time + dist <NEWLINE> if new_height < 0 : <NEWLINE> <INDENT> new_time , new_height = new_time - new_height , 0 <NEWLINE> <DEDENT> elif new_height > tree_height [ to ] : <NEWLINE> <INDENT> new_time , new_height = new_time + ( new_height - tree_height [ to ] ) , tree_height [ to ] <NEWLINE> <NL> <DEDENT> if vertices [ to ] > new_time : <NEWLINE> <INDENT> vertices [ to ] = new_time <NEWLINE> heappush ( pq , ( new_time , to , new_height ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rec = [ True ] * ( n + 2 ) <NEWLINE> now = 0 <NEWLINE> stp = [ 1 ] <NEWLINE> <NL> while rec [ now ] : <NEWLINE> <INDENT> rec [ now ] = False <NEWLINE> now = a [ now ] - 1 <NEWLINE> stp . append ( now + 1 ) <NEWLINE> <DEDENT> before_loop = stp . index ( now + 1 ) <NEWLINE> loop = stp [ before_loop : - 1 ] <NEWLINE> if k <= ( before_loop + 1 ) : <NEWLINE> <INDENT> print ( stp [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( k - before_loop ) % len ( loop ) <NEWLINE> print ( loop [ r ] ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> ans = 1 <NEWLINE> fail = False <NEWLINE> zero = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( not fail ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> if ( not fail and ans > 1000000000000000000 or ans < 0 ) : <NEWLINE> <INDENT> fail = True <NEWLINE> <DEDENT> elif ( a [ i ] == 0 ) : <NEWLINE> <INDENT> zero = True <NEWLINE> ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( fail and not zero ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from bisect import bisect_left , bisect_right <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> from itertools import islice <NEWLINE> from math import floor , log2 , sqrt <NEWLINE> from operator import itemgetter <NEWLINE> from sys import stdin , stdout <NEWLINE> <NL> <NL> def sort3 ( i , j , k ) : <NEWLINE> <INDENT> if i > j : <NEWLINE> <INDENT> if j > k : <NEWLINE> <INDENT> return ( 2 , 1 , 0 ) <NEWLINE> <DEDENT> elif i > k : <NEWLINE> <INDENT> return ( 1 , 2 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( 1 , 0 , 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i > k : <NEWLINE> <INDENT> return ( 2 , 0 , 1 ) <NEWLINE> <DEDENT> elif j > k : <NEWLINE> <INDENT> return ( 0 , 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( 0 , 1 , 2 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def partition ( ps , lo , hi , dim ) : <NEWLINE> <INDENT> mid = ( lo + hi ) // 2 <NEWLINE> ns = ( lo , mid , hi ) <NEWLINE> n0 , n1 , n2 = sort3 ( ps [ lo ] [ dim ] , ps [ mid ] [ dim ] , ps [ hi ] [ dim ] ) <NEWLINE> ps [ lo ] , ps [ mid ] , ps [ hi ] = ps [ ns [ n1 ] ] , ps [ ns [ n0 ] ] , ps [ ns [ n2 ] ] <NEWLINE> v = ps [ lo ] [ dim ] <NEWLINE> i , j = lo , hi <NEWLINE> while True : <NEWLINE> <INDENT> i , j = i + 1 , j - 1 <NEWLINE> while ps [ i ] [ dim ] < v : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> while ps [ j ] [ dim ] > v : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if i >= j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ps [ i ] , ps [ j ] = ps [ j ] , ps [ i ] <NEWLINE> <DEDENT> ps [ j ] , ps [ lo ] = ps [ lo ] , ps [ j ] <NEWLINE> return j <NEWLINE> <NL> <NL> <DEDENT> def sort ( ps , lo , hi , dim ) : <NEWLINE> <INDENT> for i , p in enumerate ( sorted ( ps [ lo : hi + 1 ] , key = itemgetter ( dim ) ) ) : <NEWLINE> <INDENT> ps [ lo + i ] = p <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def halve ( ps , s , t , dim ) : <NEWLINE> <INDENT> mid = ( s + t ) // 2 <NEWLINE> while t - s > 100 : <NEWLINE> <INDENT> i = partition ( ps , s , t , dim ) <NEWLINE> if i > mid : <NEWLINE> <INDENT> t = i - 1 <NEWLINE> <DEDENT> elif i < mid : <NEWLINE> <INDENT> s = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return mid <NEWLINE> <NL> <DEDENT> <DEDENT> sort ( ps , s , t , dim ) <NEWLINE> return mid <NEWLINE> <NL> <NL> <DEDENT> def build ( ps , n , sz , _dim ) : <NEWLINE> <INDENT> q = deque ( [ ( 0 , n - 1 , 0 ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> s , t , lv = q . popleft ( ) <NEWLINE> dim , _ = _dim ( lv ) <NEWLINE> if t - s < sz : <NEWLINE> <INDENT> sort ( ps , s , t , dim ) <NEWLINE> continue <NEWLINE> <DEDENT> mid = halve ( ps , s , t , dim ) <NEWLINE> if mid - 1 > s : <NEWLINE> <INDENT> q . append ( ( s , mid - 1 , lv + 1 ) ) <NEWLINE> <DEDENT> if t > mid + 1 : <NEWLINE> <INDENT> q . append ( ( mid + 1 , t , lv + 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def search ( ps , vs , n , sz , _dim , s , t ) : <NEWLINE> <INDENT> q = deque ( [ ( 0 , n - 1 , 0 ) ] ) <NEWLINE> ret = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> i , j , lv = q . popleft ( ) <NEWLINE> dim , rdim = _dim ( lv ) <NEWLINE> sd , td , sr , tr = s [ dim ] , t [ dim ] , s [ rdim ] , t [ rdim ] <NEWLINE> if j - i < sz : <NEWLINE> <INDENT> left = bisect_left ( vs [ dim ] , sd , i , j + 1 ) <NEWLINE> right = bisect_right ( vs [ dim ] , td , i , j + 1 ) <NEWLINE> ret . extend ( [ p [ 2 ] for p in ps [ left : right ] if sr <= p [ rdim ] <= tr ] ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> mid = ( i + j ) // 2 <NEWLINE> if td < ps [ mid ] [ dim ] : <NEWLINE> <INDENT> q . append ( ( i , mid - 1 , lv + 1 ) ) <NEWLINE> <DEDENT> elif sd > ps [ mid ] [ dim ] : <NEWLINE> <INDENT> q . append ( ( mid + 1 , j , lv + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sr <= ps [ mid ] [ rdim ] <= tr : <NEWLINE> <INDENT> ret . append ( ps [ mid ] [ 2 ] ) <NEWLINE> <DEDENT> q . append ( ( i , mid - 1 , lv + 1 ) ) <NEWLINE> q . append ( ( mid + 1 , j , lv + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ret . sort ( ) <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> def dimension ( ps , n ) : <NEWLINE> <INDENT> @ lru_cache ( maxsize = n ) <NEWLINE> def _dimension ( lv ) : <NEWLINE> <INDENT> return pat [ lv % len ( pat ) ] <NEWLINE> <NL> <DEDENT> cx = len ( set ( [ p [ 0 ] for p in ps ] ) ) <NEWLINE> cy = len ( set ( [ p [ 1 ] for p in ps ] ) ) <NEWLINE> <NL> if cx < cy : <NEWLINE> <INDENT> m , s = 1 , 0 <NEWLINE> ratio = min ( cy // cx , floor ( log2 ( n ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m , s = 0 , 1 <NEWLINE> ratio = min ( cx // cy , floor ( log2 ( n ) ) ) <NEWLINE> <NL> <DEDENT> pat = [ ] <NEWLINE> for _ in range ( ratio ) : <NEWLINE> <INDENT> pat . append ( ( m , s ) ) <NEWLINE> <DEDENT> pat . append ( ( s , m ) ) <NEWLINE> <NL> return _dimension <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> sz = floor ( sqrt ( n ) ) <NEWLINE> ps = [ ] <NEWLINE> for i , line in enumerate ( islice ( stdin , n ) ) : <NEWLINE> <INDENT> x , y = map ( int , line . split ( ) ) <NEWLINE> ps . append ( ( x , y , i ) ) <NEWLINE> <NL> <DEDENT> dim = dimension ( ps , n ) <NEWLINE> build ( ps , n , sz , dim ) <NEWLINE> <NL> input ( ) <COMMENT> <NEWLINE> vs = ( [ p [ 0 ] for p in ps ] , [ p [ 1 ] for p in ps ] ) <NEWLINE> for line in stdin : <NEWLINE> <INDENT> sx , tx , sy , ty = [ int ( v ) for v in line . split ( ) ] <NEWLINE> s = <STRING> . join ( [ <STRING> for id_ in <NEWLINE> <INDENT> search ( ps , vs , n , sz , dim , ( sx , sy ) , ( tx , ty ) ) ] ) <NEWLINE> <DEDENT> stdout . write ( s + <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> data [ b - 1 ] += 1 <NEWLINE> if data [ b - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if b == n : <NEWLINE> <INDENT> data [ a - 1 ] += 1 <NEWLINE> if data [ a - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , K , Q , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = [ K ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for x in ans : <NEWLINE> <INDENT> y = x - Q <NEWLINE> print ( <STRING> if y > 0 else <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> r = [ ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> r . append ( i ) <NEWLINE> <NL> <DEDENT> minv = r [ 0 ] <NEWLINE> maxv = r [ 1 ] - r [ 0 ] <NEWLINE> <NL> for j in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( maxv , r [ j ] - minv ) <NEWLINE> minv = min ( minv , r [ j ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( [ a [ i ] , i + 1 ] ) <NEWLINE> <DEDENT> l = sorted ( l ) <NEWLINE> ans = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> ans . append ( str ( l [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> roads = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> roads [ a ] . append ( b ) <NEWLINE> roads [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in roads [ i ] : <NEWLINE> <INDENT> if h [ i ] <= h [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = S [ i ] - 1 <NEWLINE> d [ i ] = j <NEWLINE> if j in d : <NEWLINE> <INDENT> if d [ j ] == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
def main4 ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = set ( ) <NEWLINE> G = set ( ) <NEWLINE> B = set ( ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . add ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . add ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> B . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> a , b = sorted ( [ r , g ] ) <NEWLINE> tmp = len ( B ) <NEWLINE> <NL> if ( ( b + a ) % 2 == 0 ) and ( ( b + a ) // 2 ) in B : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <NL> <DEDENT> if ( 2 * a - b ) in B : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <NL> <DEDENT> if ( 2 * b - a ) in B : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <NL> <DEDENT> ans += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main4 ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ a - 1 for a in A ] <NEWLINE> <NL> visit = [ 0 ] * N <NEWLINE> turn = [ - 1 ] * N <NEWLINE> <NL> visit [ 0 ] = 1 <NEWLINE> turn [ 0 ] = 0 <NEWLINE> <NL> cursor = 0 <NEWLINE> turn_count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cursor = A [ cursor ] <NEWLINE> turn_count += 1 <NEWLINE> <NL> if turn_count == K : <NEWLINE> <INDENT> print ( cursor + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> visit [ cursor ] += 1 <NEWLINE> <NL> if visit [ cursor ] > 1 : <NEWLINE> <INDENT> loop_length = turn_count - turn [ cursor ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> turn [ cursor ] = turn_count <NEWLINE> <NL> <DEDENT> K -= turn [ cursor ] <NEWLINE> K %= loop_length <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> cursor = A [ cursor ] <NEWLINE> <NL> <DEDENT> print ( cursor + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> mx = max ( A ) <NEWLINE> mxidx = A . index ( mx ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == mxidx : <NEWLINE> <INDENT> B = A [ 0 : i ] + A [ i + 1 : N ] <NEWLINE> print ( max ( B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l , r = 0 , K <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> s , ne = A [ l ] , A [ r ] <NEWLINE> if ne > s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> l += 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ True ] * ( n + 1 ) <NEWLINE> a [ 0 ] = a [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> for j in range ( i ** 2 , n + 1 , i ) : <NEWLINE> <INDENT> a [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a . count ( True ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = N <NEWLINE> if N % K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( N % K , abs ( N % K - K ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , Q = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> H = np . array ( [ 0 ] * ( N - 1 ) ) <NEWLINE> W = np . array ( [ 0 ] * ( N - 1 ) ) <NEWLINE> <NL> black = ( N - 2 ) ** 2 <COMMENT> <NEWLINE> <NL> Hmin = N - 1 <NEWLINE> Wmin = N - 1 <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> n , x = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if n == 1 : <COMMENT> <NEWLINE> <INDENT> if x - 1 <= Wmin : <NEWLINE> <INDENT> W [ x - 1 : Wmin ] = Hmin - 1 <NEWLINE> Wmin = x - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> black -= W [ x - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x - 1 <= Hmin : <NEWLINE> <INDENT> H [ x - 1 : Hmin ] = Wmin - 1 <NEWLINE> Hmin = x - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> black -= H [ x - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( black ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def dfs ( tree , n , ans ) : <NEWLINE> <INDENT> for i in tree [ n ] : <NEWLINE> <INDENT> ans [ i ] += ans [ n ] <NEWLINE> tree [ i ] . remove ( n ) <NEWLINE> dfs ( tree , i , ans ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> g [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] - 1 ) <NEWLINE> g [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans [ px [ i - 1 ] [ 0 ] - 1 ] += px [ i - 1 ] [ 1 ] <NEWLINE> <DEDENT> dfs ( g , 0 , ans ) <NEWLINE> <NL> print ( * ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * k <NEWLINE> a [ 0 ] = 7 % k <NEWLINE> <NL> for i in range ( 1 , k ) : <NEWLINE> <INDENT> a [ i ] = ( 10 * a [ i - 1 ] + 7 ) % k <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( int ( B - 1 ) , int ( N ) ) <NEWLINE> y = int ( A * x / B ) - A * ( int ( x / B ) ) <NEWLINE> print ( y ) <NEWLINE>
from itertools import permutations <NEWLINE> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> odd_nums = [ ] <NEWLINE> even_nums = [ ] <NEWLINE> for i , num in enumerate ( nums ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> even_nums . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd_nums . append ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> useable_nums = set ( nums ) <NEWLINE> even_length = len ( even_nums ) <NEWLINE> odd_length = len ( odd_nums ) <NEWLINE> even_counter = collections . Counter ( even_nums ) . most_common ( ) <NEWLINE> odd_counter = collections . Counter ( odd_nums ) . most_common ( ) <NEWLINE> even_counter . append ( ( 0 , 0 ) ) <NEWLINE> odd_counter . append ( ( 0 , 0 ) ) <NEWLINE> even_counter . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> odd_counter . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> min_ans = None <NEWLINE> if even_counter [ 0 ] [ 0 ] == odd_counter [ 0 ] [ 0 ] : <NEWLINE> <INDENT> min_ans = min ( ( odd_length - odd_counter [ 0 ] [ 1 ] ) + ( even_length - even_counter [ 1 ] [ 1 ] ) , <NEWLINE> <INDENT> ( odd_length - odd_counter [ 1 ] [ 1 ] ) + ( even_length - even_counter [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <NL> <INDENT> min_ans = odd_length - odd_counter [ 0 ] [ 1 ] + even_length - even_counter [ 0 ] [ 1 ] <NEWLINE> <DEDENT> print ( min_ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> p = i + 1 <NEWLINE> pnum = int ( s [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> p = 101 <NEWLINE> <NL> <DEDENT> if k < p : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( pnum ) <NEWLINE> <DEDENT>
import functools <NEWLINE> <NL> def sign ( x ) : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def multiply ( x , y ) : <NEWLINE> <INDENT> ans = x * y <NEWLINE> if ans >= 10 ** 9 + 7 or ans < 0 : <NEWLINE> <INDENT> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> if ( A [ - 1 ] < 0 and K % 2 == 1 ) : <NEWLINE> <INDENT> combi = A [ - K : ] <NEWLINE> if K > 1 : <NEWLINE> <INDENT> answer = functools . reduce ( multiply , combi ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif K == N : <NEWLINE> <INDENT> answer = functools . reduce ( multiply , A ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> signs = 1 <NEWLINE> i , j = 0 , 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> if abs ( A [ i ] ) > abs ( A [ N - j - 1 ] ) : <NEWLINE> <INDENT> signs *= sign ( A [ i ] ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> signs *= sign ( A [ N - j - 1 ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> combi = A [ N - j : ] + A [ : i ] <NEWLINE> del A [ N - j : ] <NEWLINE> del A [ : i ] <NEWLINE> combi = combi [ : : - 1 ] <NEWLINE> <NL> if signs == - 1 : <NEWLINE> <INDENT> if A : <NEWLINE> <INDENT> if combi [ - 1 ] < 0 : <NEWLINE> <INDENT> del combi [ 0 ] <NEWLINE> combi . append ( A [ - 1 ] ) <NEWLINE> <DEDENT> elif A [ 0 ] >= 0 : <NEWLINE> <INDENT> del combi [ 0 ] <NEWLINE> combi . append ( A [ - 1 ] ) <NEWLINE> <DEDENT> elif A [ 0 ] < 0 and A [ - 1 ] > 0 : <NEWLINE> <INDENT> if combi [ 0 ] * A [ 0 ] > combi [ - 1 ] * A [ - 1 ] : <NEWLINE> <INDENT> del combi [ - 1 ] <NEWLINE> combi . insert ( 0 , A [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del combi [ 0 ] <NEWLINE> combi . append ( A [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif A [ - 1 ] <= 0 : <NEWLINE> <INDENT> del combi [ - 1 ] <NEWLINE> combi . insert ( 0 , A [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> answer = functools . reduce ( multiply , combi ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> pi = 3.14159265359 <NEWLINE> a = r * r * pi <NEWLINE> l = r * 2 * pi <NEWLINE> print ( <STRING> . format ( a , l ) ) <NEWLINE>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( reverse = True ) <NEWLINE> if k >= n : <NEWLINE> <INDENT> k = n <NEWLINE> <DEDENT> h2 = h [ k : ] <NEWLINE> <NL> print ( sum ( h2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_ls . sort ( ) <NEWLINE> def check ( a , b , c ) : <NEWLINE> <INDENT> return abs ( a - b ) < c < a + b <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> short = l_ls [ i ] <NEWLINE> num = 0 <NEWLINE> r = i + 1 <NEWLINE> for l in range ( i + 1 , n ) : <NEWLINE> <INDENT> while r + 1 < n and check ( short , l_ls [ l ] , l_ls [ r + 1 ] ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> num += r - l <NEWLINE> if r == l : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> ans += num <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a += list ( range ( 1 , n + 1 ) ) <NEWLINE> a = Counter ( a ) . most_common ( ) <NEWLINE> a . sort ( ) <NEWLINE> for i , j in a : <NEWLINE> <INDENT> print ( j - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num = float ( input ( ) ) * 10 ** 9 + 0.5 <NEWLINE> A . append ( int ( num ) ) <NEWLINE> <NL> <NL> <DEDENT> def count2 ( n ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while ( n % 2 == 0 ) : <NEWLINE> <INDENT> ret += 1 <NEWLINE> n /= 2 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def count5 ( n ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while ( n % 5 == 0 ) : <NEWLINE> <INDENT> ret += 1 <NEWLINE> n /= 5 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> table = { } <NEWLINE> for i in range ( 19 ) : <NEWLINE> <INDENT> for j in range ( 19 ) : <NEWLINE> <INDENT> table [ i , j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> c2 = count2 ( a ) <NEWLINE> c5 = count5 ( a ) <NEWLINE> if ( c2 > 18 ) : <NEWLINE> <INDENT> c2 = 18 <NEWLINE> <DEDENT> if ( c5 > 18 ) : <NEWLINE> <INDENT> c5 = 18 <NEWLINE> <DEDENT> table [ c2 , c5 ] += 1 <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( 19 ) : <NEWLINE> <INDENT> for j in range ( 19 ) : <NEWLINE> <INDENT> for k in range ( 19 ) : <NEWLINE> <INDENT> for l in range ( 19 ) : <NEWLINE> <INDENT> if i + k >= 18 and j + l >= 18 : <NEWLINE> <INDENT> if i == k and j == l : <NEWLINE> <INDENT> res += table [ i , j ] * ( table [ i , j ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += table [ i , j ] * table [ k , l ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res // 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> now = 0 <NEWLINE> dict_ = { } <NEWLINE> stack = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if now not in dict_ : <NEWLINE> <INDENT> dict_ [ now ] = A [ now ] <NEWLINE> stack . append ( now ) <NEWLINE> now = A [ now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = stack . index ( now ) <NEWLINE> mod = i - idx <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> idx = idx + ( K - idx ) % mod <NEWLINE> idx = min ( K , idx ) <NEWLINE> print ( stack [ idx ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_list = list ( set ( [ * range ( 0 , 102 ) ] ) - set ( p_list ) ) <NEWLINE> <NL> diff = np . abs ( np . array ( num_list ) - X ) <NEWLINE> diff_arg_min = np . argmin ( diff ) <NEWLINE> <NL> print ( num_list [ diff_arg_min ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( b // c + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( b // c - ( a - 1 ) // c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> j = n // i <NEWLINE> ans += j * ( j + 1 ) * i / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
r = input ( ) . split ( ) <NEWLINE> A = int ( r [ 0 ] ) <NEWLINE> B = int ( r [ 1 ] ) <NEWLINE> C = int ( r [ 2 ] ) <NEWLINE> K = int ( r [ 3 ] ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A - K + B ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s in d : <NEWLINE> <INDENT> d [ s ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( d . keys ( ) ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> num = 1 <NEWLINE> L = 0 <NEWLINE> ans = - 1 <NEWLINE> <NL> <NL> if k % 7 == 0 : <NEWLINE> <INDENT> L = ( 9 * k ) / 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * k <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> if ( num * 10 ) % L == 1 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> num = num * 10 % L <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if int ( n ) == 0 : break <NEWLINE> if len ( set ( n ) ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> ans = 0 <NEWLINE> while n != <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l = <STRING> . join ( sorted ( n ) ) <NEWLINE> s = l [ : : - 1 ] <NEWLINE> n = str ( int ( s ) - int ( l ) ) . zfill ( 4 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <NL> <INDENT> if li [ i - k ] < li [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = [ int ( input ( ) ) - 1 for _ in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> latest_indices = [ - 1 ] * ( 2 * ( 10 ** 5 ) ) <NEWLINE> next_indices = [ - 1 ] * N <NEWLINE> for cur_index , c in enumerate ( C ) : <NEWLINE> <INDENT> latest_index = latest_indices [ c ] <NEWLINE> if latest_index >= 0 : <NEWLINE> <INDENT> next_indices [ latest_index ] = cur_index <NEWLINE> <DEDENT> latest_indices [ c ] = cur_index <NEWLINE> <DEDENT> dp = [ 0 ] * N <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for cur_index in range ( N - 1 ) : <NEWLINE> <INDENT> next_index = next_indices [ cur_index ] <NEWLINE> if next_index > cur_index + 1 : <NEWLINE> <INDENT> dp [ next_index ] += dp [ cur_index ] <NEWLINE> dp [ next_index ] %= MOD <NEWLINE> <DEDENT> dp [ cur_index + 1 ] += dp [ cur_index ] <NEWLINE> dp [ cur_index + 1 ] %= MOD <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> <NL> result = [ ] <NEWLINE> <NL> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if i == len ( T ) - 1 : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif result [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result . append ( T [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] + a [ i ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = { } <NEWLINE> <NL> for item in a : <NEWLINE> <INDENT> if item not in cnt : <NEWLINE> <INDENT> cnt [ item ] = 0 <NEWLINE> <DEDENT> cnt [ item ] += 1 <NEWLINE> <NL> <DEDENT> A = list ( set ( a ) ) <NEWLINE> <NL> candidate = [ ] <NEWLINE> <NL> for item in A : <NEWLINE> <INDENT> if cnt [ item ] == 1 : <NEWLINE> <INDENT> candidate . append ( item ) <NEWLINE> <NL> <DEDENT> <DEDENT> judge = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for item in A : <NEWLINE> <INDENT> for i in range ( 2 , ( ( 10 ** 6 ) // item ) + 1 ) : <NEWLINE> <INDENT> judge [ item * i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for item in candidate : <NEWLINE> <INDENT> if judge [ item ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> theta = math . pi / 3 <NEWLINE> p1 = [ 0 , 0 ] <NEWLINE> p2 = [ 100 , 0 ] <NEWLINE> <NL> <NL> def kock ( d , p1 , p2 ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> sx = ( 2 * p1 [ 0 ] + p2 [ 0 ] ) / 3 <NEWLINE> tx = ( p1 [ 0 ] + 2 * p2 [ 0 ] ) / 3 <NEWLINE> sy = ( 2 * p1 [ 1 ] + p2 [ 1 ] ) / 3 <NEWLINE> ty = ( p1 [ 1 ] + 2 * p2 [ 1 ] ) / 3 <NEWLINE> s = [ sx , sy ] <NEWLINE> t = [ tx , ty ] <NEWLINE> <NL> ux = ( t [ 0 ] - s [ 0 ] ) * math . cos ( theta ) - ( t [ 1 ] - s [ 1 ] ) * math . sin ( theta ) + sx <NEWLINE> uy = ( t [ 1 ] - s [ 1 ] ) * math . cos ( theta ) + ( t [ 0 ] - s [ 0 ] ) * math . sin ( theta ) + sy <NEWLINE> u = [ ux , uy ] <NEWLINE> <NL> kock ( d - 1 , p1 , s ) <NEWLINE> print ( <STRING> . format ( * s ) ) <NEWLINE> kock ( d - 1 , s , u ) <NEWLINE> print ( <STRING> . format ( * u ) ) <NEWLINE> kock ( d - 1 , u , t ) <NEWLINE> print ( <STRING> . format ( * t ) ) <NEWLINE> kock ( d - 1 , t , p2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> kock ( n , p1 , p2 ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( S ) <NEWLINE> <NL> <NL> print ( len ( cnt . keys ( ) ) ) <NEWLINE>
N , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i + j + n >= x ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i + j + k == x ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> if 2 not in li : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> st = 0 <NEWLINE> while st != 1 : <NEWLINE> <INDENT> if ( st == 0 and ans > 0 ) or ans > n : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> st = li [ st ] - 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> s = x % 60 <NEWLINE> m = int ( x / 60 ) <NEWLINE> h = int ( m / 60 ) <NEWLINE> m = m % 60 <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import pprint <NEWLINE> from queue import Queue <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> V , E = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G = [ [ ] for i in range ( V ) ] <NEWLINE> indig = [ 0 ] * V <COMMENT> <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> indig [ t ] += 1 <NEWLINE> <NL> <DEDENT> q = Queue ( ) <NEWLINE> out = [ ] <NEWLINE> <NL> def bfs ( node_index ) : <NEWLINE> <INDENT> q . put ( node_index ) <NEWLINE> <NL> while not q . empty ( ) : <NEWLINE> <INDENT> u = q . get ( ) <NEWLINE> out . append ( u ) <NEWLINE> <NL> <COMMENT> <NL> for index in G [ u ] : <NEWLINE> <INDENT> indig [ index ] -= 1 <NEWLINE> if indig [ index ] == 0 : <NEWLINE> <INDENT> q . put ( index ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> indig_copy = indig [ : ] <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> if indig_copy [ i ] == 0 : <NEWLINE> <INDENT> bfs ( node_index = i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for v in out : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 9999999 <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if m >= P [ i - 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> m = P [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def put ( ret , val ) : <NEWLINE> <INDENT> if val == 0 : <NEWLINE> <INDENT> ret . append ( <STRING> ) <NEWLINE> <DEDENT> elif val == 1 : <NEWLINE> <INDENT> ret . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret . append ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if tmp == <STRING> : <NEWLINE> <INDENT> val = 0 <NEWLINE> <DEDENT> elif tmp == <STRING> : <NEWLINE> <INDENT> val = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = 2 <NEWLINE> <DEDENT> s . append ( val ) <NEWLINE> <NL> <DEDENT> ret = [ ] <NEWLINE> if a + b + c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a + b + c == 1 : <NEWLINE> <INDENT> t = [ ] <NEWLINE> t . append ( a ) <NEWLINE> t . append ( b ) <NEWLINE> t . append ( c ) <NEWLINE> for i , item in enumerate ( s ) : <NEWLINE> <INDENT> if t [ item ] == 1 : <NEWLINE> <INDENT> t [ item ] = 0 <NEWLINE> t [ ( item + 1 ) % 3 ] = 1 <NEWLINE> put ( ret , ( item + 1 ) % 3 ) <NEWLINE> <DEDENT> elif t [ ( item + 1 ) % 3 ] == 1 : <NEWLINE> <INDENT> t [ item ] = 1 <NEWLINE> t [ ( item + 1 ) % 3 ] = 0 <NEWLINE> put ( ret , item ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a + b + c == 2 : <NEWLINE> <INDENT> t = [ ] <NEWLINE> t . append ( a ) <NEWLINE> t . append ( b ) <NEWLINE> t . append ( c ) <NEWLINE> for i , item in enumerate ( s ) : <NEWLINE> <INDENT> if t [ item ] == 0 and t [ ( item + 1 ) % 3 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if t [ item ] > t [ ( item + 1 ) % 3 ] : <NEWLINE> <INDENT> t [ item ] -= 1 <NEWLINE> t [ ( item + 1 ) % 3 ] += 1 <NEWLINE> put ( ret , ( item + 1 ) % 3 ) <NEWLINE> <DEDENT> elif t [ item ] < t [ ( item + 1 ) % 3 ] : <NEWLINE> <INDENT> t [ item ] += 1 <NEWLINE> t [ ( item + 1 ) % 3 ] -= 1 <NEWLINE> put ( ret , item ) <NEWLINE> <DEDENT> elif t [ item ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif t [ item ] == 2 : <NEWLINE> <INDENT> t [ item ] -= 1 <NEWLINE> t [ ( item + 1 ) % 3 ] += 1 <NEWLINE> put ( ret , ( item + 1 ) % 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( s ) > i + 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == ( item + 1 ) % 3 : <NEWLINE> <INDENT> t [ item ] -= 1 <NEWLINE> t [ ( item + 1 ) % 3 ] += 1 <NEWLINE> put ( ret , ( item + 1 ) % 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ item ] += 1 <NEWLINE> t [ ( item + 1 ) % 3 ] -= 1 <NEWLINE> put ( ret , item ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> put ( ret , item ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t = [ ] <NEWLINE> t . append ( a ) <NEWLINE> t . append ( b ) <NEWLINE> t . append ( c ) <NEWLINE> for i , item in enumerate ( s ) : <NEWLINE> <INDENT> if t [ item ] == 0 and t [ ( item + 1 ) % 3 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if t [ item ] > t [ ( item + 1 ) % 3 ] : <NEWLINE> <INDENT> t [ item ] -= 1 <NEWLINE> t [ ( item + 1 ) % 3 ] += 1 <NEWLINE> put ( ret , ( item + 1 ) % 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ item ] += 1 <NEWLINE> t [ ( item + 1 ) % 3 ] -= 1 <NEWLINE> put ( ret , item ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for item in ret : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if ( n % 2 == 0 or n % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 7 <NEWLINE> ans = 1 <NEWLINE> flag = 1 <NEWLINE> while ( flag ) : <NEWLINE> <INDENT> if ( a % n == 0 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> s = str ( a ) <NEWLINE> s1 = <STRING> <NEWLINE> s2 = int ( s + s1 ) <NEWLINE> a = ( int ( s2 ) ) % n <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import bisect <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> apoint = [ ] <NEWLINE> cpoint = [ ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] + s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> apoint . append ( i ) <NEWLINE> cpoint . append ( i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = l - 1 , r - 1 <NEWLINE> left = bisect . bisect_left ( apoint , l ) <NEWLINE> right = bisect . bisect_left ( cpoint , r ) <NEWLINE> print ( right - left ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> listH = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> listN = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if listH [ A - 1 ] > listH [ B - 1 ] : <NEWLINE> <INDENT> listN [ B - 1 ] = - 1 <NEWLINE> <DEDENT> if listH [ A - 1 ] < listH [ B - 1 ] : <NEWLINE> <INDENT> listN [ A - 1 ] = - 1 <NEWLINE> <DEDENT> if listH [ A - 1 ] == listH [ B - 1 ] : <NEWLINE> <INDENT> listN [ A - 1 ] = - 1 <NEWLINE> listN [ B - 1 ] = - 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in listN : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> l = [ [ ] for x in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> l [ a - 1 ] . append ( b - 1 ) <NEWLINE> l [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> done = [ False for i in range ( n ) ] <NEWLINE> ans = [ 0 for i in range ( n ) ] <NEWLINE> def bfs ( ) : <NEWLINE> <INDENT> stack = [ 0 ] <NEWLINE> done [ 0 ] = True <NEWLINE> while ( stack ) : <NEWLINE> <INDENT> now = stack . pop ( 0 ) <NEWLINE> done [ now ] = True <NEWLINE> <NL> for i in l [ now ] : <NEWLINE> <INDENT> if done [ i ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] = now + 1 <NEWLINE> done [ i ] = True <NEWLINE> stack . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> bfs ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( * ans [ 1 : ] ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> d2 = { } <NEWLINE> d3 = { } <NEWLINE> loopc = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = a [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> b = d [ 1 ] <NEWLINE> d2 [ b ] = 1 <NEWLINE> d3 [ i ] = b <NEWLINE> amari = 0 <NEWLINE> if k >= 2 : <NEWLINE> <INDENT> if n >= k : <NEWLINE> <INDENT> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> if b in d : <NEWLINE> <INDENT> b = d [ b ] <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if b in d : <NEWLINE> <INDENT> b = d [ b ] <NEWLINE> if b not in d2 : <NEWLINE> <INDENT> d2 [ b ] = i <NEWLINE> d3 [ i ] = b <NEWLINE> <DEDENT> elif b in d2 : <NEWLINE> <INDENT> loopc = i - d2 [ b ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> amari = k - n <NEWLINE> amari = amari % loopc <NEWLINE> for i in range ( amari ) : <NEWLINE> <INDENT> b = d [ b ] <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sl = [ ] <NEWLINE> <NL> ma , mi = max ( l ) , min ( l ) <NEWLINE> if ma == mi : <NEWLINE> <INDENT> sl . append ( 0 ) <NEWLINE> <NL> <DEDENT> for x in range ( mi , ma ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> s += ( i - x ) ** 2 <NEWLINE> <DEDENT> sl . append ( s ) <NEWLINE> <NL> <DEDENT> print ( min ( sl ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> di = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> fi = [ ] <NEWLINE> for i , j in di : <NEWLINE> <INDENT> fi . append ( [ j , i ] ) <NEWLINE> <DEDENT> for k in ls : <NEWLINE> <INDENT> fi . append ( [ k , 1 ] ) <NEWLINE> <DEDENT> fi . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> how = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if how + fi [ cnt ] [ 1 ] < n : <NEWLINE> <INDENT> how += fi [ cnt ] [ 1 ] <NEWLINE> ans += fi [ cnt ] [ 1 ] * fi [ cnt ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( n - how ) * fi [ cnt ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
arr = [ ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> arr . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> arr2 = arr . copy ( ) <NEWLINE> arr2 . sort ( ) <NEWLINE> z = arr2 [ - 1 ] <NEWLINE> zz = arr2 [ - 2 ] <NEWLINE> for k in arr : <NEWLINE> <INDENT> if k != z : <NEWLINE> <INDENT> print ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( zz ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <COMMENT> <NL> me = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> me [ 1 ] = 1 <NEWLINE> miti = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> tansaku = [ 0 for i in range ( n + 1 ) ] <NEWLINE> tansaku [ 1 ] = 1 <NEWLINE> for i , j in l : <NEWLINE> <INDENT> miti [ j ] . append ( i ) <NEWLINE> miti [ i ] . append ( j ) <NEWLINE> <DEDENT> a = deque ( ) <NEWLINE> for i in miti [ 1 ] : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> me [ i ] = 1 <NEWLINE> tansaku [ i ] = 1 <NEWLINE> <DEDENT> while len ( a ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> w = a . popleft ( ) <NEWLINE> for j in miti [ w ] : <NEWLINE> <INDENT> if tansaku [ j ] == 0 : <NEWLINE> <INDENT> a . append ( j ) <NEWLINE> tansaku [ j ] = 1 <NEWLINE> me [ j ] = w <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( len ( miti ) - 2 ) : <NEWLINE> <INDENT> print ( me [ i + 2 ] ) <NEWLINE> <DEDENT>
h , a , * m = open ( 0 ) <NEWLINE> h , w , k , a , b , f , g = map ( int , ( h + a ) . split ( ) ) <NEWLINE> m += <STRING> * w , <NEWLINE> d = [ I : = h * w ] * I <NEWLINE> a = ~ w + a * w + b <NEWLINE> d [ a ] = 1 <NEWLINE> q = [ a ] <NEWLINE> for s in q : <NEWLINE> <INDENT> for y , x in ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) : <NEWLINE> <INDENT> for z in range ( k ) : <NEWLINE> <INDENT> i , j = s // w + y * ~ z , s % w + x * ~ z ; t = i * w + j ; p = d [ s ] + 1 <NEWLINE> if <STRING> != m [ i ] [ j ] or d [ t ] < p : break <NEWLINE> if d [ t ] > p : q += t , ; d [ t ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d [ ~ w + f * w + g ] % I - 1 ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = Counter ( s ) <NEWLINE> ans = cnt [ <STRING> ] * cnt [ <STRING> ] * cnt [ <STRING> ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ken = j * 2 - i <NEWLINE> if ( ken >= n ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( s [ i ] != s [ j ] and s [ j ] != s [ ken ] and s [ i ] != s [ ken ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def sgn ( x ) : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if x < 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if x > 0 : <NEWLINE> <INDENT> x1 = x - k * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 = x + k * d <NEWLINE> <NL> <DEDENT> if sgn ( x ) == sgn ( x1 ) : <NEWLINE> <INDENT> print ( abs ( x1 ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> xright = x % d <NEWLINE> xleft = x % d - d <NEWLINE> <COMMENT> <NL> xr = ( abs ( x - xright ) // d ) % 2 <NEWLINE> if k % 2 == xr : <NEWLINE> <INDENT> print ( abs ( xright ) ) <NEWLINE> <DEDENT> elif k % 2 != xr : <NEWLINE> <INDENT> print ( abs ( xleft ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <NL> <INDENT> if a [ i ] < a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def soi ( n ) : <COMMENT> <NEWLINE> <INDENT> i = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if i * i > n : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> a = int ( input ( ) ) <NEWLINE> ans = a <NEWLINE> count = 1 <NEWLINE> i = 2 <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> temp = soi ( a ) <NEWLINE> if a == 1 : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a % temp == 0 : <COMMENT> <NEWLINE> <INDENT> a /= temp <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans *= ( 1 - 1 / temp ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> def gcd ( a , b ) : <COMMENT> <NEWLINE> <INDENT> r = 0 <NEWLINE> while True : <NEWLINE> <INDENT> r = a % b <NEWLINE> if r == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = b <NEWLINE> b = r <NEWLINE> <DEDENT> return b <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> ins = lambda : input ( ) . rstrip ( ) <NEWLINE> ini = lambda : int ( input ( ) . rstrip ( ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> out = lambda x : print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <NL> def dfs ( x ) : <NEWLINE> <INDENT> stack = [ x ] <NEWLINE> visited = 0 <NEWLINE> checked [ x ] = 1 <NEWLINE> while stack : <NEWLINE> <INDENT> visited += 1 <NEWLINE> node = stack . pop ( ) <NEWLINE> for i in graph [ node ] : <NEWLINE> <INDENT> if checked [ i ] == 0 : <NEWLINE> <INDENT> stack . append ( i ) <NEWLINE> checked [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> n , m = inm ( ) <NEWLINE> checked = [ 0 ] * ( n + 1 ) <NEWLINE> graph = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = inm ( ) <NEWLINE> if a not in graph : <NEWLINE> <INDENT> graph [ a ] = set ( ) <NEWLINE> <DEDENT> if b not in graph : <NEWLINE> <INDENT> graph [ b ] = set ( ) <NEWLINE> <DEDENT> graph [ a ] . add ( b ) <NEWLINE> graph [ b ] . add ( a ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in graph : <NEWLINE> <INDENT> if checked [ i ] == 0 : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( string ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> n , m , * ab = map ( int , string . split ( ) ) <NEWLINE> p = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b in zip ( * [ iter ( ab ) ] * 2 ) : <NEWLINE> <INDENT> p [ a - 1 ] . append ( b - 1 ) <NEWLINE> p [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> s , ans , d = deque ( [ 0 ] ) , [ 0 ] * n , [ 0 ] + [ n ] * ( n - 1 ) <NEWLINE> while s : <NEWLINE> <INDENT> c = s . popleft ( ) <NEWLINE> for t in p [ c ] : <NEWLINE> <INDENT> if d [ c ] + 1 < d [ t ] : <NEWLINE> <INDENT> d [ t ] = d [ c ] + 1 <NEWLINE> ans [ t ] = c + 1 <NEWLINE> s . append ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <STRING> + <STRING> . join ( map ( str , ans [ 1 : ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> print ( solve ( sys . stdin . read ( ) . strip ( ) ) ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> D = abs ( D ) <NEWLINE> if X > K * D : <NEWLINE> <INDENT> X = X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> quo = X // D <NEWLINE> X = X - D * quo <NEWLINE> res = K - quo <NEWLINE> if res % 2 == 1 : <NEWLINE> <INDENT> X = X - D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( X ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> for j in range ( 0 , W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> r = input ( ) <NEWLINE> r = float ( r ) <NEWLINE> <NL> area = math . pi * ( r ** 2 ) <NEWLINE> length = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( area , length ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if n . count ( x + i ) == 0 : <NEWLINE> <INDENT> ans . append ( x + i ) <NEWLINE> <NL> <DEDENT> if n . count ( x - i ) == 0 : <NEWLINE> <INDENT> ans . append ( x - i ) <NEWLINE> <NL> <DEDENT> if ans != [ ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import queue <NEWLINE> from collections import deque <NEWLINE> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> factrys = [ None ] * ( n + 1 ) <NEWLINE> ss = [ <STRING> * ( w + 2 ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = <STRING> + input ( ) + <STRING> <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> factrys [ 0 ] = ( i + 1 , s . index ( <STRING> ) ) <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if str ( j ) in s : <NEWLINE> <INDENT> factrys [ j ] = ( i + 1 , s . index ( str ( j ) ) ) <NEWLINE> <DEDENT> <DEDENT> ss . append ( s ) <NEWLINE> <DEDENT> ss . append ( <STRING> * ( w + 2 ) ) <NEWLINE> <NL> def bfs ( i ) : <NEWLINE> <INDENT> mp = [ [ None ] * ( w + 2 ) for j in range ( h + 2 ) ] <NEWLINE> x , y = factrys [ i ] <NEWLINE> mp [ x ] [ y ] = 0 <NEWLINE> que = queue . Queue ( ) <NEWLINE> que . put ( ( x , y ) ) <NEWLINE> while True : <NEWLINE> <INDENT> ( x , y ) = que . get ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( x , y ) == factrys [ i + 1 ] : <NEWLINE> <INDENT> return mp [ x ] [ y ] <NEWLINE> <DEDENT> count = mp [ x ] [ y ] <NEWLINE> if ss [ x + 1 ] [ y ] != <STRING> and mp [ x + 1 ] [ y ] is None : <NEWLINE> <INDENT> mp [ x + 1 ] [ y ] = count + 1 <NEWLINE> que . put ( ( x + 1 , y ) ) <NEWLINE> <DEDENT> if ss [ x - 1 ] [ y ] != <STRING> and mp [ x - 1 ] [ y ] is None : <NEWLINE> <INDENT> mp [ x - 1 ] [ y ] = count + 1 <NEWLINE> que . put ( ( x - 1 , y ) ) <NEWLINE> <DEDENT> if ss [ x ] [ y + 1 ] != <STRING> and mp [ x ] [ y + 1 ] is None : <NEWLINE> <INDENT> mp [ x ] [ y + 1 ] = count + 1 <NEWLINE> que . put ( ( x , y + 1 ) ) <NEWLINE> <DEDENT> if ss [ x ] [ y - 1 ] != <STRING> and mp [ x ] [ y - 1 ] is None : <NEWLINE> <INDENT> mp [ x ] [ y - 1 ] = count + 1 <NEWLINE> que . put ( ( x , y - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ret = bfs ( i ) <NEWLINE> if ret is None : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( ret ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> result += n * i - i * i + i + 1 <NEWLINE> <NL> <NL> <DEDENT> print ( result % 1000000007 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> rooms = [ [ int ( x ) for x in input ( ) . split ( <STRING> ) ] for i in range ( n ) ] <NEWLINE> <NL> rooms_people = [ [ [ 0 for k in range ( 10 ) ] for j in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> rooms_people [ rooms [ i ] [ 0 ] - 1 ] [ rooms [ i ] [ 1 ] - 1 ] [ rooms [ i ] [ 2 ] - 1 ] += rooms [ i ] [ 3 ] <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if i != 0 : print ( <STRING> ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , rooms_people [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> m = 6 ** 8 <NEWLINE> c = [ g : = 0 ] * m <NEWLINE> for a in [ * open ( 0 ) ] [ 1 ] . split ( ) : g = math . gcd ( g , a : = int ( a ) ) ; c [ a ] += 1 <NEWLINE> print ( ( <STRING> , <STRING> [ any ( sum ( c [ i : : i ] ) > 1 for i in range ( 2 , m ) ) : : 2 ] + <STRING> ) [ g < 2 ] , <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> m = 7 % k <NEWLINE> while 1 : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if c > k + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> m = m * 10 + 7 <NEWLINE> m %= k <NEWLINE> c += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
import math <NEWLINE> ans = 0 <NEWLINE> A = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> a = 10 <NEWLINE> p = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if a > ( A [ i ] % 10 ) and A [ i ] % 10 != 0 : <NEWLINE> <INDENT> p = i <NEWLINE> a = A [ i ] % 10 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 10 * ( math . ceil ( A [ i ] / 10 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( l ) <NEWLINE> <NL> [ print ( c [ i + 1 ] ) for i in range ( N ) ] <NEWLINE>
n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> X = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ [ [ 0 ] * ( 2550 ) for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> for s in range ( n * a + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if dp [ i ] [ j ] [ s ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> dp [ i + 1 ] [ j ] [ s ] += dp [ i ] [ j ] [ s ] <NEWLINE> <COMMENT> <NL> dp [ i + 1 ] [ j + 1 ] [ s + X [ i ] ] += dp [ i ] [ j ] [ s ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += dp [ n ] [ k ] [ k * a ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if L [ i ] < L [ j ] + L [ k ] : <NEWLINE> <INDENT> if L [ i ] != L [ j ] != L [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> m = [ [ ] for _ in range ( 8 ) ] <NEWLINE> m [ 0 ] . append ( [ a , b , c ] ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> for j in m [ i ] : <NEWLINE> <INDENT> m [ i + 1 ] . append ( [ j [ 0 ] * 2 , j [ 1 ] , j [ 2 ] ] ) <NEWLINE> m [ i + 1 ] . append ( [ j [ 0 ] , j [ 1 ] * 2 , j [ 2 ] ] ) <NEWLINE> m [ i + 1 ] . append ( [ j [ 0 ] , j [ 1 ] , j [ 2 ] * 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> <NL> for t in m [ k ] : <NEWLINE> <INDENT> if t [ 0 ] < t [ 1 ] and t [ 1 ] < t [ 2 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> <NL> A = [ 0 , math . ceil ( W / 2 ) ] <NEWLINE> if ( H - 1 ) * ( W - 1 ) != 0 : <NEWLINE> <INDENT> c = W * math . floor ( H / 2 ) + A [ H % 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
from itertools import accumulate , chain <NEWLINE> from collections import Counter <NEWLINE> <NL> MOD = 2019 <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> memo = [ None ] * len ( S ) <NEWLINE> x = 1 <NEWLINE> for i , c in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> memo [ i ] = x * int ( c ) % MOD <NEWLINE> x = ( 10 * x ) % MOD <NEWLINE> <NL> <DEDENT> acc = tuple ( chain ( ( 0 , ) , accumulate ( memo , lambda x , y : ( x + y ) % MOD ) ) ) <NEWLINE> <NL> print ( sum ( c * ( c - 1 ) // 2 for c in Counter ( acc ) . values ( ) ) ) <NEWLINE>
s = input ( ) <NEWLINE> turn = len ( s ) <NEWLINE> if s [ 0 ] == s [ turn - 1 ] : <NEWLINE> <INDENT> turn += 1 <NEWLINE> <DEDENT> if turn & 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> x = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> <NL> zero_flag = False <NEWLINE> for item in nums : <NEWLINE> <INDENT> if item == <STRING> : <NEWLINE> <INDENT> zero_flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if zero_flag : <NEWLINE> <INDENT> seki = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seki = 1 <NEWLINE> for item in nums : <NEWLINE> <INDENT> seki *= int ( item ) <NEWLINE> if seki > 10 ** 18 : <NEWLINE> <INDENT> seki = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( seki ) <NEWLINE>
import sys <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
while True : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> W , H = int ( x [ 0 ] ) , int ( x [ 1 ] ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> hantei = True <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if hantei : <NEWLINE> <INDENT> if H % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( H // 2 ) ) <NEWLINE> <DEDENT> elif H % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> * ( H // 2 ) + <STRING> ) <NEWLINE> <DEDENT> hantei = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if H % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( H // 2 ) ) <NEWLINE> <DEDENT> elif H % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> * ( H // 2 ) + <STRING> ) <NEWLINE> <DEDENT> hantei = True <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , key = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def tree_insert ( top , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = top <NEWLINE> while isinstance ( x , Node ) : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y is None : <NEWLINE> <INDENT> top = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return top <NEWLINE> <NL> <NL> <DEDENT> def tree_find ( node , key ) : <NEWLINE> <INDENT> if not node : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if node . key == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if key < node . key : <NEWLINE> <INDENT> return tree_find ( node . left , key ) <NEWLINE> <DEDENT> return tree_find ( node . right , key ) <NEWLINE> <NL> <NL> <DEDENT> def inorder_walk ( node ) : <NEWLINE> <INDENT> if node . left : <NEWLINE> <INDENT> inorder_walk ( node . left ) <NEWLINE> <DEDENT> print ( <STRING> , node . key , end = <STRING> ) <NEWLINE> if node . right : <NEWLINE> <INDENT> inorder_walk ( node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def preorder_walk ( node ) : <NEWLINE> <INDENT> print ( <STRING> , node . key , end = <STRING> ) <NEWLINE> if node . left : <NEWLINE> <INDENT> preorder_walk ( node . left ) <NEWLINE> <DEDENT> if node . right : <NEWLINE> <INDENT> preorder_walk ( node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( stdin . readline ( ) ) <NEWLINE> <COMMENT> <NL> <NL> top = None <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) <NEWLINE> if cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> key = int ( cmd [ 7 : ] ) <NEWLINE> <COMMENT> <NL> top = tree_insert ( top , Node ( key ) ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> key = int ( cmd [ 5 : ] ) <NEWLINE> r = tree_find ( top , key ) <NEWLINE> print ( <STRING> if r else <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inorder_walk ( top ) <NEWLINE> print ( ) <NEWLINE> preorder_walk ( top ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = s [ 0 ] // s [ 2 ] <NEWLINE> t = s [ 0 ] % s [ 2 ] <NEWLINE> if s [ 0 ] > 0 and s [ 0 ] - s [ 1 ] * s [ 2 ] > 0 : <NEWLINE> <INDENT> print ( s [ 0 ] - s [ 1 ] * s [ 2 ] ) <NEWLINE> <DEDENT> elif s [ 0 ] < 0 and s [ 0 ] + s [ 1 ] * s [ 2 ] < 0 : <NEWLINE> <INDENT> print ( - s [ 0 ] - s [ 1 ] * s [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ 0 ] > 0 : <NEWLINE> <INDENT> r = s [ 0 ] // s [ 2 ] <NEWLINE> t = s [ 0 ] % s [ 2 ] <NEWLINE> if ( s [ 1 ] - r ) % 2 == 1 : <NEWLINE> <INDENT> print ( - t + s [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> <DEDENT> elif s [ 0 ] < 0 : <NEWLINE> <INDENT> v = ( - s [ 0 ] ) // s [ 2 ] <NEWLINE> w = - ( ( - s [ 0 ] ) % s [ 2 ] ) <NEWLINE> if ( s [ 1 ] - v ) % 2 == 1 : <NEWLINE> <INDENT> print ( w + s [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - w ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> print ( s [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ <STRING> for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if N > 1 and s == 1 and c == 0 : <NEWLINE> <INDENT> ans = [ - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> if ans [ s - 1 ] != <STRING> and ans [ s - 1 ] != str ( c ) : <NEWLINE> <INDENT> ans = [ - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> ans [ s - 1 ] = str ( c ) <NEWLINE> <DEDENT> if ans == [ - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans [ 0 ] == <STRING> and N > 1 : <NEWLINE> <INDENT> ans [ 0 ] = <STRING> <NEWLINE> <DEDENT> ans = <STRING> . join ( ans ) <NEWLINE> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 100 ** ( D ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> A . append ( i * a ) <NEWLINE> <DEDENT> if D == 0 : <NEWLINE> <INDENT> A . remove ( 100 ) <NEWLINE> A . append ( 101 ) <NEWLINE> <DEDENT> elif D == 1 : <NEWLINE> <INDENT> A . remove ( 10000 ) <NEWLINE> A . append ( 10100 ) <NEWLINE> <DEDENT> elif D == 2 : <NEWLINE> <INDENT> A . remove ( 1000000 ) <NEWLINE> A . append ( 1010000 ) <NEWLINE> <DEDENT> print ( A [ N - 1 ] ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ct = k <NEWLINE> result = 0 <NEWLINE> if a > 0 : <NEWLINE> <INDENT> if ct > a : <NEWLINE> <INDENT> result = 1 * a <NEWLINE> <DEDENT> elif a >= ct : <NEWLINE> <INDENT> result = 1 * ct <NEWLINE> <DEDENT> ct = k - a <NEWLINE> <DEDENT> if ct > 0 and b > 0 : <NEWLINE> <INDENT> ct = ct - b <NEWLINE> <DEDENT> if ct > 0 and c > 0 : <NEWLINE> <INDENT> result = result + ( - 1 * ct ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
X , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> P = list ( set ( range ( - 10 , 110 ) ) - { int ( i ) for i in input ( ) . split ( ) } ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> P . sort ( ) <NEWLINE> <NL> D = [ abs ( P [ i ] - X ) for i in range ( len ( P ) ) ] <NEWLINE> <NL> print ( P [ D . index ( min ( D ) ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> keihinn_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> keihinn_list . append ( input ( ) ) <NEWLINE> <DEDENT> keihinn_list = set ( keihinn_list ) <NEWLINE> <NL> print ( len ( keihinn_list ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> S = list ( input ( ) ) <NEWLINE> S = list ( map ( int , S ) ) [ : : - 1 ] <NEWLINE> <NL> <NL> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] += 1 <NEWLINE> <NL> ans = 0 <NEWLINE> temp = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> temp += S [ i ] * p <NEWLINE> p = p * 10 % 2019 <NEWLINE> temp %= 2019 <NEWLINE> ans += mod [ temp ] <NEWLINE> mod [ temp ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
orders = { <NEWLINE> <INDENT> <STRING> : ( 2 , 6 , 3 , 4 , 1 , 5 ) , <NEWLINE> <STRING> : ( 4 , 2 , 1 , 6 , 5 , 3 ) , <NEWLINE> <STRING> : ( 3 , 2 , 6 , 1 , 5 , 4 ) , <NEWLINE> <STRING> : ( 5 , 1 , 3 , 4 , 6 , 2 ) , <NEWLINE> <STRING> : ( 1 , 3 , 5 , 2 , 4 , 6 ) , <NEWLINE> <STRING> : ( 1 , 4 , 2 , 5 , 3 , 6 ) <NEWLINE> <DEDENT> } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice = list ( range ( 1 , 7 ) ) <NEWLINE> top = 1 <NEWLINE> <NL> while n : <NEWLINE> <INDENT> dice = [ dice [ s - 1 ] for s in orders [ input ( ) . strip ( ) ] ] <NEWLINE> top += dice [ 0 ] <NEWLINE> n -= 1 <NEWLINE> <DEDENT> print ( top ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> b = [ 1 ] * ( n + 1 ) <NEWLINE> for v in e [ : : - 1 ] : <NEWLINE> <INDENT> if b [ v ] : <NEWLINE> <INDENT> b [ v ] = 0 <NEWLINE> print ( v ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if b [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> AGCT = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> AGCT_list = [ ] <NEWLINE> <NL> i = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ i ] in AGCT : <NEWLINE> <INDENT> k = 1 <NEWLINE> agct_tmp = S [ i ] <NEWLINE> if i + k < len ( S ) : <NEWLINE> <INDENT> while S [ i + k ] in AGCT : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> agct_tmp += S [ i + k ] <NEWLINE> if i + k + 1 < len ( S ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> AGCT_list . append ( agct_tmp ) <NEWLINE> i = i + k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if AGCT_list : <NEWLINE> <INDENT> print ( max ( [ len ( string ) for string in AGCT_list ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> while x != 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break ; <NEWLINE> <DEDENT> x //= 10 ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> cubes = list ( input ( ) ) <COMMENT> <NEWLINE> stack = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for cube in cubes : <NEWLINE> <INDENT> if not stack : <NEWLINE> <INDENT> stack . append ( cube ) <NEWLINE> <DEDENT> elif stack [ - 1 ] != cube : <NEWLINE> <INDENT> count += 2 <NEWLINE> stack . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( cube ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> <NL> dict_n = defaultdict ( lambda : 0 ) <NEWLINE> <NL> for i in alist : <NEWLINE> <INDENT> dict_n [ i ] += 1 <NEWLINE> <NL> <DEDENT> bclist = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> bclist . append ( [ b , c ] ) <NEWLINE> <NL> <DEDENT> sum = sum ( alist ) <NEWLINE> for i in range ( q ) : <NEWLINE> <NL> <INDENT> b = bclist [ i ] [ 0 ] <NEWLINE> c = bclist [ i ] [ 1 ] <NEWLINE> <NL> sum += dict_n [ b ] * c - dict_n [ b ] * b <NEWLINE> dict_n [ c ] += dict_n [ b ] <NEWLINE> del ( dict_n [ b ] ) <NEWLINE> <NL> print ( sum ) <NEWLINE> <DEDENT>
def lcs ( x , y , pre_lcs , pre_lcs_len ) : <NEWLINE> <INDENT> pm = dict ( ( zip ( <STRING> , [ 0 ] * 26 ) ) ) <NEWLINE> for c in pm : <NEWLINE> <INDENT> for i , xc in enumerate ( x ) : <NEWLINE> <INDENT> if c == xc : <NEWLINE> <INDENT> pm [ c ] |= ( 1 << i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> V = ( 1 << len ( x ) ) - 1 <NEWLINE> rec = [ ] <NEWLINE> <NL> for yc in y : <NEWLINE> <INDENT> V = ( ( V + ( V & pm [ yc ] ) ) | ( V & ~ pm [ yc ] ) ) <NEWLINE> rec . append ( bin ( V ) [ - len ( x ) : ] ) <NEWLINE> <NL> <DEDENT> lcs_len = bin ( V ) [ - len ( x ) : ] . count ( <STRING> ) <NEWLINE> <NL> if lcs_len > pre_lcs_len : <NEWLINE> <INDENT> rx = x [ : : - 1 ] <NEWLINE> lcs = <STRING> <NEWLINE> idx = 0 <NEWLINE> for v , yc in zip ( rec [ : : - 1 ] , reversed ( y ) ) : <NEWLINE> <INDENT> idx = v . find ( <STRING> , idx ) <NEWLINE> if yc == rx [ idx ] : <NEWLINE> <INDENT> lcs += yc <NEWLINE> if len ( lcs ) == lcs_len : <NEWLINE> <INDENT> return ( lcs [ : : - 1 ] , lcs_len ) <NEWLINE> <DEDENT> idx += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return ( pre_lcs , pre_lcs_len ) <NEWLINE> <NL> <DEDENT> <DEDENT> from sys import stdin <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> file_input = stdin <NEWLINE> ans_out = [ ] <NEWLINE> for s in file_input : <NEWLINE> <INDENT> s = s . rstrip ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s_len = len ( s ) <NEWLINE> sep = s_len // 2 <NEWLINE> ans , ans_len = lcs ( s [ : sep ] , s [ sep : ] , <STRING> , 0 ) <NEWLINE> while sep > ans_len : <NEWLINE> <INDENT> ans , ans_len = lcs ( s [ : - sep ] , s [ - sep : ] , ans , ans_len ) <NEWLINE> sep -= 1 <NEWLINE> ans , ans_len = lcs ( s [ : sep ] , s [ sep : ] , ans , ans_len ) <NEWLINE> <DEDENT> ans_out . append ( ans ) <NEWLINE> <DEDENT> print ( * ans_out , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> l = [ 0 ] * ( N + 1 ) <NEWLINE> l [ 0 ] = 1 <NEWLINE> j = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if j < M and i == a [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> l [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] = ( l [ i - 1 ] + l [ i - 2 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( l [ N ] ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ input ( ) for i in range ( H ) ] <NEWLINE> <NL> direction = [ <NEWLINE> <INDENT> ( 0 , 1 ) , <NEWLINE> ( 1 , 0 ) , <NEWLINE> ( - 1 , 0 ) , <NEWLINE> ( 0 , - 1 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <NL> def bfs ( sy , sx ) : <NEWLINE> <INDENT> reached = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> reached [ sy ] [ sx ] = 0 <NEWLINE> from collections import deque <NEWLINE> que = deque ( [ [ sy , sx ] ] ) <NEWLINE> <COMMENT> <NL> while que : <NEWLINE> <INDENT> iy , ix = que . popleft ( ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> tx , ty = ix + d [ 0 ] , iy + d [ 1 ] <NEWLINE> if tx >= W or ty >= H or tx < 0 or ty < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if reached [ ty ] [ tx ] != - 1 or maze [ ty ] [ tx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> reached [ ty ] [ tx ] = reached [ iy ] [ ix ] + 1 <NEWLINE> <COMMENT> <NL> que . append ( [ ty , tx ] ) <NEWLINE> <DEDENT> <DEDENT> d_max = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> d_max = max ( d_max , reached [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return d_max <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if maze [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , bfs ( i , j ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> p = 2019 <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] += 1 <COMMENT> <NEWLINE> now = 0 <NEWLINE> _10 = 1 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = ( now + int ( s [ i ] ) * _10 ) % p <NEWLINE> _10 *= 10 <NEWLINE> _10 %= p <NEWLINE> mod [ now ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in mod : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> m_gcd = math . gcd <NEWLINE> for h in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += m_gcd ( m_gcd ( h , i ) , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
string = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for c in range ( 0 , q ) : <NEWLINE> <INDENT> instruction = input ( ) . split ( <STRING> ) <NEWLINE> if instruction [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( string [ int ( instruction [ 1 ] ) : int ( instruction [ 2 ] ) + 1 ] ) <NEWLINE> <DEDENT> elif instruction [ 0 ] == <STRING> : <NEWLINE> <INDENT> string = string . replace ( string [ int ( instruction [ 1 ] ) : int ( instruction [ 2 ] ) + 1 ] , string [ int ( instruction [ 1 ] ) : int ( instruction [ 2 ] ) + 1 ] [ : : - 1 ] , 1 ) <NEWLINE> <DEDENT> elif instruction [ 0 ] == <STRING> : <NEWLINE> <INDENT> string = string [ : int ( instruction [ 1 ] ) ] + instruction [ 3 ] + string [ int ( instruction [ 2 ] ) + 1 : ] <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = sorted ( [ int ( input ( ) ) for _ in range ( N ) ] ) <NEWLINE> if len ( D ) > 1 : <NEWLINE> <INDENT> i , prev = 0 , None <NEWLINE> while i < ( len ( D ) - 1 ) : <NEWLINE> <INDENT> if D [ i ] == D [ i + 1 ] : <NEWLINE> <INDENT> D . pop ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev = D [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( D ) ) <NEWLINE>
p = input ( ) . split ( ) <NEWLINE> <NL> k = int ( p [ 0 ] ) <NEWLINE> s = int ( p [ 1 ] ) <NEWLINE> <NL> x = - 1 <NEWLINE> y = - 1 <NEWLINE> z = 0 <NEWLINE> answer = 0 <NEWLINE> <NL> for num in range ( k + 1 ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> y = - 1 <NEWLINE> for n in range ( k + 1 ) : <NEWLINE> <INDENT> y += 1 <NEWLINE> z = s - x - y <NEWLINE> if 0 <= z and z <= k : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX_N = max ( A ) + 1 <NEWLINE> cnt = [ 0 ] * MAX_N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> for i in range ( a , MAX_N , a ) : <NEWLINE> <INDENT> if cnt [ i ] <= 2 : cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cnt [ a ] == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> people = list ( range ( 1 , N + 1 , 1 ) ) <NEWLINE> for idx in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> X = list ( ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> A . append ( X [ i ] ) <NEWLINE> <DEDENT> <DEDENT> ans = [ i for i in people if not i in A ] <NEWLINE> print ( len ( ans ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == k : <NEWLINE> <INDENT> n = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while n > abs ( n - k ) : <NEWLINE> <INDENT> if n > k : <NEWLINE> <INDENT> n = min ( n , n % k ) <NEWLINE> <DEDENT> elif k > n : <NEWLINE> <INDENT> n = min ( n , k % n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] <NEWLINE> tmp = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> tmp += i <NEWLINE> B . append ( tmp ) <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> for i in B : <NEWLINE> <INDENT> i %= M <NEWLINE> if i not in d : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
param_n = int ( input ( ) ) <NEWLINE> params1 = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> result = [ 0 for i in range ( param_n ) ] <NEWLINE> <NL> for employee in params1 : <NEWLINE> <INDENT> result [ employee - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for num in result : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = [ 0 ] * N <NEWLINE> tmp2 = [ 0 ] * N <NEWLINE> tmp2 [ 0 ] = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tmp2 [ i ] = A [ i ] + tmp2 [ i - 1 ] <NEWLINE> <DEDENT> sum_A = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> tmp [ i ] = sum_A - tmp2 [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += ( A [ i ] * tmp [ i ] ) % mod <NEWLINE> ans = ans % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> print ( b // x - a // x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b // x - a // x ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ai = a [ - 1 ] <NEWLINE> half_ai = ai // 2 <NEWLINE> <NL> i_left = bisect . bisect_left ( a , half_ai ) <NEWLINE> i_right = bisect . bisect_right ( a , half_ai ) <NEWLINE> if ( a [ i_left ] == half_ai ) : <NEWLINE> <INDENT> print ( ai , half_ai ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ( i_left == i_right and i_left == 0 ) : <NEWLINE> <INDENT> print ( ai , a [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ( abs ( half_ai - a [ i_left - 1 ] ) >= <NEWLINE> <INDENT> abs ( half_ai - a [ i_right ] ) and i_right != len ( a ) - 1 ) : <NEWLINE> print ( ai , a [ i_right ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ai , a [ i_left - 1 ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> m = 7 % k <NEWLINE> <NL> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = ( 10 * m + 7 ) % k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> a , b , x = I ( ) <NEWLINE> <NL> if a ** 2 * b <= 2 * x : <NEWLINE> <INDENT> ama = a ** 2 * b - x <NEWLINE> ran = 2 * ama / ( a ** 2 ) <NEWLINE> print ( 90 - 180 / math . pi * math . atan2 ( a , ran ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ran = 2 * x / ( a * b ) <NEWLINE> print ( 90 - 180 / math . pi * math . atan2 ( ran , b ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> A = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> B = input ( ) . split ( ) <NEWLINE> <NL> if B [ 1 ] != 0 : <NEWLINE> <INDENT> for j in range ( int ( B [ 1 ] ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> A [ i ] [ int ( B [ 2 + j ] ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j != n - 1 : <NEWLINE> <INDENT> print ( A [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import queue <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A , np . int64 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 60 + 1 ) : <NEWLINE> <INDENT> a = ( A >> i ) & 1 <NEWLINE> count1 = np . count_nonzero ( a ) <NEWLINE> count0 = len ( A ) - count1 <NEWLINE> ans += count1 * count0 * pow ( 2 , i ) <NEWLINE> ans %= 1000000007 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in dic . keys ( ) : <NEWLINE> <INDENT> print ( dic [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> b = x - a <NEWLINE> if a * 2 + b * 4 == y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> s = str ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> rnum = s . count ( <STRING> ) <NEWLINE> gnum = s . count ( <STRING> ) <NEWLINE> bnum = s . count ( <STRING> ) <NEWLINE> <NL> ans = rnum * gnum * bnum <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> INIT = 100 <NEWLINE> <NL> query = [ ] <NEWLINE> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> q = int ( input ( ) ) <NEWLINE> if q == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> query . append ( q ) <NEWLINE> <DEDENT> MAX = max ( query ) <NEWLINE> <NL> table = [ INIT ] * ( MAX + 1 ) <NEWLINE> table [ 0 ] = 0 <NEWLINE> all_item = [ i * ( i + 1 ) * ( i + 2 ) // 6 for i in range ( 1 , 181 ) ] <NEWLINE> odd_item = [ i for i in all_item if i % 2 ] <NEWLINE> eve_item = [ i for i in all_item if not i % 2 ] <NEWLINE> <NL> for v in odd_item : <NEWLINE> <INDENT> for j in range ( v , MAX + 1 ) : <NEWLINE> <INDENT> tjv = table [ j - v ] <NEWLINE> if table [ j ] > tjv + 1 : <NEWLINE> <INDENT> table [ j ] = tjv + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for q in query : <NEWLINE> <INDENT> ans . append ( table [ q ] ) <NEWLINE> <NL> <DEDENT> for v in eve_item : <NEWLINE> <INDENT> for j in range ( v , MAX + 1 ) : <NEWLINE> <INDENT> tjv = table [ j - v ] <NEWLINE> if tjv < 5 and table [ j ] > tjv + 1 : <NEWLINE> <INDENT> table [ j ] = tjv + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i , q in enumerate ( query ) : <NEWLINE> <INDENT> print ( table [ q ] , ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> A , B , N = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> def func ( A , B , x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <DEDENT> print ( func ( A , B , min ( N , B - 1 ) ) ) <NEWLINE> <NL>
def twodig ( x , N ) : <NEWLINE> <INDENT> l = list ( bin ( x ) ) <NEWLINE> n = len ( l ) - 2 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N - n ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( 2 , n + 2 ) : <NEWLINE> <INDENT> ans . append ( int ( l [ i ] ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> lista = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lista . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> r = twodig ( count , N ) <NEWLINE> newlista = [ ] <NEWLINE> c = r . count ( 1 ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> index = r . index ( 1 ) <NEWLINE> r [ index ] = 0 <NEWLINE> newlista . append ( lista [ index ] ) <NEWLINE> <DEDENT> for k in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> summ = 0 <NEWLINE> for l in range ( c ) : <NEWLINE> <INDENT> summ += newlista [ l ] [ k ] <NEWLINE> <DEDENT> if ( summ < X ) : <NEWLINE> <INDENT> ans . append ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cuota = 0 <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> cuota += newlista [ i ] [ 0 ] <NEWLINE> <DEDENT> ans . append ( cuota ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Ans = list ( filter ( lambda x : x != - 1 , ans ) ) <NEWLINE> <NL> if ( Ans == [ ] ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( Ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def calculate ( n , arr ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] == 0 : <NEWLINE> <INDENT> res = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if res == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> res = res * arr [ i ] <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> print ( calculate ( N , ARR ) ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> input_data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in input_data : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = 1 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> result = result * int ( input_data [ i ] ) <NEWLINE> if pow ( 10 , 18 ) < result : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> f = [ ] <NEWLINE> x = 1 <NEWLINE> while x <= N : <NEWLINE> <INDENT> f . append ( x ) <NEWLINE> x = 3 * x + 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> g = f [ : : - 1 ] <NEWLINE> <NL> def insertionSort ( a , N , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , N ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> m = len ( g ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> insertionSort ( a , N , g [ j ] ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 1 <NEWLINE> if 0 in list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in list : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> al_sum = sum ( al ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> num = [ 0 ] * 100001 <NEWLINE> for a in al : <NEWLINE> <INDENT> num [ a ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> al_sum += num [ bi ] * ( ci - bi ) <NEWLINE> num [ ci ] += num [ bi ] <NEWLINE> num [ bi ] = 0 <NEWLINE> <NL> print ( al_sum ) <NEWLINE> <DEDENT>
B = [ ] ; C = [ ] ; S = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> X = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X [ A [ i ] ] += 1 <NEWLINE> S = S + A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> X [ C [ i ] ] += X [ B [ i ] ] <NEWLINE> S = S + X [ B [ i ] ] * ( C [ i ] - B [ i ] ) <NEWLINE> X [ B [ i ] ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> length = len ( a ) - len ( b ) + 1 <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> A = list ( <STRING> * i + b + <STRING> * ( length - i - 1 ) ) <NEWLINE> flag = True <NEWLINE> for j in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ j ] == <STRING> or a [ j ] == A [ j ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif a [ j ] != <STRING> and A [ j ] == <STRING> : <NEWLINE> <INDENT> A [ j ] = a [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans . append ( <STRING> . join ( A ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> ans . sort ( ) <NEWLINE> print ( ans [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = [ 0 ] * 10 ** 5 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( a , b + 1 ) : <NEWLINE> <INDENT> c [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 2 ] = max ( A [ 0 ] , A [ 1 ] ) <NEWLINE> s = A [ 0 ] <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> if i <= 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i % 2 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i - 1 ] , a + dp [ i - 2 ] ) <NEWLINE> s += a <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] = max ( a + dp [ i - 2 ] , s ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , node_id , left , right ) : <NEWLINE> <INDENT> self . node_id = node_id <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def pre_order_search ( self ) : <NEWLINE> <INDENT> l = self . left <NEWLINE> r = self . right <NEWLINE> print ( <STRING> + str ( self . node_id ) , end = <STRING> ) <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> tree [ l ] . pre_order_search ( ) <NEWLINE> <DEDENT> if r != - 1 : <NEWLINE> <INDENT> tree [ r ] . pre_order_search ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def in_order_search ( self ) : <NEWLINE> <INDENT> l = self . left <NEWLINE> r = self . right <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> tree [ l ] . in_order_search ( ) <NEWLINE> <DEDENT> print ( <STRING> + str ( self . node_id ) , end = <STRING> ) <NEWLINE> if r != - 1 : <NEWLINE> <INDENT> tree [ r ] . in_order_search ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def post_order_search ( self ) : <NEWLINE> <INDENT> l = self . left <NEWLINE> r = self . right <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> tree [ l ] . post_order_search ( ) <NEWLINE> <DEDENT> if r != - 1 : <NEWLINE> <INDENT> tree [ r ] . post_order_search ( ) <NEWLINE> <DEDENT> print ( <STRING> + str ( self . node_id ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = [ None for i in range ( n ) ] <NEWLINE> root_set = set ( range ( n ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> node_id , left , right = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ node_id ] = Node ( node_id , left , right ) <NEWLINE> root_set -= set ( [ left , right ] ) <NEWLINE> <DEDENT> root = root_set . pop ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> tree [ root ] . pre_order_search ( ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> tree [ root ] . in_order_search ( ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> tree [ root ] . post_order_search ( ) <NEWLINE> print ( ) <NEWLINE>
def insertion_sort ( array , element_number ) : <NEWLINE> <INDENT> for i in range ( element_number ) : <NEWLINE> <INDENT> v = array [ i ] <NEWLINE> j = i - 1 <NEWLINE> <NL> while ( j >= 0 and array [ j ] > v ) : <NEWLINE> <INDENT> array [ j + 1 ] = array [ j ] <NEWLINE> j = j - 1 <NEWLINE> <NL> <DEDENT> array [ j + 1 ] = v <NEWLINE> <NL> for k in range ( element_number ) : <NEWLINE> <INDENT> if k < element_number - 1 : <NEWLINE> <INDENT> print ( str ( array [ k ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( array [ k ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def test ( ) : <NEWLINE> <INDENT> element_number = int ( input ( ) ) <NEWLINE> input_array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> insertion_sort ( input_array , element_number ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pattern = 0 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> min = i * ( 0 + i - 1 ) // 2 <NEWLINE> max = i * ( n + n - i + 1 ) // 2 <NEWLINE> pattern += max - min + 1 <NEWLINE> <NL> <DEDENT> pattern %= 10 ** 9 + 7 <NEWLINE> <NL> print ( pattern ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = g = b = d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> a = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 * j - i <NEWLINE> if k >= n or s [ k ] == s [ i ] or s [ k ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a - d ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = 1 <NEWLINE> b = c = 0 <NEWLINE> exec ( <STRING> * int ( input ( ) ) ) <NEWLINE> print ( a % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def slowsolve ( N , K ) : <NEWLINE> <INDENT> import itertools <NEWLINE> import math <NEWLINE> data = { } <NEWLINE> s = 0 <NEWLINE> KK = [ i for i in range ( 1 , K + 1 ) ] <NEWLINE> for p in itertools . product ( KK , repeat = N ) : <NEWLINE> <INDENT> cdi = p [ 0 ] <NEWLINE> for c in p : <NEWLINE> <INDENT> cdi = math . gcd ( cdi , c ) <NEWLINE> <DEDENT> s += cdi <NEWLINE> data . setdefault ( cdi , 0 ) <NEWLINE> data [ cdi ] += 1 <NEWLINE> <DEDENT> print ( data ) <NEWLINE> return s <NEWLINE> <NL> <NL> <DEDENT> cache = { } <NEWLINE> def solve ( N , K ) : <NEWLINE> <INDENT> M = pow ( 10 , 9 ) + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> P = pow ( K // i , N , M ) <NEWLINE> j = i + i <NEWLINE> while j <= K : <NEWLINE> <INDENT> P -= cache [ j ] <NEWLINE> j += i <NEWLINE> <DEDENT> while P < 0 : <NEWLINE> <INDENT> P += M <NEWLINE> <NL> <DEDENT> cache [ i ] = P <NEWLINE> ans += i * P <NEWLINE> ans %= M <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( solve ( N , K ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> A . append ( S ) <NEWLINE> <NL> <DEDENT> print ( len ( list ( set ( A ) ) ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> from collections import Counter <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( abs ( min ( ( uf . parents ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> b = 100 - int ( b ) <NEWLINE> if b < 10 : <NEWLINE> <INDENT> b = str ( <STRING> ) + str ( b ) <NEWLINE> <DEDENT> elif b == 100 : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = str ( b ) <NEWLINE> <DEDENT> a = a + b <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> l2 = sorted ( l ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( l . index ( l2 [ i ] ) + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * result ) <NEWLINE>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> mod = [ 1 ] + [ 0 for _ in range ( 2019 ) ] <NEWLINE> ml = [ 0 for _ in range ( l + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> tmp = 0 <NEWLINE> for idx , degit in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> m = int ( degit ) * pow ( 10 , idx , 2019 ) <NEWLINE> m = ( m + tmp ) % 2019 <NEWLINE> tmp = m <NEWLINE> ans += mod [ m ] <NEWLINE> mod [ m ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> digit = 1 <NEWLINE> sum = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> sum = ( sum + int ( c ) * digit ) % 2019 <NEWLINE> digit = digit * 10 % 2019 <NEWLINE> counts [ sum ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for c in counts : <NEWLINE> <INDENT> result += c * ( c - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> integers = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> len_bin_k = len ( <STRING> . format ( K ) ) <NEWLINE> keys = [ K ] <NEWLINE> for shift in range ( 1 , len_bin_k + 1 ) : <NEWLINE> <INDENT> if ( K >> shift ) & 1 == 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> keys . append ( ( ( K >> shift ) << shift ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> vals = defaultdict ( int ) <NEWLINE> for a , b in integers : <NEWLINE> <INDENT> for k in keys : <NEWLINE> <COMMENT> <NL> <INDENT> if k | a == k : <NEWLINE> <INDENT> vals [ k ] += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( vals . values ( ) ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( vals . values ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> from collections import Counter <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K , L = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> uf_road = UnionFind ( N ) <NEWLINE> uf_train = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> uf_road . union ( p - 1 , q - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( L ) : <NEWLINE> <INDENT> r , s = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> uf_train . union ( r - 1 , s - 1 ) <NEWLINE> <NL> <DEDENT> pairs = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pairs . append ( ( uf_road . find ( i ) , uf_train . find ( i ) ) ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( pairs ) <NEWLINE> res = [ cnt [ pair ] for pair in pairs ] <NEWLINE> print ( * res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> l = sorted ( l ) <NEWLINE> <NL> import collections <NEWLINE> c = collections . Counter ( l ) <NEWLINE> d = c . most_common ( ) <NEWLINE> <NL> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if d [ i ] [ 1 ] == d [ 0 ] [ 1 ] : <NEWLINE> <INDENT> print ( d [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
data = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = 1000 <NEWLINE> S = [ 0 for i in range ( n ) ] <NEWLINE> <NL> def isEmpty ( ) : <NEWLINE> <INDENT> global top <NEWLINE> if ( top == 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def isFull ( ) : <NEWLINE> <INDENT> global top , n <NEWLINE> return top > n - 1 <NEWLINE> <NL> <DEDENT> def push ( S , x ) : <NEWLINE> <INDENT> global top <NEWLINE> if isFull ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return False <NEWLINE> <DEDENT> top += 1 <NEWLINE> S [ top ] = x <NEWLINE> <NL> <DEDENT> def pop ( S ) : <NEWLINE> <INDENT> global top <NEWLINE> if isEmpty ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return False <NEWLINE> <DEDENT> top -= 1 <NEWLINE> return S [ top + 1 ] <NEWLINE> <NL> <DEDENT> top = 0 <NEWLINE> <NL> for e in data : <NEWLINE> <NL> <NL> <INDENT> if e . isdigit ( ) : <NEWLINE> <INDENT> push ( S , e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( pop ( S ) ) <NEWLINE> b = int ( pop ( S ) ) <NEWLINE> <NL> if e == <STRING> : <NEWLINE> <INDENT> push ( S , b + a ) <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> push ( S , b - a ) <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> push ( S , b * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( S [ top ] ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a_times = 0 <NEWLINE> b_times = 0 <NEWLINE> c_times = 0 <NEWLINE> <NL> if a <= k : <NEWLINE> <INDENT> a_times = a <NEWLINE> <COMMENT> <NL> if a_times + b <= k : <NEWLINE> <INDENT> b_times = b <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> b_times = k - a_times <NEWLINE> <COMMENT> <NL> <DEDENT> if a_times + b_times + c <= k : <NEWLINE> <INDENT> c_times = c <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> c_times = k - a_times - b_times <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a_times = k <NEWLINE> <NL> <NL> <DEDENT> print ( a_times * 1 + b_times * 0 + c_times * - 1 ) <NEWLINE>
S = list ( input ( ) ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <COMMENT> <NEWLINE> current = 0 <NEWLINE> x = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> current = ( current + x * int ( s ) ) % 2019 <NEWLINE> ans += mods [ current ] <NEWLINE> mods [ current ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ A [ 0 ] ] <NEWLINE> s = { A [ 0 ] } <NEWLINE> a = A [ 0 ] - 1 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> if A [ a ] not in s : <NEWLINE> <INDENT> l . append ( A [ a ] ) <NEWLINE> s . add ( A [ a ] ) <NEWLINE> a = A [ a ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = A [ a ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> n = len ( l ) <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] == a : <NEWLINE> <INDENT> del l [ 0 : i ] <NEWLINE> b = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> T = len ( l ) <NEWLINE> S = ( K - b ) % T <NEWLINE> ans = l [ S - 1 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> c = 0 <NEWLINE> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = x * a [ i ] <NEWLINE> <NL> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> c = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> otv = 0 <NEWLINE> D = [ 0 ] * ( k + 1 ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> D [ i ] = pow ( k // i , n , mod ) <NEWLINE> <NL> <DEDENT> for i in range ( k // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i * 2 , k + 1 , i ) : <NEWLINE> <INDENT> D [ i ] -= D [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> otv = ( otv + D [ i ] * i ) % mod <NEWLINE> <NL> <DEDENT> print ( otv ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> from heapq import heapify , heappop , heappush , heappushpop <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> mod = 2019 <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> dp = [ 0 ] * ( mod ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> r = 0 <NEWLINE> t = 1 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> r += int ( i ) * t <NEWLINE> r %= mod <NEWLINE> t *= 10 <NEWLINE> t %= mod <NEWLINE> dp [ r ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in dp : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> class MakeTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , key , p = None , l = None , r = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . p = p <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> <NL> <DEDENT> <DEDENT> def Insert ( root , value ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = root <NEWLINE> z = MakeTree ( value ) <NEWLINE> <NL> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if x . key > z . key : <NEWLINE> <INDENT> x = x . l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . r <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . l = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . r = z <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def inParse ( u ) : <NEWLINE> <INDENT> if u == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inParse ( u . l ) <NEWLINE> global inParseList <NEWLINE> inParseList . append ( u . key ) <NEWLINE> inParse ( u . r ) <NEWLINE> <NL> <DEDENT> def preParse ( u ) : <NEWLINE> <INDENT> if u == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> global preParseList <NEWLINE> preParseList . append ( u . key ) <NEWLINE> preParse ( u . l ) <NEWLINE> preParse ( u . r ) <NEWLINE> <NL> <NL> <DEDENT> root = None <NEWLINE> n = int ( input ( ) ) <NEWLINE> inParseList = [ ] <NEWLINE> preParseList = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> order = list ( input ( ) . split ( ) ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> root = Insert ( root , int ( order [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inParse ( root ) <NEWLINE> preParse ( root ) <NEWLINE> <NL> print ( <STRING> + <STRING> . join ( [ str ( i ) for i in inParseList ] ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( [ str ( i ) for i in preParseList ] ) ) <NEWLINE> preParseList = [ ] <NEWLINE> inParseList = [ ] <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ls = deque ( [ 0 ] ) <NEWLINE> ans = [ - 1 ] * N <NEWLINE> ans [ 0 ] = 0 <NEWLINE> while len ( ls ) > 0 : <NEWLINE> <INDENT> v = ls . popleft ( ) <NEWLINE> <NL> for next_v in G [ v ] : <NEWLINE> <INDENT> if ans [ next_v ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ next_v ] = v <NEWLINE> ls . append ( next_v ) <NEWLINE> <NL> <DEDENT> <DEDENT> if - 1 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> ans = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] += 11 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if W == 1 : <NEWLINE> <INDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if ans [ i + 1 ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if ans [ i - 1 ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if ans [ i ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> ans [ i ] = map ( str , ans [ i ] ) <NEWLINE> ans [ i ] = <STRING> . join ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if ans [ i ] [ j + 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , W ) : <NEWLINE> <INDENT> if ans [ i ] [ j - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if ans [ i + 1 ] [ j - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> if ans [ i + 1 ] [ j ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> if ans [ i + 1 ] [ j + 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if ans [ i - 1 ] [ j - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> if ans [ i - 1 ] [ j ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <DEDENT> if ans [ i - 1 ] [ j + 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if ans [ i + 1 ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> if ans [ i + 1 ] [ 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if ans [ i - 1 ] [ 0 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> if ans [ i - 1 ] [ 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ 0 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if ans [ i + 1 ] [ W - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ W - 1 ] += 1 <NEWLINE> <DEDENT> if ans [ i + 1 ] [ W - 2 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ W - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if ans [ i - 1 ] [ W - 1 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ W - 1 ] += 1 <NEWLINE> <DEDENT> if ans [ i - 1 ] [ W - 2 ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ W - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ans [ i ] [ j ] > 10 : <NEWLINE> <INDENT> ans [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = map ( str , ans [ i ] ) <NEWLINE> ans [ i ] = <STRING> . join ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> n_R = S . count ( <STRING> ) <NEWLINE> n_G = S . count ( <STRING> ) <NEWLINE> n_B = N - n_R - n_G <NEWLINE> ans = n_R * n_G * n_B <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> import math <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B_float = float ( B ) <NEWLINE> B_int = int ( B [ 0 ] + B [ 2 : ] ) <NEWLINE> if B_float < 1 : <NEWLINE> <INDENT> B_float = B_float * 100 <NEWLINE> C = A * B_float / 100 <NEWLINE> <COMMENT> <NL> print ( <STRING> . format ( int ( C ) ) ) <NEWLINE> <DEDENT> elif not A == 0 : <NEWLINE> <INDENT> C = A * B_int <NEWLINE> C_str = str ( C ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . format ( int ( C_str [ : - 2 ] ) ) ) <NEWLINE> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( 0 ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> n , m , q = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> q = int ( q ) <NEWLINE> num_list = [ ] <NEWLINE> a = list ( range ( 1 , n + 1 ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> num_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ff = list ( itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> max = 0 <NEWLINE> for i in range ( len ( ff ) ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = num_list [ j ] <NEWLINE> if ff [ i ] [ b - 1 ] - ff [ i ] [ a - 1 ] == c : <NEWLINE> <INDENT> s = s + d <NEWLINE> <DEDENT> <DEDENT> if max < s : <NEWLINE> <INDENT> max = s <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> M = 2019 <NEWLINE> <NL> remainder = [ 0 ] * M <NEWLINE> val = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> val = ( int ( S [ N - 1 - i ] ) * pow ( 10 , i , M ) + val ) % M <NEWLINE> remainder [ val ] += 1 <NEWLINE> <NL> <DEDENT> ans = remainder [ 0 ] <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += remainder [ i ] * ( remainder [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 , 0 , 0 ] <NEWLINE> <NL> i = bisect . bisect_left ( s , x ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> sl = 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sl = abs ( s [ i - 1 ] - x ) <NEWLINE> <DEDENT> if i == a : <NEWLINE> <INDENT> sr = 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sr = abs ( s [ i ] - x ) <NEWLINE> <DEDENT> i = bisect . bisect_left ( t , x ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> tl = 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl = abs ( t [ i - 1 ] - x ) <NEWLINE> <DEDENT> if i == b : <NEWLINE> <INDENT> tr = 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tr = abs ( t [ i ] - x ) <NEWLINE> <DEDENT> ans [ 0 ] = max ( tl , sl ) <NEWLINE> ans [ 1 ] = max ( tr , sr ) <NEWLINE> ans [ 2 ] = min ( 2 * tl + sr , 2 * sl + tr , 2 * sr + tl , 2 * tr + sl ) <NEWLINE> print ( min ( ans ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def print_A ( A , N ) : <NEWLINE> <INDENT> stri = <STRING> <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> stri += str ( A [ i ] ) + <STRING> <NEWLINE> <DEDENT> stri += str ( A [ N - 1 ] ) <NEWLINE> print ( stri ) <NEWLINE> <NL> <DEDENT> def insertionSort ( A , N ) : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> v = A [ i + 1 ] <NEWLINE> j = i <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print_A ( A , N ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print_A ( A , N ) <NEWLINE> insertionSort ( A , N ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in ar : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in ar : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> ls = len ( s ) <NEWLINE> for i in range ( ls ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for j in range ( 1 , ls - 1 ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < ls : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> n = int ( s [ 3 ] ) <NEWLINE> sum_ = 0 <NEWLINE> if int ( s [ 0 ] ) >= n : <NEWLINE> <INDENT> sum_ = 1 * n <NEWLINE> <DEDENT> elif int ( s [ 0 ] ) + int ( s [ 1 ] ) >= n : <NEWLINE> <INDENT> sum_ = 1 * ( n - int ( s [ 1 ] ) ) <NEWLINE> <DEDENT> elif int ( s [ 0 ] ) + int ( s [ 1 ] ) + int ( s [ 2 ] ) >= n : <NEWLINE> <INDENT> sum_ = 1 * int ( s [ 0 ] ) + ( - 1 * ( n - int ( s [ 0 ] ) - int ( s [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( sum_ ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> tmp = 7 <NEWLINE> cnt = 0 <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> tmp %= k <NEWLINE> cnt += 1 <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = 10 * tmp % k <NEWLINE> tmp += 7 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_s = sorted ( a ) <NEWLINE> a_set = set ( a_s ) <NEWLINE> maxv = max ( a ) <NEWLINE> res = [ 0 ] * maxv <NEWLINE> rep = 0 <NEWLINE> for i in a_s : <NEWLINE> <INDENT> if i in a_set : <NEWLINE> <INDENT> if res [ i - 1 ] == 0 : <NEWLINE> <INDENT> for j in range ( i , maxv + 1 , i ) : <NEWLINE> <INDENT> res [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res [ i - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if res [ a [ i ] - 1 ] == 1 : <NEWLINE> <INDENT> cnt += res [ a [ i ] - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def I ( ) : return int ( input ( ) ) <NEWLINE> N = I ( ) <NEWLINE> ans = 0 <NEWLINE> if N >= 105 : <NEWLINE> <INDENT> for i in range ( 105 , N + 1 , 2 ) : <NEWLINE> <INDENT> count_yakusuu = 0 <NEWLINE> for j in range ( 1 , int ( i ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> count_yakusuu += 2 <NEWLINE> <DEDENT> <DEDENT> if count_yakusuu == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> t = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> t [ a - 1 ] = 0 <NEWLINE> <NL> <DEDENT> if h [ b - 1 ] <= h [ a - 1 ] : <NEWLINE> <INDENT> t [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( t ) ) <NEWLINE>
import sys <NEWLINE> x = int ( input ( ) ) <NEWLINE> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
floor = [ <NEWLINE> <INDENT> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> <INDENT> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> <NL> <DEDENT> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> <INDENT> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> <NL> <DEDENT> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> <INDENT> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> <NL> <DEDENT> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> <INDENT> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , <NEWLINE> [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> s = <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for c in range ( n ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 1 > b > 5 and 1 > f > 4 and 1 > r > 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> floor [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for z in range ( 4 ) : <NEWLINE> <INDENT> for i in range ( len ( floor [ z ] ) ) : <NEWLINE> <INDENT> for v in floor [ z ] [ i ] : <NEWLINE> <INDENT> print ( end = <STRING> ) <NEWLINE> print ( v , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if not z == 3 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> def solve ( n ) : <NEWLINE> <INDENT> if n % 7 == 0 : <NEWLINE> <INDENT> n //= 7 <NEWLINE> <NL> <DEDENT> if n % 2 == 0 or n % 5 == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> n9 = n * 9 <NEWLINE> d = 10 % n9 <NEWLINE> for i in range ( n9 ) : <NEWLINE> <INDENT> if d == 1 : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <DEDENT> d = ( 10 * d ) % n9 <NEWLINE> <DEDENT> raise RuntimeError ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( istr , ostr ) : <NEWLINE> <INDENT> ( k , ) = list ( map ( int , istr . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> result = solve ( k ) <NEWLINE> print ( result , file = ostr ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> main ( sys . stdin , sys . stdout ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = p = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> one = sum ( [ a >> p & 1 for a in A ] ) <NEWLINE> zero = N - one <NEWLINE> p += 1 <NEWLINE> ans += ( one * zero ) * 2 ** i <NEWLINE> ans %= M <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pa = Decimal ( 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for kk in range ( k , n ) : <NEWLINE> <INDENT> ppa = pa * A [ kk ] / A [ kk - k ] <NEWLINE> if ppa > pa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> pa = ppa <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 0 , i + 1 ) : <NEWLINE> <INDENT> y = i ** 5 - j ** 5 <NEWLINE> z = i ** 5 + j ** 5 <NEWLINE> if x == y : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> break <NEWLINE> <DEDENT> elif x == z : <NEWLINE> <INDENT> a = i <NEWLINE> b = - j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> n_R , n_G , n_B , n_total = 0 , 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> n_R += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> n_G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_B += 1 <NEWLINE> <DEDENT> <DEDENT> n_total += ( n_R * n_G * n_B ) <NEWLINE> for j in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> i = j - 1 <NEWLINE> k = j + 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if 0 <= i and k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <COMMENT> <NL> <INDENT> n_total -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i -= 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n_total ) <NEWLINE>
def time ( ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> shussha = A [ : 3 ] <NEWLINE> taisha = A [ 3 : ] <NEWLINE> sec = ( ( taisha [ 2 ] + 60 ) - shussha [ 2 ] ) % 60 <NEWLINE> kurisagari_min = int ( taisha [ 2 ] - shussha [ 2 ] < 0 ) <NEWLINE> min = ( ( taisha [ 1 ] - kurisagari_min + 60 ) - shussha [ 1 ] ) % 60 <NEWLINE> kurisagari_hour = int ( taisha [ 1 ] - kurisagari_min - shussha [ 1 ] < 0 ) <NEWLINE> hour = taisha [ 0 ] - kurisagari_hour - shussha [ 0 ] <NEWLINE> return ( str ( hour ) + <STRING> + str ( min ) + <STRING> + str ( sec ) ) <NEWLINE> <DEDENT> A = time ( ) <NEWLINE> B = time ( ) <NEWLINE> C = time ( ) <NEWLINE> print ( A ) <NEWLINE> print ( B ) <NEWLINE> print ( C ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nlist = [ 0 ] <NEWLINE> mlist = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nlist += [ nlist [ - 1 ] + int ( input ( ) ) ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> mlist += [ mlist [ - 1 ] + int ( input ( ) ) ] <NEWLINE> <NL> <DEDENT> l = [ 0 for i in range ( 1000 * 1501 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for k in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> t = nlist [ k ] - nlist [ i ] <NEWLINE> l [ t ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for k in range ( i + 1 , m + 1 ) : <NEWLINE> <INDENT> t = mlist [ k ] - mlist [ i ] <NEWLINE> count += l [ t ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( N ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> mprime = N // i <NEWLINE> answer += i * ( mprime * ( mprime + 1 ) ) // 2 <NEWLINE> <DEDENT> return answer <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <COMMENT> <NEWLINE> answer = solve ( N ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> input ( ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> def solve ( i , s ) : <NEWLINE> <INDENT> if i == len ( A ) : <NEWLINE> <INDENT> d [ s ] = 0 <NEWLINE> return s <NEWLINE> <NL> <DEDENT> solve ( i + 1 , s ) <NEWLINE> solve ( i + 1 , s + A [ i ] ) <NEWLINE> return 1 <NEWLINE> <NL> <DEDENT> solve ( 0 , 0 ) <NEWLINE> for a in M : <NEWLINE> <INDENT> if a in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
t = input ( ) <NEWLINE> ans = 0 <NEWLINE> t = list ( t ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if i + 1 < len ( t ) and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i + 1 ] = <STRING> <NEWLINE> <COMMENT> <NL> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> elif t [ i ] == <STRING> : <NEWLINE> <INDENT> if i + 1 < len ( t ) and i > 0 and t [ i - 1 ] == <STRING> and ( t [ i + 1 ] == <STRING> or t [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif i + 1 < len ( t ) and ( t [ i + 1 ] == <STRING> or t [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <COMMENT> <NL> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <COMMENT> <NL> ans += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> elif t [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> p = <STRING> <NEWLINE> for i in t : <NEWLINE> <INDENT> p += i <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
K = int ( input ( ) ) <NEWLINE> ans = False <NEWLINE> M , N = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> for number in range ( M , N + 1 ) : <NEWLINE> <INDENT> if number % K == 0 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> counter = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for p in range ( n ) : <NEWLINE> <INDENT> j = i + p <NEWLINE> k = j + p <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> counter -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
def actual ( N , M , AB ) : <NEWLINE> <INDENT> payment = 0 <NEWLINE> <NL> shop_order_by_price_desc = sorted ( AB , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> for price , stock in shop_order_by_price_desc : <NEWLINE> <INDENT> if stock >= M : <NEWLINE> <COMMENT> <NL> <INDENT> return payment + ( price * M ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> M -= stock <NEWLINE> payment += price * stock <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AB . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> print ( actual ( N , M , AB ) ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> if b <= a : <NEWLINE> <INDENT> b = 2 * b <NEWLINE> continue <NEWLINE> <DEDENT> if c <= b : <NEWLINE> <INDENT> c = 2 * c <NEWLINE> continue <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if ( a < b ) & ( b < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = 0 <NEWLINE> c = int ( a ** ( 1 / 2 ) ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if ( ( i ** 5 ) - ( j ** 5 ) == a ) : <NEWLINE> <INDENT> b = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( b == 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i , j ) <NEWLINE>
N = input ( ) <NEWLINE> fn = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> fn += int ( i ) <NEWLINE> <NL> <DEDENT> print ( <STRING> if int ( N ) % fn == 0 else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> k = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> k1 , k2 = a , b <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> k1 , k2 = b , a <NEWLINE> <NL> <DEDENT> r = k1 % k2 <NEWLINE> if r != 0 : <NEWLINE> <INDENT> return gcd ( k2 , r ) <NEWLINE> <DEDENT> elif r == 0 : <NEWLINE> <INDENT> return k2 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <NL> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <NL> <INDENT> f = gcd ( a , b ) <NEWLINE> <NL> for c in range ( 1 , b + 1 ) : <NEWLINE> <NL> <INDENT> g = gcd ( f , c ) <NEWLINE> <NL> if a == b and b != c : <NEWLINE> <INDENT> count += g * 3 <NEWLINE> <DEDENT> elif b == c and c != a : <NEWLINE> <INDENT> count += g * 3 <NEWLINE> <DEDENT> elif c == a and a != b : <NEWLINE> <INDENT> count += g * 3 <NEWLINE> <DEDENT> elif a == b and b == c : <NEWLINE> <INDENT> count += g <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += g * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( count ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ set ( ) for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> grid [ u ] . add ( v ) <NEWLINE> grid [ v ] . add ( u ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> best = 0 <NEWLINE> visited = set ( ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def dfs ( x ) : <NEWLINE> <INDENT> global cnt <NEWLINE> if x in visited : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> visited . add ( x ) <NEWLINE> for i in grid [ x ] : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> dfs ( i ) <NEWLINE> best = max ( best , cnt ) <NEWLINE> <NL> <DEDENT> print ( best ) <NEWLINE>
hiki , hon = map ( int , input ( ) . split ( ) ) <NEWLINE> turu = 0 <NEWLINE> kame = 0 <NEWLINE> <NL> for i in range ( 50 ) : <NEWLINE> <INDENT> if hiki > 0 and hon >= 4 : <NEWLINE> <INDENT> hon = hon - 4 <NEWLINE> kame = kame + 1 <NEWLINE> hiki = hiki - 1 <NEWLINE> <DEDENT> elif hon == 2 and hiki == 1 : <NEWLINE> <INDENT> hiki = 0 <NEWLINE> hon = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> hantei = hon % 2 <NEWLINE> <NL> for i in range ( 50 ) : <NEWLINE> <INDENT> if hiki == 0 or kame == 0 or hantei == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif hiki > 0 and kame > 0 and hantei == 0 : <NEWLINE> <INDENT> hiki = hiki - 1 <NEWLINE> kame = kame - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if hiki == 0 and hon == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
flag = [ False ] * 53 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , n = map ( str , input ( ) . split ( ) ) <NEWLINE> n = int ( n ) <NEWLINE> if ( c == <STRING> ) : <NEWLINE> <INDENT> flag [ n ] = True <NEWLINE> <DEDENT> elif ( c == <STRING> ) : <NEWLINE> <INDENT> flag [ 13 + n ] = True <NEWLINE> <DEDENT> elif ( c == <STRING> ) : <NEWLINE> <INDENT> flag [ 26 + n ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ 39 + n ] = True <NEWLINE> <DEDENT> <DEDENT> suit = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 1 , len ( flag ) ) : <NEWLINE> <INDENT> if ( flag [ i ] == False ) : <NEWLINE> <INDENT> print ( suit [ ( i - 1 ) // 13 ] , ( i - 1 ) % 13 + 1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> z = input ( ) <NEWLINE> x = int ( z ) <NEWLINE> <NL> if x % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> itemCount = 0 <NEWLINE> itemList = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> item = input ( ) <NEWLINE> if item in itemList : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> itemCount += 1 <NEWLINE> itemList [ item ] = item <NEWLINE> <NL> <DEDENT> <DEDENT> print ( itemCount ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> num = 0 <NEWLINE> result = [ 0 ] <NEWLINE> <NL> <NL> for c in S : <NEWLINE> <INDENT> if c == <STRING> or c == <STRING> or c == <STRING> or c == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( num ) <NEWLINE> num = 0 <NEWLINE> <DEDENT> <DEDENT> result . append ( num ) <NEWLINE> <NL> <COMMENT> <NL> print ( max ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> out = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 8 : <NEWLINE> <INDENT> out += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> z = [ ] <NEWLINE> y = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( <STRING> ) <NEWLINE> if int ( line [ 0 ] ) == int ( line [ 1 ] ) : <NEWLINE> <INDENT> z . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( z ) - 2 ) : <NEWLINE> <INDENT> if z [ i ] == z [ i + 1 ] - 1 : <NEWLINE> <INDENT> if z [ i + 1 ] == z [ i + 2 ] - 1 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if y > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> temp = X . count ( <STRING> ) <NEWLINE> t = [ 0 , 0 , 0 ] <NEWLINE> <NL> t [ 0 ] = int ( X , 2 ) % ( temp - 1 ) if temp != 1 else 0 <NEWLINE> t [ 2 ] = int ( X , 2 ) % ( temp + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> and temp == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> p = pow ( 2 , N - 1 - i , temp - 1 ) <NEWLINE> a = ( t [ 0 ] - p ) % ( temp - 1 ) <NEWLINE> <DEDENT> elif X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> m = pow ( 2 , N - 1 - i , temp + 1 ) <NEWLINE> a = ( t [ 2 ] + m ) % ( temp + 1 ) <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> while a > 0 : <NEWLINE> <INDENT> a = a % format ( a , <STRING> ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) -> None : <NEWLINE> <INDENT> N , K = rmi ( ) <NEWLINE> A = rmi ( ) <NEWLINE> route = [ ] <NEWLINE> visited = [ False ] * N <NEWLINE> current = 1 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> route . append ( current ) <NEWLINE> if not visited [ current - 1 ] : <NEWLINE> <INDENT> visited [ current - 1 ] = True <NEWLINE> current = A [ current - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> dup = route [ - 1 ] <NEWLINE> dup_index = route . index ( dup ) <NEWLINE> roop_range = len ( route ) - dup_index - 1 <NEWLINE> if K < dup_index : <NEWLINE> <INDENT> w ( route [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w ( route [ dup_index : ] [ ( K - dup_index ) % roop_range ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def r ( ) -> str : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def ri ( ) -> int : <NEWLINE> <INDENT> return int ( r ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def rmi ( delim : str = <STRING> ) -> tuple : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( delim ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def w ( data ) -> None : <NEWLINE> <INDENT> print ( data ) <NEWLINE> <NL> <NL> <DEDENT> def wm ( * data , delim : str = <STRING> ) -> None : <NEWLINE> <INDENT> print ( delim . join ( map ( str , data ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = int ( a * x / b ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( S ) < 26 : <NEWLINE> <INDENT> for x in S : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> for x in a : <NEWLINE> <INDENT> if d [ x ] == 0 : <NEWLINE> <INDENT> print ( S + x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = 25 <NEWLINE> while S [ i - 1 ] > S [ i ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> ss = sorted ( list ( S [ i - 1 : ] ) ) <NEWLINE> t = S [ i - 1 ] <NEWLINE> print ( S [ : i - 1 ] + ss [ ss . index ( t ) + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> st = set ( ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> st . add ( s ) <NEWLINE> <DEDENT> print ( len ( st ) ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> from heapq import heapify , heappop , heappush , heappushpop <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> import bisect <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if i ** 2 + j ** 2 + k ** 2 + i * j + j * k + i * k <= n : <NEWLINE> <INDENT> ans [ i ** 2 + j ** 2 + k ** 2 + i * j + j * k + i * k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( B - 1 ) <= N : <NEWLINE> <INDENT> print ( math . floor ( A * ( B - 1 ) / B ) - math . floor ( ( B - 1 ) / B ) * A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) - math . floor ( N / B ) * A ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs = [ ] <NEWLINE> rows = [ [ ] for _ in range ( H ) ] <NEWLINE> cols = [ [ ] for _ in range ( W ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> bombs . append ( ( h , w ) ) <NEWLINE> rows [ h ] . append ( w ) <NEWLINE> cols [ w ] . append ( h ) <NEWLINE> <NL> <DEDENT> max_row = 0 <NEWLINE> row_idx = set ( ) <NEWLINE> for i , row in enumerate ( rows ) : <NEWLINE> <INDENT> if max_row < len ( row ) : <NEWLINE> <INDENT> max_row = len ( row ) <NEWLINE> row_idx = { i } <NEWLINE> continue <NEWLINE> <DEDENT> elif max_row == len ( row ) : <NEWLINE> <INDENT> row_idx . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_col = 0 <NEWLINE> col_idx = set ( ) <NEWLINE> for i , col in enumerate ( cols ) : <NEWLINE> <INDENT> if max_col < len ( col ) : <NEWLINE> <INDENT> max_col = len ( col ) <NEWLINE> col_idx = { i } <NEWLINE> continue <NEWLINE> <DEDENT> elif max_col == len ( col ) : <NEWLINE> <INDENT> col_idx . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max_row + max_col <NEWLINE> points = len ( row_idx ) * len ( col_idx ) <NEWLINE> if M < points : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i , j in bombs : <NEWLINE> <INDENT> if i in row_idx and j in col_idx : <NEWLINE> <INDENT> points -= 1 <NEWLINE> <DEDENT> <DEDENT> if points == 0 : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> way = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> ans = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> reached = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> way [ a ] . append ( b ) <NEWLINE> way [ b ] . append ( a ) <NEWLINE> <DEDENT> D = deque ( [ 1 ] ) <NEWLINE> while D : <NEWLINE> <INDENT> go = D . popleft ( ) <NEWLINE> for i in way [ go ] : <NEWLINE> <INDENT> if reached [ i ] == 0 : <NEWLINE> <INDENT> D . append ( i ) <NEWLINE> reached [ i ] = 1 <NEWLINE> ans [ i ] = go <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> if N == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if int ( N ) % 1111 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> while N != <STRING> : <NEWLINE> <INDENT> N = list ( N ) <NEWLINE> S = int ( <STRING> . join ( sorted ( N ) ) ) <NEWLINE> L = int ( <STRING> . join ( sorted ( N ) [ : : - 1 ] ) ) <NEWLINE> ans += 1 <NEWLINE> N = str ( L - S ) . zfill ( 4 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for s in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for t in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> alpha = math . gcd ( s , t ) <NEWLINE> if alpha == 1 : <NEWLINE> <INDENT> total += K <NEWLINE> continue <NEWLINE> <DEDENT> for u in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> total += math . gcd ( alpha , u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S . append ( s ) <NEWLINE> <DEDENT> ans = len ( S ) <NEWLINE> S . sort ( ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ i - 1 ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> val = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> val *= i <NEWLINE> if val > 10 ** 9 + 7 : <NEWLINE> <INDENT> val = val % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( val ) <NEWLINE>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( [ H , W ] ) <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b = a [ i ] <NEWLINE> for j in range ( b [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * b [ 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> if min ( A ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> M = 10 ** 18 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > M : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_dict = collections . Counter ( A ) <NEWLINE> ANS = 1 <NEWLINE> if 0 in A_dict . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for key , value in A_dict . items ( ) : <NEWLINE> <INDENT> ANS = ANS * ( key ** value ) <NEWLINE> if ANS > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ANS ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ichi = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> ni = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> san = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> yon = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> go = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> roku = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> nana = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> hachi = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> kyu = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> zyu = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> zyu_ichi = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> zyu_ni = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> <NL> while n > 0 : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> b = int ( l [ 0 ] ) <NEWLINE> f = int ( l [ 1 ] ) <NEWLINE> r = int ( l [ 2 ] ) <NEWLINE> v = int ( l [ 3 ] ) <NEWLINE> <NL> num = 3 * ( b - 1 ) + f <NEWLINE> <NL> if num == 1 : <NEWLINE> <INDENT> ichi [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> ni [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 3 : <NEWLINE> <INDENT> san [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 4 : <NEWLINE> <INDENT> yon [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 5 : <NEWLINE> <INDENT> go [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 6 : <NEWLINE> <INDENT> roku [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 7 : <NEWLINE> <INDENT> nana [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 8 : <NEWLINE> <INDENT> hachi [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 9 : <NEWLINE> <INDENT> kyu [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 10 : <NEWLINE> <INDENT> zyu [ r - 1 ] += v <NEWLINE> <DEDENT> elif num == 11 : <NEWLINE> <INDENT> zyu_ichi [ r - 1 ] += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zyu_ni [ r - 1 ] += v <NEWLINE> <DEDENT> n = n - 1 <NEWLINE> <DEDENT> m = 1 <NEWLINE> A = <STRING> + str ( ichi [ 0 ] ) <NEWLINE> B = <STRING> + str ( ni [ 0 ] ) <NEWLINE> C = <STRING> + str ( san [ 0 ] ) <NEWLINE> D = <STRING> + str ( yon [ 0 ] ) <NEWLINE> E = <STRING> + str ( go [ 0 ] ) <NEWLINE> F = <STRING> + str ( roku [ 0 ] ) <NEWLINE> G = <STRING> + str ( nana [ 0 ] ) <NEWLINE> H = <STRING> + str ( hachi [ 0 ] ) <NEWLINE> I = <STRING> + str ( kyu [ 0 ] ) <NEWLINE> J = <STRING> + str ( zyu [ 0 ] ) <NEWLINE> K = <STRING> + str ( zyu_ichi [ 0 ] ) <NEWLINE> L = <STRING> + str ( zyu_ni [ 0 ] ) <NEWLINE> while m < 10 : <NEWLINE> <INDENT> A = A + <STRING> + str ( ichi [ m ] ) <NEWLINE> B = B + <STRING> + str ( ni [ m ] ) <NEWLINE> C = C + <STRING> + str ( san [ m ] ) <NEWLINE> D = D + <STRING> + str ( yon [ m ] ) <NEWLINE> E = E + <STRING> + str ( go [ m ] ) <NEWLINE> F = F + <STRING> + str ( roku [ m ] ) <NEWLINE> G = G + <STRING> + str ( nana [ m ] ) <NEWLINE> H = H + <STRING> + str ( hachi [ m ] ) <NEWLINE> I = I + <STRING> + str ( kyu [ m ] ) <NEWLINE> J = J + <STRING> + str ( zyu [ m ] ) <NEWLINE> K = K + <STRING> + str ( zyu_ichi [ m ] ) <NEWLINE> L = L + <STRING> + str ( zyu_ni [ m ] ) <NEWLINE> m = m + 1 <NEWLINE> <DEDENT> print ( A ) <NEWLINE> print ( B ) <NEWLINE> print ( C ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( D ) <NEWLINE> print ( E ) <NEWLINE> print ( F ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( G ) <NEWLINE> print ( H ) <NEWLINE> print ( I ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( J ) <NEWLINE> print ( K ) <NEWLINE> print ( L ) <NEWLINE> <NL>
<COMMENT> <NL> import numpy as np <NEWLINE> from decimal import Decimal <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( 10 ** 9 * Decimal ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> Z = np . zeros ( ( 20 , 20 ) , dtype = int ) <NEWLINE> <NL> def count2 ( a ) : <NEWLINE> <INDENT> n = a <NEWLINE> count = 0 <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> n //= 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def count5 ( a ) : <NEWLINE> <INDENT> n = a <NEWLINE> count = 0 <NEWLINE> while n % 5 == 0 : <NEWLINE> <INDENT> n //= 5 <NEWLINE> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> c2 = count2 ( a ) <NEWLINE> c5 = count5 ( a ) <NEWLINE> t2 = max ( 18 - c2 , 0 ) <NEWLINE> t5 = max ( 18 - c5 , 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> answer += Z [ t2 , t5 ] <NEWLINE> Z [ : min ( 19 , c2 ) + 1 , : min ( 19 , c5 ) + 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = set ( range ( N + 1 ) ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( L ) <NEWLINE> r . append ( R ) <NEWLINE> <DEDENT> ans = min ( r ) - max ( l ) + 1 <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> q = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> r = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = 0 <NEWLINE> c = sorted ( p [ 0 : x ] + q [ 0 : y ] ) <NEWLINE> for i in range ( x + y ) : <NEWLINE> <INDENT> if len ( r ) : <NEWLINE> <INDENT> if c [ i ] < r [ - 1 ] : <NEWLINE> <INDENT> c [ i ] = r . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( c ) ) <NEWLINE>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> ZIP = lambda : zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = MAP ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i ] < A [ i + K ] else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> import collections <NEWLINE> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> L = [ ] <COMMENT> <NEWLINE> R = [ ] <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = y = i + 1 <NEWLINE> L . append ( x + A [ i ] ) <NEWLINE> R . append ( y - A [ i ] ) <NEWLINE> <DEDENT> cl = collections . Counter ( L ) <NEWLINE> cr = collections . Counter ( R ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i in cl and i in cr : <NEWLINE> <INDENT> ans += cl [ i ] * cr [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> def fnw ( n , s ) : <NEWLINE> <INDENT> sm = deque ( [ ] ) <NEWLINE> if n <= len ( s ) : <NEWLINE> <INDENT> for _ in range ( n ) : <NEWLINE> <INDENT> sm . append ( s . popleft ( ) ) <NEWLINE> <DEDENT> <DEDENT> return <STRING> . join ( sm ) <NEWLINE> <NL> <DEDENT> def jfws ( s ) : <NEWLINE> <INDENT> fws = fnw ( 5 , s ) <NEWLINE> if fws == <STRING> : <NEWLINE> <INDENT> fws = fnw ( 2 , s ) <NEWLINE> if fws == <STRING> : <NEWLINE> <INDENT> if s : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . extendleft ( deque ( reversed ( list ( fws ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s . extendleft ( deque ( reversed ( list ( fws ) ) ) ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> elif fws == <STRING> : <NEWLINE> <INDENT> fws = fnw ( 1 , s ) <NEWLINE> if fws != <STRING> and fws != <STRING> : <NEWLINE> <INDENT> s . appendleft ( fws ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( s ) : <NEWLINE> <INDENT> while s : <NEWLINE> <INDENT> if jfws ( s ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> s = deque ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> print ( main ( s ) ) <NEWLINE> <NL>
import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> A_sum = [ 0 ] * ( n + 1 ) <NEWLINE> B_sum = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A_sum [ i + 1 ] = A_sum [ i ] + A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B_sum [ i + 1 ] = B_sum [ i ] + B [ i ] <NEWLINE> <NL> <DEDENT> A_limit = bisect . bisect_right ( A_sum , k ) - 1 <NEWLINE> mc = 0 <NEWLINE> B_i = 0 <NEWLINE> for i in range ( A_limit , - 1 , - 1 ) : <NEWLINE> <INDENT> remain_k = k - A_sum [ i ] <NEWLINE> while ( ( remain_k - B_sum [ B_i ] ) >= 0 ) : <NEWLINE> <INDENT> B_i += 1 <NEWLINE> if ( B_i == ( m + 1 ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> B_i -= 1 <NEWLINE> mc = max ( mc , ( i + B_i ) ) <NEWLINE> <NL> <DEDENT> print ( mc ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> PI = math . pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * PI <NEWLINE> l = 2 * PI * r <NEWLINE> <NL> print ( s , l ) <NEWLINE>
<STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] <NEWLINE> x = 1 <NEWLINE> flag = 0 <NEWLINE> flag1 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> x *= 0 <NEWLINE> flag1 = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag != 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x * a [ i ] > 1000000000000000000 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x *= a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag1 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT>
def fib ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> result = [ 1 , 0 , 0 , 1 ] <NEWLINE> matrix = [ 1 , 1 , 1 , 0 ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n % 2 : <NEWLINE> <INDENT> result = mul ( matrix , result ) <NEWLINE> <DEDENT> matrix = mul ( matrix , matrix ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return result [ 2 ] <NEWLINE> <NL> <DEDENT> def mul ( a , b ) : <NEWLINE> <INDENT> return [ a [ 0 ] * b [ 0 ] + a [ 1 ] * b [ 2 ] , <NEWLINE> <INDENT> a [ 0 ] * b [ 1 ] + a [ 1 ] * b [ 3 ] , <NEWLINE> a [ 2 ] * b [ 0 ] + a [ 3 ] * b [ 2 ] , <NEWLINE> a [ 2 ] * b [ 1 ] + a [ 3 ] * b [ 3 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> S = [ - 1 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> S . append ( N + 1 ) <NEWLINE> S = [ S [ i + 1 ] - S [ i ] for i in range ( M + 1 ) ] <NEWLINE> if any ( [ x == 1 for x in S ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> num = 1 <NEWLINE> for x in S : <NEWLINE> <INDENT> num *= fib ( x - 1 ) <NEWLINE> num = num % 1000000007 <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> sig = [ [ 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] , [ - 1 , - 1 ] ] <NEWLINE> f = False <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> for j in range ( 200 ) : <NEWLINE> <INDENT> for s in sig : <NEWLINE> <INDENT> A = s [ 0 ] * i <NEWLINE> B = s [ 1 ] * j <NEWLINE> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
<COMMENT> <NL> <NL> def solve ( ls , k , debug = 0 ) : <NEWLINE> <INDENT> modulo = 10 ** 9 + 7 <NEWLINE> n = len ( ls ) <NEWLINE> n_neg = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n_neg += ls [ i ] < 0 <NEWLINE> <DEDENT> n_pos = n - n_neg <NEWLINE> <NL> <COMMENT> <NL> ls_abs = [ abs ( x ) for x in ls ] <NEWLINE> ls_abs_argsort = sorted ( list ( range ( n ) ) , key = lambda i : - ls_abs [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> if n_neg >= k : <NEWLINE> <INDENT> positive = ( k % 2 == 0 ) or ( n_pos > 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> positive = ( n_neg % 2 == 0 ) or ( n > k ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if not positive : <NEWLINE> <INDENT> p = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x = ls [ ls_abs_argsort [ - 1 - i ] ] <NEWLINE> p *= x <NEWLINE> p %= modulo <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> s = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x = ls [ ls_abs_argsort [ i ] ] <NEWLINE> s *= - 1 if x < 0 else 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if s > 0 : <NEWLINE> <INDENT> p = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x = ls [ ls_abs_argsort [ i ] ] <NEWLINE> p *= x <NEWLINE> p %= modulo <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> opt1 = None <NEWLINE> opt2 = None <NEWLINE> neg1 = pos1 = None <NEWLINE> pos2 = neg2 = None <NEWLINE> <NL> <COMMENT> <NL> swap_pos = None <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if ls [ ls_abs_argsort [ i ] ] >= 0 : <NEWLINE> <INDENT> swap_pos = i <NEWLINE> pos1 = ls [ ls_abs_argsort [ i ] ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> swap_neg = None <NEWLINE> for i in range ( k ) [ : : - 1 ] : <NEWLINE> <INDENT> if ls [ ls_abs_argsort [ i ] ] < 0 : <NEWLINE> <INDENT> swap_neg = i <NEWLINE> neg1 = ls [ ls_abs_argsort [ i ] ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if swap_pos is not None and swap_neg is not None : <NEWLINE> <INDENT> p = 1 <NEWLINE> p *= ls [ ls_abs_argsort [ swap_pos ] ] <NEWLINE> p %= modulo <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if i == swap_neg : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = ls [ ls_abs_argsort [ i ] ] <NEWLINE> p *= x <NEWLINE> p %= modulo <NEWLINE> <DEDENT> opt1 = p <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> swap_pos = None <NEWLINE> for i in range ( k ) [ : : - 1 ] : <NEWLINE> <INDENT> if ls [ ls_abs_argsort [ i ] ] >= 0 : <NEWLINE> <INDENT> swap_pos = i <NEWLINE> pos2 = ls [ ls_abs_argsort [ i ] ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> swap_neg = None <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if ls [ ls_abs_argsort [ i ] ] < 0 : <NEWLINE> <INDENT> swap_neg = i <NEWLINE> neg2 = ls [ ls_abs_argsort [ i ] ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if swap_pos is not None and swap_neg is not None : <NEWLINE> <INDENT> p = 1 <NEWLINE> p *= ls [ ls_abs_argsort [ swap_neg ] ] <NEWLINE> p %= modulo <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if i == swap_pos : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = ls [ ls_abs_argsort [ i ] ] <NEWLINE> p *= x <NEWLINE> p %= modulo <NEWLINE> opt2 = p <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if opt1 is None : <NEWLINE> <INDENT> return opt2 <NEWLINE> <NL> <DEDENT> if opt2 is None : <NEWLINE> <INDENT> return opt1 <NEWLINE> <NL> <DEDENT> if pos1 * pos2 > neg1 * neg2 : <NEWLINE> <INDENT> return opt1 <NEWLINE> <NL> <DEDENT> return opt2 <NEWLINE> <NL> <NL> <DEDENT> def main ( istr , ostr ) : <NEWLINE> <INDENT> n , k = list ( map ( int , istr . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> ls = list ( map ( int , istr . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> result = solve ( ls , k ) <NEWLINE> print ( result , file = ostr ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> main ( sys . stdin , sys . stdout ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( Q ) ] <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> if ( K - Q ) > 0 : <NEWLINE> <INDENT> for _ in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = [ <STRING> ] * N <NEWLINE> for i , v in dict ( c ) . items ( ) : <NEWLINE> <INDENT> if v > ( Q - K ) : <NEWLINE> <INDENT> l [ i - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for j in l : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in range ( X + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : <NEWLINE> <INDENT> a = X + s * d <NEWLINE> if p . count ( a ) == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
s = str ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> l = [ 0 for i in range ( 2019 ) ] <NEWLINE> now = l [ int ( s [ n - 1 ] ) ] <NEWLINE> r = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> now = ( now + int ( s [ - i ] ) * r ) % 2019 <NEWLINE> l [ now ] += 1 <NEWLINE> r = r * 10 <NEWLINE> r = r % 2019 <NEWLINE> <DEDENT> ans += l [ 0 ] <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += int ( i * ( i - 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
from collections import deque <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> kitai = [ 0 ] * 1000 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> tmp += i + 1 <NEWLINE> kitai [ i ] = tmp / ( i + 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> total_kitai = [ 0 ] * ( n + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp += kitai [ p [ i ] - 1 ] <NEWLINE> total_kitai [ i + 1 ] = tmp <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( total_kitai [ i + k ] - total_kitai [ i ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> save = - 1 <NEWLINE> for i in range ( len ( divisors ) ) : <NEWLINE> <INDENT> if divisors [ i ] >= 200 : <NEWLINE> <INDENT> save = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if save > 0 : <NEWLINE> <INDENT> divisors = divisors [ : save ] <NEWLINE> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> def f ( a , b ) : <NEWLINE> <INDENT> return a ** 5 - b ** 5 <NEWLINE> <NL> <DEDENT> divs = make_divisors ( X ) <NEWLINE> ans = 0 <NEWLINE> for div in divs : <NEWLINE> <INDENT> a = - div - 120 <NEWLINE> b = - 120 <NEWLINE> while f ( a , b ) < X and a < 2 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> if f ( a , b ) == X : <NEWLINE> <INDENT> ans = ( a , b ) <NEWLINE> <DEDENT> a = - 120 <NEWLINE> b = - div - 120 <NEWLINE> while f ( a , b ) > X and b < 2 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> if f ( a , b ) == X : <NEWLINE> <INDENT> ans = ( a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
import collections <NEWLINE> import heapq <NEWLINE> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> <NL> <NL> def main ( K , N ) : <NEWLINE> <INDENT> P = 10 ** 9 + 7 <NEWLINE> <NL> P25 = [ 1 ] * ( K + 1 ) <NEWLINE> P26 = [ 1 ] * ( K + 1 ) <NEWLINE> F = [ 1 ] * ( N + K ) <NEWLINE> INV = [ 1 ] * ( N + K ) <NEWLINE> INVF = [ 1 ] * ( N + K ) <NEWLINE> <NL> p25 = 1 <NEWLINE> p26 = 1 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> p25 *= 25 <NEWLINE> p25 %= P <NEWLINE> P25 [ i ] = p25 <NEWLINE> <NL> p26 *= 26 <NEWLINE> p26 %= P <NEWLINE> P26 [ i ] = p26 <NEWLINE> <NL> <DEDENT> f = 1 <NEWLINE> invf = 1 <NEWLINE> for i in range ( 2 , N + K ) : <NEWLINE> <INDENT> f *= i <NEWLINE> f %= P <NEWLINE> F [ i ] = f <NEWLINE> q , r = divmod ( P , i ) <NEWLINE> INV [ i ] = - INV [ r ] * q % P <NEWLINE> invf *= INV [ i ] <NEWLINE> invf %= P <NEWLINE> INVF [ i ] = invf <NEWLINE> <NL> <DEDENT> def comb_rep ( n , r ) : <NEWLINE> <INDENT> return ( F [ n + r - 1 ] * INVF [ r ] % P ) * INVF [ n - 1 ] % P <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ret += ( <NEWLINE> <INDENT> P25 [ i ] * <NEWLINE> P26 [ K - i ] % P * <NEWLINE> comb_rep ( N , i ) % P <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return ( ret % P ) <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from my_module import main <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( main ( K , len ( S ) ) ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , list ( input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> padded = [ [ 0 for i in range ( W + 2 ) ] for j in range ( H + 2 ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> padded [ i + 1 ] [ j + 1 ] = s [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if padded [ i ] [ j ] == 1 : <NEWLINE> <INDENT> if padded [ i + 1 ] [ j ] == 0 and padded [ i - 1 ] [ j ] == 0 and padded [ i ] [ j + 1 ] == 0 and padded [ i ] [ j - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( <STRING> * w ) ) <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( ( <STRING> * w + <STRING> ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r ** 2 * math . pi , r * 2 * math . pi ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for l in range ( D ) ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> <NL> def score_down ( d ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> ans += c [ i ] * ( d - last [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for d in range ( D ) : <NEWLINE> <INDENT> score = [ ( s [ d ] [ i ] - score_down ( d + 1 ) ) for i in range ( 26 ) ] <NEWLINE> t = score . index ( max ( score ) ) <NEWLINE> print ( t + 1 ) <NEWLINE> last [ t ] = d + 1 <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> size = len ( S ) <NEWLINE> def palin ( S , size ) : <NEWLINE> <INDENT> for i in range ( size // 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ - 1 - i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> if palin ( S , size ) == True : <NEWLINE> <INDENT> L = S [ : size // 2 ] <NEWLINE> R = S [ size // 2 + 2 : ] <NEWLINE> if palin ( L , size // 2 ) & palin ( L , size // 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def f ( n ) : <NEWLINE> <INDENT> table = [ False , False ] + [ True for _ in range ( 2 , n + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while p ** 2 <= n : <NEWLINE> <INDENT> if table [ p ] : <NEWLINE> <INDENT> j = p + p <NEWLINE> while j <= n : <NEWLINE> <INDENT> table [ j ] = False <NEWLINE> j += p <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> <DEDENT> return sum ( table ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( f ( n ) ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dp [ a - 1 ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> s = int ( input ( ) . rstrip ( ) ) <NEWLINE> A [ s - 1 ] += 1 <NEWLINE> <DEDENT> for k in A : <NEWLINE> <INDENT> if K - ( Q - k ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from itertools import accumulate <NEWLINE> AS = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> BS = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if AS [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while AS [ i ] + BS [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> chohuku = 0 <NEWLINE> double = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , min ( i + 1 , n - i ) ) : <NEWLINE> <INDENT> chohuku += 1 <NEWLINE> k = j + i <NEWLINE> l = i - j <NEWLINE> if s [ i ] != s [ k ] and s [ i ] != s [ l ] and s [ l ] != s [ k ] : <NEWLINE> <INDENT> double += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = r * g * b - double <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> nr = s . count ( <STRING> ) <NEWLINE> ng = s . count ( <STRING> ) <NEWLINE> nb = s . count ( <STRING> ) <NEWLINE> ans = nr * ng * nb <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n or k <= j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - cnt ) <NEWLINE>
<COMMENT> <NL> int ( input ( ) ) <NEWLINE> q = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( len ( q ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( q [ i ] , end = <STRING> ) <NEWLINE> if ( i == 0 ) : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> d = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> d += int ( n [ i ] ) <NEWLINE> <DEDENT> if d % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> abc = <STRING> <NEWLINE> <NL> def dfs ( keta , ns ) : <NEWLINE> <INDENT> global cnt <NEWLINE> if ns in s : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if cnt == k : <NEWLINE> <INDENT> print ( ns ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if keta == k : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for i in abc : <NEWLINE> <INDENT> dfs ( keta + 1 , ns + i ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in abc : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( 1 , i ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ 0 ] * M <NEWLINE> R = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> print ( max ( min ( R ) - max ( L ) + 1 , 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n_R = S . count ( <STRING> ) <NEWLINE> n_G = S . count ( <STRING> ) <NEWLINE> n_B = S . count ( <STRING> ) <NEWLINE> ans = n_R * n_G * n_B <NEWLINE> <NL> for b in range ( 1 , N // 2 + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for a in range ( N - 2 * b ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = a <NEWLINE> j = a + b <NEWLINE> k = a + 2 * b <NEWLINE> <NL> if k > N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> change_pair = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> change_pair . append ( ( b , c ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> counts = { } <NEWLINE> total = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in counts : <NEWLINE> <INDENT> counts [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counts [ a ] = 1 <NEWLINE> <DEDENT> total += a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for b , c in change_pair : <NEWLINE> <INDENT> if b in counts : <NEWLINE> <INDENT> count = counts [ b ] <NEWLINE> counts [ b ] = 0 <NEWLINE> total -= b * count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if c in counts : <NEWLINE> <INDENT> counts [ c ] += count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counts [ c ] = count <NEWLINE> <DEDENT> total += c * count <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x % y == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> cnt = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if ( x * cnt ) % y != 0 : <NEWLINE> <INDENT> ans = x * cnt <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AA = { } <NEWLINE> t = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> t += a <NEWLINE> if a in AA : <NEWLINE> <INDENT> AA [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AA [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if b in AA : <NEWLINE> <INDENT> if c not in AA : <NEWLINE> <INDENT> AA [ c ] = 0 <NEWLINE> <DEDENT> AA [ c ] += AA [ b ] <NEWLINE> t += ( c - b ) * AA [ b ] <NEWLINE> ans += [ t ] <NEWLINE> del AA [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += [ t ] <NEWLINE> <DEDENT> <DEDENT> [ print ( a ) for a in ans ] <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> def popcnt ( x ) : <NEWLINE> <INDENT> return bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> Xs = input ( ) <NEWLINE> X = int ( Xs , 2 ) <NEWLINE> d = popcnt ( X ) <NEWLINE> <NL> lut = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> Xi = i % popcnt ( i ) <NEWLINE> lut [ i ] = lut [ Xi ] + 1 <NEWLINE> <NL> <DEDENT> dp = d + 1 <NEWLINE> dm = d - 1 <NEWLINE> mp = X % dp <NEWLINE> mm = X % dm if dm else 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mask = 1 << ( N - i - 1 ) <NEWLINE> Xi = X ^ mask <NEWLINE> _ans = 0 <NEWLINE> if Xs [ i ] == <STRING> : <NEWLINE> <INDENT> if dm : <NEWLINE> <INDENT> m = ( mm - pow ( 2 , N - i - 1 , dm ) ) % dm <NEWLINE> _ans = lut [ m ] + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> m = ( mp + pow ( 2 , N - i - 1 , dp ) ) % dp <NEWLINE> _ans = lut [ m ] + 1 <NEWLINE> <DEDENT> ans . append ( _ans ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> memo = defaultdict ( defaultdict ) <NEWLINE> <NL> rg = range ( 1 , k + 1 ) <NEWLINE> for i in rg : <NEWLINE> <INDENT> for j in rg : <NEWLINE> <INDENT> memo [ i ] [ j ] = memo [ j ] [ i ] = gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for i in rg : <NEWLINE> <INDENT> for j in rg : <NEWLINE> <INDENT> tmp = memo [ i ] [ j ] <NEWLINE> for k in rg : <NEWLINE> <INDENT> res = memo [ k ] [ tmp ] <NEWLINE> ret += res <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> def main ( ) : <NEWLINE> <INDENT> def push ( i , j , k ) : <NEWLINE> <INDENT> nonlocal A , B , C , ADD <NEWLINE> if i >= x or j >= y or k >= z : return <NEWLINE> if ( i , j , k ) not in ADD : <NEWLINE> <INDENT> heappush ( H , ( A [ i ] + B [ j ] + C [ k ] , i , j , k ) ) <NEWLINE> ADD . add ( ( i , j , k ) ) <NEWLINE> <DEDENT> <DEDENT> x , y , z , k = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 11 <NEWLINE> A = sorted ( list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) ) <NEWLINE> H = [ ] <NEWLINE> ADD = set ( ) <NEWLINE> push ( 0 , 0 , 0 ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> ans , i , j , k = heappop ( H ) <NEWLINE> push ( i + 1 , j , k ) <NEWLINE> push ( i , j + 1 , k ) <NEWLINE> push ( i , j , k + 1 ) <NEWLINE> print ( - ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pp = list ( map ( lambda x : ( x + 1 ) / 2 , p ) ) <NEWLINE> <NL> p_rui = [ pp [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p_rui . append ( p_rui [ i - 1 ] + pp [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> walist = [ p_rui [ k - 1 ] ] <NEWLINE> for i in range ( 0 , n - k ) : <NEWLINE> <INDENT> walist += [ p_rui [ k + i ] - p_rui [ i ] ] <NEWLINE> <NL> <DEDENT> print ( max ( walist ) ) <NEWLINE> <NL> <NL>
import numpy as np <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . cumsum ( a ) <NEWLINE> b = np . cumsum ( b ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a_num , time in enumerate ( a ) : <NEWLINE> <INDENT> if time > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b_num = bisect_right ( b , k - time ) <NEWLINE> num = a_num + b_num - 1 <NEWLINE> if num > ans : <NEWLINE> <INDENT> ans = num <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n != 0 : <NEWLINE> <INDENT> s = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> origin_set = set ( range ( - 1 , 102 ) ) <NEWLINE> result_set = origin_set - s <NEWLINE> result_list = list ( result_set ) <NEWLINE> result_num = 1000 <NEWLINE> <NL> for i in result_list : <NEWLINE> <INDENT> if abs ( x - i ) < result_num : <NEWLINE> <INDENT> min_num = i <NEWLINE> result_num = abs ( x - i ) <NEWLINE> <DEDENT> elif abs ( x - i ) == result_num : <NEWLINE> <INDENT> if i < min_num : <NEWLINE> <INDENT> min_num = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> <NL> <DEDENT> queue = collections . deque ( [ 0 ] ) <NEWLINE> visited = [ 0 ] * N <NEWLINE> visited [ 0 ] = 1 <NEWLINE> while queue : <NEWLINE> <INDENT> x = queue . popleft ( ) <NEWLINE> for i in G [ x ] : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> visited [ i ] = x + 1 <NEWLINE> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * visited [ 1 : ] , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = a + b <NEWLINE> m = n // ab <NEWLINE> n %= ab <NEWLINE> print ( m * a + min ( n , a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> List = list ( input ( ) ) <NEWLINE> count = List . count ( <STRING> ) * List . count ( <STRING> ) * List . count ( <STRING> ) <NEWLINE> for w in range ( 1 , n // 3 * 3 + 1 ) : <NEWLINE> <INDENT> for s in range ( n - 2 * w ) : <NEWLINE> <INDENT> if List [ s ] != List [ s + w ] and List [ s ] != List [ s + w * 2 ] and List [ s + w ] != List [ s + w * 2 ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if 0 not in A : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> <STRING> <NEWLINE> import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> <NL> cnt = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cnt += math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> ans = collections . deque ( ns ( ) ) <NEWLINE> q = ni ( ) <NEWLINE> now = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query = ns ( ) . split ( <STRING> ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> now = 1 - now <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f , c = query [ 1 ] , query [ 2 ] <NEWLINE> if f == <STRING> : <NEWLINE> <INDENT> if now == 1 : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appendleft ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if now != 1 : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appendleft ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if now == 1 : <NEWLINE> <INDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ - ( i + 1 ) ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dp = [ [ 0 , 0 , 0 ] for i in range ( N - 1 ) ] <NEWLINE> dp [ 0 ] = [ 64 , 34 , 2 ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ 2 ] = dp [ i ] [ 1 ] + dp [ i ] [ 2 ] * 10 <NEWLINE> dp [ i + 1 ] [ 1 ] = dp [ i ] [ 0 ] * 2 + dp [ i ] [ 1 ] * 9 <NEWLINE> dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] * 8 <NEWLINE> dp [ i + 1 ] [ 2 ] %= mod <NEWLINE> dp [ i + 1 ] [ 1 ] %= mod <NEWLINE> dp [ i + 1 ] [ 0 ] %= mod <NEWLINE> <DEDENT> print ( dp [ - 1 ] [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> counted = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> counted += ( n - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( counted ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> WW = [ 0 ] * ( W + 1 ) <NEWLINE> WW [ 0 ] = 1 <NEWLINE> WW [ 1 ] = 1 <NEWLINE> for i in range ( 2 , W + 1 ) : <NEWLINE> <INDENT> WW [ i ] = WW [ i - 1 ] + WW [ i - 2 ] <NEWLINE> <DEDENT> DP = [ [ 0 ] * W for i in range ( H + 1 ) ] <NEWLINE> DP [ 0 ] [ 0 ] = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> DP [ i ] [ j ] = DP [ i - 1 ] [ j ] * WW [ W - 1 ] <NEWLINE> if W > 1 : <NEWLINE> <INDENT> DP [ i ] [ j ] += DP [ i - 1 ] [ j + 1 ] * WW [ W - 2 ] <NEWLINE> <DEDENT> <DEDENT> elif j == W - 1 : <NEWLINE> <INDENT> DP [ i ] [ j ] = DP [ i - 1 ] [ j ] * WW [ W - 1 ] <NEWLINE> if W > 1 : <NEWLINE> <INDENT> DP [ i ] [ j ] += DP [ i - 1 ] [ j - 1 ] * WW [ W - 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> DP [ i ] [ j ] = DP [ i - 1 ] [ j ] * WW [ j ] * WW [ W - 1 - j ] + DP [ i - 1 ] [ j - 1 ] * WW [ j - 1 ] * WW [ W - 1 - j ] + DP [ i - 1 ] [ j + 1 ] * WW [ j ] * WW [ W - 2 - j ] <NEWLINE> <NL> <DEDENT> DP [ i ] [ j ] %= mod <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( DP [ - 1 ] [ K - 1 ] ) <NEWLINE>
import networkx as nx <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> g = nx . Graph ( ) <NEWLINE> g . add_nodes_from ( [ i for i in range ( 1 , n + 1 ) ] ) <NEWLINE> <NL> for x in s : <NEWLINE> <INDENT> g . add_edge ( x [ 0 ] , x [ 1 ] ) <NEWLINE> <DEDENT> di = nx . predecessor ( g , source = 1 ) <NEWLINE> <NL> if len ( di ) != n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( di [ x ] [ 0 ] ) <NEWLINE> <DEDENT>
def twos ( m ) : <NEWLINE> <INDENT> rt = 0 <NEWLINE> while m % 2 == 0 : <NEWLINE> <INDENT> m //= 2 <NEWLINE> rt += 1 <NEWLINE> <DEDENT> return rt <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> ans += twos ( j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from itertools import product <NEWLINE> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xyz = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for a , b , c in product ( [ 1 , - 1 ] , repeat = 3 ) : <NEWLINE> <INDENT> total = [ ] <NEWLINE> for x , y , z in xyz : <NEWLINE> <INDENT> s = x * a + y * b + z * c <NEWLINE> total . append ( s ) <NEWLINE> <DEDENT> total . sort ( reverse = True ) <NEWLINE> ans = max ( ans , sum ( total [ : m ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> L = [ 0 ] * 100001 <NEWLINE> for item in An : <NEWLINE> <INDENT> L [ item ] += 1 <NEWLINE> <NL> <DEDENT> sum = sum ( An ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum += ( c - b ) * L [ b ] <NEWLINE> L [ c ] += L [ b ] <NEWLINE> L [ b ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> list_ = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> num = 1 <NEWLINE> seed = [ [ i ] for i in range ( 1 , m + 1 ) ] <NEWLINE> while num != n : <NEWLINE> <INDENT> num += 1 <NEWLINE> tmp_list = [ ] <NEWLINE> while seed : <NEWLINE> <INDENT> tmp = seed . pop ( ) <NEWLINE> for i in range ( tmp [ - 1 ] , m + 1 ) : <NEWLINE> <INDENT> tmp_list . append ( tmp + [ i ] ) <NEWLINE> <DEDENT> <DEDENT> seed = tmp_list . copy ( ) <NEWLINE> <NL> <DEDENT> max_score = 0 <NEWLINE> visited = set ( ) <NEWLINE> for arr in seed : <NEWLINE> <INDENT> score = 0 <NEWLINE> for arr_2 in list_ : <NEWLINE> <INDENT> if arr [ arr_2 [ 1 ] - 1 ] - arr [ arr_2 [ 0 ] - 1 ] == arr_2 [ 2 ] : <NEWLINE> <INDENT> score += arr_2 [ 3 ] <NEWLINE> max_score = max ( max_score , score ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_score ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> s = int ( x / d ) <NEWLINE> ans = x % d <NEWLINE> <NL> if k < s : <NEWLINE> <INDENT> print ( x - d * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans < - ans + d : <NEWLINE> <INDENT> if ( k - s ) % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - ans + d ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( k - s ) % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - ans + d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = [ input ( ) for _ in range ( 3 ) ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> S [ i ] = list ( S [ i ] ) <NEWLINE> <DEDENT> p = 0 <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> if not S [ 0 ] and p == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if not S [ 1 ] and p == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if not S [ 2 ] and p == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> p_t = S [ p ] . pop ( 0 ) <NEWLINE> if p_t == <STRING> : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> elif p_t == <STRING> : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> elif p_t == <STRING> : <NEWLINE> <INDENT> p = 2 <NEWLINE> <DEDENT> <DEDENT>
x , y , z , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> <NL> <NL> ans = [ ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> for j in range ( y ) : <NEWLINE> <INDENT> if i * j > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( z ) : <NEWLINE> <INDENT> if i * j * k > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( a [ i ] + b [ j ] + c [ k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = sorted ( ans ) [ : : - 1 ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr , reverse = True , key = lambda x : abs ( x ) ) <NEWLINE> if k == n : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 1 and max ( arr ) < 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= arr [ n - 1 - i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if arr [ i ] < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_plus = - 1 <NEWLINE> min_minus = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if arr [ i ] >= 0 : <NEWLINE> <INDENT> min_plus = arr [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_minus = arr [ i ] <NEWLINE> <DEDENT> <DEDENT> max_plus = - 1 <NEWLINE> max_minus = 1 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if arr [ i ] >= 0 and max_plus == - 1 : <NEWLINE> <INDENT> max_plus = arr [ i ] <NEWLINE> <DEDENT> if arr [ i ] < 0 and max_minus == 1 : <NEWLINE> <INDENT> max_minus = arr [ i ] <NEWLINE> <DEDENT> <DEDENT> if min_plus == - 1 : <NEWLINE> <INDENT> arr . remove ( min_minus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_plus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> elif min_minus == 1 : <NEWLINE> <INDENT> arr . remove ( min_plus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_minus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> elif min_plus * max_plus >= min_minus * max_minus : <NEWLINE> <INDENT> arr . remove ( min_minus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_plus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . remove ( min_plus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_minus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for j in range ( m ) ] <NEWLINE> c = [ [ sum ( ak * bk for ak , bk in zip ( ai , bj ) ) for bj in zip ( * b ) ] for ai in a ] <NEWLINE> <NL> for ci in c : <NEWLINE> <INDENT> print ( * ci ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import datetime <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( input ( ) ) <NEWLINE> <DEDENT> arr . sort ( ) <NEWLINE> print ( <STRING> . join ( arr ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 ) == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x , y ) == ( 0 , 0 ) : break <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> print ( <STRING> * y ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def c ( x ) : <NEWLINE> <INDENT> return x * ( x + 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * c ( n // i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> from numba import jit <NEWLINE> <NL> @ jit <NEWLINE> def imos ( x ) : <NEWLINE> <INDENT> global N <NEWLINE> B = np . zeros_like ( x ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p = x [ i ] <NEWLINE> L = max ( i - p , 0 ) <NEWLINE> R = min ( i + p , N - 1 ) <NEWLINE> B [ L ] += 1 <NEWLINE> if R < N - 1 : <NEWLINE> <INDENT> B [ R + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> if i >= 50 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = imos ( A ) <NEWLINE> <NL> <DEDENT> print ( * A ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> <NL> if ( len ( S ) <= K ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> * 3 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> <NL> b1 = [ i [ 0 ] for i in c . items ( ) if i [ 1 ] >= 4 ] <NEWLINE> b2 = [ i [ 0 ] for i in c . items ( ) if i [ 1 ] >= 2 ] <NEWLINE> b = b1 + b2 + [ 0 , 0 ] <NEWLINE> <NL> b . sort ( ) <NEWLINE> print ( b [ - 1 ] * b [ - 2 ] ) <NEWLINE>
<COMMENT> <NL> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> list = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> par = [ - 1 ] * n <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> unite ( i [ 0 ] - 1 , i [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> max = 0 <NEWLINE> <NL> for i in range ( len ( par ) ) : <NEWLINE> <INDENT> if max < size ( i ) : <NEWLINE> <INDENT> max = size ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
from functools import reduce <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def operate ( dq , op ) : <NEWLINE> <INDENT> if op [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( int ( op [ 7 : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = op [ 6 ] <NEWLINE> if k == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> elif k == <STRING> : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dq . remove ( int ( op [ 7 : ] ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dq <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( * reduce ( operate , [ input ( ) for _ in range ( n ) ] , deque ( ) ) ) <NEWLINE>
import numpy as np <NEWLINE> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( A >= K ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( A + B >= K ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - ( A + B ) ) ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a , b = [ ] , [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> if c % 10 == 0 : <NEWLINE> <INDENT> a . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( c ) <NEWLINE> <DEDENT> <DEDENT> if len ( b ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( a ) <NEWLINE> val = 0 <NEWLINE> for i in reversed ( range ( 1 , 1 + len ( b ) ) ) : <NEWLINE> <INDENT> for j in combinations ( b , i ) : <NEWLINE> <INDENT> val0 = sum ( j ) <NEWLINE> if val0 % 10 != 0 : <NEWLINE> <INDENT> val = max ( val0 , val ) <NEWLINE> <DEDENT> <DEDENT> if val != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if val == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( val + ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> move_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> test = 1 <NEWLINE> find_f = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> find_f [ i + 1 ] = [ ] <NEWLINE> <NL> <DEDENT> find_f [ 1 ] . append ( 0 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> test = move_list [ test - 1 ] <NEWLINE> find_f [ test ] . append ( i + 1 ) <NEWLINE> if len ( find_f [ test ] ) == 2 and find_f [ test ] [ 1 ] - find_f [ test ] [ 0 ] <= 1000000 : <NEWLINE> <INDENT> state , f = test , find_f [ test ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> K = K - f [ 0 ] <NEWLINE> f = f [ 1 ] - f [ 0 ] <NEWLINE> remain = K % f <NEWLINE> for i in range ( remain ) : <NEWLINE> <INDENT> state = move_list [ state - 1 ] <NEWLINE> <NL> <DEDENT> print ( state ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( test ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
seconds = int ( input ( ) ) <NEWLINE> <NL> h = int ( seconds / 3600 ) <NEWLINE> m = int ( ( seconds - h * 3600 ) / 60 ) <NEWLINE> s = seconds - h * 3600 - m * 60 <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE> <NL>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SUM = 0 <NEWLINE> jsum = 0 <NEWLINE> MOD = 1000000007 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> jsum = ( jsum + A [ j ] ) % MOD <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> jsum = ( jsum - A [ i ] ) % MOD <NEWLINE> SUM = ( SUM + ( jsum * A [ i ] % MOD ) ) % MOD <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( SUM ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = a + b <NEWLINE> d = n % c <NEWLINE> e = n // c <NEWLINE> <NL> if d <= a : <NEWLINE> <INDENT> print ( e * a + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( e + 1 ) * a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B - 1 : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) / B ) - A * int ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * N / B ) - A * int ( N / B ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cou = 0 <NEWLINE> <NL> if a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif a >= 0 and b <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cou = abs ( b - a ) + 1 <NEWLINE> if cou % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> r = range ( 1 , k + 1 ) <NEWLINE> ans = sum ( [ gcd ( gcd ( a , b ) , c ) for a in r for b in r for c in r ] ) <NEWLINE> print ( ans ) <NEWLINE>
from bisect import bisect_right <NEWLINE> from time import time <NEWLINE> <NL> N , M , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> a_book = [ 0 ] <NEWLINE> for index , i in enumerate ( input ( ) . split ( ) , 1 ) : <NEWLINE> <INDENT> if a_book [ index - 1 ] + int ( i ) <= K : <NEWLINE> <INDENT> a_book . append ( a_book [ index - 1 ] + int ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = index - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> b_book = [ 0 ] <NEWLINE> for index , i in enumerate ( input ( ) . split ( ) , 1 ) : <NEWLINE> <INDENT> if b_book [ index - 1 ] + int ( i ) <= K : <NEWLINE> <INDENT> b_book . append ( b_book [ index - 1 ] + int ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = index - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> check = { } <NEWLINE> <NL> max_books = 0 <NEWLINE> <NL> for i , a in enumerate ( a_book ) : <NEWLINE> <INDENT> b_pos = bisect_right ( b_book , K - a ) <NEWLINE> <NL> if max_books < b_pos - 1 + i : <NEWLINE> <INDENT> max_books = b_pos - 1 + i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_books ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from heapq import * <NEWLINE> import fractions <NEWLINE> from collections import defaultdict <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = nl ( ) <NEWLINE> A . sort ( ) <NEWLINE> A_MAX = 10 ** 6 + 5 <NEWLINE> p_l = [ 0 ] * ( A_MAX ) <NEWLINE> c = 0 <NEWLINE> if ( len ( A ) == 1 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if ( p_l [ A [ i ] ] != 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( A [ i ] , A_MAX , A [ i ] ) : <NEWLINE> <INDENT> if ( p_l [ k ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> p_l [ k ] = 1 <NEWLINE> <DEDENT> if ( i < ( len ( A ) - 1 ) and A [ i ] == A [ i + 1 ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( c ) <NEWLINE> <NL> <NL> <NL>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> T = S ( ) <NEWLINE> <NL> revT = reversed ( T ) <NEWLINE> <NL> n , d , mods = 0 , 1 , [ 1 ] + [ 0 ] * 2019 <NEWLINE> <NL> for i in revT : <NEWLINE> <INDENT> n = ( n + int ( i ) * d ) % 2019 <NEWLINE> d = d * 10 % 2019 <NEWLINE> mods [ n ] += 1 <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for j in mods : <NEWLINE> <INDENT> sum += j * ( j - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p1 = n // 2 <NEWLINE> p2 = n // 2 - 1 <NEWLINE> ans = copy . copy ( l ) <NEWLINE> ans . sort ( ) <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> if i >= ans [ p1 ] : <NEWLINE> <INDENT> print ( ans [ p2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ p1 ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( k , s ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> l = s - i - j <NEWLINE> if 0 <= l <= k : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> print ( solve ( K , S ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) . split ( ) <NEWLINE> N = sorted ( N ) <NEWLINE> a = int ( N [ 0 ] ) <NEWLINE> b = int ( N [ 1 ] ) <NEWLINE> c = int ( N [ 2 ] ) <NEWLINE> print ( a , end = <STRING> ) <NEWLINE> print ( b , end = <STRING> ) <NEWLINE> print ( c ) <NEWLINE>
<COMMENT> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> idouA = 0 <NEWLINE> idouB = 0 <NEWLINE> kankaku = 0 <NEWLINE> <NL> <COMMENT> <NL> if W >= V : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idouA = V * T <NEWLINE> idouB = W * T <NEWLINE> if A < B : <NEWLINE> <INDENT> if A < 0 and B < 0 : <NEWLINE> <INDENT> kankaku = abs ( A ) - abs ( B ) <NEWLINE> <DEDENT> elif A >= 0 and B >= 0 : <NEWLINE> <INDENT> kankaku = abs ( B ) - abs ( A ) <NEWLINE> <DEDENT> elif A <= 0 and B >= 0 : <NEWLINE> <INDENT> kankaku = B - A <NEWLINE> <DEDENT> <DEDENT> elif B < A : <NEWLINE> <INDENT> if A < 0 and B < 0 : <NEWLINE> <INDENT> kankaku = abs ( B ) - abs ( A ) <NEWLINE> <DEDENT> elif A >= 0 and B >= 0 : <NEWLINE> <INDENT> kankaku = abs ( A ) - abs ( B ) <NEWLINE> <DEDENT> elif A >= 0 and B <= 0 : <NEWLINE> <INDENT> kankaku = A - B <NEWLINE> <NL> <DEDENT> <DEDENT> if ( idouB + kankaku <= idouA ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> tempList = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = tempList [ 0 ] <NEWLINE> b = tempList [ 1 ] <NEWLINE> hour = tempList [ 2 ] <NEWLINE> minute = tempList [ 3 ] <NEWLINE> time = hour * 60 + minute <NEWLINE> mypi = math . pi <NEWLINE> hourAngle = time / ( 12 * 60 ) <NEWLINE> minuteAngle = minute / 60 <NEWLINE> diff = abs ( hourAngle - minuteAngle ) <NEWLINE> if diff > 0.5 : <NEWLINE> <INDENT> diff = 1 - diff <NEWLINE> <DEDENT> angle = diff * mypi * 2 <NEWLINE> result = a * a + b * b - 2 * a * b * math . cos ( angle ) <NEWLINE> print ( math . sqrt ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> set_a = set ( make_divisors ( A ) ) <NEWLINE> set_b = set ( make_divisors ( B ) ) <NEWLINE> set_ab = set_a . intersection ( set_b ) <NEWLINE> <NL> list_ab = list ( set_ab ) <NEWLINE> list_ab . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> print ( list_ab [ - K ] ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> gcds = sum ( [ gcd ( gcd ( x [ 0 ] , x [ 1 ] ) , x [ 2 ] ) for x in itertools . product ( range ( 1 , K + 1 ) , range ( 1 , K + 1 ) , range ( 1 , K + 1 ) ) ] ) <NEWLINE> print ( gcds ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> <NL> <NL> _MOD = { 0 : 1 } <NEWLINE> amari = 0 <NEWLINE> a = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> amari = ( amari + int ( i ) * a ) % 2019 <NEWLINE> a = ( a * 10 ) % 2019 <COMMENT> <NEWLINE> if amari in _MOD : <NEWLINE> <INDENT> _MOD [ amari ] = _MOD [ amari ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _MOD [ amari ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for amari in _MOD : <NEWLINE> <INDENT> m = _MOD [ amari ] <NEWLINE> ans += ( m * ( m - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> len_c = len ( c ) <NEWLINE> total = 0 <NEWLINE> for num in b : <NEWLINE> <INDENT> idx_a = bisect_left ( a , num ) <NEWLINE> idx_c = bisect_right ( c , num ) <NEWLINE> cnt = idx_a * ( len_c - idx_c ) <NEWLINE> total += cnt <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> <NL> ans = A [ 0 ] <NEWLINE> <NL> count = 2 <NEWLINE> <NL> if count >= N : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> ans += A [ i ] <NEWLINE> <NL> if count >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count += 1 <NEWLINE> ans += A [ i ] <NEWLINE> <NL> if count >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> start = i <NEWLINE> n = N // i <NEWLINE> end = i * n <NEWLINE> ans += n * ( start + end ) // 2 <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> <NL> ans = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , ( N - 2 ) // 2 + 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * 2 <NEWLINE> <NL> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> ans += A [ ( N - 2 ) // 2 + 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if set ( S ) & set ( T ) != set ( T ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lt = len ( T ) <NEWLINE> ls = len ( S ) <NEWLINE> st = set ( T ) <NEWLINE> D = dict ( ) <NEWLINE> for t in st : <NEWLINE> <INDENT> D [ t ] = list ( ) <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if t == s : <NEWLINE> <INDENT> D [ t ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> pre = - 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def judge ( pre , t ) : <NEWLINE> <INDENT> X = D [ t ] <NEWLINE> index = bisect . bisect ( X , pre ) <NEWLINE> if len ( X ) == index : <NEWLINE> <INDENT> return ( X [ 0 ] , True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( X [ index ] , False ) <NEWLINE> <NL> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> J = judge ( pre , t ) <NEWLINE> pre = J [ 0 ] <NEWLINE> if J [ 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt * len ( S ) + pre + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> left = 1 <NEWLINE> right = n <NEWLINE> is_shift = False <NEWLINE> ans = [ ] <NEWLINE> while left < right : <NEWLINE> <INDENT> if right - left <= n // 2 and not is_shift and n % 2 == 0 : <NEWLINE> <INDENT> left += 1 <NEWLINE> is_shift = True <NEWLINE> <DEDENT> ans . append ( [ left , right ] ) <NEWLINE> left += 1 <NEWLINE> right -= 1 <NEWLINE> <NL> <DEDENT> for l in range ( m ) : <NEWLINE> <INDENT> print ( * ans [ l ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> amax = max ( a ) + 1 <NEWLINE> ah = [ 0 ] * amax <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> for j in range ( i , amax , i ) : <NEWLINE> <INDENT> ah [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> an = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ah [ i ] == 1 : <NEWLINE> <INDENT> an += 1 <NEWLINE> <DEDENT> <DEDENT> print ( an ) <NEWLINE>
N = input ( ) <NEWLINE> input = [ int ( input ( ) ) for i in range ( int ( N ) ) ] <NEWLINE> maxv = - 10000000000 <NEWLINE> minv = 10000000000 <NEWLINE> for i , x in enumerate ( input ) : <NEWLINE> <INDENT> maxv = max ( maxv , input [ i ] - minv ) <NEWLINE> minv = min ( minv , input [ i ] ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> <NL> def do_dfs ( root , add_duplicated = True ) : <NEWLINE> <INDENT> global edges , visited , duplicated <NEWLINE> <NL> def main ( i ) : <NEWLINE> <INDENT> visited [ i ] = True <NEWLINE> for edge in edges [ i ] : <NEWLINE> <INDENT> if visited [ edge ] : <NEWLINE> <INDENT> if edge == root : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if add_duplicated : <NEWLINE> <INDENT> duplicated . add ( edge ) <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> if main ( edge ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> return main ( root ) <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ set ( ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ s ] . add ( t ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * n <NEWLINE> duplicated = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> if do_dfs ( i ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in duplicated : <NEWLINE> <INDENT> visited = [ False ] * n <NEWLINE> if do_dfs ( i , False ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = n [ 0 ] <NEWLINE> b = n [ 1 ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif i == a - 1 : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for j in range ( b - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> a1 = raw_input ( ) <NEWLINE> a2 = raw_input ( ) <NEWLINE> a = len ( a1 ) <NEWLINE> b = len ( a2 ) <NEWLINE> c1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = a1 [ i ] <NEWLINE> c2 = c1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == a2 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i2 in range ( n ) : <NEWLINE> <INDENT> print solve ( ) <NEWLINE> <DEDENT>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** 0.5 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> cnt = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> root_n = math . ceil ( math . sqrt ( n ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> count = 0 <NEWLINE> <NL> for x in range ( 1 , root_n ) : <NEWLINE> <INDENT> for y in range ( 1 , root_n ) : <NEWLINE> <INDENT> for z in range ( 1 , root_n ) : <NEWLINE> <INDENT> tmp = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if tmp < n + 1 : <NEWLINE> <INDENT> ans [ tmp - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> a = list ( ) <NEWLINE> b = 0 <NEWLINE> u = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ u ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( b ) <NEWLINE> b = 0 <NEWLINE> <DEDENT> u = u + 1 <NEWLINE> <DEDENT> a . append ( b ) <NEWLINE> a . sort ( ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( a [ 0 ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> s = input ( ) . strip ( ) <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if len ( s ) == 2 and s [ 0 ] == s [ 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> dp = [ [ 0 ] * 2 for _ in range ( len ( s ) ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> dp [ 0 ] [ 0 ] = dp [ 0 ] [ 1 ] = 1 <NEWLINE> <COMMENT> <NL> if s [ 0 ] == s [ 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] [ 0 ] = 2 <NEWLINE> dp [ 1 ] [ 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 2 , len ( s ) ) : <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] + 1 , dp [ i - 1 ] [ 1 ] + 1 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if s [ i - 3 : i - 1 ] == s [ i - 1 : i + 1 ] : <NEWLINE> <INDENT> dp [ i ] [ 1 ] = dp [ i - 2 ] [ 0 ] + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ 1 ] = max ( dp [ i - 2 ] [ 0 ] + 1 , dp [ i - 2 ] [ 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp [ - 1 ] [ 0 ] , dp [ - 1 ] [ 1 ] ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def dfs ( prev , u ) : <NEWLINE> <INDENT> if visited [ u ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ u ] += cnt [ prev ] <NEWLINE> visited [ u ] = True <NEWLINE> for nu in graph [ u ] : <NEWLINE> <INDENT> if visited [ nu ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( u , nu ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p ] += x <NEWLINE> <NL> <DEDENT> visited = [ True ] + [ False ] * n <NEWLINE> <NL> dfs ( 0 , 1 ) <NEWLINE> <NL> print ( * cnt [ 1 : ] ) <NEWLINE>
<COMMENT> <NL> from decimal import Decimal <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> out = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> out = Decimal ( out * a [ i ] ) <NEWLINE> if out > Decimal ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
