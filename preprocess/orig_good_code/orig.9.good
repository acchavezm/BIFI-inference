a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from bisect import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> B = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> C = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> lst = [ N - bisect ( C , b ) for b in B ] <NEWLINE> lst = lst [ : : - 1 ] <NEWLINE> tmp_lst = [ lst [ 0 ] ] <NEWLINE> for i in lst [ 1 : ] : <NEWLINE> <INDENT> tmp_lst . append ( i + tmp_lst [ - 1 ] ) <NEWLINE> <DEDENT> tmp_lst = tmp_lst [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> res = bisect ( B , a ) <NEWLINE> ans += tmp_lst [ res ] if res < N else 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> a . append ( s ) <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> if s % 2 == 0 : <NEWLINE> <INDENT> s //= 2 <NEWLINE> if s in a : <NEWLINE> <INDENT> print ( i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = 3 * s + 1 <NEWLINE> if s in a : <NEWLINE> <INDENT> print ( i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pre = sum ( plist [ : K ] ) <NEWLINE> ans = pre <NEWLINE> for i in range ( 0 , N - K ) : <NEWLINE> <INDENT> pre = pre - plist [ i ] + plist [ i + K ] <NEWLINE> ans = max ( ans , pre ) <NEWLINE> <NL> <DEDENT> print ( ( ans + K ) / 2 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] *= ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def kaijou ( x ) : <NEWLINE> <INDENT> y = 1 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> y *= i <NEWLINE> y %= mod <NEWLINE> <DEDENT> return y <NEWLINE> <DEDENT> if abs ( n - m ) >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n == m : <NEWLINE> <INDENT> print ( ( kaijou ( n ) * kaijou ( m ) * 2 ) % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( kaijou ( n ) * kaijou ( m ) ) % mod ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M , * X = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> ans . append ( abs ( X [ i + 1 ] - X [ i ] ) ) <NEWLINE> <NL> <DEDENT> ans . sort ( reverse = True ) <NEWLINE> print ( X [ - 1 ] - X [ 0 ] - sum ( ans [ : N - 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t_all , a_all = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> t_all = t <NEWLINE> a_all = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t >= t_all and a >= a_all : <NEWLINE> <INDENT> t_all , a_all = t , a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff1 , diff2 = 0 , 0 <NEWLINE> diff1 = t_all // t if t_all % t == 0 else t_all // t + 1 <NEWLINE> diff2 = a_all // a if a_all % a == 0 else a_all // a + 1 <NEWLINE> max_diff = max ( diff1 , diff2 ) <NEWLINE> t_all = t * max_diff <NEWLINE> a_all = a * max_diff <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( t_all + a_all ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> scount , tcount , c = 0 , 0 , 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ c ] == <STRING> : <NEWLINE> <INDENT> scount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if scount > 0 : <NEWLINE> <INDENT> scount -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tcount += 1 <NEWLINE> <DEDENT> <DEDENT> c += 1 <NEWLINE> <DEDENT> print ( tcount * 2 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> def f ( a , b ) : <NEWLINE> <INDENT> return max ( len ( str ( a ) ) , len ( str ( b ) ) ) <NEWLINE> <DEDENT> m = 10000 <NEWLINE> for a in range ( 1 , 10 ** 10 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> m = min ( f ( a , n // a ) , m ) <NEWLINE> <DEDENT> if n < a or n // a < a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
ss = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in ss : <NEWLINE> <INDENT> j = i <NEWLINE> cnt = 0 <NEWLINE> while j < len ( s ) : <NEWLINE> <INDENT> if s [ j ] in ss : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> s_l = list ( map ( int , s ) ) <NEWLINE> <COMMENT> <NL> <NL> l = [ i for i in range ( 10 ) ] <NEWLINE> ans = 0 <NEWLINE> for v1 , v2 , v3 in itertools . product ( l , repeat = 3 ) : <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <INDENT> if not v1 in s_l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index1 = s_l . index ( v1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> s_l_1 = s_l [ index1 + 1 : ] <NEWLINE> <NL> if not v2 in s_l_1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index2 = s_l_1 . index ( v2 ) <NEWLINE> <NL> <DEDENT> s_l_2 = s_l_1 [ index2 + 1 : ] <NEWLINE> <NL> <NL> if not v3 in s_l_2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> ans = 2 * min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> LCM = reduce ( lcm , A ) % mod <NEWLINE> <NL> print ( sum ( [ LCM * pow ( A [ i ] , - 1 , mod ) % mod for i in range ( N ) ] ) % mod ) <NEWLINE>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = np . array ( [ 0 ] * n , dtype = <STRING> ) <NEWLINE> a [ 0 ] += n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> c = n // ( 1 + i ) <NEWLINE> d = n % ( 1 + i ) <NEWLINE> a [ 1 : i + 1 ] += c <NEWLINE> a [ 0 ] += c <NEWLINE> if d > 0 : <NEWLINE> <INDENT> a [ 1 : d + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( np . sum ( a [ k : ] ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> a [ i ] = sum ( a [ i : : i ] ) % 2 <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> def ok ( i ) : <NEWLINE> <INDENT> pin = <STRING> . format ( i ) <NEWLINE> j = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == pin [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> if j == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> ans += ok ( i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ ] ) ; MOD = pow ( 10 , 9 ) + 7 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . add ( a - 1 ) <NEWLINE> <DEDENT> dp = [ [ 0 ] * 2 for _ in range ( N ) ] <COMMENT> <NEWLINE> if 0 not in A : <NEWLINE> <INDENT> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( sum ( dp [ 0 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 1 not in A : <NEWLINE> <INDENT> dp [ 1 ] [ 0 ] = dp [ 0 ] [ 0 ] + dp [ 0 ] [ 1 ] <NEWLINE> dp [ 1 ] [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i in A : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD <NEWLINE> dp [ i ] [ 1 ] = ( dp [ i - 2 ] [ 0 ] + dp [ i - 2 ] [ 1 ] ) % MOD <NEWLINE> <DEDENT> ans = sum ( dp [ N - 1 ] ) % MOD <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE>
import bisect <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> dic = { } <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] in dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if t [ i ] not in dic : <NEWLINE> <INDENT> dic [ t [ i ] ] = [ ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in dic : <NEWLINE> <INDENT> dic [ s [ i ] ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for k , v in dic . items ( ) : <NEWLINE> <INDENT> if v == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> n = - 1 <NEWLINE> k = 0 <NEWLINE> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> l = bisect . bisect_right ( dic [ t [ i ] ] , n ) <NEWLINE> if l < len ( dic [ t [ i ] ] ) : <NEWLINE> <INDENT> n = dic [ t [ i ] ] [ l ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = dic [ t [ i ] ] [ 0 ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) * k + n + 1 ) <NEWLINE>
import math <NEWLINE> <NL> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> def divisor ( x ) : <NEWLINE> <INDENT> divs = [ ] <NEWLINE> for i in range ( 1 , math . floor ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> divs . append ( i ) <NEWLINE> if i ** 2 != x : <NEWLINE> <INDENT> divs . append ( x // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divs <NEWLINE> <NL> <DEDENT> def evPrimal ( x ) : <NEWLINE> <INDENT> if x < 4 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> divs = [ ] <NEWLINE> for i in range ( 2 , math . floor ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> codiv = set ( divisor ( A ) ) & set ( divisor ( B ) ) <NEWLINE> <NL> for i in codiv : <NEWLINE> <INDENT> if evPrimal ( i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = 2 * y - x <NEWLINE> b = 2 * x - y <NEWLINE> <NL> fac_l = [ 0 ] * ( int ( ( a + b ) / 3 ) + 1 ) <NEWLINE> inv_l = [ 0 ] * ( int ( ( a + b ) / 3 ) + 1 ) <NEWLINE> finv_l = [ 0 ] * ( int ( ( a + b ) / 3 ) + 1 ) <NEWLINE> <NL> <NL> def com_init ( ) : <NEWLINE> <INDENT> fac_l [ 1 ] = 1 <NEWLINE> inv_l [ 0 ] = 1 <NEWLINE> inv_l [ 1 ] = 1 <NEWLINE> finv_l [ 0 ] = 1 <NEWLINE> finv_l [ 1 ] = 1 <NEWLINE> for i in range ( 2 , a + b + 1 ) : <NEWLINE> <INDENT> fac_l [ i ] = ( fac_l [ i - 1 ] * i ) % MOD <NEWLINE> inv_l [ i ] = MOD - ( inv_l [ MOD % i ] * int ( MOD / i ) ) % MOD <NEWLINE> finv_l [ i ] = ( finv_l [ i - 1 ] * inv_l [ i ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> def ncr ( n , r ) : <NEWLINE> <INDENT> return ( fac_l [ n ] * ( finv_l [ r ] * finv_l [ n - r ] ) % MOD ) % MOD <NEWLINE> <NL> <NL> <DEDENT> if a % 3 != 0 or b % 3 != 0 or a < 0 or b < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( a / 3 ) <NEWLINE> b = int ( b / 3 ) <NEWLINE> <NL> com_init ( ) <NEWLINE> print ( ncr ( a + b , a ) ) <NEWLINE> <DEDENT>
x = list ( input ( ) ) <NEWLINE> first = 10 * int ( x [ 0 ] ) + int ( x [ 1 ] ) <NEWLINE> second = 10 * int ( x [ 2 ] ) + int ( x [ 3 ] ) <NEWLINE> <NL> <NL> def mc ( num ) : <NEWLINE> <INDENT> if 1 <= num <= 12 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def yc ( num ) : <NEWLINE> <INDENT> if 0 <= num <= 99 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if yc ( first ) : <NEWLINE> <INDENT> if mc ( second ) : <NEWLINE> <INDENT> if yc ( second ) : <NEWLINE> <INDENT> if mc ( first ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif yc ( second ) : <NEWLINE> <INDENT> if mc ( first ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif yc ( second ) : <NEWLINE> <INDENT> if mc ( first ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> A . sort ( ) <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> i , j = 0 , 0 <NEWLINE> <NL> while i < n and j < m : <NEWLINE> <INDENT> if A [ i ] >= bc [ j ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A [ i ] = bc [ j ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> bc [ j ] [ 0 ] -= 1 <NEWLINE> if bc [ j ] [ 0 ] == 0 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ikeru = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ikeru [ a - 1 ] . append ( ( b - 1 , i ) ) <NEWLINE> <NL> <DEDENT> settansaku = set ( [ ] ) <NEWLINE> setmada = { 0 } <NEWLINE> listmada = [ ( 0 , None ) ] <COMMENT> <NEWLINE> kouho = 1 <NEWLINE> num = [ 0 for _ in range ( n - 1 ) ] <NEWLINE> <NL> while kouho != 0 : <NEWLINE> <INDENT> for i , cnt in listmada [ : ] : <NEWLINE> <INDENT> colors = { cnt } <NEWLINE> settansaku . add ( i ) <NEWLINE> setmada . remove ( i ) <NEWLINE> listmada . remove ( ( i , cnt ) ) <NEWLINE> kouho -= 1 <NEWLINE> c = 0 <NEWLINE> for k , j in ikeru [ i ] : <NEWLINE> <INDENT> if not k in setmada : <NEWLINE> <INDENT> if not k in settansaku : <NEWLINE> <INDENT> setmada . add ( k ) <NEWLINE> while True : <NEWLINE> <INDENT> if c not in colors : <NEWLINE> <INDENT> listmada . append ( ( k , c ) ) <NEWLINE> colors . add ( c ) <NEWLINE> num [ j ] = c <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> kouho += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( num ) + 1 ) <NEWLINE> print ( <STRING> . join ( [ str ( i + 1 ) for i in num ] ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n = 0 ) : <NEWLINE> <INDENT> self . d = [ - 1 ] * n <NEWLINE> self . g = set ( ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . d [ x ] < 0 : return x <NEWLINE> self . d [ x ] = self . find ( self . d [ x ] ) <NEWLINE> return self . d [ x ] <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : return False <NEWLINE> if self . d [ x ] > self . d [ y ] : x , y = y , x <NEWLINE> self . d [ x ] += self . d [ y ] <NEWLINE> self . g . add ( x ) <NEWLINE> if y in self . g : self . g . remove ( y ) <NEWLINE> self . d [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : return self . find ( x ) == self . find ( y ) <NEWLINE> def size ( self , x ) : return - self . d [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def comb2 ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> total = comb2 ( N ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> ans = [ total ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> a , b = E [ - i - 1 ] <NEWLINE> if uf . same ( a , b ) : <NEWLINE> <INDENT> ans . append ( ans [ - 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> size1 , size2 = uf . size ( a ) , uf . size ( b ) <NEWLINE> uf . unite ( a , b ) <NEWLINE> size3 = uf . size ( a ) <NEWLINE> tmp = ans [ - 1 ] + comb2 ( size1 ) + comb2 ( size2 ) - comb2 ( size3 ) <NEWLINE> ans . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans [ : : - 1 ] ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> if ( h == 1 ) & ( w == 1 ) : <NEWLINE> <INDENT> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ 0 ] [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( h == 1 ) & ( w != 1 ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> s [ 0 ] [ j ] = s [ 0 ] [ j ] . replace ( <STRING> , str ( s [ 0 ] [ j + 1 ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> s [ 0 ] [ j ] = s [ 0 ] [ j ] . replace ( <STRING> , str ( s [ 0 ] [ j - 1 ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ 0 ] [ j ] = s [ 0 ] [ j ] . replace ( <STRING> , str ( [ s [ 0 ] [ j - 1 ] , s [ 0 ] [ j + 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif ( h != 1 ) & ( w == 1 ) : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> s [ i ] [ 0 ] = s [ i ] [ 0 ] . replace ( <STRING> , str ( s [ i + 1 ] [ 0 ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> s [ i ] [ 0 ] = s [ i ] [ 0 ] . replace ( <STRING> , str ( s [ i - 1 ] [ 0 ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ 0 ] = s [ i ] [ 0 ] . replace ( <STRING> , str ( [ s [ i - 1 ] [ 0 ] , s [ i + 1 ] [ 0 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j + 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i ] [ j + 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] , s [ i + 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i == h - 1 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j + 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i ] [ j + 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] , s [ i - 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j + 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j - 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] [ j ] = s [ i ] [ j ] . replace ( <STRING> , str ( [ s [ i ] [ j - 1 ] , s [ i ] [ j + 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] , s [ i - 1 ] [ j - 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] , s [ i + 1 ] [ j - 1 ] ] . count ( <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k in s : <NEWLINE> <INDENT> print ( <STRING> . join ( k ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n_nodes ) : <NEWLINE> <INDENT> self . n_nodes = n_nodes <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> self . parent = [ i for i in range ( n_nodes ) ] <NEWLINE> <COMMENT> <NL> self . rank = [ 1 ] * n_nodes <NEWLINE> <COMMENT> <NL> self . size = [ 1 ] * n_nodes <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> self . parent [ x ] = self . find ( self . parent [ x ] ) <NEWLINE> return self . parent [ x ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <COMMENT> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> if self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> self . parent [ y ] = x <NEWLINE> self . size [ x ] += self . size [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = y <NEWLINE> self . size [ y ] += self . size [ x ] <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def check ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_size ( self , x ) : <NEWLINE> <INDENT> return self . size [ self . find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_parent_list ( self ) : <NEWLINE> <INDENT> return [ i for i in range ( self . n_nodes ) if self . find ( i ) == i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_n_groups ( self ) : <NEWLINE> <INDENT> return len ( self . get_parent_list ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_members ( self , x ) : <NEWLINE> <INDENT> parent = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n_nodes ) if self . find ( i ) == parent ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def get_members_dict ( self ) : <NEWLINE> <INDENT> return { par : self . get_members ( par ) for par in self . get_parent_list ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> UF = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> UF . unite ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = P [ i ] - 1 <NEWLINE> if UF . check ( i , a ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mn = float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] < mn : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> mn = min ( mn , p [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = tuple ( a ) <NEWLINE> a . sort ( ) <NEWLINE> for i in b : <NEWLINE> <INDENT> if i == a [ n - 1 ] : <NEWLINE> <INDENT> print ( a [ n - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ n - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> bc = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bc . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> for i in bc : <NEWLINE> <INDENT> if a [ 0 ] < i [ 1 ] : <NEWLINE> <INDENT> for j in range ( i [ 0 ] ) : <NEWLINE> <INDENT> if a [ 0 ] < i [ 1 ] : <NEWLINE> <INDENT> a . append ( i [ 1 ] ) <NEWLINE> del a [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> abs_min = 10 ** 9 <NEWLINE> A . remove ( maxA ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if abs_min > abs ( maxA / 2 - a ) : <NEWLINE> <INDENT> abs_min = abs ( maxA / 2 - a ) <NEWLINE> r = a <NEWLINE> <DEDENT> <DEDENT> print ( maxA , r ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> H = np . array ( list ( map ( int , readline ( ) . split ( ) ) ) , dtype = int ) <NEWLINE> <NL> dp = np . zeros ( N , dtype = int ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ max ( 0 , i - K ) : i ] + abs ( H [ max ( 0 , i - K ) : i ] - H [ i ] ) ) . min ( ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 ] * ( n ) <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : return x <NEWLINE> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> px , py = find ( x ) , find ( y ) <NEWLINE> if px == py : return False <NEWLINE> else : <NEWLINE> <INDENT> if px < py : px , py = py , px <NEWLINE> par [ px ] += par [ py ] <NEWLINE> par [ py ] = px <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gl = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( x - 1 , y - 1 ) <NEWLINE> <DEDENT> for c in range ( n ) : <COMMENT> <NEWLINE> <INDENT> ap = find ( c ) <NEWLINE> gl [ ap ] . append ( c ) <NEWLINE> <DEDENT> g = 0 <NEWLINE> for sg in gl : <NEWLINE> <INDENT> temp = [ p [ index ] - 1 for index in sg ] <NEWLINE> newset = set ( sg ) & set ( temp ) <NEWLINE> g += len ( newset ) <NEWLINE> <DEDENT> print ( g ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( max ( len ( set ( S [ : i ] ) & set ( S [ i : ] ) ) for i in range ( N ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ ( i + 1 ) * 100 , a , b ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 10 ** 10 <NEWLINE> if k < L [ - 1 ] [ 0 ] * L [ - 1 ] [ 1 ] : <NEWLINE> <INDENT> if k % L [ - 1 ] [ 0 ] != 0 : <NEWLINE> <INDENT> ans = ( k // L [ - 1 ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( k // L [ - 1 ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 << n ) : <NEWLINE> <INDENT> li = [ ] <NEWLINE> score , score_zan , cnt = 0 , 0 , 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> score += ( L [ j ] [ 0 ] * L [ j ] [ 1 ] + L [ j ] [ 2 ] ) <NEWLINE> cnt += L [ j ] [ 1 ] <NEWLINE> score_zan = k - score <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( L [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if score > 0 and score_zan <= 0 : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> li . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> if li and score_zan > 0 : <NEWLINE> <INDENT> if score_zan < li [ 0 ] [ 0 ] * li [ 0 ] [ 1 ] : <NEWLINE> <INDENT> ans = min ( ans , cnt + score_zan // li [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a = ( 2 * x - y ) // 3 <NEWLINE> b = ( 2 * y - x ) // 3 <NEWLINE> <NL> <NL> <NL> if a != ( 2 * x - y ) / 3 or b != ( 2 * y - x ) / 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a < 0 or b < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = a + b + 10 <NEWLINE> fac = [ 0 ] * max <NEWLINE> finv = [ 0 ] * max <NEWLINE> inv = [ 0 ] * max <NEWLINE> <NL> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , max ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <NL> <DEDENT> ans = fac [ a + b ] * ( finv [ a ] * finv [ b ] % mod ) % mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> self . dist = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return self . dist [ x ] , x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . find ( self . parents [ x ] ) <NEWLINE> self . dist [ x ] += tmp [ 0 ] <NEWLINE> self . parents [ x ] = tmp [ 1 ] <NEWLINE> return self . dist [ x ] , self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y , d ) : <NEWLINE> <INDENT> rx = self . find ( x ) [ 1 ] <NEWLINE> ry = self . find ( y ) [ 1 ] <NEWLINE> diff = self . dist [ y ] - self . dist [ x ] - d <NEWLINE> if rx == ry : <NEWLINE> <INDENT> if diff != 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if diff < 0 : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> diff = - diff <NEWLINE> <DEDENT> self . parents [ ry ] = min ( self . parents [ ry ] , self . parents [ rx ] - diff ) <NEWLINE> self . parents [ rx ] = ry <NEWLINE> self . dist [ rx ] = diff <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * lrd = map ( int , read ( ) . split ( ) ) <NEWLINE> v = Unionfind ( n ) <NEWLINE> for l , r , d in zip ( * [ iter ( lrd ) ] * 3 ) : <NEWLINE> <INDENT> if v . union ( l - 1 , r - 1 , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> plus . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( a ) <NEWLINE> <DEDENT> <DEDENT> ans = sum ( plus ) - sum ( minus ) <NEWLINE> if len ( minus ) % 2 == 1 : <NEWLINE> <INDENT> if plus == [ ] : <NEWLINE> <INDENT> ans = ans + 2 * max ( minus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans - 2 * min ( abs ( max ( minus ) ) , min ( plus ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B . append ( arr [ i ] - ( i + 1 ) ) <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> b1 = B [ n // 2 ] <NEWLINE> b2 = B [ n // 2 ] <NEWLINE> if n > 1 : <NEWLINE> <INDENT> b2 = B [ int ( ceil ( n / 2 ) ) ] <NEWLINE> <DEDENT> ans1 , ans2 = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans1 += abs ( arr [ i ] - ( b1 + i + 1 ) ) <NEWLINE> ans2 += abs ( arr [ i ] - ( b2 + i + 1 ) ) <NEWLINE> <DEDENT> print ( min ( ans1 , ans2 ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a - k >= 0 : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a + b ) > k : <NEWLINE> <INDENT> print ( 0 , b - ( k - a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> llist = [ ] <NEWLINE> rlist = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> llist += [ l ] <NEWLINE> rlist += [ r ] <NEWLINE> <NL> <DEDENT> print ( max ( 0 , min ( rlist ) - max ( llist ) + 1 ) ) <NEWLINE>
mod = 1000000007 <NEWLINE> from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 100000 ) <NEWLINE> <NL> <NL> def valid ( i , j , n , m ) : <NEWLINE> <INDENT> if 0 <= i < n and 0 <= j < m and good [ i ] [ j ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def solve ( i , j ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] [ j ] <NEWLINE> <DEDENT> if i == n - 1 and j == m - 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> sm = 0 <NEWLINE> if valid ( i + 1 , j , n , m ) : <NEWLINE> <INDENT> sm += solve ( i + 1 , j ) <NEWLINE> <DEDENT> if valid ( i , j + 1 , n , m ) : <NEWLINE> <INDENT> sm += solve ( i , j + 1 ) <NEWLINE> <DEDENT> dp [ i ] [ j ] = sm % mod <NEWLINE> return dp [ i ] [ j ] <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> good = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> good [ i ] . append ( True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> good [ i ] . append ( False ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dp = [ [ - 1 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> print ( solve ( 0 , 0 ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> PARTS = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> global PARTS2 <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> if judgeStr2 ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def judgeStr2 ( target : str ) -> bool : <NEWLINE> <INDENT> currentStr = target <NEWLINE> while currentStr != <STRING> : <NEWLINE> <INDENT> isNextOK = False <NEWLINE> for item in PARTS : <NEWLINE> <INDENT> if not currentStr . startswith ( item ) : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> tempStr = currentStr . replace ( item , <STRING> , 1 ) <NEWLINE> if tempStr == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> for item2 in PARTS : <NEWLINE> <INDENT> if tempStr . startswith ( item2 ) : <NEWLINE> <INDENT> isNextOK = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if isNextOK : <NEWLINE> <INDENT> currentStr = tempStr <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if isNextOK : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return currentStr == <STRING> <NEWLINE> <NL> <NL> <DEDENT> def judgeStr ( target : str ) -> bool : <NEWLINE> <INDENT> for item in PARTS : <NEWLINE> <INDENT> if target . startswith ( item ) : <NEWLINE> <INDENT> tempStr = target . replace ( item , <STRING> , 1 ) <NEWLINE> if tempStr == <STRING> or judgeStr ( tempStr ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> F = 11 <NEWLINE> <NL> for i in range ( 1 , int ( ( N + 1 ) ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> F = min ( F , max ( len ( str ( i ) ) , len ( str ( int ( N / i ) ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( F ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> <NL> s = input ( ) <NEWLINE> first = s . find ( <STRING> ) <NEWLINE> <NL> if first == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( first + 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - first <NEWLINE> first += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = Counter ( input ( ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s &= Counter ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( sorted ( s . elements ( ) ) ) ) <NEWLINE>
<NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ ] <NEWLINE> d = [ ( 1 , 0 ) , ( 0 , 1 ) ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> grid . append ( input ( ) ) <NEWLINE> <DEDENT> dp = [ [ 0 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> mod = 1e9 + 7 <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if h > 0 and grid [ h - 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> dp [ h ] [ w ] = ( dp [ h ] [ w ] + dp [ h - 1 ] [ w ] ) % mod <NEWLINE> <DEDENT> if w > 0 and grid [ h ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h ] [ w ] = ( dp [ h ] [ w ] + dp [ h ] [ w - 1 ] ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( dp [ H - 1 ] [ W - 1 ] ) ) <NEWLINE>
import itertools <COMMENT> <NEWLINE> import bisect <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> bo = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> bo . sort ( ) <NEWLINE> <NL> for a in range ( n - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> cnt += bisect . bisect_left ( bo , bo [ a ] + bo [ b ] ) - ( b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import functools <NEWLINE> def euclid ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return euclid ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def gcd ( nums ) : <NEWLINE> <INDENT> if len ( nums ) == 1 : <NEWLINE> <INDENT> return nums [ 0 ] <NEWLINE> <DEDENT> return functools . reduce ( euclid , nums ) <NEWLINE> <NL> <NL> <NL> <DEDENT> n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . append ( k ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> sa = [ ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sa . append ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( gcd ( sa ) ) <NEWLINE> <NL>
x = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( x + 105 + 1 ) <NEWLINE> dp [ 100 ] = 1 <NEWLINE> dp [ 101 ] = 1 <NEWLINE> dp [ 102 ] = 1 <NEWLINE> dp [ 103 ] = 1 <NEWLINE> dp [ 104 ] = 1 <NEWLINE> dp [ 105 ] = 1 <NEWLINE> <NL> for i in range ( 100 , x - 105 + 100 ) : <NEWLINE> <INDENT> for j in range ( 100 , 106 ) : <NEWLINE> <INDENT> dp [ i + j ] = max ( dp [ i ] , dp [ i + j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ x ] ) <NEWLINE>
s = input ( ) <NEWLINE> s_reverse = <STRING> . join ( list ( reversed ( s ) ) ) <NEWLINE> t = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = len ( t ) <NEWLINE> if s_reverse == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if len ( s ) <= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if s_reverse [ n ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> . join ( list ( reversed ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif s_reverse [ n ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> . join ( list ( reversed ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif s_reverse [ n : n + 3 ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> . join ( list ( reversed ( <STRING> ) ) ) <NEWLINE> <DEDENT> elif s_reverse [ n : n + 3 ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> . join ( list ( reversed ( <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> minlist = [ ] <NEWLINE> <NL> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> minlist . append ( p ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if p < minlist [ i - 1 ] : <NEWLINE> <INDENT> minlist . append ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minlist . append ( minlist [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> pj_min = minlist [ i ] <NEWLINE> if p <= pj_min : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> top = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , ( - 1 ) * ( - top // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> lcm = { } <NEWLINE> ps = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> p = 2 <NEWLINE> ps . append ( { } ) <NEWLINE> while p * p <= ai : <NEWLINE> <INDENT> if ai % p == 0 : <NEWLINE> <INDENT> ps [ i ] [ p ] = 0 <NEWLINE> while ai % p == 0 : <NEWLINE> <INDENT> ps [ i ] [ p ] += 1 <NEWLINE> ai //= p <NEWLINE> <DEDENT> lcm [ p ] = max ( lcm . get ( p , 0 ) , ps [ i ] [ p ] ) <NEWLINE> <DEDENT> p += 1 <NEWLINE> <DEDENT> if ai > 1 : <NEWLINE> <INDENT> ps [ i ] [ ai ] = 1 <NEWLINE> lcm [ ai ] = max ( lcm . get ( ai , 0 ) , ps [ i ] [ ai ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> lcmv = 1 <NEWLINE> for p in lcm : <NEWLINE> <INDENT> lcmv = ( lcmv * ( p ** lcm [ p ] ) ) % mod <NEWLINE> <NL> <DEDENT> def inv ( p , k ) : <NEWLINE> <INDENT> k = mod - k - 1 <NEWLINE> ret = 1 <NEWLINE> b = p <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ret = ( ret * b ) % mod <NEWLINE> <DEDENT> b = ( b * b ) % mod <NEWLINE> k //= 2 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> prod = lcmv <NEWLINE> for p in ps [ i ] : <NEWLINE> <INDENT> prod = ( prod * inv ( p , ps [ i ] [ p ] ) ) % mod <NEWLINE> <DEDENT> ret = ( ret + prod ) % mod <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE> <NL>
mod = 10 ** 9 + 7 <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> not_wet = [ True ] * ( n + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> not_wet [ a ] = False <NEWLINE> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not_wet [ i ] : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> <NL> def comb ( n , k ) : <NEWLINE> <INDENT> if k > n - k : <NEWLINE> <INDENT> k = n - k <NEWLINE> <DEDENT> de = 1 <NEWLINE> nu = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> de *= ( n - i ) <NEWLINE> de = de % MOD <NEWLINE> nu *= ( i + 1 ) <NEWLINE> nu = nu % MOD <NEWLINE> <DEDENT> nu = pow ( nu , - 1 , MOD ) <NEWLINE> return ( de * nu ) % MOD <NEWLINE> <NL> <DEDENT> def calc_from_step ( step ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for i in range ( 1 + ( step // 2 ) ) : <NEWLINE> <INDENT> temp += comb ( step - i , i ) <NEWLINE> <DEDENT> return temp <NEWLINE> <NL> <NL> <DEDENT> arr = [ 1 , 1 ] <NEWLINE> steps = [ ] <NEWLINE> step = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l = int ( input ( ) ) - 1 <NEWLINE> steps . append ( l - s ) <NEWLINE> if s > l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if step < l - s : <NEWLINE> <INDENT> step = l - s <NEWLINE> <DEDENT> s = l + 2 <NEWLINE> <DEDENT> l = N <NEWLINE> steps . append ( l - s ) <NEWLINE> if step < l - s : <NEWLINE> <INDENT> step = l - s <NEWLINE> <NL> <DEDENT> for i in range ( step - 1 ) : <NEWLINE> <INDENT> arr . append ( ( arr [ i ] + arr [ i + 1 ] ) % MOD ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> for i in steps : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans = ans % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> B [ A [ n ] - 1 ] = n + 1 <NEWLINE> <NL> <DEDENT> print ( * B ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> records = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> records . setdefault ( l , 0 ) <NEWLINE> records [ l ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for v in records . values ( ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += math . comb ( v , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> S = SS ( ) <NEWLINE> K = I ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> S_k = S [ K - 1 ] <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == S_k : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if s <= t : <NEWLINE> <INDENT> a . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if len ( a ) == 0 else min ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dic . setdefault ( a , 0 ) <NEWLINE> dic [ a ] += 1 <NEWLINE> if dic [ a ] == 2 : <NEWLINE> <INDENT> dic . pop ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( dic ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( b - a ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( b - a ) // 2 + min ( a - 1 , n - b ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = deque ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> total = sum ( a ) <NEWLINE> sm = 0 <NEWLINE> while len ( a ) > 1 : <NEWLINE> <INDENT> sm += a . pop ( ) <NEWLINE> ans = min ( abs ( 2 * sm - total ) , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , x = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> if x <= 0.5 * a * a * b : <NEWLINE> <INDENT> res = math . degrees ( math . atan ( 2 * x / ( a * b * b ) ) ) <NEWLINE> <DEDENT> elif x < a * a * b : <NEWLINE> <INDENT> res = math . degrees ( math . atan ( a / ( 2 * ( b - x / a ** 2 ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 90.0 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 10 ** 9 <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> t1 = abs ( X [ i ] ) + abs ( X [ i ] - X [ i + k - 1 ] ) <NEWLINE> t2 = abs ( X [ i + k - 1 ] ) + abs ( X [ i ] - X [ i + k - 1 ] ) <NEWLINE> t = min ( t1 , t2 ) <NEWLINE> <NL> ans = min ( ans , t ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( int ( p ** ( 1 / n ) + ( p > n ** 2 ) ) , 0 , - 1 ) : <NEWLINE> <INDENT> if p % i ** n == 0 : exit ( print ( i ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> mod = 998244353 <NEWLINE> <NL> def poly_mul ( f , g ) : <NEWLINE> <COMMENT> <NL> <INDENT> Lf = len ( f ) ; Lg = len ( g ) ; L = Lf + Lg - 1 <NEWLINE> if Lf <= 16 or Lg <= 16 : <NEWLINE> <INDENT> if Lf == 0 or Lg == 0 : <NEWLINE> <INDENT> return np . zeros ( ( 0 , ) , dtype = np . int64 ) <NEWLINE> <DEDENT> return ( np . convolve ( f . astype ( np . uint64 ) , g . astype ( np . uint64 ) ) % mod ) . astype ( np . int64 ) <NEWLINE> <DEDENT> fft = np . fft . rfft ; ifft = np . fft . irfft <NEWLINE> fft_len = 1 << L . bit_length ( ) <NEWLINE> fl = f & ( 1 << 15 ) - 1 ; fh = f >> 15 <NEWLINE> gl = g & ( 1 << 15 ) - 1 ; gh = g >> 15 <NEWLINE> x = ( ifft ( fft ( fl , fft_len ) * fft ( gl , fft_len ) ) [ : L ] + 0.5 ) . astype ( np . int64 ) % mod <NEWLINE> y = ( ifft ( fft ( fl + fh , fft_len ) * fft ( gl + gh , fft_len ) ) [ : L ] + 0.5 ) . astype ( np . int64 ) % mod <NEWLINE> z = ( ifft ( fft ( fh , fft_len ) * fft ( gh , fft_len ) ) [ : L ] + 0.5 ) . astype ( np . int64 ) % mod <NEWLINE> return ( x + ( ( y - x - z ) << 15 ) + ( z << 30 ) ) % mod <NEWLINE> <NL> <DEDENT> def poly_inv ( fps , n = None ) : <NEWLINE> <INDENT> assert fps [ 0 ] != 0 <NEWLINE> if n is None : <NEWLINE> <INDENT> n = len ( fps ) <NEWLINE> <DEDENT> res = np . zeros ( 1 << ( n - 1 ) . bit_length ( ) , dtype = np . int64 ) <NEWLINE> res [ 0 ] = pow ( int ( fps [ 0 ] ) , mod - 2 , mod ) <NEWLINE> i = 1 <NEWLINE> while i < n : <NEWLINE> <INDENT> i <<= 1 <NEWLINE> res [ : i ] = ( ( res [ : i ] << 1 ) - poly_mul ( poly_mul ( res [ : i >> 1 ] , res [ : i >> 1 ] ) , fps [ : i ] ) [ : i ] ) % mod <NEWLINE> <DEDENT> return res [ : n ] <NEWLINE> <NL> <DEDENT> def poly_div ( fps1 , fps2 ) : <NEWLINE> <INDENT> n1 , n2 = len ( fps1 ) , len ( fps2 ) <NEWLINE> if n1 < n2 : <NEWLINE> <INDENT> return np . zeros ( ( 0 , ) , dtype = np . int64 ) <NEWLINE> <DEDENT> n = n1 - n2 + 1 <NEWLINE> res = poly_mul ( fps1 [ - 1 : - n - 1 : - 1 ] , poly_inv ( fps2 [ : : - 1 ] , n ) ) [ n - 1 : : - 1 ] <NEWLINE> return res <NEWLINE> <NL> <DEDENT> def poly_mod ( fps1 , fps2 ) : <NEWLINE> <INDENT> n1 , n2 = len ( fps1 ) , len ( fps2 ) <NEWLINE> if n1 < n2 : <NEWLINE> <INDENT> return fps1 <NEWLINE> <DEDENT> res = fps1 [ : n2 - 1 ] - poly_mul ( poly_div ( fps1 , fps2 ) , fps2 ) [ : n2 - 1 ] <NEWLINE> return res % mod <NEWLINE> <NL> <DEDENT> def multipoint_evaluation ( fps , xs ) : <NEWLINE> <INDENT> threshold = 8 <NEWLINE> n_xs = len ( xs ) <NEWLINE> bit = ( n_xs - 1 ) . bit_length ( ) <NEWLINE> if bit <= threshold : <NEWLINE> <INDENT> res = np . zeros_like ( xs ) <NEWLINE> xs_cumprod = np . ones_like ( xs ) <NEWLINE> for coef in fps : <NEWLINE> <INDENT> res += xs_cumprod * coef <NEWLINE> xs_cumprod *= xs <NEWLINE> xs_cumprod %= mod <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> k = 1 << bit <NEWLINE> fpss = np . zeros ( ( bit + 1 , k + 1 ) , dtype = fps . dtype ) <NEWLINE> fpss [ 0 , : n_xs ] = - xs % mod <NEWLINE> fpss [ 1 , : k : 2 ] = fpss [ 0 , : k : 2 ] * fpss [ 0 , 1 : : 2 ] % mod <NEWLINE> fpss [ 1 , 1 : : 2 ] = ( fpss [ 0 , : k : 2 ] + fpss [ 0 , 1 : : 2 ] ) % mod <NEWLINE> for i in range ( 1 , bit ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , k , step ) : <NEWLINE> <INDENT> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : j + step + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> f = poly_mul ( f1 , f2 ) <NEWLINE> fpss [ i + 1 , j : j + step ] = f [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT> f = poly_mod ( fps , f ) <NEWLINE> fpss [ - 1 , : len ( f ) ] = f <NEWLINE> fpss [ - 1 , len ( f ) : ] = 0 <NEWLINE> for i in range ( bit - 1 , threshold - 1 , - 1 ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , k , step ) : <NEWLINE> <INDENT> f = fpss [ i + 1 , j : j + step ] <NEWLINE> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : j + step + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> fpss [ i , j : j + half ] = poly_mod ( f , f1 ) <NEWLINE> fpss [ i , j + half : j + step ] = poly_mod ( f , f2 ) <NEWLINE> <DEDENT> <DEDENT> xs = ( - fpss [ 0 , : k ] % mod ) . reshape ( - 1 , 1 << threshold ) <NEWLINE> xs_cumprod = np . ones_like ( xs ) <NEWLINE> res = np . zeros_like ( xs ) <NEWLINE> for i in range ( 1 << threshold ) : <NEWLINE> <INDENT> res += fpss [ threshold , i : k : 1 << threshold , None ] * xs_cumprod % mod <NEWLINE> xs_cumprod *= xs <NEWLINE> xs_cumprod %= mod <NEWLINE> <DEDENT> return res . reshape ( - 1 ) [ : n_xs ] % mod <NEWLINE> <NL> <DEDENT> def poly_differential ( fps ) : <NEWLINE> <INDENT> return fps [ 1 : ] * np . arange ( 1 , len ( fps ) ) % mod <NEWLINE> <NL> <DEDENT> def lagrange_interpolation ( X , Y , mod ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = len ( X ) <NEWLINE> g = [ 0 ] * ( n + 1 ) <NEWLINE> g [ 0 ] = 1 <NEWLINE> for i , x in enumerate ( X ) : <NEWLINE> <INDENT> for j in range ( i , - 1 , - 1 ) : <NEWLINE> <INDENT> g [ j + 1 ] += g [ j ] * ( - x ) % mod <NEWLINE> <DEDENT> <DEDENT> res = [ 0 ] * n <NEWLINE> for x , y in zip ( X , Y ) : <NEWLINE> <INDENT> f = g [ : ] <NEWLINE> denom = 0 <NEWLINE> v = 1 <NEWLINE> pow_x = [ 1 ] <COMMENT> <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> v = v * x % mod <NEWLINE> pow_x . append ( v ) <NEWLINE> <DEDENT> pow_x . reverse ( ) <COMMENT> <NEWLINE> for i , po in enumerate ( pow_x ) : <NEWLINE> <INDENT> f_i = f [ i ] <NEWLINE> f [ i + 1 ] += f_i * x % mod <COMMENT> <NEWLINE> denom = ( denom + f_i * po ) % mod <NEWLINE> <DEDENT> denom_inv = pow ( denom , mod - 2 , mod ) <NEWLINE> for i , f_i in enumerate ( f [ : n ] ) : <NEWLINE> <INDENT> res [ i ] += ( f_i * y * denom_inv ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return [ v % mod for v in res ] <NEWLINE> <NL> <DEDENT> def polynomial_interpolation ( xs , ys ) : <NEWLINE> <COMMENT> <NL> <INDENT> assert len ( xs ) == len ( ys ) <NEWLINE> threshold = 8 <NEWLINE> as_strided = np . lib . stride_tricks . as_strided <NEWLINE> n = len ( xs ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return ys . copy ( ) <NEWLINE> <DEDENT> bit = ( n - 1 ) . bit_length ( ) <NEWLINE> if bit <= threshold : <NEWLINE> <INDENT> res = lagrange_interpolation ( xs . tolist ( ) , ys . tolist ( ) , mod ) <NEWLINE> return np . array ( res [ : : - 1 ] , dtype = np . int64 ) <NEWLINE> <DEDENT> k = 1 << bit <NEWLINE> fpss = np . zeros ( ( bit + 1 , n + 1 ) , dtype = np . int64 ) <NEWLINE> fpss [ 0 , : n ] = - xs % mod <NEWLINE> for i in range ( bit ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , n , step ) : <NEWLINE> <INDENT> if j + half >= n : <NEWLINE> <INDENT> fpss [ i + 1 , j : n ] = fpss [ i , j : n ] <NEWLINE> continue <NEWLINE> <DEDENT> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : j + step + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> f = poly_mul ( f1 , f2 ) <NEWLINE> fpss [ i + 1 , j : j + len ( f ) - 1 ] = f [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT> fpss2 = np . zeros ( ( bit + 1 , k + 1 ) , dtype = np . int64 ) <NEWLINE> fpss2 [ bit , : n ] = poly_differential ( f ) <NEWLINE> for i in range ( bit - 1 , threshold - 1 , - 1 ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , n , step ) : <NEWLINE> <INDENT> if j + half >= n : <NEWLINE> <INDENT> fpss2 [ i , j : n ] = fpss2 [ i + 1 , j : n ] <NEWLINE> continue <NEWLINE> <DEDENT> f = fpss2 [ i + 1 , j : min ( j + step , n ) ] <NEWLINE> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : min ( j + step , n ) + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> fpss2 [ i , j : j + half ] = poly_mod ( f , f1 ) <NEWLINE> fpss2 [ i , j + half : min ( j + step , n ) ] = poly_mod ( f , f2 ) <NEWLINE> <DEDENT> <DEDENT> xs = as_strided ( xs , ( k >> threshold , 1 << threshold ) , ( 8 << threshold , 8 ) ) <NEWLINE> xs_cumprod = np . ones_like ( xs ) <NEWLINE> f = np . zeros_like ( xs ) <NEWLINE> for i in range ( 1 << threshold ) : <NEWLINE> <INDENT> f += fpss2 [ threshold , i : k : 1 << threshold , None ] * xs_cumprod % mod <NEWLINE> xs_cumprod *= xs <NEWLINE> xs_cumprod %= mod <NEWLINE> <DEDENT> f = f . ravel ( ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> fpss2 [ 0 , j ] = ys [ j ] * pow ( int ( f [ j ] ) , mod - 2 , mod ) % mod <NEWLINE> <DEDENT> for i in range ( bit ) : <NEWLINE> <INDENT> step = 2 << i <NEWLINE> half = step >> 1 <NEWLINE> for j in range ( 0 , k , step ) : <NEWLINE> <INDENT> if j + half >= n : <NEWLINE> <INDENT> fpss2 [ i + 1 , j : n ] = fpss2 [ i , j : n ] <NEWLINE> continue <NEWLINE> <DEDENT> f1 = fpss [ i , j : j + half + 1 ] . copy ( ) <NEWLINE> f2 = fpss [ i , j + half : j + step + 1 ] . copy ( ) <NEWLINE> f1 [ - 1 ] = f2 [ - 1 ] = 1 <NEWLINE> fpss2 [ i + 1 , j : min ( j + step , n ) ] = ( <NEWLINE> <INDENT> poly_mul ( fpss2 [ i , j : j + half ] , f2 ) <NEWLINE> + poly_mul ( fpss2 [ i , j + half : min ( j + step , n ) ] , f1 ) <NEWLINE> <DEDENT> ) % mod <NEWLINE> <DEDENT> <DEDENT> return fpss2 [ bit , : n ] <NEWLINE> <NL> <DEDENT> mod = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> X = np . arange ( mod , dtype = np . int64 ) <NEWLINE> Ans = polynomial_interpolation ( X , A ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans . tolist ( ) ) ) ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> import decimal <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> p = find ( x ) <NEWLINE> q = find ( y ) <NEWLINE> if p == q : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if p > q : <NEWLINE> <INDENT> p , q = q , p <NEWLINE> <DEDENT> par [ p ] += par [ q ] <NEWLINE> par [ q ] = p <NEWLINE> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <DEDENT> n = 0 <NEWLINE> par = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> def prime_numbers ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> prime_numbers = [ i for i in range ( x ) ] <NEWLINE> prime_numbers [ 1 ] = 0 <NEWLINE> for prime_number in prime_numbers : <NEWLINE> <INDENT> if prime_number > math . sqrt ( x ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if prime_number == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for composite_number in range ( 2 * prime_number , x , prime_number ) : <NEWLINE> <INDENT> prime_numbers [ composite_number ] = 0 <NEWLINE> <DEDENT> <DEDENT> return [ prime_number for prime_number in prime_numbers if prime_number != 0 ] <NEWLINE> <DEDENT> def is_prime ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if x == 2 or x == 3 or x == 5 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x % 2 == 0 or x % 3 == 0 or x % 5 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> prime_number = 7 <NEWLINE> difference = 4 <NEWLINE> while prime_number <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % prime_number == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> prime_number += difference <NEWLINE> difference = 6 - difference <NEWLINE> <DEDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> if n < 0 or r < 0 : return 0 <NEWLINE> return fa [ n ] * fi [ r ] % mod * fi [ n - r ] % mod <NEWLINE> <DEDENT> fa = [ 1 ] * ( n + 1 ) <NEWLINE> fi = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fa [ i ] = fa [ i - 1 ] * i % mod <NEWLINE> fi [ i ] = pow ( fa [ i ] , mod - 2 , mod ) <NEWLINE> <COMMENT> <NL> <DEDENT> BIT = [ 0 ] * ( n + 1 ) <NEWLINE> def add ( i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> BIT [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <DEDENT> <DEDENT> def query ( i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += BIT [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> <DEDENT> from collections import deque <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> li = [ 1 for i in range ( n - k + 1 ) ] <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> if p [ i - 1 ] > p [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> li [ 0 ] = 0 <NEWLINE> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> if p [ i - 1 ] > p [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if p [ i - k ] > p [ i - k + 1 ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> li [ i - k + 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> Q1 = deque ( [ ] ) <NEWLINE> Q2 = deque ( [ ] ) <NEWLINE> L1 = [ 0 for i in range ( n - k + 2 ) ] <NEWLINE> L2 = [ 0 for i in range ( n - k + 2 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> while Q1 and p [ Q1 [ - 1 ] ] > p [ i ] : <NEWLINE> <INDENT> Q1 . pop ( ) <NEWLINE> <DEDENT> while Q2 and p [ Q2 [ - 1 ] ] < p [ i ] : <NEWLINE> <INDENT> Q2 . pop ( ) <NEWLINE> <DEDENT> Q1 . append ( i ) <NEWLINE> Q2 . append ( i ) <NEWLINE> if Q1 [ 0 ] == i - k + 1 : <NEWLINE> <INDENT> Q1 . popleft ( ) <NEWLINE> <DEDENT> if Q2 [ 0 ] == i - k + 1 : <NEWLINE> <INDENT> Q2 . popleft ( ) <NEWLINE> <DEDENT> if i >= k - 2 : <NEWLINE> <INDENT> L1 [ i - k + 2 ] = p [ Q1 [ 0 ] ] <NEWLINE> L2 [ i - k + 2 ] = p [ Q2 [ 0 ] ] <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> if p [ i - 1 ] > L1 [ i ] or p [ i + k - 1 ] < L2 [ i ] : <NEWLINE> <INDENT> if li [ i ] > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - min ( li ) + li [ 0 ] + 1 ) <NEWLINE>
from itertools import * <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> M = m <NEWLINE> a = [ 1 ] <NEWLINE> for i in range ( 2 , int ( m ** .5 ) + 1 ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> m //= i <NEWLINE> a += [ i ] <NEWLINE> <DEDENT> <DEDENT> if m != 1 : a += [ m ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> for b in combinations_with_replacement ( set ( a ) , i ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> for j in b : c *= j <NEWLINE> if c >= n and M % c == 0 : ans = max ( ans , M // c ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ map ( int , input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> dp = np . zeros ( ( N + 1 , W + 1 ) , dtype = np . int ) <NEWLINE> for i , ( w , v ) in enumerate ( wv ) : <NEWLINE> <INDENT> dp [ i + 1 ] = np . maximum ( dp [ i + 1 ] , dp [ i ] ) <NEWLINE> dp [ i + 1 ] [ w : ] = np . maximum ( dp [ i + 1 ] [ w : ] , dp [ i ] [ : - w ] + v ) <NEWLINE> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE>
H , W = input ( ) . split ( <STRING> ) <NEWLINE> H = int ( H ) <NEWLINE> W = int ( W ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> print ( a ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def solve ( N , L ) : <NEWLINE> <INDENT> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N - 1 ) : <NEWLINE> <INDENT> c = bisect_left ( L , L [ a ] + L [ b ] ) - 1 <NEWLINE> ans += c - b <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = solve ( N , L ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = max ( 0 , A - K ) <NEWLINE> b = B <NEWLINE> if K - A > 0 : <NEWLINE> <INDENT> b = max ( 0 , B - K + A ) <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> [ numbers . append ( int ( input ( ) . rstrip ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> max_n = 0 <NEWLINE> second_n = 0 <NEWLINE> <NL> for i in numbers : <NEWLINE> <INDENT> if i > max_n : <NEWLINE> <INDENT> max_n = i <NEWLINE> <DEDENT> elif i > second_n : <NEWLINE> <INDENT> second_n = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in numbers : <NEWLINE> <INDENT> if i == max_n : <NEWLINE> <INDENT> print ( second_n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_tmp = sorted ( A , key = abs , reverse = True , ) <NEWLINE> total = 0 <NEWLINE> for i , v in enumerate ( A_tmp ) : <NEWLINE> <INDENT> if ( v <= 0 ) and ( i < len ( A_tmp ) - 1 ) : <NEWLINE> <INDENT> A_tmp [ i ] = ( - 1 ) * A_tmp [ i ] <NEWLINE> A_tmp [ i + 1 ] = ( - 1 ) * A_tmp [ i + 1 ] <NEWLINE> total += A_tmp [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += v <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ 0 ] * M <NEWLINE> R = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> print ( max ( min ( R ) - max ( L ) + 1 , 0 ) ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> <NL> def swap ( a , b ) : <NEWLINE> <INDENT> return max ( a , b ) , min ( a , b ) <NEWLINE> <NL> <DEDENT> def comb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> _ = input ( ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> an . sort ( ) <NEWLINE> target = an [ - 1 ] / 2 <NEWLINE> res = min ( enumerate ( an ) , key = lambda x : abs ( target - x [ 1 ] ) ) <NEWLINE> print ( an [ - 1 ] , res [ 1 ] ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i ** 2 <= n : <NEWLINE> <INDENT> ans = i ** 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> print ( int ( min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) ) * 2 ) <NEWLINE>
def isSquare ( x ) : <NEWLINE> <INDENT> return x == round ( x ** ( 1 / 2 ) ) ** 2 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> f = N <NEWLINE> while True : <NEWLINE> <INDENT> if isSquare ( f ) : <NEWLINE> <INDENT> print ( f ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f -= 1 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> ans *= i % 1000000007 <NEWLINE> ans = ans % 1000000007 <NEWLINE> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ls = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> d = [ 0 ] <NEWLINE> pre = 0 <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> d . append ( d [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( d [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> for start , end in ls : <NEWLINE> <INDENT> print ( d [ end - 1 ] - d [ start - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> magic = [ _ for _ in range ( N ) ] <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> magic [ k ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> magic [ k ] . append ( magic [ k ] [ 0 ] / magic [ k ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> magic . sort ( key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> ans = [ 0 for _ in range ( H + 1 ) ] <NEWLINE> visited = [ 0 ] <NEWLINE> anskouho = [ float ( <STRING> ) ] <NEWLINE> <NL> def solve ( start , power , point , maryoku ) : <NEWLINE> <INDENT> if start == H : <NEWLINE> <INDENT> print ( min ( point , min ( anskouho ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif start > H : <NEWLINE> <INDENT> anskouho . append ( point ) <NEWLINE> visited . sort ( reverse = True ) <NEWLINE> return 0 <NEWLINE> <DEDENT> elif ans [ start ] != 0 : <NEWLINE> <INDENT> visited . sort ( reverse = True ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited . append ( start ) <NEWLINE> ans [ start ] = point <NEWLINE> solve ( start + power , power , point + maryoku , maryoku ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> for item in visited : <NEWLINE> <INDENT> solve ( item + magic [ k ] [ 0 ] , magic [ k ] [ 0 ] , ans [ item ] + magic [ k ] [ 1 ] , magic [ k ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( anskouho ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> ans = ( b // x ) - ( ( a - 1 ) // x ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> wb = { <STRING> : 1 , <STRING> : 0 } <NEWLINE> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> xyc = [ l . split ( ) for l in read ( ) . splitlines ( ) ] <NEWLINE> xy = [ [ int ( lst [ 0 ] ) % ( 2 * k ) , ( int ( lst [ 1 ] ) + k * wb [ lst [ 2 ] ] ) % ( 2 * k ) ] for lst in xyc ] <NEWLINE> mat = np . zeros ( ( k + 1 , 2 * k + 1 ) , dtype = <STRING> ) <NEWLINE> cand = np . zeros ( ( k + 1 , k + 1 ) , dtype = <STRING> ) <NEWLINE> for e in xy : <NEWLINE> <INDENT> f0 = e [ 0 ] >= k <NEWLINE> f1 = e [ 1 ] >= k <NEWLINE> mat [ e [ 0 ] - f0 * k + 1 , e [ 1 ] + ( - 1 ) ** f1 * f0 * k + 1 ] += 1 <NEWLINE> <DEDENT> mat = np . cumsum ( mat , axis = 0 ) <NEWLINE> mat = np . cumsum ( mat , axis = 1 ) <NEWLINE> cand = mat [ k , 2 * k ] - mat [ k , k : 2 * k + 1 ] + mat [ k , : k + 1 ] - np . reshape ( mat [ : k + 1 , 2 * k ] , ( k + 1 , 1 ) ) + 2 * mat [ : , k : 2 * k + 1 ] - 2 * mat [ : , : k + 1 ] <NEWLINE> print ( max ( np . max ( cand ) , mat [ k , 2 * k ] - np . min ( cand ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> cnt = [ 0 ] * N <NEWLINE> cnt2 = [ ] <NEWLINE> flag = 0 <NEWLINE> <NL> if len ( S ) > 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 1 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 2 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 3 ] += 1 <NEWLINE> <DEDENT> elif S [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 4 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if cnt [ i ] != 0 : <NEWLINE> <INDENT> cnt2 . append ( cnt [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> import math <NEWLINE> import itertools <NEWLINE> ans = 0 <NEWLINE> <NL> for v in itertools . combinations ( cnt2 , 3 ) : <NEWLINE> <INDENT> ans += v [ 0 ] * v [ 1 ] * v [ 2 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) + 1 <NEWLINE> <NL> a = [ - 1 ] * n <NEWLINE> tmp = 0 <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> a [ 0 ] = 0 <NEWLINE> <DEDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a [ - 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> i = i * ( - 1 ) - 1 <NEWLINE> if a [ i ] == 0 : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i - 1 ] = max ( tmp , a [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A , B , C , D = A - 1 , B - 1 , C - 1 , D - 1 <NEWLINE> <NL> <COMMENT> <NL> if B == 1 : <NEWLINE> <INDENT> a = S . find ( <STRING> ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = S . find ( <STRING> , 3 ) + 1 <NEWLINE> <NL> <DEDENT> dx = [ 1 , 2 ] <NEWLINE> <NL> <COMMENT> <NL> def dfs_ini ( v , seen_ini , X ) : <NEWLINE> <INDENT> seen_ini [ v ] = True <COMMENT> <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> next_v = v + dx [ i ] <NEWLINE> <COMMENT> <NL> if not ( - 1 < next_v < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( S [ next_v ] == <STRING> ) or ( next_v == X ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if seen_ini [ next_v ] == True : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs_ini ( next_v , seen_ini , X ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def dfs_fin ( w , seen_fin , Y ) : <NEWLINE> <INDENT> seen_fin [ w ] = True <COMMENT> <NEWLINE> for j in range ( 2 ) : <NEWLINE> <INDENT> next_w = w + dx [ j ] <NEWLINE> <COMMENT> <NL> if not ( - 1 < next_w < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( S [ next_w ] == <STRING> ) or ( next_w == Y ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if seen_fin [ next_w ] == True : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs_fin ( next_w , seen_fin , Y ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if C > D : <NEWLINE> <INDENT> seen_ini_A = [ False ] * N <NEWLINE> seen_fin_B = [ False ] * N <NEWLINE> <COMMENT> <NL> if ( a < B ) or ( a > D ) : <NEWLINE> <INDENT> a = B <NEWLINE> <DEDENT> dfs_ini ( A , seen_ini_A , a ) <NEWLINE> dfs_fin ( B , seen_fin_B , C ) <NEWLINE> result = <STRING> <NEWLINE> if seen_ini_A [ C ] and seen_fin_B [ D ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> seen_ini_B = [ False ] * N <NEWLINE> seen_fin_A = [ False ] * N <NEWLINE> dfs_ini ( B , seen_ini_B , A ) <NEWLINE> dfs_fin ( A , seen_fin_A , D ) <NEWLINE> result = <STRING> <NEWLINE> if seen_ini_B [ D ] and seen_fin_A [ C ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for p in range ( k + 1 ) : <NEWLINE> <INDENT> for q in range ( k + 1 ) : <NEWLINE> <INDENT> r = s - p - q <NEWLINE> if r >= 0 and r <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> h . sort ( ) <NEWLINE> <NL> ans = h [ - 1 ] - h [ 0 ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , h [ i + k - 1 ] - h [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> ( * a , ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL>  = 1 <NEWLINE> for i in set ( a ) : <NEWLINE> <INDENT>  *= i <NEWLINE> <DEDENT> ans =  / sum (  // i for i in a ) <NEWLINE> print ( [ ans , int ( ans ) ] [ ans % 1 == 0 ] ) <NEWLINE>
s = input ( ) <NEWLINE> now = len ( s ) <NEWLINE> while 1 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> if 7 <= now : <NEWLINE> <INDENT> if s [ now - 7 : now ] == <STRING> : <NEWLINE> <INDENT> now -= 7 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if 6 <= now : <NEWLINE> <INDENT> if s [ now - 6 : now ] == <STRING> : <NEWLINE> <INDENT> now -= 6 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if 5 <= now : <NEWLINE> <INDENT> if s [ now - 5 : now ] == <STRING> : <NEWLINE> <INDENT> now -= 5 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> if s [ now - 5 : now ] == <STRING> : <NEWLINE> <INDENT> now -= 5 <NEWLINE> flag = 0 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if now == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif now < 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = np . zeros ( N , dtype = np . int ) <NEWLINE> <NL> j = 0 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> while S [ i + j ] == <STRING> : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> if j != 0 : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> ans [ i + j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i + j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> j = 0 <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> while S [ i - j ] == <STRING> : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> if j != 0 : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> ans [ i - j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - j + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 123 - ord ( s ) <= K : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> K -= 123 - ord ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if K > 0 : <NEWLINE> <INDENT> ans = ans [ : - 1 ] + ( chr ( ord ( ans [ - 1 ] ) + K % 26 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ma = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ma . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> t = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = False <NEWLINE> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> for j in range ( n - m + 1 ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> ll = ma [ i + k ] [ j : j + m ] <NEWLINE> if ll != t [ k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , * p = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> min_p = p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> min_p = min ( min_p , p [ i ] ) <NEWLINE> if p [ i ] <= min_p : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> bCount = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> bCount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += bCount <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> s = pin ( ) [ : - 1 ] <NEWLINE> K = int ( pin ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( s ) - i + 1 ) : <NEWLINE> <INDENT> d . append ( s [ j : j + i ] ) <NEWLINE> <DEDENT> <DEDENT> ans = sorted ( list ( set ( d ) ) ) <NEWLINE> print ( ans [ K - 1 ] ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> position = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if position == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> position = a [ position - 1 ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def common_multiple ( x , y ) : <NEWLINE> <INDENT> for i in range ( 2 , min ( x , y ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 or y % i == 0 : <NEWLINE> <INDENT> return common_multiple ( x // i if x % i == 0 else x , y // i if y % i == 0 else y ) * i <NEWLINE> <DEDENT> <DEDENT> return x * y <NEWLINE> <NL> <DEDENT> a = input ( ) . split ( <STRING> ) <NEWLINE> A , B , C , D = int ( a [ 0 ] ) - 1 , int ( a [ 1 ] ) , int ( a [ 2 ] ) , int ( a [ 3 ] ) <NEWLINE> <NL> M = common_multiple ( C , D ) <NEWLINE> B0 = B // C + B // D - B // M <NEWLINE> A0 = A // C + A // D - A // M <NEWLINE> print ( B - A - B0 + A0 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> ins = lambda : input ( ) . rstrip ( ) <NEWLINE> ini = lambda : int ( input ( ) . rstrip ( ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ini ( ) <NEWLINE> a = inl ( ) <NEWLINE> if len ( set ( a ) ) == n : <NEWLINE> <INDENT> print ( n - 2 ) <NEWLINE> <DEDENT> elif len ( set ( a ) ) == 1 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = { } <NEWLINE> s = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if a [ i ] not in f : <NEWLINE> <INDENT> f [ a [ i ] ] = 0 <NEWLINE> <DEDENT> f [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i ] not in s : <NEWLINE> <INDENT> s [ a [ i ] ] = 0 <NEWLINE> <DEDENT> s [ a [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> fsum = sum ( f . values ( ) ) <NEWLINE> ssum = sum ( s . values ( ) ) <NEWLINE> f = sorted ( f . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> s = sorted ( s . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> if f [ 0 ] [ 0 ] == s [ 0 ] [ 0 ] : <NEWLINE> <INDENT> tmp1 = fsum - f [ 0 ] [ 1 ] + ssum - s [ 1 ] [ 1 ] <NEWLINE> tmp2 = fsum - f [ 1 ] [ 1 ] + ssum - s [ 0 ] [ 1 ] <NEWLINE> print ( min ( tmp1 , tmp2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( fsum - f [ 0 ] [ 1 ] + ssum - s [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
s = str ( input ( ) ) <NEWLINE> <NL> <NL> a , b = 0 , 0 <NEWLINE> <NL> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> a , b = i + 1 , i + 2 <NEWLINE> break <NEWLINE> <DEDENT> elif i < len ( s ) - 2 : <NEWLINE> <INDENT> if s [ i ] == s [ i + 2 ] : <NEWLINE> <INDENT> a , b = i + 1 , i + 3 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if a == 0 : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> maximum = [ ( 0 , [ ( ) ] ) ] <NEWLINE> <NL> s = tuple ( s ) <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> j = i - 1 <NEWLINE> while j >= 0 : <NEWLINE> <INDENT> max_count , previous = maximum [ j ] <NEWLINE> if max_count < 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> current = s [ j : i ] <NEWLINE> if any ( p != current for p in previous ) : <NEWLINE> <INDENT> if len ( maximum ) == i + 1 : <NEWLINE> <INDENT> mc , blocks = maximum [ i ] <NEWLINE> if mc == max_count + 1 : <NEWLINE> <INDENT> blocks . append ( current ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maximum . append ( ( max_count + 1 , [ current ] ) ) <NEWLINE> <DEDENT> <DEDENT> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( maximum ) != i + 1 : <NEWLINE> <INDENT> maximum . append ( ( - 1 , [ ] ) ) <NEWLINE> <DEDENT> <DEDENT> assert len ( maximum ) == i + 1 <NEWLINE> <NL> <DEDENT> print ( maximum [ - 1 ] [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ ] <NEWLINE> for i in range ( len ( a_list ) ) : <NEWLINE> <INDENT> ans_list . append ( a_list [ i ] - i - 1 ) <NEWLINE> <DEDENT> import numpy as np <NEWLINE> if len ( ans_list ) % 2 == 0 : <NEWLINE> <INDENT> ans_list1 = sorted ( ans_list ) <NEWLINE> number1 = ans_list1 [ n // 2 ] <NEWLINE> number2 = ans_list1 [ n // 2 + 1 ] <NEWLINE> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> for i in ans_list : <NEWLINE> <INDENT> ans1 += abs ( i - number1 ) <NEWLINE> ans2 += abs ( i - number2 ) <NEWLINE> <DEDENT> print ( min ( ans1 , ans2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cary = ans_list <NEWLINE> number = int ( np . median ( cary ) ) <NEWLINE> ans = 0 <NEWLINE> for i in ans_list : <NEWLINE> <INDENT> ans += abs ( i - number ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> sapp = [ [ 0 ] * n for _ in range ( 10 ) ] <NEWLINE> for idx , s in enumerate ( S ) : <NEWLINE> <INDENT> sapp [ int ( s ) ] [ idx ] = 1 <NEWLINE> <NL> <DEDENT> from itertools import accumulate <NEWLINE> sacc = [ list ( accumulate ( sa ) ) for sa in sapp ] <NEWLINE> <NL> pins = set ( ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for lnum in range ( 10 ) : <NEWLINE> <INDENT> if sacc [ lnum ] [ i - 1 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for rnum in range ( 10 ) : <NEWLINE> <COMMENT> <NL> <INDENT> rnumc = sacc [ rnum ] [ - 1 ] - sacc [ rnum ] [ i ] <NEWLINE> if rnumc > 0 : <NEWLINE> <INDENT> pins . add ( 100 * lnum + 10 * int ( S [ i ] ) + rnum ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( pins ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> e = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> dist = [ - 1 ] * ( n + 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a ] . append ( ( b , c ) ) <NEWLINE> e [ b ] . append ( ( a , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = deque ( ) <NEWLINE> a . append ( ( k , 0 ) ) <NEWLINE> while a : <NEWLINE> <INDENT> x , d = a . popleft ( ) <NEWLINE> dist [ x ] = d <NEWLINE> for j , nc in e [ x ] : <NEWLINE> <INDENT> if dist [ j ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( ( j , d + nc ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( dist [ x ] + dist [ y ] ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for s in range ( n ) ] <NEWLINE> s1 = [ ] <NEWLINE> sum0 = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i % 10 == 0 : <NEWLINE> <INDENT> sum0 += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s1 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( s1 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum1 = sum ( s1 ) <NEWLINE> if sum1 % 10 != 0 : <NEWLINE> <INDENT> print ( sum0 + sum1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum0 + sum1 - min ( s1 ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if v [ i ] > c [ i ] : <NEWLINE> <INDENT> ans += v [ i ] - c [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> suc = <STRING> <NEWLINE> maxN = H [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if maxN - 1 > H [ i ] : <NEWLINE> <INDENT> suc = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif maxN < H [ i ] : <NEWLINE> <INDENT> maxN = H [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( suc ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min = p [ 0 ] <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if p [ i ] <= min : <NEWLINE> <INDENT> count += 1 <NEWLINE> min = p [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> def DFS ( v ) : <NEWLINE> <INDENT> if DP [ v ] == - 1 : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in G [ v ] : <NEWLINE> <INDENT> res = max ( res , DFS ( i ) + 1 ) <NEWLINE> <NL> <DEDENT> DP [ v ] = res <NEWLINE> <NL> <DEDENT> return DP [ v ] <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> DP = [ - 1 ] * N <NEWLINE> for v in range ( N ) : <NEWLINE> <INDENT> DFS ( v ) <NEWLINE> <NL> <DEDENT> print ( max ( DP ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> exit ( ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> sabun_list = [ ] <NEWLINE> x_list . sort ( ) <NEWLINE> for i , x in enumerate ( x_list ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sabun_list . append ( x - x_list [ i - 1 ] ) <NEWLINE> <DEDENT> result = 0 <NEWLINE> sum_max_sabun = 0 <NEWLINE> sabun_list . sort ( reverse = True ) <NEWLINE> sum_max_sabun = sum ( sabun_list [ : n - 1 ] ) <NEWLINE> <NL> result = ( x_list [ - 1 ] - x_list [ 0 ] ) - sum_max_sabun <NEWLINE> <NL> print ( result ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <COMMENT> <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> value_min = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , ( - 1 ) * ( - value_min // 2 ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> INF = 1000000007 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= INF <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
import sys <NEWLINE> <NL> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <NL> s = list ( s ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> d = 0 <NEWLINE> if len ( s ) >= k : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if d == k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> path = [ list ( ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = ab [ i ] [ 0 ] , ab [ i ] [ 1 ] <NEWLINE> path [ a ] . append ( [ b , i ] ) <NEWLINE> path [ b ] . append ( [ a , i ] ) <NEWLINE> <NL> <DEDENT> color_max = 0 <NEWLINE> color_list = [ 0 ] * ( N - 1 ) <NEWLINE> visit = [ False ] * ( N + 1 ) <NEWLINE> visit [ 1 ] = True <NEWLINE> def dfs ( node , color , used_path ) : <NEWLINE> <INDENT> global visit <NEWLINE> nxt_color = 0 <NEWLINE> for nxt in path [ node ] : <NEWLINE> <INDENT> nxt_node = nxt [ 0 ] <NEWLINE> use_path = nxt [ 1 ] <NEWLINE> if visit [ nxt_node ] == False : <NEWLINE> <INDENT> visit [ nxt_node ] = True <NEWLINE> nxt_color += 1 <NEWLINE> if nxt_color == color : <NEWLINE> <INDENT> nxt_color += 1 <NEWLINE> <DEDENT> dfs ( nxt_node , nxt_color , use_path ) <NEWLINE> <NL> <DEDENT> <DEDENT> global color_list <NEWLINE> if used_path != - 1 : <NEWLINE> <INDENT> color_list [ used_path ] = color <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , 0 , - 1 ) <NEWLINE> <NL> <NL> for c in color_list : <NEWLINE> <INDENT> color_max = max ( c , color_max ) <NEWLINE> <DEDENT> print ( color_max ) <NEWLINE> print ( <STRING> . join ( map ( str , color_list ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for i in range ( int ( N ** 0.5 + 1 ) , - 1 , - 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> print ( len ( str ( N // i ) ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> dp [ a ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == - 1 : <NEWLINE> <INDENT> if i <= 2 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + 1 <NEWLINE> <DEDENT> elif i >= 3 : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , k , q , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> points = np . full ( n , k ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> points -= 1 <NEWLINE> points [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> [ points [ i ] > 0 : : 2 ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> f = 0 <NEWLINE> if l <= 9 : <NEWLINE> <INDENT> for i in range ( 1 << l + 1 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for j in range ( l + 1 ) : <NEWLINE> <INDENT> if i >> j & 1 : ans += <STRING> <NEWLINE> if j < l : ans += s [ j ] <NEWLINE> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : f = 0 <NEWLINE> <NL> if f : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import random <NEWLINE> from decimal import Decimal <NEWLINE> import itertools <NEWLINE> import re <NEWLINE> import bisect <NEWLINE> from collections import deque , Counter <NEWLINE> from functools import lru_cache <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 13 <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> def SERIES ( n ) : return np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> def GRID ( h , w ) : return np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . int32 , sep = <STRING> ) . reshape ( h , - 1 ) [ : , : w ] <NEWLINE> def GRIDfromString ( h , w ) : return np . frombuffer ( sys . stdin . buffer . read ( ) , <STRING> ) . reshape ( h , - 1 ) [ : , : w ] <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> a_list = LI ( ) <NEWLINE> a_dict = list ( Counter ( a_list ) . items ( ) ) <NEWLINE> a_dict . sort ( ) <NEWLINE> ans = 1 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( a_dict ) ) : <NEWLINE> <INDENT> diff , number = a_dict [ i ] <NEWLINE> if diff % 2 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if diff != 2 * i + 1 or number != 2 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= 2 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a_dict ) ) : <NEWLINE> <INDENT> diff , number = a_dict [ i ] <NEWLINE> if diff % 2 == 1 or ( diff == 0 and number != 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if diff != 2 * i or ( diff > 0 and number != 2 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if diff != 0 : <NEWLINE> <INDENT> ans *= 2 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> z = n * m // gcd ( n , m ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = z // n <NEWLINE> m = z // m <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while x < z and y < z : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> y += m <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> x += n <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] != t [ j ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> x += n <NEWLINE> y += m <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> M = [ ] <NEWLINE> con = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> L . append ( i ) <NEWLINE> <DEDENT> L = list ( set ( L ) ) <NEWLINE> L . sort ( ) <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == L [ 0 ] : <NEWLINE> <INDENT> for k in range ( 1 , 6 ) : <NEWLINE> <INDENT> if j + k >= len ( s ) : <NEWLINE> <INDENT> M . append ( s [ j : ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M . append ( s [ j : j + k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( L ) != 1 : <NEWLINE> <INDENT> for l in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ l ] == L [ 1 ] : <NEWLINE> <INDENT> for m in range ( 1 , 6 ) : <NEWLINE> <INDENT> if l + m >= len ( s ) : <NEWLINE> <INDENT> M . append ( s [ l : ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M . append ( s [ l : l + m ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( M ) < K : <NEWLINE> <INDENT> for n in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ n ] == L [ 2 ] : <NEWLINE> <INDENT> for o in range ( 1 , 6 ) : <NEWLINE> <INDENT> if n + o >= len ( s ) : <NEWLINE> <INDENT> M . append ( s [ n : ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M . append ( s [ n : n + o ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> M = list ( set ( M ) ) <NEWLINE> M . sort ( ) <NEWLINE> print ( M [ K - 1 ] ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 , 0 ] <NEWLINE> for l in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ l - 1 ] == <STRING> and s [ l ] == <STRING> : <NEWLINE> <INDENT> a . append ( a [ l ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( a [ l ] ) <NEWLINE> <DEDENT> <DEDENT> for k in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ y ] - a [ x ] ) <NEWLINE> <DEDENT>
N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> P = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> ok = [ False ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> correct = 0 <COMMENT> <NEWLINE> penalty = 0 <COMMENT> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> p = int ( query [ 0 ] ) <NEWLINE> S = query [ 1 ] <NEWLINE> if ok [ p ] == False : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> ok [ p ] = True <NEWLINE> correct += 1 <NEWLINE> penalty += P [ p ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> P [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( correct , end = <STRING> ) <NEWLINE> print ( penalty ) <NEWLINE>
from itertools import product <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) == 1 : <NEWLINE> <INDENT> print ( int ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Sum = 0 <NEWLINE> for TR in product ( [ 0 , 1 ] , repeat = ( len ( S ) - 1 ) ) : <NEWLINE> <INDENT> Op = [ <STRING> if TO == 1 else <STRING> for TO in TR ] + [ <STRING> ] <NEWLINE> Sum += eval ( <STRING> . join ( [ TS + TO for TS , TO in zip ( S , Op ) ] ) ) <NEWLINE> <DEDENT> print ( Sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> <NL> count = len ( str ( n ) ) <NEWLINE> ans = <STRING> <NEWLINE> if count % 2 == 0 : <NEWLINE> <INDENT> for i in range ( count - 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ( count // 2 ) * <STRING> <NEWLINE> try : <NEWLINE> <INDENT> ans = n - int ( ans ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> ans = n <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> min = int ( c * d / math . gcd ( c , d ) ) <NEWLINE> x = b - b // c - b // d + b // min <NEWLINE> y = a - 1 - ( a - 1 ) // c - ( a - 1 ) // d + ( a - 1 ) // min <NEWLINE> <NL> print ( int ( x - y ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def dfs ( st , depth = 0 ) : <NEWLINE> <INDENT> dist [ st ] = depth <NEWLINE> for to , c in tree [ st ] : <NEWLINE> <INDENT> if dist [ to ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( to , depth + c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> dist = [ - 1 ] * N <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> tree [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dfs ( K - 1 , 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
from math import factorial <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if abs ( N - M ) > 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N == M : <NEWLINE> <INDENT> a = N <NEWLINE> b = M <NEWLINE> ans = factorial ( a ) * factorial ( b ) * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = max ( N , M ) <NEWLINE> b = min ( N , M ) <NEWLINE> ans = factorial ( a ) * factorial ( b ) <NEWLINE> <DEDENT> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - i - j <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in D : <NEWLINE> <INDENT> D [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C in D : <NEWLINE> <INDENT> D [ C ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ C ] = B <NEWLINE> <NL> <DEDENT> <DEDENT> K = sorted ( D . keys ( ) , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> cnt = N <NEWLINE> for k in K : <NEWLINE> <INDENT> a = min ( D [ k ] , cnt ) <NEWLINE> ans += k * a <NEWLINE> cnt -= a <NEWLINE> if cnt == 0 : break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sx = sum ( x ) <NEWLINE> dp = [ [ 0 ] * ( N + 1 ) for i in range ( sx + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dp_sub = [ [ 0 ] * ( N + 1 ) for j in range ( sx + 1 ) ] <COMMENT> <NEWLINE> for j in range ( sx + 1 ) : <NEWLINE> <INDENT> for k in range ( N + 1 ) : <NEWLINE> <INDENT> if dp [ j ] [ k ] != 0 : <NEWLINE> <INDENT> dp_sub [ j + x [ i ] ] [ k + 1 ] = dp [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( sx + 1 ) : <NEWLINE> <INDENT> for k in range ( N + 1 ) : <NEWLINE> <INDENT> dp [ j ] [ k ] += dp_sub [ j ] [ k ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> for i in range ( min ( sx // A , N ) ) : <NEWLINE> <INDENT> cnt += dp [ A * ( i + 1 ) ] [ i + 1 ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> R , G , B , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> ans = [ ] <NEWLINE> <NL> r , g , b = 0 , 0 , 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> max_r = N // R <NEWLINE> for r in range ( max_r + 1 ) : <NEWLINE> <INDENT> if R * r > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> max_g = ( N - R * r ) // G <NEWLINE> <NL> for g in range ( max_g + 1 ) : <NEWLINE> <INDENT> if R * r + G * g > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = ( N - ( R * r + G * g ) ) <NEWLINE> if x % B == 0 and x >= 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for i in range ( h ) ] <NEWLINE> t = [ [ None ] * w for i in range ( h ) ] <NEWLINE> d = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> def dfs ( i , j , bw ) : <NEWLINE> <INDENT> global h , w <NEWLINE> if not ( 0 <= i < h and 0 <= j < w ) or s [ i ] [ j ] == bw or t [ i ] [ j ] : <NEWLINE> <INDENT> return 0 , 0 <NEWLINE> <DEDENT> t [ i ] [ j ] = True <NEWLINE> W , b = 0 , 0 <NEWLINE> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> W += 1 <NEWLINE> <DEDENT> for k in d : <NEWLINE> <INDENT> n , m = dfs ( i + k [ 0 ] , j + k [ 1 ] , s [ i ] [ j ] ) <NEWLINE> W += n <NEWLINE> b += m <NEWLINE> <DEDENT> return W , b <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> X , Y = dfs ( i , j , <STRING> ) <NEWLINE> ans += X * Y <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> cnt = [ 0 for _ in range ( 5 ) ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 1 ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 2 ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 3 ] += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt [ 4 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j , k in itertools . combinations ( cnt , r = 3 ) : <NEWLINE> <INDENT> ans += i * j * k <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> kitai = [ 0 ] * 1000 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> tmp += i + 1 <NEWLINE> kitai [ i ] = tmp / ( i + 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> total_kitai = [ 0 ] * ( n + 1 ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp += kitai [ p [ i ] - 1 ] <NEWLINE> total_kitai [ i + 1 ] = tmp <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( total_kitai [ i + k ] - total_kitai [ i ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minp = [ p [ 0 ] ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> minp . append ( min ( minp [ i - 1 ] , p [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minp [ i ] == p [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import itertools <NEWLINE> alsum = list ( itertools . accumulate ( al ) ) <NEWLINE> <NL> temp1 = 0 <NEWLINE> temp2 = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res += al [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if res > 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = res * ( - 1 ) + 1 <NEWLINE> temp1 += y <NEWLINE> res = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if res < 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = res + 1 <NEWLINE> temp1 += y <NEWLINE> res = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> res += al [ j ] <NEWLINE> if j % 2 == 0 : <NEWLINE> <INDENT> if res < 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = res + 1 <NEWLINE> temp2 += y <NEWLINE> res = - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if res > 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = res * ( - 1 ) + 1 <NEWLINE> temp2 += y <NEWLINE> res = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( temp1 , temp2 ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Pmin = [ 2 * 10 ** 5 for i in range ( N ) ] <NEWLINE> Pmin [ 0 ] = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> Pmin [ i ] = min ( Pmin [ i - 1 ] , P [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if Pmin [ i ] >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i * - 1 for i in a ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x = ( ( - 1 ) * heapq . heappop ( a ) ) // 2 <NEWLINE> heapq . heappush ( a , - x ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
import sys <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> while len ( S ) > 0 : <NEWLINE> <INDENT> if len ( S ) < 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> third = S [ - 3 ] <NEWLINE> if third == <STRING> : <NEWLINE> <INDENT> if len ( S ) < 5 or S [ - 5 : ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> S = S [ : - 5 ] <NEWLINE> continue <NEWLINE> <DEDENT> if third == <STRING> : <NEWLINE> <INDENT> if len ( S ) < 5 or S [ - 5 : ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> S = S [ : - 5 ] <NEWLINE> continue <NEWLINE> <DEDENT> if third == <STRING> : <NEWLINE> <INDENT> if len ( S ) < 7 or S [ - 7 : ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> S = S [ : - 7 ] <NEWLINE> continue <NEWLINE> <DEDENT> if third == <STRING> : <NEWLINE> <INDENT> if len ( S ) < 6 or S [ - 6 : ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> S = S [ : - 6 ] <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> N , M , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> array_x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> array_y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if not ( 1 <= N <= 100 and 1 <= M <= 100 ) : sys . exit ( ) <NEWLINE> if not ( - 100 <= X <= 100 and - 100 <= Y <= 100 ) : sys . exit ( ) <NEWLINE> for I in array_x : <NEWLINE> <INDENT> if not ( - 100 <= I <= 100 and array_x . count ( I ) == 1 and I != X ) : sys . exit ( ) <NEWLINE> <DEDENT> for J in array_y : <NEWLINE> <INDENT> if not ( - 100 <= J <= 100 and array_y . count ( J ) == 1 and J != Y ) : sys . exit ( ) <NEWLINE> <NL> <DEDENT> for I in range ( X + 1 , Y + 1 ) : <NEWLINE> <INDENT> if I > max ( array_x ) and I <= min ( array_y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = sum ( s ) <NEWLINE> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if all ( [ i % 10 == 0 for i in s ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans - min ( [ i for i in s if i % 10 != 0 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> np_ab = np . array ( ab ) <NEWLINE> max_a = max ( np_ab [ : , 0 ] ) <NEWLINE> dp = [ 0 ] * ( h + max_a ) <NEWLINE> for i in range ( 1 , h + max_a ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( dp [ h ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> a = s . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = s . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> c = s . find ( str ( k ) , b + 1 ) <NEWLINE> if c == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if c * 100 <= x <= c * 105 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if c * 100 > x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( L ) <NEWLINE> A = list ( c . keys ( ) ) <NEWLINE> B = list ( c . values ( ) ) <NEWLINE> R = list ( ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if B [ i ] >= 2 : <NEWLINE> <INDENT> R . append ( [ A [ i ] , B [ i ] ] ) <NEWLINE> <DEDENT> <DEDENT> R = sorted ( R , reverse = True ) <NEWLINE> if len ( R ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if R [ 0 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( R [ 0 ] [ 0 ] ** 2 ) <NEWLINE> <DEDENT> elif len ( R ) < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R [ 0 ] [ 0 ] * R [ 1 ] [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> x100 = S . find ( str ( i ) ) <NEWLINE> if x100 == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> x10 = S . find ( str ( j ) , x100 + 1 ) <NEWLINE> if x10 == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if S . find ( str ( k ) , x10 + 1 ) != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> T . append ( t ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> Tnow = T [ 0 ] <NEWLINE> Anow = A [ 0 ] <NEWLINE> <NL> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> t = T [ i ] <NEWLINE> a = A [ i ] <NEWLINE> t1 = ( Tnow + t - 1 ) // t * t <NEWLINE> a1 = t1 // t * a <NEWLINE> a2 = ( Anow + a - 1 ) // a * a <NEWLINE> t2 = a2 // a * t <NEWLINE> if a1 < Anow : <NEWLINE> <INDENT> Tnow = t2 <NEWLINE> Anow = a2 <NEWLINE> <DEDENT> elif t2 < Tnow : <NEWLINE> <INDENT> Tnow = t1 <NEWLINE> Anow = a1 <NEWLINE> <DEDENT> elif t1 + a1 <= t2 + a2 : <NEWLINE> <INDENT> Tnow = t1 <NEWLINE> Anow = a1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Tnow = t2 <NEWLINE> Anow = a2 <NEWLINE> <DEDENT> <DEDENT> print ( Tnow + Anow ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> dp = [ True ] + [ False ] * ( X ) <NEWLINE> <NL> if X < 106 : <NEWLINE> <INDENT> if 100 <= X <= 105 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 100 , 106 ) : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> <NL> <DEDENT> for i in range ( 106 , X + 1 ) : <NEWLINE> <INDENT> for j in range ( 100 , 106 ) : <NEWLINE> <INDENT> if dp [ i - j ] == True : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( 1 if dp [ X ] == True else 0 ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a_ind = bisect . bisect_left ( A , b ) <NEWLINE> c_ind = bisect . bisect_right ( C , b ) <NEWLINE> ans += a_ind * ( n - c_ind ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> even_odd_length = n / 2 <NEWLINE> replace_total = 0 <NEWLINE> <NL> list_odd = v [ 0 : : 2 ] <NEWLINE> list_even = v [ 1 : : 2 ] <NEWLINE> <NL> dict_c_odd = dict ( collections . Counter ( list_odd ) ) <NEWLINE> dict_c_even = dict ( collections . Counter ( list_even ) ) <NEWLINE> dict_c_even_bk = dict_c_even . copy ( ) <NEWLINE> dict_c_odd_bk = dict_c_odd . copy ( ) <NEWLINE> <NL> replace_total_tmp = 0 <NEWLINE> replace_total_tmp2 = 0 <NEWLINE> max_count_c_odd = max ( dict_c_odd . values ( ) ) <NEWLINE> max_count_c_even = max ( dict_c_even . values ( ) ) <NEWLINE> max_count_c_even_bk = max_count_c_even <NEWLINE> max_c_odd_keys = [ k for k , v in dict_c_odd . items ( ) if v == max_count_c_odd ] <NEWLINE> max_c_even_keys = [ k for k , v in dict_c_even . items ( ) if v == max_count_c_even ] <NEWLINE> <NL> if len ( set ( v ) ) == 1 : <NEWLINE> <INDENT> print ( int ( even_odd_length ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_c_odd_keys [ 0 ] in dict_c_even : <NEWLINE> <INDENT> del dict_c_even [ max_c_odd_keys [ 0 ] ] <NEWLINE> <DEDENT> max_count_c_even = max ( dict_c_even . values ( ) ) <NEWLINE> replace_total_tmp = ( n - max_count_c_odd - max_count_c_even ) <NEWLINE> <NL> dict_c_even = dict_c_even_bk <NEWLINE> max_count_c_even = max_count_c_even_bk <NEWLINE> <NL> if max_c_even_keys [ 0 ] in dict_c_odd : <NEWLINE> <INDENT> del dict_c_odd [ max_c_even_keys [ 0 ] ] <NEWLINE> <DEDENT> max_count_c_odd = max ( dict_c_odd . values ( ) ) <NEWLINE> replace_total_tmp2 = ( n - max_count_c_odd - max_count_c_even ) <NEWLINE> <NL> if replace_total_tmp >= replace_total_tmp2 : <NEWLINE> <INDENT> replace_total = replace_total_tmp2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> replace_total = replace_total_tmp <NEWLINE> <DEDENT> print ( replace_total ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> R = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <NL> <DEDENT> print ( max ( min ( R ) - max ( L ) + 1 , 0 ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = [ ] <NEWLINE> for _ in range ( n ) : c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> dic [ ( c [ i ] [ 0 ] - c [ j ] [ 0 ] , c [ i ] [ 1 ] - c [ j ] [ 1 ] ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> if dict ( dic ) : print ( n - max ( dic . values ( ) ) ) <NEWLINE> else : print ( 1 ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import sqrt <NEWLINE> from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in permutations ( range ( N ) ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> dx = xy [ i [ j + 1 ] ] [ 0 ] - xy [ i [ j ] ] [ 0 ] <NEWLINE> dy = xy [ i [ j + 1 ] ] [ 1 ] - xy [ i [ j ] ] [ 1 ] <NEWLINE> d += sqrt ( dx ** 2 + dy ** 2 ) <NEWLINE> <DEDENT> ans += d <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( ans / cnt ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( sum ( abs ( i ) for i in a ) - 2 * min ( abs ( a [ - 1 ] ) , abs ( a [ 0 ] ) ) * ( a [ 0 ] * a [ - 1 ] > 0 ) ) <NEWLINE> if a [ 0 ] > 0 : <NEWLINE> <INDENT> print ( a [ 0 ] , a [ - 1 ] ) <NEWLINE> a [ 0 ] -= a [ - 1 ] <NEWLINE> for i in a [ 1 : - 2 ] : <NEWLINE> <INDENT> print ( a [ 0 ] , i ) <NEWLINE> a [ 0 ] -= i <NEWLINE> <DEDENT> print ( a [ - 2 ] , a [ 0 ] ) <NEWLINE> <DEDENT> elif a [ - 1 ] < 0 : <NEWLINE> <INDENT> for i in a [ : - 1 ] : <NEWLINE> <INDENT> print ( a [ - 1 ] , i ) <NEWLINE> a [ - 1 ] -= i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in a [ 1 : - 1 ] : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> print ( a [ - 1 ] , i ) <NEWLINE> a [ - 1 ] -= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 0 ] , i ) <NEWLINE> a [ 0 ] -= i <NEWLINE> <DEDENT> <DEDENT> print ( a [ - 1 ] , a [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> A = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> isBroken = [ False ] * ( N + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> isBroken [ i ] = True <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if M >= 1 : <NEWLINE> <INDENT> temp = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> if a - 1 == temp : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> temp = a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> memo = [ 0 ] * ( N + 2 ) <NEWLINE> <NL> def rec ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if i < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if isBroken [ i ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if memo [ i ] == 0 : <NEWLINE> <INDENT> count1 = rec ( i - 1 ) % 1000000007 <NEWLINE> count2 = rec ( i - 2 ) % 1000000007 <NEWLINE> memo [ i ] = ( count1 + count2 ) % 1000000007 <NEWLINE> <DEDENT> return memo [ i ] <NEWLINE> <DEDENT> return rec ( N ) <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> MaxN = 10 ** 9 <NEWLINE> if S == MaxN : <NEWLINE> <INDENT> A = [ S ] * K + [ 1 ] * ( N - K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = [ S ] * K + [ S + 1 ] * ( N - K ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
data = input ( ) . split ( ) <NEWLINE> N = int ( data [ 0 ] ) <NEWLINE> M = int ( data [ 1 ] ) <NEWLINE> data_gate = [ input ( ) . split ( ) for i in range ( M ) ] <NEWLINE> data_min = [ ] <NEWLINE> data_max = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> data_min . append ( int ( data_gate [ i ] [ 0 ] ) ) <NEWLINE> data_max . append ( int ( data_gate [ i ] [ 1 ] ) ) <NEWLINE> <DEDENT> m = max ( data_min ) <NEWLINE> M = min ( data_max ) <NEWLINE> if M >= m : <NEWLINE> <INDENT> ans = M - m + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for i in range ( a ) ] <NEWLINE> c = sorted ( b ) [ - 2 ] <NEWLINE> d = max ( b ) <NEWLINE> if b . count ( d ) >= 2 : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in b : <NEWLINE> <INDENT> if i == d : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> l = sorted ( a ) <NEWLINE> same = 1 <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if l [ i ] == l [ i - 1 ] : <NEWLINE> <INDENT> same += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if same % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> same = 1 <NEWLINE> <DEDENT> if same % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = [ ( 1 + p ) / 2 for p in P ] <NEWLINE> temp = sum ( Q [ : K ] ) <NEWLINE> ans = temp <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> temp = temp - Q [ i ] + Q [ i + K ] <NEWLINE> ans = max ( ans , temp ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A , B , C = [ list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( 3 ) ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> def bs_l ( lis , x ) : <NEWLINE> <INDENT> low , high = 0 , len ( lis ) <NEWLINE> while low < high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if lis [ mid ] < x : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <DEDENT> def bs_r ( lis , x ) : <NEWLINE> <INDENT> low , high = 0 , len ( lis ) <NEWLINE> while low < high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if lis [ mid ] > x : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <DEDENT> for i in B : <NEWLINE> <INDENT> count += bs_l ( A , i ) * ( N - bs_r ( C , i ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
a1 , b1 , a2 , b2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 2000000000 ) <NEWLINE> <NL> p = 10 ** 9 + 7 <NEWLINE> N = a2 + b2 + 2 <COMMENT> <NEWLINE> R = max ( a2 + 1 , b2 + 1 ) <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , R + 1 ) : <NEWLINE> <INDENT> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> def comb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <DEDENT> score = comb ( a2 + b2 + 2 , a2 + 1 , p ) - comb ( a2 + b1 + 1 , a2 + 1 , p ) - comb ( a1 + b2 + 1 , a1 , p ) + comb ( a1 + b1 , a1 , p ) <NEWLINE> print ( score % ( 10 ** 9 + 7 ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> grid [ h ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> number_yx = [ [ 0 , 0 ] for _ in range ( H * W + 1 ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> number_yx [ grid [ y ] [ x ] ] = [ y , x ] <NEWLINE> <DEDENT> <DEDENT> fromto_cost = defaultdict ( lambda : defaultdict ( int ) ) <NEWLINE> for mod_group in range ( D ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = mod_group + 1 <NEWLINE> previous = start <NEWLINE> fromto_cost [ start ] [ start ] = 0 <NEWLINE> previous_y , previous_x = number_yx [ previous ] <NEWLINE> cost = 0 <NEWLINE> while previous + D <= ( H * W ) : <NEWLINE> <INDENT> Next = previous + D <NEWLINE> Next_y , Next_x = number_yx [ Next ] <NEWLINE> cost += abs ( Next_y - previous_y ) + abs ( Next_x - previous_x ) <NEWLINE> fromto_cost [ start ] [ Next ] = cost <NEWLINE> <NL> previous = Next <NEWLINE> previous_y , previous_x = Next_y , Next_x <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> ans_ls = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> start , goal = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = start % D <NEWLINE> base = mod <NEWLINE> if base == 0 : <NEWLINE> <INDENT> base = D <NEWLINE> <DEDENT> base_to_goal = fromto_cost [ base ] [ goal ] <NEWLINE> base_to_start = fromto_cost [ base ] [ start ] <NEWLINE> ans_ls [ i ] = base_to_goal - base_to_start <NEWLINE> <DEDENT> for ans in ans_ls : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <NL> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> List . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> resList = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> resList [ List [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> if List [ i ] [ 1 ] < N : <NEWLINE> <INDENT> resList [ List [ i ] [ 1 ] ] += - 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> resList [ j ] = resList [ j ] + resList [ j - 1 ] <NEWLINE> <DEDENT> print ( resList . count ( M ) ) <NEWLINE>
N = input ( ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> now_mini = 1 << 20 <NEWLINE> for i in P : <NEWLINE> <INDENT> if i < now_mini : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> now_mini = i <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> k = int ( s [ 2 ] ) <NEWLINE> <NL> <NL> <NL> <NL> for i in range ( a , min ( b , a + k - 1 ) + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( b - k + 1 , a + k ) , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> kl = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * ( n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( a [ i ] - a [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> inf = 10 ** 7 <NEWLINE> dp = [ inf ] * 100005 <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( k , i ) + 1 ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> S_A = deque ( input ( ) ) <NEWLINE> S_B = deque ( input ( ) ) <NEWLINE> S_C = deque ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> next_turn = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( S_A ) == 0 and next_turn == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( S_B ) == 0 and next_turn == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( S_C ) == 0 and next_turn == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if next_turn == <STRING> : <NEWLINE> <INDENT> next_turn = S_A . popleft ( ) <NEWLINE> <DEDENT> elif next_turn == <STRING> : <NEWLINE> <INDENT> next_turn = S_B . popleft ( ) <NEWLINE> <DEDENT> elif next_turn == <STRING> : <NEWLINE> <INDENT> next_turn = S_C . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> p = 0 <NEWLINE> while x <= k : <NEWLINE> <INDENT> while y <= k : <NEWLINE> <INDENT> if x + y > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z = s - ( x + y ) <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> y += 1 <NEWLINE> <DEDENT> x += 1 <NEWLINE> y = 0 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 10 ** 18 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if cnt >= P [ i ] : <NEWLINE> <INDENT> cnt = P [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> x = math . gcd ( A , B ) <NEWLINE> <NL> def prime_decomposition ( x ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> ls = [ ] <NEWLINE> while i * i <= x : <NEWLINE> <INDENT> while x % i == 0 : <NEWLINE> <INDENT> x /= i <NEWLINE> ls . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if x > 1 : <NEWLINE> <INDENT> ls . append ( x ) <NEWLINE> <DEDENT> return ls <NEWLINE> <NL> <DEDENT> cnt = len ( set ( prime_decomposition ( x ) ) ) <NEWLINE> <NL> print ( cnt + 1 ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = ( s - i - j ) <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
T = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if T == str ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( T ) < 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if T [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> T = str ( T [ : - 5 ] ) <NEWLINE> <DEDENT> elif T [ - 7 : ] == <STRING> : <NEWLINE> <INDENT> T = str ( T [ : - 7 ] ) <NEWLINE> <DEDENT> elif T [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> T = str ( T [ : - 5 ] ) <NEWLINE> <DEDENT> elif T [ - 6 : ] == <STRING> : <NEWLINE> <INDENT> T = str ( T [ : - 6 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = gcd ( A , B ) <NEWLINE> ans = 1 <NEWLINE> i = 2 <NEWLINE> while i <= pow ( d , 1 / 2 ) + 1 : <NEWLINE> <INDENT> if d % i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> while d % i == 0 : <NEWLINE> <INDENT> d //= i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> ans += ( d > 1 ) <NEWLINE> print ( ans ) <NEWLINE>
from math import ceil , floor , comb , factorial , gcd , pow , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if len ( s ) < len ( t ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> reg = - 1 <NEWLINE> for i in range ( len ( s ) - len ( t ) , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != <STRING> and s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> reg = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if reg == - 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif reg == len ( s ) - len ( t ) : <NEWLINE> <INDENT> s = s [ : i ] + t <NEWLINE> ans = s . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s [ : i ] + t + s [ i + len ( t ) : ] <NEWLINE> ans = s . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> ab = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> l = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> parents = [ - 1 ] * ( n + 1 ) <NEWLINE> order = [ ] <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> while q : <NEWLINE> <INDENT> c = q . pop ( ) <NEWLINE> order . append ( c ) <NEWLINE> for i in l [ c ] : <NEWLINE> <INDENT> if i == parents [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parents [ i ] = c <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> color = [ - 1 ] * ( n + 1 ) <NEWLINE> for i in order : <NEWLINE> <INDENT> ng = color [ i ] <NEWLINE> c = 1 <NEWLINE> for j in l [ i ] : <NEWLINE> <INDENT> if j == parents [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c == ng : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> color [ j ] = c <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> if a == parents [ b ] : <NEWLINE> <INDENT> ans . append ( color [ b ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( color [ a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , ans ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans , ansf = 1 , n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = max ( ans , l ) <NEWLINE> ansf = min ( ansf , r ) <NEWLINE> <NL> <DEDENT> if ansf - ans < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ansf - ans + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def zz ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def z ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def S ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) <NEWLINE> <NL> <NL> <DEDENT> def C ( line ) : <NEWLINE> <INDENT> return [ sys . stdin . readline ( ) for _ in range ( line ) ] <NEWLINE> <NL> <NL> <DEDENT> N , K = zz ( ) <NEWLINE> A , B = [ 0 ] * N , [ 0 ] * N <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = zz ( ) <NEWLINE> <DEDENT> A , B = zip ( * sorted ( zip ( A , B ) ) ) <NEWLINE> all_num = 0 <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> all_num += b <NEWLINE> if ( all_num >= K ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> s = int ( input ( ) ) <NEWLINE> if s == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( s , 2 * s ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 3 , round ( math . sqrt ( s ) ) + 1 , 2 ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> if i % k == 0 : <NEWLINE> <INDENT> t = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> a = sorted ( a ) <NEWLINE> b = sorted ( b ) <NEWLINE> c = sorted ( c ) <NEWLINE> <NL> <COMMENT> <NL> def lower_bound ( arr , x ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = len ( c ) <NEWLINE> for j in range ( 30 ) : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> <COMMENT> <NL> if x <= arr [ mid ] : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_count = lower_bound ( a , b [ i ] ) <NEWLINE> c_count = len ( c ) - lower_bound ( c , b [ i ] + 1 ) <NEWLINE> count += a_count * c_count <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( mi ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ii ( ) <NEWLINE> x = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = mi ( ) <NEWLINE> x . append ( a + b ) <NEWLINE> ans -= b <NEWLINE> <DEDENT> x . sort ( reverse = True ) <NEWLINE> ans += sum ( x [ : : 2 ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> e1 , e2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> h = [ ] <NEWLINE> for i in range ( e2 ) : <NEWLINE> <INDENT> h . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> L . append ( h [ i ] [ 0 ] ) <NEWLINE> <DEDENT> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> R . append ( h [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> if min ( R ) >= max ( L ) : <NEWLINE> <INDENT> print ( min ( R ) - max ( L ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = dict ( ) <NEWLINE> for v in l : <NEWLINE> <INDENT> if v in d : <NEWLINE> <INDENT> d [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> if k <= v : <NEWLINE> <INDENT> c += v - k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += v <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = 2 <NEWLINE> l2 = 1 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( l2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> l = l + l2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 = l + l2 <NEWLINE> <NL> <DEDENT> <DEDENT> if i % 2 == 1 : <NEWLINE> <INDENT> print ( l2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
<NL> from collections import deque <NEWLINE> <NL> icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> elif icase == 1 : <NEWLINE> <INDENT> h , w = 2 , 3 <NEWLINE> a = [ [ 1 , 2 , 3 ] , [ 0 , 1 , 1 ] ] <NEWLINE> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> h , w = 3 , 2 <NEWLINE> a = [ [ 1 , 0 ] , [ 2 , 1 ] , [ 1 , 0 ] ] <NEWLINE> <DEDENT> elif icase == 3 : <NEWLINE> <INDENT> h , w = 1 , 5 <NEWLINE> a = [ [ 9 , 9 , 9 , 9 , 9 ] ] <NEWLINE> <NL> <NL> <DEDENT> astat = 0 <NEWLINE> im = - 1 <NEWLINE> jm = - 1 <NEWLINE> q = deque ( ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> wst = 0 <NEWLINE> wed = w <NEWLINE> wpt = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wst = w - 1 <NEWLINE> wed = - 1 <NEWLINE> wpt = - 1 <NEWLINE> <DEDENT> for j in range ( wst , wed , wpt ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i ] [ j ] % 2 == 1 and astat == 0 : <NEWLINE> <INDENT> astat = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif a [ i ] [ j ] % 2 == 1 and astat == 1 : <NEWLINE> <INDENT> q . append ( ( im , jm , i , j ) ) <NEWLINE> <COMMENT> <NL> astat = 0 <NEWLINE> <DEDENT> elif a [ i ] [ j ] % 2 == 0 and astat == 0 : <NEWLINE> <INDENT> astat = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> elif a [ i ] [ j ] % 2 == 0 and astat == 1 : <NEWLINE> <INDENT> astat = 1 <NEWLINE> q . append ( ( im , jm , i , j ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> im = i <NEWLINE> jm = j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( q ) ) <NEWLINE> for i in range ( len ( q ) ) : <NEWLINE> <INDENT> yf , xf , yt , xt = q . popleft ( ) <NEWLINE> stra = str ( yf + 1 ) + <STRING> + str ( xf + 1 ) + <STRING> + str ( yt + 1 ) + <STRING> + str ( xt + 1 ) <NEWLINE> print ( stra ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> def solve ( h , n ) : <NEWLINE> <INDENT> if ( 4 * h * n - N * n - N * h ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> w = N * h * n // ( 4 * h * n - N * n - N * h ) <NEWLINE> if w < 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if w * ( 4 * h * n - N * n - N * h ) == N * h * n : <NEWLINE> <INDENT> print ( h , n , w ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if N < 2000 : <NEWLINE> <INDENT> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> solve ( h , n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for h in reversed ( range ( 1 , 3501 ) ) : <NEWLINE> <INDENT> for n in reversed ( range ( 1 , 3501 ) ) : <NEWLINE> <INDENT> solve ( h , n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> i = 0 <NEWLINE> result = [ ] <NEWLINE> for a in S : <NEWLINE> <INDENT> if a == <STRING> or a == <STRING> or a == <STRING> or a == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> i = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> result . append ( i ) <NEWLINE> result . sort ( ) <NEWLINE> print ( result [ - 1 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ input ( ) for i in range ( N ) ] <NEWLINE> B = [ input ( ) for i in range ( M ) ] <NEWLINE> <NL> <NL> def serch ( x0 , y0 ) : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if x0 + i >= N or y0 + j >= N : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if A [ x0 + i ] [ y0 + j ] != B [ i ] [ j ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if M > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> for x in range ( N ) : <NEWLINE> <INDENT> for y in range ( N ) : <NEWLINE> <INDENT> if not serch ( x , y ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> dx = [ 0 , 1 , 0 , - 1 ] <NEWLINE> dy = [ - 1 , 0 , 1 , 0 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> for d in range ( 4 ) : <NEWLINE> <INDENT> if 0 <= i + dy [ d ] < h and 0 <= j + dx [ d ] < w : <NEWLINE> <INDENT> count += 1 if field [ i + dy [ d ] ] [ j + dx [ d ] ] == <STRING> else 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if count < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if 0 <= z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( A + B ) % 2 == 0 : <NEWLINE> <INDENT> print ( int ( ( A + B ) / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> used = [ False for _ in range ( n ) ] <NEWLINE> dp = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> def dfs ( pos ) : <NEWLINE> <INDENT> if not edges [ pos ] : <NEWLINE> <INDENT> dp [ pos ] = 0 <NEWLINE> return <NEWLINE> <DEDENT> for n_pos in edges [ pos ] : <NEWLINE> <INDENT> if not used [ n_pos ] : <NEWLINE> <INDENT> dfs ( n_pos ) <NEWLINE> <DEDENT> used [ n_pos ] = True <NEWLINE> dp [ pos ] = max ( dp [ pos ] , dp [ n_pos ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if used [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ i ] = True <NEWLINE> dfs ( i ) <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( n , a , b ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = a [ ( i - 1 ) % n ] + a [ ( i + 1 ) % n ] <NEWLINE> if m < a [ i ] and b [ i ] < a [ i ] : <NEWLINE> <INDENT> a [ i ] -= b [ i ] <NEWLINE> cnt += a [ i ] // m <NEWLINE> a [ i ] %= m <NEWLINE> a [ i ] += b [ i ] <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : break <NEWLINE> ans += cnt <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( n , a , b ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] <NEWLINE> p = [ ] <NEWLINE> q = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p . append ( dp [ A [ i ] - 1 ] ) <NEWLINE> q . append ( A [ i ] ) <NEWLINE> <DEDENT> bp = [ [ 0 , 0 ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( p ) ) : <NEWLINE> <INDENT> if i + p [ j ] > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if bp [ i ] [ 0 ] == 0 : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> bp [ i + p [ j ] ] [ 0 ] = max ( bp [ i + p [ j ] ] [ 0 ] , bp [ i ] [ 0 ] + ( 10 ** bp [ i ] [ 1 ] ) * q [ j ] ) <NEWLINE> bp [ i + p [ j ] ] [ 1 ] = bp [ i ] [ 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> print ( bp [ N ] [ 0 ] ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> board = [ [ <STRING> ] * m for _ in range ( n ) ] <NEWLINE> if n * m < 2 * ( a + b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n == 1 or m == 1 : <NEWLINE> <INDENT> if n == 1 and m == 1 : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> if b >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if m // 2 < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( 0 , m // 2 ) : <NEWLINE> <INDENT> board [ 0 ] [ 2 * x ] = <STRING> <NEWLINE> board [ 0 ] [ 2 * x + 1 ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , board [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif m == 1 : <NEWLINE> <INDENT> if a >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n // 2 < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for y in range ( 0 , n // 2 ) : <NEWLINE> <INDENT> board [ 2 * y ] [ 0 ] = <STRING> <NEWLINE> board [ 2 * y + 1 ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , board [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( n * m ) % 2 != 1 : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> tmp = min ( m // 2 , a ) <NEWLINE> a -= tmp <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> board [ n - 1 ] [ 2 * i ] = <STRING> <NEWLINE> board [ n - 1 ] [ 2 * i + 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if m % 2 == 1 : <NEWLINE> <INDENT> tmp = min ( n // 2 , b ) <NEWLINE> b -= tmp <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> board [ 2 * i ] [ m - 1 ] = <STRING> <NEWLINE> board [ 2 * i + 1 ] [ m - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for y in range ( 0 , n - ( n % 2 ) , 2 ) : <NEWLINE> <INDENT> for x in range ( 0 , m - ( m % 2 ) , 2 ) : <NEWLINE> <INDENT> if a >= 2 : <NEWLINE> <INDENT> a -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b >= 2 : <NEWLINE> <INDENT> b -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a != 0 or b != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , board [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> tmp = min ( m // 2 - 1 , a ) <NEWLINE> a -= tmp <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> board [ n - 1 ] [ 2 * i ] = <STRING> <NEWLINE> board [ n - 1 ] [ 2 * i + 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if m % 2 == 1 : <NEWLINE> <INDENT> tmp = min ( n // 2 - 1 , b ) <NEWLINE> b -= tmp <NEWLINE> for i in range ( tmp ) : <NEWLINE> <INDENT> board [ 2 * i ] [ m - 1 ] = <STRING> <NEWLINE> board [ 2 * i + 1 ] [ m - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for y in range ( 0 , n - 2 , 2 ) : <NEWLINE> <INDENT> for x in range ( 0 , m - 2 , 2 ) : <NEWLINE> <INDENT> if y == n - 3 and x == m - 3 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a >= b : <NEWLINE> <INDENT> if a >= 2 : <NEWLINE> <INDENT> a -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b >= 2 : <NEWLINE> <INDENT> b -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a >= 4 or b >= 4 or a + b >= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = m - 3 <NEWLINE> y = n - 3 <NEWLINE> if a == 2 and b == 2 : <NEWLINE> <INDENT> a -= 2 <NEWLINE> b -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y ] [ x + 2 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 2 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y + 2 ] [ x ] = <STRING> <NEWLINE> board [ y + 2 ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 2 ] [ x + 2 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a != 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> board [ y + 2 ] [ x ] = <STRING> <NEWLINE> board [ y + 2 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> if b != 0 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> board [ y ] [ x + 2 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 2 ] = <STRING> <NEWLINE> <DEDENT> if a >= 2 : <NEWLINE> <INDENT> a -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b >= 2 : <NEWLINE> <INDENT> b -= 2 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> board [ y ] [ x + 1 ] = <STRING> <NEWLINE> board [ y + 1 ] [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> board [ y + 1 ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , board [ i ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> import bisect <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ab = l [ i ] + l [ j ] <NEWLINE> right = bisect . bisect ( l , ab - 1 ) <NEWLINE> left = j + 1 <NEWLINE> count += ( right - left ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def cal ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> counts = [ [ True for _ in range ( w + 2 ) ] ] + [ [ True ] + [ False ] * w + [ True ] for _ in range ( h ) ] + [ [ True for _ in range ( w + 2 ) ] ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if a [ j ] == <STRING> : <NEWLINE> <INDENT> q . append ( [ i + 1 , j + 1 , 0 ] ) <NEWLINE> counts [ i + 1 ] [ j + 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while q : <NEWLINE> <INDENT> x , y , z = q . popleft ( ) <NEWLINE> if not counts [ x + 1 ] [ y ] : <NEWLINE> <INDENT> counts [ x + 1 ] [ y ] = True <NEWLINE> q . append ( [ x + 1 , y , z + 1 ] ) <NEWLINE> <DEDENT> if not counts [ x - 1 ] [ y ] : <NEWLINE> <INDENT> counts [ x - 1 ] [ y ] = True <NEWLINE> q . append ( [ x - 1 , y , z + 1 ] ) <NEWLINE> <DEDENT> if not counts [ x ] [ y + 1 ] : <NEWLINE> <INDENT> counts [ x ] [ y + 1 ] = True <NEWLINE> q . append ( [ x , y + 1 , z + 1 ] ) <NEWLINE> <DEDENT> if not counts [ x ] [ y - 1 ] : <NEWLINE> <INDENT> counts [ x ] [ y - 1 ] = True <NEWLINE> q . append ( [ x , y - 1 , z + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE> <NL> <NL> <DEDENT> cal ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> temp = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = data [ temp - 1 ] <NEWLINE> count += 1 <NEWLINE> if temp == 2 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A , B , C , D , E , F = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> CCT = { } <NEWLINE> for a in range ( F // ( 100 * A ) + 1 ) : <NEWLINE> <INDENT> for b in range ( F // ( 100 * B ) + 1 ) : <NEWLINE> <INDENT> water = ( a * A + b * B ) * 100 <NEWLINE> if water > F : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> max_suger = water * E // 100 <NEWLINE> for c in range ( max_suger // C + 1 ) : <NEWLINE> <INDENT> for d in range ( max_suger // D + 1 ) : <NEWLINE> <INDENT> suger = c * C + d * D <NEWLINE> total = water + suger <NEWLINE> if total > F or total == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if max_suger < suger : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> CCT [ water , suger ] = suger / total <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = ( A * 100 , 0 ) <NEWLINE> max_cct = 0 <NEWLINE> for ( water , suger ) , cct in CCT . items ( ) : <NEWLINE> <INDENT> if cct > max_cct : <NEWLINE> <INDENT> max_cct = cct <NEWLINE> ans = ( water + suger , suger ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n , d , a = MAP ( ) <NEWLINE> xh = [ LIST ( ) for i in range ( n ) ] <NEWLINE> <NL> xh = sorted ( xh , key = lambda x : ( x [ 0 ] ) ) <NEWLINE> q = deque ( ) <NEWLINE> ca = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cx , ch = xh [ i ] [ 0 ] , xh [ i ] [ 1 ] <NEWLINE> <NL> while q and q [ 0 ] [ 0 ] < cx : <NEWLINE> <INDENT> qx , qa = q . popleft ( ) <NEWLINE> ca -= qa <NEWLINE> <NL> <DEDENT> if ch - ca <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cn = ( ch - ca + a - 1 ) // a <NEWLINE> cnt += cn <NEWLINE> ca += cn * a <NEWLINE> q . append ( [ cx + 2 * d , cn * a ] ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( int ( N * ( N - 1 ) // 2 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> g = math . gcd ( c , d ) <NEWLINE> l = int ( c * d / g ) <NEWLINE> <NL> less_b = b - ( b // c + b // d - b // l ) <NEWLINE> less_a = ( a - 1 ) - ( ( a - 1 ) // c + ( a - 1 ) // d - ( a - 1 ) // l ) <NEWLINE> print ( less_b - less_a ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> S . sort ( ) <NEWLINE> <NL> sum_ = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> sum_ += s <NEWLINE> <NL> <DEDENT> print ( sum_ ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> def expo ( x ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in reversed ( range ( 1 , x + 1 ) ) : <NEWLINE> <INDENT> for j in range ( int ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 2 , int ( math . sqrt ( x ) ) ) : <NEWLINE> <INDENT> if i == j ** k : <NEWLINE> <INDENT> ans = i <NEWLINE> return ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( expo ( X ) ) <NEWLINE>
import collections <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> WA_CNT = { } <NEWLINE> CLEAR = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> P , S = input ( ) . split ( ) <NEWLINE> if P in CLEAR : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> CLEAR [ P ] = 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if not P in WA_CNT : <NEWLINE> <INDENT> WA_CNT [ P ] = 0 <NEWLINE> <DEDENT> WA_CNT [ P ] += 1 <NEWLINE> <NL> <NL> <DEDENT> num = len ( CLEAR ) <NEWLINE> try_num = 0 <NEWLINE> for i in CLEAR : <NEWLINE> <INDENT> if i in WA_CNT : <NEWLINE> <INDENT> try_num += WA_CNT [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( num , try_num ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = [ 0 for i in range ( n ) ] <NEWLINE> y = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = x [ j ] - x [ i ] , y [ j ] - y [ i ] <NEWLINE> if v not in a : <NEWLINE> <INDENT> a [ v ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = n <NEWLINE> <COMMENT> <NL> if len ( a . values ( ) ) > 0 : <NEWLINE> <INDENT> ans -= max ( a . values ( ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
R , G , B , n = map ( int , input ( ) . split ( ) ) <NEWLINE> r = n // R <NEWLINE> g = n // G <NEWLINE> b = n // B <NEWLINE> ans = 0 <NEWLINE> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( ( n - R * i ) // G + 1 ) : <NEWLINE> <INDENT> if ( n - i * R - j * G ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> P = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( M - 1 ) : <NEWLINE> <INDENT> if A [ i ] + 1 == A [ i + 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> broken = [ False ] * ( N + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> broken [ a ] = True <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 if not broken [ 1 ] else 0 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if broken [ i ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % P <NEWLINE> <NL> <DEDENT> <DEDENT> ans = dp [ N ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( [ 1 for z in range ( k + 1 ) for y in range ( k + 1 ) if 0 <= s - y - z <= k ] ) ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> minimum = 2019 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if minimum == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 == 0 : <NEWLINE> <INDENT> minimum = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( i * j ) % 2019 < minimum : <NEWLINE> <INDENT> minimum = ( i * j ) % 2019 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> B = [ ] <NEWLINE> W = [ ] <NEWLINE> i = 0 <NEWLINE> fin = None <NEWLINE> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> B . append ( 1 ) <NEWLINE> fin = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> i += 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> fin = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> B . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> W . append ( 1 ) <NEWLINE> fin = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> i += 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> fin = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> W . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( B ) <NEWLINE> L = len ( B ) + len ( W ) <NEWLINE> B = B [ : : - 1 ] <NEWLINE> W = W [ : : - 1 ] <NEWLINE> now = ans <NEWLINE> if fin : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> now -= B [ i // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += W [ i // 2 ] <NEWLINE> <DEDENT> ans = min ( ans , now ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> now -= B [ i // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += W [ i // 2 ] <NEWLINE> <DEDENT> ans = min ( ans , now ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> import heapq <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> num = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , ( - num // 2 ) * ( - 1 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> def fibonacci ( n ) : <NEWLINE> <INDENT> fib = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> fib . append ( fib [ i - 2 ] + fib [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> return fib [ n - 1 ] <NEWLINE> <DEDENT> print ( fibonacci ( n + 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> prev = [ ] <NEWLINE> next = 0 <NEWLINE> count = 0 <NEWLINE> while ( count < N ) : <NEWLINE> <INDENT> next = int ( A [ next ] ) - 1 <NEWLINE> count += 1 <NEWLINE> if ( next == 1 ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> pre = <STRING> <NEWLINE> tmp = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> tmp += s <NEWLINE> if tmp != pre : <NEWLINE> <INDENT> pre = tmp <NEWLINE> tmp = <STRING> <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = [ ] <NEWLINE> <NL> if r - l >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( l + 1 , r + 1 ) : <NEWLINE> <INDENT> t . append ( ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( t ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> numlist = [ str ( i ) for i in range ( 10 ) ] <NEWLINE> for a in numlist : <NEWLINE> <INDENT> idx_a = S . find ( a ) <NEWLINE> if idx_a == - 1 or idx_a >= N - 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for b in numlist : <NEWLINE> <INDENT> idx_b = S [ idx_a + 1 : ] . find ( b ) <NEWLINE> if idx_b == - 1 or idx_a + idx_b + 1 >= N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for c in numlist : <NEWLINE> <INDENT> if c in S [ idx_a + idx_b + 2 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( A ) <NEWLINE> <DEDENT> a = sorted ( a , key = lambda x : x [ 0 ] ) <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] [ 1 ] <NEWLINE> if b >= k : <NEWLINE> <INDENT> print ( a [ i ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> s = len ( S ) <NEWLINE> T = input ( ) <NEWLINE> t = len ( T ) <NEWLINE> <NL> key = 0 <NEWLINE> for i in range ( s - t , - 1 , - 1 ) : <NEWLINE> <INDENT> for j , k in enumerate ( S [ i : i + t ] ) : <NEWLINE> <INDENT> if k == T [ j ] or k == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> key = i <NEWLINE> break <NEWLINE> <DEDENT> key = 100 <NEWLINE> <DEDENT> if key == 100 or s < t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = S [ 0 : i ] + T + S [ i + t : ] <NEWLINE> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = [ list ( input ( ) ) for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> for j in range ( n - m + 1 ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> for l in range ( m ) : <NEWLINE> <INDENT> if a [ i + k ] [ j + l ] != b [ k ] [ l ] : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b - a <= k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i not in ans : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if j not in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> check = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if check > P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> check = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> s = [ <STRING> . join ( sorted ( list ( SS ( ) ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> cnt = collections . Counter ( s ) <NEWLINE> ans = sum ( [ i * ( i - 1 ) // 2 for i in cnt . values ( ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pat = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> pat += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( pat ) <NEWLINE>
import math <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : return b <NEWLINE> return gcd ( b % a , a ) <NEWLINE> <DEDENT> def div ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> while temp % i == 0 : <NEWLINE> <INDENT> temp //= i <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> return cnt + 1 <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( div ( gcd ( a , b ) ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + k + 1 <= b : <NEWLINE> <INDENT> for i in range ( a , k + a ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> if a + k + 1 <= b + 1 - k : <NEWLINE> <INDENT> for i in range ( b + 1 - k , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a + k , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> calc = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> calc = ( i * calc ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( calc ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> dish = [ a , b , c , d , e ] <NEWLINE> last = 0 <NEWLINE> for index , d in enumerate ( dish ) : <NEWLINE> <INDENT> if d % 10 != 0 : <NEWLINE> <INDENT> d10 = ( ( d // 10 ) + 1 ) * 10 <NEWLINE> if last <= d10 - d : <NEWLINE> <INDENT> last = d10 - d <NEWLINE> <DEDENT> dish [ index ] = d10 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( dish ) - last ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> from collections import Counter <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> x = Counter ( a ) <NEWLINE> print ( sum ( list ( map ( lambda n : n % 2 , list ( x . values ( ) ) ) ) ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( len ( s ) - abs ( s . count ( <STRING> ) - s . count ( <STRING> ) ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ input ( ) for _ in range ( H ) ] <NEWLINE> sy , sx , gy , gx = 0 , 0 , H - 1 , W - 1 <NEWLINE> seen = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> <NL> if G [ sy ] [ sx ] == <STRING> or G [ gy ] [ gx ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> que = deque ( ) <NEWLINE> que . append ( [ sy , sx ] ) <NEWLINE> seen [ sy ] [ sx ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> y , x = que . popleft ( ) <NEWLINE> for d in [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] : <NEWLINE> <INDENT> dy = y + d [ 0 ] <NEWLINE> dx = x + d [ 1 ] <NEWLINE> if dy < 0 or H <= dy or dx < 0 or W <= dx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if G [ dy ] [ dx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if seen [ dy ] [ dx ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . append ( [ dy , dx ] ) <NEWLINE> seen [ dy ] [ dx ] = seen [ y ] [ x ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> bunpu = [ 0 ] * ( H * W + 1 ) <NEWLINE> if seen [ gy ] [ gx ] == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> all = H * W <NEWLINE> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if G [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = all - black - seen [ gy ] [ gx ] - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ S ] * N <NEWLINE> m = 10 ** 9 <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans [ i ] %= m <NEWLINE> ans [ i ] += 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , * v = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> vo = Counter ( v [ : : 2 ] ) <NEWLINE> ve = Counter ( v [ 1 : : 2 ] ) <NEWLINE> vo_mc = vo . most_common ( ) [ 0 ] <NEWLINE> ve_mc = ve . most_common ( ) [ 0 ] <NEWLINE> if vo_mc [ 0 ] == ve_mc [ 0 ] : <NEWLINE> <INDENT> if vo_mc [ 1 ] > ve_mc [ 1 ] : <NEWLINE> <INDENT> ans = n // 2 - vo_mc [ 1 ] <NEWLINE> if ve_mc [ 1 ] != n // 2 : <NEWLINE> <INDENT> ans += n // 2 - ve . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // 2 <NEWLINE> <DEDENT> <DEDENT> elif vo_mc [ 1 ] < ve_mc [ 1 ] : <NEWLINE> <INDENT> ans = n // 2 - ve_mc [ 1 ] <NEWLINE> if vo_mc [ 1 ] != n // 2 : <NEWLINE> <INDENT> ans += n // 2 - vo . most_common ( ) [ 1 ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = n <NEWLINE> if ve_mc [ 1 ] != n // 2 : <NEWLINE> <INDENT> ans = min ( n // 2 - vo_mc [ 1 ] + n // 2 - ve . most_common ( ) [ 1 ] [ 1 ] , ans ) <NEWLINE> <DEDENT> if vo_mc [ 1 ] != n // 2 : <NEWLINE> <INDENT> ans = min ( n // 2 - vo . most_common ( ) [ 1 ] [ 1 ] + n // 2 - ve_mc [ 1 ] , ans ) <NEWLINE> <DEDENT> ans = min ( n // 2 - vo_mc [ 1 ] + n // 2 , ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = n // 2 - vo_mc [ 1 ] + n // 2 - ve_mc [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> cs = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> from collections import defaultdict <NEWLINE> prev = - 1 <NEWLINE> c_comp = [ ] <NEWLINE> <COMMENT> <NL> for c in cs : <NEWLINE> <INDENT> if prev != c : <NEWLINE> <INDENT> c_comp . append ( c ) <NEWLINE> <DEDENT> prev = c <NEWLINE> <NL> <DEDENT> d = defaultdict ( list ) <NEWLINE> for i , c in enumerate ( c_comp ) : <NEWLINE> <INDENT> d [ c ] . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> dp = [ 0 ] * 220000 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> inds = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i , c in enumerate ( c_comp ) : <NEWLINE> <INDENT> i_prev = d [ c ] [ inds [ c ] - 1 ] <NEWLINE> if inds [ c ] >= 1 : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 ] += dp [ i ] + dp [ i_prev + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> dp [ i + 1 ] %= mod <NEWLINE> inds [ c ] += 1 <NEWLINE> <DEDENT> print ( dp [ len ( c_comp ) ] ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> def add ( a , b ) : <NEWLINE> <INDENT> return ( a + b ) % mod <NEWLINE> <NL> <DEDENT> def sub ( a , b ) : <NEWLINE> <INDENT> return ( a + mod - b ) % mod <NEWLINE> <NL> <DEDENT> def mul ( a , b ) : <NEWLINE> <INDENT> return ( ( a % mod ) * ( b % mod ) ) % mod <NEWLINE> <NL> <DEDENT> def power ( x , y ) : <NEWLINE> <INDENT> if y == 0 : return 1 <NEWLINE> elif y == 1 : return x % mod <NEWLINE> elif y % 2 == 0 : return power ( x , y // 2 ) ** 2 % mod <NEWLINE> else : return power ( x , y // 2 ) ** 2 * x % mod <NEWLINE> <NL> <DEDENT> def div ( a , b ) : <NEWLINE> <INDENT> return mul ( a , power ( b , mod - 2 ) ) <NEWLINE> <NL> <DEDENT> def cc ( ii ) : <NEWLINE> <INDENT> iii = 1 <NEWLINE> for ii in range ( 1 , ii + 1 ) : <NEWLINE> <INDENT> iii = iii * ii <NEWLINE> <DEDENT> return iii <NEWLINE> <NL> <DEDENT> def cmb ( a , b ) : <NEWLINE> <INDENT> iii = 1 <NEWLINE> for ii in range ( a - b + 1 , a + 1 ) : <NEWLINE> <INDENT> iii = ( iii * ii ) % mod <NEWLINE> <DEDENT> iiii = 1 <NEWLINE> for ii in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> iiii = ( iiii * ii ) % mod <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return div ( iii , iiii ) <NEWLINE> <NL> <DEDENT> from functools import reduce <NEWLINE> <NL> def cmb2 ( n , r ) : <NEWLINE> <INDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : return 1 <NEWLINE> if r == 1 : return n <NEWLINE> over = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return div ( over , under ) <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ib = k - 1 <NEWLINE> ir = n - ib <NEWLINE> <NL> for i in range ( 1 , ib + 2 ) : <NEWLINE> <INDENT> if i > ir : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cb = cmb2 ( ib , i - 1 ) <NEWLINE> cr = cmb2 ( ir , i ) <NEWLINE> <COMMENT> <NL> print ( mul ( cb , cr ) ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from itertools import combinations <NEWLINE> <NL> <COMMENT> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . table = [ - 1 ] * n <NEWLINE> self . n = n <NEWLINE> self . inconvenience = n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> def _root ( self , x ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> tbl = self . table <NEWLINE> while tbl [ x ] >= 0 : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> x = tbl [ x ] <NEWLINE> <DEDENT> for y in stack : <NEWLINE> <INDENT> tbl [ y ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def find ( self , x , y ) : <NEWLINE> <INDENT> return self . _root ( x ) == self . _root ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> r1 = self . _root ( x ) <NEWLINE> r2 = self . _root ( y ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> d1 = self . table [ r1 ] <NEWLINE> d2 = self . table [ r2 ] <NEWLINE> self . inconvenience -= d1 * d2 <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> self . table [ r2 ] = r1 <NEWLINE> self . table [ r1 ] += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . table [ r1 ] = r2 <NEWLINE> self . table [ r2 ] += d1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bridges = [ tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ans = [ 0 ] * m <NEWLINE> ans [ - 1 ] = n * ( n - 1 ) // 2 <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> uf . union ( * bridges [ i + 1 ] ) <NEWLINE> ans [ i ] = uf . inconvenience <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> white = s . count ( <STRING> ) <NEWLINE> ans , black = white , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> white -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> tmp = black + white <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import queue <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ma = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ma [ a ] . append ( b ) <NEWLINE> ma [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> global ans <NEWLINE> if all ( reach [ 1 : ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in ma [ i ] : <NEWLINE> <INDENT> if reach [ j ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> reach [ j ] = 1 <NEWLINE> dfs ( j ) <NEWLINE> reach [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> reach = [ 0 ] * ( n + 1 ) <NEWLINE> reach [ 1 ] = 1 <NEWLINE> dfs ( 1 ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pascal_triangle = [ ] <NEWLINE> <NL> memo = [ [ 0 for _ in range ( 51 ) ] for _ in range ( 51 ) ] <NEWLINE> <NL> def c ( n , k ) : <NEWLINE> <INDENT> if memo [ n ] [ k ] != 0 : <NEWLINE> <INDENT> return memo [ n ] [ k ] <NEWLINE> <DEDENT> if ( k <= 0 or n <= k ) : <NEWLINE> <INDENT> memo [ n ] [ k ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = c ( n - 1 , k - 1 ) + c ( n - 1 , k ) <NEWLINE> memo [ n ] [ k ] = ans <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 51 ) : <NEWLINE> <INDENT> pascal_triangle . append ( [ c ( i , j ) for j in range ( i + 1 ) ] ) <NEWLINE> <NL> <DEDENT> Numbers_1 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Numbers_1 += A [ i ] % 2 <NEWLINE> <NL> <DEDENT> Select_0_count = sum ( pascal_triangle [ N - Numbers_1 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( Numbers_1 + 1 ) : <NEWLINE> <INDENT> if i % 2 == P : <NEWLINE> <INDENT> ans += pascal_triangle [ Numbers_1 ] [ i ] * Select_0_count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> board = [ [ i for i in input ( ) ] for _ in range ( h ) ] <NEWLINE> <NL> def check ( i , j ) : <NEWLINE> <INDENT> if ( j - 1 >= 0 ) : <NEWLINE> <INDENT> if ( board [ i ] [ j - 1 ] == <STRING> ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if ( j + 1 < w ) : <NEWLINE> <INDENT> if ( board [ i ] [ j + 1 ] == <STRING> ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if ( i - 1 >= 0 ) : <NEWLINE> <INDENT> if ( board [ i - 1 ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if ( i + 1 < h ) : <NEWLINE> <INDENT> if ( board [ i + 1 ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( board [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> if ( check ( i , j ) ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
def f ( gx , gy ) : <NEWLINE> <INDENT> ans = 10 ** 9 <NEWLINE> no = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> tmp = abs ( gx - checkpoint [ i ] [ 0 ] ) + abs ( gy - checkpoint [ i ] [ 1 ] ) <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> no = i <NEWLINE> <DEDENT> <DEDENT> return no + 1 <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> gakusei = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> gakusei . append ( [ x , y ] ) <NEWLINE> <DEDENT> checkpoint = [ ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> checkpoint . append ( [ x , y ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( f ( gakusei [ i ] [ 0 ] , gakusei [ i ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> bound = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> pos = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pos += bound [ i ] <NEWLINE> if pos <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if pos > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> b = [ ] <NEWLINE> a = a [ : : - 1 ] <NEWLINE> for i in range ( n ) [ : : 2 ] : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> a = a [ : : - 1 ] <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> a . pop ( 0 ) <NEWLINE> <DEDENT> for i in range ( len ( a ) ) [ : : 2 ] : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( lambda x : ( int ( x ) + 1 ) / 2 , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( p [ : k ] ) <NEWLINE> ans = s <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> s -= p [ i - k ] <NEWLINE> s += p [ i ] <NEWLINE> ans = max ( ans , s ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 1 <NEWLINE> t = P [ 0 ] <NEWLINE> for i in range ( len ( P ) - 1 ) : <NEWLINE> <INDENT> if t > P [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> t = P [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <NL> <NL>
H = int ( input ( ) ) <NEWLINE> <NL> def battle ( h ) : <NEWLINE> <INDENT> if h == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 * battle ( h // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( battle ( H ) ) <NEWLINE> <NL>
class BITmax : <NEWLINE> <INDENT> def __init__ ( self , N , init = 0 ) : <NEWLINE> <INDENT> self . init = init <NEWLINE> self . tree = [ self . init ] * ( N + 1 ) <NEWLINE> <NL> <DEDENT> def set ( self , x , value ) : <NEWLINE> <INDENT> while x < N + 1 : <NEWLINE> <INDENT> old = self . tree [ x ] <NEWLINE> if value <= old : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . tree [ x ] = value <NEWLINE> x += x & - x <NEWLINE> <NL> <DEDENT> <DEDENT> def find_max_to ( self , x ) : <NEWLINE> <INDENT> result = self . init <NEWLINE> while x > 0 : <NEWLINE> <INDENT> result = max ( result , self . tree [ x ] ) <NEWLINE> x -= x & - x <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> dpt = BITmax ( N ) <NEWLINE> <NL> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for h , b in zip ( h_list , b_list ) : <NEWLINE> <INDENT> dpt . set ( h , dpt . find_max_to ( h - 1 ) + b ) <NEWLINE> <NL> <DEDENT> print ( max ( dpt . tree ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = n // 2 <NEWLINE> if sum ( a ) / 2 == sum ( a [ : ( n // 2 ) ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif sum ( a ) / 2 >= sum ( a [ : ( n // 2 ) ] ) : <NEWLINE> <INDENT> while sum ( a ) / 2 >= sum ( a [ : x ] ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> print ( min ( abs ( 2 * sum ( a [ : x ] ) - sum ( a ) ) , abs ( 2 * sum ( a [ : x - 1 ] ) - sum ( a ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while sum ( a ) / 2 <= sum ( a [ : x ] ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> print ( min ( abs ( 2 * sum ( a [ : x ] ) - sum ( a ) ) , abs ( 2 * sum ( a [ : x + 1 ] ) - sum ( a ) ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( 1 , math . ceil ( math . sqrt ( m ) ) ) : <NEWLINE> <INDENT> if m % n == 0 : <NEWLINE> <INDENT> print ( m // n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if m % i == 0 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> b . append ( m // i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ i ] * n <= m : <NEWLINE> <INDENT> a . append ( b [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if len ( b ) == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Graph = [ [ ] for i in range ( n ) ] <NEWLINE> seen = [ False ] * n <NEWLINE> point = [ 0 ] * n <NEWLINE> <NL> <NL> def dfs ( g , v , p ) : <NEWLINE> <COMMENT> <NL> <INDENT> seen [ v ] = True <NEWLINE> if p != - 1 : point [ v ] += point [ p ] <NEWLINE> <NL> <COMMENT> <NL> for next_v in g [ v ] : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if seen [ next_v ] : continue <NEWLINE> <NL> <COMMENT> <NL> dfs ( g , next_v , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <COMMENT> <NL> Graph [ a ] . append ( b ) <NEWLINE> Graph [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> x , p = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ x - 1 ] += p <NEWLINE> <NL> <NL> <DEDENT> dfs ( Graph , 0 , - 1 ) <NEWLINE> <NL> <NL> print ( * point ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , groupby , combinations_with_replacement <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> p = LIST ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> for i , x in enumerate ( p ) : <NEWLINE> <INDENT> if i + 1 == x : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> S = set ( [ ] ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + 1 + K ) : <NEWLINE> <COMMENT> <NL> <INDENT> S . add ( s [ i : j ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = sorted ( S ) [ K - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = [ 0 ] * M <NEWLINE> s = [ 0 ] * M <NEWLINE> b = [ 0 ] * N <NEWLINE> pena = 0 <NEWLINE> corr = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> p [ i ] , s [ i ] = input ( ) . split ( ) <NEWLINE> p [ i ] = int ( p [ i ] ) <NEWLINE> if b [ p [ i ] - 1 ] != - 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> pena += b [ p [ i ] - 1 ] <NEWLINE> corr += 1 <NEWLINE> b [ p [ i ] - 1 ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ p [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( corr , pena ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def calk1 ( n ) : <NEWLINE> <INDENT> if n == 0 : return 0 <NEWLINE> m = int ( math . log10 ( n ) ) <NEWLINE> num = m * 9 <NEWLINE> num += n // ( 10 ** m ) <NEWLINE> return num <NEWLINE> <NL> <DEDENT> def calk2 ( n ) : <NEWLINE> <INDENT> m = int ( math . log10 ( n ) ) <NEWLINE> num = m * ( m - 1 ) // 2 * 9 ** 2 <NEWLINE> num += ( n // ( 10 ** m ) - 1 ) * m * 9 <NEWLINE> num += calk1 ( n - ( n // ( 10 ** m ) * 10 ** m ) ) <NEWLINE> return num <NEWLINE> <NL> <DEDENT> def calk3 ( n ) : <NEWLINE> <INDENT> m = int ( math . log10 ( n ) ) <NEWLINE> num = m * ( m - 1 ) * ( m - 2 ) // 6 * 9 ** 3 <NEWLINE> num += ( n // ( 10 ** m ) - 1 ) * ( m * ( m - 1 ) // 2 * 9 ** 2 ) <NEWLINE> num += calk2 ( n - ( n // ( 10 ** m ) * 10 ** m ) ) <NEWLINE> return num <NEWLINE> <DEDENT> if n < 10 ** ( K - 1 ) : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> if K == 1 : print ( calk1 ( n ) ) <NEWLINE> elif K == 2 : print ( calk2 ( n ) ) <NEWLINE> else : print ( calk3 ( n ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = str ( input ( ) ) <NEWLINE> c = b . count ( <STRING> ) <NEWLINE> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n , m = INTM ( ) <NEWLINE> b_sts = [ False ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b = INT ( ) <NEWLINE> b -= 1 <NEWLINE> b_sts [ b ] = True <NEWLINE> <NL> <DEDENT> step = [ 0 ] * ( n + 2 ) <NEWLINE> step [ 1 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b_sts [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step [ i + 2 ] = ( step [ i + 1 ] + step [ i ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( step [ - 1 ] % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if B [ i ] >= B [ i + 1 ] : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> a = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <NL> <INDENT> if ans [ j ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = max ( a , cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from math import gcd <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] // gcd ( ans , a [ i ] ) <NEWLINE> <DEDENT> s = sum ( pow ( x , mod - 2 , mod ) for x in a ) <NEWLINE> print ( s * ans % mod ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> stores = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> sorted_sotres = sorted ( stores , key = lambda x : x [ 0 ] ) <NEWLINE> total = 0 <NEWLINE> ans = 0 <NEWLINE> for cost , number in sorted_sotres : <NEWLINE> <INDENT> if number > m : <NEWLINE> <INDENT> ans += cost * m <NEWLINE> break <NEWLINE> <DEDENT> elif number == m : <NEWLINE> <INDENT> ans += cost * number <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cost * number <NEWLINE> <DEDENT> m -= number <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A - K >= 0 : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( 0 , B + A - K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
from collections import deque , defaultdict <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 ; <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> visited = [ False for _ in range ( N ) ] <NEWLINE> color = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> def dfs ( now , c ) : <NEWLINE> <NL> <INDENT> color [ now ] = c <NEWLINE> <NL> for adj in graph [ now ] : <NEWLINE> <INDENT> if color [ adj ] == c : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if color [ adj ] == 0 and not dfs ( adj , - c ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> ans = dfs ( 0 , 1 ) <NEWLINE> white = color . count ( - 1 ) <NEWLINE> black = N - white <NEWLINE> if ans : <NEWLINE> <INDENT> print ( black * white - M ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * ( N - 1 ) // 2 - M ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> def ncr ( n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> r = min ( r , n - r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> numer = functools . reduce ( operator . mul , range ( n , n - r , - 1 ) , 1 ) <NEWLINE> denom = functools . reduce ( operator . mul , range ( 1 , r + 1 ) , 1 ) <NEWLINE> return numer // denom % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans = ( ncr ( k - 1 , i - 1 ) * ncr ( n - k + 1 , i ) ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) . rstrip ( ) <NEWLINE> <NL> lst = [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> lst . append ( lst [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( lst [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lst [ r - 1 ] - lst [ l - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> print ( N // 2 , N , N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if N < 4 * i : <NEWLINE> <INDENT> n = 4 * i - N <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> j , k = 2 * N * i , 2 * N * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> j , k = 2 * N * i // 3 , 2 * N * i // 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( 100 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> for y in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> if ( ( N * i ) % y == 0 ) and ( ( N * i ) % ( n - y ) == 0 ) : <NEWLINE> <INDENT> j = ( N * i ) // y <NEWLINE> k = ( N * i ) // ( n - y ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> n += 4 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( i , j , k ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = a [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> if x <= m : <NEWLINE> <INDENT> ans += 1 <NEWLINE> m = x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import collections <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> a , b = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> af = factorization ( a ) <NEWLINE> bf = factorization ( b ) <NEWLINE> <NL> c = collections . Counter ( ) <NEWLINE> c [ 1 ] = 2 <NEWLINE> for x in af : <NEWLINE> <INDENT> c [ x [ 0 ] ] += 1 <NEWLINE> <DEDENT> for x in bf : <NEWLINE> <INDENT> c [ x [ 0 ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for k in c . keys ( ) : <NEWLINE> <INDENT> if c [ k ] >= 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i <= b : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if b - a + 1 >= 2 * k : <NEWLINE> <INDENT> for j in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( a + k , b + 1 ) : <NEWLINE> <INDENT> if j <= b : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = list ( input ( ) ) <NEWLINE> x = sorted ( x ) <NEWLINE> s . append ( <STRING> . join ( x ) ) <NEWLINE> <DEDENT> s = sorted ( s ) <NEWLINE> m = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += m * ( m - 1 ) // 2 <NEWLINE> m = 1 <NEWLINE> <DEDENT> <DEDENT> ans += m * ( m - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <NL>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> <NL> r = 0 <NEWLINE> <NL> if n == s : <NEWLINE> <INDENT> print ( n + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n < s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> sq = int ( math . sqrt ( n ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> for i in range ( 2 , sq + 1 ) : <NEWLINE> <INDENT> nt = n <NEWLINE> st = 0 <NEWLINE> <NL> while nt > 0 : <NEWLINE> <INDENT> st += nt % i <NEWLINE> nt //= i <NEWLINE> <NL> <DEDENT> if st == s : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( sq + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> b = ( n - s ) // i + 1 <NEWLINE> <NL> st = n % b + n // b <NEWLINE> <NL> if n // b != b and st == s : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n , m , v , p = map ( int , input ( ) . split ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alst . sort ( reverse = True ) <NEWLINE> left = p - 1 <NEWLINE> right = n <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> pos = ( left + right ) // 2 <NEWLINE> if alst [ pos ] + m < alst [ p - 1 ] : <NEWLINE> <INDENT> right = pos <NEWLINE> continue <NEWLINE> <DEDENT> cnt = ( p - 1 ) * m <NEWLINE> base = alst [ pos ] + m <NEWLINE> for i in range ( p - 1 , n ) : <NEWLINE> <INDENT> cnt += min ( m , base - alst [ i ] ) <NEWLINE> <DEDENT> if cnt >= m * v : <NEWLINE> <INDENT> left = pos <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = pos <NEWLINE> <DEDENT> <DEDENT> print ( left + 1 ) <NEWLINE>
import sys <NEWLINE> <NL> cubes = list ( input ( ) ) <COMMENT> <NEWLINE> stack = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for cube in cubes : <NEWLINE> <INDENT> if not stack : <NEWLINE> <INDENT> stack . append ( cube ) <NEWLINE> <DEDENT> elif stack [ - 1 ] != cube : <NEWLINE> <INDENT> count += 2 <NEWLINE> stack . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( cube ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> INF = 10 ** 9 <NEWLINE> eps = 10 ** - 7 <NEWLINE> <NL> N , A , B = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> h = [ int ( readline ( ) ) for i in range ( N ) ] <NEWLINE> <NL> C = A - B <NEWLINE> ng = 0 <COMMENT> <NEWLINE> ok = INF <COMMENT> <NEWLINE> <NL> def judge ( mid ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for hi in h : <NEWLINE> <INDENT> ans += max ( 0 , ( hi - mid * B + C - 1 ) // C ) <NEWLINE> <DEDENT> if ans <= mid : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if judge ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans , num = sum ( p [ 0 : K ] ) , sum ( p [ 0 : K ] ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> num = num + p [ i + K ] - p [ i ] <NEWLINE> ans = max ( ans , num ) <NEWLINE> <DEDENT> print ( ( ans + K ) / 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> check = True <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> check = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if check else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x , y , h ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> h = - 1 <NEWLINE> ok = 1 <NEWLINE> for t in s : <NEWLINE> <INDENT> if t [ 2 ] == 0 : <NEWLINE> <INDENT> ok += 1 <NEWLINE> <DEDENT> elif h == - 1 : <NEWLINE> <INDENT> h = abs ( t [ 0 ] - i ) + abs ( t [ 1 ] - j ) + t [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h0 = abs ( t [ 0 ] - i ) + abs ( t [ 1 ] - j ) + t [ 2 ] <NEWLINE> if h == h0 : <NEWLINE> <INDENT> ok += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ok == n : <NEWLINE> <INDENT> for t in s : <NEWLINE> <INDENT> if abs ( t [ 0 ] - i ) + abs ( t [ 1 ] - j ) <= h : <NEWLINE> <INDENT> if not h == abs ( t [ 0 ] - i ) + abs ( t [ 1 ] - j ) + t [ 2 ] : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not t [ 2 ] == 0 : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ok == n : <NEWLINE> <INDENT> print ( i , j , h ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minp = 2 * 10 ** 5 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minp >= p [ i ] : <NEWLINE> <INDENT> minp = p [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dic [ A [ i ] ] = i + 1 <NEWLINE> <NL> <DEDENT> ans = [ dic [ i + 1 ] for i in range ( n ) ] <NEWLINE> print ( * ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - A + B ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mini = 0 <NEWLINE> maxi = 10 ** 9 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if mini < l : <NEWLINE> <INDENT> mini = l <NEWLINE> <DEDENT> if r < maxi : <NEWLINE> <INDENT> maxi = r <NEWLINE> <DEDENT> <DEDENT> t = maxi - mini + 1 <NEWLINE> if maxi < mini : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> l = [ 0 ] * Q <NEWLINE> r = [ 0 ] * Q <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lists = [ [ ] for _ in range ( N ) ] <NEWLINE> an . sort ( reverse = True ) <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> lists [ k ] . append ( an [ 2 * k ] ) <NEWLINE> lists [ k ] . append ( an [ 2 * k + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> lists [ i ] . append ( an [ 2 * N - 1 + i ] ) <NEWLINE> <NL> <DEDENT> sasa = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> sasa += lists [ j ] [ 1 ] <NEWLINE> <DEDENT> print ( sasa ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> B = sorted ( A ) <NEWLINE> B = B [ : len ( B ) - 1 ] <NEWLINE> C = [ max ( A ) ] * N <NEWLINE> C [ A . index ( max ( A ) ) ] = max ( B ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> print ( C [ j ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( k , s ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> l = s - i - j <NEWLINE> if 0 <= l <= k : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> print ( solve ( K , S ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> import numpy as np <NEWLINE> mem = np . full ( ( H , W ) , inf ) <NEWLINE> l = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> mem [ i , j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( W - 1 ) : <NEWLINE> <INDENT> mem [ : , i + 1 ] = np . minimum ( mem [ : , i ] + 1 , mem [ : , i + 1 ] ) <NEWLINE> <DEDENT> for i in reversed ( range ( 1 , W ) ) : <NEWLINE> <INDENT> mem [ : , i - 1 ] = np . minimum ( mem [ : , i - 1 ] , mem [ : , i ] + 1 ) <NEWLINE> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> mem [ i + 1 , : ] = np . minimum ( mem [ i + 1 , : ] , mem [ i , : ] + 1 ) <NEWLINE> <DEDENT> for i in reversed ( range ( 1 , H ) ) : <NEWLINE> <INDENT> mem [ i - 1 , : ] = np . minimum ( mem [ i - 1 , : ] , mem [ i , : ] + 1 ) <NEWLINE> <DEDENT> print ( int ( np . max ( mem ) ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return x * y // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm ( target_list ) : <NEWLINE> <INDENT> return reduce ( lcm_base , target_list ) <NEWLINE> <NL> <DEDENT> A_gcd = reduce ( math . gcd , A ) <NEWLINE> flg = True <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a // A_gcd % 2 == 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> min_x = int ( lcm ( A ) ) // 2 <NEWLINE> ans = m // min_x - m // ( 2 * min_x ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> if a == c : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a == c : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b == c : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for h in range ( H ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> pos = { } <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> pos [ A [ h ] [ w ] ] = [ h , w ] <NEWLINE> <NL> <DEDENT> <DEDENT> S = [ 0 ] * ( H * W ) <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> now = d + 1 <NEWLINE> while now + D <= H * W : <NEWLINE> <INDENT> nowh , noww = pos [ now ] <NEWLINE> newh , neww = pos [ now + D ] <NEWLINE> tmp += abs ( nowh - newh ) + abs ( noww - neww ) <NEWLINE> S [ now + D - 1 ] = tmp <NEWLINE> now += D <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = S [ R - 1 ] - S [ L - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import bisect <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> minA = A [ 0 ] <NEWLINE> Query = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if c > minA : <NEWLINE> <INDENT> Query . append ( [ b , c ] ) <NEWLINE> <DEDENT> <DEDENT> Query = sorted ( Query , key = lambda x : ( x [ 1 ] , x [ 0 ] ) , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> index = 0 <NEWLINE> for b , c in Query : <NEWLINE> <INDENT> if index >= n : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> cnt = 0 <NEWLINE> Flag = True <NEWLINE> while Flag : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ index ] < c : <NEWLINE> <INDENT> A [ index ] = c <NEWLINE> cnt += 1 <NEWLINE> index += 1 <NEWLINE> if ( cnt >= b ) or ( index >= n ) : <NEWLINE> <INDENT> Flag = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Flag = False <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE> <DEDENT> print ( sum ( A ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> <COMMENT> <NL> BC = sorted ( BC , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> m = A [ 0 ] <NEWLINE> D = [ ] <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> if c > m : <NEWLINE> <INDENT> _ = [ D . append ( c ) for i in range ( b ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if len ( D ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> D . append ( 0 ) <NEWLINE> <NL> for i , d in enumerate ( D ) : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ i ] < d : <NEWLINE> <INDENT> A [ i ] = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x * 2 == W and y * 2 == H : <NEWLINE> <INDENT> print ( W * H / 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H / 2 , 0 ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if s - k <= x + y <= s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , x = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if L [ i - 1 ] + L [ i ] > x : <NEWLINE> <INDENT> if L [ i - 1 ] > x : <NEWLINE> <INDENT> ans += L [ i - 1 ] - x <NEWLINE> ans += L [ i ] <NEWLINE> L [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += L [ i ] + L [ i - 1 ] - x <NEWLINE> L [ i ] = x - L [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = list ( collections . Counter ( A ) . values ( ) ) <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> if li [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> import networkx as nx <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LR_dict = defaultdict ( lambda : 10 ** 9 ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> LR_dict [ ( l , r ) ] = min ( LR_dict [ ( l , r ) ] , c ) <NEWLINE> <NL> <DEDENT> G = nx . DiGraph ( ) <NEWLINE> G . add_nodes_from ( range ( 1 , N + 1 ) ) <NEWLINE> G . add_weighted_edges_from ( [ ( x + 1 , x , 0 ) for x in range ( 1 , N ) ] ) <NEWLINE> G . add_weighted_edges_from ( ( l , r , c ) for ( l , r ) , c in LR_dict . items ( ) ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> print ( nx . dijkstra_path_length ( G , 1 , N ) ) <NEWLINE> <DEDENT> except nx . NetworkXNoPath : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> num [ i - 1 ] -= i <NEWLINE> <DEDENT> numbers = np . array ( num ) <NEWLINE> b = int ( round ( np . median ( numbers ) ) ) <NEWLINE> numbers -= b <NEWLINE> number = np . abs ( numbers ) <NEWLINE> print ( number . sum ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> I = int ( N ** ( 0.5 ) // 1 ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , I + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> j = N // i <NEWLINE> i = len ( list ( str ( i ) ) ) <NEWLINE> j = len ( list ( str ( j ) ) ) <NEWLINE> k = max ( i , j ) <NEWLINE> a . append ( k ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( a ) ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> w = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - w <NEWLINE> w += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ans = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> a1n = a . argmax ( ) <NEWLINE> a_s = sorted ( a ) <NEWLINE> a1 = a_s [ - 1 ] <NEWLINE> a2 = a_s [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == a1n : <NEWLINE> <INDENT> print ( a2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> INF = 1000000007 <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= INF <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> cnt , i = 0 , 1 <NEWLINE> l = len ( s ) <NEWLINE> <NL> while i < l : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i += 2 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( l - cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L0 = 2 <NEWLINE> L1 = 1 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( N - 1 ) : <NEWLINE> <INDENT> L = L0 + L1 <NEWLINE> L0 = L1 <NEWLINE> L1 = L <NEWLINE> <DEDENT> print ( L ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for _ in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M = mi ( ) <NEWLINE> Q = li2 ( M ) <NEWLINE> Q = sorted ( Q , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> l = [ N ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ind = max ( 0 , Q [ i ] [ 0 ] - 1 ) <NEWLINE> l [ ind ] = min ( Q [ i ] [ 1 ] - 1 , l [ ind ] ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> l [ i ] = min ( l [ i ] , l [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> i = l [ i ] <NEWLINE> cnt += 1 <NEWLINE> if l [ i ] == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> min_left = 2 * 10 ** 5 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> min_left = min ( min_left , p [ i ] ) <NEWLINE> if min_left >= p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> cnt = [ 0 ] * 3 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= cnt . count ( A [ i ] ) <NEWLINE> ans %= mod <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt [ cnt . index ( A [ i ] ) ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> N_root = math . sqrt ( N ) <NEWLINE> M = int ( N_root ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> list . append ( i + N // i - 2 ) <NEWLINE> <DEDENT> <DEDENT> list = sorted ( list ) <NEWLINE> print ( list [ 0 ] ) <NEWLINE>
w = str ( input ( ) ) <NEWLINE> <NL> length = len ( w ) <NEWLINE> z = sorted ( w ) <NEWLINE> i = 1 <NEWLINE> m = 0 <NEWLINE> <NL> if length % 2 == 1 : <NEWLINE> <INDENT> m = 1 <NEWLINE> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i < length : <NEWLINE> <INDENT> if z [ i ] == z [ i - 1 ] : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if m == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> <NL> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n // i == n % i : <NEWLINE> <INDENT> s . add ( i ) <NEWLINE> <DEDENT> x = ( n - i ) // i <NEWLINE> if x and n // x == n % x : <NEWLINE> <INDENT> s . add ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( list ( s ) ) ) <NEWLINE> <NL>
import math <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> N = I ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= ( i + 1 ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> r , g , b , n = I ( ) <NEWLINE> a = [ ] <NEWLINE> a . append ( r ) <NEWLINE> a . append ( g ) <NEWLINE> a . append ( b ) <NEWLINE> a . sort ( ) <NEWLINE> a [ 0 ] , a [ 1 ] , a [ 2 ] = r , g , b <NEWLINE> <NL> mx_b = n // b <NEWLINE> amari = n % b <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> for j in range ( ( n - r * i ) // g + 1 ) : <NEWLINE> <INDENT> if ( n - r * i - g * j ) % b == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> W_count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - W_count <NEWLINE> W_count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = P [ 0 ] <COMMENT> <NEWLINE> cnt = 1 <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] < m : <NEWLINE> <INDENT> m = P [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> N , W = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> weight_array = np . zeros ( W + 1 ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> weight_array [ w : ] = np . maximum ( weight_array [ : - w ] + v , weight_array [ w : ] ) <NEWLINE> <DEDENT> print ( int ( weight_array [ - 1 ] ) ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> L = abs ( S . count ( <STRING> ) - S . count ( <STRING> ) ) <NEWLINE> <NL> print ( N - L ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def solve ( N , As ) : <NEWLINE> <INDENT> import math <NEWLINE> x = 1 if max ( As ) == 0 else math . ceil ( math . log2 ( max ( As ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> cnt = sum ( ( A >> i ) % 2 for A in As ) <NEWLINE> ans += ( cnt * ( N - cnt ) ) * pow ( 2 , i , mod ) <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> solve ( N , As ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from typing import List <NEWLINE> <NL> <NL> def fast_input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def print_format ( b : bool ) -> str : <NEWLINE> <INDENT> return <STRING> if b else <STRING> <NEWLINE> <NL> <NL> <DEDENT> def solve ( s : str , tokens : List [ str ] , s_max : int ) -> bool : <NEWLINE> <INDENT> dp = [ False ] * s_max <NEWLINE> dp [ 0 ] = True <NEWLINE> <NL> for s_ind in range ( len ( s ) ) : <NEWLINE> <INDENT> if not dp [ s_ind ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for token in tokens : <NEWLINE> <INDENT> if s [ s_ind : s_ind + len ( token ) ] == token : <NEWLINE> <INDENT> dp [ s_ind + len ( token ) ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ len ( s ) ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> tokens = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> s = fast_input ( ) <NEWLINE> result = solve ( s = s , tokens = tokens , s_max = len ( s ) + 6 ) <NEWLINE> print ( print_format ( result ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 10 ** 12 <NEWLINE> for a in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> b = n // a <NEWLINE> <DEDENT> ans = min ( ans , a + b - 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N - 1 ) * N // 2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10 ** 5 + 1 ) ] <NEWLINE> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b = map ( int , x . split ( ) ) <NEWLINE> ans [ a ] += b <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> cnt += ans [ i ] <NEWLINE> if cnt >= k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = z = 0 <NEWLINE> while z <= x and i < n : <NEWLINE> <INDENT> z += l [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> if z <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> X_list = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> sorted_x = sorted ( X_list ) <NEWLINE> <NL> left = sorted_x [ ( N // 2 ) - 1 ] <NEWLINE> right = sorted_x [ N // 2 ] <NEWLINE> for x in X_list : <NEWLINE> <INDENT> if x <= left : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( left ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right , bisect_left <NEWLINE> from itertools import accumulate <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = 10 ** 12 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> def cal_primes ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> candidate = [ * range ( 2 , N + 1 ) ] <NEWLINE> primes = [ ] <NEWLINE> <NL> while candidate [ 0 ] ** 2 <= N : <NEWLINE> <INDENT> primes . append ( candidate [ 0 ] ) <NEWLINE> candidate = [ * filter ( lambda x : x % candidate [ 0 ] != 0 , candidate ) ] <NEWLINE> <NL> <DEDENT> primes . extend ( candidate ) <NEWLINE> return primes <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> primes = cal_primes ( 55555 ) <NEWLINE> primes = [ * filter ( lambda x : x % 5 == 1 , primes ) ] <NEWLINE> <NL> print ( * primes [ : N ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> age , money = map ( int , input ( ) . split ( ) ) <NEWLINE> assert 0 <= age <= 100 and 2 <= money <= 1000 and money % 2 == 0 <NEWLINE> if age <= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 6 <= age <= 12 : <NEWLINE> <INDENT> print ( money // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( money ) <NEWLINE> <DEDENT> <DEDENT> except AssertionError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from functools import reduce <NEWLINE> n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> tmp_max = sum ( [ i / 2 + 0.5 for i in p [ 0 : k ] ] ) <NEWLINE> tmp = tmp_max <NEWLINE> idx = 0 <NEWLINE> for i in range ( 1 , len ( p ) - k + 1 ) : <NEWLINE> <INDENT> tmp -= p [ i - 1 ] / 2 + 0.5 <NEWLINE> if i + k - 1 < len ( p ) : <NEWLINE> <INDENT> tmp += p [ i + k - 1 ] / 2 + 0.5 <NEWLINE> <DEDENT> tmp_max = max ( tmp_max , tmp ) <NEWLINE> <DEDENT> print ( tmp_max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> step = sum ( [ 90 * 100 ** i for i in range ( len ( str ( N ) ) // 2 ) ] ) <NEWLINE> dance_floor = sum ( [ 9 * 100 ** i for i in range ( len ( str ( N ) ) // 2 ) ] ) <NEWLINE> <NL> ans = len ( str ( N ) ) % 2 * ( N - step ) + - 1 * ( len ( str ( N ) ) % 2 - 1 ) * dance_floor <NEWLINE> print ( ans ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , M = il ( ) <NEWLINE> A = [ iss ( ) for _ in range ( N ) ] <NEWLINE> B = [ iss ( ) for _ in range ( M ) ] <NEWLINE> <NL> for i in range ( N - M + 1 ) : <NEWLINE> <INDENT> for j in range ( N - M + 1 ) : <NEWLINE> <INDENT> t = i <NEWLINE> for b in B : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if A [ t ] [ j : j + M ] == b : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce , lru_cache <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 6 <COMMENT> <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , A = MAP ( ) <NEWLINE> x = LIST ( ) <NEWLINE> <NL> big = [ ] <NEWLINE> small = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for y in x : <NEWLINE> <INDENT> if y == A : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif y < A : <NEWLINE> <INDENT> small . append ( A - y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> big . append ( y - A ) <NEWLINE> <NL> <DEDENT> <DEDENT> big_possible = [ 0 ] * 2501 <NEWLINE> small_possible = [ 0 ] * 2501 <NEWLINE> big_possible [ 0 ] = 1 <NEWLINE> small_possible [ 0 ] = 1 <NEWLINE> <NL> for a in big : <NEWLINE> <INDENT> for i in range ( 2500 - a , - 1 , - 1 ) : <NEWLINE> <INDENT> if big_possible [ i ] : <NEWLINE> <INDENT> big_possible [ i + a ] += big_possible [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for b in small : <NEWLINE> <INDENT> for i in range ( 2500 - b , - 1 , - 1 ) : <NEWLINE> <INDENT> if small_possible [ i ] : <NEWLINE> <INDENT> small_possible [ i + b ] += small_possible [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , 2501 ) : <NEWLINE> <INDENT> ans += small_possible [ i ] * big_possible [ i ] <NEWLINE> <NL> <NL> <DEDENT> ans *= 2 ** cnt <NEWLINE> print ( ans - 1 ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> if h == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while ( True ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> h = int ( h / 2 ) <NEWLINE> if h == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( 2 ** cnt - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if i > n or ans == s : break <NEWLINE> if s [ i : i + 5 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> ans += <STRING> <NEWLINE> if s [ i : i + 1 ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif s [ i : i + 5 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> ans += <STRING> <NEWLINE> if s [ i : i + 3 ] == <STRING> : continue <NEWLINE> elif s [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> i += 2 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if ans == s else <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = [ int ( i ) * ( - 1 ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> import heapq <NEWLINE> <NL> heapq . heapify ( A_list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x = heapq . heappop ( A_list ) <NEWLINE> heapq . heappush ( A_list , ( - 1 ) * ( - x // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A_list ) ) <NEWLINE>
import numpy as np <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ k for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> A [ t - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] - q > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> flflag = True <NEWLINE> <NL> if ( 2 * x - y ) % 3 == 0 : <NEWLINE> <INDENT> a = ( 2 * x - y ) // 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flflag = False <NEWLINE> <DEDENT> if ( 2 * y - x ) % 3 == 0 : <NEWLINE> <INDENT> b = ( 2 * y - x ) // 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flflag = False <NEWLINE> <NL> <DEDENT> def kaijou ( n ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> if flflag : <NEWLINE> <INDENT> N = a + b <NEWLINE> R = min ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if flflag == True and a >= 0 and b >= 0 : <NEWLINE> <INDENT> ans = kaijou ( N ) <NEWLINE> ans1 = ( kaijou ( N - R ) * kaijou ( R ) ) % mod <NEWLINE> print ( ( ans * pow ( ans1 , mod - 2 , mod ) ) % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( a - b ) > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k % 2 == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> A . sort ( ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 1 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif A [ i ] + 1 == A [ i + 1 ] : <NEWLINE> <INDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> a = b <NEWLINE> a += 1 <NEWLINE> b = c <NEWLINE> b += 1 <NEWLINE> c = 1 <NEWLINE> <DEDENT> elif A [ i ] + 2 == A [ i + 1 ] : <NEWLINE> <INDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> if ans < b : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> a = c <NEWLINE> a += 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> if ans < b : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> if ans < c : <NEWLINE> <INDENT> ans = c <NEWLINE> <DEDENT> a = 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> if ans < b : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> if ans < c : <NEWLINE> <INDENT> ans = c <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ <STRING> ] * h <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> a [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> row = [ False ] * h <NEWLINE> cal = [ False ] * w <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> row [ i ] = True <NEWLINE> cal [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if row [ i ] : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if cal [ j ] : <NEWLINE> <INDENT> print ( a [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lst = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> lst . append ( lst [ i - 1 ] + lst [ i - 2 ] ) <NEWLINE> <DEDENT> print ( lst [ N ] ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> XY = list ( list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( N ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x1 , y1 = XY [ i ] <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> x2 , y2 = XY [ j ] <NEWLINE> x = x2 - x1 <NEWLINE> y = y2 - y1 <NEWLINE> d [ x , y ] += 1 <NEWLINE> d [ - x , - y ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( N - max ( d . values ( ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> a = int ( input ( ) ) <NEWLINE> arr . append ( a ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( arr ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for j in c . values ( ) : <NEWLINE> <INDENT> if j % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d , e , f = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> max_a = f // ( 100 * a ) <NEWLINE> max_b = f // ( 100 * b ) <NEWLINE> max_c = f // c <NEWLINE> max_d = f // d <NEWLINE> <NL> <COMMENT> <NL> x_list = [ ] <NEWLINE> for i in range ( max_a + 1 ) : <NEWLINE> <INDENT> for j in range ( max_b + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 100 * a * i + 100 * b * j <NEWLINE> if 0 < x <= f and x not in x_list : <NEWLINE> <INDENT> x_list . append ( x ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> y_list = [ ] <NEWLINE> for i in range ( max_c + 1 ) : <NEWLINE> <INDENT> for j in range ( max_d + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> y = c * i + d * j <NEWLINE> if 0 <= y < f and y not in y_list : <NEWLINE> <INDENT> y_list . append ( y ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> concentration_list = [ ] <NEWLINE> sugar_water_list = [ ] <NEWLINE> sugar_list = [ ] <NEWLINE> <NL> for i in x_list : <NEWLINE> <INDENT> for j in y_list : <NEWLINE> <INDENT> if i + j <= f and j / i <= e / 100 : <NEWLINE> <INDENT> concentration = 100 * j / ( i + j ) <NEWLINE> concentration_list . append ( concentration ) <NEWLINE> sugar_water_list . append ( i + j ) <NEWLINE> sugar_list . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sugar_index = concentration_list . index ( max ( concentration_list ) ) <NEWLINE> print ( sugar_water_list [ sugar_index ] , sugar_list [ sugar_index ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif K <= ( A + B ) : <NEWLINE> <INDENT> print ( 0 , B - ( K - A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> d = defaultdict ( int ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ p - 1 ] += x <NEWLINE> <DEDENT> visited = [ False ] * N <NEWLINE> cnt = [ 0 ] * N <NEWLINE> def dfs ( n , acc ) : <NEWLINE> <INDENT> cnt [ n ] = acc <NEWLINE> for m in edges [ n ] : <NEWLINE> <INDENT> if not visited [ m ] : <NEWLINE> <INDENT> visited [ m ] = True <NEWLINE> dfs ( m , acc + d [ m ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> visited [ 0 ] = True <NEWLINE> dfs ( 0 , d [ 0 ] ) <NEWLINE> print ( * cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> y = sorted ( x ) <NEWLINE> a = y [ len ( x ) // 2 ] <NEWLINE> b = y [ ( len ( x ) // 2 ) - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] <= b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x ) == abs ( y ) : <NEWLINE> <INDENT> print ( 0 if x == y else 1 ) <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> print ( min ( y - x , abs ( y + x ) + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( y + x ) , abs ( y - x ) ) + 1 if x * y <= 0 else min ( abs ( y + x ) , abs ( y - x ) ) + 2 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sm = 0 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> c1 = np . count_nonzero ( arr & 1 ) <NEWLINE> sm += 2 ** i * c1 * ( n - c1 ) <NEWLINE> arr >>= 1 <NEWLINE> <NL> <DEDENT> print ( sm % mod ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( a , min ( a + k , b + 1 ) , 1 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> for i in range ( b , max ( a , b - k ) , - 1 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> ans = list ( set ( ans ) ) <COMMENT> <NEWLINE> ans . sort ( ) <COMMENT> <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + k - 1 >= b - k + 1 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict , Counter <NEWLINE> from itertools import product , groupby , count , permutations , combinations <NEWLINE> from math import pi , sqrt <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect , bisect_left , bisect_right <NEWLINE> from string import ascii_lowercase <NEWLINE> from functools import lru_cache <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> YES , Yes , yes , NO , No , no = <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> dy4 , dx4 = [ 0 , 1 , 0 , - 1 ] , [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy8 , dx8 = [ 0 , - 1 , 0 , 1 , 1 , - 1 , - 1 , 1 ] , [ 1 , 0 , - 1 , 0 , 1 , 1 , - 1 , - 1 ] <NEWLINE> <NL> <NL> def inside ( y , x , H , W ) : <NEWLINE> <INDENT> return 0 <= y < H and 0 <= x < W <NEWLINE> <NL> <NL> <DEDENT> def ceil ( a , b ) : <NEWLINE> <INDENT> return ( a + b - 1 ) // b <NEWLINE> <NL> <NL> <DEDENT> def sum_of_arithmetic_progression ( s , d , n ) : <NEWLINE> <INDENT> return n * ( 2 * s + ( n - 1 ) * d ) // 2 <NEWLINE> <NL> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> return a / g * b <NEWLINE> <NL> <NL> <DEDENT> def dfs ( u , p , c , color , tree ) : <NEWLINE> <INDENT> color [ ( u , p ) ] = c <NEWLINE> color [ ( p , u ) ] = c <NEWLINE> <NL> now = 0 <NEWLINE> for v in tree [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if now == c : <NEWLINE> <INDENT> now += 1 <NEWLINE> <NL> <DEDENT> dfs ( v , u , now , color , tree ) <NEWLINE> now += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> edges = [ ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> tree [ A ] . append ( B ) <NEWLINE> tree [ B ] . append ( A ) <NEWLINE> edges . append ( ( A , B ) ) <NEWLINE> <NL> <DEDENT> color = dict ( ) <NEWLINE> dfs ( 0 , - 1 , - 1 , color , tree ) <NEWLINE> <NL> print ( max ( color . values ( ) ) + 1 ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> print ( color [ e ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> s . sort ( ) <NEWLINE> S = sum ( s ) <NEWLINE> ans = 0 <NEWLINE> if S % 10 != 0 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( S - s [ i ] ) % 10 != 0 : <NEWLINE> <INDENT> ans = max ( S - s [ i ] , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> bc = b // c <NEWLINE> bd = b // d <NEWLINE> bcd = b // ( c * d // math . gcd ( c , d ) ) <NEWLINE> <NL> ac = ( a - 1 ) // c <NEWLINE> ad = ( a - 1 ) // d <NEWLINE> acd = ( a - 1 ) // ( c * d // math . gcd ( c , d ) ) <NEWLINE> <NL> ans = ( b - bc - bd + bcd ) - ( ( a - 1 ) - ac - ad + acd ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans , pena = 0 , 0 <NEWLINE> N , M = MI ( ) <NEWLINE> P = [ 0 ] * N <NEWLINE> PENA = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> p -= 1 <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if P [ p ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> P [ p ] = 1 <NEWLINE> if PENA [ p ] != 0 : <NEWLINE> <INDENT> pena += PENA [ p ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if P [ p ] == 0 : <NEWLINE> <INDENT> PENA [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans , pena ) <NEWLINE>
L = [ 1 , 0 , 1 , 2 , 1 , 2 , 1 , 1 , 2 , 1 , 2 , 1 ] <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if L [ a - 1 ] == L [ b - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> from collections import deque <NEWLINE> import math <NEWLINE> <NL> <NL> def bfs ( h , w , sy , sx , S ) : <NEWLINE> <INDENT> maze = [ [ 10 ** 9 ] * ( W ) for _ in range ( H ) ] <NEWLINE> <NL> maze [ sy - 1 ] [ sx - 1 ] = 0 <NEWLINE> que = deque ( [ [ sy - 1 , sx - 1 ] ] ) <NEWLINE> count = 0 <NEWLINE> while que : <NEWLINE> <INDENT> y , x = que . popleft ( ) <NEWLINE> for i , j in [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> nexty , nextx = y + i , x + j <NEWLINE> if 0 <= nexty < h and 0 <= nextx < w : <NEWLINE> <INDENT> dist1 = S [ nexty ] [ nextx ] <NEWLINE> dist2 = maze [ nexty ] [ nextx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist1 != <STRING> : <NEWLINE> <INDENT> if dist2 > maze [ y ] [ x ] + 1 : <NEWLINE> <INDENT> maze [ nexty ] [ nextx ] = maze [ y ] [ x ] + 1 <NEWLINE> count = max ( count , maze [ nexty ] [ nextx ] ) <NEWLINE> que . append ( [ nexty , nextx ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for sy in range ( H ) : <NEWLINE> <INDENT> for sx in range ( W ) : <NEWLINE> <INDENT> if S [ sy ] [ sx ] == <STRING> : <NEWLINE> <INDENT> now = bfs ( H , W , sy + 1 , sx + 1 , S ) <NEWLINE> ans = max ( ans , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import copy <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) + 1 <NEWLINE> a = [ 0 ] * N <NEWLINE> b = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in reversed ( range ( N - 1 ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = b [ i + 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] < b [ i ] : <NEWLINE> <INDENT> a [ i ] = b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> <NL> S = a * b <NEWLINE> s = x / a <NEWLINE> if s == S : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif s >= S / 2 : <NEWLINE> <INDENT> em_s = S - s <NEWLINE> tan = ( a ** 2 ) / ( 2 * em_s ) <NEWLINE> ans = math . degrees ( math . atan ( tan ) ) <NEWLINE> print ( 90 - ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> tan = ( 2 * s ) / ( b ** 2 ) <NEWLINE> ans = math . degrees ( math . atan ( tan ) ) <NEWLINE> print ( 90 - ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> for a , b in ab : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for c , d in cd : <NEWLINE> <INDENT> ans . append ( abs ( a - c ) + abs ( b - d ) ) <NEWLINE> <DEDENT> print ( ans . index ( min ( ans ) ) + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> alpha = <STRING> <NEWLINE> <NL> new_S = list ( ) <NEWLINE> for word in S : <NEWLINE> <INDENT> num = alpha . index ( word ) + N <NEWLINE> if num > 25 : <NEWLINE> <INDENT> num -= 26 <NEWLINE> <DEDENT> new_S . append ( alpha [ num ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( new_S ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> div = { } <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> div [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = bin ( a [ i ] ) <NEWLINE> l = len ( b ) <NEWLINE> for j in range ( l - 2 ) : <NEWLINE> <INDENT> if b [ l - 1 - j ] == <STRING> : <NEWLINE> <INDENT> div [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in div . keys ( ) : <NEWLINE> <INDENT> ans += div [ k ] * ( n - div [ k ] ) * 2 ** k <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - a for a in map ( int , input ( ) . split ( ) ) ] <NEWLINE> heapq . heapify ( A ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x = - heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , - ( x // 2 ) ) <NEWLINE> <DEDENT> ans = - sum ( A ) <NEWLINE> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> num = L [ i ] + L [ j ] <NEWLINE> third = bisect . bisect_left ( L , num ) <NEWLINE> if third > j : <NEWLINE> <INDENT> cnt += third - j - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( <STRING> . join ( sorted ( S ) ) ) <NEWLINE>
import math <NEWLINE> H = int ( input ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 * f ( x // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( f ( H ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D . sort ( ) <NEWLINE> A = list ( range ( D [ int ( N / 2 ) - 1 ] + 1 , D [ int ( N / 2 ) ] + 1 ) ) <NEWLINE> <NL> print ( len ( A ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> s = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> ls = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] % 10 != 0 : <NEWLINE> <INDENT> ls . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ls . sort ( ) <NEWLINE> <NL> base = sum ( s ) <NEWLINE> <NL> if base % 10 != 0 : <NEWLINE> <INDENT> print ( base ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ls : <NEWLINE> <INDENT> print ( base - ls [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a . append ( len ( list ( set ( s [ 0 : i ] ) & set ( s [ i : ] ) ) ) ) <NEWLINE> <DEDENT> print ( max ( a ) ) <NEWLINE>
<COMMENT> <NL> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if r - l >= 2019 : <NEWLINE> <INDENT> mn = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mn = ( l * r ) % 2019 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> mn = min ( mn , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mn ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> mi = 2019 <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( l , r ) : <NEWLINE> <INDENT> a = ( i * i ) % 2019 <NEWLINE> for _ in range ( min ( r - l - c , 2019 ) ) : <NEWLINE> <INDENT> a = ( a + i ) % 2019 <NEWLINE> <NL> if a < mi : <NEWLINE> <INDENT> mi = a <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c += 1 <NEWLINE> <NL> <DEDENT> print ( mi ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 2018 <NEWLINE> <NL> for i in range ( L , min ( R , L + 2100 ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( R + 1 , i + 2100 ) ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 <= ans : <NEWLINE> <INDENT> ans = ( i * j ) % 2019 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> n = int ( len ( s ) / 2 ) <NEWLINE> <NL> a = [ 0 ] * len ( s ) <NEWLINE> b = [ 0 ] * len ( s ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ 2 * i ] = 0 <NEWLINE> a [ 2 * i + 1 ] = 1 <NEWLINE> b [ 2 * i ] = 1 <NEWLINE> b [ 2 * i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> if len ( s ) % 2 == 1 : <NEWLINE> <INDENT> a [ len ( s ) - 1 ] = 0 <NEWLINE> b [ len ( s ) - 1 ] = 1 <NEWLINE> <NL> <NL> <DEDENT> an = 0 <NEWLINE> bn = 0 <NEWLINE> <NL> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if a [ j ] != s [ j ] : <NEWLINE> <INDENT> an += 1 <NEWLINE> <DEDENT> if b [ j ] != s [ j ] : <NEWLINE> <INDENT> bn += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( an , bn ) ) <NEWLINE>
import heapq <NEWLINE> <NL> x , y , z , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> b . sort ( reverse = True ) <NEWLINE> c . sort ( reverse = True ) <NEWLINE> <NL> hq = [ [ - a [ 0 ] - b [ 0 ] - c [ 0 ] , 0 , 0 , 0 ] ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> visited = { ( 0 , 0 , 0 ) } <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ii , ia , ib , ic = heapq . heappop ( hq ) <NEWLINE> print ( - ii ) <NEWLINE> na = min ( ia + 1 , x - 1 ) <NEWLINE> nb = min ( ib + 1 , y - 1 ) <NEWLINE> nc = min ( ic + 1 , z - 1 ) <NEWLINE> if not ( na , ib , ic ) in visited : <NEWLINE> <INDENT> heapq . heappush ( hq , [ - a [ na ] - b [ ib ] - c [ ic ] , na , ib , ic ] ) <NEWLINE> visited . add ( ( na , ib , ic ) ) <NEWLINE> <DEDENT> if not ( ia , nb , ic ) in visited : <NEWLINE> <INDENT> heapq . heappush ( hq , [ - a [ ia ] - b [ nb ] - c [ ic ] , ia , nb , ic ] ) <NEWLINE> visited . add ( ( ia , nb , ic ) ) <NEWLINE> <DEDENT> if not ( ia , ib , nc ) in visited : <NEWLINE> <INDENT> heapq . heappush ( hq , [ - a [ ia ] - b [ ib ] - c [ nc ] , ia , ib , nc ] ) <NEWLINE> visited . add ( ( ia , ib , nc ) ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT> elif s [ : k ] . replace ( <STRING> , <STRING> ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s . replace ( <STRING> , <STRING> ) [ 0 ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> core = [ ] <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if c != <STRING> : <NEWLINE> <INDENT> core . append ( c ) <NEWLINE> <DEDENT> <DEDENT> if core == [ ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = len ( core ) - 1 <NEWLINE> <NL> while l <= r : <NEWLINE> <INDENT> if core [ l ] != core [ r ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> <NL> while l <= r : <NEWLINE> <INDENT> lx = 0 <NEWLINE> rx = 0 <NEWLINE> while s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> lx += 1 <NEWLINE> <DEDENT> while s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> rx += 1 <NEWLINE> <DEDENT> ans += abs ( lx - rx ) <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ [ ] for i in range ( 100001 ) ] <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> X , Y , Z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( X - 1 , Y ) : <NEWLINE> <INDENT> l [ j ] . append ( Z ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans = max ( ans , len ( set ( i ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> U [ i ] = ( P [ i ] + 1 ) / 2 <NEWLINE> <NL> <DEDENT> ans = sum ( U [ : k ] ) <NEWLINE> t = copy . copy ( ans ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> t = t + U [ k + i ] - U [ i ] <NEWLINE> ans = max ( ans , t ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> ans = [ ] <NEWLINE> c = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> * w : <NEWLINE> <INDENT> if ans : <NEWLINE> <INDENT> ans . append ( ans [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( [ 0 ] * w ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f = i . index ( <STRING> ) <NEWLINE> ans . append ( [ c ] * ( f + 1 ) ) <NEWLINE> for j in i [ f + 1 : ] : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> ans [ - 1 ] . append ( c ) <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if ans [ i ] != [ 0 ] * w : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> ans [ j ] = ans [ i ] <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> <NL> D = [ 0 ] * N <NEWLINE> <NL> def dfs ( x , parent , index ) : <NEWLINE> <INDENT> D [ x ] = C [ index ] <NEWLINE> index += 1 <NEWLINE> for u in edges [ x ] : <NEWLINE> <INDENT> if u != parent : <NEWLINE> <INDENT> index = dfs ( u , x , index ) <NEWLINE> <DEDENT> <DEDENT> return index <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( sum ( C [ 1 : ] ) ) <NEWLINE> print ( * D ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( B - A ) > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n // 2 if n % 2 == 1 else ( n - 1 ) // 2 ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( 10 ** 5 + 3 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> dp [ a [ i ] + j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> point = [ 0 ] * N <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = a - 1 <NEWLINE> point [ a ] += b <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dfs ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in graph [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> point [ next ] += point [ now ] <NEWLINE> <COMMENT> <NL> dfs ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * point ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> l . append ( 2 ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> l . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( l [ - 1 ] + l [ - 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l [ n ] ) <NEWLINE>
<STRING> <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> cnts = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cnts [ a ] += 1 <NEWLINE> cnts [ b ] += 1 <NEWLINE> <DEDENT> if all ( [ c % 2 == 0 for c in cnts ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) + <STRING> for _ in range ( H ) ] <NEWLINE> S . append ( <STRING> * ( W + 1 ) ) <NEWLINE> <NL> todo = deque ( ) <NEWLINE> done = set ( ) <NEWLINE> ans = 0 <NEWLINE> for sh in range ( H ) : <NEWLINE> <INDENT> for sw in range ( W ) : <NEWLINE> <INDENT> if S [ sh ] [ sw ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s = ( sh , sw ) <NEWLINE> done . clear ( ) <NEWLINE> done . add ( s ) <NEWLINE> todo . append ( ( s , 0 ) ) <NEWLINE> while todo : <NEWLINE> <INDENT> p , count = todo . popleft ( ) <NEWLINE> ncount = count + 1 <NEWLINE> for dh , dw in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> nh , nw = p [ 0 ] + dh , p [ 1 ] + dw <NEWLINE> if S [ nh ] [ nw ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> np = ( nh , nw ) <NEWLINE> if np in done : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> done . add ( np ) <NEWLINE> ans = max ( ans , ncount ) <NEWLINE> todo . append ( ( np , ncount ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for small in range ( n - 2 ) : <NEWLINE> <INDENT> for mid in range ( small + 1 , n - 1 ) : <NEWLINE> <INDENT> div = bisect_left ( arr , arr [ small ] + arr [ mid ] , 0 , n ) <NEWLINE> if div > mid + 1 : <NEWLINE> <INDENT> ans += div - mid - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> XYC = sys . stdin . buffer . read ( ) . split ( ) <NEWLINE> X , Y , C = np . array ( XYC [ : : 3 ] , dtype = np . int64 ) , np . array ( XYC [ 1 : : 3 ] , dtype = np . int64 ) , np . array ( XYC [ 2 : : 3 ] ) == <STRING> <NEWLINE> solve ( N , K , X , Y , C ) <NEWLINE> <NL> <DEDENT> def solve ( N , K , X , Y , C ) : <NEWLINE> <INDENT> M = np . zeros ( ( K * 2 + 1 , K * 4 ) , dtype = np . int64 ) <NEWLINE> for x , y , c in zip ( X , Y , C ) : <NEWLINE> <INDENT> if c : <NEWLINE> <INDENT> x += K <NEWLINE> <DEDENT> x %= 2 * K <NEWLINE> y %= 2 * K <NEWLINE> if x >= K and y >= K : <NEWLINE> <INDENT> x -= K <NEWLINE> y -= K <NEWLINE> <DEDENT> elif y >= K : <NEWLINE> <INDENT> y -= K <NEWLINE> x += K <NEWLINE> <DEDENT> M [ y , x ] += 1 <NEWLINE> M [ y , ( x + 2 * K ) % ( 4 * K ) ] += 1 <NEWLINE> M [ y + K , x + K ] += 1 <NEWLINE> M [ y + K , ( x + 3 * K ) % ( 4 * K ) ] += 1 <NEWLINE> if y == 0 : <NEWLINE> <INDENT> M [ 2 * K , x ] += 1 <NEWLINE> M [ 2 * K , ( x + 2 * K ) % ( 4 * K ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for y in range ( 2 * K ) : <NEWLINE> <INDENT> for x in range ( 4 * K ) : <NEWLINE> <INDENT> M [ y + 1 , x ] += M [ y , x ] <NEWLINE> <DEDENT> <DEDENT> for y in range ( 2 * K + 1 ) : <NEWLINE> <INDENT> for x in range ( 4 * K - 1 ) : <NEWLINE> <INDENT> M [ y , x + 1 ] += M [ y , x ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( [ M [ y + K , x + K ] + M [ y , x ] - M [ y + K , x ] - M [ y , x + K ] for y in range ( K + 1 ) for x in range ( 2 * K + 1 ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> main ( ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> d , cnt = 0 , 1 <NEWLINE> for li in l : <NEWLINE> <INDENT> d += li <NEWLINE> if d <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> key = <STRING> <NEWLINE> <NL> t = - 1 <NEWLINE> <NL> for i in range ( 7 ) : <NEWLINE> <INDENT> if not S [ i ] == key [ i ] : <NEWLINE> <INDENT> t = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t == - 1 : <NEWLINE> <INDENT> t = 7 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> if not S [ - i ] == key [ - i ] : <NEWLINE> <INDENT> t += i - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t >= 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( T ) ] <NEWLINE> M = N <NEWLINE> m = 0 <NEWLINE> <NL> for a , b in X : <NEWLINE> <INDENT> M = min ( M , b ) <NEWLINE> m = max ( m , a ) <NEWLINE> <NL> <DEDENT> if M < m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( M - m + 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> and s [ 2 : - 1 ] . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> sc = s . index ( <STRING> ) <NEWLINE> if ( s [ 1 : sc ] + s [ sc + 1 : ] ) . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> a = L [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> b = L [ j ] <NEWLINE> ans += bisect_left ( L , a + b ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> passed = 0 <NEWLINE> oversea = 0 <NEWLINE> yep = False <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> if passed < ( a + b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> passed += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if oversea < b and passed < ( a + b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> passed += 1 <NEWLINE> oversea += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> import math <NEWLINE> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lcm = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> lcm = lcm * A [ i ] // math . gcd ( lcm , A [ i ] ) <NEWLINE> <DEDENT> first = lcm // 2 <NEWLINE> <NL> ans_exists = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if first % A [ i ] == 0 : <NEWLINE> <INDENT> ans_exists = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ans_exists : <NEWLINE> <INDENT> ans = int ( ( M - first ) // lcm + 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> ans [ j - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> class Eratosthenes : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . min_factor = [ - 1 ] * ( n + 1 ) <NEWLINE> self . min_factor [ 0 ] , self . min_factor [ 1 ] = 0 , 1 <NEWLINE> <NL> <DEDENT> def get_primes ( self ) : <NEWLINE> <INDENT> primes = [ ] <NEWLINE> is_prime = [ True ] * ( self . n + 1 ) <NEWLINE> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , self . n + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> primes . append ( i ) <NEWLINE> self . min_factor [ i ] = i <NEWLINE> for j in range ( i * 2 , self . n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> if self . min_factor [ j ] == - 1 : <NEWLINE> <INDENT> self . min_factor [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return primes <NEWLINE> <NL> <DEDENT> def prime_factorization ( self , n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> while n != 1 : <NEWLINE> <INDENT> prime = self . min_factor [ n ] <NEWLINE> exp = 0 <NEWLINE> while self . min_factor [ n ] == prime : <NEWLINE> <INDENT> exp += 1 <NEWLINE> n //= prime <NEWLINE> <DEDENT> res . append ( [ prime , exp ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX_A = max ( A ) + 1 <NEWLINE> <NL> er = Eratosthenes ( MAX_A ) <NEWLINE> er . get_primes ( ) <NEWLINE> num = [ 0 ] * MAX_A <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pf = er . prime_factorization ( A [ i ] ) <NEWLINE> for p , ex in pf : <NEWLINE> <INDENT> num [ p ] = max ( num [ p ] , ex ) <NEWLINE> <NL> <DEDENT> <DEDENT> LCM = 1 <NEWLINE> for v in range ( 2 , MAX_A ) : <NEWLINE> <INDENT> LCM *= pow ( v , num [ v ] , mod ) <NEWLINE> LCM %= mod <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> res += LCM * pow ( a , mod - 2 , mod ) <NEWLINE> res %= mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> answ = [ ] <NEWLINE> ansh = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if not all ( [ a == <STRING> for a in A [ i ] ] ) : <NEWLINE> <INDENT> answ . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if not all ( [ A [ i ] [ j ] == <STRING> for i in range ( h ) ] ) : <NEWLINE> <INDENT> ansh . append ( j ) <NEWLINE> <DEDENT> <DEDENT> for i in answ : <NEWLINE> <INDENT> for j in ansh : <NEWLINE> <INDENT> print ( A [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2017 * 2018 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( ns ) : <NEWLINE> <INDENT> return reduce ( math . gcd , ns ) <NEWLINE> <NL> <DEDENT> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diff = [ abs ( x - X ) for x in L ] <NEWLINE> <NL> if len ( diff ) == 1 : <NEWLINE> <INDENT> print ( diff [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( gcd ( diff ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> n = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for j in b : <NEWLINE> <INDENT> ans += ( n - bisect_right ( c , j ) ) * bisect_left ( a , j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from scipy . special import comb <NEWLINE> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> odd = [ ] <NEWLINE> even = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if aa [ i ] % 2 == 0 : <NEWLINE> <INDENT> even . append ( aa [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd . append ( aa [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> x = len ( odd ) <NEWLINE> y = len ( even ) <NEWLINE> <NL> <NL> sum1 = 0 <NEWLINE> for i in range ( 0 , x + 1 , 2 ) : <NEWLINE> <INDENT> sum1 += comb ( x , i ) <NEWLINE> <DEDENT> sum2 = 0 <NEWLINE> for i in range ( 1 , x + 1 , 2 ) : <NEWLINE> <INDENT> sum2 += comb ( x , i ) <NEWLINE> <NL> <DEDENT> if p == 0 : <NEWLINE> <INDENT> ans = int ( ( 2 ** y ) * sum1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( ( 2 ** y ) * sum2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , C , K = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> Ts = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> Ts . sort ( ) <NEWLINE> <NL> res = 0 <NEWLINE> temp_psg = 0 <NEWLINE> lim = Ts [ 0 ] + K <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> temp_psg += 1 <NEWLINE> if Ts [ i ] > lim : <NEWLINE> <INDENT> res += 1 <NEWLINE> temp_psg = 1 <NEWLINE> lim = Ts [ i ] + K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if temp_psg == C and i < N - 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> temp_psg = 0 <NEWLINE> lim = Ts [ i + 1 ] + K <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if temp_psg > 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if ( N % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> m = N // 2 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( S [ i ] != S [ i + m ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> last_ok_postion = 0 <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ last_ok_postion ] >= P [ i ] : <NEWLINE> <INDENT> m = min ( P [ last_ok_postion : i ] ) <NEWLINE> if m >= P [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> last_ok_postion = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> import itertools <NEWLINE> <NL> N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ [ 0 ] * C for _ in range ( C ) ] <NEWLINE> for i in range ( C ) : <NEWLINE> <INDENT> D [ i ] = list ( int ( d ) for d in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dict_c = [ defaultdict ( int ) for _ in range ( 3 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> dict_c [ ( i + j ) % 3 ] [ c [ j ] - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> list_C = list ( range ( C ) ) <NEWLINE> ans = 10 ** 18 <NEWLINE> for ( p , q , r ) in itertools . permutations ( list_C , 3 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i , j in enumerate ( ( p , q , r ) ) : <NEWLINE> <INDENT> for m , n in dict_c [ i ] . items ( ) : <NEWLINE> <INDENT> tmp += D [ m ] [ j ] * n <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> if n % 3 == 1 or n % 3 == 0 : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif n % 3 == 2 : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = ( n - 1 ) * n // 2 <NEWLINE> print ( a ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> lx = 0 <NEWLINE> while s [ l ] == <STRING> and l < len ( s ) - 1 : <NEWLINE> <INDENT> lx += 1 <NEWLINE> l += 1 <NEWLINE> <NL> <DEDENT> rx = 0 <NEWLINE> while s [ r ] == <STRING> and r > 0 : <NEWLINE> <INDENT> rx += 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> if s [ l ] == s [ r ] : <NEWLINE> <INDENT> cnt += abs ( rx - lx ) <NEWLINE> <NL> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> w = <STRING> <NEWLINE> l = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> w += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( len ( w ) ) <NEWLINE> w = <STRING> <NEWLINE> <DEDENT> <DEDENT> l . append ( len ( w ) ) <NEWLINE> print ( max ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = [ A [ i ] , i + 1 ] <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i ] = L [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = a [ : ] <NEWLINE> p = max ( a ) <NEWLINE> b . remove ( p ) <NEWLINE> q = max ( b ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i != p : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import math <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <DEDENT> if n >= 2 : <NEWLINE> <INDENT> ue = lcm ( a [ 0 ] , a [ 1 ] ) <NEWLINE> if n >= 3 : <NEWLINE> <INDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> ue = lcm ( ue , a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ue = a [ 0 ] <NEWLINE> <NL> <DEDENT> shita = 0 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> shita += ue // a [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> shita = n <NEWLINE> <NL> <DEDENT> ans = ue / shita <NEWLINE> print ( <STRING> ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> for i in range ( min ( len ( O ) , len ( E ) ) ) : <NEWLINE> <INDENT> print ( O [ i ] , E [ i ] , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if len ( O ) > len ( E ) : <NEWLINE> <INDENT> print ( O [ - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = len ( A ) <NEWLINE> Adel = list ( set ( A ) ) <NEWLINE> ans = len ( Adel ) - k <NEWLINE> <COMMENT> <NL> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> newA = collections . Counter ( A ) <NEWLINE> count = list ( newA . values ( ) ) <NEWLINE> count . sort ( ) <NEWLINE> <COMMENT> <NL> ans = sum ( count [ : - k ] ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> ans = 0 <NEWLINE> if a >= n : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> a += i <NEWLINE> if a >= n : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( 1 , ans + 1 ) : <NEWLINE> <INDENT> if a - n != k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
def abc044_c ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( lambda x : int ( x ) - a , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> x = np . array ( x , dtype = np . int64 ) <NEWLINE> <NL> vrange = n * ( a + np . max ( x ) ) <COMMENT> <NEWLINE> dp = np . zeros ( ( n + 1 , 2 * vrange + 1 ) , dtype = np . int64 ) <COMMENT> <NEWLINE> dp [ 0 , vrange ] = 1 <COMMENT> <NEWLINE> <NL> for i in np . arange ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 , : ] += dp [ i , : ] <NEWLINE> if 0 < x [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 , x [ i ] : ] += dp [ i , : - x [ i ] ] <NEWLINE> <DEDENT> elif x [ i ] < 0 : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 , : x [ i ] ] += dp [ i , - x [ i ] : ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 , : ] += dp [ i , : ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = dp [ n , vrange ] - 1 <COMMENT> <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc044_c ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> num_list . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> copy = num_list . copy ( ) <NEWLINE> copy . sort ( ) <NEWLINE> maximum = copy [ - 1 ] <NEWLINE> second = copy [ - 2 ] <NEWLINE> <NL> for i in num_list : <NEWLINE> <INDENT> if i == maximum : <NEWLINE> <INDENT> print ( second ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maximum ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> a = A % 10 <NEWLINE> b = B % 10 <NEWLINE> c = C % 10 <NEWLINE> d = D % 10 <NEWLINE> e = E % 10 <NEWLINE> result = 0 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> result += A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( A + 10 - a ) <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> result += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( B + 10 - b ) <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> result += C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( C + 10 - c ) <NEWLINE> <DEDENT> if d == 0 : <NEWLINE> <INDENT> result += D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( D + 10 - d ) <NEWLINE> <DEDENT> if e == 0 : <NEWLINE> <INDENT> result += E <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( E + 10 - e ) <NEWLINE> <DEDENT> if a == b == c == d == e == 0 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = set ( [ a , b , c , d , e ] ) <NEWLINE> l . discard ( 0 ) <NEWLINE> print ( result - ( 10 - min ( l ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> mini = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 0 , len ( P ) ) : <NEWLINE> <INDENT> if P [ i ] < mini : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> mini = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> mx = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if field [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dist [ h ] [ w ] = 0 <NEWLINE> que = deque ( [ ] ) <NEWLINE> que . append ( [ h , w ] ) <NEWLINE> while que != deque ( [ ] ) : <NEWLINE> <INDENT> u , v = que . popleft ( ) <NEWLINE> for dir in range ( 4 ) : <NEWLINE> <INDENT> nu = u + dx [ dir ] <NEWLINE> nv = v + dy [ dir ] <NEWLINE> <NL> if ( nu < 0 ) or ( nu >= H ) or ( nv < 0 ) or ( nv >= W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ nu ] [ nv ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist [ nu ] [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> que . append ( [ nu , nv ] ) <NEWLINE> dist [ nu ] [ nv ] = dist [ u ] [ v ] + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if mx < dist [ i ] [ j ] : <NEWLINE> <INDENT> mx = dist [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if k == 1 : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while cnt < len ( s ) and s [ cnt ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if cnt >= k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif cnt == len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ cnt ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 < a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a <= b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a <= 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter as C <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> <COMMENT> <NL> d = C ( a ) <NEWLINE> len = len ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if k - ( len - d [ i ] ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> if k - len ( a ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ( i + 1 ) / 2 for i in p ] <NEWLINE> cans = sum ( s [ : k ] ) <NEWLINE> ans = cans <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> cans = cans - s [ i ] + s [ i + k ] <NEWLINE> ans = max ( ans , cans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> X = [ 0 ] * N <NEWLINE> Y = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = MI ( ) <NEWLINE> X [ i ] , Y [ i ] = x , y <NEWLINE> <NL> <DEDENT> dct = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> xi , yi = X [ i ] , Y [ i ] <NEWLINE> xj , yj = X [ j ] , Y [ j ] <NEWLINE> <NL> dct [ ( xi - xj , yi - yj ) ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> mx = 0 <NEWLINE> for d in dct . values ( ) : <NEWLINE> <INDENT> mx = max ( mx , d ) <NEWLINE> <DEDENT> print ( N - mx ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> n1 = np . count_nonzero ( ( A >> i ) & 1 ) <NEWLINE> n0 = n - n1 <NEWLINE> ans += ( 2 ** i ) * n1 * n0 % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> lenS = len ( S ) <NEWLINE> S = S + [ <STRING> ] <NEWLINE> K = lenS <NEWLINE> i = 0 <NEWLINE> ps = S [ 0 ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s != ps : <NEWLINE> <INDENT> K = min ( K , max ( i , lenS - i ) ) <NEWLINE> ps = s <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( K ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a , b = il ( ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for n in reversed ( range ( N ) ) : <NEWLINE> <INDENT> if ( A [ n ] + ret ) % B [ n ] == 0 : continue <NEWLINE> else : <NEWLINE> <INDENT> ret += B [ n ] - ( ( A [ n ] + ret ) % B [ n ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> cntB = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cntB += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cntB <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pop_count ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def fact ( N ) : <NEWLINE> <INDENT> res = { } <NEWLINE> tmp = N <NEWLINE> for i in range ( 2 , int ( N ** 0.5 + 1 ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> res [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> res [ tmp ] = 1 <NEWLINE> <DEDENT> if res == { } : <NEWLINE> <INDENT> res [ N ] = 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def modpow ( n , p ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> while p > 0 : <NEWLINE> <INDENT> if p & 1 : <NEWLINE> <INDENT> res = res * n % MOD <NEWLINE> <DEDENT> n = n * n % MOD <NEWLINE> p >>= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def modinv ( n ) : <NEWLINE> <INDENT> b , u , v = MOD , 1 , 0 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> t = n // b <NEWLINE> n -= t * b <NEWLINE> n , b = b , n <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= MOD <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += MOD <NEWLINE> <DEDENT> return u <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = Scanner . int ( ) <NEWLINE> A = Scanner . map_int ( ) <NEWLINE> L = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for k , v in fact ( A [ i ] ) . items ( ) : <NEWLINE> <INDENT> L [ k ] = max ( L [ k ] , v ) <NEWLINE> <DEDENT> <DEDENT> lcm = 1 <NEWLINE> for k , v in L . items ( ) : <NEWLINE> <INDENT> lcm *= modpow ( k , v ) <NEWLINE> lcm %= MOD <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = lcm * modinv ( A [ i ] ) % MOD <NEWLINE> ans += x <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , node ) : <NEWLINE> <INDENT> self . parent = [ - 1 for _ in range ( node ) ] <NEWLINE> self . node = node <NEWLINE> <NL> <DEDENT> def find ( self , target ) : <NEWLINE> <INDENT> if self . parent [ target ] < 0 : <NEWLINE> <INDENT> return target <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ target ] = self . find ( self . parent [ target ] ) <NEWLINE> return self . parent [ target ] <NEWLINE> <NL> <DEDENT> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> root_x = self . find ( x ) <NEWLINE> root_y = self . find ( y ) <NEWLINE> if root_x == root_y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parent [ root_x ] > self . parent [ root_y ] : <NEWLINE> <INDENT> root_x , root_y = root_y , root_x <NEWLINE> <DEDENT> self . parent [ root_x ] += self . parent [ root_y ] <NEWLINE> self . parent [ root_y ] = root_x <NEWLINE> <NL> <DEDENT> def get_size ( self , x ) : <NEWLINE> <INDENT> return - self . parent [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def get_root ( self ) : <NEWLINE> <INDENT> return [ i for i , root in enumerate ( self . parent ) if root < 0 ] <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . node ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . get_root ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ [ <STRING> for _ in range ( w + 2 ) ] ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> grid . append ( [ <STRING> ] + list ( input ( ) ) + [ <STRING> ] ) <NEWLINE> <DEDENT> grid . append ( grid [ 0 ] ) <NEWLINE> uf = UnionFind ( h * w ) <NEWLINE> all_black = [ ] <NEWLINE> <NL> def grid_num ( i , j ) : <NEWLINE> <INDENT> return w * ( i - 1 ) + j - 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> for di , dj in [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] : <NEWLINE> <INDENT> ni = i + di <NEWLINE> nj = j + dj <NEWLINE> if grid [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif grid [ i ] [ j ] != grid [ ni ] [ nj ] : <NEWLINE> <INDENT> uf . union ( grid_num ( i , j ) , grid_num ( ni , nj ) ) <NEWLINE> <DEDENT> <DEDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> all_black . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> black = defaultdict ( int ) <NEWLINE> for i , j in all_black : <NEWLINE> <INDENT> black [ uf . find ( grid_num ( i , j ) ) ] += 1 <NEWLINE> <DEDENT> for i , r in enumerate ( uf . parent ) : <NEWLINE> <INDENT> if r < 0 : <NEWLINE> <INDENT> ans += black [ i ] * ( - r - black [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
lsnum = list ( input ( ) ) <NEWLINE> lsnum1 = [ int ( i ) for i in lsnum ] <NEWLINE> ls = [ <STRING> , <STRING> ] <NEWLINE> for i in range ( 2 ** 3 ) : <NEWLINE> <INDENT> ans = lsnum1 [ 0 ] <NEWLINE> for j in range ( 3 ) : <COMMENT> <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <COMMENT> <NEWLINE> <INDENT> ans += lsnum1 [ j + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= lsnum1 [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> if ans == 7 : <NEWLINE> <INDENT> bit = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans2 = lsnum [ 0 ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if ( ( bit >> i ) & 1 ) : <NEWLINE> <INDENT> ans2 += <STRING> + lsnum [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 += <STRING> + lsnum [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans2 + <STRING> ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ input ( ) for i in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> print ( C [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import copy <NEWLINE> from itertools import combinations <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N , A , B , C = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ i ] = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mp = [ ] <NEWLINE> for na in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for ja in combinations ( l , na ) : <NEWLINE> <NL> <INDENT> l_b = copy . copy ( l ) <NEWLINE> for i2 in ja : <NEWLINE> <INDENT> if i2 in l_b : <NEWLINE> <INDENT> l_b . remove ( i2 ) <NEWLINE> <DEDENT> <DEDENT> for nb in range ( 1 , N ) : <NEWLINE> <INDENT> for jb in combinations ( l_b , nb ) : <NEWLINE> <NL> <INDENT> l_c = copy . copy ( l_b ) <NEWLINE> for i3 in jb : <NEWLINE> <INDENT> if i3 in l_c : <NEWLINE> <INDENT> l_c . remove ( i3 ) <NEWLINE> <DEDENT> <DEDENT> for nc in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for jc in combinations ( l_c , nc ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> AA = abs ( A - sum ( ja ) ) + 10 * ( na - 1 ) <NEWLINE> BB = abs ( B - sum ( jb ) ) + 10 * ( nb - 1 ) <NEWLINE> CC = abs ( C - sum ( jc ) ) + 10 * ( nc - 1 ) <NEWLINE> mp . append ( AA + BB + CC ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min ( mp ) ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , k = I ( ) <NEWLINE> a = l ( ) <NEWLINE> x = a . index ( 1 ) <NEWLINE> if n == k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( 1 + math . ceil ( ( n - k ) / ( k - 1 ) ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for d in range ( 60 ) : <NEWLINE> <INDENT> mask = 1 << d <NEWLINE> num1 = len ( [ 1 for A in As if A & mask ] ) <NEWLINE> ans += num1 * ( N - num1 ) * mask <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = { int ( input ( ) ) for _ in range ( m ) } <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = dp [ i - 1 ] <NEWLINE> if i > 1 : <NEWLINE> <INDENT> x += dp [ i - 2 ] <NEWLINE> <DEDENT> dp [ i ] = x % mod <NEWLINE> <DEDENT> ans = dp [ n ] <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> ab . sort ( ) <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k = k - ab [ i ] [ 1 ] <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( ab [ i ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> <NL> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> table [ r ] [ l ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> table [ i ] [ j ] = table [ i ] [ j ] + table [ i ] [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> table [ j ] [ i ] = table [ j ] [ i ] + table [ j - 1 ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> if l != 0 : <NEWLINE> <INDENT> ans = table [ r ] [ r ] - table [ r ] [ l - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = table [ r ] [ r ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> out = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 8 : <NEWLINE> <INDENT> out += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> ac_done = [ False ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if ac_done [ p - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += l [ p - 1 ] <NEWLINE> ac_done [ p - 1 ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> if ( S [ k - 1 ] == <STRING> ) : <NEWLINE> <INDENT> S [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> elif ( S [ k - 1 ] == <STRING> ) : <NEWLINE> <INDENT> S [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - ( i + j ) <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> s += ( List [ i ] + 1 ) <NEWLINE> <DEDENT> num = 0 <NEWLINE> <COMMENT> <NL> if N == K : <NEWLINE> <INDENT> print ( s / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> for i in range ( N - K ) : <NEWLINE> <INDENT> a = List [ i + K ] - List [ i ] <NEWLINE> <COMMENT> <NL> n1 = s + a <NEWLINE> s = n1 <NEWLINE> n1 = n1 / 2 <NEWLINE> if n1 >= num : <NEWLINE> <INDENT> num = n1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> alist = [ 0 ] * 10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> alist [ int ( s [ i ] ) ] = i <NEWLINE> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> flag1 = False <NEWLINE> for a in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ a ] == str ( i ) : <NEWLINE> <INDENT> flag1 = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag1 : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> flag2 = False <NEWLINE> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ b ] == str ( j ) : <NEWLINE> <INDENT> flag2 = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag2 : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if b < alist [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> import itertools <NEWLINE> <NL> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> pos = [ m . end ( ) for m in re . finditer ( <STRING> , s ) ] <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> for p in pos : <NEWLINE> <INDENT> dp [ p ] = 1 <NEWLINE> <DEDENT> dp = list ( itertools . accumulate ( dp ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans . append ( dp [ r ] - dp [ l ] ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> from heapq import heappop , heappush , heapreplace <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter as cc <NEWLINE> a = cc ( a ) <NEWLINE> q = [ ] <NEWLINE> for key in a : <NEWLINE> <INDENT> heappush ( q , ( key , a [ key ] ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> now = b <NEWLINE> while q : <NEWLINE> <INDENT> num , cnt = q [ 0 ] <NEWLINE> if c <= num : break <NEWLINE> <NL> if now >= cnt : <NEWLINE> <INDENT> now -= cnt <NEWLINE> heappop ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heapreplace ( q , ( num , cnt - now ) ) <NEWLINE> now = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if now != b : <NEWLINE> <INDENT> heappush ( q , ( c , b - now ) ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for num , cnt in q : <NEWLINE> <INDENT> ans += num * cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = NMI ( ) <NEWLINE> A = NLI ( ) <NEWLINE> <NL> match_dict = { i + 1 : m for i , m in enumerate ( [ 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ) } <NEWLINE> usable_list = [ [ a , match_dict [ a ] ] for a in A ] <NEWLINE> usable_list . sort ( key = lambda x : ( x [ 1 ] , - x [ 0 ] ) ) <NEWLINE> <NL> <COMMENT> <NL> dp = [ - 1 ] * ( N + 10 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for num , m in usable_list : <NEWLINE> <INDENT> dp [ i + m ] = max ( dp [ i + m ] , dp [ i ] * 10 + num ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = collections . Counter ( A ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> max = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> D [ C ] += B <NEWLINE> <NL> <DEDENT> D = sorted ( D . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> sum = 0 <NEWLINE> count = 0 <NEWLINE> for k , v in D : <NEWLINE> <INDENT> if N > v : <NEWLINE> <INDENT> sum += k * v <NEWLINE> N -= v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += k * N <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( 0 ) <NEWLINE> a . insert ( 0 , 0 ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> s += abs ( a [ i ] - a [ i + 1 ] ) <NEWLINE> <DEDENT> for h in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = abs ( a [ h + 1 ] - a [ h - 1 ] ) - abs ( a [ h ] - a [ h - 1 ] ) - abs ( a [ h + 1 ] - a [ h ] ) <NEWLINE> print ( s + t ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> if k * 2 >= b - a + 1 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> li . append ( i ) <NEWLINE> <DEDENT> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> li . append ( a + i ) <NEWLINE> li . append ( b - i ) <NEWLINE> <DEDENT> li . sort ( ) <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> a . append ( 1000000 ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> j = 0 <NEWLINE> if a [ j ] == 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i == a [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def grid ( y , x ) : <NEWLINE> <INDENT> global dp , visited <NEWLINE> if visited [ y ] [ x ] : <NEWLINE> <INDENT> return dp [ y ] [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ y ] [ x ] = True <NEWLINE> if mp [ y ] [ x ] != <STRING> and dp [ y ] [ x ] == 0 : <NEWLINE> <INDENT> dp [ y ] [ x ] = ( grid ( y - 1 , x ) + grid ( y , x - 1 ) ) % mod <NEWLINE> <DEDENT> return dp [ y ] [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = [ [ <STRING> ] * ( W + 1 ) ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> mp . append ( [ <STRING> ] + list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( H + 1 ) ] <NEWLINE> dp [ 1 ] [ 1 ] = 1 <NEWLINE> visited = [ [ False ] * ( W + 1 ) for _ in range ( H + 1 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> grid ( H , W ) <NEWLINE> print ( dp [ H ] [ W ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> l . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <NL> <DEDENT> l = sorted ( l , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> l = sorted ( l , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( l [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> min_cal = [ 0 ] * N <NEWLINE> min_cal [ 0 ] = P [ 0 ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> min_cal [ i + 1 ] = min ( min_cal [ i ] , P [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if min_cal [ i ] >= P [ i ] : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> lb = 0 <NEWLINE> rb = N + 1 <NEWLINE> while rb - lb > 1 : <NEWLINE> <INDENT> mid = ( lb + rb ) // 2 <NEWLINE> x = 0 <NEWLINE> for i , s in enumerate ( S [ : mid ] ) : <NEWLINE> <INDENT> x += pow ( 26 , i ) * ( ord ( s ) - ord ( <STRING> ) ) <NEWLINE> <DEDENT> m = pow ( 26 , mid - 1 ) <NEWLINE> a = [ x ] <NEWLINE> for i , s in enumerate ( S [ mid : ] ) : <NEWLINE> <INDENT> x -= ord ( S [ i ] ) - ord ( <STRING> ) <NEWLINE> x //= 26 <NEWLINE> x += m * ( ord ( s ) - ord ( <STRING> ) ) <NEWLINE> a += [ x ] <NEWLINE> <DEDENT> f = 0 <NEWLINE> se = set ( [ ] ) <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> if i >= mid : <NEWLINE> <INDENT> se . add ( a [ i - mid ] ) <NEWLINE> <DEDENT> if x in se : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> lb = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rb = mid <NEWLINE> <DEDENT> <DEDENT> print ( lb ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if m == 0 : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> p = [ list ( input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> correct = set ( [ p [ i ] [ 0 ] for i in range ( m ) if p [ i ] [ 1 ] == <STRING> ] ) <NEWLINE> <NL> s = set ( ) <NEWLINE> sum_wa = 0 <NEWLINE> <NL> for i in [ p [ j ] for j in range ( m ) if p [ j ] [ 0 ] in correct ] : <NEWLINE> <INDENT> if i [ 0 ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i [ 1 ] == <STRING> : <NEWLINE> <INDENT> sum_wa += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( i [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( correct ) , sum_wa ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n = INT ( ) <NEWLINE> d = LIST ( ) <NEWLINE> m = INT ( ) <NEWLINE> t = LIST ( ) <NEWLINE> d . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( d [ i ] == t [ j ] ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if ( j == m ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( j == m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> x = set ( ) <NEWLINE> y = set ( ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> x . add ( b ) <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> y . add ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if x & y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> L = [ [ ] for i in range ( N + 1 ) ] <COMMENT> <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ a ] . append ( b ) <NEWLINE> L [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> parent = [ 0 ] * ( N + 1 ) <NEWLINE> order = [ ] <NEWLINE> stack = [ 1 ] <NEWLINE> while stack : <NEWLINE> <INDENT> x = stack . pop ( ) <NEWLINE> order . append ( x ) <COMMENT> <NEWLINE> for y in L [ x ] : <NEWLINE> <INDENT> if y == parent [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ y ] = x <COMMENT> <NEWLINE> stack . append ( y ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> half = pow ( 2 , MOD - 2 , MOD ) <NEWLINE> power_inv = [ 1 ] * ( N + 1 ) <COMMENT> <NEWLINE> size = [ 1 ] * ( N + 1 ) <NEWLINE> for i , v in enumerate ( order [ : : - 1 ] , 1 ) : <COMMENT> <NEWLINE> <INDENT> p = parent [ v ] <NEWLINE> x = size [ v ] <COMMENT> <NEWLINE> size [ p ] += x <COMMENT> <NEWLINE> power_inv [ i ] = power_inv [ i - 1 ] * half % MOD <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = sum ( ( 1 - power_inv [ i ] - power_inv [ N - i ] + power_inv [ N ] ) % <NEWLINE> <INDENT> MOD for i in size [ 2 : ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans += 1 <COMMENT> <NEWLINE> <COMMENT> <NL> ans -= power_inv [ N ] + N * power_inv [ 1 ] <NEWLINE> <COMMENT> <NL> ans %= MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> <NL> s = <STRING> <NEWLINE> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> s += O [ i ] <NEWLINE> if i < len ( E ) : <NEWLINE> <INDENT> s += E [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) / gcd ( a , b ) <NEWLINE> <NL> <DEDENT> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( int ( lcm ( a , b ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = l [ 0 ] <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if m > l [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> m = l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b / a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> INF = 10 ** 9 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( 3 * N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> <NL> G [ u ] . append ( v + N ) <NEWLINE> G [ u + N ] . append ( v + 2 * N ) <NEWLINE> G [ u + 2 * N ] . append ( v ) <NEWLINE> <NL> <DEDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s , t = s - 1 , t - 1 <NEWLINE> <NL> dist = [ INF ] * ( 3 * N ) <NEWLINE> dist [ s ] = 0 <NEWLINE> <NL> Q = deque ( [ s ] ) <NEWLINE> while len ( Q ) > 0 : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if dist [ v ] == INF : <NEWLINE> <INDENT> dist [ v ] = dist [ u ] + 1 <NEWLINE> Q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if dist [ t ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ t ] // 3 ) <NEWLINE> <DEDENT>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> s . reverse ( ) <NEWLINE> len_s = len ( s ) <NEWLINE> t = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if t == len_s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif t > len_s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> . join ( s [ t : t + 5 ] ) == <STRING> : <NEWLINE> <INDENT> t += 5 <NEWLINE> <DEDENT> elif <STRING> . join ( s [ t : t + 7 ] ) == <STRING> : <NEWLINE> <INDENT> t += 7 <NEWLINE> <DEDENT> elif <STRING> . join ( s [ t : t + 5 ] ) == <STRING> : <NEWLINE> <INDENT> t += 5 <NEWLINE> <DEDENT> elif <STRING> . join ( s [ t : t + 6 ] ) == <STRING> : <NEWLINE> <INDENT> t += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = { } <COMMENT> <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 10000 , 100000 ) : <NEWLINE> <INDENT> L = list ( str ( i ) ) <NEWLINE> if L == list ( reversed ( L ) ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> N [ i ] = cnt <NEWLINE> <DEDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( N [ B ] - N [ A - 1 ] if A > 10000 else N [ B ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( a + 1 ) : <NEWLINE> <INDENT> if 0 <= ( b - i - j ) <= a : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> a_sort = sorted ( a , reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a_sort [ 0 ] : <NEWLINE> <INDENT> print ( a_sort [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a_sort [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = collections . Counter ( a [ 0 : : 2 ] ) . most_common ( ) <NEWLINE> a2 = collections . Counter ( a [ 1 : : 2 ] ) . most_common ( ) <NEWLINE> a1 . append ( ( 0 , 0 ) ) <NEWLINE> a2 . append ( ( 0 , 0 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if a1 [ 0 ] != a2 [ 0 ] : <NEWLINE> <INDENT> print ( n - a1 [ 0 ] [ 1 ] - a2 [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n - a1 [ 0 ] [ 1 ] - a2 [ 1 ] [ 1 ] , n - a1 [ 1 ] [ 1 ] - a2 [ 0 ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = x <NEWLINE> <NL> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> x += tmp <NEWLINE> if x % y != 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> m = n - 1 <NEWLINE> g = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> g . append ( l [ i ] + l [ j ] ) <NEWLINE> <DEDENT> <DEDENT> g = sorted ( g , reverse = True ) <NEWLINE> for i in g : <NEWLINE> <INDENT> while l [ m ] >= i : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> cnt += n - m - 1 <NEWLINE> <DEDENT> print ( n * ( n - 1 ) * ( n - 2 ) // 6 - cnt ) <NEWLINE>
from collections import Counter <NEWLINE> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> A_list . append ( A ) <NEWLINE> <DEDENT> A_Counter = Counter ( A_list ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if K + A_Counter [ i ] - Q > 0 else <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = ( 10 ** 5 + 1 ) * [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a <= 10 ** 5 : <NEWLINE> <INDENT> B [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in range ( 10 ** 5 ) : <NEWLINE> <INDENT> if B [ n ] < n : <NEWLINE> <INDENT> ans += B [ n ] <NEWLINE> <DEDENT> elif n < B [ n ] : <NEWLINE> <INDENT> ans += B [ n ] - n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while A % 2 == 0 and B % 2 == 0 and C % 2 == 0 : <NEWLINE> <INDENT> a = B // 2 + C // 2 <NEWLINE> b = A // 2 + C // 2 <NEWLINE> c = A // 2 + B // 2 <NEWLINE> if A == a and B == b and C == c : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> A = a <NEWLINE> B = b <NEWLINE> C = c <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> r = N <NEWLINE> l = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l = max ( l , L [ i ] [ 0 ] ) <NEWLINE> r = min ( r , L [ i ] [ 1 ] ) <NEWLINE> <DEDENT> if r - l + 1 < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r - l + 1 ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> n , m = LI ( ) <NEWLINE> a = LI ( ) <NEWLINE> a = sorted ( a ) [ : : - 1 ] <NEWLINE> bc = LIR ( m ) <NEWLINE> bc = sorted ( bc , key = lambda x : x [ 1 ] ) [ : : - 1 ] <NEWLINE> all_c = [ ] <NEWLINE> for bi , ci in bc : <NEWLINE> <INDENT> all_c += [ ci ] * bi <NEWLINE> if len ( all_c ) >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( all_c ) < n : <NEWLINE> <INDENT> all_c += [ 0 ] * ( n - len ( all_c ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> a_i = 0 <NEWLINE> c_i = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if a [ a_i ] > all_c [ c_i ] : <NEWLINE> <INDENT> ans += a [ a_i ] <NEWLINE> a_i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += all_c [ c_i ] <NEWLINE> c_i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z <= k and z >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from itertools import accumulate <NEWLINE> n , c , * stc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> table = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> m = list ( zip ( stc [ : : 3 ] , stc [ 1 : : 3 ] , stc [ 2 : : 3 ] ) ) <NEWLINE> m . sort ( key = lambda a : ( a [ 2 ] , a [ 0 ] , a [ 1 ] ) ) <NEWLINE> <NL> ch_ = 0 <NEWLINE> t_ = 0 <NEWLINE> for s , t , ch in m : <NEWLINE> <INDENT> if ch != ch_ : <NEWLINE> <INDENT> ch_ = ch <NEWLINE> t_ = 0 <NEWLINE> <DEDENT> if t_ == s : <NEWLINE> <INDENT> table [ t_ + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ s ] += 1 <NEWLINE> <NL> <DEDENT> table [ t + 1 ] -= 1 <NEWLINE> t_ = t <NEWLINE> <NL> <DEDENT> * x , = accumulate ( table ) <NEWLINE> ans = max ( x ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
O = str ( input ( ) ) <NEWLINE> E = str ( input ( ) ) <NEWLINE> st = <STRING> <NEWLINE> if len ( O ) == len ( E ) : <NEWLINE> <INDENT> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> st += O [ i ] <NEWLINE> st += E [ i ] <NEWLINE> <DEDENT> print ( st ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( O ) - 1 ) : <NEWLINE> <INDENT> st += O [ i ] <NEWLINE> st += E [ i ] <NEWLINE> <NL> <DEDENT> print ( st + O [ - 1 ] ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] <NEWLINE> <DEDENT> <DEDENT> L [ N ] = L [ N - 1 ] <NEWLINE> for x in X : <NEWLINE> <INDENT> print ( L [ x [ 1 ] - 1 ] - L [ x [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> Edges = list ( [ ] for _ in range ( N ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> Edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> P = [ 0 for _ in range ( N ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> P [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> gone = [ False for _ in range ( N ) ] <NEWLINE> <NL> def dfs ( counter , count , cur_node ) : <NEWLINE> <INDENT> count += P [ cur_node ] <NEWLINE> gone [ cur_node ] = True <NEWLINE> counter [ cur_node ] += count <NEWLINE> for next_node in Edges [ cur_node ] : <NEWLINE> <INDENT> if gone [ next_node ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( counter , count , next_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> counter = [ 0 for _ in range ( N ) ] <NEWLINE> dfs ( counter , 0 , 0 ) <NEWLINE> <NL> for c in counter : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 18 <NEWLINE> left = 0 <NEWLINE> right = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( left - right ) ) <NEWLINE> left += A [ i ] <NEWLINE> right -= A [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> red_map = np . array ( [ input ( ) . split ( ) for i in range ( H ) ] , dtype = <STRING> ) <NEWLINE> blue_map = np . array ( [ input ( ) . split ( ) for i in range ( H ) ] , dtype = <STRING> ) <NEWLINE> sub_map = abs ( red_map - blue_map ) <NEWLINE> dp = [ [ 2020 ] * W for i in range ( H ) ] <NEWLINE> max_deviation = 2 ** ( 80 * ( H + W ) ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if not i and not j : <NEWLINE> <INDENT> dp [ i ] [ j ] = ( max_deviation << sub_map [ i ] [ j ] | max_deviation >> sub_map [ i ] [ j ] ) <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] |= ( dp [ i - 1 ] [ j ] << sub_map [ i ] [ j ] | dp [ i - 1 ] [ j ] >> sub_map [ i ] [ j ] ) <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] |= ( dp [ i ] [ j - 1 ] << sub_map [ i ] [ j ] | dp [ i ] [ j - 1 ] >> sub_map [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> pre_ans = dp [ H - 1 ] [ W - 1 ] >> 80 * ( H + W ) <NEWLINE> pre_ans_bit = format ( pre_ans & - pre_ans , <STRING> ) <NEWLINE> ans = len ( pre_ans_bit ) - 1 <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l . append ( lr [ i ] [ 0 ] ) <NEWLINE> r . append ( lr [ i ] [ 1 ] ) <NEWLINE> <DEDENT> lm = max ( l ) <NEWLINE> rm = min ( r ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if lm <= i <= rm : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> k = N - i - j <NEWLINE> if 1000 * i + j * 5000 + k * 10000 == Y and i + j + k == N and k >= 0 : <NEWLINE> <INDENT> print ( k , j , i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ L ] [ R ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> G [ i + 1 ] [ j + 1 ] += G [ i + 1 ] [ j ] + G [ i ] [ j + 1 ] - G [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = G [ q ] [ q ] - G [ p - 1 ] [ q ] - G [ q ] [ p - 1 ] + G [ p - 1 ] [ p - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> stud = [ ] <NEWLINE> poit = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> stud . append ( [ a , b ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> poit . append ( [ c , d ] ) <NEWLINE> <NL> <DEDENT> for a , b in stud : <NEWLINE> <INDENT> dist = float ( <STRING> ) <NEWLINE> for i , info in enumerate ( poit ) : <NEWLINE> <INDENT> c = info [ 0 ] <NEWLINE> d = info [ 1 ] <NEWLINE> mdist = abs ( a - c ) + abs ( b - d ) <NEWLINE> if dist > mdist : <NEWLINE> <INDENT> dist = mdist <NEWLINE> ans = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = list ( map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) ) <NEWLINE> P_cumsum = [ 0 ] + list ( accumulate ( P ) ) <NEWLINE> print ( max ( [ P_cumsum [ i + K ] - P_cumsum [ i ] for i in range ( N - K + 1 ) ] ) / 2 ) <NEWLINE>
import itertools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> N , K = I ( ) <NEWLINE> S = list ( s ( ) ) <NEWLINE> num = 1 <NEWLINE> cnt = 0 <NEWLINE> L = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> L . append ( num ) <NEWLINE> num = 0 <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> num += 1 <NEWLINE> <DEDENT> L . append ( num ) <NEWLINE> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ruiseki = [ 0 ] + list ( itertools . accumulate ( L ) ) <NEWLINE> l = len ( ruiseki ) <NEWLINE> if cnt <= K : <NEWLINE> <INDENT> print ( N ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> start = 0 <NEWLINE> ans = 0 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> start = 1 <NEWLINE> <DEDENT> for i in range ( start , l , 2 ) : <NEWLINE> <INDENT> if i + K * 2 + 1 > l - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , ruiseki [ i + K * 2 + 1 ] - ruiseki [ i ] ) <NEWLINE> <DEDENT> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , ruiseki [ K * 2 ] ) <NEWLINE> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , ruiseki [ - 1 ] - ruiseki [ l - K * 2 - 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> sum += p [ i ] <NEWLINE> <DEDENT> max = sum <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> sum += p [ k - 1 + i ] - p [ i - 1 ] <NEWLINE> if sum > max : <NEWLINE> <INDENT> max = sum <NEWLINE> <DEDENT> <DEDENT> ans = ( max + k ) * 0.5 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , T , * AB = map ( int , read ( ) . split ( ) ) <NEWLINE> D = [ ( a , b ) for a , b in zip ( * [ iter ( AB ) ] * 2 ) ] <NEWLINE> <NL> D . sort ( ) <NEWLINE> <NL> dp = [ 0 ] * T <NEWLINE> ans = 0 <NEWLINE> <NL> for i , ( a , b ) in enumerate ( D [ : - 1 ] ) : <NEWLINE> <INDENT> for t in range ( T - 1 , a - 1 , - 1 ) : <NEWLINE> <INDENT> if dp [ t ] < dp [ t - a ] + b : <NEWLINE> <INDENT> dp [ t ] = dp [ t - a ] + b <NEWLINE> <DEDENT> <DEDENT> if ans < dp [ T - 1 ] + D [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> ans = dp [ T - 1 ] + D [ i + 1 ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def luc ( x ) : <NEWLINE> <INDENT> x1 = 2 <NEWLINE> x2 = 1 <NEWLINE> if x == 1 : <NEWLINE> <INDENT> return x1 <NEWLINE> <DEDENT> elif x == 2 : <NEWLINE> <INDENT> return x2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x - 2 ) : <NEWLINE> <INDENT> x1 , x2 = x2 , x1 + x2 <NEWLINE> <DEDENT> return x2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( luc ( n + 1 ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> cnt = 0 <NEWLINE> x = math . inf <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if min ( x , i [ j ] ) == i [ j ] : <NEWLINE> <INDENT> x = i [ j ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> sorted_list = sorted ( a , reverse = True ) <NEWLINE> a_max = sorted_list [ 0 ] <NEWLINE> a_sec = sorted_list [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != a_max : <NEWLINE> <INDENT> print ( a_max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a_sec ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 20 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( abs ( xlist [ i ] - xlist [ i + k - 1 ] ) + min ( abs ( xlist [ i ] ) , abs ( xlist [ i + k - 1 ] ) ) , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> small = 0 <NEWLINE> dp = [ ] <NEWLINE> <NL> for idx , data in enumerate ( numbers ) : <NEWLINE> <INDENT> if idx == 0 : <NEWLINE> <INDENT> small = data <NEWLINE> dp . append ( data ) <NEWLINE> <DEDENT> elif data < small : <NEWLINE> <INDENT> small = data <NEWLINE> dp . append ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( len ( dp ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 ] * 10 ** 5 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> count [ i - 1 ] += 1 <NEWLINE> <DEDENT> count [ i ] += 1 <NEWLINE> if i < 10 ** 5 - 1 : <NEWLINE> <INDENT> count [ i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( count ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> graph [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> K -= 1 <NEWLINE> query = [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> <NL> <NL> seen = { K } <NEWLINE> v = [ K ] <NEWLINE> distfromK = [ 0 ] * N <NEWLINE> while len ( v ) != 0 : <COMMENT> <NEWLINE> <INDENT> for nv in graph [ v [ 0 ] ] : <NEWLINE> <INDENT> if nv [ 0 ] in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> distfromK [ nv [ 0 ] ] = distfromK [ v [ 0 ] ] + nv [ 1 ] <NEWLINE> v . append ( nv [ 0 ] ) <NEWLINE> seen . add ( nv [ 0 ] ) <NEWLINE> <DEDENT> v . pop ( 0 ) <NEWLINE> <NL> <DEDENT> for q in query : <NEWLINE> <INDENT> print ( distfromK [ q [ 0 ] - 1 ] + distfromK [ q [ 1 ] - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> def t ( S ) : <NEWLINE> <NL> <INDENT> N = len ( S ) <NEWLINE> <NL> a = [ 0 ] * ( N + 1 ) <NEWLINE> d = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a [ i + 1 ] += a [ i ] <NEWLINE> d [ i + 1 ] += d [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> S = in_s ( ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> ans = 0 <NEWLINE> for ts in S . split ( ) : <NEWLINE> <INDENT> ans += t ( ts ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> ) <NEWLINE> def get_expv ( N , i , j , k , expv ) : <NEWLINE> <INDENT> result = 0.0 <NEWLINE> if expv [ i ] [ j ] [ k ] != - 1 : <NEWLINE> <INDENT> return expv [ i ] [ j ] [ k ] <NEWLINE> <DEDENT> nonlp = 1.0 - ( N - i - j - k ) / N <NEWLINE> result += 1 <NEWLINE> if i != 0 : <NEWLINE> <INDENT> result += get_expv ( N , i - 1 , j , k , expv ) * ( i / N ) <NEWLINE> <DEDENT> if j != 0 : <NEWLINE> <INDENT> result += get_expv ( N , i + 1 , j - 1 , k , expv ) * ( j / N ) <NEWLINE> <DEDENT> if k != 0 : <NEWLINE> <INDENT> result += get_expv ( N , i , j + 1 , k - 1 , expv ) * ( k / N ) <NEWLINE> <DEDENT> result /= nonlp <NEWLINE> expv [ i ] [ j ] [ k ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> sushi_count = { 1 : 0 , 2 : 0 , 3 : 0 } <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> sushi_count [ a ] += 1 <NEWLINE> <DEDENT> sh = ( N + 1 , N - sushi_count [ 1 ] + 1 , sushi_count [ 3 ] + 1 ) <NEWLINE> expv = np . full ( sh , - 1.0 ) <NEWLINE> <NL> expv [ 0 ] [ 0 ] [ 0 ] = 0.0 <NEWLINE> <NL> print ( get_expv ( N , sushi_count [ 1 ] , sushi_count [ 2 ] , sushi_count [ 3 ] , expv ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect_left ( L , L [ i ] + L [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n -= 2 <NEWLINE> m -= 2 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if n == 0 or m == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> elif n == - 1 and m == - 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> elif n == - 1 or m == - 1 : <NEWLINE> <INDENT> ans = max ( n , m ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = n * m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> from itertools import product <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> maze = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> points = [ ( y , x ) for y , x in product ( range ( H ) , range ( W ) ) if maze [ y ] [ x ] == <STRING> ] <NEWLINE> <NL> ans = 0 <NEWLINE> for sy , sx in points : <NEWLINE> <INDENT> costs = { } <NEWLINE> queue = deque ( ) <NEWLINE> queue . append ( ( sy , sx , 0 ) ) <NEWLINE> while queue : <NEWLINE> <INDENT> y , x , cost = queue . popleft ( ) <NEWLINE> if ( y , x ) in costs : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> costs [ ( y , x ) ] = cost <NEWLINE> <NL> <DEDENT> for ny , nx in ( ( y + 1 , x ) , ( y - 1 , x ) , ( y , x + 1 ) , ( y , x - 1 ) ) : <NEWLINE> <INDENT> if not 0 <= ny < H : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not 0 <= nx < W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( ny , nx ) in costs : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if maze [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> queue . append ( ( ny , nx , cost + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , max ( costs . values ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lst = [ 0 ] * ( N - 1 ) <NEWLINE> x = [ a [ 0 ] ] * ( N - 1 ) <NEWLINE> y = [ sum ( a ) - a [ 0 ] ] * ( N - 1 ) <NEWLINE> lst [ 0 ] = abs ( x [ 0 ] - y [ 0 ] ) <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> x [ i ] = x [ i - 1 ] + a [ i ] <NEWLINE> y [ i ] = y [ i - 1 ] - a [ i ] <NEWLINE> lst [ i ] = abs ( x [ i ] - y [ i ] ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> ans = min ( lst ) <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> nums [ 0 ] = 1 <NEWLINE> if 1 not in a : nums [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i not in a : nums [ i ] = nums [ i - 1 ] + nums [ i - 2 ] <NEWLINE> <DEDENT> print ( nums [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> yes = dict ( ) <NEWLINE> for i in range ( 3 , 1000 ) : <NEWLINE> <INDENT> if ( i * ( i - 1 ) ) % 2 == 0 : <NEWLINE> <INDENT> yes [ ( i * ( i - 1 ) ) // 2 ] = [ i , i - 1 ] <NEWLINE> <DEDENT> <DEDENT> tmp = max ( yes ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( 2 ) <NEWLINE> print ( 1 , 1 ) <NEWLINE> print ( 1 , 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> if n not in yes . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> xl , xs = yes [ n ] <NEWLINE> <NL> ans = [ [ ] for _ in range ( xl ) ] <NEWLINE> cnt = 1 <NEWLINE> idx = 0 <NEWLINE> while xs >= 0 : <NEWLINE> <INDENT> tmp = cnt <NEWLINE> for i in range ( idx , min ( xl , idx + 3 ) ) : <NEWLINE> <INDENT> for j in range ( xs ) : <NEWLINE> <INDENT> if cnt == tmp + 3 * ( xs - 1 ) : <NEWLINE> <INDENT> ans [ i ] . append ( tmp ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] . append ( cnt ) <NEWLINE> <NL> <DEDENT> if j != 0 and j != xs - 1 : <NEWLINE> <INDENT> ans [ idx + 2 + j ] . append ( cnt ) <NEWLINE> <DEDENT> if j != xs - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> idx += 3 <NEWLINE> xs -= 3 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> for ansi in ans : <NEWLINE> <INDENT> print ( len ( ansi ) , * ansi , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> AB = [ LI ( ) for _ in range ( N ) ] <NEWLINE> <NL> W = [ [ ] for _ in range ( M + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if 0 <= M - a : <NEWLINE> <INDENT> W [ M - a ] . append ( b ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> hq = [ ] <NEWLINE> for i in reversed ( W ) : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> heapq . heappush ( hq , - j ) <NEWLINE> <DEDENT> if hq : <NEWLINE> <INDENT> ans -= heapq . heappop ( hq ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) <NEWLINE> num_a = F // ( 100 * A ) <NEWLINE> num_b = F // ( 100 * B ) <NEWLINE> num_c = int ( ( F * E / ( E + 100 ) ) // C ) <NEWLINE> num_d = int ( ( F * E / ( E + 100 ) ) // D ) <NEWLINE> <NL> def check_w ( w_mizu , w_sato , F ) : <NEWLINE> <INDENT> return w_mizu + w_sato <= F <NEWLINE> <NL> <DEDENT> def check_tokeru ( w_mizu , w_sato , E ) : <NEWLINE> <INDENT> return 100 * w_sato / ( w_mizu + w_sato ) <= 100 * E / ( 100 + E ) <NEWLINE> <NL> <DEDENT> def culc_density ( w_mizu , w_sato ) : <NEWLINE> <INDENT> return 100 * w_sato / ( w_mizu + w_sato ) <NEWLINE> <NL> <DEDENT> max = [ 100 * A , 0 , 0 ] <COMMENT> <NEWLINE> for _a , _b , in product ( range ( num_a + 1 ) , range ( num_b + 1 ) ) : <NEWLINE> <INDENT> w_mizu = ( A * _a + B * _b ) * 100 <NEWLINE> if w_mizu == 0 or w_mizu >= F : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for _c , _d in product ( range ( num_c + 1 ) , range ( num_d + 1 ) ) : <NEWLINE> <INDENT> w_sato = ( C * _c + D * _d ) <NEWLINE> if w_sato == 0 or w_sato >= F or ( w_mizu + w_sato ) > F : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> density = culc_density ( w_mizu , w_sato ) <NEWLINE> <NL> if check_w ( w_mizu , w_sato , F ) and check_tokeru ( w_mizu , w_sato , E ) : <NEWLINE> <INDENT> if max [ 2 ] < density : <NEWLINE> <INDENT> max [ 0 ] = w_mizu + w_sato <NEWLINE> max [ 1 ] = w_sato <NEWLINE> max [ 2 ] = density <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if max [ 0 ] : <NEWLINE> <INDENT> print ( max [ 0 ] , max [ 1 ] ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> s = deque ( list ( input ( ) ) ) <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> cach = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if s == deque ( [ ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = s . popleft ( ) <NEWLINE> <NL> <DEDENT> if tmp != cach : <NEWLINE> <INDENT> ans += 1 <NEWLINE> cach = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s != deque ( [ ] ) : <NEWLINE> <INDENT> tmp += s . popleft ( ) <NEWLINE> ans += 1 <NEWLINE> cach = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = deque ( ) <NEWLINE> <NL> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . appendleft ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 != 0 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <NL> <DEDENT> print ( * b ) <NEWLINE>
import queue <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> seen = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> length = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( [ i , j ] ) <NEWLINE> seen [ i ] [ j ] = 1 <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> ci , cj = q . get ( ) <NEWLINE> for ni , nj in [ [ ci - 1 , cj ] , [ ci + 1 , cj ] , [ ci , cj - 1 ] , [ ci , cj + 1 ] ] : <NEWLINE> <INDENT> if 0 <= ni < h and 0 <= nj < w and s [ ni ] [ nj ] == <STRING> and seen [ ni ] [ nj ] == 0 : <NEWLINE> <INDENT> q . put ( [ ni , nj ] ) <NEWLINE> length [ ni ] [ nj ] = length [ ci ] [ cj ] + 1 <NEWLINE> seen [ ni ] [ nj ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , length [ ci ] [ cj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <NL> <INDENT> def __init__ ( self , n : int ) -> None : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , i : int ) -> None : <NEWLINE> <INDENT> if self . parent [ i ] == i : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . find ( self . parent [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , i : int , j : int ) -> None : <NEWLINE> <INDENT> root_i = self . find ( i ) <NEWLINE> root_j = self . find ( j ) <NEWLINE> if root_i == root_j : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ root_i ] < self . rank [ root_j ] : <NEWLINE> <INDENT> self . parent [ root_i ] = root_j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ root_j ] = root_i <NEWLINE> if self . rank [ root_i ] == self . rank [ root_j ] : <NEWLINE> <INDENT> self . rank [ root_i ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf1 = UnionFind ( N ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> uf1 . unite ( i - 1 , j - 1 ) <NEWLINE> <NL> <DEDENT> uf2 = UnionFind ( N ) <NEWLINE> for _ in range ( L ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> uf2 . unite ( i - 1 , j - 1 ) <NEWLINE> <NL> <DEDENT> set_id_pairs = [ ( uf1 . find ( i ) , uf2 . find ( i ) ) for i in range ( N ) ] <NEWLINE> counter = Counter ( set_id_pairs ) <NEWLINE> counts = [ counter [ set_id_pairs [ i ] ] for i in range ( N ) ] <NEWLINE> print ( <STRING> . join ( str ( c ) for c in counts ) ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while i < len ( S ) and S [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> if i >= K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * n <NEWLINE> f = 0 <NEWLINE> visited [ f ] = True <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t = a [ f ] <NEWLINE> if t == 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> if visited [ t ] : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> visited [ t ] = True <NEWLINE> f = t <NEWLINE> <DEDENT> print ( cnt ) if flg else print ( - 1 ) <NEWLINE>
import heapq , math <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , A ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> max_a = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , math . ceil ( max_a / 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> A = il ( ) <NEWLINE> o , t , f = 0 , 0 , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % 4 == 0 : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> elif a % 2 == 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> <DEDENT> if t > 0 : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> print ( <STRING> if o <= f + 1 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> nums = list ( map ( str , range ( 10 ) ) ) <NEWLINE> for i in nums : <NEWLINE> <INDENT> s1 = S . find ( i ) <NEWLINE> if s1 < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in nums : <NEWLINE> <INDENT> s2 = S . find ( j , s1 + 1 ) <NEWLINE> if s2 < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in nums : <NEWLINE> <INDENT> s3 = S . find ( k , s2 + 1 ) <NEWLINE> if s3 > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> E = [ 0 ] * ( N + 1 ) <NEWLINE> W = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> E [ i + 1 ] = E [ i ] + 1 <NEWLINE> W [ i + 1 ] = W [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E [ i + 1 ] = E [ i ] <NEWLINE> W [ i + 1 ] = W [ i ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> min = N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = W [ i ] - W [ 0 ] + E [ N ] - E [ i + 1 ] <NEWLINE> if S < min : <NEWLINE> <INDENT> min = S <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> used = list ( input ( ) for x in range ( n ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if used . count ( used [ i ] ) == 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if used [ i ] [ - 1 ] != used [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> def make_divisors ( n ) : <COMMENT> <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return n // lower_divisors [ - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> ans = make_divisors ( N ) <NEWLINE> print ( len ( str ( ans ) ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> A = [ I ( ) for _ in range ( N ) ] <NEWLINE> <NL> is_ok = True <NEWLINE> <NL> <COMMENT> <NL> if [ A [ i ] for i in range ( N ) if A [ i ] > i ] : <NEWLINE> <INDENT> is_ok = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] + 1 < A [ i + 1 ] : <NEWLINE> <INDENT> is_ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if is_ok : <NEWLINE> <COMMENT> <NL> <INDENT> ans = 0 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <DEDENT> <DEDENT> ans += A [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if is_ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> @ njit ( ( i8 , i8 , i8 [ : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( H , N , A , B ) : <NEWLINE> <INDENT> INF = 1 << 30 <NEWLINE> dp = np . full ( H + 1 , INF , np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for h in range ( A [ i ] , H ) : <NEWLINE> <INDENT> dp [ h ] = min ( dp [ h ] , dp [ h - A [ i ] ] + B [ i ] ) <NEWLINE> <DEDENT> dp [ H ] = min ( dp [ H ] , min ( dp [ H - A [ i ] : H ] + B [ i ] ) ) <NEWLINE> <DEDENT> ans = dp [ - 1 ] <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . zeros ( N , np . int64 ) <NEWLINE> B = np . zeros ( N , np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( main ( H , N , A , B ) ) <NEWLINE>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> t = n - r * i <NEWLINE> for j in range ( t // g + 1 ) : <NEWLINE> <INDENT> if ( n - ( r * i + g * j ) ) % b == 0 : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> while l < r : <NEWLINE> <INDENT> if s [ l ] != s [ r ] : <NEWLINE> <INDENT> if s [ l ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> elif s [ r ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - count <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> res = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , res ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> yakusuu = [ ] <NEWLINE> for i in range ( 1 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> yakusuu . append ( m // i ) <NEWLINE> if m // i == i : continue <NEWLINE> yakusuu . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for y in yakusuu : <NEWLINE> <INDENT> if y < n : continue <NEWLINE> if m % y == 0 : <NEWLINE> <INDENT> ans = max ( ans , m // y ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . add ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dp [ i ] += dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] = dp [ i ] % 1000000007 <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> flag = False <NEWLINE> L = [ 0 for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> flag = False <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> L [ i ] = cnt <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> print ( L [ r ] - L [ l ] ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( S [ i ] != <STRING> ) : <NEWLINE> <INDENT> ans . append ( S [ i ] ) <NEWLINE> <DEDENT> elif ( S [ i ] == <STRING> and len ( ans ) != 0 ) : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s3 = [ ] <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> <NL> s1 = s <NEWLINE> <NL> <NL> s2 = s1 [ K - 1 ] <NEWLINE> <NL> s3 = s2 . lower ( ) <NEWLINE> <NL> s1 [ K - 1 ] = s3 <NEWLINE> <NL> print ( <STRING> . join ( s1 ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = set ( range ( A , min ( A + K , B + 1 ) ) ) . union ( set ( range ( B , max ( A - 1 , B - K ) , - 1 ) ) ) <NEWLINE> <NL> print ( * sorted ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( ( b , c ) ) <NEWLINE> g [ b ] . append ( ( a , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> dist = [ - 1 ] * n <NEWLINE> <NL> def dfs ( st , depth = 0 ) : <NEWLINE> <INDENT> dist [ st ] = depth <NEWLINE> for to , c in g [ st ] : <NEWLINE> <INDENT> if dist [ to ] >= 0 : continue <NEWLINE> dfs ( to , depth + c ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( k - 1 , 0 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 ; y -= 1 <NEWLINE> print ( dist [ x ] + dist [ y ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> c = 0 <NEWLINE> i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> if c >= n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> i = l [ i - 1 ] <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> search_max = int ( sqrt ( N ) ) <NEWLINE> <NL> min_number = 10 ** 12 <NEWLINE> for x in range ( 1 , search_max + 1 ) : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> y = N // x <NEWLINE> if x + y < min_number : <NEWLINE> <INDENT> min_number = x + y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min_number - 2 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m . append ( <STRING> . join ( sorted ( str ( input ( ) ) ) ) ) <NEWLINE> <DEDENT> m = Counter ( m ) <NEWLINE> ans = 0 <NEWLINE> for j in m . values ( ) : <NEWLINE> <INDENT> ans += j * ( j - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> As . sort ( ) <NEWLINE> <NL> def isOK ( x ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for k , A in enumerate ( As , start = 1 ) : <NEWLINE> <INDENT> i = bisect_left ( As , x - A ) <NEWLINE> num += N - i <NEWLINE> if num >= M : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif num + ( N - k ) * N < M : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return num >= M <NEWLINE> <NL> <DEDENT> ng , ok = 2 * 10 ** 5 + 1 , 0 <NEWLINE> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ng + ok ) // 2 <NEWLINE> if isOK ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> score = 0 <NEWLINE> num = 0 <NEWLINE> accAs = list ( accumulate ( [ 0 ] + As ) ) <NEWLINE> for A in As : <NEWLINE> <INDENT> i = bisect_right ( As , ok - A ) <NEWLINE> score += A * ( N - i ) + accAs [ N ] - accAs [ i ] <NEWLINE> num += N - i <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = score + ok * ( M - num ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <COMMENT> <NEWLINE> N = 10 ** 6 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> x , y = MAP ( ) <NEWLINE> a = 2 * x - y <NEWLINE> b = 2 * y - x <NEWLINE> <NL> if a >= 0 and b >= 0 and a % 3 == 0 and b % 3 == 0 : <NEWLINE> <INDENT> a //= 3 <NEWLINE> b //= 3 <NEWLINE> ans = cmb ( a + b , a , 10 ** 9 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ i - 1 for i in range ( n + 2 ) ] <NEWLINE> r = [ i + 1 for i in range ( n + 2 ) ] <NEWLINE> ind = [ 0 ] * n <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ind [ a - 1 ] = i <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> x = ind [ i ] <NEWLINE> ans += ( i + 1 ) * ( r [ x ] - x ) * ( x - l [ x ] ) <NEWLINE> l [ r [ x ] ] , r [ l [ x ] ] , = l [ x ] , r [ x ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ a ] += b <NEWLINE> <NL> <DEDENT> v = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> v += ans [ i ] <NEWLINE> if ans [ i ] == 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> if v >= k : <NEWLINE> <INDENT> a = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> index_lst = [ ] <NEWLINE> grid_0 = [ 0 ] * ( W + 1 ) <NEWLINE> grid_0 [ 1 ] = 1 <NEWLINE> for _ in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> grid_1 = [ 0 ] * ( W + 1 ) <NEWLINE> for i , j in enumerate ( input ( ) , 1 ) : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> grid_1 [ i ] = ( grid_0 [ i ] + grid_1 [ i - 1 ] ) % m <NEWLINE> <DEDENT> <DEDENT> grid_0 = grid_1 <NEWLINE> <NL> <DEDENT> print ( grid_0 [ - 1 ] ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> self . parent = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , i ) : <NEWLINE> <INDENT> if self . parent [ i ] < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> r = self . root ( self . parent [ i ] ) <NEWLINE> self . parent [ i ] = r <NEWLINE> return r <NEWLINE> <NL> <DEDENT> def unite ( self , i , j ) : <NEWLINE> <INDENT> i = self . root ( i ) <NEWLINE> j = self . root ( j ) <NEWLINE> <NL> if i == j : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if i > j : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <NL> <DEDENT> self . parent [ i ] += self . parent [ j ] <NEWLINE> self . parent [ j ] = i <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def same ( self , i , j ) : <NEWLINE> <INDENT> return self . root ( i ) == self . root ( j ) <NEWLINE> <NL> <DEDENT> def size ( self , i ) : <NEWLINE> <INDENT> return - self . parent [ self . root ( i ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <NL> forest = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> forest . unite ( x , y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if forest . same ( i , p [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> t_lst = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> t_lst . sort ( ) <NEWLINE> answer = t_lst [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> t = t_lst [ i ] <NEWLINE> answer = lcm ( answer , t ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> dp = [ True ] + [ False ] * ( n + 1 ) <NEWLINE> way = [ 1 ] + [ 6 ** i for i in range ( 1 , 9 ) if 6 ** i <= n ] + [ 9 ** i for i in range ( 1 , 7 ) if 9 ** i <= n ] <NEWLINE> loop_counter = 0 <NEWLINE> while True : <NEWLINE> <INDENT> loop_counter += 1 <NEWLINE> newdp = [ False ] * ( n + 1 ) <NEWLINE> for w in way : <NEWLINE> <INDENT> for i in range ( w , n + 1 ) : <NEWLINE> <INDENT> if newdp [ i ] : continue <NEWLINE> if dp [ i - w ] : newdp [ i ] = True <NEWLINE> if newdp [ n ] : <NEWLINE> <INDENT> return loop_counter <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp = [ x for x in newdp ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( solve ( ) ) <NEWLINE>
import math <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> T = list ( str ( input ( ) ) ) <NEWLINE> g = math . gcd ( N , M ) <NEWLINE> gn , gm = N // g , M // g <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> if S [ i * gn ] != T [ i * gm ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( gn * gm * g ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 1 ] * N <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> B [ A [ x ] - 1 ] += x <NEWLINE> <DEDENT> for y in B : <NEWLINE> <INDENT> print ( y , end = <STRING> ) <NEWLINE> if y != B [ N - 1 ] : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> color = [ - 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> w %= 2 <NEWLINE> graph [ a ] . append ( ( b , w ) ) <NEWLINE> graph [ b ] . append ( ( a , w ) ) <NEWLINE> <NL> <DEDENT> next_q = [ ( 0 , 0 ) ] <NEWLINE> while len ( next_q ) > 0 : <NEWLINE> <INDENT> nw , nc = next_q . pop ( ) <NEWLINE> color [ nw ] = nc <NEWLINE> for nxt , nl in graph [ nw ] : <NEWLINE> <INDENT> if color [ nxt ] == - 1 : <NEWLINE> <INDENT> next_q . append ( ( nxt , ( nl + nc ) % 2 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in color : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i + 1 == ps [ i ] : <NEWLINE> <INDENT> tmp = ps [ i ] <NEWLINE> ps [ i ] = ps [ i + 1 ] <NEWLINE> ps [ i + 1 ] = tmp <NEWLINE> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if ps [ n - 1 ] == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> max_len = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> while j < n and s [ i : j ] in s [ j : ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> max_len = max ( max_len , j - i - 1 ) <NEWLINE> <NL> <DEDENT> print ( max_len ) <NEWLINE>
from collections import deque <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> pathes = [ ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> pathes . append ( ( a , b ) ) <NEWLINE> <DEDENT> childs = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for a , b in pathes : <NEWLINE> <INDENT> childs [ a ] . append ( b ) <NEWLINE> childs [ b ] . append ( a ) <NEWLINE> <DEDENT> cnt = [ 0 ] * ( N + 1 ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p ] += x <NEWLINE> <DEDENT> closed = [ False ] * ( N + 1 ) <NEWLINE> nodes = deque ( ) <NEWLINE> nodes . append ( 1 ) <NEWLINE> while len ( nodes ) != 0 : <NEWLINE> <INDENT> node = nodes . popleft ( ) <NEWLINE> closed [ node ] = True <NEWLINE> for c in childs [ node ] : <NEWLINE> <INDENT> if closed [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nodes . append ( c ) <NEWLINE> cnt [ c ] += cnt [ node ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> <NL> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , ( - 1 ) * ( - x // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> s = input ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i < len ( s ) - 1 and s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> print ( i + 1 , i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> elif i < len ( s ) - 2 and s [ i ] == s [ i + 2 ] : <NEWLINE> <INDENT> print ( i + 1 , i + 3 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for k in range ( 60 ) : <NEWLINE> <INDENT> x , y = 0 , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> x += 1 & a >> k <NEWLINE> <DEDENT> tmp = x * ( n - x ) % mod <NEWLINE> tmp *= pow ( 2 , k , mod ) <NEWLINE> ans += tmp <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> idx = 0 <NEWLINE> ans = <STRING> <NEWLINE> while idx < len ( S ) : <NEWLINE> <INDENT> ans += S [ idx ] <NEWLINE> idx += w <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a = [ str ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> <NL> n = 10 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if int ( a [ i ] [ - 1 ] ) < n and int ( a [ i ] [ - 1 ] ) != 0 : <NEWLINE> <INDENT> n = int ( a [ i ] [ - 1 ] ) <NEWLINE> cnt = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i == cnt : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> elif int ( a [ i ] [ - 1 ] ) == 0 : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = ( int ( a [ i ] ) // 10 + 1 ) * 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( int ( 10 ** 9 ) ) <NEWLINE> n , m = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> edges = collections . defaultdict ( list ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , d = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> edges [ s - 1 ] . append ( d - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> maxPath = 0 <NEWLINE> @ lru_cache ( None ) <NEWLINE> def dfs ( node ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in edges [ node ] : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i ) + 1 ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> maxPath = max ( dfs ( i ) , maxPath ) <NEWLINE> <DEDENT> print ( maxPath ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> k = [ ] <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> k . append ( s [ i ] ) <NEWLINE> k . append ( t [ i ] ) <NEWLINE> <DEDENT> if len ( s ) > len ( t ) : <NEWLINE> <INDENT> k . append ( s [ len ( s ) - 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( k ) ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> temp = d [ i - 1 ] + l [ i - 1 ] <NEWLINE> if temp > x : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> d . append ( temp ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = n + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> n = 0 <NEWLINE> i = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( set ( S [ i : i + 2 ] ) ) == 2 : <NEWLINE> <INDENT> S = S [ : i ] + S [ i + 2 : ] <NEWLINE> n += 2 <NEWLINE> if i != 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> h . append ( tmp ) <NEWLINE> <DEDENT> h = sorted ( h ) [ : : - 1 ] <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = min ( h [ i ] - h [ i + K - 1 ] , ans ) <NEWLINE> <DEDENT> print ( str ( ans ) ) <NEWLINE>
<NL> import sys <NEWLINE> from collections import deque <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def read_values ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def read_index ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def read_list ( ) : return list ( read_values ( ) ) <NEWLINE> def read_lists ( N ) : return [ read_list ( ) for n in range ( N ) ] <NEWLINE> <NL> H , W = read_values ( ) <NEWLINE> P = [ [ False for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> F = [ input ( ) . strip ( ) for i in range ( H ) ] <NEWLINE> <NL> def f ( h , w ) : <NEWLINE> <INDENT> S = deque ( ) <NEWLINE> S . append ( ( h , w ) ) <NEWLINE> P [ h ] [ w ] = True <NEWLINE> T = [ 0 , 1 ] <NEWLINE> while S : <NEWLINE> <INDENT> h , w = S . popleft ( ) <NEWLINE> for hh , ww in [ ( h + 1 , w ) , ( h - 1 , w ) , ( h , w + 1 ) , ( h , w - 1 ) ] : <NEWLINE> <INDENT> if not ( 0 <= hh < H and 0 <= ww < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if P [ hh ] [ ww ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if F [ hh ] [ ww ] == F [ h ] [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> P [ hh ] [ ww ] = True <NEWLINE> t = 0 if F [ hh ] [ ww ] == <STRING> else 1 <NEWLINE> T [ t ] += 1 <NEWLINE> S . append ( ( hh , ww ) ) <NEWLINE> <DEDENT> <DEDENT> return T [ 0 ] * T [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if P [ h ] [ w ] or F [ h ] [ w ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> res += f ( h , w ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def isPrime ( num ) : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for p in range ( 2 , num ) : <NEWLINE> <INDENT> if num % p == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> num = int ( n ) <NEWLINE> while True : <NEWLINE> <INDENT> if isPrime ( num ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> break <NEWLINE> <DEDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> dd = 0 , 1 , 0 , - 1 <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> def dist ( sr , sc ) : <NEWLINE> <INDENT> if G [ sr ] [ sc ] == <STRING> : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> memo = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> <NL> dq = deque ( ) <NEWLINE> dq . append ( ( sr , sc , 0 ) ) <NEWLINE> memo [ sr ] [ sc ] = 0 <NEWLINE> while dq : <NEWLINE> <INDENT> r , c , d = dq . popleft ( ) <NEWLINE> nd = d + 1 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nr = r + dd [ i ] <NEWLINE> nc = c + dd [ i ^ 1 ] <NEWLINE> if not ( 0 <= nr < H and 0 <= nc < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ~ memo [ nr ] [ nc ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if G [ nr ] [ nc ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dq . append ( ( nr , nc , nd ) ) <NEWLINE> memo [ nr ] [ nc ] = nd <NEWLINE> <NL> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for sr in range ( H ) : <NEWLINE> <INDENT> for sc in range ( W ) : <NEWLINE> <INDENT> ans = max ( ans , dist ( sr , sc ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = dict ( ) <NEWLINE> ans = 0 <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if M > A [ i ] [ 1 ] : <NEWLINE> <INDENT> M -= A [ i ] [ 1 ] <NEWLINE> ans += A [ i ] [ 0 ] * A [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ i ] [ 0 ] * M <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
