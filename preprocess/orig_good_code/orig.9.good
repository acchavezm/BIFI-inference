s = input ( ) <NEWLINE> p = 2019 <NEWLINE> t = 1 <NEWLINE> y = 0 <NEWLINE> c = [ 0 ] * p <NEWLINE> c [ 0 ] = 1 <NEWLINE> for x in map ( int , s [ : : - 1 ] ) : <NEWLINE> <INDENT> y = ( y + t * x ) % p <NEWLINE> c [ y ] += 1 <NEWLINE> t = ( t * 10 ) % p <NEWLINE> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in c ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = i ( ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if N < 27 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N -= 1 <NEWLINE> S . append ( chr ( ord ( <STRING> ) + N % 26 ) ) <NEWLINE> N = N // 26 <NEWLINE> <DEDENT> S . append ( chr ( ord ( <STRING> ) + N - 1 ) ) <NEWLINE> print ( <STRING> . join ( S [ : : - 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if count [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i * count [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = bc [ i ] <NEWLINE> ans += ( c - b ) * count [ b ] <NEWLINE> count [ c ] += count [ b ] <NEWLINE> count [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ 0 for i in range ( m ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> road [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if H [ road [ j ] [ 0 ] - 1 ] < H [ road [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ road [ j ] [ 0 ] - 1 ] = 1 <NEWLINE> <DEDENT> elif H [ road [ j ] [ 0 ] - 1 ] > H [ road [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ road [ j ] [ 1 ] - 1 ] = 1 <NEWLINE> <DEDENT> elif H [ road [ j ] [ 0 ] - 1 ] == H [ road [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ road [ j ] [ 0 ] - 1 ] = 1 <NEWLINE> ans [ road [ j ] [ 1 ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> total = sum ( ans ) <NEWLINE> print ( n - total ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = Counter ( l ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in counter . keys ( ) : <NEWLINE> <INDENT> print ( counter [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> n = ri ( ) <NEWLINE> s = rr ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ k ] != s [ j ] and s [ j ] != s [ i ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if A_l [ i ] < A_l [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> P = [ ] <NEWLINE> S = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> P . append ( int ( p ) ) <NEWLINE> S . append ( s ) <NEWLINE> <NL> <DEDENT> AC = np . zeros ( N ) <NEWLINE> WA = np . zeros ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if AC [ P [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> WA [ P [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC [ P [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> WA [ AC == 0 ] = 0 <NEWLINE> <NL> print ( int ( sum ( AC ) ) , int ( sum ( WA ) ) ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> kyo = abs ( b - a ) <NEWLINE> ti = v - w <NEWLINE> <NL> if w >= v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> if kyo / ti <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( math . pi * r ** 2 , math . pi * r * 2 ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) . strip ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , 2 * r * math . pi ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> print ( answer ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> answer = answer * a <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> print ( answer ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
a1 = int ( input ( ) ) <NEWLINE> b2 = input ( ) . split ( <STRING> ) <NEWLINE> <NL> def check ( a , b ) : <NEWLINE> <INDENT> score = 1 <NEWLINE> if <STRING> in b : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> score *= int ( b [ i ] ) <NEWLINE> if score > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> <DEDENT> print ( check ( a1 , b2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = input ( ) . split ( ) <NEWLINE> <NL> a_list_reverse = a_list [ : : - 1 ] <NEWLINE> <COMMENT> <NL> <NL> rusekiwa = [ 0 ] * ( len ( a_list_reverse ) - 1 ) <NEWLINE> sum_v = 0 <NEWLINE> for i in range ( len ( a_list_reverse ) - 1 ) : <NEWLINE> <INDENT> sum_v += int ( a_list_reverse [ i ] ) <NEWLINE> rusekiwa [ i ] = sum_v <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a_list ) - 1 ) : <NEWLINE> <INDENT> v = int ( a_list [ i ] ) * rusekiwa [ - 1 - ( i ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans += v <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return int ( a * b / int ( gcd ( a , b ) ) ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c_m = lcm ( nums [ 0 ] , nums [ 1 ] ) <NEWLINE> for n in nums [ 2 : ] : <NEWLINE> <INDENT> c_m = lcm ( c_m , n ) <NEWLINE> <DEDENT> print ( c_m ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = factorization ( n ) <NEWLINE> if a [ 0 ] [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = [ ] <NEWLINE> c = [ 0 , 1 , 3 , 6 , 10 , 15 , 21 , 28 , 36 , 45 , 55 , 66 , 78 , 91 , 105 , 120 , 136 , 153 , 171 , 190 ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b . append ( a [ i ] [ 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> for j in range ( len ( c ) ) : <NEWLINE> <INDENT> if b [ i ] == c [ j ] : <NEWLINE> <INDENT> ans += j <NEWLINE> break <NEWLINE> <DEDENT> elif b [ i ] < c [ j ] : <NEWLINE> <INDENT> ans += j - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ i + A [ i - 1 ] for i in range ( 1 , n + 1 ) ] <NEWLINE> C = Counter ( B ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i - A [ i - 1 ] <NEWLINE> if x in C . keys ( ) : <NEWLINE> <INDENT> ans += C [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> M = int ( 1e6 + 1 ) <NEWLINE> f = [ 0 ] * M <NEWLINE> for x in a : <NEWLINE> <INDENT> if f [ x ] != 0 : <NEWLINE> <INDENT> f [ x ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for nx in range ( x , M , x ) : <NEWLINE> <INDENT> f [ nx ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if f [ x ] == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> vc = [ ] <NEWLINE> for i , j in zip ( v , c ) : <NEWLINE> <INDENT> vc . append ( i - j ) <NEWLINE> <DEDENT> vc = sorted ( vc , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in vc : <NEWLINE> <INDENT> if i <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> radius = float ( input ( ) ) <NEWLINE> <NL> area = radius ** 2 * math . pi <NEWLINE> perimeter = 2 * radius * math . pi <NEWLINE> <NL> print ( <STRING> . format ( area , perimeter ) ) <NEWLINE> <DEDENT>
MOD = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> s = sum ( A ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> s -= a <NEWLINE> ans += ( a * s ) <NEWLINE> <NL> <DEDENT> ans %= MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] in d : <NEWLINE> <INDENT> d [ A [ i ] ] . append ( i + 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ i ] ] = [ i + 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> print ( len ( d [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def max_heapify ( a , i ) : <NEWLINE> <INDENT> global n <NEWLINE> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> largest = l if l <= n and a [ l ] > a [ i ] else i <NEWLINE> if r <= n and a [ r ] > a [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> a [ largest ] , a [ i ] = a [ i ] , a [ largest ] <NEWLINE> max_heapify ( a , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( int ( n / 2 ) , 0 , - 1 ) : <NEWLINE> <INDENT> max_heapify ( a , i ) <NEWLINE> <NL> <DEDENT> print ( <STRING> + <STRING> . join ( map ( str , a [ 1 : ] ) ) ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cost_lists = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> min_cost = 10 ** 9 <NEWLINE> unst_flag = False <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> combi_lists = list ( combinations ( range ( n ) , i ) ) <NEWLINE> <NL> for combi_list in combi_lists : <NEWLINE> <INDENT> tmp_list = list ( ) <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> tmp_unst = 0 <NEWLINE> for k in combi_list : <NEWLINE> <INDENT> tmp_unst += cost_lists [ k ] [ j ] <NEWLINE> <NL> <DEDENT> tmp_list . append ( tmp_unst ) <NEWLINE> <NL> <DEDENT> if min ( tmp_list ) >= x : <NEWLINE> <INDENT> tmp_cost = 0 <NEWLINE> for k in combi_list : <NEWLINE> <INDENT> tmp_cost += cost_lists [ k ] [ 0 ] <NEWLINE> <NL> <DEDENT> min_cost = min ( min_cost , tmp_cost ) <NEWLINE> unst_flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if unst_flag : <NEWLINE> <INDENT> print ( min_cost ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def input_one_number ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_multiple_number ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_multiple_number_as_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n = input_one_number ( ) <NEWLINE> a = input_multiple_number_as_list ( ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ssum = 0 <NEWLINE> <NL> sumA = sum ( a ) <NEWLINE> <NL> for _a in a : <NEWLINE> <INDENT> ssum += _a * ( sumA - _a ) <NEWLINE> <NL> <DEDENT> print ( ssum // 2 % mod ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> l = map ( int , input ( ) . split ( ) ) <NEWLINE> for j , k in enumerate ( l , 1 ) : <NEWLINE> <INDENT> p . append ( ( k , ( i , j ) ) ) <NEWLINE> <DEDENT> <DEDENT> p . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> dist = [ 0 ] * ( w * h + 1 ) <NEWLINE> <NL> def Q ( i , c , x , y ) : <NEWLINE> <INDENT> if i + d > w * h : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> _ , ( nx , ny ) = p [ i + d - 1 ] <NEWLINE> nc = c + abs ( nx - x ) + abs ( ny - y ) <NEWLINE> dist [ i + d ] = nc <NEWLINE> Q ( i + d , nc , nx , ny ) <NEWLINE> <NL> <DEDENT> for i in range ( d ) : <NEWLINE> <INDENT> n , ( x , y ) = p [ i ] <NEWLINE> Q ( n , 0 , x , y ) <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> res . append ( dist [ r ] - dist [ l ] ) <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( map ( str , res ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s = deque ( list ( input ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> flg = True <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> t , f , c = input ( ) . split ( ) <NEWLINE> if flg : <NEWLINE> <INDENT> if f == <STRING> : <NEWLINE> <INDENT> s . appendleft ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if f == <STRING> : <NEWLINE> <INDENT> s . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> if flg : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = list ( reversed ( s ) ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> for _ in <STRING> * k : <NEWLINE> <INDENT> b = [ 0 ] * n <NEWLINE> for i , t in enumerate ( a ) : <NEWLINE> <INDENT> if i > t : b [ i - t ] += 1 <NEWLINE> else : b [ 0 ] += 1 <NEWLINE> j = i - ~ t <NEWLINE> if j < n : b [ j ] -= 1 <NEWLINE> <DEDENT> a = [ * accumulate ( b ) ] <NEWLINE> if min ( a ) == n : break <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> COMMAND = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> com = input ( ) . split ( ) <NEWLINE> if com [ 0 ] == COMMAND [ 0 ] : <NEWLINE> <INDENT> ans . appendleft ( com [ 1 ] ) <NEWLINE> <DEDENT> elif com [ 0 ] == COMMAND [ 1 ] : <NEWLINE> <INDENT> if com [ 1 ] in ans : <NEWLINE> <INDENT> ans . remove ( com [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif com [ 0 ] == COMMAND [ 2 ] : <NEWLINE> <INDENT> ans . popleft ( ) <NEWLINE> <DEDENT> elif com [ 0 ] == COMMAND [ 3 ] : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for k in range ( i + 2 , n ) : <NEWLINE> <INDENT> if ( i + k ) % 2 != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = ( i + k ) // 2 <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( r ) * len ( g ) * len ( b ) - cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 1000000007 : <NEWLINE> <INDENT> ans = ans % 1000000007 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = a [ : n ] <NEWLINE> heapq . heapify ( l ) <NEWLINE> memo_l = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> memo_l [ 0 ] = sum ( a [ : n ] ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> memo_l [ i ] = memo_l [ i - 1 ] <NEWLINE> if l [ 0 ] < a [ n + i - 1 ] : <NEWLINE> <INDENT> x = heapq . heappop ( l ) <NEWLINE> heapq . heappush ( l , a [ n + i - 1 ] ) <NEWLINE> memo_l [ i ] += a [ n + i - 1 ] - x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> r = [ - a [ - i ] for i in range ( 1 , n + 1 ) ] <NEWLINE> heapq . heapify ( r ) <NEWLINE> memo_r = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> memo_r [ 0 ] = sum ( a [ - n : ] ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> memo_r [ i ] = memo_r [ i - 1 ] <NEWLINE> if abs ( r [ 0 ] ) > a [ - n - i ] : <NEWLINE> <INDENT> x = heapq . heappop ( r ) <NEWLINE> heapq . heappush ( r , - a [ - n - i ] ) <NEWLINE> memo_r [ i ] += x + a [ - n - i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = - 10 ** 20 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , memo_l [ i ] - memo_r [ n - i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S += A [ i ] <NEWLINE> <NL> <DEDENT> c = S <NEWLINE> d = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> c -= A [ j ] <NEWLINE> c = c % ( 10 ** 9 + 7 ) <NEWLINE> d += A [ j ] * c <NEWLINE> d = d % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( d ) <NEWLINE>
num = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] > num [ j ] : <NEWLINE> <INDENT> bigger = num [ i ] <NEWLINE> num [ i ] = num [ j ] <NEWLINE> num [ j ] = bigger <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( num ) - 1 ) : <NEWLINE> <INDENT> print ( num [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( num [ len ( num ) - 1 ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - A > 200 : <NEWLINE> <INDENT> k = range ( A , A + K ) <NEWLINE> l = range ( B - K + 1 , B + 1 ) <NEWLINE> for i in k : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = range ( A , B + 1 ) <NEWLINE> t = [ x for x in s if A <= x <= A + K - 1 or B - K + 1 <= x <= B ] <NEWLINE> t . sort ( ) <NEWLINE> for i in t : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> inf = 1 << 60 <NEWLINE> mod = 1000000007 <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> nin = lambda y : [ ni ( ) for _ in range ( y ) ] <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nan = lambda y : [ na ( ) for _ in range ( y ) ] <NEWLINE> nf = lambda : float ( ns ( ) ) <NEWLINE> nfn = lambda y : [ nf ( ) for _ in range ( y ) ] <NEWLINE> nfa = lambda : list ( map ( float , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nfan = lambda y : [ nfa ( ) for _ in range ( y ) ] <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> nsn = lambda y : [ ns ( ) for _ in range ( y ) ] <NEWLINE> ncl = lambda y : [ list ( ns ( ) ) for _ in range ( y ) ] <NEWLINE> nas = lambda : stdin . readline ( ) . split ( ) <NEWLINE> <NL> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans >= 1 and a [ i ] > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> b = N <NEWLINE> blis = [ ] <NEWLINE> c = 0 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 == 1 : <NEWLINE> <INDENT> blis . append ( c ) <NEWLINE> <DEDENT> c += 1 <NEWLINE> b >>= 1 <NEWLINE> <NL> <NL> <DEDENT> def modpow ( a , blis = blis , c = c ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> li = [ ] <NEWLINE> for _ in range ( c ) : <NEWLINE> <INDENT> li . append ( a % mod ) <NEWLINE> a = a * a % mod <NEWLINE> <DEDENT> for item in blis : <NEWLINE> <INDENT> res = res * li [ item ] % mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> fact_count = [ 0 for _ in range ( K + 1 ) ] <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> fact_count [ k ] = K // k <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> count = [ 0 for _ in range ( K + 1 ) ] <NEWLINE> for k in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> x = 1 * fact_count [ k ] <NEWLINE> cc = modpow ( x ) <NEWLINE> j = 2 * k <NEWLINE> l = 2 <NEWLINE> while ( j <= K ) : <NEWLINE> <INDENT> cc -= count [ j ] <NEWLINE> l += 1 <NEWLINE> j = k * l <NEWLINE> <DEDENT> count [ k ] = cc <NEWLINE> cc = cc * k % mod <NEWLINE> ans += cc <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
from collections import deque <NEWLINE> dic = { } <NEWLINE> def make_map ( a , b , dic ) : <NEWLINE> <INDENT> if a in dic . keys ( ) : <NEWLINE> <INDENT> dic [ a ] . append ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = [ b ] <NEWLINE> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> make_map ( a - 1 , b - 1 , dic ) <NEWLINE> make_map ( b - 1 , a - 1 , dic ) <NEWLINE> <DEDENT> queue = deque ( [ 0 ] ) <NEWLINE> count = 0 <NEWLINE> dekai = 10 ** 5 <NEWLINE> lenlist = [ dekai ] * N <NEWLINE> lenlist [ 0 ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> a = queue . popleft ( ) <NEWLINE> for i in dic [ a ] : <NEWLINE> <INDENT> if lenlist [ i ] == dekai or a == 0 : <NEWLINE> <INDENT> queue . append ( i ) <COMMENT> <NEWLINE> lenlist [ i ] = a <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for n in range ( 1 , N , 1 ) : <NEWLINE> <INDENT> print ( lenlist [ n ] + 1 ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> H , W , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> d1 = defaultdict ( int ) <NEWLINE> d2 = defaultdict ( int ) <NEWLINE> <NL> b = defaultdict ( int ) <NEWLINE> <NL> for h , w in hw : <NEWLINE> <INDENT> d1 [ h ] += 1 <NEWLINE> d2 [ w ] += 1 <NEWLINE> b [ ( h , w ) ] = 1 <NEWLINE> <NL> <DEDENT> m1 = max ( d1 . values ( ) ) <NEWLINE> m2 = max ( d2 . values ( ) ) <NEWLINE> <NL> e1 = [ k for k in d1 . keys ( ) if d1 [ k ] == m1 ] <NEWLINE> e2 = [ k for k in d2 . keys ( ) if d2 [ k ] == m2 ] <NEWLINE> <NL> flag = True <NEWLINE> <NL> for x in e1 : <NEWLINE> <INDENT> for y in e2 : <NEWLINE> <INDENT> if b [ ( x , y ) ] == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( m1 + m2 - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 + m2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> b = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> if i < 10 ** 5 : <NEWLINE> <INDENT> b [ i + 1 ] += 1 <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( b ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 0 <NEWLINE> x = n <NEWLINE> <NL> while x >= n - b : <NEWLINE> <INDENT> if m > ( a * x ) // b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = math . floor ( ( a * ( x / b - math . floor ( x / b ) ) ) ) <NEWLINE> if m < y : <NEWLINE> <INDENT> m = y <NEWLINE> x = b * math . floor ( x / b ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import queue <NEWLINE> <NL> def proceess ( start_x , start_y ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> new_island = queue . Queue ( ) <NEWLINE> map [ start_x ] [ start_y ] = 0 <NEWLINE> new_island . put ( [ start_x , start_y ] ) <NEWLINE> while True : <NEWLINE> <INDENT> ob = new_island . get ( ) <NEWLINE> x = ob [ 0 ] <NEWLINE> y = ob [ 1 ] <NEWLINE> <COMMENT> <NL> <NL> for i in [ - 1 , 0 , 1 ] : <NEWLINE> <INDENT> for j in [ - 1 , 0 , 1 ] : <NEWLINE> <INDENT> nx = x + i <NEWLINE> ny = y + j <NEWLINE> <NL> if nx >= 0 and ny >= 0 and nx < h and ny < w : <NEWLINE> <INDENT> if map [ nx ] [ ny ] == 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> new_island . put ( [ nx , ny ] ) <NEWLINE> map [ nx ] [ ny ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if new_island . empty ( ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> map = [ ] <NEWLINE> <NL> tmp = input ( ) . split ( <STRING> ) <NEWLINE> w = int ( tmp [ 0 ] ) <NEWLINE> h = int ( tmp [ 1 ] ) <NEWLINE> <NL> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> for j in range ( h ) : <NEWLINE> <INDENT> nova = [ ] <NEWLINE> arm = input ( ) <NEWLINE> for k in arm . split ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> nova . append ( int ( k ) ) <NEWLINE> <DEDENT> map . append ( nova ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if map [ i ] [ j ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> proceess ( i , j ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> <NL> S = a * b <NEWLINE> s = x / a <NEWLINE> if s == S : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif s >= S / 2 : <NEWLINE> <INDENT> em_s = S - s <NEWLINE> tan = ( a ** 2 ) / ( 2 * em_s ) <NEWLINE> ans = math . degrees ( math . atan ( tan ) ) <NEWLINE> print ( 90 - ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> tan = ( 2 * s ) / ( b ** 2 ) <NEWLINE> ans = math . degrees ( math . atan ( tan ) ) <NEWLINE> print ( 90 - ans ) <NEWLINE> <DEDENT>
dic = { } <NEWLINE> <NL> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> cmd , arg = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> dic [ arg ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if arg in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> T = tuple ( map ( int , input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> a = i // 100 <NEWLINE> b = ( i // 10 ) % 10 <NEWLINE> c = i % 10 <NEWLINE> flag1 = False <NEWLINE> flag2 = False <NEWLINE> flag3 = False <NEWLINE> for t in T : <NEWLINE> <INDENT> if flag2 : <NEWLINE> <INDENT> if t == c : <NEWLINE> <INDENT> flag3 = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag1 : <NEWLINE> <INDENT> if t == b : <NEWLINE> <INDENT> flag2 = True <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if t == a : <NEWLINE> <INDENT> flag1 = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> al = list ( range ( a , min ( b + 1 , a + k ) ) ) <NEWLINE> bl = list ( range ( max ( a , b - k + 1 ) , b + 1 ) ) <NEWLINE> l = sorted ( set ( al + bl ) ) <NEWLINE> for v in l : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <COMMENT> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> minA = min ( A ) <NEWLINE> sumA = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> sumA += i <NEWLINE> <NL> <NL> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> global n <NEWLINE> global A <NEWLINE> global minA <NEWLINE> global sumA <NEWLINE> <NL> if m < 0 or m > sumA : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if m < minA or m > sumA : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> b = a . copy ( ) <NEWLINE> b = list ( set ( b ) ) <NEWLINE> b . sort ( reverse = True ) <NEWLINE> c = [ 0 ] * len ( b ) <NEWLINE> j = 0 <NEWLINE> c [ j ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i - 1 ] == a [ i ] : <NEWLINE> <INDENT> c [ j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> c [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if c [ i ] >= 4 : <NEWLINE> <NL> <INDENT> ans = b [ i ] * b [ i ] <NEWLINE> break <NEWLINE> <DEDENT> elif c [ i ] >= 2 : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( b ) ) : <NEWLINE> <INDENT> if c [ j ] >= 2 : <NEWLINE> <INDENT> ans = b [ i ] * b [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
count = { } <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S in count : <NEWLINE> <INDENT> count [ S ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ S ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( count . values ( ) ) <NEWLINE> print ( * sorted ( [ A [ 0 ] for A in count . items ( ) if A [ 1 ] == ans ] ) ) <NEWLINE>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * m <NEWLINE> c = [ 0 ] * m <NEWLINE> d = dict ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for x in range ( m ) : <NEWLINE> <INDENT> s [ x ] , c [ x ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if s [ x ] not in d : <NEWLINE> <INDENT> d [ s [ x ] ] = c [ x ] <NEWLINE> <DEDENT> elif d [ s [ x ] ] != c [ x ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if x in d : <NEWLINE> <INDENT> if x != 1 : <NEWLINE> <INDENT> ans += str ( d [ x ] ) <NEWLINE> <DEDENT> elif x == 1 and d [ x ] != 0 : <NEWLINE> <INDENT> ans += str ( d [ x ] ) <NEWLINE> <DEDENT> elif n == 1 and d [ x ] == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if m != 0 : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> ans += str ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += str ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> ans = str ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> + ( <STRING> * ( n - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> sums = [ 0 ] * ( n - 1 ) <NEWLINE> <NL> for j in range ( n - 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> sums [ 0 ] = nums [ 0 ] % x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sums [ j ] = ( sums [ j - 1 ] + nums [ j ] ) % x <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( nums ) ) : <NEWLINE> <INDENT> ans += sums [ i - 1 ] * nums [ i ] <NEWLINE> ans = ans % x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> cnt [ a - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , cnt ) ) ) <NEWLINE> <COMMENT> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> d = sum ( A ) <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> d -= A [ i ] <NEWLINE> c += A [ i ] * d <NEWLINE> if ( c > 10 ** 9 + 7 ) : <NEWLINE> <INDENT> c %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = [ float ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( <STRING> % math . sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) ) ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> mia = sorted ( [ i for i in a if i < 0 ] , reverse = True ) <NEWLINE> pla = sorted ( [ i for i in a if i >= 0 ] ) <NEWLINE> ans , num = 1 , [ ] <NEWLINE> <NL> if len ( pla ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> for i in mia [ : k ] : <NEWLINE> <INDENT> ans = ans * i % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> if len ( mia ) > 0 and len ( pla ) > 0 : <NEWLINE> <INDENT> if abs ( mia [ - 1 ] ) <= pla [ - 1 ] : <NEWLINE> <INDENT> tmp = pla . pop ( ) <NEWLINE> <DEDENT> elif abs ( mia [ - 1 ] ) > pla [ - 1 ] : <NEWLINE> <INDENT> tmp = mia . pop ( ) <NEWLINE> <DEDENT> <DEDENT> elif len ( mia ) == 0 : <NEWLINE> <INDENT> tmp = pla . pop ( ) <NEWLINE> <DEDENT> elif len ( pla ) == 0 : <NEWLINE> <INDENT> tmp = mia . pop ( ) <NEWLINE> <DEDENT> num . append ( tmp ) <NEWLINE> <NL> <DEDENT> cnt = sum ( i < 0 for i in num ) <NEWLINE> for i in num : <NEWLINE> <INDENT> ans = ans * i % mod <NEWLINE> <NL> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> if len ( mia ) > 0 and cnt != k : <NEWLINE> <INDENT> for i in num [ : : - 1 ] : <NEWLINE> <INDENT> if i >= 0 : <NEWLINE> <INDENT> p , q = i , mia [ - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if len ( pla ) == 0 : <NEWLINE> <INDENT> ans *= q * pow ( p , mod - 2 , mod ) <NEWLINE> <DEDENT> <DEDENT> if len ( pla ) > 0 : <NEWLINE> <INDENT> for i in num [ : : - 1 ] : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> r , s = i , pla [ - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if len ( mia ) == 0 or cnt == k : <NEWLINE> <INDENT> ans *= s * pow ( r , mod - 2 , mod ) <NEWLINE> <DEDENT> <DEDENT> if len ( mia ) > 0 and len ( pla ) > 0 and cnt != k : <NEWLINE> <INDENT> if q * r >= p * s : <NEWLINE> <INDENT> ans *= q * pow ( p , mod - 2 , mod ) <NEWLINE> <DEDENT> if q * r < p * s : <NEWLINE> <INDENT> ans *= s * pow ( r , mod - 2 , mod ) <NEWLINE> <DEDENT> <DEDENT> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> plus_lis = [ A [ i ] + i for i in range ( N ) ] <NEWLINE> minus_lis = [ k - A [ k ] for k in range ( N ) ] <NEWLINE> <NL> ans_lis = [ 0 ] * 10 ** 6 <NEWLINE> for x in plus_lis : <NEWLINE> <INDENT> if x < 10 ** 6 : <NEWLINE> <INDENT> ans_lis [ x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for y in minus_lis : <NEWLINE> <INDENT> if y > 0 : <NEWLINE> <INDENT> ans += ans_lis [ y - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> ans = [ 1 ] * n <NEWLINE> <NL> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if H [ a [ j ] - 1 ] < H [ b [ j ] - 1 ] : <NEWLINE> <INDENT> ans [ a [ j ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a [ j ] - 1 ] > H [ b [ j ] - 1 ] : <NEWLINE> <INDENT> ans [ b [ j ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a [ j ] - 1 ] == H [ b [ j ] - 1 ] : <NEWLINE> <INDENT> ans [ a [ j ] - 1 ] = 0 <NEWLINE> ans [ b [ j ] - 1 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def cmb ( n , r , p ) : <NEWLINE> <INDENT> if r < 0 or n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return facto [ n ] * factoinv [ r ] * factoinv [ n - r ] % p <NEWLINE> <DEDENT> p = 10 ** 9 + 7 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> facto = [ 1 , 1 ] <NEWLINE> <COMMENT> <NL> factoinv = [ 1 , 1 ] <NEWLINE> <COMMENT> <NL> inv = [ 0 , 1 ] <NEWLINE> <COMMENT> <NL> for i in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> facto . append ( ( facto [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factoinv . append ( ( factoinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <DEDENT> if n == m : <NEWLINE> <INDENT> kosuub = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> kosuub += ( facto [ ( n - i ) ] * cmb ( n , i , p ) * ( ( - 1 ) ** i ) ) % p <NEWLINE> <DEDENT> kosuu = ( kosuub * facto [ ( n ) ] ) % p <NEWLINE> print ( kosuu ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kosuub = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> kosuub += ( cmb ( ( m - i ) , ( n - i ) , p ) * facto [ ( n - i ) ] * cmb ( n , i , p ) * ( ( - 1 ) ** i ) ) % p <NEWLINE> <DEDENT> kosuu = ( kosuub * cmb ( m , n , p ) * facto [ n ] ) % p <NEWLINE> print ( kosuu ) <NEWLINE> <DEDENT>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> ans = [ ] <NEWLINE> def move ( inc , dec ) : <NEWLINE> <INDENT> d [ inc ] += 1 <NEWLINE> d [ dec ] -= 1 <NEWLINE> ans . append ( inc ) <NEWLINE> <DEDENT> q = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = q [ i ] [ 0 ] <NEWLINE> y = q [ i ] [ 1 ] <NEWLINE> if d [ x ] == 0 and d [ y ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if d [ x ] == 1 and d [ y ] == 1 : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> move ( x , y ) <NEWLINE> continue <NEWLINE> <DEDENT> if x in q [ i + 1 ] : <NEWLINE> <INDENT> move ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> move ( y , x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d [ x ] >= d [ y ] : <NEWLINE> <INDENT> move ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> move ( x , y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
<NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> path = [ 0 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> path . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ A ] . append ( B ) <NEWLINE> path [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( path [ i ] ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif H [ i ] > max ( H [ j ] for j in path [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> multi = 1 <NEWLINE> if min ( a ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> multi = multi * a [ i ] <NEWLINE> if multi > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if multi <= 1000000000000000000 : <NEWLINE> <INDENT> print ( multi ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Alist = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> result = 1 <NEWLINE> for A in Alist : <NEWLINE> <INDENT> result *= A <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> if 0 in Alist : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> rec = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if rec [ 0 ] == 0 and rec [ 1 ] == 0 : break <NEWLINE> for i in range ( rec [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( rec [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , K = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> N = [ A , B , C ] <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> K -= N [ i ] <NEWLINE> if K == 0 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> N [ i + 1 ] = 0 <NEWLINE> N [ i + 2 ] = 0 <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> N [ i + 1 ] = 0 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> elif K < 0 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> N [ i + 1 ] = 0 <NEWLINE> N [ i + 2 ] = 0 <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> N [ i + 1 ] = 0 <NEWLINE> <DEDENT> N [ i ] += K <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( 1 * N [ 0 ] - 1 * N [ 2 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n , k = [ 0 ] * 2 <NEWLINE> a = [ ] <NEWLINE> <NL> def format_input ( filename = None ) : <NEWLINE> <INDENT> global n , k <NEWLINE> global a <NEWLINE> if filename == None : <NEWLINE> <INDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> elif filename == <STRING> : <NEWLINE> <INDENT> from random import randint as rng <NEWLINE> n = rng ( 2 , 2 * 10 ** 5 ) <NEWLINE> k = rng ( 1 , 10 ** 18 ) <NEWLINE> a = [ rng ( 1 , n ) for i in range ( n ) ] <NEWLINE> print ( n , k ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , a ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_answer ( ) : <NEWLINE> <INDENT> loop = [ 1 ] <NEWLINE> loop_index = defaultdict ( int ) <NEWLINE> start = - 1 <NEWLINE> while start == - 1 and len ( loop ) < k + 1 : <NEWLINE> <INDENT> node = a [ loop [ - 1 ] - 1 ] <NEWLINE> if loop_index [ node ] > 0 : <NEWLINE> <INDENT> start = loop_index [ node ] <NEWLINE> <DEDENT> elif node == 1 : <NEWLINE> <INDENT> start = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop . append ( node ) <NEWLINE> loop_index [ node ] = len ( loop ) - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> l = len ( loop ) <NEWLINE> if k >= l : <NEWLINE> <INDENT> answer = loop [ ( k - l ) % ( l - start ) + start ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = loop [ k ] <NEWLINE> <NL> <DEDENT> return answer <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> format_input ( ) <NEWLINE> <NL> ans = get_answer ( ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = a <NEWLINE> if k < a : <NEWLINE> <INDENT> ans = k <NEWLINE> <NL> <DEDENT> if k > a + b : <NEWLINE> <INDENT> ans = ans - ( k - ( a + b ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
residents = [ [ [ 0 ] * 11 for i in range ( 4 ) ] for j in range ( 5 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for _i in range ( N ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> residents [ b ] [ f ] [ r ] += v <NEWLINE> <DEDENT> for i in range ( 1 , 5 ) : <NEWLINE> <INDENT> for j in range ( 1 , 4 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , residents [ i ] [ j ] [ 1 : ] ) ) ) <NEWLINE> <DEDENT> if not i == 4 : <NEWLINE> <INDENT> print ( <STRING> . join ( [ <STRING> ] * 20 ) ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n = input ( ) <NEWLINE> d = deque ( ) <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> command = input ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . appendleft ( command [ 7 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if command [ 6 ] == <STRING> : <NEWLINE> <INDENT> if command [ 7 : ] in d : <NEWLINE> <INDENT> d . remove ( command [ 7 : ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if command [ 6 ] == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for _ in range ( len ( d ) - 1 ) : <NEWLINE> <INDENT> print ( d . popleft ( ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( d . pop ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> ii = i <NEWLINE> while ( ii > 1 ) : <NEWLINE> <INDENT> if ii % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ii //= 10 <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
from itertools import combinations <NEWLINE> from collections import Counter <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> L = [ 0 ] <NEWLINE> C = [ 0 ] <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l = int ( input ( ) ) <NEWLINE> x += l <NEWLINE> L . append ( x ) <NEWLINE> <NL> <DEDENT> dL = Counter ( [ max ( x1 , x2 ) - min ( x1 , x2 ) for ( x1 , x2 ) in combinations ( L , 2 ) ] ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> y += c <NEWLINE> C . append ( y ) <NEWLINE> <DEDENT> for y1 , y2 in combinations ( C , 2 ) : <NEWLINE> <INDENT> dy = max ( y1 , y2 ) - min ( y1 , y2 ) <NEWLINE> if dy in dL : <NEWLINE> <INDENT> count += dL [ dy ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def warshall_floyd ( d ) : <NEWLINE> <COMMENT> <NL> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> d [ i ] [ j ] = min ( d [ i ] [ k ] + d [ k ] [ j ] , d [ i ] [ j ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> d = [ [ float ( <STRING> ) ] * n for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> hen = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ x - 1 ] [ y - 1 ] = z <NEWLINE> d [ y - 1 ] [ x - 1 ] = z <NEWLINE> hen [ i ] = [ x - 1 , y - 1 , z ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] [ i ] = 0 <COMMENT> <NEWLINE> <NL> <DEDENT> ans = warshall_floyd ( d ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> answer = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> now = hen [ i ] <NEWLINE> if d [ now [ 0 ] ] [ now [ 1 ] ] != now [ 2 ] : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL>
<COMMENT> <NL> [ p , rank ] = [ [ ] , [ ] ] <NEWLINE> [ n , q ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = [ 0 for i in range ( n ) ] <NEWLINE> <NL> def makeSet ( x ) : <NEWLINE> <INDENT> global p , rank <NEWLINE> p . append ( x ) <NEWLINE> rank . append ( 0 ) <NEWLINE> <NL> <DEDENT> def findSet ( x ) : <NEWLINE> <INDENT> global p <NEWLINE> if x != p [ x ] : <NEWLINE> <INDENT> pre_parent = p [ x ] <NEWLINE> p [ x ] = findSet ( p [ x ] ) <NEWLINE> w [ x ] += w [ pre_parent ] <NEWLINE> <DEDENT> return p [ x ] <NEWLINE> <NL> <DEDENT> def link ( x , y , z ) : <NEWLINE> <INDENT> global p , rank , w <NEWLINE> if rank [ x ] > rank [ y ] : <NEWLINE> <INDENT> p [ y ] = x <NEWLINE> w [ y ] = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ x ] = y <NEWLINE> w [ x ] = - z <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ y ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> if findSet ( x ) == findSet ( y ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def relate ( x , y , z ) : <NEWLINE> <INDENT> global w <NEWLINE> root_x = findSet ( x ) <NEWLINE> root_y = findSet ( y ) <NEWLINE> z += w [ x ] <NEWLINE> z -= w [ y ] <NEWLINE> link ( root_x , root_y , z ) <NEWLINE> <NL> <DEDENT> def diff ( x , y ) : <NEWLINE> <INDENT> if same ( x , y ) == 1 : <NEWLINE> <INDENT> global w <NEWLINE> return w [ y ] - w [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> makeSet ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if data [ 0 ] == 0 : <NEWLINE> <INDENT> relate ( data [ 1 ] , data [ 2 ] , data [ 3 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( diff ( data [ 1 ] , data [ 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def bfs ( goal , graph , seen , next_v ) : <NEWLINE> <INDENT> for x in graph [ next_v [ 0 ] [ 0 ] ] : <NEWLINE> <INDENT> if x == goal : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> next_v . append ( ( x , next_v [ 0 ] [ 1 ] + 1 ) ) <NEWLINE> seen . add ( x ) <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> next_v = [ ( 0 , 0 ) ] <NEWLINE> seen = { 0 } <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> if len ( next_v ) == 0 or next_v [ 0 ] [ 1 ] == 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if bfs ( N - 1 , graph , seen , next_v ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> next_v . pop ( 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = set ( p ) <NEWLINE> p = [ ] <NEWLINE> for x1 in range ( - 100 , 200 ) : <NEWLINE> <INDENT> if x1 in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . append ( x1 ) <NEWLINE> <DEDENT> <DEDENT> mind = abs ( x - p [ 0 ] ) <NEWLINE> pos = [ p [ 0 ] ] <NEWLINE> for q in p : <NEWLINE> <INDENT> if abs ( x - q ) < mind : <NEWLINE> <COMMENT> <NL> <INDENT> mind = abs ( x - q ) <NEWLINE> pos = [ q ] <NEWLINE> <DEDENT> elif abs ( x - q ) == mind : <NEWLINE> <INDENT> pos . append ( q ) <NEWLINE> <DEDENT> <DEDENT> pos . sort ( ) <NEWLINE> print ( pos [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> def prime_factorize ( n , a ) : <NEWLINE> <INDENT> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> prime_factorize ( N , a ) <NEWLINE> ans = 0 <NEWLINE> if len ( a ) > 1 : <NEWLINE> <INDENT> before = a [ 0 ] <NEWLINE> kosuu = 1 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> tmp = a [ i ] <NEWLINE> if tmp == before : <NEWLINE> <INDENT> kosuu += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ini = 1 <NEWLINE> while kosuu - ini >= 0 : <NEWLINE> <INDENT> kosuu = kosuu - ini <NEWLINE> ini += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> before = tmp <NEWLINE> kosuu = 1 <NEWLINE> <DEDENT> ini = 1 <NEWLINE> <DEDENT> while kosuu - ini >= 0 : <NEWLINE> <INDENT> kosuu = kosuu - ini <NEWLINE> ini += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( a ) == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> for i , j in zip ( a , a [ k : ] ) : <NEWLINE> <INDENT> print ( <STRING> if i < j else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> MAX_A = 10 ** 6 + 1 <NEWLINE> C = [ 0 ] * MAX_A <NEWLINE> for a in A : C [ a ] += 1 <NEWLINE> pairwise = True <NEWLINE> for i in range ( 2 , MAX_A ) : <NEWLINE> <INDENT> if sum ( C [ i : : i ] ) > 1 : pairwise = False <NEWLINE> <DEDENT> if pairwise : return <STRING> <NEWLINE> from math import gcd <NEWLINE> g = 0 <NEWLINE> for a in A : g = gcd ( g , a ) <NEWLINE> if g == 1 : return <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> print ( solve ( ) , <STRING> ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> num_f = 0 <NEWLINE> qual = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if num < a + b : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> qual . append ( <STRING> ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and num_f < b : <NEWLINE> <INDENT> num += 1 <NEWLINE> num_f += 1 <NEWLINE> qual . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> qual . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> qual . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( qual [ i ] ) <NEWLINE> <DEDENT>
def solve ( n , m , a , b ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = 0 <NEWLINE> if a >= m : <NEWLINE> <INDENT> res += ( n - 1 ) * n // 2 * ( a // m ) <NEWLINE> a %= m <NEWLINE> <DEDENT> if b >= m : <NEWLINE> <INDENT> res += n * ( b // m ) <NEWLINE> b %= m <NEWLINE> <DEDENT> p = ( a * n + b ) // m <NEWLINE> q = p * m - b <NEWLINE> return res + solve ( p , a , m , a * n - q ) <NEWLINE> <NL> <DEDENT> t = int ( input ( ) ) <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> n , m , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( n , m , a , b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> for x in A : <NEWLINE> <INDENT> l [ x - 1 ] += 1 <NEWLINE> <DEDENT> for s in l : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> <NL> class IP : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . input = sys . stdin . readline <NEWLINE> <NL> <DEDENT> def I ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return int ( self . input ( ) ) <NEWLINE> <NL> <DEDENT> def S ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . input ( ) <NEWLINE> <NL> <DEDENT> def IL ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return list ( map ( int , self . input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def SL ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return list ( map ( str , self . input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def ILS ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ int ( self . input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def SLS ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ self . input ( ) for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def SILS ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ self . IL ( ) for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def SSLS ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return [ self . SL ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Idea : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def HF ( self , p ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return sorted ( set ( p [ i ] + p [ j ] for i in range ( len ( p ) ) for j in range ( i , len ( p ) ) ) ) <NEWLINE> <NL> <DEDENT> def Bfs2 ( self , a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> value = [ ] <NEWLINE> for i in range ( 1 << len ( a ) ) : <NEWLINE> <INDENT> output = [ ] <NEWLINE> <NL> for j in range ( len ( a ) ) : <NEWLINE> <INDENT> if self . bit_o ( i , j ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> output . append ( a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> value . append ( [ format ( i , <STRING> ) . zfill ( 16 ) , sum ( output ) ] ) <NEWLINE> <NL> <DEDENT> value . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> bin = [ value [ k ] [ 0 ] for k in range ( len ( value ) ) ] <NEWLINE> val = [ value [ k ] [ 1 ] for k in range ( len ( value ) ) ] <NEWLINE> return bin , val <NEWLINE> <NL> <DEDENT> def S ( self , s , r = 0 , m = - 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = bool ( r ) <NEWLINE> if m == - 1 : <NEWLINE> <INDENT> s . sort ( reverse = r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . sort ( reverse = r , key = lambda x : x [ m ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bit_n ( self , a , b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return bool ( ( a >> b & 1 ) > 0 ) <NEWLINE> <NL> <DEDENT> def bit_o ( self , a , b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return bool ( ( ( a >> b ) & 1 ) == 1 ) <NEWLINE> <NL> <DEDENT> def ceil ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return - ( - x // y ) <NEWLINE> <NL> <DEDENT> def ave ( self , a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return sum ( a ) / len ( a ) <NEWLINE> <NL> <DEDENT> def gcd ( self , x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( self , x , y ) : <NEWLINE> <INDENT> return ( x * y ) // self . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> r , e = range , enumerate <NEWLINE> ip = IP ( ) <NEWLINE> id = Idea ( ) <NEWLINE> <NL> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( ip . IL ( ) ) <NEWLINE> <NL> b = np . bincount ( a ) [ 1 : ] <NEWLINE> m = len ( b ) <NEWLINE> others = np . zeros ( n - m ) . astype ( int ) <NEWLINE> <COMMENT> <NL> print ( * b , sep = <STRING> ) <NEWLINE> print ( * others , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 for _ in range ( n ) ] <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> a [ int ( i ) - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> def abs_calc ( x ) : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> xi = ( - 1 ) * x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xi = x <NEWLINE> <DEDENT> return xi <NEWLINE> <NL> <NL> <DEDENT> xi = abs_calc ( x ) <NEWLINE> a = xi // d <NEWLINE> if a >= k : <NEWLINE> <INDENT> ans = xi - d * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= a <NEWLINE> ans = xi - d * a <NEWLINE> if k % 2 != 0 : <NEWLINE> <INDENT> ans = d - ans <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> INF = 10 ** 9 + 5 <NEWLINE> <NL> N , M , K = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> tmpA = [ INF ] * ( N + 1 ) <NEWLINE> tmpA [ 0 ] = 0 <NEWLINE> <NL> cntA = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmpA [ i ] = A [ i - 1 ] + tmpA [ i - 1 ] <NEWLINE> cntA = i <NEWLINE> if tmpA [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> j = 0 <NEWLINE> vol = 0 <NEWLINE> tmpB = 0 <NEWLINE> <NL> for i in range ( cntA , - 1 , - 1 ) : <NEWLINE> <INDENT> rest = K - tmpA [ i ] <COMMENT> <NEWLINE> <COMMENT> <NL> while j < M + 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if rest < tmpB : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> vol = max ( i + j , vol ) <NEWLINE> if j >= M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmpB += B [ j ] <COMMENT> <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( vol ) <NEWLINE>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> <NL> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = [ i for i in range ( - 101 , 201 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t . remove ( p [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> res = 100 <NEWLINE> s = 1000 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s >= abs ( x - t [ len ( t ) - 1 - i ] ) : <NEWLINE> <INDENT> s = abs ( x - t [ len ( t ) - 1 - i ] ) <NEWLINE> res = t [ len ( t ) - 1 - i ] <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = 1 <NEWLINE> while K > 0 : <NEWLINE> <INDENT> if K & 1 : a = A [ a - 1 ] <NEWLINE> A = [ A [ A [ i ] - 1 ] for i in range ( N ) ] <NEWLINE> K >>= 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def dfs ( v , p , ccc , links , ans ) : <NEWLINE> <INDENT> ret_colors = defaultdict ( int ) <NEWLINE> ret_count = 1 <NEWLINE> cv = ccc [ v ] <NEWLINE> for u in links [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sub_colors , sub_count = dfs ( u , v , ccc , links , ans ) <NEWLINE> cc = sub_count - sub_colors [ cv ] <NEWLINE> ans [ cv ] -= cc * ( cc + 1 ) // 2 <NEWLINE> ret_count += sub_count <NEWLINE> <NL> if len ( ret_colors ) < len ( sub_colors ) : <NEWLINE> <INDENT> ret_colors , sub_colors = sub_colors , ret_colors <NEWLINE> <NL> <DEDENT> for c , cnt in sub_colors . items ( ) : <NEWLINE> <INDENT> ret_colors [ c ] += cnt <NEWLINE> <NL> <DEDENT> <DEDENT> ret_colors [ cv ] = ret_count <NEWLINE> <NL> return ret_colors , ret_count <NEWLINE> <NL> <NL> <DEDENT> def solve ( n , ccc , links ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return [ 1 ] <NEWLINE> <NL> <DEDENT> all_pair = n * ( n + 1 ) // 2 <NEWLINE> ans = [ all_pair ] * ( n + 1 ) <NEWLINE> <NL> colors , count = dfs ( 0 , - 1 , ccc , links , ans ) <NEWLINE> assert count == n <NEWLINE> <NL> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cc = n - colors [ c ] <NEWLINE> ans [ c ] -= cc * ( cc + 1 ) // 2 <NEWLINE> <NL> <DEDENT> return ans [ 1 : ] <NEWLINE> <NL> <NL> <DEDENT> n , * cab = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> ccc = cab [ : n ] <NEWLINE> links = [ set ( ) for _ in range ( n ) ] <NEWLINE> <NL> for a , b in zip ( cab [ n + 0 : : 2 ] , cab [ n + 1 : : 2 ] ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> links [ a ] . add ( b ) <NEWLINE> links [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , solve ( n , ccc , links ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = sorted ( set ( a ) ) <NEWLINE> count = 0 <NEWLINE> z = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if i > n : <NEWLINE> <INDENT> count += n - z <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = a . count ( i ) <NEWLINE> if j < i : <NEWLINE> <INDENT> count += j <NEWLINE> z += j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += j - i <NEWLINE> z += j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ABs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> <NL> par = [ i for i in range ( N + 1 ) ] <NEWLINE> size = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <COMMENT> <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> par [ x ] = y <NEWLINE> size [ y ] = size [ x ] + size [ y ] <NEWLINE> size [ x ] = 0 <NEWLINE> <NL> <DEDENT> for AB in ABs : <NEWLINE> <INDENT> unite ( AB [ 0 ] , AB [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( max ( size ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> p = [ ] <NEWLINE> n = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] <= 0 : <NEWLINE> <INDENT> n . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . append ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> p . sort ( reverse = True ) <NEWLINE> n . sort ( ) <NEWLINE> numplus = len ( p ) <NEWLINE> if numplus == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans = ( ans * n [ i * ( - 1 ) ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * n [ i ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ( ans * A [ i ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if numplus >= K : <NEWLINE> <INDENT> x = K <NEWLINE> if 0 in p : <NEWLINE> <INDENT> zero = p . index ( 0 ) <NEWLINE> len ( p ) - zero - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( K - numplus ) % 2 == 1 : <NEWLINE> <INDENT> x = numplus - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = numplus <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> ans = ( ans * p [ i ] ) % MOD <NEWLINE> <DEDENT> for i in range ( K - x ) : <NEWLINE> <INDENT> ans = ( ans * n [ i ] ) % MOD <NEWLINE> <DEDENT> temp = ans <NEWLINE> while x > 1 : <NEWLINE> <INDENT> if len ( n ) < ( K - x + 2 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n [ K - x ] * n [ K - x + 1 ] < p [ x - 1 ] * p [ x - 2 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> temp = ( temp * n [ K - x ] * n [ K - x + 1 ] ) % MOD <NEWLINE> temp = ( temp * pow ( p [ x - 1 ] * p [ x - 2 ] , MOD - 2 , MOD ) ) % MOD <NEWLINE> ans = temp <NEWLINE> x -= 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( [ input ( ) for i in range ( 2 ) ] ) <NEWLINE> print ( int ( a [ 0 ] ) + int ( a [ 1 ] ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> nt = tuple ( range ( n ) ) <NEWLINE> kt = tuple ( range ( 1 , k + 1 ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 10 ** 9 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in nt : <NEWLINE> <INDENT> for j in kt : <NEWLINE> <INDENT> i_j = i + j <NEWLINE> if i_j < n : <NEWLINE> <INDENT> x = dp [ i ] + abs ( h [ i ] - h [ i_j ] ) <NEWLINE> if dp [ i_j ] > x : <NEWLINE> <INDENT> dp [ i_j ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pat = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( x + y ) <= k : <NEWLINE> <INDENT> pat += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( pat ) <NEWLINE>
import sys <NEWLINE> H , W , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> hlst = { } <NEWLINE> wlst = { } <NEWLINE> hwlst = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h , w = sys . stdin . readline ( ) . split ( ) <NEWLINE> if h in hlst : <NEWLINE> <INDENT> hlst [ h ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hlst [ h ] = 1 <NEWLINE> <NL> <DEDENT> if w in wlst : <NEWLINE> <INDENT> wlst [ w ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wlst [ w ] = 1 <NEWLINE> <NL> <DEDENT> hwlst . append ( [ h , w ] ) <NEWLINE> <NL> <DEDENT> h = max ( hlst . values ( ) ) <NEWLINE> w = max ( wlst . values ( ) ) <NEWLINE> hmax = [ i for i in hlst if hlst [ i ] == h ] <NEWLINE> wmax = [ i for i in wlst if wlst [ i ] == w ] <NEWLINE> num = len ( hmax ) * len ( wmax ) <NEWLINE> ans = h + w - 1 <NEWLINE> <NL> <NL> for i in hwlst : <NEWLINE> <INDENT> if hlst [ i [ 0 ] ] == h and wlst [ i [ 1 ] ] == w : <NEWLINE> <INDENT> num -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if num == 0 : <NEWLINE> <INDENT> print ( h + w - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h + w ) <NEWLINE> <DEDENT>
<NL> import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( s ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <NL> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , m = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> a , b = [ ] , [ ] <NEWLINE> d = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> d [ ai ] = d . get ( ai , [ ] ) <NEWLINE> d [ ai ] . append ( bi ) <NEWLINE> d [ bi ] = d . get ( bi , [ ] ) <NEWLINE> d [ bi ] . append ( ai ) <NEWLINE> <NL> <DEDENT> r = { } <NEWLINE> def trace ( ) : <NEWLINE> <INDENT> tasks = [ ( 1 , 0 ) ] <NEWLINE> i = 0 <NEWLINE> while i < len ( tasks ) : <NEWLINE> <INDENT> no , lv = tasks [ i ] <NEWLINE> for c in d [ no ] : <NEWLINE> <INDENT> if c != 1 : <NEWLINE> <INDENT> if c not in r or ( r [ c ] [ 1 ] > lv and r [ c ] [ 1 ] != 0 ) : <NEWLINE> <INDENT> r [ c ] = ( no , lv ) <NEWLINE> tasks . append ( ( c , lv + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> trace ( ) <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i not in r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( r [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = [ 1 ] <NEWLINE> seen = [ 0 ] * n <NEWLINE> seen [ 0 ] = 1 <NEWLINE> now = 0 <NEWLINE> while True : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> D . append ( now + 1 ) <NEWLINE> if seen [ now ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> seen [ now ] = 1 <NEWLINE> <DEDENT> f = D . index ( D [ - 1 ] ) <NEWLINE> if k < f : <NEWLINE> <INDENT> print ( D [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cycle = len ( D ) - f - 1 <NEWLINE> k -= f <NEWLINE> print ( D [ f + k % ( cycle ) ] ) <NEWLINE> <DEDENT>
global cnt <NEWLINE> cnt = 0 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( int ) ( ( left + right ) / 2 ) <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mergeSort ( S , 0 , n ) <NEWLINE> print ( * S ) <NEWLINE> print ( cnt ) <NEWLINE>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> xy_pos = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for k in range ( - 2 , 1 ) : <NEWLINE> <INDENT> for l in range ( - 2 , 1 ) : <NEWLINE> <INDENT> x = ( a - 1 ) + k <NEWLINE> y = ( b - 1 ) + l <NEWLINE> if ( 0 <= x <= h - 3 and 0 <= y <= w - 3 ) : <NEWLINE> <INDENT> xy = str ( x ) + <STRING> + str ( y ) <NEWLINE> if xy in xy_pos : <NEWLINE> <INDENT> xy_pos [ xy ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xy_pos [ xy ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * 10 <NEWLINE> for v in xy_pos . values ( ) : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> ans [ 0 ] = ( h - 2 ) * ( w - 2 ) - sum ( ans ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
ans = [ [ 0 for i in range ( 1001 ) ] for j in range ( 11 ) ] <NEWLINE> ans [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> for n in range ( 9 , - 1 , - 1 ) : <NEWLINE> <INDENT> for s in range ( 1001 - i ) : <NEWLINE> <INDENT> ans [ n + 1 ] [ s + i ] += ans [ n ] [ s ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ans [ n ] [ s ] ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> D = 7 <NEWLINE> for i in range ( 1000000 ) : <NEWLINE> <INDENT> if D % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> D = D * 10 + 7 <NEWLINE> D %= K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> gcd = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> ans += math . gcd ( gcd , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a_ = int ( input ( ) ) <NEWLINE> a . append ( a_ ) <NEWLINE> <DEDENT> a1 = sorted ( a ) <NEWLINE> ans1 = a1 [ - 1 ] <NEWLINE> ans2 = a1 [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == ans1 : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> res = N - ( r * R + g * G ) <NEWLINE> if res >= 0 and res % B == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k , s = i_map ( ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import queue <NEWLINE> from decimal import Decimal <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , K = il ( ) <NEWLINE> tel = [ 0 ] + il ( ) <NEWLINE> <NL> <COMMENT> <NL> position = 1 <NEWLINE> <NL> <COMMENT> <NL> if K <= N : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> position = tel [ position ] <NEWLINE> <DEDENT> print ( position ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> position = tel [ position ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> K -= N <NEWLINE> <COMMENT> <NL> base = position <NEWLINE> cnt = 1 <NEWLINE> while base != tel [ position ] : <NEWLINE> <INDENT> position = tel [ position ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for k in range ( K % cnt + 1 ) : <NEWLINE> <INDENT> position = tel [ position ] <NEWLINE> <DEDENT> print ( position ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> countList = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> answer = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in A : <NEWLINE> <INDENT> countList [ i ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( 10 ** 6 + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if countList [ j ] > 0 : <NEWLINE> <INDENT> for k in range ( 2 * j , 10 ** 6 + 1 , j ) : <NEWLINE> <INDENT> countList [ k ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if countList [ j ] == 1 : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> <NL> def initRMQ ( n ) : <NEWLINE> <INDENT> n_ = 1 <NEWLINE> <NL> while n_ < n : <NEWLINE> <INDENT> n_ *= 2 <NEWLINE> <NL> <DEDENT> D = [ ] <NEWLINE> for _ in range ( 2 * n_ - 1 ) : <NEWLINE> <INDENT> D . append ( 0 ) <NEWLINE> <NL> <DEDENT> return n_ , D <NEWLINE> <NL> <NL> <DEDENT> def update ( k , a ) : <NEWLINE> <INDENT> k += n_ - 1 <NEWLINE> D [ k ] += a <NEWLINE> while k > 0 : <NEWLINE> <INDENT> k = int ( ( k - 1 ) / 2 ) <NEWLINE> D [ k ] = D [ k * 2 + 1 ] + D [ k * 2 + 2 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def findSum ( a , b ) : <NEWLINE> <INDENT> return query ( a , b + 1 , 0 , 0 , n_ ) <NEWLINE> <NL> <NL> <DEDENT> def query ( a , b , k , l , r ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if a <= l and r <= b : <NEWLINE> <INDENT> return D [ k ] <NEWLINE> <NL> <DEDENT> vl = query ( a , b , k * 2 + 1 , l , int ( ( l + r ) / 2 ) ) <NEWLINE> vr = query ( a , b , k * 2 + 2 , int ( ( l + r ) / 2 ) , r ) <NEWLINE> <NL> return vl + vr <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n_ , D = initRMQ ( n ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <COMMENT> <NL> <INDENT> c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if c == 0 : <NEWLINE> <INDENT> update ( x - 1 , y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( findSum ( x - 1 , y - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict as dd <NEWLINE> d = dd ( int ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in [ int ( n ) for n in input ( ) . split ( ) ] : <NEWLINE> <INDENT> d [ i ] = d [ i ] + 1 <NEWLINE> <DEDENT> times = int ( input ( ) ) <NEWLINE> summation = sum ( [ key * value for key , value in d . items ( ) if value > 0 ] ) <NEWLINE> for i in range ( times ) : <NEWLINE> <INDENT> a , b = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> summation = summation + ( b - a ) * d [ a ] <NEWLINE> d [ b ] , d [ a ] = d [ b ] + d [ a ] , 0 <NEWLINE> print ( summation ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li_h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li_route = list ( ) <NEWLINE> remove_idx_set = set ( ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h_a = li_h [ a - 1 ] <NEWLINE> h_b = li_h [ b - 1 ] <NEWLINE> <NL> if h_a <= h_b : <NEWLINE> <INDENT> remove_idx_set . add ( a - 1 ) <NEWLINE> <DEDENT> if h_a >= h_b : <NEWLINE> <INDENT> remove_idx_set . add ( b - 1 ) <NEWLINE> <DEDENT> <DEDENT> for s in remove_idx_set : <NEWLINE> <INDENT> li_h [ s ] = 0 <NEWLINE> <DEDENT> print ( len ( [ v for v in li_h if v != 0 ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> a_sum = sum ( a ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a_sum -= a [ i ] <NEWLINE> ans += a [ i ] * a_sum <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> <NL> W = C . count ( <STRING> ) <NEWLINE> R = C . count ( <STRING> ) <NEWLINE> w = 0 <NEWLINE> r = R <NEWLINE> <NL> ans = R <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if C [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> ans = min ( ans , max ( w , r ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def solve ( n ) : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> print ( solve ( k ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> S2 = [ ] <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> n = S [ i ] <NEWLINE> S2 . append ( n ) <NEWLINE> <DEDENT> <DEDENT> if len ( S2 ) == K : <NEWLINE> <INDENT> print ( <STRING> . join ( S2 ) + <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { 1 : 0 } <NEWLINE> pre_a = 0 <NEWLINE> a = 1 <NEWLINE> c = 0 <NEWLINE> while K : <NEWLINE> <INDENT> K -= 1 <NEWLINE> next_a = A [ a ] <NEWLINE> c += 1 <NEWLINE> if next_a in d : <NEWLINE> <INDENT> idx = d [ next_a ] <NEWLINE> n = len ( d ) <NEWLINE> K %= ( n - idx ) <NEWLINE> K += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ next_a ] = c <NEWLINE> pre_a = a <NEWLINE> a = next_a <NEWLINE> <NL> <DEDENT> <DEDENT> while K : <NEWLINE> <INDENT> pre_a = a <NEWLINE> a = A [ a ] <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Sum = 0 <NEWLINE> Al = [ 0 ] <NEWLINE> Bl = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Sum += A [ i ] <NEWLINE> Al . append ( Sum ) <NEWLINE> <DEDENT> Sum = 0 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> Sum += B [ j ] <NEWLINE> Bl . append ( Sum ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if Al [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while Bl [ j ] > K - Al [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ set ( ) for _ in range ( n ) ] <NEWLINE> group_ids = [ 0 ] * n <NEWLINE> <NL> while m : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ s ] . add ( t ) <NEWLINE> g [ t ] . add ( s ) <NEWLINE> m -= 1 <NEWLINE> <NL> <NL> <DEDENT> def search ( s , gid ) : <NEWLINE> <INDENT> global g , group_ids <NEWLINE> queue = set ( g [ s ] ) <NEWLINE> group_ids [ s ] = gid <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> i = queue . pop ( ) <NEWLINE> if not group_ids [ i ] : <NEWLINE> <INDENT> group_ids [ i ] = gid <NEWLINE> queue . update ( g [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> gid = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if group_ids [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> search ( i , gid ) <NEWLINE> gid += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> while q : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> gs , gt = group_ids [ s ] , group_ids [ t ] <NEWLINE> print ( <STRING> if gs and gt and gs == gt else <STRING> ) <NEWLINE> q -= 1 <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ [ 0 ] * ( c + 1 ) for i in range ( r + 1 ) ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> table [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> table [ i ] . append ( sum ( table [ i ] ) ) <NEWLINE> for j in range ( c + 1 ) : <NEWLINE> <INDENT> table [ r ] [ j ] += table [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if ( j == c ) : <NEWLINE> <INDENT> print ( <STRING> % ( table [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( table [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> f = sorted ( f , reverse = True ) <NEWLINE> <NL> <NL> def is_lessthanK ( X ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for A , F in zip ( a , f ) : <NEWLINE> <INDENT> if A * F > X : <NEWLINE> <INDENT> ans += A - X // F <NEWLINE> <DEDENT> if ans > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> ng = - 1 <NEWLINE> ok = a [ - 1 ] * f [ 0 ] <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_lessthanK ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL>
s = input ( ) . split ( ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> k = int ( s [ 2 ] ) <NEWLINE> <NL> <NL> <NL> <NL> for i in range ( a , min ( b , a + k - 1 ) + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( b - k + 1 , a + k ) , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s , t = list ( input ( ) ) , list ( input ( ) ) <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return gcd ( b , a ) <NEWLINE> <DEDENT> while a > 0 : <NEWLINE> <INDENT> a , b = b % a , a <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> l = lcm ( len ( s ) , len ( t ) ) <NEWLINE> x = { } <COMMENT> <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> x [ i * ( l // len ( s ) ) ] = s [ i ] <NEWLINE> <DEDENT> for i in range ( 0 , len ( t ) ) : <NEWLINE> <INDENT> if i * ( l // len ( t ) ) not in x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x [ i * ( l // len ( t ) ) ] != t [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left , bisect , bisect_right <NEWLINE> <NL> icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> <DEDENT> elif icase == 1 : <NEWLINE> <INDENT> n , m = 3 , 2 <NEWLINE> a = [ 1 , 4 , 5 ] <NEWLINE> cb = [ [ 5 , 1 ] , [ 3 , 2 ] ] <NEWLINE> <DEDENT> elif icase == 3 : <NEWLINE> <INDENT> n , m = 3 , 2 <NEWLINE> a = [ 100 , 100 , 100 ] <NEWLINE> cb = [ [ 99 , 3 ] , [ 99 , 3 ] ] <NEWLINE> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> n , m = 10 , 3 <NEWLINE> a = [ 1 , 4 , 5 , 5 , 7 , 8 , 13 , 33 , 52 , 100 ] <NEWLINE> cb = [ [ 30 , 4 ] , [ 10 , 3 ] , [ 4 , 1 ] ] <NEWLINE> <DEDENT> elif icase == 4 : <NEWLINE> <INDENT> n , m = 11 , 3 <NEWLINE> a = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] <NEWLINE> cb = [ [ 1000000000 , 4 ] , [ 1000000000 , 3 ] , [ 1000000000 , 3 ] ] <NEWLINE> <DEDENT> elif icase == 5 : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> ll = f . readline ( ) <NEWLINE> n , m = map ( int , ll . split ( ) ) <NEWLINE> ll = f . readline ( ) <NEWLINE> a = list ( map ( int , ll . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ll = f . readline ( ) <NEWLINE> bi , ci = map ( int , ll . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> ans = 99913215738299 <NEWLINE> <DEDENT> elif icase == 6 : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> ll = f . readline ( ) <NEWLINE> n , m = map ( int , ll . split ( ) ) <NEWLINE> ll = f . readline ( ) <NEWLINE> a = list ( map ( int , ll . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ll = f . readline ( ) <NEWLINE> bi , ci = map ( int , ll . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> f . close ( ) <NEWLINE> ans = 95821339675952 <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> cb . sort ( reverse = True ) <NEWLINE> <NL> if cb [ 0 ] [ 0 ] <= a [ 0 ] : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> asum = 0 <NEWLINE> isum = 0 <NEWLINE> isumm = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> isum += cb [ i ] [ 1 ] <NEWLINE> if isum > n : <NEWLINE> <INDENT> if a [ - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> asum += cb [ i ] [ 0 ] * ( n - isumm ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ isum - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * cb [ i ] [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> isumm = isum <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> isumm = isum <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> asum += sum ( a [ isumm : ] ) <NEWLINE> <NL> print ( asum ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> ans += k - 1 - j <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> rnum = s . count ( <STRING> ) <NEWLINE> gnum = s . count ( <STRING> ) <NEWLINE> bnum = s . count ( <STRING> ) <NEWLINE> ans = rnum * gnum * bnum <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> d = i + j <NEWLINE> f = d + j <NEWLINE> if f >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ d ] and s [ d ] != s [ f ] and s [ f ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k , * a = map ( int , open ( i : = 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> p = a . pop <NEWLINE> s = b = ~ k % 2 or p ( ) <NEWLINE> while k > 1 : <NEWLINE> <INDENT> if ( x : = a [ i ] * a [ i + 1 ] ) * b > a [ - 1 ] * a [ - 2 ] * b : s *= x ; i += 2 <NEWLINE> else : s *= p ( ) * p ( ) <NEWLINE> s %= 10 ** 9 + 7 ; k -= 2 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> listA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> listB = [ ] <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> listB . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> sum = sum ( listA ) <NEWLINE> numlist = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in listA : <NEWLINE> <INDENT> numlist [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B = listB [ i ] [ 0 ] <NEWLINE> C = listB [ i ] [ 1 ] <NEWLINE> if numlist [ B ] != 0 : <NEWLINE> <INDENT> sum = sum + ( C - B ) * numlist [ B ] <NEWLINE> <COMMENT> <NL> numlist [ C ] += numlist [ B ] <NEWLINE> numlist [ B ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
def abc164_d ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = str ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> m = 2019 <NEWLINE> srev = s [ : : - 1 ] <COMMENT> <NEWLINE> x = 1 <COMMENT> <NEWLINE> total = 0 <COMMENT> <NEWLINE> cnt = [ 0 ] * m <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ total ] += 1 <NEWLINE> total += int ( srev [ i ] ) * x <NEWLINE> total %= m <NEWLINE> ans += cnt [ total ] <NEWLINE> x = x * 10 % m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> abc164_d ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def rrs ( quantum , process ) : <NEWLINE> <INDENT> finished_process = [ ] <NEWLINE> queue = Queue ( ) <NEWLINE> current_time = 0 <NEWLINE> i = 0 <NEWLINE> while len ( finished_process ) < len ( process ) : <NEWLINE> <INDENT> if i < len ( process ) : <NEWLINE> <INDENT> p_info = process [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_info = queue . dequeue ( ) <NEWLINE> <DEDENT> time = int ( p_info [ 1 ] ) <NEWLINE> name = p_info [ 0 ] <NEWLINE> <NL> if time <= quantum : <NEWLINE> <INDENT> current_time += time <NEWLINE> finished_process . append ( ( name , current_time ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current_time += quantum <NEWLINE> queue . enqueue ( ( name , time - quantum ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return finished_process <NEWLINE> <NL> <NL> <DEDENT> class Queue : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . data = [ ] <NEWLINE> <NL> <DEDENT> def enqueue ( self , d ) : <NEWLINE> <INDENT> self . data . append ( d ) <NEWLINE> <NL> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> r = self . data [ 0 ] <NEWLINE> self . data = self . data [ 1 : ] <NEWLINE> return r <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> info = input ( ) . split ( ) <NEWLINE> n_list = int ( info [ 0 ] ) <NEWLINE> quantum = int ( info [ 1 ] ) <NEWLINE> target_list = [ tuple ( input ( ) . split ( ) ) for i in range ( n_list ) ] <NEWLINE> print ( <STRING> . join ( [ p + <STRING> + str ( t ) for p , t in rrs ( quantum , target_list ) ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
house = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> house [ data [ 0 ] - 1 ] [ data [ 1 ] - 1 ] [ data [ 2 ] - 1 ] += data [ 3 ] <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( list ( map ( str , house [ i ] [ j ] ) ) ) ) <NEWLINE> <DEDENT> if i != 3 : print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> card = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card_type , card_num = input ( ) . split ( ) <NEWLINE> card . add ( card_type + card_num ) <NEWLINE> <DEDENT> for card_type in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for card_num in range ( 1 , 14 ) : <NEWLINE> <INDENT> if card_type + str ( card_num ) not in card : <NEWLINE> <INDENT> print ( card_type + <STRING> + str ( card_num ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] <NEWLINE> <NL> if A [ 0 ] != 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev_min , prev_max = 2 , 3 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if a > prev_max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if prev_min % a == 0 : <NEWLINE> <INDENT> now_min = prev_min <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now_min = ( prev_min // a + 1 ) * a <NEWLINE> <DEDENT> if now_min > prev_max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> diff = prev_max - now_min <NEWLINE> now_max = now_min + ( diff // a + 1 ) * a - 1 <NEWLINE> prev_min , prev_max = now_min , now_max <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( prev_min , prev_max ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = n // i <NEWLINE> ans += d * ( d + 1 ) // 2 * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( n ) , end = <STRING> ) <NEWLINE> x = int ( pow ( n , 0.5 ) ) + 1 <NEWLINE> for i in range ( 2 , x ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> n //= i <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( n ) if n != 1 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( set ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> S . sort ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> OK = 0 <NEWLINE> NG = len ( S ) <NEWLINE> while abs ( OK - NG ) > 1 : <NEWLINE> <INDENT> mid = ( OK + NG ) // 2 <NEWLINE> if S [ mid ] <= T [ i ] : <NEWLINE> <INDENT> OK = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NG = mid <NEWLINE> <DEDENT> <DEDENT> if S [ OK ] == T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> d = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ss = [ <STRING> for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> f = False <NEWLINE> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> f = True <NEWLINE> continue <NEWLINE> <DEDENT> for dy , dx in d : <NEWLINE> <INDENT> if 0 <= i + dy < h and 0 <= j + dx < w : <NEWLINE> <INDENT> if s [ i + dy ] [ j + dx ] == <STRING> : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not f : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] + [ 0 ] <NEWLINE> <NL> yen = 1000 <NEWLINE> kabu_yen = 0 <NEWLINE> kabu_n = 0 <NEWLINE> last_buy = - 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if A [ i - 1 ] < A [ i ] : <COMMENT> <NEWLINE> <INDENT> tanka = A [ i - 1 ] <NEWLINE> m = yen // tanka <NEWLINE> cost = tanka * m <NEWLINE> yen -= cost <NEWLINE> kabu_yen += cost <NEWLINE> kabu_n += m <NEWLINE> <NL> <DEDENT> elif A [ i - 1 ] > A [ i ] : <COMMENT> <NEWLINE> <INDENT> yen += A [ i - 1 ] * kabu_n <NEWLINE> kabu_yen = 0 <NEWLINE> kabu_n = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( yen ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 1000001 <NEWLINE> cnt = [ 0 ] * M <NEWLINE> ans = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> if cnt [ x ] != 0 : <NEWLINE> <INDENT> cnt [ x ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( x , M , x ) : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for x in A : <NEWLINE> <INDENT> if cnt [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> a = sorted ( a , key = lambda x : x [ 0 ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cnt + a [ i ] [ 1 ] < m : <NEWLINE> <INDENT> ans += a [ i ] [ 0 ] * a [ i ] [ 1 ] <NEWLINE> cnt += a [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i ] [ 0 ] * ( m - cnt ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> seiseki = [ ] <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> X = [ A % 10 , B % 10 , C % 10 , D % 10 , E % 10 ] <NEWLINE> minimum = 100 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if X [ i ] != 0 : <NEWLINE> <INDENT> minimum = min ( minimum , X [ i ] ) <NEWLINE> <DEDENT> <DEDENT> Y = [ A , B , C , D , E ] <NEWLINE> if minimum == 100 : <NEWLINE> <INDENT> minimum = 0 <NEWLINE> <DEDENT> last = X . index ( minimum ) <NEWLINE> time = 0 <NEWLINE> import math <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if i != last : <NEWLINE> <INDENT> time = time + 10 * math . ceil ( Y [ i ] / 10 ) <NEWLINE> <DEDENT> <DEDENT> if X == [ 0 , 0 , 0 , 0 , 0 ] : <NEWLINE> <INDENT> print ( sum ( Y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( time + Y [ last ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> B = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B [ A [ i ] ] = 0 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i - 1 >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] * B [ i ] + dp [ i - 1 ] * B [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] * B [ i ] <NEWLINE> <DEDENT> dp [ i + 1 ] %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import os , sys , re , math <NEWLINE> <NL> <NL> ( H , W ) = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def set_moves ( x , y , moves ) : <NEWLINE> <INDENT> if S [ y + 1 ] [ x + 1 ] != <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if 0 <= grid [ y ] [ x ] < moves : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> grid [ y ] [ x ] = moves <NEWLINE> set_moves ( x , y - 1 , moves + 1 ) <NEWLINE> set_moves ( x , y + 1 , moves + 1 ) <NEWLINE> set_moves ( x - 1 , y , moves + 1 ) <NEWLINE> set_moves ( x + 1 , y , moves + 1 ) <NEWLINE> <NL> <NL> <DEDENT> S = [ ] <NEWLINE> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> has_wall = False <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> has_wall |= <STRING> in s <NEWLINE> S . append ( <STRING> + s + <STRING> ) <NEWLINE> <DEDENT> S . append ( <STRING> * ( W + 2 ) ) <NEWLINE> <NL> if not has_wall : <NEWLINE> <INDENT> result = W + H - 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 0 <NEWLINE> for gy in range ( H ) : <NEWLINE> <INDENT> for gx in range ( W ) : <NEWLINE> <INDENT> if S [ gy + 1 ] [ gx + 1 ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> grid = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> grid . append ( [ - 1 ] * W ) <NEWLINE> <DEDENT> set_moves ( gx , gy , 0 ) <NEWLINE> <NL> result = max ( result , max ( [ max ( row ) for row in grid ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N > 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <COMMENT> <NL> <DEDENT> p . sort ( ) <NEWLINE> <COMMENT> <NL> ans_1 = X <NEWLINE> ans_2 = X <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pi = p [ i ] <NEWLINE> if pi == ans_1 : <NEWLINE> <INDENT> ans_1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> p . reverse ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pi = p [ i ] <NEWLINE> if pi == ans_2 : <NEWLINE> <INDENT> ans_2 -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = X <NEWLINE> if abs ( ans_1 - X ) < abs ( ans_2 - X ) : <NEWLINE> <INDENT> ans = ans_1 <NEWLINE> <DEDENT> elif ans_1 - X == - abs ( ans_2 - X ) : <NEWLINE> <INDENT> ans = ans_1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans_2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> class Tree : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . p = - 1 <NEWLINE> self . sibling = - 1 <NEWLINE> self . degree = 0 <NEWLINE> self . depth = - 1 <NEWLINE> self . height = 0 <NEWLINE> self . type = <STRING> <NEWLINE> self . c = [ ] <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> input ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> tree = tuple ( Tree ( i ) for i in range ( n ) ) <NEWLINE> leaf_li = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> id , * c = map ( int , readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> if c != [ ] : <NEWLINE> <INDENT> tree [ id ] . type = <STRING> <NEWLINE> tree [ id ] . c = c <NEWLINE> for j in c : <NEWLINE> <INDENT> tree [ j ] . p = id <NEWLINE> <DEDENT> len_c = len ( c ) <NEWLINE> tree [ id ] . degree = len_c <NEWLINE> if len_c == 2 : <NEWLINE> <INDENT> tree [ c [ 0 ] ] . sibling = c [ 1 ] <NEWLINE> tree [ c [ 1 ] ] . sibling = c [ 0 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> leaf_li . add ( id ) <NEWLINE> <DEDENT> <DEDENT> for i in leaf_li : <NEWLINE> <INDENT> a = i <NEWLINE> cnt = 1 <NEWLINE> while tree [ a ] . p != - 1 and tree [ tree [ a ] . p ] . height < cnt : <NEWLINE> <INDENT> tree [ tree [ a ] . p ] . height = cnt <NEWLINE> cnt += 1 <NEWLINE> a = tree [ a ] . p <NEWLINE> <DEDENT> <DEDENT> root = 0 <NEWLINE> while tree [ root ] . p != - 1 : <NEWLINE> <INDENT> root = tree [ root ] . p <NEWLINE> <DEDENT> tree [ root ] . type = <STRING> <NEWLINE> tree [ root ] . depth = 0 <NEWLINE> tree [ root ] . height = max ( tree [ i ] . height for i in tree [ root ] . c ) + 1 <NEWLINE> def depth_check ( id , d ) : <NEWLINE> <INDENT> d += 1 <NEWLINE> for i in tree [ id ] . c : <NEWLINE> <INDENT> tree [ i ] . depth = d <NEWLINE> if tree [ i ] . type != <STRING> : <NEWLINE> <INDENT> depth_check ( i , d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> depth_check ( root , 0 ) <NEWLINE> print ( <STRING> . join ( map ( str , tree ) ) ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <NL>
from itertools import accumulate <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> array = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> acc = accumulate ( array ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i , ai in enumerate ( acc ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += ai * array [ i + 1 ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> T = sum ( A ) <NEWLINE> Z = Counter ( A ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> x = Z [ B ] <NEWLINE> y = Z [ C ] <NEWLINE> Z . pop ( B , 0 ) <NEWLINE> Z [ C ] = x + y <NEWLINE> T = T - ( B * x ) + ( C * x ) <NEWLINE> print ( T ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = list ( enumerate ( a ) ) <NEWLINE> a . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <NL> DP = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> DP [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pos , val = a . pop ( ) <NEWLINE> pos = pos + 1 <NEWLINE> <NL> DP [ 0 ] [ i ] = DP [ 0 ] [ i - 1 ] + abs ( val * ( n - i + 1 - pos ) ) <NEWLINE> DP [ i ] [ 0 ] = DP [ i - 1 ] [ 0 ] + abs ( val * ( pos - i ) ) <NEWLINE> for x in range ( 1 , i ) : <NEWLINE> <INDENT> y = i - x <NEWLINE> DP [ x ] [ y ] = max ( DP [ x - 1 ] [ y ] + abs ( val * ( pos - x ) ) , DP [ x ] [ y - 1 ] + abs ( val * ( n - y + 1 - pos ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , DP [ i ] [ n - i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 or a [ i ] > 10 ** 18 : <NEWLINE> <INDENT> if a [ i : ] . count ( 0 ) > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = s <NEWLINE> factors = { } <NEWLINE> <NL> while p > 1 : <NEWLINE> <INDENT> f = False <NEWLINE> for i in range ( 2 , int ( p ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> if i in factors : <NEWLINE> <INDENT> factors [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> factors [ i ] = 1 <NEWLINE> <NL> <DEDENT> p //= i <NEWLINE> f = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not f : <NEWLINE> <INDENT> if p in factors : <NEWLINE> <INDENT> factors [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> factors [ p ] = 1 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( factors ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> primes = list ( factors . keys ( ) ) <NEWLINE> exp = [ 0 ] * len ( primes ) <NEWLINE> upper = s / k <NEWLINE> ans = 1 <NEWLINE> <NL> while exp [ 0 ] <= factors [ primes [ 0 ] ] : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in range ( len ( primes ) ) : <NEWLINE> <INDENT> num *= pow ( primes [ i ] , exp [ i ] ) <NEWLINE> <NL> <DEDENT> if num == upper : <NEWLINE> <INDENT> ans = num <NEWLINE> break <NEWLINE> <DEDENT> elif num < upper : <NEWLINE> <INDENT> ans = max ( ans , num ) <NEWLINE> <NL> <DEDENT> index = len ( primes ) - 1 <NEWLINE> done = False <NEWLINE> while not done : <NEWLINE> <INDENT> exp [ index ] += 1 <NEWLINE> if exp [ index ] > factors [ primes [ index ] ] : <NEWLINE> <INDENT> if index == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exp [ index ] = 0 <NEWLINE> index -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> done = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) . split ( ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( s [ i ] ) ) <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> A . sort ( reverse = True ) <NEWLINE> result += A [ 0 ] <NEWLINE> A . pop ( 0 ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> result += sum ( A [ : ( int ( N / 2 ) - 1 ) ] ) * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( sum ( A [ : ( int ( ( N - 1 ) / 2 ) - 1 ) ] ) * 2 + A [ int ( ( N - 1 ) / 2 ) - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> tot = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tot += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if s - k <= x + y <= s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ [ [ 0 for i in range ( 10 ) ] for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w = input ( ) . split ( ) <NEWLINE> b = ( int ( w [ 0 ] ) ) <NEWLINE> f = ( int ( w [ 1 ] ) ) <NEWLINE> r = ( int ( w [ 2 ] ) ) <NEWLINE> v = ( int ( w [ 3 ] ) ) <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> . format ( a [ i ] [ j ] [ k ] ) ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> if ( i != 3 ) : <NEWLINE> <INDENT> for x in range ( 20 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = len ( [ i for i in range ( n ) if s [ i ] == <STRING> ] ) <NEWLINE> g = len ( [ i for i in range ( n ) if s [ i ] == <STRING> ] ) <NEWLINE> b = len ( [ i for i in range ( n ) if s [ i ] == <STRING> ] ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - count ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> ans_max = 10 ** 18 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > ans_max : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x * y , ( x + y ) * 2 ) <NEWLINE>
<COMMENT> <NL> from decimal import * <NEWLINE> from itertools import permutations , combinations , combinations_with_replacement , product <NEWLINE> import math <NEWLINE> from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r_list = [ ] <NEWLINE> g_list = [ ] <NEWLINE> b_list = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> r_list . append ( i ) <NEWLINE> <DEDENT> elif ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> g_list . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_list . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> R_count = len ( r_list ) <NEWLINE> G_count = len ( g_list ) <NEWLINE> B_count = len ( b_list ) <NEWLINE> <COMMENT> <NL> <NL> b_num_list = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( B_count ) : <NEWLINE> <INDENT> b_num_list [ b_list [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> counter = R_count * G_count * B_count <NEWLINE> NG_list = [ ] <NEWLINE> for i in range ( R_count ) : <NEWLINE> <INDENT> for j in range ( G_count ) : <NEWLINE> <INDENT> r = r_list [ i ] <NEWLINE> g = g_list [ j ] <NEWLINE> hit_count = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( g + g - r >= 0 and g + g - r <= N - 1 ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if ( b_num_list [ g + g - r ] == 1 ) : <NEWLINE> <INDENT> hit_count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if ( ( g + r ) % 2 == 0 and b_num_list [ int ( ( g + r ) / 2 ) ] == 1 ) : <NEWLINE> <INDENT> hit_count += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if ( r + r - g >= 0 and r + r - g <= N - 1 ) : <COMMENT> <NEWLINE> <INDENT> if ( b_num_list [ r + r - g ] == 1 ) : <NEWLINE> <INDENT> hit_count += 1 <NEWLINE> <DEDENT> <DEDENT> counter -= hit_count <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE> <NL>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x = [ [ int ( 0 ) for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> z = [ [ int ( 0 ) for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> y = [ [ int ( 0 ) for i in range ( l ) ] for j in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = input ( ) . split ( ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x [ i ] [ j ] = int ( k [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> k = input ( ) . split ( ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> y [ i ] [ j ] = int ( k [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> count = int ( 0 ) <NEWLINE> for v in range ( m ) : <NEWLINE> <INDENT> count = count + x [ i ] [ v ] * y [ v ] [ j ] <NEWLINE> <DEDENT> z [ i ] [ j ] = count <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l - 1 ) : <NEWLINE> <INDENT> print ( z [ i ] [ j ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( z [ i ] [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = n // i <NEWLINE> ans += i * a * ( a + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <COMMENT> <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <COMMENT> <NEWLINE> N //= 26 <COMMENT> <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <COMMENT> <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = K - A - B <NEWLINE> print ( A - k ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> SS = [ a for a in S ] <NEWLINE> SS . insert ( 0 , 0 ) <NEWLINE> nr = S . count ( <STRING> ) <NEWLINE> ng = S . count ( <STRING> ) <NEWLINE> nb = S . count ( <STRING> ) <NEWLINE> n = 0 <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k <= N : <NEWLINE> <INDENT> if SS [ i ] != SS [ j ] and SS [ j ] != SS [ k ] and SS [ k ] != SS [ i ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> answer = nr * ng * nb - n <NEWLINE> print ( answer ) <NEWLINE>
<NL> from collections import Counter <NEWLINE> a = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = Counter ( num_list ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print ( D [ i + 1 ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> arr = np . array ( A ) <NEWLINE> <NL> <NL> print ( <STRING> . join ( map ( str , np . argsort ( arr ) + 1 ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if 400 <= x <= 599 : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> elif 600 <= x <= 799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 800 <= x <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1000 <= x <= 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1200 <= x <= 1399 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1400 <= x <= 1599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1600 <= x <= 1799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b - a <= k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i not in ans : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if j not in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def delete_head_zeros ( n ) : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> l = len ( n ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> l = n . find ( <STRING> ) <NEWLINE> <DEDENT> head_zeros = 0 <NEWLINE> for i in range ( l - 1 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> head_zeros += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return n [ head_zeros : ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_compare ( a , b ) : <NEWLINE> <INDENT> a = delete_head_zeros ( a ) <NEWLINE> b = delete_head_zeros ( b ) <NEWLINE> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif len ( a ) < len ( b ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def bigint_plus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> d = max ( [ len ( a ) , len ( b ) ] ) <NEWLINE> a = <STRING> * ( d - len ( a ) ) + a <NEWLINE> b = <STRING> * ( d - len ( b ) ) + b <NEWLINE> <NL> ans = <STRING> <NEWLINE> carry = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s = int ( a [ - i - 1 ] ) + int ( b [ - i - 1 ] ) + carry <NEWLINE> carry = s // 10 <NEWLINE> ans = str ( s % 10 ) + ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> ans = str ( carry ) + ans <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_minus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> M = [ ] <NEWLINE> m = [ ] <NEWLINE> sign = <STRING> <NEWLINE> <NL> if len ( a ) > len ( b ) or ( len ( a ) == len ( b ) and a >= b ) : <NEWLINE> <INDENT> [ M , m ] = [ a , b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> [ M , m ] = [ b , a ] <NEWLINE> sign = <STRING> <NEWLINE> <DEDENT> m = <STRING> * ( len ( M ) - len ( m ) ) + m <NEWLINE> <NL> ans = <STRING> <NEWLINE> borrow = 0 <NEWLINE> for i in range ( len ( M ) ) : <NEWLINE> <INDENT> s = int ( M [ - i - 1 ] ) - int ( m [ - i - 1 ] ) - borrow <NEWLINE> if s < 0 : <NEWLINE> <INDENT> borrow = 1 <NEWLINE> s += 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> borrow = 0 <NEWLINE> <DEDENT> ans = str ( s ) + ans <NEWLINE> <NL> <DEDENT> return sign + delete_head_zeros ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_multiply ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> md = [ ] <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> carry = 0 <NEWLINE> mj = <STRING> <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> m = int ( a [ - i - 1 ] ) * int ( b [ - j - 1 ] ) + carry <NEWLINE> carry = m // 10 <NEWLINE> mj = str ( m % 10 ) + mj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> mj = str ( carry ) + mj <NEWLINE> <DEDENT> <DEDENT> md . append ( mj ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( len ( md ) ) : <NEWLINE> <INDENT> ans = bigint_plus ( md [ k ] + <STRING> * k , ans ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_divide ( a , b , d = 0 ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> d = int ( d ) <NEWLINE> if d < 0 : <NEWLINE> <INDENT> d = 0 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> r = <STRING> <NEWLINE> for i in range ( len ( a ) + d ) : <NEWLINE> <INDENT> q = 0 <NEWLINE> if i < len ( a ) : <NEWLINE> <INDENT> r += a [ i ] <NEWLINE> <DEDENT> elif i == len ( a ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> r += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += <STRING> <NEWLINE> <NL> <DEDENT> if bigint_compare ( r , b ) == - 1 : <NEWLINE> <INDENT> ans += str ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while bigint_compare ( r , b ) >= 0 : <NEWLINE> <INDENT> r = bigint_minus ( r , b ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> ans += str ( q ) <NEWLINE> <NL> <DEDENT> <DEDENT> return delete_head_zeros ( ans ) <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if bigint_compare ( a , b ) >= 0 : <NEWLINE> <INDENT> M = a <NEWLINE> m = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = b <NEWLINE> m = a <NEWLINE> <DEDENT> if m == <STRING> : <NEWLINE> <INDENT> return M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = bigint_divide ( M , m ) <NEWLINE> r = bigint_minus ( M , bigint_multiply ( m , q ) ) <NEWLINE> return gcd ( m , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return bigint_divide ( bigint_multiply ( a , b ) , gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> T = [ input ( ) for i in range ( N ) ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> ans = lcm ( T [ i ] , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> p = math . pi <NEWLINE> print ( round ( r * r * p , 6 ) , round ( 2 * r * p , 6 ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> d [ 0 ] = 1 <NEWLINE> x = 0 <NEWLINE> b = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> x += b * int ( s [ i ] ) <NEWLINE> x %= 2019 <NEWLINE> d [ x ] += 1 <NEWLINE> <NL> b *= 10 <NEWLINE> b %= 2019 <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for k in d : <NEWLINE> <INDENT> c = d [ k ] <NEWLINE> res += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ [ 0 ] * 1001 for _ in range ( 1001 ) ] <NEWLINE> for x1 , y1 , x2 , y2 in ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ) : <NEWLINE> <INDENT> a [ x1 ] [ y1 ] += 1 <NEWLINE> a [ x1 ] [ y2 ] -= 1 <NEWLINE> a [ x2 ] [ y1 ] -= 1 <NEWLINE> a [ x2 ] [ y2 ] += 1 <NEWLINE> <DEDENT> print ( max ( map ( max , map ( accumulate , zip ( * map ( accumulate , a ) ) ) ) ) ) <NEWLINE>
z = input ( ) <NEWLINE> <NL> a , b = z . split ( ) <NEWLINE> c = int ( a ) <NEWLINE> d = int ( b ) <NEWLINE> <NL> if c < d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c > d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> x , n = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> if n > 0 : <NEWLINE> <INDENT> P = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> memos = [ False ] * 102 <NEWLINE> <NL> for p in P : <NEWLINE> <INDENT> memos [ p ] = True <NEWLINE> <NL> <DEDENT> tgt = x <NEWLINE> offset = 1 <NEWLINE> look_down = True <NEWLINE> while True : <NEWLINE> <NL> <INDENT> if memos [ tgt ] == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if look_down : <NEWLINE> <INDENT> look_down = False <NEWLINE> tgt = x - offset <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> look_down = True <NEWLINE> tgt = tgt + offset + offset <NEWLINE> offset += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( tgt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = [ 0 ] * ( n + 1 ) <NEWLINE> sb = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sa [ i + 1 ] = sa [ i ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> sb [ i + 1 ] = sb [ i ] + b [ i ] <NEWLINE> <DEDENT> rx = 0 <NEWLINE> rb = m <NEWLINE> for ra in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> while ( sb [ rb ] + sa [ ra ] ) > k and rb > 0 : <NEWLINE> <INDENT> rb -= 1 <NEWLINE> <DEDENT> if ( sb [ rb ] + sa [ ra ] ) <= k : <NEWLINE> <INDENT> rx = max ( rx , ra + rb ) <NEWLINE> <DEDENT> <DEDENT> print ( rx ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A , B = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> t , a = 1 , 1 <NEWLINE> if A > x : <NEWLINE> <INDENT> t = A // x <NEWLINE> if A % x != 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> if B > y : <NEWLINE> <INDENT> a = B // y <NEWLINE> if B % y != 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> m = max ( t , a ) <NEWLINE> A = x * m <NEWLINE> B = y * m <NEWLINE> <DEDENT> print ( A + B ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> RB = B [ : : - 1 ] <NEWLINE> <NL> start = v = - 1 <NEWLINE> seq = 0 <NEWLINE> for i , ( a , b ) in enumerate ( zip ( A , RB ) ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> v = a <NEWLINE> seq += 1 <NEWLINE> if start == - 1 : <NEWLINE> <INDENT> start = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if v == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * RB ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if A . count ( v ) + B . count ( v ) > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> from bisect import bisect_left , bisect <NEWLINE> al = bisect_left ( A , v ) <NEWLINE> bl = bisect_left ( B , v ) <NEWLINE> br = bisect ( B , v ) <NEWLINE> rbl = N - br <NEWLINE> <NL> m = min ( seq , start , al , rbl ) <NEWLINE> RB [ : m ] , RB [ start : start + m ] = RB [ start : start + m ] , RB [ : m ] <NEWLINE> seq -= m <NEWLINE> start += m <NEWLINE> if seq : <NEWLINE> <INDENT> RB [ start : start + seq ] , RB [ - seq : ] = RB [ - seq : ] , RB [ start : start + seq ] <NEWLINE> <NL> <DEDENT> assert all ( a != b for a , b in zip ( A , RB ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( * RB ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if V [ i ] > C [ i ] : <NEWLINE> <INDENT> ans += V [ i ] - C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t = 1 <NEWLINE> d = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = t * i % d <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> x = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x *= a [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> pf = { } <NEWLINE> answer = 0 <NEWLINE> <NL> for i in range ( 2 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while N % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> N //= i <NEWLINE> <NL> <DEDENT> if N < i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if N > 1 : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> for j , k in pf . items ( ) : <NEWLINE> <INDENT> sq = 1 <NEWLINE> for l in range ( k ) : <NEWLINE> <INDENT> answer += 1 <NEWLINE> k -= sq <NEWLINE> sq += 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif k < 0 : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> t , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = sorted ( [ d [ i + 1 ] - d [ i ] for i in range ( t - 1 ) ] ) <NEWLINE> print ( sum ( d [ : t - k ] ) if t > k else 0 ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> K = [ 0 ] * N <NEWLINE> <NL> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> K [ L [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * K , sep = <STRING> ) <NEWLINE>
it = input ( ) <NEWLINE> it = it . split ( ) <NEWLINE> n = int ( it [ 0 ] ) <NEWLINE> m = int ( it [ 1 ] ) <NEWLINE> p = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> itf = input ( ) <NEWLINE> itf = itf . split ( ) <NEWLINE> a = int ( itf [ 0 ] ) <NEWLINE> b = int ( itf [ 1 ] ) <NEWLINE> p [ a - 1 ] . append ( b ) <NEWLINE> p [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> d = [ 1 , ] <NEWLINE> con = [ 0 ] * n <NEWLINE> while d : <NEWLINE> <INDENT> l = d . pop ( 0 ) <NEWLINE> for k in p [ l - 1 ] : <NEWLINE> <INDENT> if con [ k - 2 ] == 0 : <NEWLINE> <INDENT> d . append ( k ) <NEWLINE> con [ k - 2 ] = l <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( con [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> temp_max = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if temp_max > x : <NEWLINE> <INDENT> res += temp_max - x <NEWLINE> <DEDENT> temp_max = max ( temp_max , x ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> Q = int ( 1e9 + 7 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> <NL> if K == N : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= Q <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif K == 1 : <NEWLINE> <INDENT> ans = A [ - 1 ] % Q <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A_mi , A_0 , A_pl = [ ] , [ ] , [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> A_pl . append ( a ) <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> A_mi . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_0 . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( A_mi ) + len ( A_pl ) < K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if N == len ( A_pl ) : <NEWLINE> <INDENT> ans , c = 1 , 0 <NEWLINE> for a in reversed ( A_pl ) : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= Q <NEWLINE> c += 1 <NEWLINE> if c == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if N == len ( A_mi ) + len ( A_0 ) : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> ans , c = 1 , 0 <NEWLINE> for a in A_mi : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= Q <NEWLINE> c += 1 <NEWLINE> if c == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( A_0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans , c = 1 , 0 <NEWLINE> for a in reversed ( A_mi ) : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= Q <NEWLINE> c += 1 <NEWLINE> if c == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> cost_2 = [ ] <NEWLINE> if len ( A_mi ) > 1 : <NEWLINE> <INDENT> for i in range ( 0 , len ( A_mi ) - 1 , 2 ) : <NEWLINE> <INDENT> cost_2 . append ( A_mi [ i ] * A_mi [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> ans = 1 <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if len ( cost_2 ) > 0 : <NEWLINE> <INDENT> c2 = cost_2 [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c2 = 0 <NEWLINE> <DEDENT> if len ( A_pl ) > 1 : <NEWLINE> <INDENT> pl2 = A_pl [ - 1 ] * A_pl [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pl2 = 0 <NEWLINE> <DEDENT> if c2 > pl2 : <NEWLINE> <INDENT> ans *= c2 <NEWLINE> cost_2 . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pl2 <NEWLINE> A_pl . pop ( - 1 ) <NEWLINE> A_pl . pop ( - 1 ) <NEWLINE> <DEDENT> ans %= Q <NEWLINE> c += 2 <NEWLINE> if c == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if ( K - c > 1 ) and ( len ( cost_2 ) > 0 ) : <NEWLINE> <INDENT> c2 = cost_2 [ 0 ] <NEWLINE> if len ( A_pl ) > 2 : <NEWLINE> <INDENT> pl2 = A_pl [ - 1 ] * A_pl [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pl2 = 0 <NEWLINE> <DEDENT> if c2 >= pl2 : <NEWLINE> <INDENT> ans *= c2 <NEWLINE> cost_2 . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pl2 <NEWLINE> A_pl . pop ( - 1 ) <NEWLINE> A_pl . pop ( - 1 ) <NEWLINE> <DEDENT> ans %= Q <NEWLINE> c += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A_pl [ - 1 ] <NEWLINE> ans %= Q <NEWLINE> c += 1 <NEWLINE> A_pl . pop ( - 1 ) <NEWLINE> <DEDENT> if K == c : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> ca = Counter ( a ) <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if b in ca : <NEWLINE> <INDENT> cnt = ca . pop ( b ) <NEWLINE> ca [ c ] += cnt <NEWLINE> <NL> ans -= b * cnt <NEWLINE> ans += c * cnt <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = list ( accumulate ( P ) ) <NEWLINE> <NL> largest = A [ K - 1 ] <NEWLINE> point = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if largest < A [ i ] - A [ i - K ] : <NEWLINE> <INDENT> largest = A [ i ] - A [ i - K ] <NEWLINE> point = i <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in range ( point - K + 1 , point + 1 ) : <NEWLINE> <INDENT> p = P [ j ] <NEWLINE> ans += ( ( ( p + 1 ) * p ) / 2 ) / p <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> max_1 = 0 <NEWLINE> max_2 = 0 <NEWLINE> a_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> a_list . append ( a ) <NEWLINE> if max_1 < a : <NEWLINE> <INDENT> max_2 = max_1 <NEWLINE> max_1 = a <NEWLINE> <DEDENT> elif max_2 < a : <NEWLINE> <INDENT> max_2 = a <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a_list [ i ] == max_1 : <NEWLINE> <INDENT> print ( max_2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_1 ) <NEWLINE> <DEDENT> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> tmp = factorization ( p ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( len ( tmp ) ) : <NEWLINE> <INDENT> while tmp [ i ] [ 1 ] >= n : <NEWLINE> <INDENT> tmp [ i ] [ 1 ] -= n <NEWLINE> ans *= tmp [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> import bisect <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> sushi = [ <STRING> ] <NEWLINE> alt = [ chr ( ord ( <STRING> ) + i ) for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sushi = [ ans + x for ans in sushi for x in alt [ : len ( set ( ans ) ) + 1 ] ] <NEWLINE> <DEDENT> for i in sushi : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a + b if a + b < 10 else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def r ( D , s ) : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> t = D [ 0 ] <NEWLINE> D [ 0 ] = D [ 1 ] <NEWLINE> D [ 1 ] = D [ 5 ] <NEWLINE> D [ 5 ] = D [ 4 ] <NEWLINE> D [ 4 ] = t <NEWLINE> <DEDENT> elif s == 2 : <NEWLINE> <INDENT> t = D [ 0 ] <NEWLINE> D [ 0 ] = D [ 4 ] <NEWLINE> D [ 4 ] = D [ 5 ] <NEWLINE> D [ 5 ] = D [ 1 ] <NEWLINE> D [ 1 ] = t <NEWLINE> <DEDENT> elif s == 3 : <NEWLINE> <INDENT> t = D [ 0 ] <NEWLINE> D [ 0 ] = D [ 3 ] <NEWLINE> D [ 3 ] = D [ 5 ] <NEWLINE> D [ 5 ] = D [ 2 ] <NEWLINE> D [ 2 ] = t <NEWLINE> <DEDENT> elif s == 1 : <NEWLINE> <INDENT> t = D [ 0 ] <NEWLINE> D [ 0 ] = D [ 2 ] <NEWLINE> D [ 2 ] = D [ 5 ] <NEWLINE> D [ 5 ] = D [ 3 ] <NEWLINE> D [ 3 ] = t <NEWLINE> <DEDENT> elif s == 4 : <NEWLINE> <INDENT> D = r ( r ( D , 1 ) , 1 ) <NEWLINE> <DEDENT> return D <NEWLINE> <DEDENT> def ch ( C , D ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> while k < 6 and C [ k ] == D [ k ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> if k == 6 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> def d3 ( C , D ) : <NEWLINE> <INDENT> nd = 0 <NEWLINE> if ch ( C , D ) == 1 : <NEWLINE> <INDENT> nd = 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> while i < 4 and nd == 0 : <NEWLINE> <INDENT> D = r ( D , i ) <NEWLINE> j = i + 1 <NEWLINE> j %= 4 <NEWLINE> k = 0 <NEWLINE> if ch ( C , D ) == 1 : <NEWLINE> <INDENT> nd = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> while k < 3 and nd == 0 : <NEWLINE> <INDENT> D = r ( D , j ) <NEWLINE> if ch ( C , D ) == 1 : <NEWLINE> <INDENT> nd = 1 <NEWLINE> <DEDENT> k += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> D = r ( D , j ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> m = i + 2 <NEWLINE> m %= 4 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> D = r ( D , m ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> i += 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> while nd == 0 and i < 4 : <NEWLINE> <INDENT> D = r ( D , 0 ) <NEWLINE> D = r ( D , 1 ) <NEWLINE> D = r ( D , 0 ) <NEWLINE> if ch ( C , D ) == 1 : <NEWLINE> <INDENT> nd = 1 <NEWLINE> <DEDENT> D = r ( r ( D , 0 ) , 0 ) <NEWLINE> if ch ( C , D ) == 1 : <NEWLINE> <INDENT> nd = 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if nd == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> Dl = [ [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> i1 = 0 <NEWLINE> ne = 1 <NEWLINE> while i1 < n - 1 and ne == 1 : <NEWLINE> <INDENT> i2 = i1 + 1 <NEWLINE> while i2 < n and ne == 1 : <NEWLINE> <INDENT> if d3 ( Dl [ i1 ] , Dl [ i2 ] ) == 1 : <NEWLINE> <INDENT> ne = 0 <NEWLINE> <DEDENT> i2 += 1 <NEWLINE> <DEDENT> i1 += 1 <NEWLINE> <DEDENT> if ne == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ k ] * n ) <NEWLINE> a -= q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> l = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if l <= n : <NEWLINE> <INDENT> ans [ l - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for m in range ( n ) : <NEWLINE> <INDENT> print ( ans [ m ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> r = 0 <NEWLINE> t = pow ( 26 , K , mod ) <NEWLINE> s = 1 <NEWLINE> inv26 = pow ( 26 , mod - 2 , mod ) <NEWLINE> inv = [ 0 ] * ( K + 2 ) <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , K + 2 ) : <NEWLINE> <INDENT> inv [ i ] = - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> <DEDENT> for i in range ( K + 1 ) : <NEWLINE> <INDENT> r = ( r + t * s ) % mod <NEWLINE> t = ( t * 25 * inv26 ) % mod <NEWLINE> s = ( s * ( N + i ) * inv [ i + 1 ] ) % mod <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> d = [ int ( 0 ) ] * 2019 <NEWLINE> d [ 0 ] = int ( 1 ) <NEWLINE> r = int ( 0 ) <NEWLINE> t = int ( 1 ) <NEWLINE> <NL> for si in reversed ( s ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> r = int ( si ) * t + r <NEWLINE> r = r % 2019 <NEWLINE> <NL> t = t * 10 <NEWLINE> t = t % 2019 <NEWLINE> <NL> d [ r ] = d [ r ] + 1 <NEWLINE> <NL> <DEDENT> ans = int ( 0 ) <NEWLINE> for di in d : <NEWLINE> <INDENT> ans = ans + di * ( di - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> try : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> print ( 100 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> old_diff = 10000 <NEWLINE> for i in range ( - 110 , 110 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = abs ( x - i ) <NEWLINE> if diff < old_diff : <NEWLINE> <INDENT> ans = i <NEWLINE> old_diff = abs ( x - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> start = max ( 0 , i - k ) <NEWLINE> dp [ i ] = min ( dp [ j ] + abs ( l [ i ] - l [ j ] ) for j in range ( start , i ) ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> def max_heapify ( A , i ) : <NEWLINE> <INDENT> j = i <NEWLINE> largest = i <NEWLINE> H = len ( A ) - 1 <NEWLINE> while True : <NEWLINE> <INDENT> l = j * 2 <NEWLINE> r = l + 1 <NEWLINE> if l <= H and A [ l ] > A [ j ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> if r <= H and A [ r ] > A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != j : <NEWLINE> <INDENT> A [ j ] , A [ largest ] = A [ largest ] , A [ j ] <NEWLINE> <COMMENT> <NL> j = largest <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def build_max_heap ( A ) : <NEWLINE> <INDENT> i = len ( A ) - 1 <NEWLINE> last = A [ i ] <NEWLINE> parent = i // 2 <NEWLINE> while parent > 0 and A [ parent ] < last : <NEWLINE> <INDENT> A [ i ] = A [ parent ] <NEWLINE> i = parent <NEWLINE> parent = i // 2 <NEWLINE> <DEDENT> A [ i ] = last <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def extract ( A ) : <NEWLINE> <INDENT> print ( A [ 1 ] ) <NEWLINE> A [ 1 ] = A [ - 1 ] <NEWLINE> del A [ - 1 ] <NEWLINE> max_heapify ( A , 1 ) <NEWLINE> <NL> <DEDENT> A = [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> for l in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if l [ 0 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> A . append ( int ( l [ 7 : ] ) ) <NEWLINE> build_max_heap ( A ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif l [ 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> print ( out , end = <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( A ) <= 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif len ( A ) == 2 : <NEWLINE> <INDENT> out += str ( A . pop ( ) ) + <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> out += str ( A [ 1 ] ) + <STRING> <NEWLINE> A [ 1 ] = A . pop ( ) <NEWLINE> max_heapify ( A , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , collections <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> fr = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> bl = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> <NL> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> fr [ a ] . append ( b ) <NEWLINE> fr [ b ] . append ( a ) <NEWLINE> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> bl [ c ] . append ( d ) <NEWLINE> bl [ d ] . append ( c ) <NEWLINE> <NL> <DEDENT> fl = [ - 1 for i in range ( N + 1 ) ] <NEWLINE> fl [ 0 ] = 0 <NEWLINE> fl [ 1 ] = 1 <NEWLINE> nxt = 1 <NEWLINE> dic = { } <NEWLINE> s = set ( range ( 1 , N + 1 ) ) <NEWLINE> while nxt != 0 : <NEWLINE> <INDENT> q = collections . deque ( [ nxt ] ) <NEWLINE> <NL> fl [ nxt ] = nxt <NEWLINE> cnt = 0 <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> s . discard ( now ) <NEWLINE> for f in fr [ now ] : <NEWLINE> <INDENT> if fl [ f ] == - 1 : <NEWLINE> <INDENT> fl [ f ] = nxt <NEWLINE> cnt += 1 <NEWLINE> q . append ( f ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dic [ nxt ] = cnt <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if len ( s ) == 0 : <NEWLINE> <INDENT> nxt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nxt = s . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> mbf = collections . deque ( ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ff = 0 <NEWLINE> for j in bl [ i ] : <NEWLINE> <INDENT> if fl [ j ] == fl [ i ] : <NEWLINE> <INDENT> ff -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ff += dic [ fl [ i ] ] - len ( fr [ i ] ) <NEWLINE> mbf . append ( ff ) <NEWLINE> <DEDENT> print ( * mbf ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def primeTable ( n ) : <NEWLINE> <INDENT> list = [ True for _ in range ( n + 1 ) ] <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if list [ i ] : <NEWLINE> <INDENT> j = i + i <NEWLINE> while j <= n : <NEWLINE> <INDENT> list [ j ] = False <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> table = [ i for i in range ( n + 1 ) if list [ i ] and i >= 2 ] <NEWLINE> return table <NEWLINE> <NL> <DEDENT> lines = sys . stdin . readlines ( ) <NEWLINE> primeList = primeTable ( 999999 ) <NEWLINE> <NL> for line in lines : <NEWLINE> <INDENT> inp = int ( line ) <NEWLINE> primes = list ( filter ( lambda n : n >= 2 and n <= inp , primeList ) ) <NEWLINE> num = len ( primes ) <NEWLINE> print ( num ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> def merge_sort ( array ) : <NEWLINE> <INDENT> if len ( array ) > 1 : <NEWLINE> <INDENT> L , countL = merge_sort ( array [ 0 : len ( array ) // 2 ] ) <NEWLINE> R , countR = merge_sort ( array [ len ( array ) // 2 : ] ) <NEWLINE> return merge ( L , R , countL + countR ) <NEWLINE> <NL> <DEDENT> if len ( array ) == 1 : <NEWLINE> <INDENT> return [ array , 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( L , R , count = 0 ) : <NEWLINE> <INDENT> L . append ( 10 ** 9 + 1 ) <NEWLINE> R . append ( 10 ** 9 + 1 ) <NEWLINE> response = [ ] <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( len ( L ) - 1 + len ( R ) - 1 ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> response . append ( L [ i ] ) <NEWLINE> i += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> response . append ( R [ j ] ) <NEWLINE> j += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> return [ response , count ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numbers , count = merge_sort ( S ) <NEWLINE> print ( * numbers ) <NEWLINE> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 121 ) : <NEWLINE> <INDENT> for j in range ( - 121 , 121 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == n : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> def gcd ( m , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return m <NEWLINE> <DEDENT> return gcd ( n , m % n ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g = gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if k % g == 0 : <NEWLINE> <INDENT> t += g <NEWLINE> <DEDENT> elif g % k == 0 : <NEWLINE> <INDENT> t += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += gcd ( g , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE> <NL> <NL> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_list_E = [ ] <NEWLINE> p_list_E_temp = [ 1 , 1.5 , 2 , 2.5 , 3 , 3.5 ] <NEWLINE> <NL> for i in range ( len ( p_list ) ) : <NEWLINE> <INDENT> p_list_E . append ( ( p_list [ i ] + 1 ) * 0.5 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> p_list_sum = [ 0 ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> p_list_sum . append ( p_list_sum [ i ] + p_list_E [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K , N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , p_list_sum [ i ] - p_list_sum [ i - K ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mp = [ False ] * 101 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mp [ l [ i ] ] = True <NEWLINE> <NL> <NL> <NL> <DEDENT> queue = [ x ] <NEWLINE> while ( len ( queue ) > 0 ) : <NEWLINE> <INDENT> now = queue . pop ( 0 ) <NEWLINE> if ( now <= 0 or now >= 101 ) : <NEWLINE> <INDENT> print ( now ) <NEWLINE> break <NEWLINE> <DEDENT> if ( mp [ now ] == False ) : <NEWLINE> <INDENT> print ( now ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if ( now == x ) : <NEWLINE> <INDENT> queue . append ( now - 1 ) <NEWLINE> queue . append ( now + 1 ) <NEWLINE> <DEDENT> if ( now < x ) : <NEWLINE> <INDENT> queue . append ( now - 1 ) <NEWLINE> <DEDENT> if ( now > x ) : <NEWLINE> <INDENT> queue . append ( now + 1 ) <NEWLINE> <DEDENT> <DEDENT>
A = int ( input ( ) ) <NEWLINE> for i in range ( 3 , A + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
x = int ( input ( <STRING> ) ) <NEWLINE> print ( <STRING> . format ( x * x * x ) ) <NEWLINE>
<COMMENT> <NL> <NL> points = [ float ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> a = [ points [ 0 ] , points [ 1 ] ] <NEWLINE> b = [ points [ 2 ] , points [ 3 ] ] <NEWLINE> <NL> distanceSquare = ( a [ 0 ] - b [ 0 ] ) ** 2 + ( a [ 1 ] - b [ 1 ] ) ** 2 <NEWLINE> distance = distanceSquare ** 0.5 <NEWLINE> <NL> print ( distance ) <NEWLINE> <NL>
a , b = [ int ( tem ) for tem in input ( ) . split ( ) ] <NEWLINE> <NL> def mak ( A , B ) : <NEWLINE> <INDENT> while B != 0 : <NEWLINE> <INDENT> q , r = divmod ( A , B ) <NEWLINE> A = int ( ( A - r ) / q ) <NEWLINE> B = r <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> if a > b : print ( mak ( a , b ) ) <NEWLINE> else : print ( mak ( b , a ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_pos = sorted ( [ i for i in a if i >= 0 ] ) <NEWLINE> a_neg = sorted ( [ i for i in a if i < 0 ] , reverse = True ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> if len ( a_pos ) == 0 and k % 2 : <NEWLINE> <INDENT> for i in a_neg [ : k ] : <NEWLINE> <INDENT> ans = ans * i % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while k > 0 : <NEWLINE> <INDENT> if k == 1 or len ( a_neg ) <= 1 : <NEWLINE> <INDENT> if len ( a_pos ) == 0 : <NEWLINE> <INDENT> ans *= a_neg . pop ( ) <NEWLINE> <DEDENT> elif len ( a_pos ) > 0 : <NEWLINE> <INDENT> ans *= a_pos . pop ( ) <NEWLINE> <DEDENT> k -= 1 <NEWLINE> <DEDENT> elif len ( a_pos ) <= 1 : <NEWLINE> <INDENT> ans *= a_neg . pop ( ) * a_neg . pop ( ) <NEWLINE> k -= 2 <NEWLINE> <NL> <DEDENT> elif a_pos [ - 1 ] * a_pos [ - 2 ] > a_neg [ - 1 ] * a_neg [ - 2 ] : <NEWLINE> <INDENT> ans *= a_pos . pop ( ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> elif a_pos [ 0 ] * a_pos [ 1 ] <= a_neg [ - 1 ] * a_neg [ - 2 ] : <NEWLINE> <INDENT> ans *= a_neg . pop ( ) * a_neg . pop ( ) <NEWLINE> k -= 2 <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , ( <STRING> + input ( ) ) . split ( ) ) ) <NEWLINE> <NL> <NL> c = [ 0 ] * ( N + 1 ) <NEWLINE> i = 1 <NEWLINE> cnt = 0 <NEWLINE> f = True <NEWLINE> <NL> while cnt < K : <NEWLINE> <INDENT> if f and ( c [ A [ i ] ] or A [ i ] == 1 ) : <NEWLINE> <INDENT> loop = cnt - c [ A [ i ] ] + 1 <NEWLINE> cnt += ( K - cnt - 1 ) // loop * loop <NEWLINE> f = False <NEWLINE> <NL> <DEDENT> cnt += 1 <NEWLINE> i = A [ i ] <NEWLINE> c [ i ] = cnt <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <NL> <DEDENT> d = { n : 1 for n in p } <NEWLINE> <NL> a = X <NEWLINE> b = X <NEWLINE> while True : <NEWLINE> <INDENT> if d . get ( a ) != 1 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> elif d . get ( b ) != 1 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab_list = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> ab_dict = { i : [ ] for i in range ( N ) } <NEWLINE> for a , b in ab_list : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> ab_dict [ a ] . append ( b ) <NEWLINE> ab_dict [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( H_list ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for k , v_list in ab_dict . items ( ) : <NEWLINE> <INDENT> for v in v_list : <NEWLINE> <INDENT> if H_list [ v ] >= H_list [ k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> S = deque ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> rev_cnt = 0 <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> q = input ( ) . split ( ) <NEWLINE> if len ( q ) == 1 : <NEWLINE> <INDENT> rev_cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( rev_cnt + int ( q [ 1 ] ) ) % 2 == 0 : <NEWLINE> <INDENT> S . append ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . appendleft ( q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if rev_cnt % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( reversed ( S ) ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
menu = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> def kuriage ( n ) : <NEWLINE> <INDENT> if n % 10 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 10 - ( n % 10 ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> mini = 10 <NEWLINE> k = 5 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if menu [ i ] % 10 < mini and menu [ i ] % 10 != 0 : <NEWLINE> <INDENT> mini = menu [ i ] % 10 <NEWLINE> k = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> menu [ i ] , menu [ - 1 ] = menu [ - 1 ] , menu [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i != 4 : <NEWLINE> <INDENT> ans += menu [ i ] + kuriage ( menu [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += menu [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( N + 1 ) ] <NEWLINE> size = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> par [ x ] = y <NEWLINE> size [ y ] = size [ x ] + size [ y ] <NEWLINE> size [ x ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <DEDENT> Ans = 0 <NEWLINE> for j in size [ 1 : ] : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> Ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> A = list ( range ( 1 , N + 1 ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> A [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> A [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ a - 1 ] = 0 <NEWLINE> A [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( N - A . count ( 0 ) ) <NEWLINE>
n = input ( ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( 1 , int ( n ) + 1 ) : <NEWLINE> <INDENT> s += ( <STRING> + str ( i ) ) if i % 3 == 0 or <STRING> in str ( i ) else <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 18 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul = 1 <NEWLINE> flg = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mul *= a [ i ] <NEWLINE> if mul > INF : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
number = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxV = 10 ** 6 + 1 <NEWLINE> dp = [ 0 ] * ( maxV ) <NEWLINE> <NL> for a in values : <NEWLINE> <INDENT> i = 1 <NEWLINE> if dp [ a ] > 0 : <NEWLINE> <INDENT> dp [ a ] = dp [ a ] + 1 <NEWLINE> continue <NEWLINE> <DEDENT> while i * a < maxV : <NEWLINE> <INDENT> i_a = i * a <NEWLINE> dp [ i_a ] = dp [ i_a ] + 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for a in values : <NEWLINE> <INDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ <STRING> * ( W + 4 ) ] <NEWLINE> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> <NL> ans = [ [ - 1 ] * ( W + 4 ) for _ in range ( H + 4 ) ] <NEWLINE> for i in range ( H + 4 ) : <NEWLINE> <INDENT> for j in range ( W + 4 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ch += 1 ; cw += 1 <NEWLINE> dh += 1 ; dw += 1 <NEWLINE> ans [ ch ] [ cw ] = 0 <NEWLINE> <NL> move = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> magic = [ <NEWLINE> <INDENT> [ - 2 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 2 , 2 ] , [ - 1 , - 2 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ - 1 , 2 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , - 2 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , - 2 ] , [ 2 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] <NEWLINE> ] <NEWLINE> <NL> <DEDENT> mylist = deque ( [ [ ch , cw ] ] ) <NEWLINE> mylist2 = deque ( [ ] ) <NEWLINE> while len ( mylist ) > 0 : <NEWLINE> <INDENT> x , y = mylist . popleft ( ) <NEWLINE> mylist2 . append ( [ x , y ] ) <NEWLINE> for p , q in move : <NEWLINE> <INDENT> v1 , v2 = x + p , y + q <NEWLINE> if ans [ v1 ] [ v2 ] == - 1 : <NEWLINE> <INDENT> mylist . append ( [ v1 , v2 ] ) <NEWLINE> ans [ v1 ] [ v2 ] = ans [ x ] [ y ] <NEWLINE> <DEDENT> <DEDENT> if len ( mylist ) == 0 : <NEWLINE> <INDENT> while len ( mylist2 ) > 0 : <NEWLINE> <INDENT> x2 , y2 = mylist2 . popleft ( ) <NEWLINE> for v1 , v2 in magic : <NEWLINE> <INDENT> i , j = x2 + v1 , y2 + v2 <NEWLINE> if ans [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> mylist . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ dh ] [ dw ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> inf = 10 ** 6 + 1 <NEWLINE> t = [ True for i in range ( inf ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if j + 1 <= N - 1 and t [ A [ j ] ] : <NEWLINE> <INDENT> if A [ j + 1 ] != A [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ A [ j ] ] = False <NEWLINE> <DEDENT> for numb in range ( A [ j ] , inf , A [ j ] ) : <NEWLINE> <INDENT> t [ numb ] = False <NEWLINE> <DEDENT> <DEDENT> elif j == N - 1 and t [ A [ j ] ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> m = m * a [ i ] <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> p = x . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> def solve ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while n : <NEWLINE> <INDENT> popcount = bin ( n ) . count ( <STRING> ) <NEWLINE> n %= popcount <NEWLINE> count += 1 <NEWLINE> <DEDENT> return count + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if p == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> z = x . index ( <STRING> ) <NEWLINE> t = pow ( 2 , n - z - 1 , p + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == z : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( t + pow ( 2 , n - i - 1 , p + 1 ) ) % ( p + 1 ) <NEWLINE> print ( solve ( tmp ) ) <NEWLINE> <DEDENT> <DEDENT> exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> a , b = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( pow ( 2 , i , p + 1 ) ) <NEWLINE> b . append ( pow ( 2 , i , p - 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a1 , b1 = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ - 1 - i ] == <STRING> : <NEWLINE> <INDENT> a1 += a [ i ] <NEWLINE> b1 += b [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> tmp = ( b1 - b [ - 1 - i ] ) % ( p - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( a1 + a [ - 1 - i ] ) % ( p + 1 ) <NEWLINE> <DEDENT> print ( solve ( tmp ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> A = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , num = input ( ) . strip ( ) . split ( ) <NEWLINE> A [ int ( b ) - 1 ] [ int ( f ) - 1 ] [ int ( r ) - 1 ] += int ( num ) <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , A [ i ] [ j ] ) ) ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> r1 = 0 <NEWLINE> for jj in range ( n ) : <NEWLINE> <INDENT> r1 = r1 ^ a [ jj ] <NEWLINE> <NL> <DEDENT> r = [ 0 ] * n <NEWLINE> for ii in range ( n ) : <NEWLINE> <INDENT> r [ ii ] = r1 ^ a [ ii ] <NEWLINE> <DEDENT> <STRING> <NEWLINE> print ( * r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( A [ i ] + B [ i ] ) <NEWLINE> <DEDENT> l . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N // 2 ) : <NEWLINE> <INDENT> ans += l [ 2 * i ] <NEWLINE> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> ans += l [ - 1 ] <NEWLINE> <DEDENT> ans -= sum ( B ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if sorted ( a ) [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import math <NEWLINE> b = [ math . log10 ( i ) for i in a if i != 0 ] <NEWLINE> if sum ( b ) > 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> z *= i <NEWLINE> <DEDENT> if z > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( z ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 for _ in range ( n ) ] <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <COMMENT> <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x != y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> <NL> par [ y ] = x <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in par : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> * C , = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> T = [ int ( input ( ) ) for _ in range ( D ) ] <NEWLINE> days = [ [ 0 ] for _ in range ( 26 ) ] <NEWLINE> <NL> def init ( ) : <NEWLINE> <INDENT> global T , days <NEWLINE> score = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for d , t in enumerate ( T , 1 ) : <NEWLINE> <INDENT> score += S [ d - 1 ] [ t - 1 ] <NEWLINE> last [ t - 1 ] = d <NEWLINE> for c , l in zip ( C , last ) : score -= c * ( d - l ) <NEWLINE> days [ t - 1 ] . append ( d ) <NEWLINE> <DEDENT> for i in range ( 26 ) : days [ i ] . append ( D + 1 ) <NEWLINE> return score <NEWLINE> <NL> <DEDENT> def diff ( d , q ) : <NEWLINE> <INDENT> global score , T , C , S , days <NEWLINE> p = T [ d - 1 ] <NEWLINE> score += S [ d - 1 ] [ q - 1 ] - S [ d - 1 ] [ p - 1 ] <NEWLINE> idx_p = bisect_left ( days [ p - 1 ] , d ) <NEWLINE> bef_p , aft_p = days [ p - 1 ] [ idx_p - 1 ] , days [ p - 1 ] [ idx_p + 1 ] <NEWLINE> del days [ p - 1 ] [ idx_p ] <NEWLINE> idx_q = bisect_left ( days [ q - 1 ] , d ) <NEWLINE> bef_q , aft_q = days [ q - 1 ] [ idx_q - 1 ] , days [ q - 1 ] [ idx_q ] <NEWLINE> days [ q - 1 ] . insert ( idx_q , d ) <NEWLINE> score += C [ q - 1 ] * ( d - bef_q ) * ( aft_q - d ) - C [ p - 1 ] * ( d - bef_p ) * ( aft_p - d ) <NEWLINE> T [ d - 1 ] = q <NEWLINE> return score <NEWLINE> <NL> <DEDENT> score = init ( ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> d , q = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( diff ( d , q ) ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> <NL> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> x = A * 2 ** i <NEWLINE> y = B * 2 ** j <NEWLINE> z = C * 2 ** k <NEWLINE> <COMMENT> <NL> <NL> if x < y < z and i + j + k <= K : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> l = sorted ( a ) <NEWLINE> same = 1 <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if l [ i ] == l [ i - 1 ] : <NEWLINE> <INDENT> same += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if same % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> same = 1 <NEWLINE> <DEDENT> if same % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> li = [ True ] * n <NEWLINE> <NL> a = 1 + m <NEWLINE> if m % 2 == 0 : <NEWLINE> <INDENT> for i in range ( m // 2 ) : <NEWLINE> <INDENT> print ( 1 + i , a - i ) <NEWLINE> <DEDENT> for i in range ( m // 2 ) : <NEWLINE> <INDENT> print ( a + 1 + i , a + m - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ( m + 1 ) // 2 ) : <NEWLINE> <INDENT> print ( 1 + i , a - i ) <NEWLINE> <DEDENT> for i in range ( m // 2 ) : <NEWLINE> <INDENT> print ( a + 1 + i , a + m - i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> ans += int ( ( N - 1 ) / n ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> l = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] and l [ i ] == 0 : <NEWLINE> <INDENT> l [ i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if s . count ( s [ 0 ] ) == n : <NEWLINE> <INDENT> print ( n * k // 2 ) <NEWLINE> <DEDENT> elif s [ 0 ] != s [ - 1 ] : <NEWLINE> <INDENT> print ( sum ( l ) * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = 0 <NEWLINE> ac = True <NEWLINE> bc = True <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ 0 ] and ac == True : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif s [ i ] != s [ 0 ] : <NEWLINE> <INDENT> ac = False <NEWLINE> <DEDENT> if s [ n - 1 - i ] == s [ n - 1 ] and bc == True : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : bc = False <NEWLINE> <DEDENT> sub = a // 2 + b // 2 - ( a + b ) // 2 <NEWLINE> print ( sum ( l ) * k - sub * ( k - 1 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> max_z , max_w , min_z , min_w = - 10 ** 20 , - 10 ** 20 , 10 ** 20 , 10 ** 20 <NEWLINE> ans = 0 <NEWLINE> for p in xy : <NEWLINE> <INDENT> max_z , max_w = max ( max_z , p [ 0 ] + p [ 1 ] ) , max ( max_w , p [ 0 ] - p [ 1 ] ) <NEWLINE> min_z , min_w = min ( min_z , p [ 0 ] + p [ 1 ] ) , min ( min_w , p [ 0 ] - p [ 1 ] ) <NEWLINE> <DEDENT> ans = max ( max_z - min_z , max_w - min_w ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num . sort ( ) <NEWLINE> print ( num [ 0 ] , num [ 1 ] , num [ 2 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> def gdc ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gdc ( b , a % b ) <NEWLINE> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gdc ( a , b ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> T = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> return print ( T [ 0 ] ) <NEWLINE> <DEDENT> ans = lcm ( max ( T [ 0 ] , T [ 1 ] ) , min ( T [ 0 ] , T [ 1 ] ) ) <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> ans = lcm ( max ( ans , T [ i ] ) , min ( ans , T [ i ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if K >= sum ( A ) + sum ( B ) : <NEWLINE> <INDENT> print ( M + N ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> acc = 0 <NEWLINE> ans = 0 <NEWLINE> for j , b in enumerate ( B ) : <NEWLINE> <INDENT> acc += b <NEWLINE> if K >= acc : <NEWLINE> <INDENT> ans = j + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> acc += A [ i ] <NEWLINE> if K >= acc : <NEWLINE> <INDENT> ans = max ( ans , i + j + 2 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( K < acc ) & ( j > - 1 ) : <NEWLINE> <INDENT> acc -= B [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> if K >= acc : <NEWLINE> <INDENT> ans = max ( ans , i + j + 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> id = a [ 0 ] <NEWLINE> jisu = a [ 1 ] <NEWLINE> for j in range ( jisu ) : <NEWLINE> <INDENT> c = a [ j + 2 ] <NEWLINE> ans [ i ] [ c - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if j != N - 1 : <NEWLINE> <INDENT> print ( ans [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( i , j ) <NEWLINE> for t in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( gcd1 , t ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> text = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> text . append ( s ) <NEWLINE> <DEDENT> print ( len ( collections . Counter ( text ) ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> output = list ( ) <NEWLINE> <NL> axor = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> axor ^= A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> output . append ( axor ^ A [ i ] ) <NEWLINE> <DEDENT> print ( * output ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> maxi = a [ - 1 ] <NEWLINE> boo = [ True ] * ( maxi + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k = a [ i ] <NEWLINE> if not boo [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i != n - 1 and k == a [ i + 1 ] : <NEWLINE> <INDENT> boo [ k ] = False <NEWLINE> <DEDENT> for j in range ( 2 , maxi // k + 1 ) : <NEWLINE> <INDENT> boo [ k * j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for k in a : <NEWLINE> <INDENT> if boo [ k ] == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from itertools import combinations <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = set ( A ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for C in combinations ( A , i ) : <NEWLINE> <INDENT> B . add ( sum ( C ) ) <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for m in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> print ( <STRING> if m in B else <STRING> ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> i_index = S . find ( str ( i ) ) <NEWLINE> j_index = S . find ( str ( j ) , i_index + 1 ) <NEWLINE> k_index = S . find ( str ( k ) , j_index + 1 ) <NEWLINE> if i_index != - 1 and j_index != - 1 and k_index != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> temp = gcd ( i , j ) <NEWLINE> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans += gcd ( temp , k ) <NEWLINE> <DEDENT> elif len ( { i , j , k } ) == 2 : <NEWLINE> <INDENT> ans += gcd ( temp , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( temp , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ct = [ 0 ] * N <NEWLINE> <NL> for a in As : <COMMENT> <NEWLINE> <INDENT> ct [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for c in ct : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> gap = x <NEWLINE> ans = 0 <NEWLINE> <NL> for y in range ( 0 , 102 ) : <NEWLINE> <INDENT> if y not in p : <NEWLINE> <INDENT> if abs ( x - y ) < gap : <NEWLINE> <INDENT> gap = abs ( x - y ) <NEWLINE> ans = y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( b ) <NEWLINE> <NL> n , m = zip ( * c . most_common ( ) ) <NEWLINE> n , m = list ( n ) , list ( m ) <NEWLINE> result = 0 <NEWLINE> for i in range ( len ( m ) ) : <NEWLINE> <INDENT> result += ( m [ i ] * ( m [ i ] - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( result - c [ i ] + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> length = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list . sort ( ) <NEWLINE> <NL> max = list [ - 1 ] <NEWLINE> dp = [ 0 ] * ( max + 1 ) <NEWLINE> dp = np . array ( dp , int ) <NEWLINE> <NL> for num in list : <NEWLINE> <INDENT> dp [ num ] = 1 <NEWLINE> <NL> <DEDENT> for num in list : <NEWLINE> <INDENT> if dp [ num ] == 1 : <NEWLINE> <INDENT> dp [ 2 * num : : num ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> count = Counter ( list ) <NEWLINE> <NL> for num , cnt in count . items ( ) : <NEWLINE> <INDENT> if cnt > 1 : <NEWLINE> <INDENT> dp [ num ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp . sum ( ) ) <NEWLINE>
import math <NEWLINE> <NL> a_0 , b_0 = input ( ) . split ( ) <NEWLINE> a = int ( a_0 ) <NEWLINE> <NL> small = str ( a * int ( b_0 [ - 2 : ] ) ) <NEWLINE> <NL> <NL> if len ( small ) >= 3 : <NEWLINE> <INDENT> ans = a * int ( b_0 [ 0 : - 3 ] ) + int ( small [ : - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a * int ( b_0 [ 0 : - 3 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from functools import * <NEWLINE> from math import * <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> gcds = [ ] <NEWLINE> lgcd = [ ] <NEWLINE> rgcd = [ 0 for _ in range ( n ) ] <NEWLINE> l = r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> l = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = gcd ( l , a [ i - 1 ] ) <NEWLINE> <DEDENT> lgcd . append ( l ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> r = 0 <NEWLINE> rgcd [ n - 1 ] = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = gcd ( r , a [ n - i ] ) <NEWLINE> rgcd [ n - i - 1 ] = r <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> g = gcd ( lgcd [ i ] , rgcd [ i ] ) <NEWLINE> gcds . append ( g ) <NEWLINE> <NL> <DEDENT> print ( max ( gcds ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> c = np . array ( list ( input ( ) ) ) <NEWLINE> n = np . count_nonzero ( c == <STRING> ) <NEWLINE> i = 0 <NEWLINE> j = N - 1 <NEWLINE> cnt = 0 <NEWLINE> if N == n : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> while c [ i ] != <STRING> and i < n : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> while c [ j ] != <STRING> and j > n - 1 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if i >= n or j < n : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> temp = c [ i ] <NEWLINE> c [ i ] = c [ j ] <NEWLINE> c [ j ] = temp <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l = 0 <NEWLINE> p = x <NEWLINE> <NL> if x > y : <NEWLINE> <INDENT> l += ( x - y ) * a <NEWLINE> p = y <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> l += ( y - x ) * b <NEWLINE> p = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> l += p * 2 * c <NEWLINE> n = max ( x , y ) * 2 * c <NEWLINE> m = x * a + y * b <NEWLINE> print ( min ( l , n , m ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp_left = np . zeros ( ( N + 1 , K ) , dtype = bool ) <NEWLINE> dp_right = np . zeros ( ( N + 1 , K ) , dtype = bool ) <NEWLINE> dp_left [ 0 , 0 ] = 1 <NEWLINE> dp_right [ N , 0 ] = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp_left [ i + 1 ] = dp_left [ i ] <NEWLINE> dp_right [ N - i - 1 ] = dp_right [ N - i ] <NEWLINE> if ( a : = A [ i ] ) < K : <NEWLINE> <INDENT> dp_left [ i + 1 , a : ] |= dp_left [ i , : - a ] <NEWLINE> <DEDENT> if ( a : = A [ N - i - 1 ] ) < K : <NEWLINE> <INDENT> dp_right [ N - i - 1 , a : ] |= dp_right [ N - i , : - a ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> left_true = np . nonzero ( dp_left [ i ] ) [ 0 ] <NEWLINE> right_true = np . nonzero ( dp_right [ i + 1 ] ) [ 0 ] <NEWLINE> <NL> ss = np . searchsorted ( right_true , K - left_true ) - 1 <NEWLINE> if all ( right_true [ ss ] + left_true + a < K ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mult = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> mult *= i <NEWLINE> if mult > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( mult ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 ] * Q <NEWLINE> C = [ 0 ] * Q <NEWLINE> from collections import Counter <NEWLINE> K = Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in K : <NEWLINE> <INDENT> ans += i * K [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> ans -= B [ i ] * K [ B [ i ] ] <NEWLINE> ans += C [ i ] * K [ B [ i ] ] <NEWLINE> K [ C [ i ] ] += K [ B [ i ] ] <NEWLINE> K [ B [ i ] ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> flag0 = 0 <NEWLINE> flag1 = 0 <NEWLINE> inf = 1000000000000000000 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if ( a == 0 ) : <NEWLINE> <INDENT> flag0 = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag0 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ( ans > inf ) : <NEWLINE> <INDENT> flag1 = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag1 == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> Num = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> Num . append ( 1 ) <NEWLINE> n = ( n - 1 ) / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Num . append ( 0 ) <NEWLINE> n = n / 2 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( Num ) - 1 ) : <NEWLINE> <INDENT> if Num [ i ] == 1 : <NEWLINE> <INDENT> print ( 2 ** i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( 2 ** ( len ( Num ) - 1 ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) for i in range ( n ) ) <NEWLINE> s = sorted ( s ) <NEWLINE> c = collections . Counter ( s ) <NEWLINE> p = max ( c . values ( ) ) <NEWLINE> s = sorted ( list ( set ( s ) ) ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if c [ s [ i ] ] == p : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
def gcd ( m , n ) : <NEWLINE> <INDENT> while ( m % n != 0 ) : <NEWLINE> <INDENT> n , m = m % n , n <NEWLINE> <DEDENT> return ( n ) <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> t = gcd ( a , b ) <NEWLINE> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> v = gcd ( t , c ) <NEWLINE> l = len ( set ( [ a , b , c ] ) ) <NEWLINE> if ( l == 1 ) : s += v <NEWLINE> elif ( l == 2 ) : s += v * 3 <NEWLINE> else : s += v * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> from collections import deque <NEWLINE> C = [ deque ( [ ] ) , deque ( [ ] ) , deque ( [ ] ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> C [ 0 ] . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> C [ 1 ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ 2 ] . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = len ( C [ 0 ] ) * len ( C [ 1 ] ) * len ( C [ 2 ] ) <NEWLINE> <NL> for i in C [ 0 ] : <NEWLINE> <INDENT> for j in C [ 1 ] : <NEWLINE> <INDENT> if max ( i , j ) + abs ( j - i ) < N and S [ max ( i , j ) + abs ( j - i ) ] == <STRING> : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> if min ( i , j ) - abs ( j - i ) >= 0 and S [ min ( i , j ) - abs ( j - i ) ] == <STRING> : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> if ( i + j ) % 2 == 0 and S [ ( i + j ) // 2 ] == <STRING> : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def update ( i , x ) : <NEWLINE> <INDENT> i += base <NEWLINE> st [ i ] = x <NEWLINE> while i > 0 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> st [ i ] = min ( st [ i * 2 + 1 ] , st [ i * 2 + 2 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def find ( a , b ) : <NEWLINE> <INDENT> return _find ( a , b + 1 , 0 , 0 , n ) <NEWLINE> <NL> <NL> <DEDENT> def _find ( a , b , k , l , r ) : <NEWLINE> <INDENT> if b <= l or r <= a : <NEWLINE> <INDENT> return 2 ** 31 - 1 <NEWLINE> <NL> <DEDENT> if a <= l and r <= b : <NEWLINE> <INDENT> return st [ k ] <NEWLINE> <NL> <DEDENT> rl = _find ( a , b , 2 * k + 1 , l , ( l + r ) / 2 ) <NEWLINE> rr = _find ( a , b , 2 * k + 2 , ( l + r ) / 2 , r ) <NEWLINE> return min ( rl , rr ) <NEWLINE> <NL> <NL> <DEDENT> ( _n , q ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = 1 <NEWLINE> while ( n <= _n ) : <NEWLINE> <INDENT> n *= 2 <NEWLINE> <DEDENT> base = n - 1 <NEWLINE> st = [ 2 ** 31 - 1 ] * ( 2 * n - 1 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ( c , l , r ) = map ( int , input ( ) . split ( ) ) <NEWLINE> if c : <NEWLINE> <INDENT> print ( find ( l , r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> update ( l , r ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> data = stdin . readlines ( ) <NEWLINE> <NL> n = int ( data [ 0 ] . split ( ) [ 0 ] ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( data [ i + 1 ] . split ( ) [ 0 ] ) <NEWLINE> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for s in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from math import sqrt <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def dijkstra ( s , G ) : <NEWLINE> <INDENT> BLACK , GRAY , WHITE = 0 , 1 , 2 <NEWLINE> d = [ float ( <STRING> ) ] * 101 <NEWLINE> color = [ WHITE ] * 101 <NEWLINE> p = [ - 1 ] * 101 <NEWLINE> <NL> d [ s ] = 0 <NEWLINE> while True : <NEWLINE> <INDENT> mincost = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> if color [ i ] != BLACK and d [ i ] < mincost : <COMMENT> <NEWLINE> <INDENT> mincost = d [ i ] <NEWLINE> u = i <COMMENT> <NEWLINE> <DEDENT> <DEDENT> if mincost == float ( <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> color [ u ] = BLACK <COMMENT> <NEWLINE> for v in range ( 101 ) : <NEWLINE> <INDENT> if color [ v ] != BLACK and G [ u ] [ v ] != float ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> if d [ u ] + G [ u ] [ v ] < d [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u ] + G [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ v ] = GRAY <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return d , p <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> G = [ [ float ( <STRING> ) ] * ( 100 + 1 ) for _ in range ( 100 + 1 ) ] <NEWLINE> data = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , x , y = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> data . append ( [ b , x , y ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b1 , x1 , y1 = data [ i ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> b2 , x2 , y2 = data [ j ] <NEWLINE> if b1 == b2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist = sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> if dist <= 50.0 : <NEWLINE> <INDENT> G [ b1 ] [ b2 ] = dist <NEWLINE> G [ b2 ] [ b1 ] = dist <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> m = int ( input ( ) ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , g = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if s == g : <NEWLINE> <INDENT> print ( s ) <NEWLINE> continue <NEWLINE> <DEDENT> if ( not 1 <= s <= 100 ) or ( not 1 <= g <= 100 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> d , p = dijkstra ( s , G ) <NEWLINE> if d [ g ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path = [ g ] <NEWLINE> while p [ g ] != s : <NEWLINE> <INDENT> path . append ( p [ g ] ) <NEWLINE> g = p [ g ] <NEWLINE> <DEDENT> path . append ( s ) <NEWLINE> rev = path [ : : - 1 ] <NEWLINE> print ( <STRING> . join ( map ( str , rev ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main2 ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> b , x , y = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , g = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
length = int ( input ( ) ) <NEWLINE> text = input ( ) <NEWLINE> <NL> r_count = text . count ( <STRING> ) <NEWLINE> g_count = text . count ( <STRING> ) <NEWLINE> b_count = text . count ( <STRING> ) <NEWLINE> <NL> answer = r_count * g_count * b_count <NEWLINE> <NL> for i in range ( length - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , length - 1 ) : <NEWLINE> <INDENT> k = i + ( j - i ) * 2 <NEWLINE> if k < length and text [ i ] != text [ j ] and text [ i ] != text [ k ] and text [ j ] != text [ k ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> m = [ 0 ] * 2019 <NEWLINE> num = 0 <NEWLINE> ans = 0 <NEWLINE> n = len ( s ) <NEWLINE> ten = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num += s [ n - i - 1 ] * ten <NEWLINE> num %= 2019 <NEWLINE> m [ num ] += 1 <NEWLINE> ten = ( ten * 10 ) % 2019 <NEWLINE> <DEDENT> for mi in m : <NEWLINE> <INDENT> if mi : <NEWLINE> <INDENT> ans += ( mi * ( mi - 1 ) ) // 2 <NEWLINE> <DEDENT> <DEDENT> ans += m [ 0 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> forward = [ ] <NEWLINE> back = [ ] <NEWLINE> result = <STRING> <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t ^= a [ i ] <NEWLINE> forward . append ( t ) <NEWLINE> <DEDENT> t = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> t ^= a [ i ] <NEWLINE> back . append ( t ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t = back [ n - 2 ] <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> t = forward [ n - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = forward [ i - 1 ] ^ back [ n - 2 - i ] <NEWLINE> <DEDENT> result += str ( t ) + <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> l = input ( ) . split ( ) <NEWLINE> x1 = float ( l [ 0 ] ) <NEWLINE> y1 = float ( l [ 1 ] ) <NEWLINE> x2 = float ( l [ 2 ] ) <NEWLINE> y2 = float ( l [ 3 ] ) <NEWLINE> <NL> A = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) <NEWLINE> print ( A ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ k ] != S [ j ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> adj = [ [ ] for i in range ( N ) ] <NEWLINE> signs = [ - 1 for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ x - 1 ] . append ( y - 1 ) <NEWLINE> adj [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> queue = deque ( [ 0 ] ) <NEWLINE> <NL> while len ( queue ) > 0 : <NEWLINE> <INDENT> cur = queue . popleft ( ) <NEWLINE> for i in adj [ cur ] : <NEWLINE> <INDENT> if signs [ i ] == - 1 : <NEWLINE> <INDENT> queue . append ( i ) <NEWLINE> signs [ i ] = cur <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if all ( [ sign != - 1 for sign in signs [ 1 : ] ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for sign in signs [ 1 : ] : <NEWLINE> <INDENT> print ( sign + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> mat = [ [ i for i in map ( int , input ( ) . split ( ) ) ] for _ in range ( r ) ] <NEWLINE> c_sum = [ 0 for _ in range ( c + 1 ) ] <NEWLINE> for i in mat : <NEWLINE> <INDENT> i . append ( sum ( i ) ) <NEWLINE> for j in range ( len ( i ) ) : <NEWLINE> <INDENT> c_sum [ j ] += i [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> mat . append ( c_sum ) <NEWLINE> for i in mat : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( map ( str , i ) ) ) ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( n , p ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> w = n + 2 <NEWLINE> grid = np . ones ( ( w , w ) , np . int32 ) <NEWLINE> dis = np . zeros ( ( w , w ) , np . int32 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dis [ i ] [ j ] = min ( i , n - i + 1 , j , n - j + 1 ) - 1 <NEWLINE> <DEDENT> <DEDENT> grid = grid . ravel ( ) <NEWLINE> dis = dis . ravel ( ) <NEWLINE> stack = np . empty_like ( grid ) <NEWLINE> for pos in p : <NEWLINE> <INDENT> pos -= 1 <NEWLINE> x = pos % n + 1 <NEWLINE> y = pos // n + 1 <NEWLINE> v = y * w + x <NEWLINE> ans += dis [ v ] <NEWLINE> grid [ v ] = 0 <NEWLINE> k = min ( dis [ v - 1 ] , dis [ v + 1 ] , dis [ v + w ] , dis [ v - w ] ) <NEWLINE> cur = 0 <NEWLINE> stack [ 0 ] = v <NEWLINE> while cur >= 0 : <NEWLINE> <INDENT> v = stack [ cur ] <NEWLINE> cur -= 1 <NEWLINE> for dx in ( - 1 , 1 , w , - w ) : <NEWLINE> <INDENT> next_v = v + dx <NEWLINE> k = dis [ v ] + grid [ v ] <NEWLINE> if dis [ next_v ] > k : <NEWLINE> <INDENT> dis [ next_v ] = k <NEWLINE> cur += 1 <NEWLINE> stack [ cur ] = next_v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( readline ( ) ) <NEWLINE> p = np . array ( readline ( ) . split ( ) , np . int32 ) <NEWLINE> print ( main ( n , p ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k <= ( a + b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + ( k - a - b ) * ( - 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_num = max ( a_list ) <NEWLINE> <NL> is_ans = [ False ] * ( max_num + 1 ) <NEWLINE> memo = [ 0 ] * ( max_num + 1 ) <NEWLINE> for i in a_list : <NEWLINE> <INDENT> is_ans [ i ] = True <NEWLINE> memo [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , max_num + 1 ) : <NEWLINE> <INDENT> if is_ans [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , max_num + 1 , i ) : <NEWLINE> <INDENT> is_ans [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> if memo [ i ] > 1 : <NEWLINE> <INDENT> is_ans [ i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = is_ans . count ( True ) <NEWLINE> print ( ans ) <NEWLINE>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> def cmb ( n , r ) : <NEWLINE> <INDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : return 1 <NEWLINE> over = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return over // under <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> rest = 10 ** 9 + 7 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = ( 10 ** N ) - ( 9 ** N ) - ( 9 ** N ) + ( 8 ** N ) <NEWLINE> <DEDENT> print ( answer % rest ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> suffix_sum = list ( accumulate ( a [ : : - 1 ] ) ) [ : : - 1 ] <NEWLINE> <NL> req_arr = [ x - y for x , y in zip ( suffix_sum , a ) ] <NEWLINE> <NL> result = sum ( [ ( x * y ) % MOD for x , y in zip ( req_arr , a ) ] ) <NEWLINE> <NL> print ( result % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> last = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * A [ i ] <NEWLINE> <DEDENT> last += sum ( A ) * sum ( A ) <NEWLINE> last -= ans <NEWLINE> last //= 2 <NEWLINE> print ( last % 1000000007 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> paths = { i : [ ] for i in range ( N + 1 ) } <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ x ] . append ( y ) <NEWLINE> paths [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> dpt = [ [ - 1 ] * 2 for i in range ( N + 1 ) ] <NEWLINE> <NL> def count_cc ( prev , node , color ) : <NEWLINE> <INDENT> if dpt [ node ] [ color ] != - 1 : <NEWLINE> <INDENT> return dpt [ node ] [ color ] <NEWLINE> <DEDENT> if paths [ node ] == [ prev ] : <NEWLINE> <INDENT> dpt [ node ] [ color ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> result = 1 <NEWLINE> if color == 0 : <NEWLINE> <INDENT> for nxt in paths [ node ] : <NEWLINE> <INDENT> if nxt == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> result *= ( count_cc ( node , nxt , 0 ) + count_cc ( node , nxt , 1 ) ) <NEWLINE> result %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for nxt in paths [ node ] : <NEWLINE> <INDENT> if nxt == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> result *= count_cc ( node , nxt , 0 ) <NEWLINE> result %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> dpt [ node ] [ color ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> print ( ( count_cc ( 0 , 1 , 0 ) + count_cc ( 0 , 1 , 1 ) ) % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 0 <NEWLINE> s = sum ( X ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> s -= X [ n ] <NEWLINE> s = s % ( 10 ** 9 + 7 ) <NEWLINE> p += s * X [ n ] <NEWLINE> p = p % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for e in a : <NEWLINE> <INDENT> ans *= e <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ 0 ] * ( 10 ** 6 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> m = i + 1 + A [ i ] <NEWLINE> if m < 10 ** 6 : <NEWLINE> <INDENT> d [ i + 1 + A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> f = A [ - i ] + N + 1 - i - ( 2 * A [ - i ] ) <NEWLINE> if f >= 0 and f < 10 ** 6 : <NEWLINE> <INDENT> ans += d [ f ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> magic = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> dp = [ 0 for _ in range ( 10 ** 5 ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in magic ) <NEWLINE> <NL> <DEDENT> print ( dp [ H - 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> class FLOOR : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . room = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> class BUILD : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . floor = [ FLOOR ( ) , FLOOR ( ) , FLOOR ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> all_rooms = [ BUILD ( ) , BUILD ( ) , BUILD ( ) , BUILD ( ) ] <NEWLINE> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> all_rooms [ b - 1 ] . floor [ f - 1 ] . room [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> display = [ ] <NEWLINE> for r in range ( 10 ) : <NEWLINE> <INDENT> display . append ( str ( all_rooms [ b ] . floor [ f ] . room [ r ] ) ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( display ) ) <NEWLINE> <DEDENT> if ( b < 3 ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for a in range ( min ( n , k ) + 1 ) : <NEWLINE> <INDENT> pa , va = v [ : a ] , v [ a : ] <NEWLINE> for b in range ( min ( n , k ) - a + 1 ) : <NEWLINE> <INDENT> pb = pa + va [ - b : ] if b > 0 else pa <NEWLINE> pb . sort ( ) <NEWLINE> s = sum ( pb ) <NEWLINE> ans = max ( s , ans ) <NEWLINE> for c in range ( min ( k - a - b , a + b ) ) : <NEWLINE> <INDENT> s -= pb [ c ] <NEWLINE> ans = max ( s , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if B [ i ] >= B [ i + 1 ] : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> a = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <NL> <INDENT> if ans [ j ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = max ( a , cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> b . append ( i + 1 ) <NEWLINE> b . append ( i ) <NEWLINE> b . append ( i - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> c = Counter ( b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( c . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> listA = itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) <NEWLINE> ans = 0 <NEWLINE> listQ = [ ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> listQ += [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <DEDENT> for i in listA : <NEWLINE> <INDENT> anssub = 0 <NEWLINE> for a , b , c , d in listQ : <NEWLINE> <INDENT> if i [ b - 1 ] - i [ a - 1 ] == c : <NEWLINE> <INDENT> anssub += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , anssub ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l , r = [ ] , [ ] <NEWLINE> ans = min ( s . count ( <STRING> ) , s . count ( <STRING> ) ) <NEWLINE> k = s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <DEDENT> ans = min ( ans , k ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D [ i + 1 ] = A [ i ] <NEWLINE> <DEDENT> C = [ ] <NEWLINE> for k , v in D . items ( ) : <NEWLINE> <INDENT> [ C . append ( k ) for _ in range ( v ) ] <NEWLINE> <DEDENT> h = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h += 1 <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> print ( C [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> [ C . pop ( 0 ) for _ in range ( W ) ] <NEWLINE> if h == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h += 1 <NEWLINE> for i in reversed ( range ( W ) ) : <NEWLINE> <INDENT> print ( C [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> [ C . pop ( 0 ) for _ in range ( W ) ] <NEWLINE> if h == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ 0 ] <NEWLINE> ans = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p . append ( list ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> p [ A ] . append ( B ) <NEWLINE> p [ B ] . append ( A ) <NEWLINE> <DEDENT> D = deque ( [ 1 ] ) <NEWLINE> while D : <NEWLINE> <INDENT> ind = D . popleft ( ) <NEWLINE> for i in p [ ind ] : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> D . append ( i ) <NEWLINE> ans [ i ] = ind <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in ans [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> grid = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> grid . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> grid [ i ] [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> grid [ i ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for v in itertools . product ( [ 1 , 0 ] , repeat = ( h + w ) ) : <NEWLINE> <INDENT> grid_dum = np . array ( grid . copy ( ) ) <NEWLINE> for i , x in enumerate ( v [ : h ] ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> grid_dum [ i , : ] = 0 <NEWLINE> <DEDENT> <DEDENT> for i , x in enumerate ( v [ h : ] ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> grid_dum [ : , i ] = 0 <NEWLINE> <DEDENT> <DEDENT> if grid_dum . sum ( ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if not r : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lst = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( r ) ] <NEWLINE> dic = [ 0 for i in range ( 2 ** r ) ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> num *= 2 <NEWLINE> num += lst [ j ] [ i ] <NEWLINE> <DEDENT> dic [ num ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** r ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for j in range ( 2 ** r ) : <NEWLINE> <INDENT> num = ( i ^ j ) <NEWLINE> cnt = 0 <NEWLINE> for k in range ( r ) : <NEWLINE> <INDENT> cnt += num % 2 <NEWLINE> num //= 2 <NEWLINE> <DEDENT> ret += max ( cnt , r - cnt ) * dic [ j ] <NEWLINE> <DEDENT> ans = max ( ans , ret ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> score = np . array ( [ 0 for i in range ( n - k + 1 ) ] , dtype = np . int64 ) <NEWLINE> wknum = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> wknum *= A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n - k ) : <NEWLINE> <INDENT> wknum //= A [ i ] <NEWLINE> wknum *= A [ k + i ] <NEWLINE> if A [ i ] >= A [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> USED = [ False ] * 26 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> USED [ ord ( s ) - 97 ] = True <NEWLINE> <NL> <DEDENT> ok = False <NEWLINE> ans = None <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if not USED [ i ] : <NEWLINE> <INDENT> ans = chr ( 97 + i ) <NEWLINE> ok = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i - k ] < A [ i ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <NEWLINE> town = 1 <NEWLINE> visited = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> town = A [ town ] <NEWLINE> if visited [ town ] == 0 : <NEWLINE> <INDENT> visited [ town ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = i - visited [ town ] <NEWLINE> place = ( K - visited [ town ] ) % loop + visited [ town ] <NEWLINE> print ( visited . index ( place ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( town ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( N , P ) : <NEWLINE> <INDENT> W = N + 2 <NEWLINE> dp = np . zeros ( ( W , W ) , np . int32 ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> dp = dp . T [ : : - 1 ] <NEWLINE> for n in range ( 1 , ( N + 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> dp [ n , n : - n ] = n <NEWLINE> <DEDENT> <DEDENT> filled = np . zeros_like ( dp ) <NEWLINE> filled [ 1 : - 1 , 1 : - 1 ] = 1 <NEWLINE> dp = dp . ravel ( ) <NEWLINE> filled = filled . ravel ( ) <NEWLINE> stack = np . empty_like ( dp ) <NEWLINE> ans = 0 <NEWLINE> for n in P : <NEWLINE> <INDENT> n -= 1 <NEWLINE> h , w = divmod ( n , N ) <NEWLINE> v = ( h + 1 ) * W + ( w + 1 ) <NEWLINE> ans += dp [ v ] - 1 <NEWLINE> filled [ v ] = 0 <NEWLINE> k = min ( dp [ v - 1 ] , dp [ v + 1 ] , dp [ v - W ] , dp [ v + W ] ) <NEWLINE> if dp [ v ] == k : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> p = 0 <NEWLINE> stack [ 0 ] = v <NEWLINE> dp [ v ] = k <NEWLINE> while p >= 0 : <NEWLINE> <INDENT> v = stack [ p ] <NEWLINE> p -= 1 <NEWLINE> for dx in ( - 1 , 1 , - W , W ) : <NEWLINE> <INDENT> w = v + dx <NEWLINE> k = dp [ v ] + filled [ w ] <NEWLINE> if dp [ w ] > k : <NEWLINE> <INDENT> dp [ w ] = k <NEWLINE> p += 1 <NEWLINE> stack [ p ] = w <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> P = np . array ( input ( ) . split ( ) , np . int32 ) <NEWLINE> <NL> print ( solve ( N , P ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> class nCr ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . fa = [ 1 ] * ( self . n + 1 ) <NEWLINE> self . fi = [ 1 ] * ( self . n + 1 ) <NEWLINE> for i in range ( 1 , self . n + 1 ) : <NEWLINE> <INDENT> self . fa [ i ] = self . fa [ i - 1 ] * i % mod <NEWLINE> self . fi [ i ] = pow ( self . fa [ i ] , mod - 2 , mod ) <NEWLINE> <DEDENT> <DEDENT> def comb ( self , n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> if n < 0 or r < 0 : return 0 <NEWLINE> return self . fa [ n ] * self . fi [ r ] % mod * self . fi [ n - r ] % mod <NEWLINE> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> c = nCr ( n * m ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += i * ( n - i ) * m * m <NEWLINE> ans %= mod <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ans += i * ( m - i ) * n * n <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans * c . comb ( n * m - 2 , k - 2 ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 1 <NEWLINE> k = 7 <NEWLINE> while 1 : <NEWLINE> <INDENT> if k % n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if c > n : <NEWLINE> <INDENT> c = - 1 <NEWLINE> break <NEWLINE> <DEDENT> k = ( k % n ) * 10 + 7 <NEWLINE> c += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import sys <NEWLINE> <NL> ans = 0 <NEWLINE> if a != 0 and a >= k : <NEWLINE> <COMMENT> <NL> <INDENT> print ( k ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif a != 0 : <NEWLINE> <INDENT> ans += a <NEWLINE> k -= a <NEWLINE> <NL> <DEDENT> if b != 0 and b >= k : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif b != 0 : <NEWLINE> <INDENT> k -= b <NEWLINE> <NL> <DEDENT> ans += k * - 1 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> num = k + 2 <NEWLINE> lst = [ ( [ None ] * num ) for i in range ( num ) ] <NEWLINE> <COMMENT> <NL> for i in range ( num ) : <NEWLINE> <INDENT> for j in range ( num ) : <NEWLINE> <INDENT> lst [ i ] [ j ] = gcd ( i + 1 , j + 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> NUM = lst [ a - 1 ] [ b - 1 ] <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += lst [ NUM - 1 ] [ c - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> new_a = np . zeros ( n + 1 , dtype = int ) <NEWLINE> np . add . at ( new_a , np . maximum ( 0 , np . arange ( 0 , n ) - a ) , 1 ) <NEWLINE> np . add . at ( new_a , np . minimum ( n , np . arange ( 0 , n ) + a + 1 ) , - 1 ) <NEWLINE> a = new_a . cumsum ( ) [ : - 1 ] <NEWLINE> if np . all ( a == n ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( x ) for x in a ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> coll = collections . Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> suma = sum ( a ) <NEWLINE> lis = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> lis [ i - 1 ] = coll [ i ] <COMMENT> <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sa = c - b <NEWLINE> lis [ c - 1 ] += lis [ b - 1 ] <NEWLINE> ans += sa * lis [ b - 1 ] <NEWLINE> lis [ b - 1 ] = 0 <NEWLINE> suma += ans <NEWLINE> print ( suma ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> def prod ( a ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> res = ( res * x ) % MOD <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def solve ( n , k , a ) : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> return max ( a ) <NEWLINE> <DEDENT> elif k == n : <NEWLINE> <INDENT> return prod ( a ) <NEWLINE> <DEDENT> elif ( max ( a ) < 0 ) and ( k % 2 == 1 ) : <NEWLINE> <INDENT> a = sorted ( a , reverse = True ) <NEWLINE> return prod ( a [ : k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = sorted ( a , key = lambda x : - abs ( x ) ) <NEWLINE> num_negative = len ( list ( filter ( lambda x : x < 0 , a [ : k ] ) ) ) <NEWLINE> if num_negative % 2 == 0 : <NEWLINE> <INDENT> return prod ( a [ : k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i1 , j1 = None , None <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if a [ i ] < 0 : <NEWLINE> <INDENT> i1 = i <NEWLINE> <DEDENT> <DEDENT> for j in range ( k , n ) : <NEWLINE> <INDENT> if a [ j ] >= 0 : <NEWLINE> <INDENT> j1 = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i2 , j2 = None , None <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if a [ i ] >= 0 : <NEWLINE> <INDENT> i2 = i <NEWLINE> <DEDENT> <DEDENT> for j in range ( k , n ) : <NEWLINE> <INDENT> if a [ j ] < 0 : <NEWLINE> <INDENT> j2 = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( ( i1 is None ) or ( j1 is None ) ) and ( ( i2 is None ) or ( j2 is None ) ) : <NEWLINE> <INDENT> return prod ( a [ : k ] ) <NEWLINE> <DEDENT> elif ( i1 is None ) or ( j1 is None ) : <NEWLINE> <INDENT> return prod ( a [ : i2 ] + a [ i2 + 1 : k ] + [ a [ j2 ] ] ) <NEWLINE> <DEDENT> elif ( i2 is None ) or ( j2 is None ) : <NEWLINE> <INDENT> return prod ( a [ : i1 ] + a [ i1 + 1 : k ] + [ a [ j1 ] ] ) <NEWLINE> <DEDENT> elif abs ( a [ j1 ] * a [ i2 ] ) > abs ( a [ i1 ] * a [ j2 ] ) : <NEWLINE> <INDENT> return prod ( a [ : i1 ] + a [ i1 + 1 : k ] + [ a [ j1 ] ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return prod ( a [ : i2 ] + a [ i2 + 1 : k ] + [ a [ j2 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( n , k , a ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , min ( b , a + k - 1 ) + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( b - k + 1 , a + k ) , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = np . zeros ( ( n , n ) , dtype = int ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ s - 1 ] [ t - 1 ] += 1 <NEWLINE> <DEDENT> lst = lst . cumsum ( axis = 1 ) [ : : - 1 ] . cumsum ( axis = 0 ) [ : : - 1 ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lst [ s - 1 ] [ t - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> S = 0 <NEWLINE> M = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> S += i <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> S -= i <NEWLINE> M += ( S * i ) % mod <NEWLINE> <DEDENT> print ( M % mod ) <NEWLINE>
class BellmanFord ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class Edge ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , _from , _to , _cost ) : <NEWLINE> <INDENT> self . from_ = _from <NEWLINE> self . to = _to <NEWLINE> self . cost = _cost <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . edges = [ ] <COMMENT> <NEWLINE> self . v_set = set ( ) <COMMENT> <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def E ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return len ( self . edges ) <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def V ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return len ( self . v_set ) <NEWLINE> <NL> <DEDENT> def add ( self , _from , _to , _cost ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . edges . append ( self . Edge ( _from , _to , _cost ) ) <NEWLINE> self . v_set . add ( _from ) <NEWLINE> self . v_set . add ( _to ) <NEWLINE> <NL> <DEDENT> def shortest_path ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d = [ float ( <STRING> ) ] * self . V <NEWLINE> d [ s ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> do_update = False <NEWLINE> for i in range ( self . E ) : <NEWLINE> <INDENT> e = self . edges [ i ] <NEWLINE> if d [ e . from_ ] != float ( <STRING> ) and d [ e . to ] > d [ e . from_ ] + e . cost : <NEWLINE> <INDENT> d [ e . to ] = d [ e . from_ ] + e . cost <NEWLINE> do_update = True <NEWLINE> <NL> <DEDENT> <DEDENT> if not do_update : break <NEWLINE> <NL> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def exist_negative_loop ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d = [ 0 ] * self . V <NEWLINE> for i in range ( self . V ) : <NEWLINE> <INDENT> for j in range ( self . E ) : <NEWLINE> <INDENT> e = self . edges [ j ] <NEWLINE> if d [ e . to ] > d [ e . from_ ] + e . cost : <NEWLINE> <INDENT> d [ e . to ] = d [ e . from_ ] + e . cost <NEWLINE> <COMMENT> <NL> if i == self . V - 1 : return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> V , E , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bf = BellmanFord ( ) <NEWLINE> if V == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if E == 0 : <NEWLINE> <INDENT> for i in range ( V - 1 ) : <NEWLINE> <INDENT> bf . add ( i , i + 1 , float ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( E ) : <NEWLINE> <INDENT> _from , to , cost = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bf . add ( _from , to , cost ) <NEWLINE> <NL> <DEDENT> for i in range ( V ) : <NEWLINE> <COMMENT> <NL> <INDENT> if not i in bf . v_set : <NEWLINE> <INDENT> bf . add ( i , 0 , float ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> d = bf . shortest_path ( s ) <NEWLINE> <NL> for i in range ( V ) : <NEWLINE> <INDENT> if i >= len ( d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> cost = d [ i ] <NEWLINE> if cost == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Authority = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> cards = list ( range ( 1 , n + 2 ) ) <NEWLINE> l_list = [ ] <NEWLINE> r_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l_list . append ( Authority [ i ] [ 0 ] ) <NEWLINE> r_list . append ( Authority [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( len ( cards [ max ( l_list ) : min ( r_list ) + 1 ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from math import isinf <NEWLINE> <NL> <NL> class Edge ( object ) : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . cost = float ( <STRING> ) <NEWLINE> self . source , self . target = None , None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def generate_edge_table ( _v_info ) : <NEWLINE> <INDENT> for index , each in enumerate ( _v_info ) : <NEWLINE> <INDENT> edge = init_edge_table [ index ] <NEWLINE> source , target , cost = map ( int , each ) <NEWLINE> edge . source = source <NEWLINE> edge . target = target <NEWLINE> edge . cost = cost <NEWLINE> <DEDENT> return init_edge_table <NEWLINE> <NL> <NL> <DEDENT> def bellman_ford ( ) : <NEWLINE> <INDENT> distance [ root ] = 0 <NEWLINE> <NL> for j in range ( vertices - 1 ) : <NEWLINE> <INDENT> for edge in edge_table : <NEWLINE> <INDENT> source , target , cost = edge . source , edge . target , edge . cost <NEWLINE> if distance [ source ] + cost < distance [ target ] : <NEWLINE> <INDENT> distance [ target ] = distance [ source ] + cost <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for edge in edge_table : <NEWLINE> <INDENT> source , target , cost = edge . source , edge . target , edge . cost <NEWLINE> if distance [ source ] + cost < distance [ target ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return list ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> return distance <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges , root = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <COMMENT> <NL> <NL> distance = [ float ( <STRING> ) ] * vertices <NEWLINE> init_edge_table = tuple ( Edge ( ) for _ in range ( edges ) ) <NEWLINE> <NL> edge_table = generate_edge_table ( v_info ) <NEWLINE> <NL> res = bellman_ford ( ) <NEWLINE> if res : <NEWLINE> <INDENT> print ( <STRING> . join ( ( <STRING> if isinf ( ele ) else str ( ele ) for ele in res ) ) ) <NEWLINE> <DEDENT> <DEDENT>
def dfs ( tiles , w , h , x , y ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> tiles [ y ] [ x ] = <STRING> <NEWLINE> for dx , dy in ( ( 0 , 1 ) , ( 0 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) ) : <NEWLINE> <INDENT> if 0 <= x + dx < w and 0 <= y + dy < h and tiles [ y + dy ] [ x + dx ] == <STRING> : <NEWLINE> <INDENT> cnt += dfs ( tiles , w , h , x + dx , y + dy ) <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> W , H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> tiles = [ [ c for c in input ( ) ] for h in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if <STRING> in tiles [ i ] : <NEWLINE> <INDENT> Y = i <NEWLINE> X = tiles [ i ] . index ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> answer = dfs ( tiles , W , H , X , Y ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import statistics <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) - i - 1 for i , a in enumerate ( input ( ) . split ( ) , 1 ) ] <NEWLINE> b = statistics . median_low ( A ) <NEWLINE> c = statistics . median_high ( A ) <NEWLINE> d = sum ( map ( lambda x : abs ( x - b ) , A ) ) <NEWLINE> e = sum ( map ( lambda x : abs ( x - c ) , A ) ) <NEWLINE> print ( min ( d , e ) ) <NEWLINE>
from math import * <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def get_matrix ( n ) : <NEWLINE> <INDENT> matrix = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> matrix . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> return matrix <NEWLINE> <NL> <DEDENT> A = get_matrix ( n ) <NEWLINE> B = get_matrix ( m ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> sum += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> if j == l - 1 : print ( sum ) <NEWLINE> else : print ( sum , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys , math <NEWLINE> import io , os <NEWLINE> <COMMENT> <NL> from bisect import bisect_left as bl , bisect_right as br , insort <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> from collections import defaultdict as dd , deque , Counter <NEWLINE> <COMMENT> <NL> def data ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def mdata ( ) : return list ( map ( int , data ( ) . split ( ) ) ) <NEWLINE> def outl ( var ) : sys . stdout . write ( <STRING> . join ( map ( str , var ) ) + <STRING> ) <NEWLINE> def out ( var ) : sys . stdout . write ( str ( var ) + <STRING> ) <NEWLINE> from decimal import Decimal <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> mod = 998244353 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> n , k = mdata ( ) <NEWLINE> set1 = set ( ) <NEWLINE> dp = [ 0 ] * ( n ) <NEWLINE> s = [ 0 ] * n <NEWLINE> lis = sorted ( [ mdata ( ) for i in range ( k ) ] , key = lambda x : x [ 0 ] ) <NEWLINE> for i , j in lis : <NEWLINE> <INDENT> for m in range ( i , j + 1 ) : <NEWLINE> <INDENT> set1 . add ( m ) <NEWLINE> <DEDENT> <DEDENT> m = lis [ 0 ] [ 0 ] <NEWLINE> for i in range ( m , n ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> if lis [ j ] [ 0 ] >= i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i ] += s [ i - lis [ j ] [ 0 ] ] - s [ i - min ( lis [ j ] [ 1 ] , i - 1 ) - 1 ] <NEWLINE> <DEDENT> if i in set1 : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> <DEDENT> dp [ i ] %= mod <NEWLINE> s [ i ] = dp [ i ] + s [ i - 1 ] <NEWLINE> <DEDENT> out ( dp [ - 1 ] ) <NEWLINE>
def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import deque <NEWLINE> def bfs ( field , s ) : <NEWLINE> <INDENT> q = deque ( [ ( 0 , s ) ] ) <NEWLINE> MOVE = [ ( - 1 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) ] <NEWLINE> dist = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> d , i , j = - 1 , - 1 , - 1 <NEWLINE> while q : <NEWLINE> <INDENT> d , ( i , j ) = q . popleft ( ) <NEWLINE> if dist [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] [ j ] = d <NEWLINE> for di , dj in MOVE : <NEWLINE> <INDENT> ni = i + di <NEWLINE> nj = j + dj <NEWLINE> if not 0 <= ni < H or not 0 <= nj < W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist [ ni ] [ nj ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( ( d + 1 , ( ni , nj ) ) ) <NEWLINE> <DEDENT> <DEDENT> return d , i , j <NEWLINE> <DEDENT> H , W = MI ( ) <NEWLINE> field = [ input ( ) for _ in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> d , i , j = bfs ( field , ( i , j ) ) <NEWLINE> ans = max ( ans , d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> l = sorted ( l ) <NEWLINE> new_list = [ ] <NEWLINE> new_list . append ( l [ 0 ] ) <NEWLINE> for i in range ( 1 , len ( l ) ) : <NEWLINE> <INDENT> if l [ i - 1 ] != l [ i ] : <NEWLINE> <INDENT> new_list . append ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( new_list ) ) <NEWLINE> <NL>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( g , k ) <NEWLINE> total += a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> C = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( 0 , l ) : <NEWLINE> <INDENT> for k in range ( 0 , m ) : <NEWLINE> <INDENT> C [ i ] [ j ] = C [ i ] [ j ] + A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> print ( * C [ i ] ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> limit = 10 ** 18 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] = min ( a [ i ] * a [ i - 1 ] , limit + 1 ) <NEWLINE> <NL> <DEDENT> print ( a [ - 1 ] if a [ - 1 ] <= limit else - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C *= A [ i ] <NEWLINE> if C > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif A [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if C <= 10 ** 18 : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> S = sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> N = 2019 <NEWLINE> L = len ( S ) <NEWLINE> curr = 0 <NEWLINE> seen = { } <NEWLINE> INV = 210 <NEWLINE> seen [ curr ] = 1 <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> curr = ( curr * 10 + int ( S [ i ] ) ) % N <NEWLINE> t = ( curr * pow ( 10 , L - i , N ) ) % N <NEWLINE> if t not in seen : seen [ t ] = 0 <NEWLINE> seen [ t ] += 1 <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i not in seen : continue <NEWLINE> t = seen [ i ] <NEWLINE> res += t * ( t - 1 ) // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
s = [ int ( x ) for x in list ( input ( ) ) ] <NEWLINE> x = s . count ( 0 ) <NEWLINE> print ( min ( x , len ( s ) - x ) * 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> while n > 1000 : <NEWLINE> <INDENT> n -= 1000 <NEWLINE> <DEDENT> print ( 1000 - n ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = dict ( ) <NEWLINE> for v in l : <NEWLINE> <INDENT> if v in d : <NEWLINE> <INDENT> d [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> if k <= v : <NEWLINE> <INDENT> c += v - k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += v <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <COMMENT> <NEWLINE> <NL> good = [ True ] * N <NEWLINE> for i , j in A : <NEWLINE> <INDENT> i -= 1 <NEWLINE> j -= 1 <NEWLINE> if H [ i ] < H [ j ] : <NEWLINE> <INDENT> good [ i ] = False <NEWLINE> <DEDENT> if H [ i ] > H [ j ] : <NEWLINE> <INDENT> good [ j ] = False <NEWLINE> <DEDENT> if H [ i ] == H [ j ] : <NEWLINE> <INDENT> good [ i ] = False <NEWLINE> good [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( good . count ( True ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( v ) for v in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> sum_A = sum ( A ) <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum_A -= A [ i ] <NEWLINE> total += A [ i ] * sum_A <NEWLINE> <NL> <DEDENT> print ( total % ( 10 ** 9 + 7 ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> L = S // 3 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> def cmb ( n , r ) : <NEWLINE> <INDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : return 1 <NEWLINE> over = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return over // under <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> <NL> for l in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> s = S - l * 3 <NEWLINE> a = cmb ( s + l - 1 , l - 1 ) <NEWLINE> res += a <NEWLINE> <NL> <DEDENT> print ( int ( res % mod ) ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2020 <NEWLINE> <NL> for i in range ( L , min ( L + 2019 , R ) ) : <NEWLINE> <INDENT> for j in range ( L + 1 , min ( L + 2019 , R ) + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M_DICT = { } <NEWLINE> <NL> <NL> def make_m ( i , m ) : <NEWLINE> <INDENT> if ( i , m ) in M_DICT : <NEWLINE> <INDENT> return M_DICT [ ( i , m ) ] <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= N or m < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> res = make_m ( i + 1 , m ) or make_m ( i + 1 , m - A [ i ] ) <NEWLINE> M_DICT [ ( i , m ) ] = res <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> q = int ( input ( ) ) <NEWLINE> m_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> if make_m ( 0 , m_lst [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a , b , n = LI ( ) <NEWLINE> x = min ( n , b - 1 ) <NEWLINE> return math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> num = [ True for i in range ( a [ - 1 ] + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if num [ a [ i ] ] : <NEWLINE> <INDENT> for j in range ( a [ - 1 ] // a [ i ] + 1 ) : <NEWLINE> <INDENT> if j < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num [ a [ i ] * j ] = False <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> num [ a [ i ] ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if num [ a [ i ] ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( i , j ) <NEWLINE> if g == 1 : <NEWLINE> <INDENT> ans += K <NEWLINE> continue <NEWLINE> <DEDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( g , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def abc173_b ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> l = [ 0 for i in range ( 4 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Inp = input ( ) <NEWLINE> if Inp == <STRING> : <NEWLINE> <INDENT> l [ 0 ] += 1 <NEWLINE> <DEDENT> if Inp == <STRING> : <NEWLINE> <INDENT> l [ 1 ] += 1 <NEWLINE> <DEDENT> if Inp == <STRING> : <NEWLINE> <INDENT> l [ 2 ] += 1 <NEWLINE> <DEDENT> if Inp == <STRING> : <NEWLINE> <INDENT> l [ 3 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( l [ 0 ] ) ) <NEWLINE> print ( <STRING> + str ( l [ 1 ] ) ) <NEWLINE> print ( <STRING> + str ( l [ 2 ] ) ) <NEWLINE> print ( <STRING> + str ( l [ 3 ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> abc173_b ( ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> K = 10 ** 9 <NEWLINE> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> S = i * 2 * C + max ( 0 , X - i ) * A + max ( 0 , Y - i ) * B <NEWLINE> K = min ( K , S ) <NEWLINE> <DEDENT> print ( K ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> counter = [ 0 ] * 2019 <NEWLINE> k = 10 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> sub = 0 <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> sub = int ( S [ N - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sub += int ( S [ N - i ] ) * k <NEWLINE> k *= 10 <NEWLINE> k %= 2019 <NEWLINE> <DEDENT> rest = sub % 2019 <NEWLINE> counter [ rest ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for r in counter : <NEWLINE> <INDENT> ans += r * ( r - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from math import gcd <NEWLINE> <NL> L = [ 0 ] * n <NEWLINE> R = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> L [ i + 1 ] = gcd ( L [ i ] , A [ i ] ) <NEWLINE> <DEDENT> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> R [ i - 1 ] = gcd ( R [ i ] , A [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , gcd ( L [ i ] , R [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b = list ( input ( ) ) <NEWLINE> b . sort ( ) <NEWLINE> b = str ( b ) <NEWLINE> s . append ( b ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( s ) <NEWLINE> <NL> for i in c . values ( ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> a += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> acum1 = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acum1 . append ( acum1 [ - 1 ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> acum2 = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> acum2 . append ( acum2 [ - 1 ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acum1 [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while acum2 [ j ] > k - acum1 [ i ] and j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> <NL> count = R * G * B <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> count = count - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ K + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
ans = 1 <NEWLINE> n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mul = int ( nums [ i ] ) <NEWLINE> if mul == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> mul = int ( nums [ i ] ) <NEWLINE> ans = ans * mul <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> exit ( ) <NEWLINE>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cb = - ( - c // b ) <NEWLINE> ad = - ( - a // d ) <NEWLINE> if ad < cb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = n % 9 <NEWLINE> <NL> if result == 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if flg [ x ] : <NEWLINE> <INDENT> flg [ x ] = 0 <NEWLINE> p = 0 <NEWLINE> for y in glaph [ x ] : <NEWLINE> <INDENT> p = max ( p , f ( y ) + 1 ) <NEWLINE> <DEDENT> dp [ x ] = p <NEWLINE> <DEDENT> return dp [ x ] <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> flg = [ 1 ] * ( n + 1 ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> glaph = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> glaph [ x ] . append ( y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , f ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( 0 in lst ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> product = 1 <NEWLINE> for i in lst : <NEWLINE> <INDENT> product *= i <NEWLINE> <NL> if ( product > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> def solve0 ( N , M , edges ) : <NEWLINE> <INDENT> path = edges . copy ( ) <NEWLINE> exists = 1 <NEWLINE> for i in range ( 2 , M + 1 ) : <NEWLINE> <INDENT> next_path = defaultdict ( set ) <NEWLINE> for v1 in path : <NEWLINE> <INDENT> for v2 in path [ v1 ] : <NEWLINE> <INDENT> if edges [ v2 ] : <NEWLINE> <INDENT> next_path [ v1 ] . update ( edges [ v2 ] ) <NEWLINE> exists = i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if exists != i : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> path = next_path <NEWLINE> <DEDENT> return exists <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , M , edges ) : <NEWLINE> <INDENT> longest = { } <NEWLINE> <NL> def get_longest ( start ) : <NEWLINE> <INDENT> if longest . get ( start ) != None : <NEWLINE> <INDENT> return longest [ start ] <NEWLINE> <NL> <DEDENT> next_edges = edges . get ( start ) <NEWLINE> if not next_edges : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = max ( get_longest ( v ) for v in edges [ start ] ) + 1 <NEWLINE> <DEDENT> longest [ start ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> return max ( get_longest ( v ) for v in edges ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , M , edges ) : <NEWLINE> <INDENT> import numba <NEWLINE> longest = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> def intlist ( xs ) : <NEWLINE> <INDENT> if xs : <NEWLINE> <INDENT> return list ( xs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return numba . typed . List ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> edges = [ intlist ( edges [ k ] ) for k in range ( N + 1 ) ] <NEWLINE> @ numba . njit <NEWLINE> def get_longest ( start , edges ) : <NEWLINE> <INDENT> if longest [ start ] != - 1 : <NEWLINE> <INDENT> return longest [ start ] <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for v in edges [ start ] : <NEWLINE> <INDENT> x = get_longest ( v , edges ) + 1 <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> longest [ start ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for v in range ( N + 1 ) : <NEWLINE> <INDENT> x = get_longest ( v , edges ) <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , M , edges ) : <NEWLINE> <INDENT> longest = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if not edges [ i ] : <NEWLINE> <INDENT> longest [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def get_longest ( start ) : <NEWLINE> <INDENT> next = edges [ start ] <NEWLINE> for v in next : <NEWLINE> <INDENT> if longest [ v ] == - 1 : <NEWLINE> <INDENT> longest [ v ] = get_longest ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> ret = max ( longest [ v ] for v in next ) + 1 <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if longest [ i ] == - 1 : <NEWLINE> <INDENT> longest [ i ] = get_longest ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return max ( longest [ v ] for v in edges ) <NEWLINE> <NL> <NL> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = defaultdict ( set ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> v1 , v2 = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ v1 ] . add ( v2 ) <NEWLINE> <NL> <DEDENT> print ( solve ( N , M , edges ) ) <NEWLINE> <NL> <NL> <DEDENT> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = 0 <NEWLINE> <NL> for i in n : <NEWLINE> <INDENT> a += int ( i ) <NEWLINE> <NL> <DEDENT> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> Ans = 0 <NEWLINE> numlist = [ 0 ] * 10001 <NEWLINE> <NL> if int ( float ( N ) ** 0.5 ) <= 1 : <NEWLINE> <INDENT> rMax = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rMax = int ( float ( N ) ** 0.5 ) <NEWLINE> <NL> <DEDENT> for x in range ( 1 , rMax + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , rMax + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , rMax + 1 ) : <NEWLINE> <INDENT> Ans = x ** 2 + y ** 2 + z ** 2 + ( x * y ) + ( y * z ) + ( z * x ) <NEWLINE> if Ans <= 10000 : <NEWLINE> <INDENT> numlist [ Ans ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for r in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( numlist [ r ] ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = [ a , b ] <NEWLINE> c . sort ( ) <NEWLINE> print ( * c , sep = <STRING> ) <NEWLINE> <DEDENT>
a , b = open ( 0 ) ; c = 1 ; <NEWLINE> for i in sorted ( b . split ( ) ) : c = [ - 1 , d : = int ( i ) * c ] [ - 1 < d <= 10 ** 18 ] <NEWLINE> print ( c ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = [ ( A [ i ] , 1 ) for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> B , C = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D . append ( ( C , B ) ) <NEWLINE> <NL> <DEDENT> D . sort ( ) <NEWLINE> D . reverse ( ) <NEWLINE> <NL> ans , left = 0 , N <NEWLINE> for ( i , j ) in D : <NEWLINE> <INDENT> use = min ( j , left ) <NEWLINE> ans += use * i <NEWLINE> left -= use <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> cnt_ac = 0 <NEWLINE> cnt_wa = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> if p not in d : <NEWLINE> <INDENT> d [ p ] = [ s ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ p ] . append ( s ) <NEWLINE> <DEDENT> <DEDENT> for i in d : <NEWLINE> <INDENT> if <STRING> in d [ i ] : <NEWLINE> <INDENT> cnt_ac += 1 <NEWLINE> cnt_wa += d [ i ] . index ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt_ac , cnt_wa ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> def test_case ( k ) : <NEWLINE> <INDENT> ans , cnt = 7 , 1 <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> if k == 1 or k == 7 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> ans = ( ans * 10 + 7 ) % k <NEWLINE> cnt += 1 <NEWLINE> <NL> if ans == 0 : <NEWLINE> <INDENT> return cnt <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( test_case ( k ) ) <NEWLINE> <NL>
K = int ( input ( ) ) <NEWLINE> <NL> GCD = [ [ 0 ] * 200 for i in range ( 200 ) ] <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> if GCD [ x - 1 ] [ y - 1 ] == 0 : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return GCD [ x - 1 ] [ y - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> tot = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s = gcd ( i , j ) <NEWLINE> if s != 1 : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = gcd ( k , s ) <NEWLINE> tot += t <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tot += K <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 9 ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <NL> if S % i == 0 and S // i <= 9 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> s = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> s ^= ai <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans . append ( s ^ ai ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL>
from collections import deque <NEWLINE> <NL> R = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n , m = R ( ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = R ( ) <NEWLINE> g [ u - 1 ] . append ( v - 1 ) <NEWLINE> g [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> r = [ None ] * ( n - 1 ) <NEWLINE> V = [ True ] + [ False ] * ( n - 1 ) <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> for v in g [ u ] : <NEWLINE> <INDENT> if not V [ v ] : <NEWLINE> <INDENT> V [ v ] = True <NEWLINE> r [ v - 1 ] = u + 1 <NEWLINE> q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ( [ <STRING> ] , [ <STRING> ] + r ) [ all ( r ) ] , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> def isort ( A , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def ssort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = [ ] <NEWLINE> h = 1 <NEWLINE> while h <= n : <NEWLINE> <INDENT> G . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> m = len ( G ) <NEWLINE> G . reverse ( ) <NEWLINE> print ( m ) <NEWLINE> print ( * G , sep = <STRING> ) <NEWLINE> for g in G : <NEWLINE> <INDENT> cnt += isort ( A , n , g ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readlines ( ) ) ) <NEWLINE> cnt = ssort ( A , n ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> zero = False <NEWLINE> fl = False <NEWLINE> x = 1 <NEWLINE> for i in lst : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> zero = True <NEWLINE> break <NEWLINE> <DEDENT> if not fl : <NEWLINE> <INDENT> x *= i <NEWLINE> <DEDENT> if ( x > 1e18 ) : <NEWLINE> <INDENT> fl = True <NEWLINE> <DEDENT> <DEDENT> if zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif fl : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> idx1 = s . find ( str ( i ) ) <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> idx2 = s . find ( str ( j ) , idx1 + 1 , n ) <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> idx3 = s . find ( str ( k ) , idx2 + 1 , n ) <NEWLINE> if idx1 == - 1 or idx2 == - 1 or idx3 == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> MOD = 1000000007 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> d = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g = math . gcd ( a , b ) <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> if a == 0 and b < 0 : <NEWLINE> <INDENT> b *= - 1 <NEWLINE> <DEDENT> if g != 0 : <NEWLINE> <INDENT> a = a // g <NEWLINE> b = b // g <NEWLINE> <DEDENT> if ( a , b ) in d : <NEWLINE> <INDENT> d [ ( a , b ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( a , b ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans_sp = 0 <NEWLINE> if ( 0 , 0 ) in d : <NEWLINE> <INDENT> ans_sp += d [ ( 0 , 0 ) ] <NEWLINE> <NL> <DEDENT> def pow ( n , k ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ret = ret * n % MOD <NEWLINE> <DEDENT> n = n * n % MOD <NEWLINE> k = k // 2 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for k in d : <NEWLINE> <INDENT> a , b = k [ 0 ] , k [ 1 ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = d [ k ] <NEWLINE> x , y = b , - a <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> y *= - 1 <NEWLINE> <DEDENT> if x == 0 and y < 0 : <NEWLINE> <INDENT> y *= - 1 <NEWLINE> <DEDENT> if y == 0 and x < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> <DEDENT> if ( x , y ) in d : <NEWLINE> <INDENT> if b > y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tmp = ( pow ( 2 , v ) + pow ( 2 , d [ ( x , y ) ] ) - 1 ) % MOD <NEWLINE> ans = ( ans * tmp ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * pow ( 2 , v ) ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( ( ans_sp + ans - 1 ) % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> steps = [ ] <NEWLINE> <NL> for x in range ( int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> if n % ( x + 1 ) == 0 : <NEWLINE> <INDENT> steps . append ( x + n // ( x + 1 ) - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( steps ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( i + N + 1 ) // 2 ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if len ( set ( [ S [ i ] , S [ j ] , S [ k ] ] ) ) == 3 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - c ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * math . pi ) ) <NEWLINE> print ( <STRING> . format ( 2 * r * math . pi ) ) <NEWLINE> <NL>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = sorted ( n ) <NEWLINE> for i , n in enumerate ( n ) : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ps = [ 0 ] + list ( filter ( lambda x : x >= 0 , X ) ) <NEWLINE> ns = [ 0 ] + list ( sorted ( filter ( lambda x : x < 0 , X ) , reverse = True ) ) <NEWLINE> <NL> ans = INF <NEWLINE> for i in range ( len ( ns ) ) : <NEWLINE> <INDENT> val = abs ( ns [ i ] ) * 2 <NEWLINE> if K - i >= 0 and K - i < len ( ps ) : <NEWLINE> <INDENT> val += abs ( ps [ K - i ] ) <NEWLINE> ans = min ( ans , val ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( ps ) ) : <NEWLINE> <INDENT> val = abs ( ps [ i ] ) * 2 <NEWLINE> if K - i >= 0 and K - i < len ( ns ) : <NEWLINE> <INDENT> val += abs ( ns [ K - i ] ) <NEWLINE> ans = min ( ans , val ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; z = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i > 1e18 // z : z = - 1 ; break <NEWLINE> z *= i <NEWLINE> <DEDENT> print ( 0 if 0 in a else z ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans == 0 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = n // i <NEWLINE> b = n % i <NEWLINE> if b == 0 : <NEWLINE> <INDENT> count += a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += a <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = 1 << 10 ) <NEWLINE> def solve ( p , q , a , n ) : <NEWLINE> <INDENT> def _solve ( num , dem , d , m , s ) : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if d == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if num * a // m < dem : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return sum ( ( _solve ( num * i - dem , dem * i , d - 1 , m * i , i ) <NEWLINE> <INDENT> for i in range ( s , min ( dem * n // num , a // m ) + 1 ) ) , 0 ) <NEWLINE> <DEDENT> <DEDENT> return _solve ( p , q , n , 1 , 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> p , q , a , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( solve ( p , q , a , n ) ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <COMMENT> <NL> n , m , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> b = [ 0 ] + b <NEWLINE> acc = list ( itertools . accumulate ( a ) ) <NEWLINE> bcc = list ( itertools . accumulate ( b ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> j = m <NEWLINE> for i , val in enumerate ( acc ) : <NEWLINE> <INDENT> if ( val > k ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = k - val <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while ( bcc [ j ] > rest ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , j + i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] <NEWLINE> def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] <NEWLINE> def Yes ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> def YES ( ) : print ( <STRING> ) <NEWLINE> def NO ( ) : print ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 19 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> EPS = 10 ** - 10 <NEWLINE> <NL> N , K = MAP ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> A1 = [ ] <NEWLINE> A2 = [ ] <NEWLINE> zero = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> A1 . append ( a ) <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> A2 . append ( - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> B1 = np . log ( np . array ( A1 , dtype = np . longdouble ) ) <NEWLINE> B2 = np . log ( np . array ( A2 , dtype = np . longdouble ) ) <NEWLINE> A1 . sort ( ) <NEWLINE> A2 . sort ( ) <NEWLINE> B1 . sort ( ) <NEWLINE> B2 . sort ( ) <NEWLINE> acc1 = np . insert ( B1 . cumsum ( ) , 0 , 0 ) <NEWLINE> accrev1 = np . insert ( B1 [ : : - 1 ] . cumsum ( ) , 0 , 0 ) <NEWLINE> acc2 = np . insert ( B2 . cumsum ( ) , 0 , 0 ) <NEWLINE> accrev2 = np . insert ( B2 [ : : - 1 ] . cumsum ( ) , 0 , 0 ) <NEWLINE> mx = - np . inf <NEWLINE> mn = np . inf <NEWLINE> idx1 = ( - 1 , - 1 ) <NEWLINE> idx2 = ( - 1 , - 1 ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> j = K - i <NEWLINE> if len ( B1 ) < i or len ( B2 ) < j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j % 2 == 0 : <NEWLINE> <INDENT> sm = accrev1 [ i ] + accrev2 [ j ] <NEWLINE> if sm > mx : <NEWLINE> <INDENT> mx = sm <NEWLINE> idx1 = ( i , j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sm = acc1 [ i ] + acc2 [ j ] <NEWLINE> if sm < mn : <NEWLINE> <INDENT> mn = sm <NEWLINE> idx2 = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if mx != - np . inf : <NEWLINE> <INDENT> ans = 1 <NEWLINE> n , m = idx1 <NEWLINE> A1 . reverse ( ) <NEWLINE> A2 . reverse ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A1 [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ans *= - A2 [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> elif zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> n , m = idx2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A1 [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ans *= - A2 [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = input ( ) <NEWLINE> <DEDENT> c = Counter ( s ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
command_num = int ( input ( ) ) <NEWLINE> dict = set ( [ ] ) <NEWLINE> <NL> for i in range ( command_num ) : <NEWLINE> <INDENT> in_command , in_str = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> <NL> if in_command == <STRING> : <NEWLINE> <INDENT> dict . add ( in_str ) <NEWLINE> <DEDENT> elif in_command == <STRING> : <NEWLINE> <INDENT> if in_str in dict : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> cnt = X . count ( <STRING> ) <NEWLINE> Y , Z = 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if cnt > 1 : <NEWLINE> <INDENT> Y = ( Y + int ( X [ i ] ) * pow ( 2 , N - i - 1 , cnt - 1 ) ) % ( cnt - 1 ) <NEWLINE> <DEDENT> Z = ( Z + int ( X [ i ] ) * pow ( 2 , N - i - 1 , cnt + 1 ) ) % ( cnt + 1 ) <NEWLINE> <NL> <DEDENT> def popcount ( n ) : <NEWLINE> <INDENT> c = bin ( n ) . count ( <STRING> ) <NEWLINE> return c <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> pc = cnt - 1 <NEWLINE> if pc <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y_i = ( Y - pow ( 2 , N - i - 1 , cnt - 1 ) ) % ( cnt - 1 ) <NEWLINE> ans = 1 <NEWLINE> while Y_i > 0 : <NEWLINE> <INDENT> Y_i = Y_i % popcount ( Y_i ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Z_i = ( Z + pow ( 2 , N - i - 1 , cnt + 1 ) ) % ( cnt + 1 ) <NEWLINE> ans = 1 <NEWLINE> while Z_i > 0 : <NEWLINE> <INDENT> Z_i = Z_i % popcount ( Z_i ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ARR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N - 1 ) ] <NEWLINE> <NL> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> BRR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> <NL> <NL> def prepare ( arr , n ) : <NEWLINE> <INDENT> links = [ [ ] for i in range ( n ) ] <NEWLINE> depth = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> startNode = arr [ i ] [ 0 ] - 1 <NEWLINE> endNode = arr [ i ] [ 1 ] - 1 <NEWLINE> dist = arr [ i ] [ 2 ] <NEWLINE> <NL> links [ startNode ] . append ( ( endNode , dist ) ) <NEWLINE> links [ endNode ] . append ( ( startNode , dist ) ) <NEWLINE> <NL> <DEDENT> return links , depth <NEWLINE> <NL> <NL> <DEDENT> def dfs ( currentNode , parrentNode = - 1 , dist = 0 ) : <NEWLINE> <INDENT> childNodes = links [ currentNode ] <NEWLINE> depths [ currentNode ] = dist <NEWLINE> for ( childNode , childDistance ) in childNodes : <NEWLINE> <INDENT> if childNode == parrentNode : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dfs ( childNode , currentNode , dist + childDistance ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> links , depths = prepare ( ARR , N ) <NEWLINE> <NL> dfs ( K - 1 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> p1 = BRR [ i ] [ 0 ] - 1 <NEWLINE> p2 = BRR [ i ] [ 1 ] - 1 <NEWLINE> <NL> d1 = depths [ p1 ] <NEWLINE> d2 = depths [ p2 ] <NEWLINE> <NL> print ( d1 + d2 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> Cs = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Ss = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ss . append ( s ) <NEWLINE> <NL> <DEDENT> Ss = np . array ( Ss ) <NEWLINE> <NL> <NL> def scoring ( solution ) : <NEWLINE> <INDENT> sat = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> assert 1 <= solution [ d ] <= 26 <NEWLINE> j = solution [ d ] - 1 <NEWLINE> last [ j ] = d + 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> sat -= ( d + 1 - last [ i ] ) * Cs [ i ] <NEWLINE> <DEDENT> sat += Ss [ d ] [ j ] <NEWLINE> <DEDENT> return sat <NEWLINE> <NL> <NL> <DEDENT> def update_days_till_next ( days_till_next , solution , d , erase = False ) : <NEWLINE> <INDENT> contest = solution [ d ] <NEWLINE> delta = days_till_next [ d + 1 , contest ] + 1 if d < D - 1 else 0 <NEWLINE> days_till_next [ d , contest ] = delta <NEWLINE> for _d in range ( d - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if solution [ _d ] == contest or _d == 0 : <NEWLINE> <INDENT> days_till_next [ _d : d , contest ] = ( d - _d ) - np . arange ( d - _d ) + ( delta if erase else 0 ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def get_solution ( seed ) : <NEWLINE> <INDENT> solution = np . array ( seed ) <NEWLINE> days_till_next = np . ones_like ( Ss ) * ( D - 1 ) - np . arange ( D ) . reshape ( ( D , 1 ) ) <NEWLINE> for d in range ( D - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> update_days_till_next ( days_till_next , solution , d ) <NEWLINE> <NL> <DEDENT> for _ in range ( 80 ) : <NEWLINE> <INDENT> n_contests = len ( Ss [ 0 ] ) <NEWLINE> days_since_last = np . zeros ( n_contests ) <NEWLINE> for d , i in enumerate ( solution ) : <NEWLINE> <INDENT> days_since_last += 1 <NEWLINE> new_scores = days_till_next [ d ] * days_since_last * Cs + Ss [ d ] <NEWLINE> new_i = new_scores . argmax ( ) <NEWLINE> days_since_last [ new_i ] = 0 <NEWLINE> if new_i != i : <NEWLINE> <INDENT> update_days_till_next ( days_till_next , solution , d , erase = True ) <NEWLINE> solution [ d ] = new_i <NEWLINE> update_days_till_next ( days_till_next , solution , d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return solution <NEWLINE> <NL> <NL> <DEDENT> def get_best_solution ( ) : <NEWLINE> <INDENT> seeds = [ np . argmax ( Ss + Cs . reshape ( 1 , - 1 ) * e , axis = 1 ) for e in [ 10 , 20 , 40 , 80 ] ] + [ np . argmax ( Ss , axis = 1 ) ] <NEWLINE> best_sol = None <NEWLINE> best_score = - np . inf <NEWLINE> for seed in seeds : <NEWLINE> <INDENT> sol = get_solution ( seed ) + 1 <NEWLINE> score = scoring ( sol ) <NEWLINE> if score > best_score : <NEWLINE> <INDENT> best_sol = sol <NEWLINE> <NL> <DEDENT> <DEDENT> return best_sol <NEWLINE> <NL> <NL> <DEDENT> solution = get_best_solution ( ) <NEWLINE> <NL> <NL> for s in solution : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def cal ( x ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for aa in a : <NEWLINE> <INDENT> s += math . ceil ( aa / x ) - 1 <NEWLINE> <DEDENT> if s <= K : return True <NEWLINE> else : return False <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> r = max ( a ) <NEWLINE> while abs ( r - l ) > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if cal ( mid ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sec = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> sec . append ( [ l , r ] ) <NEWLINE> <NL> <DEDENT> mod = 998244353 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] , dp [ 1 ] = 0 , 1 <NEWLINE> cumsum = [ 0 ] * ( n + 1 ) <NEWLINE> cumsum [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for l , r in sec : <NEWLINE> <INDENT> if i > l : <NEWLINE> <INDENT> dp [ i ] += cumsum [ i - l ] - cumsum [ max ( 0 , i - r - 1 ) ] <NEWLINE> <DEDENT> <DEDENT> cumsum [ i ] = ( dp [ i ] + cumsum [ i - 1 ] ) % mod <NEWLINE> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
from collections import defaultdict , Counter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from sys import stdin <NEWLINE> <NL> d = dict ( ) <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if ( a , b ) in d : <NEWLINE> <INDENT> return d [ ( a , b ) ] <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = gcd ( b , a % b ) <NEWLINE> d [ ( a , b ) ] = res <NEWLINE> return res <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def gcd_3 ( a , b , c ) : <NEWLINE> <INDENT> return gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = gcd ( a , b ) <NEWLINE> if m == 1 : <NEWLINE> <INDENT> res += 1 * n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res += gcd ( m , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> def input ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> d = [ [ a [ i ] [ 0 ] - a [ i ] [ 1 ] , a [ i ] [ 0 ] + a [ i ] [ 1 ] ] for i in range ( n ) ] <NEWLINE> <NL> d = sorted ( d , key = lambda x : x [ 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> b = [ - 100000000000000000 ] <NEWLINE> c = [ 0 ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if d [ i ] [ 0 ] >= b [ j ] : <NEWLINE> <INDENT> b = [ d [ i ] [ 1 ] ] <NEWLINE> c = [ c [ j ] + 1 ] <NEWLINE> break <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( c ) ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> def NIJIGEN ( H ) : return [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> N , M = MAP ( ) <NEWLINE> H = LIST ( ) <NEWLINE> L = [ [ 0 ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = MAP ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> L [ a ] . append ( H [ b ] ) <NEWLINE> L [ b ] . append ( H [ a ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if max ( L [ i ] ) < H [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif K == 2 : <NEWLINE> <INDENT> ans = 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , j ) * 6 <NEWLINE> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> c = collections . Counter ( A ) <NEWLINE> sum = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if c [ l [ i ] [ 0 ] ] == 0 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += c [ l [ i ] [ 0 ] ] * ( l [ i ] [ 1 ] - l [ i ] [ 0 ] ) <NEWLINE> c [ l [ i ] [ 1 ] ] += c [ l [ i ] [ 0 ] ] <NEWLINE> del c [ l [ i ] [ 0 ] ] <NEWLINE> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def func ( x ) : return ( A * x ) // B - A * ( x // B ) <NEWLINE> <NL> ans = func ( min ( B - 1 , N ) ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> ang = 0 <NEWLINE> tan = 30 * h + 0.5 * m <NEWLINE> cho = 6 * m <NEWLINE> ang = abs ( cho - tan ) <NEWLINE> <COMMENT> <NL> <NL> ans = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( ang ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if ( ( i ** 5 ) - ( j ** 5 ) == X ) : <NEWLINE> <INDENT> ans . append ( ( str ( i ) + <STRING> + str ( j ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> S = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> S += B [ i ] * ( B [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> print ( S - B [ A [ k ] ] + 1 ) <NEWLINE> <DEDENT>
h , w , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> r = [ 0 ] * ( 3 * 10 ** 5 + 2 ) <NEWLINE> c = [ 0 ] * ( 3 * 10 ** 5 + 2 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r [ h ] = r [ h ] + 1 <NEWLINE> c [ w ] = c [ w ] + 1 <NEWLINE> b . append ( [ h , w ] ) <NEWLINE> <DEDENT> if max ( r ) > max ( c ) : <NEWLINE> <INDENT> j = r . index ( max ( r ) ) <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ i ] [ 0 ] == j : <NEWLINE> <INDENT> c [ b [ i ] [ 1 ] ] = c [ b [ i ] [ 1 ] ] - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = c . index ( max ( c ) ) <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ j ] [ 1 ] == i : <NEWLINE> <INDENT> r [ b [ j ] [ 0 ] ] = r [ b [ j ] [ 0 ] ] - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( r ) + max ( c ) ) <NEWLINE>
import sys <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> inf = 10 ** 9 + 1 <NEWLINE> <NL> def dfs ( v , prev = - 1 ) : <NEWLINE> <INDENT> x = As [ v ] <NEWLINE> if len ( LIS ) == 0 or x > LIS [ - 1 ] : <NEWLINE> <INDENT> old = inf <NEWLINE> i = len ( LIS ) <NEWLINE> LIS . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = bisect . bisect_left ( LIS , x ) <NEWLINE> old = LIS [ i ] <NEWLINE> LIS [ i ] = x <NEWLINE> <NL> <DEDENT> a = len ( LIS ) <NEWLINE> ans_array [ v ] = a <NEWLINE> for u in graph [ v ] : <NEWLINE> <INDENT> if u == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( u , v ) <NEWLINE> <DEDENT> if old == inf : <NEWLINE> <INDENT> LIS . pop ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LIS [ i ] = old <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> LIS = [ ] <NEWLINE> ans_array = [ 0 ] * N <NEWLINE> dfs ( 0 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans_array [ i ] ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> d = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> d [ i ] = d [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = d [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( d [ r - 1 ] - d [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> import collections <NEWLINE> list2 = collections . Counter ( list ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( list2 [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> fumidai = 0 <NEWLINE> great = A [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if great > A [ i ] : <NEWLINE> <INDENT> fumidai += great - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> great = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( fumidai ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( - 400 , 400 ) : <NEWLINE> <INDENT> for j in range ( - 400 , 400 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> exit <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( pow ( 10 , 6 ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Edges = list ( [ ] for _ in range ( N ) ) <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> Edges [ x - 1 ] . append ( y - 1 ) <NEWLINE> Edges [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( cur_node , parent_node ) : <NEWLINE> <INDENT> grundy = 0 <NEWLINE> for child_node in Edges [ cur_node ] : <NEWLINE> <INDENT> if child_node == parent_node : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> grundy ^= ( dfs ( child_node , cur_node ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> return grundy <NEWLINE> <NL> <DEDENT> G = dfs ( 0 , - 1 ) <NEWLINE> if G == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( <STRING> ) <NEWLINE> ans = l . copy ( ) <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> ans [ l [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> except TypeError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> num = [ 0 ] * ( 3 * 10 ** 5 ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> num [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( num [ i ] ) <NEWLINE> <DEDENT>
in_a = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> in_b = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> result = False <NEWLINE> <NL> p_a = in_a [ 0 ] <NEWLINE> p_b = in_b [ 0 ] <NEWLINE> m_a = in_a [ 1 ] <NEWLINE> m_b = in_b [ 1 ] <NEWLINE> end_p_a = m_a * t <NEWLINE> end_p_b = m_b * t <NEWLINE> <NL> diff_s = abs ( p_a - p_b ) <NEWLINE> <NL> if end_p_a - end_p_b >= diff_s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ set ( ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> id = int ( input ( ) ) - 1 <NEWLINE> a [ id ] . add ( i ) <NEWLINE> <NL> <DEDENT> step = - 1 <NEWLINE> <COMMENT> <NL> now = a [ 1 ] <NEWLINE> next = set ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if 0 in now : <NEWLINE> <INDENT> step = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> for j in now : <NEWLINE> <INDENT> next = next . union ( a [ j ] ) <NEWLINE> <DEDENT> now = next <NEWLINE> next = set ( ) <NEWLINE> <NL> <DEDENT> print ( step ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> b = 10 ** 18 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > b : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil <COMMENT> <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> <NL> def inp ( ) : return int ( input ( ) ) <COMMENT> <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> def check ( a , b , X ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> X = inp ( ) <NEWLINE> for A in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if check ( A , B , X ) : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> ANS = [ ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ a - 1 ] . append ( b - 1 ) <NEWLINE> E [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> INF = 2 * m <NEWLINE> <NL> dists = [ INF for i in range ( n ) ] <NEWLINE> <NL> def bfs ( cur , pre , dist ) : <NEWLINE> <INDENT> stack = deque ( [ [ cur , pre , dist ] ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> cur , pre , dist = stack . popleft ( ) <NEWLINE> if dist < dists [ cur ] : <NEWLINE> <INDENT> dists [ cur ] = dist <NEWLINE> for e in E [ cur ] : <NEWLINE> <INDENT> if e != pre : <NEWLINE> <INDENT> stack . append ( [ e , cur , dist + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> di = dists [ i ] <NEWLINE> for e in E [ i ] : <NEWLINE> <INDENT> if di - 1 == dists [ e ] : <NEWLINE> <INDENT> print ( e + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> alfabet = deque ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> reverse = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> operation_list = list ( input ( ) . split ( ) ) <NEWLINE> if int ( operation_list [ 0 ] ) == 1 : <NEWLINE> <INDENT> reverse += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( operation_list [ 1 ] ) == 2 and reverse % 2 == 0 : <NEWLINE> <INDENT> alfabet . append ( operation_list [ 2 ] ) <NEWLINE> <DEDENT> elif int ( operation_list [ 1 ] ) == 2 and reverse % 2 == 1 : <NEWLINE> <INDENT> alfabet . appendleft ( operation_list [ 2 ] ) <NEWLINE> <DEDENT> elif int ( operation_list [ 1 ] ) == 1 and reverse % 2 == 0 : <NEWLINE> <INDENT> alfabet . appendleft ( operation_list [ 2 ] ) <NEWLINE> <DEDENT> elif int ( operation_list [ 1 ] ) == 1 and reverse % 2 == 1 : <NEWLINE> <INDENT> alfabet . append ( operation_list [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if reverse % 2 != 0 : <NEWLINE> <INDENT> alfabet . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( alfabet ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from math import gcd <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] // gcd ( ans , a [ i ] ) <NEWLINE> <DEDENT> s = sum ( pow ( x , mod - 2 , mod ) for x in a ) <NEWLINE> print ( s * ans % mod ) <NEWLINE>
i = 0 <NEWLINE> j = int ( input ( ) ) <NEWLINE> numlist = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> while i < j - 1 : <NEWLINE> <INDENT> print ( numlist [ j - i - 1 ] , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( numlist [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ _ for _ in input ( ) ] <NEWLINE> <NL> l , r = 0 , n - 1 <NEWLINE> if not ( <STRING> in s ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if not ( <STRING> in s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> while s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> while s [ r ] == <STRING> and l != r : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <NL> <DEDENT> if l != r : <NEWLINE> <INDENT> s [ l ] , s [ r ] = s [ r ] , s [ l ] <NEWLINE> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if l == r : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> dif = 100 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( min ( p ) - 1 , max ( p ) + 2 ) : <NEWLINE> <INDENT> if not ( i in p ) : <NEWLINE> <INDENT> if dif > abs ( x - i ) : <NEWLINE> <INDENT> dif = abs ( x - i ) <NEWLINE> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( input ( ) ) <NEWLINE> <NL> count = x . count ( <STRING> ) <NEWLINE> one_count = count - 1 <NEWLINE> zero_count = count + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> for b in x : <NEWLINE> <INDENT> if one_count : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_count <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_count <NEWLINE> <NL> <DEDENT> f = [ 0 ] * 2000001 <NEWLINE> pop_count = [ 0 ] * 200001 <NEWLINE> for i in range ( 1 , 200001 ) : <NEWLINE> <INDENT> pop_count [ i ] = pop_count [ i // 2 ] + i % 2 <NEWLINE> f [ i ] = f [ i % pop_count [ i ] ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if one_count : <NEWLINE> <INDENT> nxt = one_mod <NEWLINE> nxt -= pow ( 2 , n - i - 1 , one_count ) <NEWLINE> nxt %= one_count <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> nxt = zero_mod <NEWLINE> nxt += pow ( 2 , n - i - 1 , zero_count ) <NEWLINE> nxt %= zero_count <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = np . array ( p ) <NEWLINE> p = np . sort ( p ) <NEWLINE> <NL> ans = p [ : K ] . sum ( ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ u ] . append ( v ) <NEWLINE> t [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> m = 10 ** 18 <NEWLINE> dp = [ m ] * ( n + 1 ) <NEWLINE> ans = [ 1 ] * ( n + 1 ) <NEWLINE> checked = [ False ] * ( n + 1 ) <NEWLINE> checked [ 1 ] = True <NEWLINE> changes = [ ] <NEWLINE> <NL> def search ( x ) : <NEWLINE> <INDENT> ind = bisect . bisect_left ( dp , a [ x ] ) <NEWLINE> changes . append ( ( ind , dp [ ind ] ) ) <NEWLINE> dp [ ind ] = a [ x ] <NEWLINE> ans [ x ] = bisect . bisect_left ( dp , m ) <NEWLINE> <NL> for i in t [ x ] : <NEWLINE> <INDENT> if not checked [ i ] : <NEWLINE> <INDENT> checked [ i ] = True <NEWLINE> search ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> b , c = changes . pop ( ) <NEWLINE> dp [ b ] = c <NEWLINE> <NL> <DEDENT> search ( 1 ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if c * 100 <= x <= c * 105 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if c * 100 > x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> * B , = map ( int , input ( ) . split ( ) ) <NEWLINE> * C , = map ( int , input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect_left ( A , b ) <NEWLINE> c = bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) . rstrip ( ) for _ in range ( N ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for i , op in enumerate ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> if A == B == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if A > B : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A == B and i < N - 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> and A == 1 : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> and B == 1 : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> if A == C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if A > C : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A == C and i < N - 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> and A == 1 : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> and C == 1 : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if B == C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if B > C : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B == C and i < N - 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> and B == 1 : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ i + 1 ] == <STRING> and C == 1 : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> gacha = collections . deque ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> gacha . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( collections . Counter ( gacha ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a_li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> a_li = [ a for a in a_li if a != 1 and a != 0 ] <NEWLINE> a_li . append ( 1 ) <NEWLINE> for a in a_li : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = k <NEWLINE> if k > a : <NEWLINE> <INDENT> sum = a <NEWLINE> if k - a <= b : <NEWLINE> <INDENT> sum = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 2 * a + b - k <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sX = input ( ) <NEWLINE> <NL> origin_count = sX . count ( <STRING> ) <NEWLINE> one_r_count = origin_count - 1 <NEWLINE> zero_r_count = origin_count + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> for b in sX : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_r_count <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_r_count <NEWLINE> <NL> <DEDENT> f = [ 0 ] * 220000 <NEWLINE> pop = [ 0 ] * 220000 <NEWLINE> <NL> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> pop [ i ] = pop [ i // 2 ] + i % 2 <NEWLINE> f [ i ] = f [ i % pop [ i ] ] + 1 <NEWLINE> <NL> <DEDENT> onepow = [ 1 ] * 220000 <NEWLINE> zeropow = [ 1 ] * 220000 <NEWLINE> <NL> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> onepow [ i ] = onepow [ i - 1 ] * 2 % one_r_count <NEWLINE> <DEDENT> zeropow [ i ] = zeropow [ i - 1 ] * 2 % zero_r_count <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if sX [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> Xi_n = one_mod - onepow [ N - i ] <NEWLINE> Xi_n %= one_r_count <NEWLINE> print ( f [ Xi_n ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if sX [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> Xi_n = zero_mod + zeropow [ N - i ] <NEWLINE> Xi_n %= zero_r_count <NEWLINE> print ( f [ Xi_n ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> <NL> count = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( int ( N / 2 ) ) : <NEWLINE> <INDENT> count += 2 * a [ i ] <NEWLINE> <DEDENT> count -= a [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( int ( ( N + 1 ) / 2 ) ) : <NEWLINE> <INDENT> count += 2 * a [ i ] <NEWLINE> <DEDENT> count -= a [ 0 ] <NEWLINE> count -= a [ int ( ( N - 1 ) / 2 ) ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> d = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> , 0 : <STRING> } <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> n = N <NEWLINE> ans = <STRING> <NEWLINE> <NL> while n > 0 : <NEWLINE> <INDENT> x = n % 26 <NEWLINE> ans += d [ x ] <NEWLINE> if ( x == 0 ) : <NEWLINE> <INDENT> n = n // 26 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n //= 26 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 7 % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , 10000000 ) : <NEWLINE> <INDENT> a = ( 10 * a + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cou = 0 <NEWLINE> x = math . inf <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> if min ( x , p [ j ] ) == p [ j ] : <NEWLINE> <INDENT> x = p [ j ] <NEWLINE> cou += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cou ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( ( b1 [ : , : ] , i8 , i8 , i8 , i8 ) , cache = True ) <NEWLINE> def main ( wall , Sx , Sy , Tx , Ty ) : <NEWLINE> <INDENT> INF = 1 << 30 <NEWLINE> H , W = wall . shape <NEWLINE> S = Sx * W + Sy <NEWLINE> T = Tx * W + Ty <NEWLINE> dist = np . full ( H * W , INF , np . int64 ) <NEWLINE> deq = np . empty ( H * W + 100 , np . int64 ) <NEWLINE> dist [ S ] = 0 <NEWLINE> deq [ 0 ] , l , r = S , 0 , 1 <NEWLINE> while l < r : <NEWLINE> <INDENT> v , l = deq [ l ] , l + 1 <NEWLINE> vx , vy = divmod ( v , W ) <NEWLINE> <COMMENT> <NL> for dx , dy in ( ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> wx , wy = vx + dx , vy + dy <NEWLINE> if not ( 0 <= wx < H ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not ( 0 <= wy < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if wall [ wx , wy ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = wx * W + wy <NEWLINE> if dist [ w ] <= dist [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w ] = dist [ v ] <NEWLINE> deq [ l - 1 ] , l = w , l - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for dx in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for dy in range ( - 2 , 3 ) : <NEWLINE> <INDENT> wx , wy = vx + dx , vy + dy <NEWLINE> if not ( 0 <= wx < H ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not ( 0 <= wy < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if wall [ wx , wy ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = wx * W + wy <NEWLINE> if dist [ w ] <= dist [ v ] + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w ] = dist [ v ] + 1 <NEWLINE> deq [ r ] , r = w , r + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = dist [ T ] <NEWLINE> if ans == INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> H , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> Sx , Sy = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> Tx , Ty = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> wall = np . frombuffer ( read ( ) , <STRING> ) . reshape ( H , - 1 ) [ : , : W ] == <STRING> <NEWLINE> <NL> print ( main ( wall , Sx , Sy , Tx , Ty ) ) <NEWLINE>
s = [ 0 ] * 13 <NEWLINE> h = [ 0 ] * 13 <NEWLINE> c = [ 0 ] * 13 <NEWLINE> d = [ 0 ] * 13 <NEWLINE> N = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> m , n = map ( str , input ( ) . split ( <STRING> ) ) <NEWLINE> n = int ( n ) - 1 <NEWLINE> if m == <STRING> : <NEWLINE> <INDENT> s [ n ] = 1 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> h [ n ] = 1 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> c [ n ] = 1 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> d [ n ] = 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> j = 0 <NEWLINE> while j < 13 : <NEWLINE> <INDENT> if s [ j ] == 0 : <NEWLINE> <INDENT> ans += <STRING> + str ( j + 1 ) + <STRING> <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> j = 0 <NEWLINE> while j < 13 : <NEWLINE> <INDENT> if h [ j ] == 0 : <NEWLINE> <INDENT> ans += <STRING> + str ( j + 1 ) + <STRING> <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> j = 0 <NEWLINE> while j < 13 : <NEWLINE> <INDENT> if c [ j ] == 0 : <NEWLINE> <INDENT> ans += <STRING> + str ( j + 1 ) + <STRING> <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> j = 0 <NEWLINE> while j < 13 : <NEWLINE> <INDENT> if d [ j ] == 0 : <NEWLINE> <INDENT> ans += <STRING> + str ( j + 1 ) + <STRING> <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> if ans != <STRING> : <NEWLINE> <INDENT> print ( ans [ : - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> N_square_root = math . floor ( math . sqrt ( N ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( N_square_root + 1 ) : <NEWLINE> <INDENT> result = i * i <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> slist = [ ] <NEWLINE> var = 0 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> slist . append ( s ) <NEWLINE> <DEDENT> sset = set ( slist ) <NEWLINE> print ( len ( sset ) ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> fact = factorization ( N ) <NEWLINE> fact_num = [ ] <NEWLINE> fact_num2 = [ ] <NEWLINE> <NL> <NL> for i in range ( len ( fact ) ) : <NEWLINE> <INDENT> fact_num . append ( fact [ i ] [ 0 ] ) <NEWLINE> fact_num2 . append ( fact [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> for j in range ( max ( fact_num2 ) + 1 ) : <NEWLINE> <INDENT> for i in range ( len ( fact ) ) : <NEWLINE> <INDENT> if N % fact_num [ i ] == 0 and N % ( fact_num [ i ] ** ( j + 1 ) ) == 0 : <NEWLINE> <INDENT> N = N / ( fact_num [ i ] ** ( j + 1 ) ) <NEWLINE> cnt += 1 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> c = [ 0 ] * n <NEWLINE> d = 0 <NEWLINE> sums = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if j - a [ j ] < 1 : <NEWLINE> <INDENT> das = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ j - a [ j ] ] = b [ j - a [ j ] ] + 1 <NEWLINE> <DEDENT> if j + a [ j ] > n - 2 : <NEWLINE> <INDENT> das = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ j + a [ j ] ] = c [ j + a [ j ] ] + 1 <NEWLINE> <DEDENT> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> d = b [ k ] * c [ k ] <NEWLINE> sums = sums + d <NEWLINE> <DEDENT> print ( sums ) <NEWLINE>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a , b = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( data [ 0 ] ) <NEWLINE> b . append ( data [ 1 ] ) <NEWLINE> <NL> <DEDENT> d = defaultdict ( lambda : [ 0 , 0 ] ) <NEWLINE> zeros = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] * b [ i ] != 0 : <NEWLINE> <INDENT> g = gcd ( a [ i ] , b [ i ] ) <NEWLINE> a [ i ] //= g <NEWLINE> b [ i ] //= g <NEWLINE> <DEDENT> if a [ i ] * b [ i ] > 0 : <NEWLINE> <INDENT> d [ ( abs ( a [ i ] ) , abs ( b [ i ] ) ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] * b [ i ] < 0 : <NEWLINE> <INDENT> d [ ( abs ( b [ i ] ) , abs ( a [ i ] ) ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] == 0 and b [ i ] != 0 : <NEWLINE> <INDENT> d [ ( 0 , 1 ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> elif b [ i ] == 0 and a [ i ] != 0 : <NEWLINE> <INDENT> d [ ( 0 , 1 ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] == b [ i ] == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mod = 1000000007 <NEWLINE> cnt = 1 <NEWLINE> for pair in d . values ( ) : <NEWLINE> <INDENT> cnt *= pow ( 2 , pair [ 0 ] , mod ) + pow ( 2 , pair [ 1 ] , mod ) - 1 <NEWLINE> cnt %= mod <NEWLINE> <DEDENT> cnt += zeros - 1 <NEWLINE> cnt %= mod <NEWLINE> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 1000 ) : <NEWLINE> <INDENT> X = list ( str ( x ) . zfill ( 3 ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> if X [ 0 ] in S [ : N - 2 ] : <NEWLINE> <INDENT> i = S . index ( X [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if X [ 1 ] in S [ i + 1 : N - 1 ] : <NEWLINE> <INDENT> j = S [ i + 1 : N - 1 ] . index ( X [ 1 ] ) + i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if X [ 2 ] in S [ j + 1 : N ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . insert ( 0 , 0 ) <NEWLINE> A . append ( 0 ) <NEWLINE> _A = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> _A . append ( abs ( A [ i ] - A [ i - 1 ] ) ) <NEWLINE> <DEDENT> _A . append ( abs ( 0 - A [ N ] ) ) <NEWLINE> S = sum ( _A ) <NEWLINE> <NL> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> allS = S <NEWLINE> allS -= ( _A [ i ] + _A [ i + 1 ] - abs ( A [ i + 2 ] - A [ i ] ) ) <NEWLINE> print ( allS ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
i , x = 1 , input ( ) <NEWLINE> while x != <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , x ) <NEWLINE> i += 1 ; x = input ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if k % 7 == 0 : <NEWLINE> <INDENT> L = int ( ( 9 * k ) / 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * k <NEWLINE> <DEDENT> if L % 2 == 0 or L % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 % L <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> if ( a * 10 ) % L == 1 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> a = ( a * 10 ) % L <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> print ( x * y , ( x + y ) * 2 ) <NEWLINE>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( n ) ] <NEWLINE> b = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( m ) ] <NEWLINE> c = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , c [ i ] ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <NL> s = list ( s ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> d = 0 <NEWLINE> if len ( s ) >= k : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if d == k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> P = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> <NL> c = Counter ( S ) <NEWLINE> ans = 1 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> ans = ( ans * ( v + 1 ) ) % P <NEWLINE> <NL> <DEDENT> ans = ( ans - 1 ) % P <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from typing import List <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , node_id , parent_id ) : <NEWLINE> <INDENT> self . node_id = node_id <NEWLINE> self . parent_id = parent_id <NEWLINE> self . children = [ ] <NEWLINE> <NL> self . depth = None <NEWLINE> self . node_type = None <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . node_id ) <NEWLINE> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return self . __str__ ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Tree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> self . n_node = n <NEWLINE> self . node_list = [ None for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find_node ( self , node_id : int ) : <NEWLINE> <INDENT> if self . node_list [ node_id ] != None : <NEWLINE> <INDENT> return self . node_list [ node_id ] <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def add_children_from_ids ( self , node_id : int , children_ids : List [ int ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> parent_node = self . find_node ( node_id ) <NEWLINE> if parent_node == None : <NEWLINE> <COMMENT> <NL> <INDENT> parent_node = Node ( node_id = node_id , parent_id = - 1 ) <NEWLINE> self . node_list [ node_id ] = parent_node <NEWLINE> <NL> <DEDENT> if len ( children_ids ) > 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for child_id in children_ids : <NEWLINE> <INDENT> child_node = self . find_node ( child_id ) <NEWLINE> <NL> if child_node == None : <NEWLINE> <INDENT> child_node = Node ( node_id = child_id , parent_id = node_id ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> child_node . parent_id = node_id <NEWLINE> <NL> <DEDENT> parent_node . children . append ( child_node ) <NEWLINE> self . node_list [ child_id ] = child_node <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def overwrite_node_type ( self ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> for node in self . node_list : <NEWLINE> <COMMENT> <NL> <INDENT> if node . parent_id == - 1 : <NEWLINE> <INDENT> node_type = <STRING> <NEWLINE> self . root = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if node . children != [ ] : <NEWLINE> <INDENT> node_type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node_type = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> node . node_type = node_type <NEWLINE> <NL> <DEDENT> <DEDENT> def overwrite_depth ( self , node , depth ) : <NEWLINE> <INDENT> if node . children == [ ] : <NEWLINE> <INDENT> node . depth = depth <NEWLINE> <COMMENT> <NL> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . depth = depth <NEWLINE> for child_node in node . children : <NEWLINE> <INDENT> self . overwrite_depth ( child_node , depth + 1 ) <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def print_nodes ( self ) : <NEWLINE> <INDENT> for node in self . node_list : <NEWLINE> <INDENT> print ( <STRING> . format ( <NEWLINE> <INDENT> node . node_id , node . parent_id , node . depth , node . node_type , node . children <NEWLINE> <DEDENT> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> tree = Tree ( n ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> node_id , k , * children = map ( int , input ( ) . split ( ) ) <NEWLINE> tree . add_children_from_ids ( node_id = node_id , children_ids = children ) <NEWLINE> <DEDENT> tree . overwrite_node_type ( ) <NEWLINE> <NL> tree . overwrite_depth ( tree . root , 0 ) <NEWLINE> tree . print_nodes ( ) <NEWLINE> <DEDENT> main ( ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> history = set ( ) <NEWLINE> now = 0 <NEWLINE> cnt = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if now in history : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> history . add ( now ) <NEWLINE> now = a [ now ] - 1 <NEWLINE> if now == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> global FLAG_LOG <NEWLINE> FLAG_LOG = False <NEWLINE> <NL> <NL> def log ( value ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if FLAG_LOG : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> K = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> dic = dict ( ) <NEWLINE> for x in range ( 1 , K ) : <NEWLINE> <INDENT> for y in range ( x + 1 , K + 1 ) : <NEWLINE> <INDENT> dic [ ( x , y ) ] = math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> su = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> tmp = [ a , b , c ] <NEWLINE> tmp . sort ( ) <NEWLINE> x , y , z = tmp <NEWLINE> <COMMENT> <NL> su += get_gcd_by_dic ( dic , x , y , z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return [ su ] <NEWLINE> <NL> <NL> <DEDENT> def gcd ( p , q ) : <NEWLINE> <INDENT> if p % q == 0 : <NEWLINE> <INDENT> return q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( q , p % q ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation2 ( lines ) : <NEWLINE> <INDENT> K = int ( lines [ 0 ] ) <NEWLINE> <NL> gcdlist = [ [ 0 for i in range ( K ) ] for j in range ( K ) ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( i , K ) : <NEWLINE> <INDENT> tmp = gcd ( i + 1 , j + 1 ) <NEWLINE> gcdlist [ i ] [ j ] = tmp <NEWLINE> gcdlist [ j ] [ i ] = tmp <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> su = 0 <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> for c in range ( K ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> tmp = a + 1 <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> tmp = gcdlist [ a ] [ c ] <NEWLINE> <DEDENT> elif a == c : <NEWLINE> <INDENT> tmp = gcdlist [ a ] [ b ] <NEWLINE> <DEDENT> elif b == c : <NEWLINE> <INDENT> tmp = gcdlist [ a ] [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = gcdlist [ a ] [ gcdlist [ b ] [ c ] - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> su += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return [ su ] <NEWLINE> <NL> <NL> <DEDENT> def calculation3 ( lines ) : <NEWLINE> <INDENT> K = int ( lines [ 0 ] ) <NEWLINE> su = 0 <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> for c in range ( K ) : <NEWLINE> <INDENT> su += gcd ( gcd ( a + 1 , b + 1 ) , c + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return [ su ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def get_gcd_by_dic ( dic , a , b , c ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> x = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = dic [ ( a , b ) ] <NEWLINE> <DEDENT> if a == c : <NEWLINE> <INDENT> y = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = dic [ ( a , c ) ] <NEWLINE> <DEDENT> if x == y : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> ret = dic [ ( y , x ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = dic [ ( x , y ) ] <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 9 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 10813692 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> global FLAG_LOG <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> FLAG_LOG = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> FLAG_LOG = True <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation2 ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ma = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> ni = lambda : int ( input ( ) ) <NEWLINE> yn = lambda fl : print ( <STRING> ) if fl else print ( <STRING> ) <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq as hq <NEWLINE> n , k = ma ( ) <NEWLINE> A = list ( ma ( ) ) <NEWLINE> s = 1 <NEWLINE> zeros = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> zeros [ i ] += 1 <NEWLINE> zeros [ min ( n , i + k ) ] -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> zeros [ i ] += zeros [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> if zeros [ i ] > 0 : <NEWLINE> <INDENT> f = False <NEWLINE> yn ( f ) <NEWLINE> continue <NEWLINE> <DEDENT> if A [ i ] > A [ i - k ] : <NEWLINE> <INDENT> f = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> yn ( f ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> d = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> <NL> <NL> def dfs ( i ) : <NEWLINE> <INDENT> if min ( d . values ( ) ) < 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if i == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> k1 , k2 = s [ i ] <NEWLINE> <NL> d [ k1 ] += 1 <NEWLINE> d [ k2 ] -= 1 <NEWLINE> ans . append ( k1 ) <NEWLINE> dfs ( i + 1 ) <NEWLINE> d [ k1 ] -= 1 <NEWLINE> d [ k2 ] += 1 <NEWLINE> ans . pop ( ) <NEWLINE> <NL> d [ k2 ] += 1 <NEWLINE> d [ k1 ] -= 1 <NEWLINE> ans . append ( k2 ) <NEWLINE> dfs ( i + 1 ) <NEWLINE> d [ k2 ] -= 1 <NEWLINE> d [ k1 ] += 1 <NEWLINE> ans . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
e = enumerate <NEWLINE> n , a = open ( 0 ) <NEWLINE> n = int ( n ) <NEWLINE> d = [ 0 ] + [ - 2 ** 64 ] * n <NEWLINE> for j , ( a , i ) in e ( sorted ( ( - int ( a ) , i ) for i , a in e ( a . split ( ) ) ) ) : d = [ max ( t - a * ( ~ i - j + k + n ) , d [ k - 1 ] - a * abs ( ~ i + k ) ) for k , t in e ( d ) ] <NEWLINE> print ( max ( d ) ) <NEWLINE>
books1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while ( i < len ( books1 ) ) : <NEWLINE> <INDENT> if ( books1 [ i ] == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( i + 1 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> tree = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ A ] . append ( B ) <NEWLINE> tree [ B ] . append ( A ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def dfs ( u , par ) : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> ret = 1 <NEWLINE> for v in tree [ u ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> ret += dfs ( v , u ) <NEWLINE> <NL> <DEDENT> <DEDENT> if par > 0 : <NEWLINE> <INDENT> tree_dic [ ( u , par ) ] = ret <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> visited = [ False ] * ( N + 1 ) <NEWLINE> tree_dic = { } <NEWLINE> dfs ( 1 , 0 ) <NEWLINE> <COMMENT> <NL> <NL> bumbo = pow ( 2 , N , MOD ) <NEWLINE> bunshi = ( pow ( 2 , N , MOD ) - 1 - N * pow ( 2 , N - 1 , MOD ) ) % MOD <NEWLINE> for x in tree_dic . values ( ) : <NEWLINE> <INDENT> term = ( pow ( 2 , x , MOD ) - 1 ) * ( pow ( 2 , N - x , MOD ) - 1 ) <NEWLINE> bunshi += term <NEWLINE> bunshi %= MOD <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> answer = bunshi * pow ( bumbo , MOD - 2 , MOD ) <NEWLINE> answer %= MOD <NEWLINE> print ( answer ) <NEWLINE>
import sys <NEWLINE> S = input ( ) <NEWLINE> sec = int ( S ) <NEWLINE> if ( sec < 86400 ) : <NEWLINE> <INDENT> if ( sec >= 0 ) : <NEWLINE> <INDENT> h = int ( sec / 3600 ) <NEWLINE> sec = sec % 3600 <NEWLINE> m = int ( sec / 60 ) <NEWLINE> s = sec % 60 <NEWLINE> print ( h , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( m , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
S = int ( input ( ) ) <NEWLINE> x = 10 ** 9 + 7 <NEWLINE> a = [ 0 for i in range ( 2001 ) ] <NEWLINE> a [ 3 ] = 1 <NEWLINE> a [ 4 ] = 1 <NEWLINE> a [ 5 ] = 1 <NEWLINE> a [ 6 ] = 2 <NEWLINE> for i in range ( 7 , S + 1 ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 1 ] + a [ i - 3 ] ) % x <NEWLINE> <DEDENT> print ( a [ S ] ) <NEWLINE>
def mbisect ( ok , ng ) : <NEWLINE> <INDENT> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> def check ( mid ) : <NEWLINE> <INDENT> if mid == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt += ( i + mid - 1 ) // mid - 1 <NEWLINE> <DEDENT> return cnt <= k <NEWLINE> <NL> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( mbisect ( 10 ** 9 , - 1 ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( b - 1 , n ) <NEWLINE> <NL> print ( int ( a * x / b ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> result = <STRING> if a < b < c else <STRING> <NEWLINE> print ( result ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> subtree_size = [ 0 ] * n <NEWLINE> cnt = [ 0 ] * n <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> cnt [ p ] += x <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> def dfs ( G , v , p ) : <NEWLINE> <INDENT> ans [ v ] += cnt [ v ] <NEWLINE> for nv in G [ v ] : <NEWLINE> <INDENT> if nv == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ nv ] += cnt [ v ] <NEWLINE> dfs ( G , nv , v ) <NEWLINE> <NL> <DEDENT> subtree_size [ v ] = 1 <NEWLINE> for c in G [ v ] : <NEWLINE> <INDENT> if c == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> subtree_size [ v ] += subtree_size [ c ] <NEWLINE> <NL> <DEDENT> <DEDENT> root = 0 <NEWLINE> dfs ( G , root , - 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> A = [ 1 ] * 10 <NEWLINE> <NL> def check ( A , ans ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> t += d [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans < t : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i1 in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> A [ 1 ] = i1 <NEWLINE> if n >= 3 : <NEWLINE> <INDENT> for i2 in range ( i1 , m + 1 ) : <NEWLINE> <INDENT> A [ 2 ] = i2 <NEWLINE> if n >= 4 : <NEWLINE> <INDENT> for i3 in range ( i2 , m + 1 ) : <NEWLINE> <INDENT> A [ 3 ] = i3 <NEWLINE> if n >= 5 : <NEWLINE> <INDENT> for i4 in range ( i3 , m + 1 ) : <NEWLINE> <INDENT> A [ 4 ] = i4 <NEWLINE> if n >= 6 : <NEWLINE> <INDENT> for i5 in range ( i4 , m + 1 ) : <NEWLINE> <INDENT> A [ 5 ] = i5 <NEWLINE> if n >= 7 : <NEWLINE> <INDENT> for i6 in range ( i5 , m + 1 ) : <NEWLINE> <INDENT> A [ 6 ] = i6 <NEWLINE> if n >= 8 : <NEWLINE> <INDENT> for i7 in range ( i6 , m + 1 ) : <NEWLINE> <INDENT> A [ 7 ] = i7 <NEWLINE> if n >= 9 : <NEWLINE> <INDENT> for i8 in range ( i7 , m + 1 ) : <NEWLINE> <INDENT> A [ 8 ] = i8 <NEWLINE> if n >= 10 : <NEWLINE> <INDENT> for i9 in range ( i8 , m + 1 ) : <NEWLINE> <INDENT> A [ 9 ] = i9 <NEWLINE> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = check ( A , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> li = list ( c ) <NEWLINE> count = li . count ( <STRING> ) <NEWLINE> num = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( count ) : <NEWLINE> <INDENT> if li [ i ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
M = 2019 <NEWLINE> a = i = 0 <NEWLINE> d = [ 0 ] * M <NEWLINE> p = 1 <NEWLINE> for j in <STRING> + input ( ) [ : : - 1 ] : i = ( i + int ( j ) * p ) % M ; p = p * 10 % M ; a += d [ i ] ; d [ i ] += 1 <NEWLINE> print ( a ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> R_pos = [ ] <NEWLINE> G_pos = [ ] <NEWLINE> B_pos = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R_pos . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G_pos . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> B_pos . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> answer = len ( R_pos ) * len ( G_pos ) * len ( B_pos ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sums = 0 <NEWLINE> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> m = n // i <NEWLINE> sums = sums + ( ( m + 1 ) / 2 * m ) * i <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> print ( int ( sums ) ) <NEWLINE>
from collections import * <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ <STRING> * ( W + 4 ) ] <NEWLINE> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> s . append ( <STRING> * ( W + 4 ) ) <NEWLINE> <NL> ans = [ [ - 1 ] * ( W + 4 ) for _ in range ( H + 4 ) ] <NEWLINE> for i in range ( H + 4 ) : <NEWLINE> <INDENT> for j in range ( W + 4 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ch += 1 ; cw += 1 <NEWLINE> dh += 1 ; dw += 1 <NEWLINE> ans [ ch ] [ cw ] = 0 <NEWLINE> <NL> move = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> magic = [ <NEWLINE> <INDENT> [ - 2 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 2 , 2 ] , [ - 1 , - 2 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ - 1 , 2 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , - 2 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , - 2 ] , [ 2 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] <NEWLINE> ] <NEWLINE> <NL> <DEDENT> mylist = deque ( [ [ ch , cw ] ] ) <NEWLINE> mylist2 = deque ( [ ] ) <NEWLINE> while len ( mylist ) > 0 : <NEWLINE> <INDENT> x , y = mylist . popleft ( ) <NEWLINE> mylist2 . append ( [ x , y ] ) <NEWLINE> for p , q in move : <NEWLINE> <INDENT> v1 , v2 = x + p , y + q <NEWLINE> if ans [ v1 ] [ v2 ] == - 1 : <NEWLINE> <INDENT> mylist . append ( [ v1 , v2 ] ) <NEWLINE> ans [ v1 ] [ v2 ] = ans [ x ] [ y ] <NEWLINE> <DEDENT> <DEDENT> if len ( mylist ) == 0 : <NEWLINE> <INDENT> while len ( mylist2 ) > 0 : <NEWLINE> <INDENT> x2 , y2 = mylist2 . popleft ( ) <NEWLINE> for v1 , v2 in magic : <NEWLINE> <INDENT> i , j = x2 + v1 , y2 + v2 <NEWLINE> if ans [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> mylist . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ dh ] [ dw ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> count = 0 <NEWLINE> num = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num . append ( x ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> print ( <STRING> + str ( ( i + 1 ) ) + <STRING> , num [ i ] ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> ans = 1 <NEWLINE> <COMMENT> <NL> A . sort ( ) <NEWLINE> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import os <NEWLINE> import heapq <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import operator <NEWLINE> from collections import defaultdict <NEWLINE> from io import BytesIO , IOBase <NEWLINE> <NL> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> def inpt ( ) : <NEWLINE> <INDENT> return [ int ( k ) for k in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> def check ( mid , k , ar ) : <NEWLINE> <INDENT> ct = k <NEWLINE> for i in ar : <NEWLINE> <INDENT> if ( i <= mid ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ct -= ( i // mid ) <NEWLINE> <DEDENT> return ct >= 0 <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ar = inpt ( ) <NEWLINE> i , j = 1 , 100000000000 <NEWLINE> while ( i < j ) : <NEWLINE> <INDENT> mid = ( i + j ) // 2 <NEWLINE> if ( check ( mid , k , ar ) ) : <NEWLINE> <INDENT> j = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = mid + 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE> <NL> <DEDENT> BUFSIZE = 8192 <NEWLINE> <NL> <NL> class FastIO ( IOBase ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> <NL> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _fd = file . fileno ( ) <NEWLINE> self . buffer = BytesIO ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> not in file . mode <NEWLINE> self . write = self . buffer . write if self . writable else None <NEWLINE> <NL> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines = 0 <NEWLINE> return self . buffer . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . newlines = b . count ( <STRING> ) + ( not b ) <NEWLINE> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return self . buffer . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . buffer . getvalue ( ) ) <NEWLINE> self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ X ] <NEWLINE> p = [ - 1 ] * ( M + 1 ) <NEWLINE> p [ X ] = 0 <NEWLINE> x = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x = ( l [ - 1 ] ** 2 ) % M <NEWLINE> if p [ x ] >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l . append ( x ) <NEWLINE> p [ x ] = i + 1 <NEWLINE> <DEDENT> x = p [ x ] <NEWLINE> y = len ( l ) - x <NEWLINE> print ( sum ( l [ : x ] ) + ( N - x ) // y * sum ( l [ x : ] ) + sum ( l [ x : x + ( N - x ) % y ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> b = list ( a ) <NEWLINE> b . sort ( reverse = True ) <NEWLINE> c = b [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == c : <NEWLINE> <INDENT> print ( b [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N -= 1 <NEWLINE> matsubi = N % 26 <NEWLINE> matsubi = chr ( 96 + matsubi + 1 ) <NEWLINE> ans += matsubi <NEWLINE> <NL> if N // 26 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N //= 26 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
isPrime = [ ] <NEWLINE> prime = [ ] <NEWLINE> count = [ ] <NEWLINE> <NL> def init ( ) : <NEWLINE> <INDENT> for i in range ( 50000 + 1 ) : <NEWLINE> <INDENT> isPrime . append ( True ) <NEWLINE> count . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def eratos ( ) : <NEWLINE> <INDENT> isPrime [ 0 ] = False <NEWLINE> isPrime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( ( 50000 ** ( 1 / 2 ) ) ) + 1 ) : <NEWLINE> <INDENT> if ( isPrime [ i ] ) : <NEWLINE> <INDENT> for j in range ( i * 2 , 50000 + 1 , i ) : <NEWLINE> <INDENT> isPrime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 2 , 50001 ) : <NEWLINE> <INDENT> if isPrime [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def table ( ) : <NEWLINE> <INDENT> for i in prime : <NEWLINE> <INDENT> for j in prime : <NEWLINE> <INDENT> if i < j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i + j > 50000 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count [ i + j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> init ( ) <NEWLINE> eratos ( ) <NEWLINE> table ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( count [ n ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * 9 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> aa = int ( A [ i ] / 400 ) <NEWLINE> if aa > 8 : <NEWLINE> <INDENT> aa = 8 <NEWLINE> <DEDENT> ans [ aa ] += 1 <NEWLINE> <NL> <DEDENT> min_a = 0 <NEWLINE> max_a = 0 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> if i != 8 : <NEWLINE> <INDENT> if ans [ i ] != 0 : <NEWLINE> <INDENT> min_a += 1 <NEWLINE> max_a += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max_a += ans [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> min_a = max ( min_a , 1 ) <NEWLINE> print ( min_a , max_a ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ i for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ m ] > k : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + m ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> big = max ( a , b ) <NEWLINE> small = min ( a , b ) <NEWLINE> while not big % small == 0 : <NEWLINE> <INDENT> big , small = small , big % small <NEWLINE> <DEDENT> return small <NEWLINE> <NL> <DEDENT> print ( gcd ( a , b ) ) <NEWLINE> <NL>
import itertools <NEWLINE> <NL> nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> list0 = [ ] <NEWLINE> A = [ ] <NEWLINE> A0 = list ( range ( 0 , nums [ 0 ] ) ) <NEWLINE> for i in range ( 0 , nums [ 0 ] ) : <NEWLINE> <INDENT> val = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> list0 . append ( val ) <NEWLINE> for x in itertools . combinations ( A0 , i + 1 ) : <NEWLINE> <INDENT> A . append ( list ( x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> Z = [ 0 ] <NEWLINE> for i in range ( 1 , nums [ 1 ] + 1 ) : <NEWLINE> <INDENT> Z . append ( nums [ 2 ] ) <NEWLINE> <NL> <DEDENT> X = [ ] <NEWLINE> for i in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> Y = [ 0 ] * ( nums [ 1 ] + 1 ) <NEWLINE> for j in range ( 0 , len ( A [ i ] ) ) : <NEWLINE> <INDENT> Y = [ x + y for ( x , y ) in zip ( Y , list0 [ A [ i ] [ j ] ] ) ] <NEWLINE> <DEDENT> W = [ x - y for ( x , y ) in zip ( Y , Z ) ] <NEWLINE> if min ( W ) >= 0 : <NEWLINE> <INDENT> X . append ( Y [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( X ) > 0 : <NEWLINE> <INDENT> print ( min ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> towns = [ 1 ] <NEWLINE> town_dic = defaultdict ( lambda : 0 ) <NEWLINE> prev = 1 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> next = a [ prev - 1 ] <NEWLINE> count += 1 <NEWLINE> if count == k : <NEWLINE> <INDENT> print ( next ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if town_dic [ next ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> town_dic [ next ] += 1 <NEWLINE> <DEDENT> towns . append ( next ) <NEWLINE> prev = next <NEWLINE> <DEDENT> i = towns . index ( next ) <NEWLINE> repeat = towns [ i : ] <NEWLINE> unit = len ( repeat ) <NEWLINE> rest = k - count + 1 <NEWLINE> print ( repeat [ ( rest % unit ) - 1 ] ) <NEWLINE>
user = input ( ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> b = user . split ( ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> a . append ( int ( b [ i ] ) ) <NEWLINE> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , 5 ) : <COMMENT> <NEWLINE> <INDENT> if a [ j ] < a [ k ] : <NEWLINE> <INDENT> tmp = a [ j ] <NEWLINE> a [ j ] = a [ k ] <NEWLINE> a [ k ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> if j == 4 : <NEWLINE> <INDENT> print ( a [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( a [ j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B > N : <NEWLINE> <INDENT> ans = math . floor ( A * N / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = math . floor ( A * ( B - 1 ) / B ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> sumval = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> f = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( f , c ) <NEWLINE> sumval += g <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sumval ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ [ 0 ] * 2 for i in range ( n + 1 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp [ 0 ] [ 0 ] = 0 <NEWLINE> dp [ 0 ] [ 1 ] = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = ( dp [ i ] [ 0 ] + ( i + 1 ) ) % mod <NEWLINE> <DEDENT> dp [ n ] [ 1 ] = dp [ n ] [ 0 ] <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 1 ] = ( dp [ i + 1 ] [ 1 ] - ( n - 1 - i ) ) % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> ksum = 0 <NEWLINE> for kk in range ( k - 1 , n + 1 ) : <NEWLINE> <INDENT> ksum = ( ksum + dp [ kk ] [ 1 ] - dp [ kk ] [ 0 ] + 1 ) % mod <NEWLINE> <DEDENT> print ( ksum ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> import bisect <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> visited = [ - 1 ] * ( n + 1 ) <NEWLINE> visited [ 0 ] = 0 <NEWLINE> visited [ 1 ] = 1 <NEWLINE> <NL> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> dp = [ 10 ** 10 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = A [ 1 ] <NEWLINE> update_task = [ ( ) for _ in range ( n + 1 ) ] <NEWLINE> update_task [ 1 ] = ( 1 , 0 ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d [ - 1 ] <NEWLINE> if graph [ v ] == [ ] : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> index , atai = update_task [ v ] <NEWLINE> dp [ index ] = atai <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = graph [ v ] . pop ( ) <NEWLINE> if visited [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> bis = bisect . bisect_left ( dp , A [ i ] ) <NEWLINE> update_task [ i ] = ( bis , dp [ bis ] ) <NEWLINE> dp [ bis ] = A [ i ] <NEWLINE> visited [ i ] = bisect . bisect_left ( dp , 10 ** 10 - 100 ) - 1 <NEWLINE> d . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * visited [ 1 : ] , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> decrement = 0 <NEWLINE> profit = [ ] <NEWLINE> loss = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . rstrip ( ) <NEWLINE> min_p = 0 <NEWLINE> end_p = 0 <NEWLINE> point = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> point += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> point -= 1 <NEWLINE> if point < min_p : <NEWLINE> <INDENT> min_p = point <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> end_p = point <NEWLINE> <DEDENT> if 0 <= min_p : <NEWLINE> <INDENT> cnt += end_p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if min_p == end_p : <NEWLINE> <INDENT> decrement += end_p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 0 <= end_p : <NEWLINE> <INDENT> profit . append ( ( min_p , end_p ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loss . append ( ( min_p , end_p ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> profit . sort ( ) <NEWLINE> while profit : <NEWLINE> <INDENT> min_p , end_p = profit . pop ( ) <NEWLINE> if cnt + min_p < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> cnt += end_p <NEWLINE> <NL> <NL> <DEDENT> loss . sort ( reverse = True ) <NEWLINE> while loss : <NEWLINE> <INDENT> min_p , end_p = loss . pop ( ) <NEWLINE> if cnt + min_p < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> cnt += end_p <NEWLINE> <NL> <DEDENT> print ( <STRING> if cnt + decrement == 0 else <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > int ( 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , m , k = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> sa = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( sa [ - 1 ] + a [ i ] ) > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sa . append ( sa [ - 1 ] + a [ i ] ) <NEWLINE> <DEDENT> sb = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( sb [ - 1 ] + b [ i ] ) > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sb . append ( sb [ - 1 ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> r = 0 <NEWLINE> j = 0 <NEWLINE> cur = sa [ - 1 ] <NEWLINE> <NL> for i in range ( len ( sa ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> while j < len ( sb ) : <NEWLINE> <INDENT> if sa [ i ] + sb [ j ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> r = max ( r , i + j - 1 ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> now = 0 <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> if A [ x ] == now + 1 : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> <DEDENT> if now == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - now ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if ( a [ i ] < a [ i + k ] ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = set ( p ) <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> if X - i not in p : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> if X + i not in p : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if ( arr [ i - k ] < arr [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> def gcd ( * nums ) : <NEWLINE> <INDENT> return reduce ( math . gcd , nums ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> if b == c : <NEWLINE> <INDENT> s += gcd ( a , b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 2 * gcd ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> A . sort ( reverse = True ) <NEWLINE> dis = deque ( [ A [ 0 ] ] ) <NEWLINE> num = 0 <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> num += dis . popleft ( ) <NEWLINE> <COMMENT> <NL> dis . append ( A [ i ] ) <NEWLINE> dis . append ( A [ i ] ) <NEWLINE> <DEDENT> print ( num ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
import bisect <NEWLINE> N , K , * A = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> K -= 1 <NEWLINE> L = [ [ ] for _ in range ( 2 * 10 ** 5 + 1 ) ] <NEWLINE> for i , a in enumerate ( A * 2 ) : <NEWLINE> <INDENT> L [ a ] += [ i ] <NEWLINE> <DEDENT> before_next = [ L [ a ] [ bisect . bisect ( L [ a ] , i ) ] for i , a in enumerate ( A ) ] <NEWLINE> first_cycle = [ None ] * N <NEWLINE> now = 0 <NEWLINE> idx = 0 <NEWLINE> cycle = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if first_cycle [ now ] is not None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> first_cycle [ now ] = cycle <NEWLINE> now = before_next [ now ] + 1 <NEWLINE> dcycle , now = divmod ( now , N ) <NEWLINE> cycle += dcycle <NEWLINE> <DEDENT> cycle2 = cycle <NEWLINE> cycle1 = first_cycle [ now ] <NEWLINE> <COMMENT> <NL> K2 = cycle1 + ( K - cycle1 ) % ( cycle2 - cycle1 ) <NEWLINE> if K2 : <NEWLINE> <INDENT> f1 = f2 = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if first_cycle [ i ] == K2 - 1 : <NEWLINE> <INDENT> f1 = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if first_cycle [ j ] == K2 : <NEWLINE> <INDENT> f2 = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f2 : <NEWLINE> <INDENT> B = A [ j : ] <NEWLINE> <DEDENT> elif f1 : <NEWLINE> <INDENT> B = A [ i : ] + A <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B = A <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> cnt = [ 0 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> for a in B : <NEWLINE> <INDENT> if cnt [ a ] > 0 : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> cnt [ ans . pop ( ) ] -= 1 <NEWLINE> if cnt [ a ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += [ a ] <NEWLINE> cnt [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li2 = [ 0 ] * n <NEWLINE> li3 = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> if i + li [ i ] < len ( li ) : <NEWLINE> <INDENT> li2 [ i + li [ i ] ] += 1 <NEWLINE> <DEDENT> if i - li [ i ] >= 0 : <NEWLINE> <INDENT> li3 [ i - li [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> if li2 [ i ] > 0 and li3 [ i ] > 0 : <NEWLINE> <INDENT> cnt += li2 [ i ] * li3 [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> deque = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> inp = list ( input ( ) . split ( ) ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> deque . popleft ( ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> deque . pop ( ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> deque . appendleft ( inp [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if inp [ 1 ] in deque : <NEWLINE> <INDENT> deque . remove ( inp [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * deque ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> red_index = c . rfind ( <STRING> ) <NEWLINE> white_index = c . find ( <STRING> ) <NEWLINE> if red_index < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if white_index >= red_index or white_index < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> red_end = red_index <NEWLINE> white_start = white_index + 1 <NEWLINE> red_index = c . rfind ( <STRING> , 0 , red_end ) <NEWLINE> white_index = c . find ( <STRING> , white_start , N ) <NEWLINE> if red_index < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if white_index >= red_index or white_index < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> from itertools import combinations <NEWLINE> <NL> <NL> def enum_sum_numbers ( sets , s_range , r ) : <NEWLINE> <INDENT> for cmb in combinations ( sets , r ) : <NEWLINE> <INDENT> yield sum ( cmb ) <NEWLINE> <DEDENT> if r <= s_range : <NEWLINE> <INDENT> for s in enum_sum_numbers ( sets , s_range , r + 1 ) : <NEWLINE> <INDENT> yield s <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> stdin . readline ( ) <NEWLINE> a = [ int ( s ) for s in stdin . readline ( ) . split ( ) ] <NEWLINE> stdin . readline ( ) <NEWLINE> ms = [ int ( s ) for s in stdin . readline ( ) . split ( ) ] <NEWLINE> sets = { s for s in enum_sum_numbers ( a , len ( a ) , 1 ) } <NEWLINE> <NL> for m in ms : <NEWLINE> <INDENT> print ( <STRING> if m in sets else <STRING> ) <NEWLINE> <DEDENT>
home = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> home [ a - 1 ] [ b - 1 ] [ c - 1 ] += d <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( home [ i ] [ j ] [ k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( home [ 3 ] [ j ] [ k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> <DEDENT> r = len ( R ) <NEWLINE> g = len ( G ) <NEWLINE> ans = r * g * ( N - r - g ) <NEWLINE> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> a = 2 * i - j <NEWLINE> b = 2 * j - i <NEWLINE> c = i + j <NEWLINE> if 0 <= a < N and S [ a ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 0 <= b < N and S [ b ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if c % 2 == 0 and S [ c // 2 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> <NL> s = input ( ) <NEWLINE> <NL> MOD = 2019 <NEWLINE> d = [ 0 ] * MOD <NEWLINE> d [ 0 ] = 1 <NEWLINE> r = 0 <NEWLINE> t = 1 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> r += int ( i ) * t <NEWLINE> r %= MOD <NEWLINE> t *= 10 <NEWLINE> t %= MOD <NEWLINE> d [ r ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in d ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_val = pow ( 10 , 18 ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = 1 <NEWLINE> for aa in a : <NEWLINE> <INDENT> answer *= aa <NEWLINE> if max_val < answer : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from math import inf <NEWLINE> <NL> inv = 0 <NEWLINE> <NL> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global inv <NEWLINE> <NL> L = A [ left : mid ] <NEWLINE> L . append ( inf ) <NEWLINE> R = A [ mid : right ] <NEWLINE> R . append ( inf ) <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] < R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inv += len ( L ) - i - 1 <NEWLINE> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> merge_sort ( A , 0 , n ) <NEWLINE> print ( inv ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
n = [ i for i in range ( 1000 , 10001 , 1000 ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> for i in n : <NEWLINE> <INDENT> if i > m or i == m : <NEWLINE> <INDENT> a = i - m <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> score = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if score [ i - k ] < score [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> def e ( x , y ) : <NEWLINE> <INDENT> z = 1 <NEWLINE> if x < y : <NEWLINE> <INDENT> z = x <NEWLINE> x = y <NEWLINE> y = z <NEWLINE> <NL> <DEDENT> while x != 0 and y != 0 and z != 0 and x != y : <NEWLINE> <INDENT> z = x % y <NEWLINE> x = y <NEWLINE> y = z <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> el = [ ] <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> kara = [ ] <NEWLINE> for b in range ( n ) : <NEWLINE> <INDENT> kara . append ( e ( a + 1 , b + 1 ) ) <NEWLINE> <NL> <DEDENT> el . append ( kara ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( n ) : <NEWLINE> <INDENT> u = el [ a ] [ b ] <NEWLINE> for c in range ( n ) : <NEWLINE> <INDENT> v = el [ b ] [ c ] <NEWLINE> w = el [ u - 1 ] [ v - 1 ] <NEWLINE> s = s + w <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> B = [ [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( m ) ] <NEWLINE> result = [ [ 0 for i in range ( l ) ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> for k in range ( l ) : <NEWLINE> <INDENT> result [ i ] [ k ] += A [ i ] [ j ] * B [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , result [ i ] ) ) ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> tmp_min = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , ( - 1 ) * ( - tmp_min // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
arr = [ [ [ 0 for i3 in range ( 10 ) ] for i2 in range ( 3 ) ] for i1 in range ( 4 ) ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> arr [ a - 1 ] [ b - 1 ] [ c - 1 ] += d <NEWLINE> <DEDENT> for j1 in range ( 4 ) : <NEWLINE> <INDENT> for j2 in range ( 3 ) : <NEWLINE> <INDENT> u = arr [ j1 ] [ j2 ] <NEWLINE> print ( <STRING> , u [ 0 ] , u [ 1 ] , u [ 2 ] , u [ 3 ] , u [ 4 ] , u [ 5 ] , u [ 6 ] , u [ 7 ] , u [ 8 ] , u [ 9 ] ) <NEWLINE> <DEDENT> if j1 == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> anslist = [ 0 ] * ( N + 1 ) <NEWLINE> ma = int ( math . sqrt ( N ) ) + 1 <NEWLINE> for x in range ( 1 , ma ) : <NEWLINE> <INDENT> for y in range ( x , ma ) : <NEWLINE> <INDENT> for z in range ( y , ma ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n <= N : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> anslist [ n ] += 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> anslist [ n ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> anslist [ n ] += 6 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( anslist [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c_str = input ( ) <NEWLINE> c_list = list ( c_str ) <NEWLINE> <NL> cnt = 0 <NEWLINE> flag = 1 <NEWLINE> w_pos = 0 <NEWLINE> r_pos = 0 <NEWLINE> range_start = 0 <NEWLINE> range_end = n <NEWLINE> <NL> while flag : <NEWLINE> <INDENT> for i in range ( range_start , range_end ) : <NEWLINE> <INDENT> if c_list [ i ] == <STRING> : <NEWLINE> <INDENT> w_pos = i <NEWLINE> range_start = i <NEWLINE> break <NEWLINE> <DEDENT> if i == range_end - 1 : <NEWLINE> <INDENT> w_pos = range_end - 1 <NEWLINE> <DEDENT> <DEDENT> for j in reversed ( range ( range_start , range_end ) ) : <NEWLINE> <INDENT> if c_list [ j ] == <STRING> : <NEWLINE> <INDENT> r_pos = j <NEWLINE> range_end = j <NEWLINE> break <NEWLINE> <DEDENT> if j == range_start : <NEWLINE> <INDENT> r_pos = range_start <NEWLINE> <DEDENT> <DEDENT> if w_pos < r_pos : <NEWLINE> <INDENT> c_list [ w_pos ] = <STRING> <NEWLINE> c_list [ r_pos ] = <STRING> <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = min ( b - 1 , n ) <COMMENT> <NEWLINE> ans = int ( a * x / b ) <NEWLINE> print ( ans ) <NEWLINE>
<NL> <COMMENT> <NL> import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> cal = math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <COMMENT> <NL> if a != b and b != c : <NEWLINE> <INDENT> count += cal * 6 <NEWLINE> <DEDENT> elif a == b == c : <NEWLINE> <INDENT> count += cal <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += cal * 3 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> P = 2019 <NEWLINE> ans = 0 <NEWLINE> <NL> count = [ 0 ] * P <NEWLINE> count [ 0 ] = 1 <NEWLINE> u = 0 <NEWLINE> for i , s in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> u = ( int ( s ) * pow ( 10 , i , P ) + u ) % P <NEWLINE> ans += count [ u ] <NEWLINE> count [ u ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> import bisect <NEWLINE> import numpy as np <NEWLINE> amax = a [ - 1 ] <NEWLINE> cent = amax // 2 <NEWLINE> <NL> idx = bisect . bisect_left ( a , cent ) <NEWLINE> if idx == len ( a ) - 1 : <NEWLINE> <INDENT> print ( amax , a [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_idx = np . argmin ( [ abs ( a [ idx ] - cent ) , abs ( a [ idx - 1 ] - cent ) ] ) <NEWLINE> if max_idx : <NEWLINE> <INDENT> print ( amax , a [ idx - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( amax , a [ idx ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> def get_array ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> g = defaultdict ( set ) <NEWLINE> ( n , m ) = get_ints ( ) <NEWLINE> visited = [ 0 ] * n <NEWLINE> <NL> <NL> def dfs ( i , l , par ) : <NEWLINE> <INDENT> global visited <NEWLINE> visited [ i ] = True <NEWLINE> l . append ( i ) <NEWLINE> for j in g [ i ] : <NEWLINE> <INDENT> if j != par and not visited [ j ] : <NEWLINE> <INDENT> dfs ( j , l , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ( u , v ) = get_ints ( ) <NEWLINE> g [ u - 1 ] . add ( v - 1 ) <NEWLINE> g [ v - 1 ] . add ( u - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> l = [ ] <NEWLINE> dfs ( i , l , - 1 ) <NEWLINE> ans = max ( ans , len ( l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> N = INT ( ) <NEWLINE> AB = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> <NL> A , B = zip ( * AB ) <NEWLINE> A = list ( A ) <NEWLINE> B = list ( B ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if N % 2 : <NEWLINE> <INDENT> a = A [ N // 2 ] <NEWLINE> b = B [ N // 2 ] <NEWLINE> print ( b - a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( A [ N // 2 - 1 ] + A [ N // 2 ] ) / 2 <NEWLINE> b = ( B [ N // 2 - 1 ] + B [ N // 2 ] ) / 2 <NEWLINE> print ( int ( ( b - a ) * 2 + 1 ) ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> A_N = [ [ i ] for i in range ( 1 , M + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for j in range ( len ( A_N ) ) : <NEWLINE> <INDENT> last = A_N [ j ] [ - 1 ] <NEWLINE> for k in range ( last , M + 1 ) : <NEWLINE> <INDENT> a . append ( A_N [ j ] + [ k ] ) <NEWLINE> <DEDENT> <DEDENT> A_N = a <NEWLINE> <NL> <DEDENT> high_score = 0 <NEWLINE> for i in range ( len ( A_N ) ) : <NEWLINE> <INDENT> A = A_N [ i ] <NEWLINE> score = 0 <NEWLINE> for j in range ( len ( l ) ) : <NEWLINE> <INDENT> aj , bj , cj , dj = l [ j ] <NEWLINE> if A [ bj - 1 ] - A [ aj - 1 ] == cj : <NEWLINE> <INDENT> score += dj <NEWLINE> <DEDENT> <DEDENT> if high_score < score : <NEWLINE> <INDENT> high_score = score <NEWLINE> <NL> <DEDENT> <DEDENT> print ( high_score ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> MAX = A [ - 1 ] + 1 <NEWLINE> num_tmp = [ 0 ] * MAX <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> num_tmp [ a ] += 1 <NEWLINE> if num_tmp [ a ] == 1 : <NEWLINE> <INDENT> for i in range ( 2 * a , MAX , a ) : <NEWLINE> <INDENT> num_tmp [ i ] = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num_tmp . count ( 1 ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> n = 1 <NEWLINE> x = 7 <NEWLINE> <NL> <NL> if ( K % 2 == 0 ) or ( K % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> if x % K == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> x = ( x * 10 + 7 ) % K <NEWLINE> n += 1 <NEWLINE> <COMMENT> <NL> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> elif x == 1 or y == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> G = [ ] <NEWLINE> i , j = 1 , 1 <NEWLINE> while i < 201 : <NEWLINE> <INDENT> j = 1 <NEWLINE> g0 = [ ] <NEWLINE> while j < 201 : <NEWLINE> <INDENT> g0 . append ( gcd ( i , j ) ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> g0 = tuple ( g0 ) <NEWLINE> G . append ( g0 ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> j = 1 <NEWLINE> k = 1 <NEWLINE> ans = 0 <NEWLINE> while i < n + 1 : <NEWLINE> <INDENT> j = 1 <NEWLINE> while j < n + 1 : <NEWLINE> <INDENT> k = 1 <NEWLINE> p = G [ i - 1 ] [ j - 1 ] <NEWLINE> while k < n + 1 : <NEWLINE> <INDENT> ans += G [ k - 1 ] [ p - 1 ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> from collections import Counter <NEWLINE> cnt = Counter ( a ) <NEWLINE> <NL> for i , j in s : <NEWLINE> <INDENT> if j in cnt : <NEWLINE> <INDENT> cnt [ j ] += cnt [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ j ] = cnt [ i ] <NEWLINE> <DEDENT> ans = ans - i * cnt [ i ] + cnt [ i ] * j <NEWLINE> if i in cnt : <NEWLINE> <INDENT> cnt . pop ( i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> HSum = [ 0 for _ in range ( H ) ] <NEWLINE> WSum = [ 0 for _ in range ( W ) ] <NEWLINE> <NL> <NL> bombs = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> hi , wi = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> HSum [ hi ] += 1 <NEWLINE> WSum [ wi ] += 1 <NEWLINE> bombs . add ( ( hi , wi ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> curMax = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> hMax = max ( HSum ) <NEWLINE> wMax = max ( WSum ) <NEWLINE> tmpMax = hMax + wMax <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> hSumMaxOnly = [ h for h , x in enumerate ( HSum ) if x == hMax ] <NEWLINE> wSumMaxOnly = [ w for w , y in enumerate ( WSum ) if y == wMax ] <NEWLINE> <NL> for h in hSumMaxOnly : <NEWLINE> <INDENT> if ans == tmpMax : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for w in wSumMaxOnly : <NEWLINE> <INDENT> if ( h , w ) in bombs : <NEWLINE> <INDENT> ans = tmpMax - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = tmpMax <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> good = list ( range ( 1 , N + 1 ) ) <NEWLINE> good = [ 1 ] * N <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> good [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> good [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a - 1 ] == H [ b - 1 ] : <NEWLINE> <INDENT> good [ a - 1 ] = 0 <NEWLINE> good [ b - 1 ] = 0 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( sum ( good ) ) <NEWLINE>
t = input ( ) <NEWLINE> p = input ( ) <NEWLINE> l_t = len ( t ) <NEWLINE> l_p = len ( p ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( l_t - l_p + 1 ) : <NEWLINE> <INDENT> if t [ i : i + l_p ] == p : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def iif ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def lmif ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def ss ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> mod = 1000000007 <NEWLINE> <NL> F = [ 1 , 1 ] <NEWLINE> for i in range ( 100000 ) : <NEWLINE> <INDENT> F . append ( F [ i ] + F [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> N , M = mi ( ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( F [ N ] % mod ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> A = iif ( M ) <NEWLINE> DA = [ ] <NEWLINE> left = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> da = A [ i ] - left <NEWLINE> if da == 0 and left != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DA . append ( da - 1 ) <NEWLINE> <DEDENT> left = A [ i ] + 1 <NEWLINE> <DEDENT> if A [ - 1 ] != N : <NEWLINE> <INDENT> DA . append ( N - A [ - 1 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> for i in DA : <NEWLINE> <INDENT> ans *= F [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<NL> class TreeNode : <NEWLINE> <INDENT> def __init__ ( self , nodeid ) : <NEWLINE> <INDENT> self . nodeid = nodeid <NEWLINE> self . parent = None <NEWLINE> self . sibling = None <NEWLINE> self . child = None <NEWLINE> self . depth = 0 <NEWLINE> <NL> <DEDENT> def node_type ( self ) : <NEWLINE> <INDENT> if self . parent is None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif self . child is None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def parent_nodeid ( self ) : <NEWLINE> <INDENT> if self . parent is None : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . parent . nodeid <NEWLINE> <NL> <DEDENT> <DEDENT> def child_nodeids ( self ) : <NEWLINE> <INDENT> if self . child is not None : <NEWLINE> <INDENT> yield self . child . nodeid <NEWLINE> yield from self . child . sibling_nodeids ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def sibling_nodeids ( self ) : <NEWLINE> <INDENT> s = self . sibling <NEWLINE> stack = [ ] <NEWLINE> while s is not None : <NEWLINE> <INDENT> stack . append ( s . nodeid ) <NEWLINE> s = s . sibling <NEWLINE> <DEDENT> while len ( stack ) > 0 : <NEWLINE> <INDENT> yield stack . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_depth ( self ) : <NEWLINE> <INDENT> if self . node_type ( ) != <STRING> and self . depth == 0 : <NEWLINE> <INDENT> self . depth = self . parent . get_depth ( ) + 1 <NEWLINE> <NL> <DEDENT> return self . depth <NEWLINE> <NL> <DEDENT> def add_child ( self , node ) : <NEWLINE> <INDENT> if self . child is None : <NEWLINE> <INDENT> self . child = node <NEWLINE> self . child . parent = self <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . child . add_sibling ( node ) <NEWLINE> <NL> <DEDENT> <DEDENT> def add_sibling ( self , node ) : <NEWLINE> <INDENT> node . parent = self . parent <NEWLINE> node . sibling = self . sibling <NEWLINE> self . sibling = node <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return ( <STRING> . format ( <NEWLINE> <INDENT> self . nodeid , self . parent_nodeid ( ) , self . get_depth ( ) , <NEWLINE> self . node_type ( ) , <NEWLINE> <STRING> . join ( [ str ( i ) for i in self . child_nodeids ( ) ] ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Tree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nodes = { } <NEWLINE> <NL> <DEDENT> def node ( self , nodeid ) : <NEWLINE> <INDENT> if nodeid not in self . nodes : <NEWLINE> <INDENT> self . nodes [ nodeid ] = TreeNode ( nodeid ) <NEWLINE> <NL> <DEDENT> return self . nodes [ nodeid ] <NEWLINE> <NL> <DEDENT> def sorted_nodes ( self ) : <NEWLINE> <INDENT> for nodeid in sorted ( self . nodes . keys ( ) ) : <NEWLINE> <INDENT> yield self . nodes [ nodeid ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> tree = Tree ( ) <NEWLINE> <NL> for _ in range ( c ) : <NEWLINE> <INDENT> nodeid , deg , * cs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> node = tree . node ( nodeid ) <NEWLINE> for c in cs : <NEWLINE> <INDENT> node . add_child ( tree . node ( c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for node in tree . sorted_nodes ( ) : <NEWLINE> <INDENT> print ( node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( reverse = True ) <NEWLINE> ans = l [ - 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = collections . Counter ( a [ 0 : : 2 ] ) . most_common ( ) <NEWLINE> a2 = collections . Counter ( a [ 1 : : 2 ] ) . most_common ( ) <NEWLINE> a1 . append ( ( 0 , 0 ) ) <NEWLINE> a2 . append ( ( 0 , 0 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if a1 [ 0 ] != a2 [ 0 ] : <NEWLINE> <INDENT> print ( n - a1 [ 0 ] [ 1 ] - a2 [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n - a1 [ 0 ] [ 1 ] - a2 [ 1 ] [ 1 ] , n - a1 [ 1 ] [ 1 ] - a2 [ 0 ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> left = 0 <NEWLINE> right = N - 1 <NEWLINE> <NL> while left < right : <NEWLINE> <INDENT> if c [ left ] == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> if left >= right : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if c [ right ] == <STRING> : <NEWLINE> <INDENT> c [ right ] = <STRING> <NEWLINE> c [ left ] = <STRING> <NEWLINE> counter += 1 <NEWLINE> right -= 1 <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> left += 1 <NEWLINE> <NL> <DEDENT> print ( counter ) <NEWLINE>
[ N , K ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> st = 0 <NEWLINE> la = K <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ la ] > A [ st ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> st += 1 <NEWLINE> la += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> product = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> product = product * p [ i ] <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( product ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( n % k , abs ( k - n % k ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> flg = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] % 10 != 0 : <NEWLINE> <INDENT> ans -= a [ i ] <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) if flg else print ( 0 ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> data . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> next_data = [ ] <NEWLINE> <COMMENT> <NL> for d in data : <NEWLINE> <INDENT> if <STRING> in d : <NEWLINE> <INDENT> next_data . append ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> next_next_data = [ ] <NEWLINE> origin_v_data = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( len ( next_data [ 0 ] ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> v_data = [ ] <NEWLINE> for j in range ( len ( next_data ) ) : <NEWLINE> <INDENT> v_data . append ( next_data [ j ] [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if <STRING> in v_data : <NEWLINE> <INDENT> origin_v_data . append ( v_data ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans_data = [ ] <NEWLINE> for i in range ( len ( origin_v_data [ 0 ] ) ) : <NEWLINE> <INDENT> join_data = [ ] <NEWLINE> for j in range ( len ( origin_v_data ) ) : <NEWLINE> <INDENT> join_data . append ( origin_v_data [ j ] [ i ] ) <NEWLINE> <DEDENT> ans_data . append ( join_data ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for a in ans_data : <NEWLINE> <INDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> kind = int ( input ( ) ) <NEWLINE> for i in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> a [ i - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a . count ( 0 ) if 0 in a else 0 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> def gcd ( a , b , c ) : <NEWLINE> <INDENT> gcd1 = 1 <NEWLINE> if a % c == 0 and b % c == 0 : <NEWLINE> <INDENT> gcd1 = c <NEWLINE> <DEDENT> elif a % 2 == 0 and b % 2 == 0 and c % 2 == 0 : <NEWLINE> <INDENT> gcd1 = 2 <NEWLINE> for i in range ( 4 , c // 2 + 1 , 2 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 and c % i == 0 : <NEWLINE> <INDENT> gcd1 = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , c // 2 + 1 , 2 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 and c % i == 0 : <NEWLINE> <INDENT> gcd1 = i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return gcd1 <NEWLINE> <NL> <DEDENT> sum_gcd = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> sum_gcd += gcd ( a , b , c ) <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> sum_gcd += 3 * gcd ( a , b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_gcd += 6 * gcd ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum_gcd ) <NEWLINE>
<NL> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a == 0 and b == 0 ) : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> r_indices = tuple ( [ i for i in range ( N ) if S [ i ] == <STRING> ] ) <NEWLINE> g_indices = tuple ( [ i for i in range ( N ) if S [ i ] == <STRING> ] ) <NEWLINE> b_indices = tuple ( [ i for i in range ( N ) if S [ i ] == <STRING> ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> avoid = 0 <NEWLINE> <NL> for center in range ( 1 , N - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> for width in range ( 1 , min ( center + 1 , N - center ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> little = center - width <NEWLINE> great = center + width <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if S [ little ] != S [ great ] and S [ center ] != S [ great ] and S [ little ] != S [ center ] : <NEWLINE> <INDENT> avoid += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> total = len ( r_indices ) * len ( g_indices ) * len ( b_indices ) <NEWLINE> <NL> print ( total - avoid ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math ; r = float ( input ( ) ) ; print ( math . pi * ( r ** 2 ) , math . pi * r * 2 ) <NEWLINE>
s , f = input ( ) [ : : - 1 ] , - 1 <NEWLINE> while f < 0 : <NEWLINE> <INDENT> if s : <NEWLINE> <INDENT> if s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> <DEDENT> elif s [ : 5 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 5 : ] <NEWLINE> <DEDENT> elif s [ : 6 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 6 : ] <NEWLINE> <DEDENT> elif s [ : 7 ] == <STRING> : <NEWLINE> <INDENT> s = s [ 7 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ f ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : break <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans -= cnt <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> def g ( n ) : <NEWLINE> <INDENT> return ( n * ( n + 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> total += i * g ( N // i ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> com = input ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( com [ 1 ] ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( com [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( q ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = { } <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if x in ans . keys ( ) : <NEWLINE> <INDENT> ans [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans . get ( i , 0 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( sys . stdin . readline ( ) ) <NEWLINE> if N < 6 : <NEWLINE> <INDENT> x , y , z = 0 , 0 , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( ( N / 6 ) ** 0.5 ) <NEWLINE> y = int ( round ( ( ( ( ( N - 1 ) / 3 ) - 1 / 9 ) ** 0.5 - 1 / 3 ) + 0.5 , 0 ) ) <NEWLINE> z = int ( ( N - 5 ) ** 0.5 + 1 ) <NEWLINE> <DEDENT> n = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( i , y + 1 ) : <NEWLINE> <INDENT> for k in range ( j , z + 1 ) : <NEWLINE> <INDENT> p = int ( ( i + j + k ) ** 2 - i * ( j + k ) - j * k ) <NEWLINE> if N < p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == j : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> n [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n [ p ] += 3 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> n [ p ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> n [ p ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n [ p ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( n [ i ] ) <NEWLINE> <DEDENT>
line = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( line [ 0 ] ) <NEWLINE> B = int ( line [ 1 ] ) <NEWLINE> N = int ( line [ 2 ] ) <NEWLINE> max = 0 <NEWLINE> if B < N : <NEWLINE> <INDENT> K = B <NEWLINE> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> if max < ( int ( A * ( K + i ) / B ) - A * int ( ( K + i ) / B ) ) : <NEWLINE> <INDENT> max = int ( A * ( K + i ) / B ) - A * int ( ( K + i ) / B ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> K = N <NEWLINE> for i in range ( - 1 , 1 ) : <NEWLINE> <INDENT> if max < ( int ( A * ( K + i ) / B ) - A * int ( ( K + i ) / B ) ) : <NEWLINE> <INDENT> max = int ( A * ( K + i ) / B ) - A * int ( ( K + i ) / B ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> c = 1 <NEWLINE> e = 0 <NEWLINE> for d in range ( a ) : <NEWLINE> <INDENT> c = c * b [ 0 ] <NEWLINE> b . pop ( 0 ) <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> e = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if e == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A . sort ( ) <NEWLINE> res = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> res *= A [ i ] <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> import re <NEWLINE> import copy <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ceil = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if all ( [ b > 0 for b in a ] ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > ceil : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if any ( [ b == 0 for b in a ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ans > ceil : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> P = [ ( A [ i ] , i + 1 ) for i in range ( N ) ] <NEWLINE> P . sort ( reverse = True ) <NEWLINE> <NL> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for n , p in zip ( range ( 1 , N + 1 ) , P ) : <NEWLINE> <INDENT> x , y = p <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = n - 1 - i <NEWLINE> left = dp [ i ] [ j ] + x * abs ( y - ( i + 1 ) ) <NEWLINE> dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , left ) <NEWLINE> right = dp [ i ] [ j ] + x * abs ( y - ( N - j ) ) <NEWLINE> dp [ i ] [ j + 1 ] = max ( dp [ i ] [ j + 1 ] , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( [ dp [ i ] [ N - i ] for i in range ( N ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> s_dict = { } <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( x == y ) : <NEWLINE> <INDENT> L . append ( x ) <NEWLINE> s_dict [ ( x , y ) ] = x <NEWLINE> <DEDENT> elif ( x % y == 0 ) : <NEWLINE> <INDENT> L . append ( y ) <NEWLINE> s_dict [ ( x , y ) ] = y <NEWLINE> <DEDENT> elif ( y % x == 0 ) : <NEWLINE> <INDENT> L . append ( x ) <NEWLINE> s_dict [ ( x , y ) ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = gcd ( x , y ) <NEWLINE> L . append ( tmp ) <NEWLINE> s_dict [ ( x , y ) ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x in L : <NEWLINE> <INDENT> for z in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += s_dict [ ( x , z ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import string <NEWLINE> import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = n <NEWLINE> l = list ( string . ascii_lowercase ) <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> s -= 26 ** i <NEWLINE> if s <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> n_list = [ ] <NEWLINE> answer = [ ] <NEWLINE> for i in reversed ( range ( 1 , count + 1 ) ) : <NEWLINE> <INDENT> number = min ( 26 , n // 26 ** ( i - 1 ) ) <NEWLINE> n -= number * 26 ** ( i - 1 ) <NEWLINE> n_list . append ( number ) <NEWLINE> <DEDENT> n_l = [ ] <NEWLINE> for i , x in enumerate ( reversed ( n_list ) ) : <NEWLINE> <INDENT> if x <= 0 : <NEWLINE> <INDENT> n_l . append ( x + 26 ) <NEWLINE> n_list [ - ( i + 2 ) ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_l . append ( x ) <NEWLINE> <DEDENT> <DEDENT> for i in reversed ( n_l ) : <NEWLINE> <INDENT> answer . append ( l [ i - 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( answer ) ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> map_ = [ - 1 ] * 2019 <NEWLINE> map_ [ 0 ] = 0 <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> now = ( now + int ( S [ N - i - 1 ] ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> map_ [ now ] += 1 <NEWLINE> ans += map_ [ now ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> input = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( input ) ) : <NEWLINE> <INDENT> if ( input [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> multi = 1 <NEWLINE> for i in range ( len ( input ) ) : <NEWLINE> <INDENT> multi *= input [ i ] <NEWLINE> if ( multi > ( 10 ** 18 ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( multi ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> button = [ 0 ] * N <NEWLINE> button [ 0 ] = 1 <NEWLINE> next_button = 1 <NEWLINE> i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> button [ next_button - 1 ] = 2 <NEWLINE> next_button = A [ next_button - 1 ] <NEWLINE> if button [ next_button - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif next_button == 2 : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> button [ next_button - 1 ] = 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> n = len ( x ) <NEWLINE> <NL> t = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> elif t > 0 and x [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - 2 * cnt ) <NEWLINE>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def dfs ( v , visited , edges , order ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for to in edges [ v ] : <NEWLINE> <INDENT> if not visited [ to ] : <NEWLINE> <INDENT> dfs ( to , visited , edges , order ) <NEWLINE> <DEDENT> <DEDENT> order . append ( v ) <NEWLINE> <NL> <DEDENT> def search_strongly_connection ( v , visited , reverse_edges , parent ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for to in reverse_edges [ v ] : <NEWLINE> <INDENT> if not visited [ to ] : <NEWLINE> <INDENT> parent [ to ] = v <NEWLINE> search_strongly_connection ( to , visited , reverse_edges , parent ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( parent , x ) : <NEWLINE> <INDENT> if parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> tmp = find ( parent , parent [ x ] ) <NEWLINE> parent [ x ] = tmp <NEWLINE> return tmp <NEWLINE> <NL> <DEDENT> v_num , e_num = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( v_num ) ] <NEWLINE> reverse_edges = [ [ ] for _ in range ( v_num ) ] <NEWLINE> for _ in range ( e_num ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ s ] . append ( t ) <NEWLINE> reverse_edges [ t ] . append ( s ) <NEWLINE> <NL> <NL> <DEDENT> order = [ ] <NEWLINE> visited = [ False ] * v_num <NEWLINE> for v in range ( v_num ) : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> dfs ( v , visited , edges , order ) <NEWLINE> <DEDENT> <DEDENT> order . reverse ( ) <NEWLINE> <NL> <NL> visited = [ False ] * v_num <NEWLINE> parent = [ i for i in range ( v_num ) ] <NEWLINE> for v in order : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> search_strongly_connection ( v , visited , reverse_edges , parent ) <NEWLINE> <NL> <DEDENT> <DEDENT> q_num = int ( input ( ) ) <NEWLINE> for _ in range ( q_num ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if find ( parent , u ) == find ( parent , v ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> timeA = H + ( M / 60 ) <NEWLINE> argA = ( 1 / 12 ) * timeA <NEWLINE> <NL> argB = ( 1 / 60 ) * M <NEWLINE> <NL> <NL> sitaA = 360 * argA <NEWLINE> sitaB = 360 * argB <NEWLINE> <NL> <NL> <NL> if abs ( sitaA - sitaB ) == 180 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if sitaA == sitaB : <NEWLINE> <INDENT> print ( abs ( B - A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif sitaA > sitaB : <NEWLINE> <INDENT> c = math . sqrt ( A ** 2 + B ** 2 - ( 2 * A * B * math . cos ( math . radians ( sitaA - sitaB ) ) ) ) <NEWLINE> <DEDENT> elif sitaA < sitaB : <NEWLINE> <INDENT> c = math . sqrt ( A ** 2 + B ** 2 - ( 2 * A * B * math . cos ( math . radians ( sitaB - sitaA ) ) ) ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for r in range ( 0 , int ( N // R ) + 1 ) : <NEWLINE> <INDENT> for g in range ( 0 , int ( ( N - R * r ) // G ) + 1 ) : <NEWLINE> <INDENT> if ( N - R * r - G * g ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in list ( range ( N ) ) ] <NEWLINE> maxv = - 1000000000 <NEWLINE> minr = R [ 0 ] <NEWLINE> <NL> for i in list ( range ( 1 , N ) ) : <NEWLINE> <INDENT> maxv = max ( maxv , R [ i ] - minr ) <NEWLINE> minr = min ( minr , R [ i ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> answer = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> answer += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
from collections import Counter <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> blist = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> blist_set = set ( map ( tuple , blist ) ) <NEWLINE> <NL> rowdict = Counter ( [ blist [ i ] [ 0 ] for i in range ( m ) ] ) <NEWLINE> coldict = Counter ( [ blist [ i ] [ 1 ] for i in range ( m ) ] ) <NEWLINE> <NL> maxr = rowdict . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> maxr_keys = [ ] <NEWLINE> for i in rowdict . most_common ( ) : <NEWLINE> <INDENT> if i [ 1 ] == maxr : <NEWLINE> <INDENT> maxr_keys . append ( i [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> maxc = coldict . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> maxc_keys = [ ] <NEWLINE> for i in coldict . most_common ( ) : <NEWLINE> <INDENT> if i [ 1 ] == maxc : <NEWLINE> <INDENT> maxc_keys . append ( i [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in maxr_keys : <NEWLINE> <INDENT> for j in maxc_keys : <NEWLINE> <INDENT> if ( i , j ) not in blist_set : <NEWLINE> <INDENT> print ( maxr + maxc ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxr + maxc - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> table = { } <NEWLINE> for num in l : <NEWLINE> <INDENT> if num in table : <NEWLINE> <INDENT> table [ num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ num ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> tot = 0 <NEWLINE> for num in l : <NEWLINE> <INDENT> tot += num <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in table : <NEWLINE> <INDENT> if c in table : <NEWLINE> <INDENT> table [ c ] += table [ b ] <NEWLINE> tot += table [ b ] * ( c - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ c ] = table [ b ] <NEWLINE> tot += table [ b ] * ( c - b ) <NEWLINE> <DEDENT> <DEDENT> table [ b ] = 0 <NEWLINE> print ( tot ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> import sys <NEWLINE> si = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( si ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for r in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cnt += gcd ( p , gcd ( q , r ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> StringList = [ ] <NEWLINE> for TSt in range ( 0 , N ) : <NEWLINE> <INDENT> for TEd in range ( TSt + 1 , TSt + K + 1 ) : <NEWLINE> <INDENT> StringList . append ( S [ TSt : TEd ] ) <NEWLINE> <DEDENT> <DEDENT> SetString = sorted ( set ( StringList ) ) <NEWLINE> print ( SetString [ K - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = [ 0 for i in range ( n + 1 ) ] <NEWLINE> q = list ( ) <NEWLINE> q2 = list ( ) <NEWLINE> <NL> g = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> q2 . append ( 1 ) <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> q = q2 <NEWLINE> q2 = [ ] <NEWLINE> <NL> while len ( q ) : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> <NL> for nv in g [ v ] : <NEWLINE> <INDENT> if p [ nv ] == 0 : <NEWLINE> <INDENT> p [ nv ] = v <NEWLINE> g [ nv ] . remove ( v ) <NEWLINE> q2 . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( q2 ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in p [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for q in p [ 2 : ] : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from pprint import pprint as pp <NEWLINE> from pprint import pformat as pf <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> from fractions import Fraction <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def is_same_sign ( a , b ) : <NEWLINE> <INDENT> if a > 0 and b > 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if a < 0 and b < 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def fraction_taple ( a , b ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> if is_same_sign ( a , b ) : <NEWLINE> <INDENT> s = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = - 1 <NEWLINE> <DEDENT> a = abs ( a ) // g <NEWLINE> b = abs ( b ) // g <NEWLINE> return ( s , a , b ) <NEWLINE> <NL> <DEDENT> def mode ( a , b ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> return 0 , 0 <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> return <STRING> , 0 <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> return <STRING> , 1 <NEWLINE> <DEDENT> x = fraction_taple ( a , b ) <NEWLINE> y = fraction_taple ( - 1 * b , a ) <NEWLINE> if x > y : <NEWLINE> <INDENT> return x , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return y , 1 <NEWLINE> <NL> <DEDENT> <DEDENT> MOD = 1000000007 <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> d = defaultdict ( lambda : [ 0 , 0 ] ) <NEWLINE> zero = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dkey , akey = mode ( a , b ) <NEWLINE> if dkey == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ dkey ] [ akey ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for pair in d . values ( ) : <NEWLINE> <INDENT> tmp = pow ( 2 , pair [ 0 ] , MOD ) - 1 + pow ( 2 , pair [ 1 ] , MOD ) - 1 + 1 <NEWLINE> ans *= tmp <NEWLINE> <DEDENT> ans += zero - 1 <NEWLINE> ans %= MOD <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT>
def f ( a , b , n ) : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Max = 0 <NEWLINE> step = 1 if b // a == 0 else b // a <NEWLINE> for x in range ( b // a , n + step , step ) : <NEWLINE> <INDENT> res = ( a * x ) // b - a * ( x // b ) <NEWLINE> if res > Max : <NEWLINE> <INDENT> Max = res <NEWLINE> <DEDENT> <DEDENT> print ( Max ) <NEWLINE> <NL> <DEDENT> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) ; f ( a , b , n ) <NEWLINE>
from heapq import * <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> heapify ( A ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> heappush ( A , int ( heappop ( A ) / 2 ) ) <NEWLINE> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) <NEWLINE> a1 , b1 , c1 = 2 * ( x2 - x1 ) , 2 * ( y2 - y1 ) , ( x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2 ) <NEWLINE> a2 , b2 , c2 = 2 * ( x3 - x1 ) , 2 * ( y3 - y1 ) , ( x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2 ) <NEWLINE> <NL> p1 = ( b1 * c2 - b2 * c1 ) / ( a1 * b2 - a2 * b1 ) <NEWLINE> p2 = ( c1 * a2 - c2 * a1 ) / ( a1 * b2 - a2 * b1 ) <NEWLINE> r = math . hypot ( x1 - p1 , y1 - p2 ) <NEWLINE> temp = [ p1 , p2 , r ] <NEWLINE> ans = map ( lambda x : round ( x , 3 ) , temp ) <NEWLINE> print ( <STRING> % ( temp [ 0 ] , temp [ 1 ] , temp [ 2 ] ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s , q = deque ( [ * input ( ) ] ) , int ( input ( ) ) <NEWLINE> judge = False <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> if len ( t ) == 1 : <NEWLINE> <INDENT> judge = not judge <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t , f , c = t <NEWLINE> if not judge and f == <STRING> : s . appendleft ( c ) <NEWLINE> elif not judge and f == <STRING> : s . append ( c ) <NEWLINE> elif judge and f == <STRING> : s . append ( c ) <NEWLINE> else : s . appendleft ( c ) <NEWLINE> <DEDENT> <DEDENT> if judge : s . reverse ( ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> min = int ( c * d / math . gcd ( c , d ) ) <NEWLINE> x = b - b // c - b // d + b // min <NEWLINE> y = a - 1 - ( a - 1 ) // c - ( a - 1 ) // d + ( a - 1 ) // min <NEWLINE> <NL> print ( int ( x - y ) ) <NEWLINE>
from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ld = deque ( l ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( n - 2 ) : <NEWLINE> <INDENT> l_a = ld . popleft ( ) <NEWLINE> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> cnt += bisect_left ( l , l_a + l [ b ] ) - b - 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min_x = 1 <NEWLINE> max_x = N <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> y = ( A * x ) // B - A * ( x // B ) <NEWLINE> return y <NEWLINE> <NL> <DEDENT> ans = f ( min ( B - 1 , N ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> d = { 0 : 1 , 1 : 1 , 2 : 2 } <NEWLINE> def countcombi ( n ) : <NEWLINE> <INDENT> if n in d : <NEWLINE> <INDENT> return d [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ n ] = countcombi ( n - 1 ) + countcombi ( n - 2 ) <NEWLINE> return d [ n ] <NEWLINE> <DEDENT> <DEDENT> N , M = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> a_now = 0 <NEWLINE> a_before = 0 <NEWLINE> ans = 1 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a_now = int ( input ( ) . rstrip ( ) ) <NEWLINE> if a_now - a_before == 0 and a_before != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> ans = ( ans * countcombi ( a_now - a_before - 1 ) ) % 1_000_000_007 <NEWLINE> a_before = a_now + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_now = N <NEWLINE> ans = ( ans * countcombi ( a_now - a_before ) ) % 1_000_000_007 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> point = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . append ( b - 1 ) <NEWLINE> tree [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> stack = [ [ 0 , 0 , - 1 ] ] <NEWLINE> while stack : <NEWLINE> <INDENT> v , p , parent = stack . pop ( ) <NEWLINE> point [ v ] += p <NEWLINE> for child in tree [ v ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack . append ( [ child , point [ v ] , v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * point ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> def fx ( raw ) : <NEWLINE> <INDENT> min_n = raw [ 0 ] <NEWLINE> max_n = raw [ 1 ] - raw [ 0 ] <NEWLINE> for i in raw [ 1 : ] : <NEWLINE> <INDENT> if i - min_n >= max_n : <NEWLINE> <INDENT> max_n = i - min_n <NEWLINE> <DEDENT> if i < min_n : <NEWLINE> <INDENT> min_n = i <NEWLINE> <DEDENT> <DEDENT> return max_n <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( fx ( m ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if cnt [ i ] < 1 : <NEWLINE> <INDENT> multiple = 2 <NEWLINE> while i * multiple <= 10 ** 6 : <NEWLINE> <INDENT> cnt [ multiple * i ] += 1 <NEWLINE> multiple += 1 <NEWLINE> <DEDENT> <DEDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if cnt [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def partition ( p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <COMMENT> <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A_tmp = A [ i ] <NEWLINE> A [ i ] = A [ j ] <NEWLINE> A [ j ] = A_tmp <NEWLINE> <DEDENT> <DEDENT> t = A [ i + 1 ] <NEWLINE> A [ i + 1 ] = A [ r ] <NEWLINE> A [ r ] = t <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> q = partition ( 0 , n - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if i == q : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ i ] , end = <STRING> ) <NEWLINE> if i == q : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = { } <NEWLINE> for val in A : <NEWLINE> <INDENT> if val in count : <NEWLINE> <INDENT> count [ val ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ val ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> diff = len ( set ( A ) ) - K <NEWLINE> if diff > 0 : <NEWLINE> <INDENT> count_sorted = sorted ( count . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> for k , v in count_sorted : <NEWLINE> <INDENT> ans += v <NEWLINE> diff -= 1 <NEWLINE> if diff == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def iwa_check ( start , end ) : <NEWLINE> <INDENT> for i in range ( start , end ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s = [ <STRING> ] + s + [ <STRING> ] <NEWLINE> <NL> <COMMENT> <NL> if not iwa_check ( a , c ) or not iwa_check ( b , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if c > d : <NEWLINE> <INDENT> ok = False <NEWLINE> for i in range ( b , d + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ok = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from itertools import combinations <NEWLINE> from heapq import heappop , heappush <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> <NL> def convert ( s , m , n ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> return int ( s [ 1 : ] ) + 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> return int ( s [ 1 : ] ) + m + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def get_cost ( start , m , n , edges ) : <NEWLINE> <INDENT> cost = [ INF ] * ( m + n + 2 ) <NEWLINE> cost [ start ] = 0 <NEWLINE> que = [ ] <NEWLINE> heappush ( que , ( 0 , start ) ) <NEWLINE> while que : <NEWLINE> <INDENT> total , node = heappop ( que ) <NEWLINE> for dist , to in edges [ node ] : <NEWLINE> <INDENT> if cost [ to ] > total + dist : <NEWLINE> <INDENT> cost [ to ] = total + dist <NEWLINE> if not ( 2 <= to <= m + 1 ) : <NEWLINE> <INDENT> heappush ( que , ( total + dist , to ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <NL> <DEDENT> def shortest_path ( start , goal , rest , cakes_dist , dic ) : <NEWLINE> <INDENT> if not rest : <NEWLINE> <INDENT> return cakes_dist [ start ] [ goal ] <NEWLINE> <DEDENT> if ( start , rest ) in dic : <NEWLINE> <INDENT> return dic [ ( start , rest ) ] <NEWLINE> <NL> <DEDENT> ret = INF <NEWLINE> for to in rest : <NEWLINE> <INDENT> ret = min ( ret , shortest_path ( to , goal , tuple ( ( i for i in rest if i != to ) ) , cakes_dist , dic ) + cakes_dist [ start ] [ to ] ) <NEWLINE> <DEDENT> dic [ ( start , rest ) ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m , n , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> clst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <STRING> <NEWLINE> edges = [ [ ] for _ in range ( m + n + 2 ) ] <NEWLINE> for _ in range ( d ) : <NEWLINE> <INDENT> s , t , e = input ( ) . split ( ) <NEWLINE> e = int ( e ) <NEWLINE> s = convert ( s , m , n ) <NEWLINE> t = convert ( t , m , n ) <NEWLINE> edges [ s ] . append ( ( e , t ) ) <NEWLINE> edges [ t ] . append ( ( e , s ) ) <NEWLINE> <NL> <DEDENT> cakes_dist = [ [ INF ] * ( m + 2 ) for _ in range ( m + 2 ) ] <NEWLINE> for start in range ( m + 2 ) : <NEWLINE> <INDENT> cost = get_cost ( start , m , n , edges ) <NEWLINE> for to in range ( m + 2 ) : <NEWLINE> <INDENT> if to != start : <NEWLINE> <INDENT> cakes_dist [ start ] [ to ] = cost [ to ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> dic = { } <NEWLINE> ans = INF <NEWLINE> cakes = [ i for i in range ( 2 , m + 2 ) ] <NEWLINE> for num in range ( m + 1 ) : <NEWLINE> <INDENT> for rest in combinations ( cakes , num ) : <NEWLINE> <INDENT> cal = sum ( [ clst [ i - 2 ] for i in rest ] ) <NEWLINE> ans = min ( ans , shortest_path ( 0 , 1 , rest , cakes_dist , dic ) * k - cal ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ans = 0 <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> x = 7 % K <NEWLINE> num_list = [ ] <NEWLINE> <NL> for count in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> x = ( x * 10 + 7 ) % K <NEWLINE> <NL> <DEDENT> else : print ( - 1 ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = min ( A , K ) - max ( 0 , K - A - B ) <NEWLINE> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N - 1 ) >= ( K - 1 ) * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> x = [ 0. ] * 100 ; y = [ 0. ] * 100 <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : x [ i ] , y [ i ] = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> for i , j in itertools . product ( range ( 100 ) , range ( 100 ) ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if pow ( x [ k ] - ( i / 10 ) , 2 ) + pow ( y [ k ] - ( j / 10 ) , 2 ) <= 1.01 : c += 1 <NEWLINE> <DEDENT> if c > a : a = c <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> import collections <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ str ( i ) ] ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( a * ( 1 + a * ( 1 + a ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> o = 10 ** 18 <NEWLINE> r = 1 <NEWLINE> if 0 not in a : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> r *= i <NEWLINE> if r > o : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> r = 0 <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> a_sum = sum ( A ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a_sum -= A [ i ] <NEWLINE> answer += a_sum * A [ i ] <NEWLINE> <DEDENT> print ( str ( answer % mod ) ) <NEWLINE>
def pc ( x ) : <NEWLINE> <INDENT> return format ( x , <STRING> ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> Xo = int ( X , 2 ) <NEWLINE> <NL> count = 0 <NEWLINE> ans = 0 <NEWLINE> ori = pc ( Xo ) <NEWLINE> X = list ( X ) <NEWLINE> <NL> Xp = Xo % ( ori + 1 ) <NEWLINE> if ori == 1 : <NEWLINE> <INDENT> Xm = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Xm = Xo % ( ori - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ori == 1 and X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> ans = Xm - pow ( 2 , N - 1 - i , ori - 1 ) <NEWLINE> ans %= ori - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans = Xp + pow ( 2 , N - 1 - i , ori + 1 ) <NEWLINE> ans %= ori + 1 <NEWLINE> <DEDENT> <DEDENT> count = 1 <NEWLINE> while ans > 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans %= pc ( ans ) <NEWLINE> count += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( count ) <NEWLINE> count = 1 <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i + k >= n : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> pre = A [ i ] <NEWLINE> aft = A [ i + k ] <NEWLINE> if pre >= aft : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> P = 2019 <NEWLINE> ans = 0 <NEWLINE> <NL> count = [ 0 ] * P <NEWLINE> count [ 0 ] = 1 <NEWLINE> u = 0 <NEWLINE> <NL> for i , s in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> u = ( int ( s ) * pow ( 10 , i , P ) + u ) % P <NEWLINE> ans += count [ u ] <NEWLINE> count [ u ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( ( N - 1 ) * N // 2 ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 2019 <NEWLINE> for a in range ( L , min ( L + 2019 , R ) + 1 ) : <NEWLINE> <INDENT> for b in range ( L , min ( L + 2019 , R ) + 1 ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = min ( a * b % 2019 , ans ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> def gcd ( lst ) : <NEWLINE> <INDENT> return math . gcd ( math . gcd ( lst [ 0 ] , lst [ 1 ] ) , lst [ 2 ] ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> lst = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> itr = itertools . combinations_with_replacement ( lst , 3 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in itr : <NEWLINE> <INDENT> st = set ( i ) <NEWLINE> num = len ( st ) <NEWLINE> if num == 1 : <NEWLINE> <INDENT> ans += i [ 0 ] <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> a , b = st <NEWLINE> ans += math . gcd ( a , b ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i [ 0 ] , i [ 1 ] ) , i [ 2 ] ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ABCD = input ( ) . strip ( ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> ope = [ { 0 : <STRING> , 1 : <STRING> } [ ( i >> j ) & 1 ] for j in range ( 3 ) ] <NEWLINE> fomula = ABCD [ 0 ] + ope [ 0 ] + ABCD [ 1 ] + ope [ 1 ] + ABCD [ 2 ] + ope [ 2 ] + ABCD [ 3 ] <NEWLINE> if eval ( fomula ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> arrive_time = [ 0 ] * n <NEWLINE> time = 1 <NEWLINE> done = [ 0 ] * n <NEWLINE> done [ A [ 0 ] ] = 1 <NEWLINE> arrive_time [ A [ 0 ] ] = time <NEWLINE> last = 0 <NEWLINE> next = A [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> v = next <NEWLINE> if done [ A [ v ] ] == 0 : <NEWLINE> <INDENT> done [ A [ v ] ] = 1 <NEWLINE> time += 1 <NEWLINE> arrive_time [ A [ v ] ] = time <NEWLINE> next = A [ v ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = A [ v ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if time >= k : <NEWLINE> <INDENT> for i , a in enumerate ( arrive_time ) : <NEWLINE> <INDENT> if a == k : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> roop = time - arrive_time [ last ] + 1 <NEWLINE> nokori = ( k - arrive_time [ last ] ) % roop <NEWLINE> ans = nokori + arrive_time [ last ] <NEWLINE> for i , a in enumerate ( arrive_time ) : <NEWLINE> <INDENT> if a == ans : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> LR = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> pos = [ None ] * ( H * W ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> pos [ A [ i ] [ j ] - 1 ] = ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ 0 ] * ( H * W ) <NEWLINE> for i in range ( D , H * W ) : <NEWLINE> <INDENT> px , py = pos [ i - D ] <NEWLINE> x , y = pos [ i ] <NEWLINE> d [ i ] = d [ i - D ] + abs ( x - px ) + abs ( y - py ) <NEWLINE> <NL> <DEDENT> for l , r in LR : <NEWLINE> <INDENT> print ( d [ r - 1 ] - d [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> sosu = make_divisors ( n ) <NEWLINE> <COMMENT> <NL> kumi = [ ] <NEWLINE> for i in range ( len ( sosu ) ) : <NEWLINE> <INDENT> for j in range ( len ( sosu ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if sosu [ i ] * sosu [ j ] == n : <NEWLINE> <INDENT> kumi . append ( [ str ( sosu [ i ] ) , str ( sosu [ j ] ) ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> top = 10000000000 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in kumi [ : int ( len ( kumi ) / 2 ) + 2 ] : <NEWLINE> <INDENT> sums = max ( len ( i [ 0 ] ) , len ( i [ 1 ] ) ) <NEWLINE> if top > sums : <NEWLINE> <INDENT> top = sums <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( top ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> MAX_VALUE = int ( 1e4 + 1 ) <NEWLINE> <NL> <NL> def min_cost_sort ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( array_length ) : <NEWLINE> <INDENT> if check_order [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> current_index = i <NEWLINE> circle_sum , circle_min , circle_size = 0 , MAX_VALUE , 0 <NEWLINE> while True : <NEWLINE> <INDENT> check_order [ current_index ] = True <NEWLINE> circle_size += 1 <NEWLINE> current_value = array [ current_index ] <NEWLINE> circle_min = min ( circle_min , current_value ) <NEWLINE> circle_sum += current_value <NEWLINE> current_index = kv_reverse [ current_value ] <NEWLINE> if check_order [ current_index ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans += min ( circle_sum + ( circle_size - 2 ) * circle_min , <NEWLINE> <INDENT> circle_sum + circle_min + ( circle_size + 1 ) * min_value ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> array = list ( map ( int , _input [ 1 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> check_order = [ False ] * array_length <NEWLINE> kv_reverse = [ - 1 ] * MAX_VALUE <NEWLINE> compare_ans = sorted ( array ) <NEWLINE> min_value = compare_ans [ 0 ] <NEWLINE> for j in range ( array_length ) : <NEWLINE> <INDENT> kv_reverse [ compare_ans [ j ] ] = j <NEWLINE> <DEDENT> print ( min_cost_sort ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input ( ) <NEWLINE> dic = { } <NEWLINE> line = map ( lambda x : x . split ( ) , sys . stdin . readlines ( ) ) <NEWLINE> for i in line : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> dic [ i [ 1 ] ] = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if i [ 1 ] in dic else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> X = int ( a [ 0 ] ) <NEWLINE> N = int ( a [ 1 ] ) <NEWLINE> <NL> if N != 0 : <NEWLINE> <INDENT> Ls = input ( ) . split ( <STRING> ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( int ( Ls [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if X - i in L and X + i in L : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif X - i not in L : <NEWLINE> <INDENT> s = X - i <NEWLINE> break <NEWLINE> <DEDENT> elif X - i in L and X + i not in L : <NEWLINE> <INDENT> s = X + i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = X <NEWLINE> <NL> <NL> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> dataset = sys . stdin . readlines ( ) <NEWLINE> <NL> seq = 0 <NEWLINE> <NL> while dataset [ seq ] != <STRING> : <NEWLINE> <INDENT> s = dataset [ seq ] <NEWLINE> l = len ( s ) - 1 <NEWLINE> s = s [ : l ] <NEWLINE> seq += 1 <NEWLINE> n = dataset [ seq ] <NEWLINE> l = len ( n ) - 1 <NEWLINE> n = int ( n [ : l ] ) <NEWLINE> seq += 1 <NEWLINE> for i in range ( seq , seq + n ) : <NEWLINE> <INDENT> h = dataset [ i ] <NEWLINE> l = len ( h ) - 1 <NEWLINE> h = int ( h [ : l ] ) <NEWLINE> s = s [ h : ] + s [ 0 : h ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> seq += n <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> total = a <NEWLINE> k = k - a <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( total ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> k = k - b <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( total ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( total - k ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = np . zeros ( ( n , 2 ) ) <NEWLINE> sum1 = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> sum1 = sum1 + ( ( m [ j ] [ 0 ] - m [ k ] [ 0 ] ) ** 2 + ( m [ j ] [ 1 ] - m [ k ] [ 1 ] ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> mul = 1 <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> mul *= n - l <NEWLINE> <DEDENT> po = 0 <NEWLINE> if n == 2 : <NEWLINE> <INDENT> po = 1 <NEWLINE> <DEDENT> elif n == 3 : <NEWLINE> <INDENT> po = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for m in range ( n ) : <NEWLINE> <INDENT> po += m <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum1 * ( n - 1 ) / count <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC . append ( tmp ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> BC . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> j = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while A [ j ] < BC [ i ] [ 1 ] : <NEWLINE> <INDENT> A [ j ] = BC [ i ] [ 1 ] <COMMENT> <NEWLINE> j += 1 <NEWLINE> count += 1 <NEWLINE> if count == BC [ i ] [ 0 ] or j == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if j == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
def partiton ( A , p , r ) : <NEWLINE> <INDENT> x = A [ - 1 ] <NEWLINE> i = p - 1 <NEWLINE> <NL> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> _ = int ( input ( ) ) <NEWLINE> li = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> q = partiton ( li , 0 , len ( li ) - 1 ) <NEWLINE> <NL> <NL> li [ q ] = <STRING> % ( li [ q ] ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in li ] ) ) <NEWLINE>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . strip ( ) <NEWLINE> x = [ 0 for _ in [ 0 ] * 2020 ] <NEWLINE> x [ 0 ] , c = 1 , 0 <NEWLINE> m , d = 0 , 1 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> m += ( int ( i ) * d ) <NEWLINE> x [ m % 2019 ] += 1 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> <DEDENT> for v in x : c += v * ( v - 1 ) // 2 <NEWLINE> print ( c ) <NEWLINE> <DEDENT> if __name__ == <STRING> : main ( ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> res = 0 <NEWLINE> v = 10 ** 9 + 7 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> res += A [ i ] * S <NEWLINE> <DEDENT> print ( res % v ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import collections <NEWLINE> a = collections . deque ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> if b [ 0 ] == <STRING> : a . appendleft ( b [ 7 : ] ) <NEWLINE> elif b [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : a . remove ( b [ 7 : ] ) <NEWLINE> except : pass <NEWLINE> <DEDENT> elif len ( b ) > 10 : a . popleft ( ) <NEWLINE> elif len ( b ) > 6 : a . pop ( ) <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from itertools import product <NEWLINE> <NL> ans = 10 ** 9 <NEWLINE> <NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> problem = [ list ( map ( int , list ( input ( ) . split ( ) ) ) ) for i in range ( D ) ] <NEWLINE> <NL> for p in product ( [ True , False ] , repeat = D ) : <NEWLINE> <NL> <INDENT> point = 0 <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> point += ( i + 1 ) * 100 * problem [ i ] [ 0 ] + problem [ i ] [ 1 ] <NEWLINE> num += problem [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if point >= G : <NEWLINE> <INDENT> ans = min ( ans , num ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( D ) ) : <NEWLINE> <INDENT> if p [ i ] == False : <NEWLINE> <INDENT> if point >= G : <NEWLINE> <INDENT> ans = min ( ans , num ) <NEWLINE> break <NEWLINE> <DEDENT> for j in range ( problem [ i ] [ 0 ] ) : <NEWLINE> <INDENT> point += ( i + 1 ) * 100 <NEWLINE> num += 1 <NEWLINE> if point >= G : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if point >= G : <NEWLINE> <INDENT> ans = min ( ans , num ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import math <NEWLINE> <NL> A , B = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> c = math . gcd ( A , B ) <NEWLINE> if c == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ps = [ ] <NEWLINE> d = math . floor ( math . sqrt ( c ) ) <NEWLINE> for i in range ( 2 , d + 2 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> if all ( i % x != 0 for x in ps ) : <NEWLINE> <INDENT> ps . append ( i ) <NEWLINE> while c % i == 0 : <NEWLINE> <INDENT> c = c // i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if c > 1 : <NEWLINE> <INDENT> ps . append ( 0 ) <NEWLINE> <DEDENT> print ( len ( ps ) + 1 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> ans = ans * l [ i ] <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> base = 127 <NEWLINE> mask = ( 1 << 32 ) - 1 <NEWLINE> def calc_hash ( f , pl , tl ) : <NEWLINE> <INDENT> dl = tl - pl <NEWLINE> tmp = set ( ) <NEWLINE> t = 1 <NEWLINE> for _ in range ( pl ) : <NEWLINE> <INDENT> t = ( t * base ) & mask <NEWLINE> <DEDENT> e = 0 <NEWLINE> for i in range ( pl ) : <NEWLINE> <INDENT> e = ( e * base + f [ i ] ) & mask <NEWLINE> <DEDENT> for i in range ( dl ) : <NEWLINE> <INDENT> tmp . add ( e ) <NEWLINE> e = ( e * base - t * f [ i ] + f [ i + pl ] ) & mask <NEWLINE> <DEDENT> tmp . add ( e ) <NEWLINE> return tmp <NEWLINE> <DEDENT> t = tuple ( ord ( c ) for c in input ( ) ) <NEWLINE> tl = len ( t ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> h = dict ( ) <NEWLINE> c = dict ( ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p = readline ( ) . strip ( ) <NEWLINE> if p in c : <NEWLINE> <INDENT> a . append ( c [ p ] ) <NEWLINE> continue <NEWLINE> <DEDENT> p = tuple ( ord ( c ) for c in p ) <NEWLINE> pl = len ( p ) <NEWLINE> if pl > tl : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> bs = min ( 19 , pl ) <NEWLINE> keys = calc_hash ( p , bs , pl ) <NEWLINE> if bs not in h : <NEWLINE> <INDENT> h [ bs ] = calc_hash ( t , bs , tl ) <NEWLINE> <DEDENT> a . append ( 1 if keys . issubset ( h [ bs ] ) else 0 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> A = [ int ( a [ i ] ) for i in range ( N ) ] <NEWLINE> frag = [ 0 for i in range ( 60 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> j = 1 << i <NEWLINE> cnt = sum ( ( k & j ) >> i for k in A ) <NEWLINE> ans += ( cnt * ( N - cnt ) ) << i <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 60 ** 2 <NEWLINE> S = S % 60 ** 2 <NEWLINE> m = S // 60 <NEWLINE> S = S % 60 <NEWLINE> s = S <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
from math import * <NEWLINE> <NL> def trycut ( val ) : <NEWLINE> <INDENT> if val == 0 : return float ( <STRING> ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ret += ceil ( a [ i ] / val ) - 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> low = 0 <NEWLINE> high = 1000000000 <NEWLINE> ans = - 1 <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> cut = trycut ( mid ) <NEWLINE> if cut <= k : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> ans = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sx , sy , gx , gy = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = [ input ( ) for i in range ( h ) ] <NEWLINE> <NL> not_yet = deque ( [ ( sx - 1 , sy - 1 ) ] ) <NEWLINE> dist = [ [ - 1 ] * w for i in range ( h ) ] <NEWLINE> dist [ sx - 1 ] [ sy - 1 ] = 0 <NEWLINE> already = [ [ False ] * w for i in range ( h ) ] <NEWLINE> already [ sx - 1 ] [ sy - 1 ] = True <NEWLINE> <NL> while not_yet : <NEWLINE> <INDENT> x , y = not_yet . popleft ( ) <NEWLINE> d = dist [ x ] [ y ] <NEWLINE> <NL> for i in range ( x + 1 , x + k + 1 ) : <NEWLINE> <INDENT> if i >= h or c [ i ] [ y ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if already [ i ] [ y ] and dist [ i ] [ y ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if already [ i ] [ y ] and dist [ i ] [ y ] == d + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] [ y ] = d + 1 <NEWLINE> already [ i ] [ y ] = True <NEWLINE> not_yet . append ( ( i , y ) ) <NEWLINE> <NL> <DEDENT> for i in range ( x - 1 , x - k - 1 , - 1 ) : <NEWLINE> <INDENT> if i < 0 or c [ i ] [ y ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if already [ i ] [ y ] and dist [ i ] [ y ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if already [ i ] [ y ] and dist [ i ] [ y ] == d + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] [ y ] = d + 1 <NEWLINE> already [ i ] [ y ] = True <NEWLINE> not_yet . append ( ( i , y ) ) <NEWLINE> <NL> <DEDENT> for i in range ( y + 1 , y + k + 1 ) : <NEWLINE> <INDENT> if i >= w or c [ x ] [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if already [ x ] [ i ] and dist [ x ] [ i ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if already [ x ] [ i ] and dist [ x ] [ i ] == d + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ x ] [ i ] = d + 1 <NEWLINE> already [ x ] [ i ] = True <NEWLINE> not_yet . append ( ( x , i ) ) <NEWLINE> <NL> <DEDENT> for i in range ( y - 1 , y - k - 1 , - 1 ) : <NEWLINE> <INDENT> if i < 0 or c [ x ] [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if already [ x ] [ i ] and dist [ x ] [ i ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if already [ x ] [ i ] and dist [ x ] [ i ] == d + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ x ] [ i ] = d + 1 <NEWLINE> already [ x ] [ i ] = True <NEWLINE> not_yet . append ( ( x , i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = dist [ gx - 1 ] [ gy - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <COMMENT> <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <COMMENT> <NEWLINE> <NL> sum_Aij = 0 <NEWLINE> sum_j = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> sum_j [ i - 1 ] = ( A [ i ] + ( 0 if i == N - 1 else sum_j [ i ] ) ) % 1000000007 <NEWLINE> sum_Aij += sum_j [ i - 1 ] * A [ i - 1 ] % 1000000007 <NEWLINE> <NL> <DEDENT> print ( sum_Aij % 1000000007 ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> ans2 = 0 <NEWLINE> <NL> <NL> import math <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> ans += math . gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> tmp3 = math . gcd ( i , j ) <NEWLINE> ans2 += math . gcd ( tmp3 , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tmp2 = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp2 += i <NEWLINE> <NL> <DEDENT> print ( ( ans - tmp2 - ans2 ) * 3 + ans2 * 6 + tmp2 ) <NEWLINE>
primes = [ 0 , 0 ] + [ 1 ] * 999999 <NEWLINE> for i in range ( 2 , 1001 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 1000001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) + 1 <NEWLINE> print ( sum ( [ 1 for i in range ( n ) if primes [ i ] ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> db = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> db . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( db ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def sumdic ( dic ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k , v in dic . items ( ) : <NEWLINE> <INDENT> s += int ( k ) * v <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> if x in dic : <NEWLINE> <INDENT> dic [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> s = sumdic ( dic ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> ( b , c ) = [ x for x in input ( ) . split ( ) ] <NEWLINE> if c in dic and b in dic : <NEWLINE> <INDENT> dic [ c ] += dic [ b ] <NEWLINE> s += ( int ( c ) - int ( b ) ) * dic [ b ] <NEWLINE> dic . pop ( b ) <NEWLINE> <DEDENT> elif b in dic : <NEWLINE> <INDENT> dic [ c ] = dic [ b ] <NEWLINE> s += ( int ( c ) - int ( b ) ) * dic [ b ] <NEWLINE> dic . pop ( b ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
s = ( 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 ) <NEWLINE> w = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> while True : <NEWLINE> <INDENT> m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> print ( w [ ( d + sum ( s [ : m ] ) ) % 7 ] ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> A , B , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> f = lambda k : floor ( A * k / B ) <NEWLINE> if B - 1 < N : <NEWLINE> <INDENT> print ( f ( B - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( N ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = len ( str ( int ( n / i ) ) ) <NEWLINE> b = len ( str ( int ( i ) ) ) <NEWLINE> l . append ( max ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> if <STRING> in str ( i ) : print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL>
from heapq import heapify , heappop , heappush <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> DEBUG = False <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MAX_N = 50 <NEWLINE> MAX_A = 50 <NEWLINE> <NL> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> U = [ ] <NEWLINE> V = [ ] <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> <NL> connect = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> U . append ( u ) <NEWLINE> V . append ( v ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> connect [ u - 1 ] . append ( [ v - 1 , a , b ] ) <NEWLINE> connect [ v - 1 ] . append ( [ u - 1 , a , b ] ) <NEWLINE> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> C . append ( c ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> . format ( U ) ) <NEWLINE> print ( <STRING> . format ( V ) ) <NEWLINE> print ( <STRING> . format ( A ) ) <NEWLINE> print ( <STRING> . format ( B ) ) <NEWLINE> print ( <STRING> . format ( C ) ) <NEWLINE> print ( <STRING> . format ( D ) ) <NEWLINE> print ( <STRING> . format ( connect ) ) <NEWLINE> <NL> <DEDENT> MAX_N = N <NEWLINE> MAX_A = max ( A ) <NEWLINE> MAX_MONEY = MAX_N * MAX_A <NEWLINE> S = min ( S , MAX_MONEY - 1 ) <NEWLINE> <NL> node = [ INF for _ in range ( MAX_MONEY * N ) ] <NEWLINE> hq = [ ] <NEWLINE> heappush ( hq , ( 0 , S ) ) <NEWLINE> while hq : <NEWLINE> <INDENT> time , current_node = heappop ( hq ) <NEWLINE> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> . format ( time , current_node , len ( hq ) ) ) <NEWLINE> <DEDENT> if time < node [ current_node ] : <NEWLINE> <INDENT> node [ current_node ] = time <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> index_city = current_node // MAX_MONEY <NEWLINE> money = current_node % MAX_MONEY <NEWLINE> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> . format ( money ) ) <NEWLINE> <NL> <DEDENT> for index_next_city , a , b in connect [ index_city ] : <NEWLINE> <INDENT> if money >= a and time + b < node [ index_next_city * MAX_MONEY + money - a ] : <NEWLINE> <INDENT> heappush ( hq , ( time + b , index_next_city * MAX_MONEY + money - a ) ) <NEWLINE> <DEDENT> <DEDENT> if money < MAX_MONEY - 1 : <NEWLINE> <INDENT> heappush ( hq , ( time + D [ index_city ] , min ( money + C [ index_city ] , MAX_MONEY - 1 ) + MAX_MONEY * index_city ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> . format ( i , node [ MAX_MONEY * i : MAX_MONEY * ( i + 1 ) ] ) ) <NEWLINE> <DEDENT> print ( min ( node [ MAX_MONEY * i : MAX_MONEY * ( i + 1 ) ] ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> temp = pow ( 10 , 18 ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > temp : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> X -= 1 <NEWLINE> Y -= 1 <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans [ min ( j - i , abs ( X - i ) + 1 + abs ( Y - j ) ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r , b , g = 0 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> if i + 2 * j >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ i + j ] and s [ i ] != s [ i + 2 * j ] and s [ i + j ] != s [ i + 2 * j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> def counting_sort ( a , b , k ) : <NEWLINE> <INDENT> c = [ 0 for _ in range ( k + 1 ) ] <NEWLINE> <NL> for aj in a : <NEWLINE> <INDENT> c [ aj ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> c [ i ] += c [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in reversed ( range ( n ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> b [ c [ a [ j ] ] ] = a [ j ] <NEWLINE> c [ a [ j ] ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> k = max ( a ) <NEWLINE> counting_sort ( a , b , k ) <NEWLINE> print ( b [ 1 ] , end = <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( b [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 1 <NEWLINE> t = P [ 0 ] <NEWLINE> for i in range ( len ( P ) - 1 ) : <NEWLINE> <INDENT> if t > P [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> t = P [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <NL> <NL>
from sys import exit <NEWLINE> <NL> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> if len ( H ) <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> H . sort ( reverse = True ) <NEWLINE> H = H [ K : ] <NEWLINE> <NL> print ( sum ( H ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = a [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if 1000000000000000000 < ans : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , numpy , string , random <NEWLINE> import sys <NEWLINE> from decimal import Decimal <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> D = I ( ) <NEWLINE> C = LI ( ) <NEWLINE> s = [ LI ( ) for _ in range ( D ) ] <NEWLINE> <NL> T = [ 1 for _ in range ( D ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def last ( d , i ) : <NEWLINE> <INDENT> T_d = T [ : d ] <NEWLINE> n = [ j for j , x in enumerate ( T_d , 1 ) if x == i ] <NEWLINE> if n : <NEWLINE> <COMMENT> <NL> <INDENT> return max ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def Score ( T ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> sum_c = 0 <NEWLINE> for i in range ( 1 , 26 + 1 ) : <NEWLINE> <INDENT> sum_c += C [ i - 1 ] * ( d - last ( d , i ) ) <NEWLINE> <DEDENT> score += s [ d - 1 ] [ T [ d - 1 ] - 1 ] - sum_c <NEWLINE> <COMMENT> <NL> <DEDENT> score_d = max ( 10 ** 6 + score , 0 ) <NEWLINE> <COMMENT> <NL> return score_d <NEWLINE> <NL> <DEDENT> score_0 = Score ( T ) <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> T_new = [ random . randint ( 1 , 26 ) if i % 36 == 0 else T [ i ] for i in range ( D ) ] <NEWLINE> if Score ( T_new ) > score_0 : <NEWLINE> <INDENT> T = T_new <NEWLINE> score_0 = Score ( T_new ) <NEWLINE> <NL> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( c [ i ] == <STRING> ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( a , b ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( c [ i ] == <STRING> ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> now = max ( a , b ) <NEWLINE> ans = min ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <NL> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( K < A ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( K > A + B ) : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> line = input ( ) <NEWLINE> num = int ( line ) <NEWLINE> total = 0 <NEWLINE> <NL> if num == 200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 198 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 197 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 196 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 195 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 194 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 193 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 192 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 191 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 190 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 189 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 188 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 187 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 186 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 185 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 184 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 183 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 182 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 181 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 180 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 179 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 178 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 177 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 176 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 175 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> ans = math . gcd ( ( math . gcd ( i , j ) ) , k ) <NEWLINE> total = total + ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A , B , C , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> result = 0 <NEWLINE> <NL> if A < K : <NEWLINE> <INDENT> result += A <NEWLINE> K -= A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = K <NEWLINE> K -= A <NEWLINE> <NL> <DEDENT> if K > 0 : <NEWLINE> <INDENT> if B < K : <NEWLINE> <INDENT> K -= B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= B <NEWLINE> <NL> <DEDENT> <DEDENT> if K > 0 : <NEWLINE> <INDENT> if C < K : <NEWLINE> <INDENT> result -= C <NEWLINE> K -= C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result -= K <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if plist [ i ] < plist [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> Q = [ 0 ] * ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Q [ P [ i ] - 1 ] = i <NEWLINE> <NL> <DEDENT> cnt = 1 <NEWLINE> ans = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if Q [ i + 1 ] > Q [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , cnt ) <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> print ( N - ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> curCoord = 0 <NEWLINE> n = 1 <NEWLINE> <NL> while ( curCoord <= X ) : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <NL> if ( n > N + 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> curCoord = curCoord + L [ n - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> from_jump = max ( 0 , i - k ) <NEWLINE> dp [ i ] = min ( dp [ j ] + abs ( h_l [ i ] - h_l [ j ] ) for j in range ( from_jump , i ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) + <STRING> <NEWLINE> <COMMENT> <NL> count = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count [ i + 1 ] += count [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ i + 1 ] = count [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count [ i + 1 ] = count [ i ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( count [ r - 1 ] - count [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from functools import lru_cache <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> S = input ( ) [ : : - 1 ] <NEWLINE> <NL> MOD = 2019 <NEWLINE> tmp = [ 0 ] * MOD <NEWLINE> tmp [ 0 ] += 1 <NEWLINE> tens = 1 <NEWLINE> num = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> num += int ( s ) * tens <NEWLINE> num = num % MOD <NEWLINE> tmp [ num ] += 1 <NEWLINE> tens *= 10 <NEWLINE> tens %= MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in tmp : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
S = input ( ) <NEWLINE> if len ( S ) < 4 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> dp = [ 0 ] * 2019 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> s = int ( S [ - 1 ] ) <NEWLINE> dp [ s ] = 1 <NEWLINE> ans = 0 <NEWLINE> for k in range ( len ( S ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> s = int ( S [ k ] ) * ( pow ( 10 , len ( S ) - k - 1 , 2019 ) ) + s <NEWLINE> s %= 2019 <NEWLINE> dp [ s ] += 1 <NEWLINE> <DEDENT> for e in dp : <NEWLINE> <INDENT> ans += e * ( e - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
num = input ( ) . split ( ) <NEWLINE> num . sort ( ) <NEWLINE> print ( num [ 0 ] , num [ 1 ] , num [ 2 ] , sep = <STRING> ) <NEWLINE>
def preorder ( tree , now ) : <NEWLINE> <INDENT> if now == - 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = tree [ now ] [ 0 ] <NEWLINE> right = tree [ now ] [ 1 ] <NEWLINE> return [ now ] + preorder ( tree , left ) + preorder ( tree , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def inorder ( tree , now ) : <NEWLINE> <INDENT> if now == - 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = tree [ now ] [ 0 ] <NEWLINE> right = tree [ now ] [ 1 ] <NEWLINE> return inorder ( tree , left ) + [ now ] + inorder ( tree , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def postorder ( tree , now ) : <NEWLINE> <INDENT> if now == - 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = tree [ now ] [ 0 ] <NEWLINE> right = tree [ now ] [ 1 ] <NEWLINE> return postorder ( tree , left ) + postorder ( tree , right ) + [ now ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print_list_split_whitespace ( a ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for x in a [ : - 1 ] : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> ps = [ - 1 for _ in range ( n ) ] <NEWLINE> ss = [ - 1 for _ in range ( n ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> id = int ( s [ 0 ] ) <NEWLINE> left = int ( s [ 1 ] ) <NEWLINE> right = int ( s [ 2 ] ) <NEWLINE> tree [ id ] = [ left , right ] <NEWLINE> if left >= 0 : <NEWLINE> <INDENT> ps [ left ] = id <NEWLINE> ss [ left ] = right <NEWLINE> <DEDENT> if right >= 0 : <NEWLINE> <INDENT> ps [ right ] = id <NEWLINE> ss [ right ] = left <NEWLINE> <NL> <DEDENT> <DEDENT> root = ps . index ( - 1 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> pre_list = preorder ( tree , root ) <NEWLINE> print_list_split_whitespace ( pre_list ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> in_list = inorder ( tree , root ) <NEWLINE> print_list_split_whitespace ( in_list ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> post_list = postorder ( tree , root ) <NEWLINE> print_list_split_whitespace ( post_list ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in As : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in As : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> B = list ( itertools . product ( [ 0 , 1 ] , repeat = N ) ) <NEWLINE> sums = { } <NEWLINE> anss = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> ans = 0 <NEWLINE> Point = [ 0 ] * M <NEWLINE> count = 0 <NEWLINE> for z in b : <NEWLINE> <INDENT> if z == 1 : <NEWLINE> <INDENT> for k in range ( M ) : <NEWLINE> <INDENT> Point [ k ] += A [ count ] [ k + 1 ] <NEWLINE> <DEDENT> ans += A [ count ] [ 0 ] <NEWLINE> if M == len ( [ Point [ n ] for n in range ( M ) if Point [ n ] >= X ] ) : <NEWLINE> <INDENT> anss . append ( ans ) <NEWLINE> <DEDENT> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( anss ) != 0 : <NEWLINE> <INDENT> print ( min ( anss ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> def U1 ( a , b ) : <NEWLINE> <INDENT> if b > a : <NEWLINE> <INDENT> b , a = a , b <NEWLINE> <DEDENT> while a % b != 0 : <NEWLINE> <INDENT> r = a % b <NEWLINE> a = b <NEWLINE> b = r <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> arr = [ ] <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> arr . append ( U1 ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> arr = collections . Counter ( arr ) <NEWLINE> <NL> for key , value in arr . items ( ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> c += U1 ( k , key ) * value <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mp = set ( ) <NEWLINE> hp = [ 0 ] * h <NEWLINE> wp = [ 0 ] * w <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mp . add ( ( a , b ) ) <NEWLINE> l = [ a , b ] <NEWLINE> hp [ l [ 0 ] - 1 ] += 1 <NEWLINE> wp [ l [ 1 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> maxhp = max ( hp ) <NEWLINE> maxwp = max ( wp ) <NEWLINE> hpdex = [ i for i , x in enumerate ( hp ) if x == maxhp ] <NEWLINE> wpdex = [ i for i , x in enumerate ( wp ) if x == maxwp ] <NEWLINE> <NL> for i in hpdex : <NEWLINE> <INDENT> for j in wpdex : <NEWLINE> <INDENT> if ( i + 1 , j + 1 ) not in mp : <NEWLINE> <INDENT> print ( max ( hp ) + max ( wp ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( hp ) + max ( wp ) - 1 ) <NEWLINE>
N = str ( input ( ) ) <NEWLINE> N = list ( N ) <NEWLINE> N = [ int ( i ) for i in N ] <NEWLINE> <NL> if sum ( N ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Item = [ <STRING> ] * N <NEWLINE> for T in range ( 0 , N ) : <NEWLINE> <INDENT> Item [ T ] = input ( ) <NEWLINE> <DEDENT> print ( len ( set ( Item ) ) ) <NEWLINE>
n = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( n , x ) ) <NEWLINE> n += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse . csgraph import bellman_ford , NegativeCycleError <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def dfs ( s ) : <NEWLINE> <INDENT> for u in to [ s ] : <NEWLINE> <INDENT> if not toflag [ u ] : <NEWLINE> <INDENT> toflag [ u ] = True <NEWLINE> dfs ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def rdfs ( s ) : <NEWLINE> <INDENT> for u in ot [ s ] : <NEWLINE> <INDENT> if not otflag [ u ] : <NEWLINE> <INDENT> otflag [ u ] = True <NEWLINE> rdfs ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges [ i ] = [ a , b , - ( c + 1 - p ) ] <NEWLINE> to [ a ] . append ( b ) <NEWLINE> ot [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> toflag [ 0 ] = True <NEWLINE> otflag [ - 1 ] = True <NEWLINE> dfs ( 0 ) <NEWLINE> rdfs ( n - 1 ) <NEWLINE> <NL> dic = { } <NEWLINE> for a , b , c in edges : <NEWLINE> <INDENT> if toflag [ a ] and otflag [ b ] : <NEWLINE> <INDENT> if ( a , b ) in dic . keys ( ) : <NEWLINE> <INDENT> dic [ ( a , b ) ] = min ( dic [ ( a , b ) ] , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ ( a , b ) ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> row = [ ] <NEWLINE> col = [ ] <NEWLINE> data = [ ] <NEWLINE> for ( a , b ) , c in dic . items ( ) : <NEWLINE> <INDENT> row . append ( a ) <NEWLINE> col . append ( b ) <NEWLINE> data . append ( c ) <NEWLINE> <DEDENT> g = csr_matrix ( ( data , ( row , col ) ) , shape = ( n , n ) ) <NEWLINE> try : <NEWLINE> <INDENT> d = bellman_ford ( g , indices = 0 ) . astype ( int ) <NEWLINE> print ( max ( 0 , - d [ - 1 ] ) ) <NEWLINE> <DEDENT> except NegativeCycleError : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( m ) ] <NEWLINE> to = [ [ ] for i in range ( n ) ] <NEWLINE> ot = [ [ ] for i in range ( n ) ] <NEWLINE> toflag = [ False ] * n <NEWLINE> otflag = [ False ] * n <NEWLINE> main ( ) <NEWLINE> <DEDENT>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ma = ( a * n / b ) // 1 - a * ( ( n / b ) // 1 ) <NEWLINE> for i in range ( b - 1 , n + 1 , b ) : <NEWLINE> <INDENT> tmp = ( a * i / b ) // 1 - a * ( ( i / b ) // 1 ) <NEWLINE> ma = max ( tmp , ma ) <NEWLINE> <DEDENT> print ( int ( ma ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if z >= 0 and z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import os <NEWLINE> from collections import deque <NEWLINE> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 999999999 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> def resolve ( test_def_name = <STRING> ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> que . extend ( list ( input ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> query_s = [ list ( input ( ) . split ( ) ) for i in range ( q ) ] <NEWLINE> <NL> isReverse = False <NEWLINE> for query in query_s : <NEWLINE> <INDENT> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> isReverse = True if not isReverse else False <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if ( isReverse is False and query [ 1 ] == <STRING> ) or ( isReverse and query [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> que . appendleft ( query [ 2 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> que . append ( query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> if isReverse : <NEWLINE> <INDENT> ans = <STRING> . join ( list ( reversed ( que ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> . join ( que ) <NEWLINE> <NL> <DEDENT> print ( ans . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , assert_input , output ) : <NEWLINE> <INDENT> stdout , sat_in = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( assert_input ) <NEWLINE> resolve ( sys . _getframe ( ) . f_back . f_code . co_name ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , sat_in <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_input_1 ( self ) : <NEWLINE> <INDENT> test_input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( test_input , output ) <NEWLINE> <NL> <DEDENT> def test_input_2 ( self ) : <NEWLINE> <INDENT> test_input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( test_input , output ) <NEWLINE> <NL> <DEDENT> def test_input_3 ( self ) : <NEWLINE> <INDENT> test_input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( test_input , output ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def tes_t_1original_1 ( self ) : <NEWLINE> <INDENT> test_input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( test_input , output ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if os . environ . get ( <STRING> ) is None : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> unittest . main ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> <NL> import collections <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> S . append ( str ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> S = sorted ( S ) <NEWLINE> cnt = collections . Counter ( ) <NEWLINE> <NL> for word in S : <NEWLINE> <INDENT> cnt [ word ] += 1 <NEWLINE> <NL> <DEDENT> mostCommon = cnt . most_common ( ) <NEWLINE> <NL> D = mostCommon [ 0 ] [ 1 ] <NEWLINE> print ( mostCommon [ 0 ] [ 0 ] ) <NEWLINE> for i in range ( 1 , len ( set ( S ) ) ) : <NEWLINE> <INDENT> if mostCommon [ i ] [ 1 ] == D : <NEWLINE> <INDENT> print ( mostCommon [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> <NL> sum = 0 <NEWLINE> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( a , k ) : <NEWLINE> <INDENT> for c in range ( b , k ) : <NEWLINE> <INDENT> tmp = math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> if a != b and b != c and a != c : <NEWLINE> <INDENT> tmp *= 2 <NEWLINE> <DEDENT> if a != b or b != c : <NEWLINE> <INDENT> tmp *= 3 <NEWLINE> <DEDENT> sum += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif lst [ i ] % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <COMMENT> <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> union_find = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> union_find . union ( A , B ) <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> answer = max ( answer , union_find . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AD = sorted ( list ( Counter ( A ) . values ( ) ) ) <NEWLINE> print ( sum ( AD [ : len ( AD ) - k ] ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> S = input ( ) <NEWLINE> mods = [ 0 ] <NEWLINE> num , ten = 0 , 1 <NEWLINE> for n in S [ : : - 1 ] : <NEWLINE> <INDENT> num += int ( n ) * ten <NEWLINE> num %= 2019 <NEWLINE> mods . append ( num ) <NEWLINE> ten *= 10 <NEWLINE> ten %= 2019 <NEWLINE> <NL> <DEDENT> counter = Counter ( mods ) <NEWLINE> ret = 0 <NEWLINE> for v in counter . values ( ) : <NEWLINE> <INDENT> ret += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if gcd ( a , b ) == 1 : <NEWLINE> <INDENT> sum += 1 * k <NEWLINE> continue <NEWLINE> <DEDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( a , b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> count = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ 2 * j - i ] != S [ i ] and S [ 2 * j - i ] != S [ j ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter , defaultdict , deque <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> import sys , math , itertools , fractions , pprint <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , m = inpl ( ) <NEWLINE> a = inpl ( ) <NEWLINE> a . sort ( ) <NEWLINE> bc = [ inpl ( ) for _ in range ( m ) ] <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ind = - 1 <NEWLINE> now = - 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cnt == 0 : <NEWLINE> <INDENT> ind += 1 <NEWLINE> if ind >= m : break <NEWLINE> cnt , now = bc [ ind ] <NEWLINE> <DEDENT> if a [ i ] >= now : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ i ] = now <NEWLINE> cnt -= 1 <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = 1 , n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , L ) <NEWLINE> r = min ( r , R ) <NEWLINE> <DEDENT> if l > r : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r - l + 1 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> A = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n = X - A ** 5 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( A , 0 ) <NEWLINE> <DEDENT> elif n > 0 : <NEWLINE> <INDENT> B = int ( n ** ( 1 / 5 ) ) <NEWLINE> if B ** 5 == n : <NEWLINE> <INDENT> print ( A , - B ) <NEWLINE> break <NEWLINE> <DEDENT> B += 1 <NEWLINE> if B ** 5 == n : <NEWLINE> <INDENT> print ( A , - B ) <NEWLINE> break <NEWLINE> <DEDENT> A += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = - int ( ( - n ) ** ( 1 / 5 ) ) <NEWLINE> if B ** 5 == n : <NEWLINE> <INDENT> print ( A , - B ) <NEWLINE> break <NEWLINE> <DEDENT> B -= 1 <NEWLINE> if B ** 5 == n : <NEWLINE> <INDENT> print ( A , - B ) <NEWLINE> break <NEWLINE> <DEDENT> A += 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> prev = A [ i - k ] <NEWLINE> now = A [ i ] <NEWLINE> print ( <STRING> if prev < now else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import math <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> ans = [ 0 ] * 100000 <NEWLINE> l = list ( range ( 1 , int ( math . sqrt ( a ) ) ) ) <NEWLINE> <NL> for x , y , z in itertools . product ( l , repeat = 3 ) : <NEWLINE> <INDENT> ans [ x * x + y * y + z * z + x * y + y * z + z * x ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> N = len ( S ) <NEWLINE> p = S [ 0 ] <NEWLINE> c = 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( K // 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( set ( S ) ) == 1 : <NEWLINE> <INDENT> print ( N * K // 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == p : <NEWLINE> <INDENT> c += 1 <NEWLINE> p = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = S [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = c * K <NEWLINE> if S [ 0 ] == S [ - 1 ] : <NEWLINE> <INDENT> p = S [ 0 ] <NEWLINE> c = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if p == S [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> d = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if p == S [ - i ] : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( c % 2 ) * ( d % 2 ) == 1 : <NEWLINE> <INDENT> ans += K - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import argparse <NEWLINE> import logging <NEWLINE> <COMMENT> <NL> <NL> logging . basicConfig ( filename = <STRING> , level = logging . DEBUG ) <NEWLINE> logger = logging . getLogger ( __name__ ) <NEWLINE> logger . setLevel ( logging . DEBUG ) <NEWLINE> <NL> <NL> def f ( n : int , l_list : list , i : int = None , j : int = None , k : int = None ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n <= 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> result = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> li = l_list [ i ] <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> lj = l_list [ j ] <NEWLINE> if li == lj : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> lk = l_list [ k ] <NEWLINE> if li == lk or lj == lk : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> l_ijk = sorted ( [ l_list [ i ] , l_list [ j ] , l_list [ k ] ] ) <NEWLINE> if l_ijk [ 0 ] + l_ijk [ 1 ] > l_ijk [ 2 ] : <NEWLINE> <COMMENT> <NL> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> parser = argparse . ArgumentParser ( ) <NEWLINE> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , action = <STRING> , default = False ) <NEWLINE> <DEDENT> args = parser . parse_args ( ) <NEWLINE> if args . doctest : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( verbose = True ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> l_list = list ( map ( lambda x : int ( x ) , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> print ( f ( n , l_list ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ gcd ( i + 1 , gcd ( j + 1 , k + 1 ) ) for i in range ( n ) for j in range ( n ) for k in range ( n ) ] <NEWLINE> print ( sum ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> l = [ 0 for i in range ( n ) ] <NEWLINE> l [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l [ i ] += l [ i - 1 ] <NEWLINE> l [ i ] %= mod <NEWLINE> l [ i ] += a [ i ] <NEWLINE> l [ i ] %= mod <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s += ( ( a [ i ] % mod ) * ( l [ i - 1 ] % mod ) ) % mod <NEWLINE> s %= mod <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> obvs = list ( range ( 1 , N + 1 , 1 ) ) <NEWLINE> obvs_height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> obvs = { } <NEWLINE> i = 1 <NEWLINE> for h in obvs_height : <NEWLINE> <INDENT> obvs [ i ] = h <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> obvs_remain = obvs . copy ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> path = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if path == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if obvs [ path [ 0 ] ] == obvs [ path [ 1 ] ] : <NEWLINE> <INDENT> obvs_remain . pop ( path [ 0 ] , None ) <NEWLINE> obvs_remain . pop ( path [ 1 ] , None ) <NEWLINE> <DEDENT> elif obvs [ path [ 0 ] ] > obvs [ path [ 1 ] ] : <NEWLINE> <INDENT> obvs_remain . pop ( path [ 1 ] , None ) <NEWLINE> <DEDENT> elif obvs [ path [ 0 ] ] < obvs [ path [ 1 ] ] : <NEWLINE> <INDENT> obvs_remain . pop ( path [ 0 ] , None ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( obvs_remain ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> num = x // i <NEWLINE> ans += num * ( num + 1 ) / 2 * i <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from heapq import heappush , heappop <NEWLINE> from bisect import bisect_left as bi_l , bisect_right as bi_r <NEWLINE> from collections import deque , Counter , defaultdict <NEWLINE> from itertools import combinations , product <NEWLINE> inf = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> import scipy <NEWLINE> from heapq import heappush , heappop <NEWLINE> from bisect import bisect_left as bi_l , bisect_right as bi_r <NEWLINE> from collections import deque , Counter , defaultdict <NEWLINE> from itertools import combinations , permutations , product <NEWLINE> from functools import lru_cache <NEWLINE> from math import sin , cos , tan , asin , acos , atan <NEWLINE> inf = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> <NL> class NumberTheory ( ) : <NEWLINE> <INDENT> def __init__ ( self , n = 2 * 10 ** 6 , numpy = True ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . np_flg = numpy <NEWLINE> self . is_prime_number , self . prime_numbers = self . sieve_of_eratosthenes ( n ) <NEWLINE> <NL> <DEDENT> def sieve_of_eratosthenes ( self , n ) : <NEWLINE> <INDENT> if self . np_flg : <NEWLINE> <INDENT> sieve = np . ones ( n + 1 , dtype = np . int64 ) ; sieve [ : 2 ] = 0 <NEWLINE> for i in range ( 2 , int ( n ** .5 ) + 1 ) : <NEWLINE> <INDENT> if sieve [ i ] : sieve [ i * 2 : : i ] = 0 <NEWLINE> <DEDENT> prime_numbers = np . flatnonzero ( sieve ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sieve = [ 1 ] * ( n + 1 ) ; sieve [ 0 ] = sieve [ 1 ] = 0 <NEWLINE> for i in range ( 2 , int ( n ** .5 ) + 1 ) : <NEWLINE> <INDENT> if not sieve [ i ] : continue <NEWLINE> for j in range ( i * 2 , n + 1 , i ) : sieve [ j ] = 0 <NEWLINE> <DEDENT> prime_numbers = [ i for i in range ( 2 , n + 1 ) if sieve [ i ] ] <NEWLINE> <DEDENT> return sieve , prime_numbers <NEWLINE> <NL> <DEDENT> def prime_factorize ( self , n ) : <NEWLINE> <INDENT> res = dict ( ) <NEWLINE> if n < 2 : return res <NEWLINE> border = int ( n ** .5 ) <NEWLINE> for p in self . prime_numbers : <NEWLINE> <INDENT> if p > border : break <NEWLINE> while n % p == 0 : res [ p ] = res . get ( p , 0 ) + 1 ; n //= p <NEWLINE> if n == 1 : return res <NEWLINE> <DEDENT> res [ n ] = 1 ; return res <NEWLINE> <NL> <DEDENT> def prime_factorize_factorial ( self , n ) : <NEWLINE> <INDENT> res = dict ( ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for p , c in self . prime_factorize ( i ) . items ( ) : res [ p ] = res . get ( p , 0 ) + c <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def gcd ( a , b ) : return gcd ( b , a % b ) if b else abs ( a ) <NEWLINE> <NL> @ staticmethod <NEWLINE> def lcm ( a , b ) : return abs ( a // gcd ( a , b ) * b ) <NEWLINE> <NL> @ staticmethod <NEWLINE> def find_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** .5 ) + 1 ) : <NEWLINE> <INDENT> if n % i : continue <NEWLINE> divisors . append ( i ) <NEWLINE> j = n // i <NEWLINE> if j != i : divisors . append ( j ) <NEWLINE> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def base_convert ( n , b ) : <COMMENT> <NEWLINE> <INDENT> if not n : return <STRING> <NEWLINE> res = <STRING> <NEWLINE> while n : <NEWLINE> <INDENT> n , r = divmod ( n , b ) <NEWLINE> if r < 0 : n += 1 ; r -= b <NEWLINE> res += str ( r ) <NEWLINE> <DEDENT> return res [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n = 10 ** 6 ) : <NEWLINE> <INDENT> self . root = list ( range ( n ) ) <NEWLINE> self . height = [ 0 ] * n <NEWLINE> self . size = [ 1 ] * n <NEWLINE> <NL> <DEDENT> def find_root ( self , u ) : <NEWLINE> <INDENT> if self . root [ u ] == u : return u <NEWLINE> self . root [ u ] = self . find_root ( self . root [ u ] ) <NEWLINE> return self . root [ u ] <NEWLINE> <NL> <DEDENT> def unite ( self , u , v ) : <NEWLINE> <INDENT> ru = self . find_root ( u ) <NEWLINE> rv = self . find_root ( v ) <NEWLINE> if ru == rv : return <NEWLINE> hu = self . height [ ru ] <NEWLINE> hv = self . height [ rv ] <NEWLINE> if hu >= hv : <NEWLINE> <INDENT> self . root [ rv ] = ru <NEWLINE> self . size [ ru ] += self . size [ rv ] <NEWLINE> self . height [ ru ] = max ( hu , hv + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root [ ru ] = rv <NEWLINE> self . size [ rv ] += self . size [ ru ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Combinatorics ( ) : <NEWLINE> <INDENT> def __init__ ( self , N = 10 ** 9 , n = 10 ** 6 , mod = 10 ** 9 + 7 , numpy = True ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . nCr = dict ( ) <NEWLINE> self . np_flg = numpy <NEWLINE> self . make_mod_tables ( N , n ) <NEWLINE> <NL> <DEDENT> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def choose ( self , n , r , mod = None ) : <COMMENT> <NEWLINE> <INDENT> if r > n or r < 0 : return 0 <NEWLINE> if r == 0 : return 1 <NEWLINE> if ( n , r ) in self . nCr : return self . nCr [ ( n , r ) ] <NEWLINE> if not mod : <NEWLINE> <INDENT> self . nCr [ ( n , r ) ] = ( self . choose ( n - 1 , r ) + self . choose ( n - 1 , r - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . nCr [ ( n , r ) ] = ( self . choose ( n - 1 , r , mod ) + self . choose ( n - 1 , r - 1 , mod ) ) % mod <NEWLINE> <DEDENT> return self . nCr [ ( n , r ) ] <NEWLINE> <NL> <DEDENT> def cumprod ( self , a ) : <NEWLINE> <INDENT> p = self . mod <NEWLINE> l = len ( a ) ; sql = int ( np . sqrt ( l ) + 1 ) <NEWLINE> a = np . resize ( a , sql ** 2 ) . reshape ( sql , sql ) <NEWLINE> for i in range ( sql - 1 ) : a [ : , i + 1 ] *= a [ : , i ] ; a [ : , i + 1 ] %= p <NEWLINE> for i in range ( sql - 1 ) : a [ i + 1 ] *= a [ i , - 1 ] ; a [ i + 1 ] %= p <NEWLINE> return np . ravel ( a ) [ : l ] <NEWLINE> <NL> <DEDENT> def make_mod_tables ( self , N , n ) : <NEWLINE> <INDENT> p = self . mod <NEWLINE> if self . np_flg : <NEWLINE> <INDENT> fac = np . arange ( n + 1 ) ; fac [ 0 ] = 1 ; fac = self . cumprod ( fac ) <NEWLINE> ifac = np . arange ( n + 1 , 0 , - 1 ) ; ifac [ 0 ] = pow ( int ( fac [ - 1 ] ) , p - 2 , p ) <NEWLINE> ifac = self . cumprod ( ifac ) [ n : : - 1 ] <NEWLINE> n_choose = np . arange ( N + 1 , N - n , - 1 ) ; n_choose [ 0 ] = 1 ; <NEWLINE> n_choose [ 1 : ] = self . cumprod ( n_choose [ 1 : ] ) * ifac [ 1 : n + 1 ] % p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fac = [ None ] * ( n + 1 ) ; fac [ 0 ] = 1 <NEWLINE> for i in range ( n ) : fac [ i + 1 ] = fac [ i ] * ( i + 1 ) % p <NEWLINE> ifac = [ None ] * ( n + 1 ) ; ifac [ n ] = pow ( fac [ n ] , p - 2 , p ) <NEWLINE> for i in range ( n , 0 , - 1 ) : ifac [ i - 1 ] = ifac [ i ] * i % p <NEWLINE> n_choose = [ None ] * ( n + 1 ) ; n_choose [ 0 ] = 1 <NEWLINE> for i in range ( n ) : n_choose [ i + 1 ] = n_choose [ i ] * ( N - i ) % p <NEWLINE> for i in range ( n + 1 ) : n_choose [ i ] = n_choose [ i ] * ifac [ i ] % p <NEWLINE> <DEDENT> self . fac , self . ifac , self . mod_n_choose = fac , ifac , n_choose <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def z_algorithm ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> a = [ 0 ] * n ; a [ 0 ] = n <NEWLINE> l = r = - 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if r >= i : a [ i ] = min ( a [ i - l ] , r - i ) <NEWLINE> while i + a [ i ] < n and s [ i + a [ i ] ] == s [ a [ i ] ] : a [ i ] += 1 <NEWLINE> if i + a [ i ] >= r : l , r = i , i + a [ i ] <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> class ABC001 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> h1 , h2 = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> print ( h1 - h2 ) <NEWLINE> <NL> <DEDENT> def B ( ) : pass <NEWLINE> def C ( ) : pass <NEWLINE> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC002 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( max ( x , y ) ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> vowels = set ( <STRING> ) <NEWLINE> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> t = <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> if c in vowels : continue <NEWLINE> t += c <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> * coords , = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def triangle_area ( x0 , y0 , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> x1 -= x0 ; x2 -= x0 ; y1 -= y0 ; y2 -= y0 ; <NEWLINE> return abs ( x1 * y2 - x2 * y1 ) / 2 <NEWLINE> <DEDENT> print ( triangle_area ( * coords ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> edges = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> x -= 1 ; y -= 1 <NEWLINE> edges . add ( ( x , y ) ) <NEWLINE> <DEDENT> cand = [ ] <NEWLINE> for i in range ( 1 , 1 << n ) : <NEWLINE> <INDENT> s = [ j for j in range ( n ) if i >> j & 1 ] <NEWLINE> for x , y in combinations ( s , 2 ) : <NEWLINE> <INDENT> if ( x , y ) not in edges : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand . append ( len ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( cand ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ABC003 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( ( n + 1 ) * 5000 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> atcoder = set ( <STRING> ) <NEWLINE> s , t = sys . stdin . read ( ) . split ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : continue <NEWLINE> if s [ i ] == <STRING> and t [ i ] in atcoder : continue <NEWLINE> if t [ i ] == <STRING> and s [ i ] in atcoder : continue <NEWLINE> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , k , * r = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> for x in sorted ( r ) [ - k : ] : <NEWLINE> <INDENT> res = ( res + x ) / 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC004 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> print ( int ( sys . stdin . readline ( ) . rstrip ( ) ) * 2 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> c = [ sys . stdin . readline ( ) . rstrip ( ) for _ in range ( 4 ) ] <NEWLINE> for l in c [ : : - 1 ] : <NEWLINE> <INDENT> print ( l [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> n %= 30 <NEWLINE> res = list ( range ( 1 , 7 ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i %= 5 <NEWLINE> res [ i ] , res [ i + 1 ] = res [ i + 1 ] , res [ i ] <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , res ) ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC005 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( y // x ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * t = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> print ( min ( t ) ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> t = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> a = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> m = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> b = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> i = 0 <NEWLINE> for p in b : <NEWLINE> <INDENT> if i == n : print ( <STRING> ) ; return <NEWLINE> while p - a [ i ] > t : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i == n : print ( <STRING> ) ; return <NEWLINE> <DEDENT> if a [ i ] > p : print ( <STRING> ) ; return <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> d = np . array ( [ sys . stdin . readline ( ) . split ( ) for _ in range ( n ) ] , np . int64 ) <NEWLINE> s = d . cumsum ( axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> s = np . pad ( s , 1 ) <NEWLINE> max_del = np . zeros ( ( n + 1 , n + 1 ) , dtype = np . int64 ) <NEWLINE> for y in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> max_del [ y , x ] = np . amax ( s [ y : n + 1 , x : n + 1 ] - s [ 0 : n - y + 1 , x : n + 1 ] - s [ y : n + 1 , 0 : n - x + 1 ] + s [ 0 : n - y + 1 , 0 : n - x + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> res = np . arange ( n ** 2 + 1 ) [ : , None ] <NEWLINE> i = np . arange ( 1 , n + 1 ) <NEWLINE> res = max_del [ i , np . minimum ( res // i , n ) ] . max ( axis = 1 ) <NEWLINE> q = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> p = np . array ( sys . stdin . read ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> print ( * res [ p ] , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ABC006 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if <STRING> in n : print ( <STRING> ) <NEWLINE> elif int ( n ) % 3 == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> mod = 10007 <NEWLINE> t = [ 0 , 0 , 1 ] <NEWLINE> for _ in range ( 1001001 ) : <NEWLINE> <INDENT> t . append ( t [ - 1 ] + t [ - 2 ] + t [ - 3 ] ) ; t [ - 1 ] %= mod <NEWLINE> <DEDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( t [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> cnt = [ 0 , 0 , 0 ] <NEWLINE> if m == 1 : cnt = [ - 1 , - 1 , - 1 ] <NEWLINE> else : <NEWLINE> <INDENT> if m & 1 : m -= 3 ; cnt [ 1 ] += 1 ; n -= 1 <NEWLINE> cnt [ 2 ] = m // 2 - n <NEWLINE> cnt [ 0 ] = n - cnt [ 2 ] <NEWLINE> <DEDENT> if cnt [ 0 ] < 0 or cnt [ 1 ] < 0 or cnt [ 2 ] < 0 : print ( - 1 , - 1 , - 1 ) <NEWLINE> else : print ( * cnt , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n , * c = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> lis = [ inf ] * n <NEWLINE> for x in c : lis [ bi_l ( lis , x ) ] = x <NEWLINE> print ( n - bi_l ( lis , inf ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ABC007 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( n - 1 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if s == <STRING> : print ( - 1 ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> r , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> sy , sx = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> gy , gx = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> sy -= 1 ; sx -= 1 ; gy -= 1 ; gx -= 1 <NEWLINE> maze = [ sys . stdin . readline ( ) . rstrip ( ) for _ in range ( r ) ] <NEWLINE> queue = deque ( [ ( sy , sx ) ] ) <NEWLINE> dist = np . full ( ( r , c ) , np . inf ) ; dist [ sy , sx ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> y , x = queue . popleft ( ) <NEWLINE> for i , j in [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] : <NEWLINE> <INDENT> i += y ; j += x <NEWLINE> if maze [ i ] [ j ] == <STRING> or dist [ i , j ] != np . inf : continue <NEWLINE> dist [ i , j ] = dist [ y , x ] + 1 <NEWLINE> queue . append ( ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( dist [ gy , gx ] ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC008 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> s , t = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( t - s + 1 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * s = sys . stdin . read ( ) . split ( ) <NEWLINE> res = defaultdict ( int ) <NEWLINE> for name in s : res [ name ] += 1 <NEWLINE> print ( sorted ( res . items ( ) , key = lambda x : x [ 1 ] ) [ - 1 ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> a = np . array ( a ) <NEWLINE> c = n - np . count_nonzero ( a [ : , None ] % a , axis = 1 ) <NEWLINE> print ( np . sum ( ( c + 1 ) // 2 / c ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <DEDENT> class ABC009 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( ( n + 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> print ( sorted ( set ( a ) ) [ - 2 ] ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> s = list ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> cost = [ 1 ] * n <NEWLINE> r = k <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] < s [ i ] and cost [ i ] + cost [ j ] <= r : <NEWLINE> <INDENT> heappush ( q , ( s [ j ] , cost [ i ] + cost [ j ] , - j ) ) <NEWLINE> <DEDENT> <DEDENT> if not q : continue <NEWLINE> _ , c , j = heappop ( q ) ; j = - j <NEWLINE> s [ i ] , s [ j ] = s [ j ] , s [ i ] <NEWLINE> r -= c <NEWLINE> cost [ i ] = cost [ j ] = 0 <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC010 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> print ( sys . stdin . readline ( ) . rstrip ( ) + <STRING> ) <NEWLINE> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> tot = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> c = 0 <NEWLINE> while x % 2 == 0 or x % 3 == 2 : <NEWLINE> <INDENT> x -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> tot += c <NEWLINE> <DEDENT> print ( tot ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> sx , sy , gx , gy , t , v , n , * xy = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> x , y = np . array ( xy ) . reshape ( - 1 , 2 ) . T <NEWLINE> def dist ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> return np . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> <DEDENT> ans = <STRING> if ( dist ( sx , sy , x , y ) + dist ( x , y , gx , gy ) <= v * t ) . any ( ) else <STRING> <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <DEDENT> class ABC011 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( n % 12 + 1 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> print ( s [ 0 ] . upper ( ) + s [ 1 : ] . lower ( ) ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , * ng = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> ng = set ( ng ) <NEWLINE> if n in ng : print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> r = 100 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if r == 0 : print ( <STRING> ) ; return <NEWLINE> for i in range ( 3 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( n - i ) in ng : continue <NEWLINE> n -= i <NEWLINE> r -= 1 <NEWLINE> break <NEWLINE> <DEDENT> else : print ( <STRING> ) ; return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC170 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> x = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] != i + 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def B ( ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( <STRING> if 2 * x <= y <= 4 * x and y % 2 == 0 else <STRING> ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> x , n , * p = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> a = list ( set ( range ( 102 ) ) - set ( p ) ) <NEWLINE> a = [ ( abs ( y - x ) , y ) for y in a ] <NEWLINE> print ( sorted ( a ) [ 0 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> cand = set ( a ) <NEWLINE> cnt = 0 <NEWLINE> for x , c in sorted ( Counter ( a ) . items ( ) ) : <NEWLINE> <INDENT> cnt += c == 1 and x in cand <NEWLINE> cand -= set ( range ( x * 2 , 10 ** 6 + 1 , x ) ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> def E ( ) : pass <NEWLINE> def F ( ) : pass <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ABC170 . D ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> X = int ( S , 2 ) <NEWLINE> C = S . count ( <STRING> ) <NEWLINE> xc0 = X % ( C + 1 ) <NEWLINE> xc1 = X % ( C - 1 ) if C > 1 else 0 <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while x : <NEWLINE> <INDENT> c += 1 <NEWLINE> x = x % bin ( x ) . count ( <STRING> ) <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> k = N - 1 - i <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( f ( ( xc0 + pow ( 2 , k , C + 1 ) ) % ( C + 1 ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if C > 1 : <NEWLINE> <INDENT> print ( f ( ( xc1 - pow ( 2 , k , C - 1 ) ) % ( C - 1 ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> past_a = [ 1 ] <NEWLINE> first = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> past_a . append ( a_list [ past_a [ - 1 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> def check ( past_a ) : <NEWLINE> <INDENT> if len ( past_a ) == len ( set ( past_a ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> left = 0 <NEWLINE> right = len ( past_a ) <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> middle = ( right + left ) // 2 <NEWLINE> if check ( past_a [ : middle ] ) == True : <NEWLINE> <INDENT> left = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = middle <NEWLINE> <DEDENT> <DEDENT> roop_2 = left <NEWLINE> roop_1 = past_a . index ( past_a [ roop_2 ] ) <NEWLINE> unit = roop_2 - roop_1 <NEWLINE> p_unit = past_a [ roop_1 : roop_2 ] <NEWLINE> if k <= left : <NEWLINE> <INDENT> print ( past_a [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( k - left ) % unit <NEWLINE> print ( p_unit [ k ] ) <NEWLINE> <NL> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> count = abs ( x ) // d <NEWLINE> if count >= k : <NEWLINE> <INDENT> print ( abs ( x ) - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - count ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x ) - count * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - ( count + 1 ) * d ) ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> next_v = deque ( [ 0 ] ) <NEWLINE> prev = [ - 1 ] * n <NEWLINE> while next_v : <NEWLINE> <INDENT> v = next_v . popleft ( ) <NEWLINE> for v2 in edges [ v ] : <NEWLINE> <INDENT> if prev [ v2 ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prev [ v2 ] = v + 1 <NEWLINE> next_v . append ( v2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for x in prev [ 1 : ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> hh = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> rr = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> if hh [ a - 1 ] <= hh [ b - 1 ] : <NEWLINE> <INDENT> rr [ a - 1 ] = 0 <NEWLINE> <DEDENT> if hh [ b - 1 ] <= hh [ a - 1 ] : <NEWLINE> <INDENT> rr [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( rr ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = collections . defaultdict ( lambda : True ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i < N - 1 and A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> dp [ A [ i ] ] = False <NEWLINE> <DEDENT> k = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if A [ i ] * k > A [ - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ A [ i ] * k ] = False <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( dp [ a ] for a in A ) ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> Q = np . cumsum ( P ) <NEWLINE> <NL> R = np . pad ( Q , K , <STRING> , constant_values = 0 ) [ : N ] <NEWLINE> <NL> a = np . argmax ( Q - R ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += ( 1.00 + P [ a - i ] ) / 2.00 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt [ i + 1 ] = cnt [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( cnt [ r - 1 ] - cnt [ l - 1 ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A not in d : <NEWLINE> <INDENT> d [ A ] = [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A ] . append ( B ) <NEWLINE> <DEDENT> if B not in d : <NEWLINE> <INDENT> d [ B ] = [ A ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ( - 1 , float ( <STRING> ) ) ] * N <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> queue = deque ( [ ( 1 , 0 ) ] ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> val , step = queue . popleft ( ) <NEWLINE> next_vals = d [ val ] <NEWLINE> for nxt in next_vals : <NEWLINE> <COMMENT> <NL> <INDENT> if ans [ nxt - 1 ] [ 0 ] == - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans [ nxt - 1 ] = ( val , step + 1 ) <NEWLINE> queue . append ( ( nxt , step + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt < N - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> readall = sys . stdin . read <NEWLINE> ns = lambda : readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> h , w , k = nm ( ) <NEWLINE> sy , sx , gy , gx = nm ( ) <NEWLINE> d = [ ( 0 , 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> sx -= 1 ; sy -= 1 <NEWLINE> gx -= 1 ; gy -= 1 <NEWLINE> C = [ ns ( ) for _ in range ( h ) ] <NEWLINE> G = [ [ 10 ** 7 ] * w for _ in range ( h ) ] <NEWLINE> G [ sy ] [ sx ] = 0 <NEWLINE> q = deque ( [ ( sy , sx ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> y , x = q . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> dy , dx = d [ i ] <NEWLINE> ny , nx = y , x <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> ny += dy ; nx += dx <NEWLINE> if ny < 0 or h <= ny or nx < 0 or w <= nx : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if C [ ny ] [ nx ] == <STRING> or G [ ny ] [ nx ] <= G [ y ] [ x ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if G [ ny ] [ nx ] > G [ y ] [ x ] + 1 : <NEWLINE> <INDENT> G [ ny ] [ nx ] = G [ y ] [ x ] + 1 <NEWLINE> q . append ( ( ny , nx ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = G [ gy ] [ gx ] <NEWLINE> print ( ans if ans < 10 ** 7 else - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> L11 = [ 0 ] * 10 <NEWLINE> L12 = [ 0 ] * 10 <NEWLINE> L13 = [ 0 ] * 10 <NEWLINE> L21 = [ 0 ] * 10 <NEWLINE> L22 = [ 0 ] * 10 <NEWLINE> L23 = [ 0 ] * 10 <NEWLINE> L31 = [ 0 ] * 10 <NEWLINE> L32 = [ 0 ] * 10 <NEWLINE> L33 = [ 0 ] * 10 <NEWLINE> L41 = [ 0 ] * 10 <NEWLINE> L42 = [ 0 ] * 10 <NEWLINE> L43 = [ 0 ] * 10 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> r -= 1 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> L11 [ r ] += v <NEWLINE> <DEDENT> if f == 2 : <NEWLINE> <INDENT> L12 [ r ] += v <NEWLINE> <DEDENT> if f == 3 : <NEWLINE> <INDENT> L13 [ r ] += v <NEWLINE> <DEDENT> <DEDENT> if b == 2 : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> L21 [ r ] += v <NEWLINE> <DEDENT> if f == 2 : <NEWLINE> <INDENT> L22 [ r ] += v <NEWLINE> <DEDENT> if f == 3 : <NEWLINE> <INDENT> L23 [ r ] += v <NEWLINE> <DEDENT> <DEDENT> if b == 3 : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> L31 [ r ] += v <NEWLINE> <DEDENT> if f == 2 : <NEWLINE> <INDENT> L32 [ r ] += v <NEWLINE> <DEDENT> if f == 3 : <NEWLINE> <INDENT> L33 [ r ] += v <NEWLINE> <DEDENT> <DEDENT> if b == 4 : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> L41 [ r ] += v <NEWLINE> <DEDENT> if f == 2 : <NEWLINE> <INDENT> L42 [ r ] += v <NEWLINE> <DEDENT> if f == 3 : <NEWLINE> <INDENT> L43 [ r ] += v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def PV ( L ) : <NEWLINE> <INDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( L [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> + str ( L [ 9 ] ) ) <NEWLINE> <NL> <DEDENT> def PL ( ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> PV ( L11 ) <NEWLINE> PV ( L12 ) <NEWLINE> PV ( L13 ) <NEWLINE> PL ( ) <NEWLINE> PV ( L21 ) <NEWLINE> PV ( L22 ) <NEWLINE> PV ( L23 ) <NEWLINE> PL ( ) <NEWLINE> PV ( L31 ) <NEWLINE> PV ( L32 ) <NEWLINE> PV ( L33 ) <NEWLINE> PL ( ) <NEWLINE> PV ( L41 ) <NEWLINE> PV ( L42 ) <NEWLINE> PV ( L43 ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> def make_adjlist_d ( n , edges ) : <NEWLINE> <INDENT> res = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> res [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> res [ edge [ 1 ] ] . append ( edge [ 0 ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def make_adjlist_nond ( n , edges ) : <NEWLINE> <INDENT> res = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> res [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def cmb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // math . factorial ( r ) // math . factorial ( n - r ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> A = NLI ( ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> ma = A [ - 1 ] <NEWLINE> hurui = [ 0 ] * ( ma + 10 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if hurui [ a ] == 0 : <NEWLINE> <INDENT> hurui [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hurui [ a ] = 10 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if hurui [ a ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for i in range ( a * 2 , ma + 10 , a ) : <NEWLINE> <INDENT> hurui [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( hurui . count ( 1 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> sum += a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> if j == l - 1 : print ( sum ) <NEWLINE> else : print ( sum , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> def parse ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> m = 1 <NEWLINE> while m * ( m + 1 ) <= 2 * n : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> return m - 1 <NEWLINE> <NL> <NL> <DEDENT> def factorint ( n ) : <NEWLINE> <INDENT> fct = [ ] <NEWLINE> b , e = 2 , 0 <NEWLINE> while b * b <= n : <NEWLINE> <INDENT> while n % b == 0 : <NEWLINE> <INDENT> n = n // b <NEWLINE> e = e + 1 <NEWLINE> <DEDENT> if e > 0 : <NEWLINE> <INDENT> fct . append ( ( b , e ) ) <NEWLINE> <DEDENT> b , e = b + 1 , 0 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> fct . append ( ( n , 1 ) ) <NEWLINE> <DEDENT> return fct <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> factors = factorint ( N ) <NEWLINE> print ( sum ( parse ( v ) for _ , v in factors ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n + 1 ) ] <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def same_check ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i ] = [ i , a , b ] <NEWLINE> <NL> <DEDENT> B = copy . deepcopy ( A ) <NEWLINE> A = sorted ( A , key = lambda x : x [ 1 ] ) <NEWLINE> B = sorted ( B , key = lambda x : x [ 2 ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> A2 = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l = abs ( A [ i ] [ 1 ] - A [ i - 1 ] [ 1 ] ) <NEWLINE> A2 [ i - 1 ] = [ A [ i ] [ 0 ] , A [ i - 1 ] [ 0 ] , l ] <NEWLINE> <NL> <DEDENT> B2 = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l = abs ( B [ i ] [ 2 ] - B [ i - 1 ] [ 2 ] ) <NEWLINE> B2 [ i - 1 ] = [ B [ i ] [ 0 ] , B [ i - 1 ] [ 0 ] , l ] <NEWLINE> <DEDENT> Len = A2 + B2 <NEWLINE> Len = sorted ( Len , key = lambda x : x [ 2 ] ) <NEWLINE> <COMMENT> <NL> <NL> data = UnionFind ( N + 1 ) <NEWLINE> cost = 0 <NEWLINE> for i in range ( len ( Len ) ) : <NEWLINE> <INDENT> if not data . same_check ( Len [ i ] [ 0 ] , Len [ i ] [ 1 ] ) : <NEWLINE> <INDENT> data . union ( Len [ i ] [ 0 ] , Len [ i ] [ 1 ] ) <NEWLINE> cost += Len [ i ] [ 2 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cost ) <NEWLINE> <NL> <NL> <NL>
n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> edges [ u ] . append ( ( v , a , b ) ) <NEWLINE> edges [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <DEDENT> banks = tuple ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ) <NEWLINE> <NL> max_s = 50 * ( n - 1 ) <NEWLINE> <NL> s = min ( s , max_s ) <NEWLINE> <NL> import heapq <NEWLINE> <NL> h = [ ] <NEWLINE> dp = [ [ float ( <STRING> ) ] * ( max_s + 1 ) for _ in range ( n ) ] <NEWLINE> ans = [ float ( <STRING> ) ] * n <NEWLINE> <NL> heapq . heappush ( h , ( 0 , 0 , s ) ) <NEWLINE> while h : <NEWLINE> <INDENT> time , node , coin = heapq . heappop ( h ) <NEWLINE> if time >= dp [ node ] [ coin ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ node ] [ coin ] = time <NEWLINE> if time < ans [ node ] : <NEWLINE> <INDENT> ans [ node ] = time <NEWLINE> <NL> <DEDENT> c , d = banks [ node ] <NEWLINE> if coin < max_s : <NEWLINE> <INDENT> heapq . heappush ( h , ( time + d , node , min ( coin + c , max_s ) ) ) <NEWLINE> <NL> <DEDENT> for n , a , b in edges [ node ] : <NEWLINE> <INDENT> new_time = time + b <NEWLINE> new_coin = coin - a <NEWLINE> if new_coin < 0 or new_time >= dp [ n ] [ new_coin ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> heapq . heappush ( h , ( new_time , n , new_coin ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> nums = [ int ( n ) for n in stdin ] <NEWLINE> <NL> primes = list ( filter ( is_prime , nums ) ) <NEWLINE> print ( len ( primes ) ) <NEWLINE> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if 1 == n : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if 2 == n : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if 0 == n % 2 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if not i <= int ( n / i ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if 0 == n % i : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <COMMENT> <NL> def solve ( A ) : <NEWLINE> <INDENT> count = np . zeros ( 10 ** 6 + 10 , np . int32 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> if count [ x ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count [ : : x ] += 1 <NEWLINE> <DEDENT> ret = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> ret += count [ x ] == 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , np . int32 ) <NEWLINE> <NL> print ( solve ( A ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 9 ** 9 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ a - 1 ] . append ( b - 1 ) <NEWLINE> L [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> A = [ 0 ] + [ - 1 ] * ( n - 1 ) <NEWLINE> B = [ [ 0 , L [ 0 ] ] ] <NEWLINE> def wfs ( A , B ) : <NEWLINE> <INDENT> C = [ ] <NEWLINE> f = False <NEWLINE> for b in B : <NEWLINE> <INDENT> for l in b [ 1 ] : <NEWLINE> <INDENT> if A [ l ] == - 1 : <NEWLINE> <INDENT> A [ l ] = b [ 0 ] <NEWLINE> C . append ( [ l , L [ l ] ] ) <NEWLINE> f = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> return wfs ( A , C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> wfs ( A , B ) <NEWLINE>
from itertools import combinations , combinations_with_replacement <NEWLINE> from math import sqrt <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for x , y , z in combinations_with_replacement ( range ( 1 , int ( sqrt ( n ) ) ) , 3 ) : <NEWLINE> <INDENT> i = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if i <= n : <NEWLINE> <INDENT> if x == y == z : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> elif all ( [ ( s != t ) for s , t in combinations ( [ x , y , z ] , 2 ) ] ) : <NEWLINE> <INDENT> ans [ i ] += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] += 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> S = list ( reversed ( S ) ) <NEWLINE> <NL> m = 2019 <NEWLINE> cnt = [ 0 for i in range ( m ) ] <NEWLINE> <NL> len_S = len ( S ) <NEWLINE> x = 1 <NEWLINE> tot = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> cnt [ tot ] += 1 <NEWLINE> tot += ( ord ( S [ i ] ) - ord ( <STRING> ) ) * x <NEWLINE> tot %= m <NEWLINE> ans += cnt [ tot ] <NEWLINE> x = x * 10 % m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
M , N = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> P = [ <STRING> * ( N + 1 ) for _ in range ( M + 1 ) ] <NEWLINE> for mi in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> P [ mi ] = <STRING> + input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> J = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ] <NEWLINE> O = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ] <NEWLINE> I = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> ji , oi , ii = 0 , 0 , 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ji += P [ i ] [ j ] == <STRING> <NEWLINE> oi += P [ i ] [ j ] == <STRING> <NEWLINE> ii += P [ i ] [ j ] == <STRING> <NEWLINE> J [ i ] [ j ] = J [ i - 1 ] [ j ] + ji <NEWLINE> O [ i ] [ j ] = O [ i - 1 ] [ j ] + oi <NEWLINE> I [ i ] [ j ] = I [ i - 1 ] [ j ] + ii <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> def cum ( mat , a , b , c , d ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> return mat [ a ] [ b ] + mat [ c ] [ d ] - mat [ a ] [ d ] - mat [ c ] [ b ] <NEWLINE> <NL> <NL> <DEDENT> for k in range ( K ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> j = cum ( J , a , b , c , d ) <NEWLINE> o = cum ( O , a , b , c , d ) <NEWLINE> i = cum ( I , a , b , c , d ) <NEWLINE> print ( j , o , i ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lcm = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> lcm = lcm * i // gcd ( lcm , i ) <NEWLINE> <DEDENT> lcm %= mod <NEWLINE> <NL> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans += lcm * pow ( i , mod - 2 , mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a % 3 == 0 or b % 3 == 0 or ( a + b ) % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> i = 0 <NEWLINE> B . append ( 1 ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> B . append ( A [ i ] ) <NEWLINE> i = A [ i ] - 1 <NEWLINE> <DEDENT> if K > N : <NEWLINE> <INDENT> start = 0 <NEWLINE> num = 0 <NEWLINE> for j in range ( len ( B ) ) : <NEWLINE> <INDENT> if B [ len ( B ) - 1 ] == B [ j ] : <NEWLINE> <INDENT> start = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , len ( B ) - start ) : <NEWLINE> <INDENT> if B [ start + j ] == B [ start ] : <NEWLINE> <INDENT> num = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( B [ ( ( K - start ) % num ) + start ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ K ] ) <NEWLINE> <DEDENT>
l = input ( ) . split ( ) <NEWLINE> l . sort ( ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> a = int ( X / D ) <NEWLINE> if a < K : <NEWLINE> <INDENT> K -= a <NEWLINE> X -= a * D <NEWLINE> <NL> <DEDENT> if K * D <= X : <NEWLINE> <INDENT> X -= K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K %= 2 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if X > 0 : <NEWLINE> <INDENT> X -= D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += D <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( abs ( X ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if all ( [ i > 0 for i in a ] ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> mod = ( 10 ** 9 ) + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> suma = sum ( a ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> suma -= a [ i ] <NEWLINE> ans += a [ i ] * suma <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> mn = min ( A , K ) <NEWLINE> s += mn <NEWLINE> K -= mn <NEWLINE> <NL> mn = min ( B , K ) <NEWLINE> K -= mn <NEWLINE> <NL> mn = min ( C , K ) <NEWLINE> s -= mn <NEWLINE> K -= mn <NEWLINE> <NL> print ( s ) <NEWLINE>
import math <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for k in range ( 2 , math . floor ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> divisors . append ( k ) <NEWLINE> divisors . append ( n // k ) <NEWLINE> <NL> <DEDENT> <DEDENT> divisors . append ( n ) <NEWLINE> <NL> return sorted ( divisors ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> original_n = n <NEWLINE> <NL> factors = [ ] <NEWLINE> divisors = make_divisors ( n ) <NEWLINE> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if n % divisors [ i ] == 0 : <NEWLINE> <INDENT> n //= divisors [ i ] <NEWLINE> factors . append ( divisors [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( <NEWLINE> <INDENT> original_n , <NEWLINE> <STRING> . join ( list ( map ( str , factors ) ) ) <NEWLINE> <DEDENT> ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> import bisect <NEWLINE> <NL> <NL> <NL> def main ( args ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> fisher , event = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> fishes = [ 0 for _ in range ( fisher + 1 ) ] <NEWLINE> <NL> winner = 9999999999 <NEWLINE> max_fish = - 1 <NEWLINE> for _ in range ( event ) : <NEWLINE> <INDENT> id , fish = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> fishes [ id ] += fish <NEWLINE> if fish > 0 : <NEWLINE> <INDENT> if fishes [ id ] > max_fish : <NEWLINE> <INDENT> max_fish = fishes [ id ] <NEWLINE> winner = id <NEWLINE> <DEDENT> elif fishes [ id ] == max_fish : <NEWLINE> <INDENT> winner = min ( winner , id ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if winner == id : <NEWLINE> <INDENT> max_fish = max ( fishes ) <NEWLINE> winner = fishes . index ( max_fish ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( winner , max_fish ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> <NL> debug = False <NEWLINE> <NL> def log ( text ) : <NEWLINE> <INDENT> if debug : <NEWLINE> <INDENT> print ( text ) <NEWLINE> <NL> <DEDENT> <DEDENT> def parse_input ( lines_as_string = None ) : <NEWLINE> <NL> <INDENT> global debug <NEWLINE> lines = [ ] <NEWLINE> if lines_as_string is None : <NEWLINE> <INDENT> debug = False <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> lines . append ( line . strip ( ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> debug = True <NEWLINE> lines = [ e for e in lines_as_string . split ( <STRING> ) ] [ 1 : - 1 ] <NEWLINE> <NL> <DEDENT> n = lines [ 0 ] <NEWLINE> <NL> return ( n , ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( n , ) : <NEWLINE> <NL> <NL> <INDENT> total = sum ( [ int ( e ) for e in n ] ) <NEWLINE> <NL> result = <STRING> <NEWLINE> <COMMENT> <NL> if total % 9 == 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <NL> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> result = solve ( * parse_input ( ) ) <NEWLINE> if isinstance ( result , list ) : <NEWLINE> <INDENT> for r in result : <NEWLINE> <INDENT> print ( <STRING> % r , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % result , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
MAX = 10 ** 5 + 1 <NEWLINE> f = [ True ] * ( MAX ) <NEWLINE> c = [ 0 ] * ( MAX + 1 ) <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> if f [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , MAX , i ) : <NEWLINE> <INDENT> f [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 , MAX , 2 ) : <NEWLINE> <INDENT> if f [ i ] and f [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 , MAX ) : <NEWLINE> <INDENT> c [ i ] += c [ i - 1 ] <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( c [ r ] - c [ l - 1 ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> get = input ( ) <NEWLINE> <NL> if get not in dic : <NEWLINE> <INDENT> dic [ get ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( dic ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = ( N // i ) <NEWLINE> ret += x * ( x + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def bfs ( start , line ) : <NEWLINE> <INDENT> quene = deque ( [ start ] ) <NEWLINE> d = [ None ] * len ( line ) <COMMENT> <NEWLINE> d [ start ] = 0 <NEWLINE> ans = [ None ] * len ( line ) <NEWLINE> while quene : <NEWLINE> <INDENT> v = quene . popleft ( ) <NEWLINE> for i in line [ v ] : <NEWLINE> <INDENT> if d [ i ] is None : <NEWLINE> <INDENT> d [ i ] = d [ v ] + 1 <NEWLINE> ans [ i ] = v <NEWLINE> quene . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> checker = [ 0 ] <NEWLINE> line = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> line [ x ] . append ( y ) <NEWLINE> line [ y ] . append ( x ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> ans = bfs ( 0 , line ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ 0 ] * m <NEWLINE> S = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> P [ i ] , S [ i ] = map ( str , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> WA = [ 0 ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> AC = [ False ] * ( n + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p = int ( P [ i ] ) <NEWLINE> if AC [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> WA [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC [ p ] = True <NEWLINE> cnt += WA [ p ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ac = sum ( AC ) <NEWLINE> print ( ac , cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if result <= 10 ** 18 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <NL> <DEDENT> <DEDENT>
H , W , M , * hw = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> H_cnt = [ 0 ] * ( H + 1 ) <NEWLINE> W_cnt = [ 0 ] * ( W + 1 ) <NEWLINE> bombs = [ ( h , w ) for h , w in zip ( * [ iter ( hw ) ] * 2 ) ] <NEWLINE> for h , w in bombs : <NEWLINE> <INDENT> H_cnt [ h ] += 1 <NEWLINE> W_cnt [ w ] += 1 <NEWLINE> <NL> <DEDENT> H_max_cnt = max ( H_cnt ) <NEWLINE> W_max_cnt = max ( W_cnt ) <NEWLINE> <NL> H_max = { i for i in range ( 1 , H + 1 ) if H_cnt [ i ] == H_max_cnt } <NEWLINE> W_max = { i for i in range ( 1 , W + 1 ) if W_cnt [ i ] == W_max_cnt } <NEWLINE> <NL> comb_cnt = len ( H_max ) * len ( W_max ) <NEWLINE> for h , w in bombs : <NEWLINE> <INDENT> if H_cnt [ h ] == H_max_cnt and W_cnt [ w ] == W_max_cnt : <NEWLINE> <INDENT> comb_cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = H_max_cnt + W_max_cnt <NEWLINE> print ( ans if comb_cnt else ans - 1 ) <NEWLINE>
N , K = input ( ) . split ( <STRING> ) <NEWLINE> NA = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> if NA - K > K : <NEWLINE> <INDENT> NA = NA - K * ( NA // K - 1 ) <NEWLINE> <DEDENT> N1 = abs ( NA - K ) <NEWLINE> <NL> while N1 < NA : <NEWLINE> <INDENT> NA = N1 <NEWLINE> N1 = abs ( N1 - K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( NA ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = [ x ] <NEWLINE> c = set ( ) <NEWLINE> c . add ( x ) <NEWLINE> <NL> for i in range ( m + 1 ) : <NEWLINE> <INDENT> x = x * x % m <NEWLINE> if x in c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt . append ( x ) <NEWLINE> c . add ( x ) <NEWLINE> <NL> <DEDENT> start = cnt . index ( x ) <NEWLINE> <NL> ans = sum ( cnt [ : start ] ) <NEWLINE> roop = len ( cnt ) - start <NEWLINE> <NL> n = n - start <NEWLINE> ans = ans + ( n // roop ) * sum ( cnt [ start : ] ) + sum ( list ( cnt ) [ start : ( start + n % roop ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> product = 1 <NEWLINE> A . sort ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> product *= A [ i ] <NEWLINE> if ( product > 10 ** 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( product <= 10 ** 18 ) : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> <NL> x = [ int ( a [ 0 ] ) , int ( a [ 1 ] ) ] <NEWLINE> y = [ int ( a [ 2 ] ) , int ( a [ 3 ] ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> for j in y : <NEWLINE> <INDENT> s = i * j <NEWLINE> <NL> ans . append ( s ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( reverse = True ) <NEWLINE> print ( ans [ 0 ] ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> ans = 0 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> query = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , readline ( ) . split ( ) ) <NEWLINE> query . append ( ( a , b , c , d ) ) <NEWLINE> <NL> <DEDENT> def getScore ( array ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for a , b , c , d in query : <NEWLINE> <INDENT> if array [ b - 1 ] - array [ a - 1 ] == c : <NEWLINE> <INDENT> res += d <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> A = [ 0 ] * N <NEWLINE> <NL> def dfs ( idx ) : <NEWLINE> <INDENT> global ans <NEWLINE> if idx == N : <NEWLINE> <INDENT> ans = max ( getScore ( A ) , ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if idx == 0 : <NEWLINE> <INDENT> k = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = A [ idx - 1 ] <NEWLINE> <DEDENT> for i in range ( k , M + 1 ) : <NEWLINE> <INDENT> A [ idx ] = i <NEWLINE> dfs ( idx + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = sum ( a ) <NEWLINE> calc = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_a -= a [ i ] <NEWLINE> calc += ( ( sum_a % 1000000007 ) * a [ i ] ) % 1000000007 <NEWLINE> <DEDENT> calc %= 1000000007 <NEWLINE> print ( calc ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( int ( 10 ** 9 ) ) <NEWLINE> n , m = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> edges = collections . defaultdict ( list ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , d = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> edges [ s - 1 ] . append ( d - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> maxPath = 0 <NEWLINE> @ lru_cache ( None ) <NEWLINE> def dfs ( node ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in edges [ node ] : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i ) + 1 ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> maxPath = max ( dfs ( i ) , maxPath ) <NEWLINE> <DEDENT> print ( maxPath ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> cards = [ [ False for x in range ( 13 ) ] for y in range ( 4 ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> s , v = map ( str , input ( ) . split ( ) ) <NEWLINE> u = int ( v ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> cards [ 0 ] [ u - 1 ] = True <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> cards [ 1 ] [ u - 1 ] = True <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> cards [ 2 ] [ u - 1 ] = True <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> cards [ 3 ] [ u - 1 ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if cards [ 0 ] [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if cards [ 1 ] [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if cards [ 2 ] [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if cards [ 3 ] [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( j + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> def calculate ( n , s ) : <NEWLINE> <INDENT> arr = list ( s ) <NEWLINE> result = [ ] <NEWLINE> <NL> <NL> leftW = 0 <NEWLINE> rightR = arr . count ( <STRING> ) <NEWLINE> <NL> <NL> if rightR == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> val = arr [ i ] <NEWLINE> <NL> if val == <STRING> : <NEWLINE> <INDENT> rightR -= 1 <NEWLINE> <NL> <DEDENT> if val == <STRING> : <NEWLINE> <INDENT> leftW += 1 <NEWLINE> <NL> <DEDENT> result . append ( max ( leftW , rightR ) ) <NEWLINE> <NL> <DEDENT> if len ( result ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( result ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> calculate ( N , S ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = 1 <NEWLINE> visited = [ 1 ] <NEWLINE> visitedbit = [ 0 ] * ( N + 1 ) <NEWLINE> visitedbit [ 1 ] = 1 <NEWLINE> k = 0 <NEWLINE> flag = True <NEWLINE> while True : <NEWLINE> <NL> <INDENT> k += 1 <NEWLINE> <COMMENT> <NL> if k == K : <NEWLINE> <INDENT> print ( A [ n ] ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> if visitedbit [ A [ n ] ] == 0 : <NEWLINE> <INDENT> visited . append ( A [ n ] ) <NEWLINE> visitedbit [ A [ n ] ] = 1 <NEWLINE> n = A [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hazime = visited . index ( A [ n ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <COMMENT> <NL> <INDENT> loop = visited [ hazime : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( loop [ ( K - hazime ) % ( len ( loop ) ) ] ) <NEWLINE> <DEDENT>
h = w = 0 <NEWLINE> slist = [ ] <NEWLINE> list1 = [ ] <NEWLINE> def dfs ( f ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if len ( slist ) == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> coordinate = slist . pop ( ) <NEWLINE> <COMMENT> <NL> x = coordinate [ 0 ] <NEWLINE> y = coordinate [ 1 ] <NEWLINE> <NL> list1 [ y ] = list1 [ y ] [ : x ] + <STRING> + list1 [ y ] [ x + 1 : ] <NEWLINE> if x + 1 < w : <NEWLINE> <INDENT> if list1 [ y ] [ x + 1 ] == f : <NEWLINE> <INDENT> slist . append ( [ x + 1 , y ] ) <NEWLINE> <DEDENT> <DEDENT> if x - 1 >= 0 : <NEWLINE> <INDENT> if list1 [ y ] [ x - 1 ] == f : <NEWLINE> <INDENT> slist . append ( [ x - 1 , y ] ) <NEWLINE> <DEDENT> <DEDENT> if y + 1 < h : <NEWLINE> <INDENT> if list1 [ y + 1 ] [ x ] == f : <NEWLINE> <INDENT> slist . append ( [ x , y + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if y - 1 >= 0 : <NEWLINE> <INDENT> if list1 [ y - 1 ] [ x ] == f : <NEWLINE> <INDENT> slist . append ( [ x , y - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> h , w = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if 0 in ( h , w ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = 0 <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> list1 . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> if list1 [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> slist . append ( [ j , i ] ) <NEWLINE> n += dfs ( list1 [ i ] [ j ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE> list1 = [ ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> <NL> rev = 0 <NEWLINE> <NL> front = [ ] <NEWLINE> end = [ ] <NEWLINE> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> rev = 1 - rev <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ( rev == 0 ) & ( query [ 1 ] == <STRING> ) ) | ( ( rev == 1 ) & ( query [ 1 ] == <STRING> ) ) : <NEWLINE> <INDENT> front . append ( query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end . append ( query [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> front = <STRING> . join ( front ) <NEWLINE> end = <STRING> . join ( end ) <NEWLINE> <NL> <NL> if rev : <NEWLINE> <INDENT> print ( end [ : : - 1 ] + S [ : : - 1 ] + front ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( front [ : : - 1 ] + S + end ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( N ) <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ j ] - h [ i ] ) for j in range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> class vector : <NEWLINE> <INDENT> def cross ( a , b ) : <NEWLINE> <INDENT> return a . real * b . imag - a . imag * b . real <NEWLINE> <NL> <DEDENT> def dot ( a , b ) : <NEWLINE> <INDENT> return a . real * b . real + a . imag * b . imag <NEWLINE> <NL> <DEDENT> def ccw ( a , b , c ) : <NEWLINE> <INDENT> b -= a <NEWLINE> c -= a <NEWLINE> if vector . cross ( b , c ) > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if vector . cross ( b , c ) < 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> if vector . dot ( b , c ) < 0 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> if abs ( b ) < abs ( c ) : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> return 5 <NEWLINE> <NL> <DEDENT> def polygon ( p ) : <NEWLINE> <INDENT> if len ( p ) < 3 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 0.5 * sum ( vector . cross ( p [ i - 1 ] , p [ i ] ) for i in range ( len ( p ) ) ) <NEWLINE> <NL> <DEDENT> def intersection ( p1 , p2 , p3 , p4 ) : <NEWLINE> <INDENT> a1 = p4 - p2 <NEWLINE> b1 = p2 - p3 <NEWLINE> b2 = p1 - p2 <NEWLINE> s1 = vector . cross ( a1 , b2 ) / 2 <NEWLINE> s2 = vector . cross ( a1 , b1 ) / 2 <NEWLINE> if s1 + s2 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> c1 = p1 + ( p3 - p1 ) * s1 / ( s1 + s2 ) <NEWLINE> return c1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) ) <NEWLINE> p = [ map ( float , readline ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> p = [ x + y * 1j for x , y in p ] <NEWLINE> q = int ( readline ( ) ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p1x , p1y , p2x , p2y = map ( float , readline ( ) . split ( ) ) <NEWLINE> p1 , p2 = p1x + p1y * 1j , p2x + p2y * 1j <NEWLINE> <NL> pre_tmp = vector . ccw ( p [ - 1 ] , p1 , p2 ) <NEWLINE> left = [ ] <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> tmp = vector . ccw ( p [ i ] , p1 , p2 ) <NEWLINE> if pre_tmp != tmp and all ( i in ( 1 , 2 ) for i in ( pre_tmp , tmp ) ) : <NEWLINE> <INDENT> c1 = vector . intersection ( p1 , p [ i - 1 ] , p2 , p [ i ] ) <NEWLINE> left . append ( c1 ) <NEWLINE> <DEDENT> if tmp != 2 : <NEWLINE> <INDENT> left . append ( p [ i ] ) <NEWLINE> <NL> <DEDENT> pre_tmp = tmp <NEWLINE> <DEDENT> print ( <STRING> . format ( vector . polygon ( left ) ) ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> a_len = len ( a ) <NEWLINE> b_len = len ( b ) <NEWLINE> <NL> huku = [ ] <NEWLINE> <NL> for i in range ( a_len ) : <NEWLINE> <INDENT> if a_len != b_len and i == a_len - 1 : <NEWLINE> <INDENT> huku . append ( a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> huku . append ( a [ i ] ) <NEWLINE> huku . append ( b [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( huku ) ) : <NEWLINE> <INDENT> print ( huku [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = list ( accumulate ( A [ : - 1 ] , gcd , initial = 0 ) ) <NEWLINE> r = list ( accumulate ( A [ : : - 1 ] , gcd , initial = 0 ) ) <NEWLINE> print ( max ( gcd ( l [ i ] , r [ N - i - 1 ] ) for i in range ( N ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> DAY = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> print ( 7 - DAY . index ( S ) ) <NEWLINE>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> stage = [ input ( ) for i in range ( h ) ] <NEWLINE> starts = [ str ( i ) for i in range ( n ) ] <NEWLINE> goals = [ str ( i + 1 ) for i in range ( n ) ] <NEWLINE> starts_y = [ 0 for i in range ( n ) ] <NEWLINE> starts_x = [ 0 for i in range ( n ) ] <NEWLINE> goals_y = [ 0 for i in range ( n ) ] <NEWLINE> goals_x = [ 0 for i in range ( n ) ] <NEWLINE> <NL> starts [ 0 ] = <STRING> <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if stage [ y ] [ x ] in starts : <NEWLINE> <INDENT> starts_y [ starts . index ( stage [ y ] [ x ] ) ] = y <NEWLINE> starts_x [ starts . index ( stage [ y ] [ x ] ) ] = x <NEWLINE> <DEDENT> if stage [ y ] [ x ] in goals : <NEWLINE> <INDENT> goals_y [ goals . index ( stage [ y ] [ x ] ) ] = y <NEWLINE> goals_x [ goals . index ( stage [ y ] [ x ] ) ] = x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <NL> for start_y , start_x , goal_y , goal_x in zip ( starts_y , starts_x , goals_y , goals_x ) : <NEWLINE> <INDENT> bfs_map = [ [ - 1 for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> data_y = [ start_y ] <NEWLINE> data_x = [ start_x ] <NEWLINE> bfs_map [ start_y ] [ start_x ] = 0 <NEWLINE> goal = False <NEWLINE> <NL> while len ( data_y ) != 0 and not goal : <NEWLINE> <INDENT> y = data_y . pop ( 0 ) <NEWLINE> x = data_x . pop ( 0 ) <NEWLINE> goal = False <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = y + [ 1 , - 1 , 0 , 0 ] [ i ] <NEWLINE> nx = x + [ 0 , 0 , 1 , - 1 ] [ i ] <NEWLINE> <NL> if ny >= 0 and ny < h and nx >= 0 and nx < w : <NEWLINE> <INDENT> if bfs_map [ ny ] [ nx ] == - 1 and stage [ ny ] [ nx ] != <STRING> : <NEWLINE> <INDENT> bfs_map [ ny ] [ nx ] = bfs_map [ y ] [ x ] + 1 <NEWLINE> data_y . append ( ny ) <NEWLINE> data_x . append ( nx ) <NEWLINE> <DEDENT> <DEDENT> if bfs_map [ goal_y ] [ goal_x ] != - 1 : <NEWLINE> <INDENT> sum += bfs_map [ goal_y ] [ goal_x ] <NEWLINE> goal = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ b ] . append ( a ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * n <NEWLINE> que = deque ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if dist [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] = 0 <NEWLINE> que . append ( i ) <NEWLINE> while len ( que ) : <NEWLINE> <INDENT> v = que . pop ( ) <NEWLINE> s = G [ v ] <NEWLINE> for j in s : <NEWLINE> <INDENT> if dist [ j ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ j ] = 0 <NEWLINE> que . append ( j ) <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt - 1 ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> satu = [ 1000 , 5000 , 10000 ] <NEWLINE> <NL> sen = [ 1000 * i for i in range ( n + 1 ) ] <NEWLINE> gsen = [ 5000 * i for i in range ( n + 1 ) ] <NEWLINE> man = [ 10000 * i for i in range ( n + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> if man [ i ] + gsen [ j ] + sen [ n - i - j ] == y : <NEWLINE> <INDENT> print ( i , j , n - i - j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL>
ans = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> print ( ans [ n - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> S = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> if len ( set ( S ) ) == 1 or N < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> Rs = S . count ( <STRING> ) <NEWLINE> Gs = S . count ( <STRING> ) <NEWLINE> Bs = S . count ( <STRING> ) <NEWLINE> ans = Rs * Gs * Bs <NEWLINE> <NL> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= N : break <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> row = <STRING> <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> row = row + <STRING> <NEWLINE> <DEDENT> print ( row ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def debug ( x , table ) : <NEWLINE> <INDENT> for name , val in table . items ( ) : <NEWLINE> <INDENT> if x is val : <NEWLINE> <INDENT> print ( <STRING> . format ( name , val ) , file = sys . stderr ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def paint_col ( adj , cols , i , col ) : <NEWLINE> <INDENT> nxt = [ i ] <NEWLINE> <NL> while nxt : <NEWLINE> <INDENT> u = nxt [ - 1 ] <NEWLINE> try : <NEWLINE> <INDENT> v = next ( adj [ u ] ) <NEWLINE> if cols [ v ] == 0 : <NEWLINE> <INDENT> cols [ v ] = col <NEWLINE> nxt . append ( v ) <NEWLINE> <DEDENT> <DEDENT> except StopIteration : <NEWLINE> <INDENT> nxt . pop ( ) <NEWLINE> cols [ u ] = col <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> adj [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> cols = [ 0 ] * n <NEWLINE> col = 1 <NEWLINE> adj = list ( map ( iter , adj ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if cols [ i ] == 0 : <NEWLINE> <INDENT> paint_col ( adj , cols , i , col ) <NEWLINE> col += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> q = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> if cols [ s ] == cols [ t ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min_sum = 100000 * 5000 + 100000 * 5000 + 200000 * 5000 <NEWLINE> <NL> if a == c and b == c : <NEWLINE> <INDENT> min_sum = a * x + b * y <NEWLINE> <DEDENT> elif a < c and b < c or a == c and b < c or a < c and b == c : <NEWLINE> <INDENT> min_sum = a * x + b * y <NEWLINE> <DEDENT> elif a > c and b > c or a == c and b > c or a > c and b == c : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> min_sum = y * 2 * c <NEWLINE> if a > c * 2 : <NEWLINE> <INDENT> min_sum = min_sum + ( x - y ) * c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_sum = min_sum + ( x - y ) * a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> min_sum = x * 2 * c <NEWLINE> if b > c * 2 : <NEWLINE> <INDENT> min_sum = min_sum + ( y - x ) * c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_sum = min_sum + ( y - x ) * b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a < c and b > c : <NEWLINE> <INDENT> if c - a > b - c : <COMMENT> <NEWLINE> <INDENT> min_sum = a * x + b * y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> min_sum = ( x - y ) * a + y * c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_sum = ( y - x ) * b + x * c * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a > c and b < c : <NEWLINE> <INDENT> if c - b > a - c : <COMMENT> <NEWLINE> <INDENT> min_sum = a * x + b * y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> min_sum = ( x - y ) * a + y * c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_sum = ( y - x ) * b + x * c * 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , y + 1 ) : <NEWLINE> <INDENT> if min_sum > a * i + b * j + max ( x - i , y - j ) * c * 2 : <NEWLINE> <INDENT> min_sum = a * i + b * j + max ( x - i , y - j ) * c * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min_sum ) <NEWLINE> <DEDENT> main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> from math import gcd <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> P = 2019 <NEWLINE> <NL> ans , base = 0 , 1 <NEWLINE> MOD_list = [ 0 ] <NEWLINE> <NL> for st in S [ : : - 1 ] : <NEWLINE> <INDENT> num = int ( st ) <NEWLINE> MOD = ( MOD_list [ - 1 ] + num * base ) % P <NEWLINE> MOD_list . append ( MOD ) <NEWLINE> base *= 10 <NEWLINE> base %= P <NEWLINE> <NL> <DEDENT> c = Counter ( MOD_list ) <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> ans += ( v * ( v - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> a . append ( 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + a_list [ i ] ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> b . append ( 0 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + b_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ m ] > k : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + m ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> nums [ 0 ] = 1 <NEWLINE> if 1 not in a : nums [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i not in a : nums [ i ] = nums [ i - 1 ] + nums [ i - 2 ] <NEWLINE> <DEDENT> print ( nums [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if c [ 0 ] == 0 : <NEWLINE> <INDENT> a [ c [ 1 ] ] . append ( c [ 2 ] ) <NEWLINE> <DEDENT> elif c [ 0 ] == 1 : <NEWLINE> <INDENT> if a [ c [ 1 ] ] : <NEWLINE> <INDENT> print ( a [ c [ 1 ] ] [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ c [ 1 ] ] : <NEWLINE> <INDENT> a [ c [ 1 ] ] . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 110000 ) <COMMENT> <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( 110000 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> dp_memo = [ - 1 ] * 110000 <NEWLINE> <NL> def dp ( v ) : <NEWLINE> <INDENT> if dp_memo [ v ] != - 1 : <NEWLINE> <INDENT> return dp_memo [ v ] <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for item in graph [ v ] : <NEWLINE> <INDENT> ret = max ( ret , dp ( item ) + 1 ) <NEWLINE> <NL> <DEDENT> dp_memo [ v ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , dp ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def isPrime ( num ) : <NEWLINE> <INDENT> prime = True <NEWLINE> save = num <NEWLINE> save2 = None <NEWLINE> for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> prime = False <NEWLINE> save = i <NEWLINE> save2 = num // i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return prime , save , save2 <NEWLINE> <NL> <DEDENT> store = defaultdict ( int ) <NEWLINE> <NL> def solve ( num ) : <NEWLINE> <INDENT> check , num1 , num2 = isPrime ( num ) <NEWLINE> if check == True : <NEWLINE> <INDENT> global store <NEWLINE> store [ num1 ] += 1 <NEWLINE> <DEDENT> if check == False : <NEWLINE> <INDENT> solve ( num1 ) <NEWLINE> solve ( num2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> solve ( n ) <NEWLINE> for key , v in store . items ( ) : <NEWLINE> <INDENT> for i in range ( 1 , v + 1 ) : <NEWLINE> <INDENT> if store [ key ] >= i : <NEWLINE> <INDENT> store [ key ] -= i <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in B : <NEWLINE> <INDENT> ans += bisect . bisect_left ( A , i ) * ( N - bisect . bisect_right ( C , i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> C = [ 0 for i in range ( 2019 ) ] <NEWLINE> C [ 0 ] = 1 <NEWLINE> now = 0 <NEWLINE> tenfactor = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = int ( S [ - i - 1 ] ) <NEWLINE> now = ( now + s * tenfactor ) % 2019 <NEWLINE> tenfactor = tenfactor * 10 % 2019 <NEWLINE> C [ now ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += C [ i ] * ( C [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> ls_S = list ( S ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while len ( ls_S ) != 0 : <NEWLINE> <INDENT> if <STRING> . join ( ls_S [ len ( ls_S ) - 5 : ] ) == <STRING> : <NEWLINE> <INDENT> ls_S = ls_S [ : len ( ls_S ) - 5 ] <NEWLINE> <DEDENT> elif <STRING> . join ( ls_S [ len ( ls_S ) - 5 : ] ) == <STRING> : <NEWLINE> <INDENT> ls_S = ls_S [ : len ( ls_S ) - 5 ] <NEWLINE> <DEDENT> elif <STRING> . join ( ls_S [ len ( ls_S ) - 7 : ] ) == <STRING> : <NEWLINE> <INDENT> ls_S = ls_S [ : len ( ls_S ) - 7 ] <NEWLINE> <DEDENT> elif <STRING> . join ( ls_S [ len ( ls_S ) - 6 : ] ) == <STRING> : <NEWLINE> <INDENT> ls_S = ls_S [ : len ( ls_S ) - 6 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def sum_of_gcd_tuples ( ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL> <NL> <DEDENT> sum_of_gcd_tuples ( ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 10 ** 4 ) : <NEWLINE> <INDENT> for b in range ( 10 ** 4 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : print ( a , b ) ; exit ( ) <NEWLINE> elif a ** 5 + b ** 5 == X : print ( a , - b ) ; exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import bisect <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> s_L = sorted ( L ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( s_L , s_L [ i ] + s_L [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mo = 10 ** 9 + 7 <NEWLINE> an = 0 <NEWLINE> wk = 0 <NEWLINE> ru = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> wk += i <NEWLINE> ru . append ( wk % mo ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> an += a [ i ] * ( ru [ n - 1 ] - ru [ i ] ) <NEWLINE> an %= mo <NEWLINE> <NL> <DEDENT> print ( an ) <NEWLINE>
import sys <NEWLINE> <NL> M = 1046527 <NEWLINE> def h1 ( key ) : <NEWLINE> <INDENT> return key % M <NEWLINE> <NL> <DEDENT> def h2 ( key ) : <NEWLINE> <INDENT> return 1 + ( key % ( M - 1 ) ) <NEWLINE> <NL> <DEDENT> def h3 ( key , i ) : <NEWLINE> <INDENT> return ( h1 ( key ) + i * h2 ( key ) ) % M <NEWLINE> <NL> <DEDENT> word_dic = { <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 } <NEWLINE> def getkey ( text ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> p = 1 <NEWLINE> for c in text : <NEWLINE> <INDENT> sum += p * word_dic [ c ] <NEWLINE> p *= 5 <NEWLINE> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> dict = [ None for i in range ( M ) ] <NEWLINE> def find ( text ) : <NEWLINE> <INDENT> key = getkey ( text ) <NEWLINE> i = 0 <NEWLINE> while i < M : <NEWLINE> <INDENT> h = h3 ( key , i ) <NEWLINE> if dict [ h ] == None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif dict [ h ] == text : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def insert ( text ) : <NEWLINE> <NL> <INDENT> key = getkey ( text ) <NEWLINE> i = 0 <NEWLINE> while i < M : <NEWLINE> <INDENT> j = h3 ( key , i ) <NEWLINE> if dict [ j ] == None : <NEWLINE> <INDENT> dict [ j ] = text <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> operations = sys . stdin . readlines ( ) <NEWLINE> for ope in operations : <NEWLINE> <INDENT> op , text = ope . rstrip ( ) . split ( <STRING> ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> insert ( text ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> rst = find ( text ) <NEWLINE> if rst : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> m = min ( s , k ) <NEWLINE> for x in range ( m + 1 ) : <NEWLINE> <INDENT> for y in range ( m + 1 ) : <NEWLINE> <INDENT> if s < x + y : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s > x + y + k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def pi ( i ) : <NEWLINE> <INDENT> global a , n <NEWLINE> s = <STRING> <NEWLINE> if i != 1 : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> if i * 2 <= n : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> if i * 2 + 1 <= n : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pi ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> tmp = 0 <NEWLINE> tmpura = 0 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> tmp += a [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> tmp = tmp ** 2 <NEWLINE> i = 0 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> tmpura += a [ i ] ** 2 <NEWLINE> i += 1 <NEWLINE> <DEDENT> tmpura = tmpura <NEWLINE> ans = ( ( tmp - tmpura ) // 2 ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
import bisect <NEWLINE> A , B , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> S = [ - INF ] + [ int ( input ( ) ) for i in range ( A ) ] + [ INF ] <NEWLINE> T = [ - INF ] + [ int ( input ( ) ) for i in range ( B ) ] + [ INF ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> i = bisect . bisect_right ( S , x ) <NEWLINE> j = bisect . bisect_right ( T , x ) <NEWLINE> d = INF <NEWLINE> for s in [ S [ i - 1 ] , S [ i ] ] : <NEWLINE> <INDENT> for t in [ T [ j - 1 ] , T [ j ] ] : <NEWLINE> <INDENT> d1 = abs ( s - x ) + abs ( s - t ) <NEWLINE> d2 = abs ( t - x ) + abs ( s - t ) <NEWLINE> d = min ( d , d1 , d2 ) <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> array = [ ] <NEWLINE> array += map ( int , input ( ) . split ( ) ) <NEWLINE> flag = 0 <NEWLINE> flag2 = 0 <NEWLINE> s = 1 <NEWLINE> for m in range ( len ( array ) ) : <NEWLINE> <INDENT> if array [ m ] == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> s = s * array [ m ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> flag2 = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> flag3 = 0 <NEWLINE> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif flag2 == 1 : <NEWLINE> <INDENT> for i in range ( m , len ( array ) ) : <NEWLINE> <INDENT> if array [ i ] == 0 : <NEWLINE> <INDENT> flag3 = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if flag3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : print ( s ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = [ ] <NEWLINE> t = [ ] <NEWLINE> nq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( nq [ 0 ] ) : <NEWLINE> <INDENT> inp = input ( ) . split ( ) <NEWLINE> n . append ( int ( inp [ 1 ] ) ) <NEWLINE> t . append ( inp [ 0 ] ) <NEWLINE> <DEDENT> cnt1 = 0 <NEWLINE> while len ( n ) != 0 : <NEWLINE> <INDENT> n [ 0 ] = n [ 0 ] - nq [ 1 ] <NEWLINE> if n [ 0 ] <= 0 : <NEWLINE> <INDENT> cnt1 = cnt1 + nq [ 1 ] + n [ 0 ] <NEWLINE> print ( t [ 0 ] , cnt1 ) <NEWLINE> n . pop ( 0 ) <NEWLINE> t . pop ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> n . append ( n [ 0 ] ) <NEWLINE> t . append ( t [ 0 ] ) <NEWLINE> n . pop ( 0 ) <NEWLINE> t . pop ( 0 ) <NEWLINE> cnt1 += nq [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT>
from math import sqrt , ceil <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> unit = ceil ( sqrt ( n ) ) <NEWLINE> <NL> l = [ ( 0 , [ 0 ] * unit ) for _ in range ( unit ) ] <NEWLINE> <NL> while q : <NEWLINE> <INDENT> op , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> sd , sm = s // unit , s % unit <NEWLINE> if op : <NEWLINE> <INDENT> t -= 1 <NEWLINE> td , tm = t // unit , t % unit <NEWLINE> if sd == td : <NEWLINE> <INDENT> print ( sum ( l [ sd ] [ 1 ] [ sm : tm + 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> unit_sum = sum ( ( tup [ 0 ] for tup in l [ sd + 1 : td ] ) ) <NEWLINE> s_sum = sum ( l [ sd ] [ 1 ] [ sm : ] ) <NEWLINE> t_sum = sum ( l [ td ] [ 1 ] [ : tm + 1 ] ) <NEWLINE> print ( unit_sum + s_sum + t_sum ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tup = l [ sd ] <NEWLINE> tup [ 1 ] [ sm ] += t <NEWLINE> l [ sd ] = ( tup [ 0 ] + t , tup [ 1 ] ) <NEWLINE> <DEDENT> q -= 1 <NEWLINE> <DEDENT>
from itertools import permutations , accumulate <NEWLINE> mod = 2019 <NEWLINE> <NL> a = list ( map ( int , input ( ) ) ) <NEWLINE> n = len ( a ) <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] *= pow ( 10 , n - i - 1 , mod ) <COMMENT> <NEWLINE> <NL> <DEDENT> s = [ 0 ] + list ( accumulate ( a ) ) <COMMENT> <NEWLINE> d = [ 0 ] * mod <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> j = i % mod <NEWLINE> ans += d [ j ] <NEWLINE> d [ j ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> backward = [ 0 ] * n <NEWLINE> forward = [ 0 ] * n <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i + a < n : <NEWLINE> <INDENT> forward [ i + a ] += 1 <NEWLINE> <DEDENT> if i - a >= 0 : <NEWLINE> <INDENT> backward [ i - a ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x , y in zip ( forward , backward ) : <NEWLINE> <INDENT> ans += x * y <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> oE = S . count ( <STRING> ) <NEWLINE> Wo = 0 <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> oE -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> Wo += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> oE -= 1 <NEWLINE> <DEDENT> <DEDENT> L . append ( Wo + oE ) <NEWLINE> if Wo + oE == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( min ( L ) ) <NEWLINE>
def fizz_buzz ( ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> if c % 3 == 0 : <NEWLINE> <INDENT> res = res + <STRING> <NEWLINE> <DEDENT> if c % 5 == 0 : <NEWLINE> <INDENT> res = res + <STRING> <NEWLINE> <DEDENT> if res == <STRING> : <NEWLINE> <INDENT> yield str ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield res <NEWLINE> <DEDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> <NL> player = list ( range ( m ) ) <NEWLINE> <NL> p = 0 <NEWLINE> fb = fizz_buzz ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> if len ( player ) > 1 : <NEWLINE> <INDENT> if inp != next ( fb ) : <NEWLINE> <INDENT> del player [ p ] <NEWLINE> p = p % len ( player ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = ( p + 1 ) % len ( player ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> result = str ( player [ 0 ] + 1 ) <NEWLINE> if len ( player ) > 1 : <NEWLINE> <INDENT> for pi in player [ 1 : ] : <NEWLINE> <INDENT> result += <STRING> + str ( pi + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
class Tree : <NEWLINE> <INDENT> def __init__ ( self , ary ) : <NEWLINE> <INDENT> self . nodes = [ <NEWLINE> <INDENT> Node ( node , self ) for node in sorted ( ary , key = lambda x : x [ 0 ] ) <NEWLINE> <DEDENT> ] <NEWLINE> [ node . set ( ) for node in self . nodes ] <NEWLINE> for node in self . nodes : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> self . root = node <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> self . root . set_depth ( 0 ) <NEWLINE> self . root . set_height ( ) <NEWLINE> <NL> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> [ node . output ( ) for node in self . nodes ] <NEWLINE> <NL> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> self . root . preorder ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> self . root . inorder ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> def postorder ( self ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> self . root . postorder ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , node , tree ) : <NEWLINE> <INDENT> self . tree = tree <NEWLINE> self . no = node [ 0 ] <NEWLINE> self . left = node [ 1 ] <NEWLINE> self . right = node [ 2 ] <NEWLINE> self . parent = - 1 <NEWLINE> self . sibling = - 1 <NEWLINE> self . degree = 0 <NEWLINE> <NL> <DEDENT> def set ( self ) : <NEWLINE> <INDENT> if self . left > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . left ] . parent = self . no <NEWLINE> if self . right > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . right ] . sibling = self . left <NEWLINE> <DEDENT> self . degree += 1 <NEWLINE> <NL> <DEDENT> if self . right > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . right ] . parent = self . no <NEWLINE> if self . left > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . left ] . sibling = self . right <NEWLINE> <DEDENT> self . degree += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def set_depth ( self , d ) : <NEWLINE> <INDENT> self . depth = d <NEWLINE> if self . left > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . left ] . set_depth ( d + 1 ) <NEWLINE> <DEDENT> if self . right > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . right ] . set_depth ( d + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def set_height ( self ) : <NEWLINE> <INDENT> if self . degree == 0 : <NEWLINE> <INDENT> self . height = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . tree . nodes [ self . right ] . set_height ( ) <NEWLINE> self . tree . nodes [ self . left ] . set_height ( ) <NEWLINE> self . height = 1 + max ( self . tree . nodes [ self . right ] . height , <NEWLINE> <INDENT> self . tree . nodes [ self . left ] . height ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> if self . parent == - 1 : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> elif self . degree == 0 : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kind = <STRING> <NEWLINE> <DEDENT> print ( <NEWLINE> <INDENT> <STRING> . <NEWLINE> format ( self . no , self . parent , self . sibling , self . degree , self . depth , <NEWLINE> <INDENT> self . height , kind ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . no ) , end = <STRING> ) <NEWLINE> if self . left > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . left ] . preorder ( ) <NEWLINE> <DEDENT> if self . right > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . right ] . preorder ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> if self . left > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . left ] . inorder ( ) <NEWLINE> <DEDENT> print ( <STRING> . format ( self . no ) , end = <STRING> ) <NEWLINE> if self . right > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . right ] . inorder ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def postorder ( self ) : <NEWLINE> <INDENT> if self . left > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . left ] . postorder ( ) <NEWLINE> <DEDENT> if self . right > - 1 : <NEWLINE> <INDENT> self . tree . nodes [ self . right ] . postorder ( ) <NEWLINE> <DEDENT> print ( <STRING> . format ( self . no ) , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ary = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> tree = Tree ( ary ) <NEWLINE> tree . preorder ( ) <NEWLINE> tree . inorder ( ) <NEWLINE> tree . postorder ( ) <NEWLINE> <NL>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
t = input ( ) <NEWLINE> before_is_zero = True <NEWLINE> keeped_ones = 0 <NEWLINE> n0 = 0 <NEWLINE> ones = [ 0 ] * int ( 1e5 + 1 ) <COMMENT> <NEWLINE> ones_index = 0 <NEWLINE> for i , x in enumerate ( t ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> n0 += 1 <NEWLINE> before_is_zero = True <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> if before_is_zero : <NEWLINE> <INDENT> ones [ ones_index ] = ( n0 , ( i + 1 ) % 2 ) <NEWLINE> ones_index += 1 <NEWLINE> before_is_zero = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> keeped_ones += 1 <NEWLINE> ones_index -= 1 <NEWLINE> before_is_zero = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if before_is_zero : <NEWLINE> <INDENT> if len ( ones ) > 0 : <NEWLINE> <INDENT> ones = ones [ : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = keeped_ones * n0 <NEWLINE> for i in range ( ones_index ) : <NEWLINE> <INDENT> n0_before , is_odd = ones [ i ] <NEWLINE> ans += ( n0_before + is_odd ) // 2 + ( n0 - n0_before ) <NEWLINE> <DEDENT> ans += ( keeped_ones + ( ones_index + 1 ) // 2 ) * ( keeped_ones + ones_index // 2 + 1 ) <NEWLINE> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> def get_sieved_list ( x ) : <NEWLINE> <INDENT> dp = [ 1 if item % 2 == 0 else 0 for item in range ( x + 1 ) ] <NEWLINE> dp [ : 3 ] = [ 2 , 1 , 1 ] <NEWLINE> <NL> for prim_candi in range ( 3 , x + 1 ) : <NEWLINE> <INDENT> temp_num = prim_candi <NEWLINE> while temp_num <= x : <NEWLINE> <INDENT> dp [ temp_num ] += 1 <NEWLINE> temp_num += prim_candi <NEWLINE> <DEDENT> if prim_candi >= x : <NEWLINE> <INDENT> return [ i for i in range ( x + 1 ) if dp [ i ] == 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if N > 2 : <NEWLINE> <INDENT> factor_filter = set ( get_sieved_list ( N ) ) <NEWLINE> prime_list = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> for i in factor_filter : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> for j in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> while j >= 1 and j % i == 0 : <NEWLINE> <INDENT> j //= i <NEWLINE> prime_list [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = 1 <NEWLINE> for item in prime_list : <NEWLINE> <INDENT> res *= ( item + 1 ) <NEWLINE> res %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = N <NEWLINE> <NL> <DEDENT> print ( res % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x . sort ( ) <NEWLINE> d = x [ - 1 ] - x [ 0 ] <NEWLINE> y = [ ] <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> y . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <DEDENT> y . sort ( reverse = True ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d -= y [ i ] <NEWLINE> <DEDENT> print ( d ) <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> def readinput ( ) : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> bb , cc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . append ( bb ) <NEWLINE> c . append ( cc ) <NEWLINE> <DEDENT> return n , m , a , b , c <NEWLINE> <NL> <DEDENT> def main ( n , m , a , b , c ) : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <COMMENT> <NL> <INDENT> bi = b [ i ] <NEWLINE> ci = c [ i ] <NEWLINE> j = bisect_left ( a , ci ) - 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j > bi - 1 : <NEWLINE> <INDENT> save = a [ bi : j + 1 ] <NEWLINE> l = j - bi + 1 <NEWLINE> r = j <NEWLINE> a [ l : r + 1 ] = [ ci ] * ( r - l + 1 ) <NEWLINE> a [ 0 : l ] = save <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = j <NEWLINE> a [ l : r + 1 ] = [ ci ] * ( r - l + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> def main2 ( n , m , a , b , c ) : <NEWLINE> <INDENT> all = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> all . append ( ( a [ i ] , 1 ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> all . append ( ( c [ i ] , b [ i ] ) ) <NEWLINE> <DEDENT> all . sort ( reverse = True , key = lambda x : x [ 0 ] ) <NEWLINE> <COMMENT> <NL> count = n <NEWLINE> sum = 0 <NEWLINE> i = 0 <NEWLINE> while ( count > 0 ) : <NEWLINE> <INDENT> ni = all [ i ] [ 1 ] <NEWLINE> if ni <= count : <NEWLINE> <INDENT> sum += all [ i ] [ 0 ] * ni <NEWLINE> count -= ni <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += all [ i ] [ 0 ] * count <NEWLINE> count = 0 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , a , b , c = readinput ( ) <NEWLINE> ans = main2 ( n , m , a , b , c ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = <STRING> <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> t += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += s [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import deque <NEWLINE> r = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> r [ a ] . append ( b ) <NEWLINE> r [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> prev = [ - 1 ] * n <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> <NL> for j in r [ v ] : <NEWLINE> <INDENT> if prev [ j ] == - 1 : <NEWLINE> <INDENT> prev [ j ] = v <NEWLINE> q . append ( j ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( prev [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> i = 1 <NEWLINE> <NL> <COMMENT> <NL> for s in sys . stdin : <NEWLINE> <COMMENT> <NL> <INDENT> if int ( s ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( <STRING> , i , <STRING> , int ( s ) , sep = <STRING> ) <NEWLINE> <COMMENT> <NL> i += 1 <NEWLINE> <DEDENT>
n_cards = int ( input ( ) ) <NEWLINE> taro_cards = [ ] <NEWLINE> for i in range ( n_cards ) : <NEWLINE> <INDENT> taro_card = input ( ) <NEWLINE> taro_cards . append ( taro_card ) <NEWLINE> <DEDENT> full_cards = [ ] <NEWLINE> for mark in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for card_number in range ( 13 ) : <NEWLINE> <INDENT> full_cards . append ( mark + <STRING> + str ( card_number + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> missing_cards = [ ] <NEWLINE> for card in full_cards : <NEWLINE> <INDENT> if card not in taro_cards : <NEWLINE> <INDENT> missing_cards . append ( card ) <NEWLINE> <NL> <DEDENT> <DEDENT> for missing_card in missing_cards : <NEWLINE> <INDENT> print ( missing_card ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ set ( ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ s ] . add ( t ) <NEWLINE> edges [ t ] . add ( s ) <NEWLINE> <NL> <DEDENT> prenum = [ None ] * n <NEWLINE> parent = [ None ] * n <NEWLINE> lowest = [ None ] * n <NEWLINE> counter = 0 <NEWLINE> <NL> <NL> def dfs ( cur , prev ) : <NEWLINE> <INDENT> global counter <NEWLINE> prenum [ cur ] = lowest [ cur ] = counter <NEWLINE> counter += 1 <NEWLINE> for edge in edges [ cur ] : <NEWLINE> <INDENT> if prenum [ edge ] is not None : <NEWLINE> <INDENT> if edge != prev : <NEWLINE> <INDENT> lowest [ cur ] = min ( lowest [ cur ] , prenum [ edge ] ) <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> parent [ edge ] = cur <NEWLINE> dfs ( edge , cur ) <NEWLINE> lowest [ cur ] = min ( lowest [ cur ] , lowest [ edge ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , 1 ) <NEWLINE> ap = [ False ] * n <NEWLINE> r = 0 <NEWLINE> for _ in filter ( lambda x : x == 0 , parent ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> if r > 1 : <NEWLINE> <INDENT> ap [ 0 ] = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p = parent [ i ] <NEWLINE> if p and prenum [ p ] <= lowest [ i ] : <NEWLINE> <INDENT> ap [ p ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for i , e in enumerate ( ap ) : <NEWLINE> <INDENT> if e : print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c , s = input ( ) . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> dic [ s ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if s in dic else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> def unite ( x , y ) : <NEWLINE> <INDENT> global dat <NEWLINE> x , y = find ( dat , x ) , find ( dat , y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if dat [ y ] < dat [ x ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> dat [ x ] += dat [ y ] <NEWLINE> dat [ y ] = x <NEWLINE> return False <NEWLINE> <NL> <NL> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> global dat <NEWLINE> x , y = find ( dat , x ) , find ( dat , y ) <NEWLINE> print ( 1 if x == y else 0 ) <NEWLINE> <DEDENT> def find ( dat , x ) : <NEWLINE> <INDENT> if dat [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> dat [ x ] = find ( dat , dat [ x ] ) <NEWLINE> return dat [ x ] <NEWLINE> <NL> <DEDENT> com = ( unite , same ) <NEWLINE> <NL> n , q = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> dat = [ - 1 ] * n <NEWLINE> <NL> for c , x , y in ( map ( int , f . readline ( ) . split ( ) ) for _ in range ( q ) ) : <NEWLINE> <INDENT> com [ c ] ( x , y ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> cnt = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while i + 2 * j < n : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i + 2 * j ] != s [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from decimal import Decimal <NEWLINE> a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if N % i != 0 : <NEWLINE> <INDENT> for j in range ( 1 , N // i + 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , N // i ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> primes = [ 0 , 0 ] + [ 1 ] * 49999 <NEWLINE> for i in range ( 2 , 224 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 50001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> values = [ k for k , b in enumerate ( primes ) if b ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> end = bisect . bisect_right ( values , n // 2 ) <NEWLINE> print ( sum ( 1 for i in values [ : end ] if primes [ n - i ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> lst = [ 0 ] * N <NEWLINE> Re = S . count ( <STRING> ) <NEWLINE> Lw = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> Re -= 1 <NEWLINE> lst [ i ] = Re + Lw <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Lw += 1 <NEWLINE> lst [ i ] = Re + Lw - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = min ( lst ) <NEWLINE> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> flg = False <NEWLINE> for A in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> done = { } <NEWLINE> ans = 0 <NEWLINE> now = A [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if now == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if done . get ( now ) == None : <NEWLINE> <INDENT> done [ now ] = True <NEWLINE> now = A [ now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import numpy as np <NEWLINE> lis = [ ] <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> lis . append ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> listA = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> listA . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> X_ = listA [ 0 ] <NEWLINE> X = X_ [ 0 ] <NEWLINE> N = X_ [ 1 ] <NEWLINE> if N != 0 : <NEWLINE> <INDENT> P = listA [ 1 ] <NEWLINE> <NL> arr = np . array ( lis ) <NEWLINE> P_max = max ( P ) <NEWLINE> P_min = min ( P ) - 1 <NEWLINE> arr = arr [ arr <= P_max + 1 ] <NEWLINE> arr = arr [ arr >= P_min - 1 ] <NEWLINE> lis = arr . tolist ( ) <NEWLINE> for p in P : <NEWLINE> <INDENT> lis . remove ( p ) <NEWLINE> <COMMENT> <NL> <DEDENT> lis_ = [ ] <NEWLINE> for l in lis : <NEWLINE> <INDENT> lis_ . append ( abs ( l - X ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> lis_min = min ( lis_ ) <NEWLINE> <NL> def my_index ( l , x , default = False ) : <NEWLINE> <INDENT> if x in l : <NEWLINE> <INDENT> return l . index ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return default <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lis [ my_index ( lis_ , lis_min ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> import sys <NEWLINE> <NL> h = [ ] <NEWLINE> <NL> for com in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( h , - int ( com [ 7 : ] ) ) <NEWLINE> <DEDENT> elif com [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - heapq . heappop ( h ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> keihin_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> keihin_list . append ( s ) <NEWLINE> <DEDENT> print ( len ( set ( keihin_list ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_counter = collections . Counter ( a ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for v in a_counter : <COMMENT> <NEWLINE> <INDENT> res += a_counter [ v ] * ( a_counter [ v ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for v in a : <NEWLINE> <INDENT> befor = a_counter [ v ] * ( a_counter [ v ] - 1 ) // 2 <NEWLINE> after = ( a_counter [ v ] - 1 ) * ( a_counter [ v ] - 2 ) // 2 <NEWLINE> print ( res - befor + after ) <NEWLINE> <NL> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if ( A [ i ] > A [ i - K ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = a * lis [ i ] <NEWLINE> if a > 1000000000000000000 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> if 0 in lis : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( list ) : <NEWLINE> <INDENT> return reduce ( lcm_base , list , 1 ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> T = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> print ( lcm_list ( T ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ <STRING> ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = str ( int ( ans [ a [ i ] - 1 ] ) + 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> max = sorted ( A ) [ - 1 ] <NEWLINE> semi_max = sorted ( A ) [ - 2 ] <NEWLINE> <NL> if max != semi_max : <NEWLINE> <INDENT> ex = A . index ( max ) <NEWLINE> <NL> for i in range ( 0 , ex ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <NL> <DEDENT> print ( semi_max ) <NEWLINE> <NL> for i in range ( ex + 1 , N ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> def popcount ( n ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( 18 ) : <NEWLINE> <INDENT> if n >> i & 1 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) . decode ( ) . rstrip ( ) <NEWLINE> <NL> <COMMENT> <NL> x_cnt = X . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> x_mod_pl , x_mod_mi = 0 , 0 <NEWLINE> d_pl , d_mi = 1 , 1 <NEWLINE> mod_pl , mod_mi = x_cnt + 1 , max ( 1 , x_cnt - 1 ) <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> x_mod_pl = ( x_mod_pl + d_pl ) % mod_pl <NEWLINE> x_mod_mi = ( x_mod_mi + d_mi ) % mod_mi <NEWLINE> <DEDENT> d_pl = ( d_pl * 2 ) % mod_pl <NEWLINE> d_mi = ( d_mi * 2 ) % mod_mi <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> if x_cnt == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> a = ( x_mod_mi - pow ( 2 , ( N - 1 - i ) , mod_mi ) ) % mod_mi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( x_mod_pl + pow ( 2 , ( N - 1 - i ) , mod_pl ) ) % mod_pl <NEWLINE> <NL> <DEDENT> while a > 0 : <NEWLINE> <INDENT> pop_cnt = popcount ( a ) <NEWLINE> a %= pop_cnt <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for B in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if ( A ** 5 - B ** 5 == X ) : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> S = [ input ( ) for _ in range ( n ) ] <NEWLINE> word = collections . Counter ( S ) . most_common ( ) <NEWLINE> maxi = word [ 0 ] [ 1 ] <NEWLINE> ans = [ ] <NEWLINE> for w in word : <NEWLINE> <INDENT> if w [ 1 ] == maxi : <NEWLINE> <INDENT> ans . append ( w [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> a = <STRING> . join ( ans ) <NEWLINE> print ( a ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hint_list = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> y -= 1 <NEWLINE> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for i in range ( len ( hint_list ) ) : <NEWLINE> <INDENT> uf . union ( hint_list [ i ] [ 0 ] , hint_list [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( - min ( uf . parents ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if w == h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * w , end = <STRING> ) <NEWLINE> print ( ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) * ( h - 2 ) ) <NEWLINE> print ( <STRING> * w , end = <STRING> ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> s += S [ i ] <NEWLINE> <DEDENT> s += <STRING> <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B > N : <NEWLINE> <INDENT> print ( math . floor ( ( A * N ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( ( A * ( B - 1 ) / B ) ) ) <NEWLINE> <NL> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , value ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . next = None <NEWLINE> self . prev = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> tail = Node ( None ) <NEWLINE> node = tail <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> command = input ( ) <NEWLINE> if command . startswith ( <STRING> ) : <NEWLINE> <INDENT> nn = Node ( int ( command [ 2 : ] ) ) <NEWLINE> nn . prev , nn . next = node . prev , node <NEWLINE> if node . prev is not None : <NEWLINE> <INDENT> node . prev . next = nn <NEWLINE> <DEDENT> node . prev = nn <NEWLINE> node = node . prev <NEWLINE> <DEDENT> elif command . startswith ( <STRING> ) : <NEWLINE> <INDENT> i = int ( command [ 2 : ] ) <NEWLINE> if i > 0 : <NEWLINE> <INDENT> for _ in range ( i ) : <NEWLINE> <INDENT> node = node . next <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( - i ) : <NEWLINE> <INDENT> node = node . prev <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif command . startswith ( <STRING> ) : <NEWLINE> <INDENT> p , n = node . prev , node . next <NEWLINE> node . prev , node . next = None , None <NEWLINE> node = n <NEWLINE> if p is None : <NEWLINE> <INDENT> n . prev = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n . prev , p . next = p , n <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> st = [ ] <NEWLINE> node = tail . prev <NEWLINE> while node is not None : <NEWLINE> <INDENT> st . append ( node . value ) <NEWLINE> node = node . prev <NEWLINE> <NL> <DEDENT> while len ( st ) > 0 : <NEWLINE> <INDENT> print ( st . pop ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> value = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in value : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in value : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> k = S - i - j <NEWLINE> if 0 <= k <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> ac = Counter ( A ) <NEWLINE> <NL> td = dict ( ) <NEWLINE> for k , v in ac . items ( ) : <NEWLINE> <INDENT> if v % 2 == 0 : <NEWLINE> <INDENT> td [ k ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> td [ k ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> two = 0 <NEWLINE> for k , v in td . items ( ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> two += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if two % 2 == 0 : <NEWLINE> <INDENT> ans += two <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> two -= 1 <NEWLINE> ans += two <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> L = [ A [ x ] + x + 1 for x in range ( N ) ] <NEWLINE> R = [ x + 1 - A [ x ] for x in range ( N ) ] <NEWLINE> <NL> cL = collections . Counter ( L ) <NEWLINE> cR = collections . Counter ( R ) <NEWLINE> <NL> cRlist = list ( cR . keys ( ) ) <NEWLINE> <NL> for i in range ( len ( cRlist ) ) : <NEWLINE> <INDENT> tmp = cRlist [ i ] <NEWLINE> ans += cR . get ( tmp , 0 ) * cL . get ( tmp , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = N % K <NEWLINE> m = K - n <NEWLINE> <NL> print ( min ( abs ( n ) , abs ( m ) ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> INF = 9999999999999999999999999999 <NEWLINE> <NL> def spanning_tree ( G ) : <NEWLINE> <INDENT> n = len ( G ) <NEWLINE> T = { } <NEWLINE> added = set ( [ 0 ] ) <NEWLINE> heap = [ ] <NEWLINE> for v in G [ 0 ] : <NEWLINE> <INDENT> heappush ( heap , ( G [ 0 ] [ v ] , ( 0 , v ) ) ) <NEWLINE> <DEDENT> while len ( added ) < n : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> c , e = heappop ( heap ) <NEWLINE> if e [ 1 ] not in added : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> T [ e ] = c <NEWLINE> added . add ( e [ 1 ] ) <NEWLINE> for v in G [ e [ 1 ] ] : <NEWLINE> <INDENT> heappush ( heap , ( G [ e [ 1 ] ] [ v ] , ( e [ 1 ] , v ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return T <NEWLINE> <NL> <NL> <DEDENT> G = { } <NEWLINE> <NL> n , m = [ int ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> G [ i ] = { } <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> s , t , c = [ int ( v ) for v in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> G [ s ] [ t ] = c <NEWLINE> G [ t ] [ s ] = c <NEWLINE> <NL> <DEDENT> if m == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> T = spanning_tree ( G ) <NEWLINE> <NL> s = 0 <NEWLINE> for e in T : <NEWLINE> <INDENT> s += T [ e ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> li = l [ i - 1 ] + l [ i - 2 ] <NEWLINE> l . append ( li ) <NEWLINE> <DEDENT> print ( l [ len ( l ) - 1 ] ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> a += ( v * t ) <NEWLINE> b += ( w * t ) <NEWLINE> if a >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= ( v * t ) <NEWLINE> b -= ( w * t ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m , * ab , = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> p = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> while p [ x ] > 0 : <NEWLINE> <INDENT> x = p [ x ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def union ( i , j ) : <NEWLINE> <INDENT> pi , pj = find ( i ) , find ( j ) <NEWLINE> if pi == pj : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if p [ pi ] < p [ pj ] : <NEWLINE> <INDENT> pi , pj = pj , pi <NEWLINE> i , j = j , i <NEWLINE> <DEDENT> p [ pi ] += p [ pj ] <NEWLINE> p [ pj ] = pi <NEWLINE> reconnect ( j , pi ) <NEWLINE> <NL> <DEDENT> def reconnect ( i , j ) : <NEWLINE> <INDENT> while p [ i ] > 0 : <NEWLINE> <INDENT> k = p [ i ] <NEWLINE> p [ i ] = j <NEWLINE> i = k <NEWLINE> <NL> <DEDENT> <DEDENT> for i , j in zip ( ab [ : : 2 ] , ab [ 1 : : 2 ] ) : <NEWLINE> <INDENT> union ( i , j ) <NEWLINE> <NL> <DEDENT> print ( - min ( p ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> if ( X - i ) not in p : <NEWLINE> <INDENT> ans = X - i <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif ( X + i ) not in p : <NEWLINE> <INDENT> ans = X + i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loop_counter = 0 <COMMENT> <NEWLINE> <NL> start = 1 <NEWLINE> end = a [ start - 1 ] <NEWLINE> is_checked = [ 0 for _ in range ( n ) ] <NEWLINE> is_checked [ 0 ] = 1 <NEWLINE> road = [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> if is_checked [ end - 1 ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> roop_start = end <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> road . append ( end ) <NEWLINE> is_checked [ end - 1 ] = 1 <NEWLINE> start = end <NEWLINE> end = a [ start - 1 ] <NEWLINE> <DEDENT> <DEDENT> roop_start_index = road . index ( roop_start ) <NEWLINE> roop_length = len ( road ) - roop_start_index <NEWLINE> if k <= roop_start_index + 1 : <NEWLINE> <INDENT> print ( road [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= roop_start_index <NEWLINE> k %= roop_length <NEWLINE> print ( road [ roop_start_index + k ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alr = [ 0 for i in range ( n ) ] <NEWLINE> now = 1 <NEWLINE> path = [ now ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if alr [ now - 1 ] != 0 : <NEWLINE> <INDENT> now = path [ path . index ( now ) + ( k - i - 1 ) % ( len ( path ) - path . index ( now ) ) ] <NEWLINE> break <NEWLINE> <DEDENT> path . append ( now ) <NEWLINE> alr [ now - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( now ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> ls1 = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ [ [ 0 for k in range ( 2600 ) ] for j in range ( 51 ) ] for i in range ( 51 ) ] <NEWLINE> for i in range ( 51 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> for s in range ( 2600 ) : <NEWLINE> <INDENT> if s < ls1 [ j ] : <NEWLINE> <INDENT> dp [ j ] [ k ] [ s ] = dp [ j - 1 ] [ k ] [ s ] <NEWLINE> <DEDENT> elif s >= ls1 [ j ] : <NEWLINE> <INDENT> dp [ j ] [ k ] [ s ] = dp [ j - 1 ] [ k - 1 ] [ s - ls1 [ j ] ] + dp [ j - 1 ] [ k ] [ s ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += dp [ N ] [ k ] [ k * A ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 2019 <NEWLINE> <NL> if R - L >= p : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = p <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> res = min ( res , i * j % p ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> INF = 10 ** 20 <NEWLINE> <NL> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( ( x - l , x + l - 1 ) ) <NEWLINE> <NL> <DEDENT> X = sorted ( X , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> last = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if X [ last ] [ 1 ] < X [ i ] [ 0 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> last = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> count += gcd ( a , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> import heapq as he <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> he . heapify ( a ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> he . heappush ( a , he . heappop ( a ) * ( - 1 ) // 2 * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( A ) <NEWLINE> <NL> av = s / 2 <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x += A [ i ] <NEWLINE> <NL> if x < av < x + A [ i + 1 ] : <NEWLINE> <NL> <INDENT> y = s - x - A [ i + 1 ] <NEWLINE> <NL> if x > y : <NEWLINE> <INDENT> print ( A [ i + 1 ] - x + y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i + 1 ] - y + x ) <NEWLINE> <DEDENT> <DEDENT> elif x == av : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> L = [ 0 ] * 2000000 <NEWLINE> L [ 0 ] = 7 % K <NEWLINE> for i in range ( 1 , 2000000 ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] * 10 % K <NEWLINE> <DEDENT> for i in range ( 2000000 ) : <NEWLINE> <INDENT> a = ( a + L [ i ] ) % K <NEWLINE> if a == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> count = 0 <NEWLINE> sList = list ( s ) <NEWLINE> tList = list ( t ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ex = [ 0 ] * 11 <NEWLINE> if n == 0 : break <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d , p = map ( int , input ( ) . split ( ) ) <NEWLINE> ex [ p ] += d <NEWLINE> <DEDENT> ex . reverse ( ) <NEWLINE> for i in range ( len ( ex ) ) : <NEWLINE> <INDENT> m -= ex [ i ] <NEWLINE> if m <= 0 : <NEWLINE> <INDENT> ex [ i ] = abs ( m ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ex [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ex . reverse ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( ex ) ) : <NEWLINE> <INDENT> ans += ex [ i ] * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def extractMax ( A ) : <NEWLINE> <INDENT> x = A [ 0 ] <NEWLINE> A [ 0 ] = A [ - 1 ] <NEWLINE> A . pop ( ) <NEWLINE> H = len ( A ) <NEWLINE> i = 0 <NEWLINE> while i < H : <COMMENT> <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> rv = 0 <NEWLINE> lv = 0 <NEWLINE> r = ( i + 1 ) * 2 <NEWLINE> l = r - 1 <NEWLINE> if l < H : <NEWLINE> <INDENT> lv = A [ l ] <NEWLINE> if r < H : <NEWLINE> <INDENT> rv = A [ r ] <NEWLINE> <NL> <DEDENT> <DEDENT> if v < lv and lv > rv : <NEWLINE> <INDENT> A [ l ] = v <NEWLINE> A [ i ] = lv <NEWLINE> i = l <NEWLINE> <DEDENT> elif v < rv : <NEWLINE> <INDENT> A [ r ] = v <NEWLINE> A [ i ] = rv <NEWLINE> i = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def insert ( A , n ) : <NEWLINE> <INDENT> i = len ( A ) <NEWLINE> A . append ( n ) <NEWLINE> while i > 0 : <COMMENT> <NEWLINE> <INDENT> p = int ( ( i + 1 ) / 2 ) - 1 <NEWLINE> v = A [ i ] <NEWLINE> pv = A [ p ] <NEWLINE> if pv < v : <COMMENT> <NEWLINE> <INDENT> A [ p ] = v <NEWLINE> A [ i ] = pv <NEWLINE> i = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> istr = sys . stdin . read ( ) <NEWLINE> cmds = list ( istr . splitlines ( ) ) <NEWLINE> <NL> end = False <NEWLINE> S = [ ] <NEWLINE> for cmd in cmds : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( S , int ( cmd [ 7 : ] ) ) <NEWLINE> <NL> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> a = extractMax ( S ) <NEWLINE> print ( a ) <NEWLINE> <NL> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> end = True <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> <NL> def dfs1 ( v , p ) : <NEWLINE> <INDENT> val = 1 <NEWLINE> pre_mul = [ 1 ] <NEWLINE> rev_mul = [ ] <NEWLINE> for c in links [ v ] : <NEWLINE> <INDENT> if c == p : <NEWLINE> <INDENT> pre_mul . append ( val ) <NEWLINE> rev_mul . append ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> res = 1 + dfs1 ( c , v ) <NEWLINE> val *= res <NEWLINE> val %= m <NEWLINE> pre_mul . append ( val ) <NEWLINE> rev_mul . append ( res ) <NEWLINE> <DEDENT> dp [ v ] = val <NEWLINE> for i in range ( len ( rev_mul ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> rev_mul [ i ] *= rev_mul [ i + 1 ] <NEWLINE> rev_mul [ i ] %= m <NEWLINE> <DEDENT> rev_mul . append ( 1 ) <NEWLINE> pre_muls [ v ] = [ pre_mul , rev_mul ] <NEWLINE> return val <NEWLINE> <NL> <NL> <DEDENT> def dfs2 ( v , p , a ) : <NEWLINE> <INDENT> dp [ v ] = dp [ v ] * a % m <NEWLINE> pmv = pre_muls [ v ] <NEWLINE> for i , c in enumerate ( links [ v ] ) : <NEWLINE> <INDENT> if c == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pmc = pmv [ 0 ] [ i ] * pmv [ 1 ] [ i + 1 ] % m <NEWLINE> pmc = pmc * a % m <NEWLINE> dfs2 ( c , v , pmc + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> links = [ [ ] for _ in range ( n ) ] <NEWLINE> dp = [ 0 for _ in range ( n ) ] <NEWLINE> pre_muls = [ None for _ in range ( n ) ] <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x , y = map ( int , line . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> links [ x ] . append ( y ) <NEWLINE> links [ y ] . append ( x ) <NEWLINE> <DEDENT> dfs1 ( 0 , None ) <NEWLINE> dfs2 ( 0 , None , 1 ) <NEWLINE> print ( <STRING> . join ( map ( str , dp ) ) ) <NEWLINE>
import typing <NEWLINE> <NL> <NL> class DSU : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , n : int = 0 ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . parent_or_size = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def merge ( self , a : int , b : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> assert 0 <= b < self . _n <NEWLINE> <NL> x = self . leader ( a ) <NEWLINE> y = self . leader ( b ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> if - self . parent_or_size [ x ] < - self . parent_or_size [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parent_or_size [ x ] += self . parent_or_size [ y ] <NEWLINE> self . parent_or_size [ y ] = x <NEWLINE> <NL> return x <NEWLINE> <NL> <DEDENT> def same ( self , a : int , b : int ) -> bool : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> assert 0 <= b < self . _n <NEWLINE> <NL> return self . leader ( a ) == self . leader ( b ) <NEWLINE> <NL> <DEDENT> def leader ( self , a : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> <NL> if self . parent_or_size [ a ] < 0 : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> self . parent_or_size [ a ] = self . leader ( self . parent_or_size [ a ] ) <NEWLINE> return self . parent_or_size [ a ] <NEWLINE> <NL> <DEDENT> def size ( self , a : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> <NL> return - self . parent_or_size [ self . leader ( a ) ] <NEWLINE> <NL> <DEDENT> def groups ( self ) -> typing . List [ typing . List [ int ] ] : <NEWLINE> <INDENT> leader_buf = [ self . leader ( i ) for i in range ( self . _n ) ] <NEWLINE> <NL> result = [ [ ] for _ in range ( self . _n ) ] <NEWLINE> for i in range ( self . _n ) : <NEWLINE> <INDENT> result [ leader_buf [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> return list ( filter ( lambda r : r , result ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = DSU ( n ) <NEWLINE> ab = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> g . merge ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> print ( len ( g . groups ( ) ) - 1 ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INTMAX = 9223372036854775807 <NEWLINE> INTMIN = - 9223372036854775808 <NEWLINE> DVSR = 1000000007 <NEWLINE> def POW ( x , y ) : return pow ( x , y , DVSR ) <NEWLINE> def INV ( x , m = DVSR ) : return pow ( x , m - 2 , m ) <NEWLINE> def DIV ( x , y , m = DVSR ) : return ( x * INV ( y , m ) ) % m <NEWLINE> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def FLIST ( n ) : <NEWLINE> <INDENT> res = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : res . append ( res [ i - 1 ] * i % DVSR ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x = x ^ y <NEWLINE> y = x ^ y <NEWLINE> x = x ^ y <NEWLINE> <DEDENT> div = x % y <NEWLINE> while div != 0 : <NEWLINE> <INDENT> x = y <NEWLINE> y = div <NEWLINE> div = x % y <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <NL> <DEDENT> N = II ( ) <NEWLINE> MP1 = { } <NEWLINE> A0 = 0 <NEWLINE> B0 = 0 <NEWLINE> AB0 = 0 <NEWLINE> RES = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = LI ( ) <NEWLINE> if A * B != 0 : <NEWLINE> <INDENT> G = gcd ( abs ( A ) , abs ( B ) ) <NEWLINE> A //= G <NEWLINE> B //= G <NEWLINE> v = ( abs ( A ) , abs ( B ) , A * B > 0 ) <NEWLINE> if not v in MP1 : <NEWLINE> <INDENT> MP1 [ v ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MP1 [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if A == 0 and B != 0 : A0 += 1 <NEWLINE> if A != 0 and B == 0 : B0 += 1 <NEWLINE> if A == 0 and B == 0 : AB0 += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> VIS = set ( ) <NEWLINE> for ( vv , n ) in MP1 . items ( ) : <NEWLINE> <INDENT> ( A , B , isPos ) = vv <NEWLINE> v = ( B , A , not isPos ) <NEWLINE> if not v in VIS and not vv in VIS : <NEWLINE> <INDENT> VIS . add ( v ) <NEWLINE> VIS . add ( vv ) <NEWLINE> if v in MP1 : <NEWLINE> <INDENT> m = MP1 [ v ] <NEWLINE> RES = ( RES * POW ( 2 , n ) ) % DVSR + ( RES * POW ( 2 , m ) ) % DVSR - RES <NEWLINE> RES %= DVSR <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RES *= POW ( 2 , n ) <NEWLINE> RES %= DVSR <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if A0 and B0 : <NEWLINE> <INDENT> RES = ( RES * POW ( 2 , A0 ) ) % DVSR + ( RES * POW ( 2 , B0 ) ) % DVSR - RES <NEWLINE> <DEDENT> elif A0 : <NEWLINE> <INDENT> RES = RES * POW ( 2 , A0 ) % DVSR <NEWLINE> <DEDENT> elif B0 : <NEWLINE> <INDENT> RES = RES * POW ( 2 , B0 ) % DVSR <NEWLINE> <NL> <NL> <DEDENT> print ( ( RES + AB0 - 1 ) % DVSR ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A , reverse = True ) <NEWLINE> <NL> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> rl = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , rl ( ) . strip ( ) . split ( ) ) <NEWLINE> eaw = [ list ( map ( int , rl ( ) . strip ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> d = dict ( ( ( x [ 0 ] - 1 , x [ 1 ] - 1 ) , - x [ 2 ] ) for x in eaw ) <NEWLINE> inf = 10 ** 14 <NEWLINE> mdl = [ inf ] * n <NEWLINE> mdl [ 0 ] = 0 <NEWLINE> def blrelax ( dl , k ) : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> for e in iter ( d ) : <NEWLINE> <INDENT> if dl [ e [ 0 ] ] + d [ e ] < dl [ e [ 1 ] ] : <NEWLINE> <INDENT> dl [ e [ 1 ] ] = dl [ e [ 0 ] ] + d [ e ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> blrelax ( mdl , n - 1 ) <NEWLINE> a1 = mdl [ n - 1 ] <NEWLINE> blrelax ( mdl , n ) <NEWLINE> a2 = mdl [ n - 1 ] <NEWLINE> if a1 > a2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - a1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import defaultdict , deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> G = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> G [ i ] = [ ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = ( int ( n ) for n in input ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( ( v , w ) ) <NEWLINE> G [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> ret = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> que = deque ( ) <NEWLINE> que . append ( ( 1 , 0 ) ) <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> node , distance = que [ 0 ] <NEWLINE> que . popleft ( ) <NEWLINE> <NL> ret [ node ] = distance % 2 <NEWLINE> for next_node , next_distance in G [ node ] : <NEWLINE> <INDENT> if ret [ next_node ] == - 1 : <NEWLINE> <INDENT> que . append ( ( next_node , distance + next_distance ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ret [ i + 1 ] ) <NEWLINE> <NL> <DEDENT>
A , B , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ans = 0 <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> floor = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> print ( floor ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> C = Counter ( a ) <NEWLINE> ans = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * C [ b ] <NEWLINE> C [ c ] += C [ b ] <NEWLINE> C [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def move ( act , y , x , direction ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if x < 0 or x == M or y < 0 or y == H : <NEWLINE> <INDENT> return s_map <NEWLINE> <DEDENT> if act == <STRING> : <COMMENT> <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s_map [ y - 1 ] [ x ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> s_map [ y ] [ x ] , s_map [ y - 1 ] [ x ] = <STRING> , <STRING> <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif act == <STRING> : <COMMENT> <NEWLINE> <INDENT> if y == H - 1 : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s_map [ y + 1 ] [ x ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> s_map [ y ] [ x ] , s_map [ y + 1 ] [ x ] = <STRING> , <STRING> <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif act == <STRING> : <COMMENT> <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s_map [ y ] [ x - 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> s_map [ y ] [ x ] , s_map [ y ] [ x - 1 ] = <STRING> , <STRING> <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif act == <STRING> : <COMMENT> <NEWLINE> <INDENT> if x == M - 1 : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s_map [ y ] [ x + 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> s_map [ y ] [ x ] , s_map [ y ] [ x + 1 ] = <STRING> , <STRING> <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> now_dir = s_map [ y ] [ x ] <NEWLINE> ma = shoot ( y , x , now_dir ) <NEWLINE> return ma <NEWLINE> <NL> <DEDENT> <DEDENT> def shoot ( y , x , now_dir ) : <NEWLINE> <INDENT> if x < 0 or y < 0 or x == M or y == H : <NEWLINE> <INDENT> return s_map <NEWLINE> <DEDENT> if now_dir == <STRING> : <COMMENT> <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if s_map [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif s_map [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shoot ( y , x + 1 , now_dir ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> elif now_dir == <STRING> : <COMMENT> <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if s_map [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif s_map [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shoot ( y , x - 1 , now_dir ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> elif now_dir == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if s_map [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif s_map [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shoot ( y - 1 , x , now_dir ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> elif now_dir == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if s_map [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> s_map [ y ] [ x ] = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif s_map [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shoot ( y + 1 , x , now_dir ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def search_index ( s_map ) : <COMMENT> <NEWLINE> <INDENT> direction = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( len ( direction ) ) : <NEWLINE> <INDENT> for j in range ( len ( s_map ) ) : <NEWLINE> <INDENT> for k in range ( len ( s_map [ 0 ] ) ) : <NEWLINE> <INDENT> if direction [ i ] in s_map [ j ] [ k ] : <NEWLINE> <INDENT> x , y , d = j , k , direction [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return x , y , d <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> T = int ( input ( ) ) <COMMENT> <NEWLINE> all_map = [ ] <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> s_map = [ ] <NEWLINE> H , M = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> for j in range ( H ) : <COMMENT> <NEWLINE> <INDENT> s_map . append ( [ i for i in input ( ) ] ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <COMMENT> <NEWLINE> action = input ( ) <COMMENT> <NEWLINE> for k in action : <NEWLINE> <INDENT> x , y , direction = search_index ( s_map ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> m = move ( k , x , y , direction ) <NEWLINE> <DEDENT> all_map . append ( s_map ) <NEWLINE> <DEDENT> for j in range ( len ( all_map ) ) : <NEWLINE> <INDENT> for i in range ( len ( all_map [ j ] ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( all_map [ j ] [ i ] ) ) <NEWLINE> <DEDENT> if j != len ( all_map ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> while l [ i ] == 0 : <NEWLINE> <INDENT> l [ i ] = a [ i ] <NEWLINE> i = a [ i ] - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> start = i + 1 <NEWLINE> i = 0 <NEWLINE> pre = 0 <NEWLINE> while i + 1 != start : <NEWLINE> <INDENT> i = a [ i ] - 1 <NEWLINE> pre += 1 <NEWLINE> <DEDENT> loop = cnt - pre <NEWLINE> if pre + loop < k : <NEWLINE> <INDENT> k = ( k - pre ) % loop + pre <NEWLINE> <DEDENT> i = 0 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> i = a [ i ] - 1 <NEWLINE> <DEDENT> print ( i + 1 ) <NEWLINE>
from math import ceil <NEWLINE> <NL> n , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> l , r = 0 , 10 ** 9 <NEWLINE> <NL> while r - l > 1 : <NEWLINE> <NL> <INDENT> m = ( l + r ) // 2 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < m : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c += a [ i ] // m - ( a [ i ] % m == 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> if c > k : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> max_num = pow ( 10 , 18 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > max_num : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( a [ - 1 ] + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> for i in set ( a ) : <NEWLINE> <INDENT> if cnt [ i ] >= 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , a [ - 1 ] + 1 , i ) : <NEWLINE> <INDENT> cnt [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt . count ( 1 ) ) <NEWLINE>
from functools import reduce <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A . sort ( reverse = True ) <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> s *= a <NEWLINE> if s == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import math <NEWLINE> l_gcd = [ ] <NEWLINE> r_gcd = [ ] <NEWLINE> <NL> c = a [ 0 ] <NEWLINE> for i in a [ : - 1 ] : <NEWLINE> <INDENT> c = math . gcd ( c , i ) <NEWLINE> l_gcd . append ( c ) <NEWLINE> <NL> <DEDENT> c = a [ - 1 ] <NEWLINE> for j in a [ 1 : ] [ : : - 1 ] : <NEWLINE> <INDENT> c = math . gcd ( c , j ) <NEWLINE> r_gcd . append ( c ) <NEWLINE> <NL> <DEDENT> ans = max ( r_gcd [ - 1 ] , l_gcd [ - 1 ] ) <NEWLINE> for r , l in zip ( r_gcd [ : - 1 ] , l_gcd [ : - 1 ] [ : : - 1 ] ) : <NEWLINE> <INDENT> c = math . gcd ( r , l ) <NEWLINE> ans = max ( ans , c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> MOD = 1000000007 <NEWLINE> N = int ( input ( ) ) <NEWLINE> both_zeros_cnt = 0 <NEWLINE> bads = defaultdict ( lambda : [ 0 , 0 ] ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == 0 and B == 0 : <NEWLINE> <INDENT> both_zeros_cnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if B < 0 or ( B == 0 and A < 0 ) : <NEWLINE> <INDENT> A , B = - A , - B <NEWLINE> <DEDENT> g = gcd ( A , B ) <NEWLINE> A , B = A // g , B // g <NEWLINE> if A > 0 : <NEWLINE> <INDENT> bads [ ( A , B ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bads [ ( B , - A ) ] [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for k , l in bads . values ( ) : <NEWLINE> <INDENT> ans *= ( pow ( 2 , k , MOD ) - 1 ) + ( pow ( 2 , l , MOD ) - 1 ) + 1 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ( ans + both_zeros_cnt - 1 ) % MOD ) <NEWLINE>
ceil = lambda a , b : ( a + b - 1 ) // b <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l , r = 0 , max ( A ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if sum ( ceil ( x , m ) - 1 for x in A ) > K : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
dic = set ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd , val = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> dic . add ( val ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if val in dic else <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> <NL> score = - a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> score += a [ i // 2 ] <NEWLINE> <DEDENT> print ( score ) <NEWLINE>
import numpy as np <NEWLINE> from collections import deque <NEWLINE> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> e = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> <NL> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> e [ a - 1 ] . append ( b - 1 ) <NEWLINE> e [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> ans = np . ones ( n - 1 ) <NEWLINE> check = np . zeros ( n ) <NEWLINE> <NL> while len ( q ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> node = q . popleft ( ) <NEWLINE> <NL> if node is not None : <NEWLINE> <INDENT> check [ node ] = 2 <NEWLINE> con = e [ node ] <NEWLINE> for i in con : <NEWLINE> <INDENT> if check [ i ] == 0 : <NEWLINE> <INDENT> ans [ i - 1 ] = int ( node ) + 1 <NEWLINE> q . append ( i ) <NEWLINE> check [ i ] = 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( int ( i ) ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> from itertools import * <NEWLINE> n = range ( 50001 ) ; a = list ( n ) ; a [ 1 ] = 0 <NEWLINE> for i in range ( 2 , 224 ) : a [ i * 2 : : i ] = [ 0 ] * len ( a [ i * 2 : : i ] ) <NEWLINE> p = list ( compress ( n , a ) ) <NEWLINE> for x in iter ( input , <STRING> ) : x = int ( x ) ; print ( sum ( a [ x - d ] > 0 for d in p [ : bisect . bisect ( p , x // 2 ) ] ) ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> man = [ 0 ] * n <NEWLINE> ball , a = p , 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> a %= n <NEWLINE> if ball > 0 : <NEWLINE> <INDENT> ball -= 1 <NEWLINE> man [ a ] += 1 <NEWLINE> <DEDENT> elif ball == 0 : ball , man [ a ] = man [ a ] , ball <NEWLINE> if man [ a ] == p : break <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : nums [ i ] = abs ( a [ i ] - a [ i + 1 ] ) <NEWLINE> <NL> t = sum ( nums ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = t - ( nums [ i - 1 ] + nums [ i ] ) + abs ( a [ i - 1 ] - a [ i + 1 ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> s = list ( a ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( a [ i ] == <STRING> ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> s = <STRING> . join ( s ) <NEWLINE> print ( s ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> numlist = range ( 1000 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in numlist : <NEWLINE> <INDENT> num = str ( i ) <NEWLINE> if len ( num ) == 1 : <NEWLINE> <INDENT> num = <STRING> + num <NEWLINE> <DEDENT> if len ( num ) == 2 : <NEWLINE> <INDENT> num = <STRING> + num <NEWLINE> <DEDENT> if num [ 0 ] in S [ : N - 1 ] : <NEWLINE> <INDENT> num1 = S . index ( num [ 0 ] ) <NEWLINE> if num [ 1 ] in S [ num1 + 1 : N - 1 ] : <NEWLINE> <INDENT> S2 = S [ num1 + 1 : N - 1 ] <NEWLINE> num2 = S2 . index ( num [ 1 ] ) + num1 + 1 <NEWLINE> if num [ 2 ] in S [ num2 + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> B . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> s += A [ i ] [ j ] * B [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 ; <NEWLINE> iszero = False <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> iszero = True <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( iszero ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> wa = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> wa . append ( wa [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> t = wa [ k ] - wa [ 0 ] <NEWLINE> for i in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> if t < wa [ i ] - wa [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> t = wa [ i ] - wa [ i - k ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = ans + ( ( n // i ) * ( ( n // i ) + 1 ) * i ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> def popcount ( x ) : <NEWLINE> <INDENT> return str ( bin ( x ) ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> p = popcount ( i ) <NEWLINE> cnt [ i ] = cnt [ i % p ] + 1 <NEWLINE> <NL> <NL> <DEDENT> P = X . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> MODSPP = [ 0 ] * N <NEWLINE> MODSPM = [ 0 ] * N <NEWLINE> <NL> PP = P + 1 <NEWLINE> if P - 1 <= 0 : <NEWLINE> <INDENT> PM = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> PM = P - 1 <NEWLINE> <NL> <DEDENT> MODSPP [ 0 ] = 1 % PP <NEWLINE> MODSPM [ 0 ] = 1 % PM <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> MODSPP [ i ] = ( MODSPP [ i - 1 ] * 2 ) % PP <NEWLINE> MODSPM [ i ] = ( MODSPM [ i - 1 ] * 2 ) % PM <NEWLINE> <NL> <NL> <NL> <DEDENT> MODSX_PP = 0 <NEWLINE> MODSX_PM = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> MODSX_PP += MODSPP [ N - i - 1 ] <NEWLINE> MODSX_PM += MODSPM [ N - i - 1 ] <NEWLINE> <DEDENT> MODSX_PP %= PP <NEWLINE> MODSX_PM %= PM <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ret = MODSX_PP + MODSPP [ N - i - 1 ] <NEWLINE> ret %= PP <NEWLINE> print ( cnt [ ret ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if P - 1 <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = ( MODSX_PM - MODSPM [ N - i - 1 ] + PM ) % PM <NEWLINE> print ( cnt [ ret ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> dp = np . full ( 10 ** 5 + 1 , W + 1 , dtype = int ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> np . minimum ( dp [ : - v ] + w , dp [ v : ] , out = dp [ v : ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( dp ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if dp [ i ] <= W : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> sum = k * 1 <NEWLINE> <DEDENT> elif a < k and k <= a + b : <NEWLINE> <INDENT> sum = a <NEWLINE> <DEDENT> elif a + b < k <= a + b + c : <NEWLINE> <INDENT> sum = a + ( - 1 ) * ( k - a - b ) <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = { } <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> if i in P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ab = abs ( i - X ) <NEWLINE> m [ i ] = ab <NEWLINE> <COMMENT> <NL> <DEDENT> min_k_list = [ kv [ 0 ] for kv in m . items ( ) if kv [ 1 ] == min ( m . values ( ) ) ] <NEWLINE> print ( min ( min_k_list ) ) <NEWLINE>
from itertools import accumulate <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def prime_numbers ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <NL> <DEDENT> m = ( n + 1 ) // 2 <NEWLINE> p = [ True ] * m <NEWLINE> for i in range ( 1 , int ( ( n ** 0.5 - 1 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i * ( i + 1 ) , m , 2 * i + 1 ) : <NEWLINE> <INDENT> p [ j ] = False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> a = [ 2 * i + 1 for i in range ( m ) if p [ i ] ] <NEWLINE> a [ 0 ] = 2 <NEWLINE> return a <NEWLINE> <NL> <NL> <DEDENT> N = 10 ** 5 <NEWLINE> P = set ( prime_numbers ( N ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> P = [ n for n in P if ( n + 1 ) // 2 in P ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a = [ 0 ] * ( N + 1 ) <NEWLINE> for n in P : <NEWLINE> <COMMENT> <NL> <INDENT> a [ n ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> a = list ( accumulate ( a ) ) <NEWLINE> <NL> <NL> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ r ] - a [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , K = il ( ) <NEWLINE> X = il ( ) <NEWLINE> <NL> ret = MAX <NEWLINE> for n in range ( N - K + 1 ) : <NEWLINE> <INDENT> ret = min ( ret , abs ( X [ n ] ) + abs ( X [ n ] - X [ n + K - 1 ] ) , abs ( X [ n + K - 1 ] ) + abs ( X [ n ] - X [ n + K - 1 ] ) ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> l . append ( s ) <NEWLINE> <NL> <DEDENT> a = set ( l ) <NEWLINE> print ( len ( a ) ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> <NL> n = int ( s [ 0 ] ) <NEWLINE> k = int ( s [ 1 ] ) <NEWLINE> <NL> a = input ( ) . split ( ) <NEWLINE> <NL> siyouzumi = { 1 } <NEWLINE> y = [ 1 ] <NEWLINE> t = 1 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <NL> <INDENT> t = int ( a [ t - 1 ] ) <NEWLINE> if t in siyouzumi : <NEWLINE> <INDENT> haba = i - y . index ( t ) <NEWLINE> kaisu = int ( ( k - i ) / haba ) <NEWLINE> <NL> l = k - ( i + ( haba * kaisu ) ) <NEWLINE> <NL> for j in range ( l ) : <NEWLINE> <INDENT> t = int ( a [ t - 1 ] ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> siyouzumi . add ( t ) <NEWLINE> y . append ( t ) <NEWLINE> <NL> <NL> <DEDENT> print ( t ) <NEWLINE>
string = input ( ) <NEWLINE> numbers = string . split ( <STRING> ) <NEWLINE> numbers . sort ( ) <NEWLINE> print ( numbers [ 0 ] , numbers [ 1 ] , numbers [ 2 ] ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> nrow = [ 0 ] * H <NEWLINE> ncol = [ 0 ] * W <NEWLINE> xycoord = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> nrow [ h - 1 ] += 1 <NEWLINE> ncol [ w - 1 ] += 1 <NEWLINE> xycoord += [ [ w - 1 , h - 1 ] ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> a = max ( nrow ) <NEWLINE> b = max ( ncol ) <NEWLINE> row_cand = set ( [ i for i , x in enumerate ( nrow ) if x == a ] ) <NEWLINE> col_cand = set ( [ i for i , x in enumerate ( ncol ) if x == b ] ) <NEWLINE> <NL> <NL> flag = 0 <NEWLINE> for i in xycoord : <NEWLINE> <INDENT> if ( i [ 0 ] in col_cand ) and ( i [ 1 ] in row_cand ) : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag < ( len ( col_cand ) * len ( row_cand ) ) : <NEWLINE> <INDENT> print ( max ( nrow ) + max ( ncol ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( nrow ) + max ( ncol ) - 1 ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
line = input ( ) <NEWLINE> r = float ( line ) <NEWLINE> <NL> import math <NEWLINE> <NL> print ( <STRING> % ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> l = 2 * r * math . pi <NEWLINE> <NL> print ( s , l , sep = <STRING> ) <NEWLINE> <NL>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> answer = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> answer += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> p = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> q = math . gcd ( p , c ) <NEWLINE> result += q <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> c = [ [ 0 for i in range ( l ) ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> c [ i ] [ j ] = sum ( [ ( a [ i ] [ x ] * b [ x ] [ j ] ) for x in range ( m ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , c [ i ] ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> i = 0 <NEWLINE> ans = 0 <NEWLINE> while ans <= 1000000000 : <NEWLINE> <INDENT> i += 1 <NEWLINE> ans = i ** 5 - ( i - 1 ) ** 5 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> i = 0 <NEWLINE> ans = 0 <NEWLINE> while ans <= 1000000000 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> ans = i ** 5 - ( i - 1 ) ** 5 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = [ _ ** 5 for _ in range ( 120 ) ] <NEWLINE> <NL> for i in range ( 1 , 120 ) : <NEWLINE> <INDENT> for j in range ( 120 ) : <NEWLINE> <INDENT> if l [ i ] - l [ j ] == n : <NEWLINE> <INDENT> print ( int ( l [ i ] ** 0.2 ) , int ( l [ j ] ** 0.2 ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if l [ i ] + l [ j ] == n : <NEWLINE> <INDENT> print ( int ( l [ i ] ** 0.2 ) , int ( - 1 * l [ j ] ** 0.2 ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_num = A [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if ( max_num >= i ) : <NEWLINE> <INDENT> ans += max_num - i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_num = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> def range_strip ( S , i , j ) : <NEWLINE> <INDENT> return S [ : i ] + S [ j : ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i , len ( S ) ) : <NEWLINE> <INDENT> if range_strip ( S , i , j ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= li [ i ] <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> a . append ( A ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> if i > Q - K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <DEDENT> print ( min ( R ) - max ( L ) + 1 if min ( R ) - max ( L ) + 1 > 0 else 0 ) <NEWLINE>
n , k = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> b = [ 1 ] * n <NEWLINE> <NL> <NL> for i in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> b [ i - 1 ] = a [ i - 1 ] / a [ i - k - 1 ] <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> if 1 < b [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> num = 7 % k <NEWLINE> temp = 7 % k <NEWLINE> while True : <NEWLINE> <INDENT> if num % k == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> temp = temp * 10 % k <NEWLINE> num += temp % k <NEWLINE> num %= k <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> numOfEdges = [ 0 for _ in range ( N ) ] <NEWLINE> visited = [ 0 for _ in range ( N ) ] <NEWLINE> edges = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 ; <NEWLINE> numOfEdges [ a ] += 1 <NEWLINE> numOfEdges [ b ] += 1 <NEWLINE> edges [ ( a , b ) ] = 0 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( prev , now , col ) : <NEWLINE> <INDENT> if visited [ now ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> visited [ now ] = 1 <NEWLINE> i = 1 <NEWLINE> for adj in graph [ now ] : <NEWLINE> <INDENT> if adj == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if now < adj : <NEWLINE> <INDENT> edges [ ( now , adj ) ] = col + i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edges [ ( adj , now ) ] = col + i <NEWLINE> <DEDENT> dfs ( now , adj , col + i ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( - 1 , 0 , 1 ) <NEWLINE> maxColor = max ( numOfEdges ) <NEWLINE> print ( maxColor ) <NEWLINE> <NL> for k , i in edges . items ( ) : <NEWLINE> <INDENT> e = i % maxColor <NEWLINE> if e : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxColor ) <NEWLINE> <DEDENT> <DEDENT>
from sys import setrecursionlimit <NEWLINE> <NL> <NL> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> <NL> n = int ( input ( ) ) <NEWLINE> t = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> <NL> <NL> hands = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for a , b in t : <NEWLINE> <INDENT> hands [ a ] += 1 <NEWLINE> hands [ b ] += 1 <NEWLINE> <NL> <DEDENT> number_of_colors = max ( * hands ) <NEWLINE> <NL> def next_color ( i ) : <NEWLINE> <INDENT> return i + 1 if i < number_of_colors else 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> class edge ( ) : <NEWLINE> <INDENT> def __init__ ( self , en ) : <NEWLINE> <INDENT> self . ends = en <NEWLINE> self . color = 0 <NEWLINE> <NL> <DEDENT> def set_color ( self , co ) : <NEWLINE> <INDENT> self . color = co <NEWLINE> <NL> <DEDENT> <DEDENT> class nord ( ) : <NEWLINE> <INDENT> def __init__ ( self , tr ) : <NEWLINE> <INDENT> self . parent = tr <NEWLINE> self . edges = [ ] <NEWLINE> <NL> <DEDENT> def add ( self , ed ) : <NEWLINE> <INDENT> self . edges . append ( ed ) <NEWLINE> <NL> <DEDENT> def set_color ( self , previous_color ) : <NEWLINE> <INDENT> co = next_color ( previous_color ) <NEWLINE> for ed in self . edges : <NEWLINE> <INDENT> if ed . color == 0 : <NEWLINE> <INDENT> ed . set_color ( co ) <NEWLINE> for i in ed . ends : <NEWLINE> <INDENT> no = self . parent . nords [ i - 1 ] <NEWLINE> if self is not no : <NEWLINE> <INDENT> no . set_color ( co ) <NEWLINE> <DEDENT> <DEDENT> co = next_color ( co ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nords = [ ] <NEWLINE> <NL> <DEDENT> def add_nord ( self , no ) : <NEWLINE> <INDENT> self . nords . append ( no ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , ed ) : <NEWLINE> <INDENT> for i in ed . ends : <NEWLINE> <INDENT> self . nords [ i - 1 ] . add ( ed ) <NEWLINE> <NL> <DEDENT> <DEDENT> def set_color ( self ) : <NEWLINE> <INDENT> self . nords [ 0 ] . set_color ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> tr = tree ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> no = nord ( tr ) <NEWLINE> tr . add_nord ( no ) <NEWLINE> <NL> <DEDENT> e_tree = [ ] <NEWLINE> for en in t : <NEWLINE> <INDENT> ed = edge ( en ) <NEWLINE> e_tree . append ( ed ) <NEWLINE> tr . add_edge ( ed ) <NEWLINE> <NL> <DEDENT> tr . set_color ( ) <NEWLINE> <NL> print ( number_of_colors ) <NEWLINE> for e in e_tree : <NEWLINE> <INDENT> print ( e . color ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t += 1 / a [ i ] <NEWLINE> <NL> <DEDENT> print ( 1 / t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from decimal import * <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = Decimal ( a ) <NEWLINE> b = Decimal ( b ) <NEWLINE> c = a * b <NEWLINE> e = c . quantize ( Decimal ( <STRING> ) , rounding = ROUND_FLOOR ) <NEWLINE> print ( e ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> G = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( [ b , c ] ) <NEWLINE> G [ b ] . append ( [ a , c ] ) <NEWLINE> <NL> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> D = [ None ] * ( n + 1 ) <NEWLINE> <NL> def dfs ( x , d ) : <NEWLINE> <INDENT> D [ x ] = d <NEWLINE> for yy , dd in G [ x ] : <NEWLINE> <INDENT> if D [ yy ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( yy , dd + d ) <NEWLINE> <DEDENT> <DEDENT> dfs ( k , 0 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( D [ x ] + D [ y ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> cnt = np . count_nonzero ( a & 1 ) <NEWLINE> ans += ( n - cnt ) * cnt * ( 2 ** i ) <NEWLINE> if ans >= 10 ** 9 + 7 : <NEWLINE> <INDENT> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> a >>= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> num = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( num - 1 ) : <NEWLINE> <INDENT> tmp = int ( num / ( a + 1 ) ) <NEWLINE> if num % ( a + 1 ) == 0 : <NEWLINE> <INDENT> count += tmp - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += tmp <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> def cross ( P0 , P1 , P2 ) : <NEWLINE> <INDENT> x0 , y0 = P0 ; x1 , y1 = P1 ; x2 , y2 = P2 <NEWLINE> x1 -= x0 ; x2 -= x0 <NEWLINE> y1 -= y0 ; y2 -= y0 <NEWLINE> return x1 * y2 - x2 * y1 <NEWLINE> <NL> <DEDENT> def dot ( P0 , P1 , P2 ) : <NEWLINE> <INDENT> x0 , y0 = P0 ; x1 , y1 = P1 ; x2 , y2 = P2 <NEWLINE> x1 -= x0 ; x2 -= x0 <NEWLINE> y1 -= y0 ; y2 -= y0 <NEWLINE> return x1 * x2 + y1 * y2 <NEWLINE> <NL> <DEDENT> def dist2 ( P0 , P1 ) : <NEWLINE> <INDENT> x0 , y0 = P0 ; x1 , y1 = P1 <NEWLINE> return ( x1 - x0 ) ** 2 + ( y1 - y0 ) ** 2 <NEWLINE> <NL> <DEDENT> def convex_hull ( PS ) : <NEWLINE> <INDENT> QS = [ ] <NEWLINE> n = len ( PS ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return PS [ : ] <NEWLINE> <DEDENT> for P in PS : <NEWLINE> <INDENT> while len ( QS ) > 1 and cross ( QS [ - 1 ] , QS [ - 2 ] , P ) > 0 : <NEWLINE> <INDENT> QS . pop ( ) <NEWLINE> <DEDENT> QS . append ( P ) <NEWLINE> <DEDENT> k = len ( QS ) <NEWLINE> RS = reversed ( PS ) ; next ( RS ) <NEWLINE> for P in RS : <NEWLINE> <INDENT> while len ( QS ) > k and cross ( QS [ - 1 ] , QS [ - 2 ] , P ) > 0 : <NEWLINE> <INDENT> QS . pop ( ) <NEWLINE> <DEDENT> QS . append ( P ) <NEWLINE> <DEDENT> return QS <NEWLINE> <NL> <DEDENT> def cross4 ( S0 , S1 , T0 , T1 ) : <NEWLINE> <INDENT> x0 , y0 = S0 ; x1 , y1 = S1 <NEWLINE> X0 , Y0 = T0 ; X1 , Y1 = T1 <NEWLINE> return ( x1 - x0 ) * ( Y1 - Y0 ) - ( y1 - y0 ) * ( X1 - X0 ) <NEWLINE> <DEDENT> def calipers ( PS ) : <NEWLINE> <INDENT> QS = convex_hull ( PS ) <NEWLINE> n = len ( QS ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> return sqrt ( dist2 ( * QS ) ) <NEWLINE> <DEDENT> i = j = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if QS [ k ] < QS [ i ] : i = k <NEWLINE> if QS [ j ] < QS [ k ] : j = k <NEWLINE> <DEDENT> res = 0 <NEWLINE> si = i ; sj = j <NEWLINE> while i != sj or j != si : <NEWLINE> <INDENT> res = max ( res , dist2 ( QS [ i ] , QS [ j ] ) ) <NEWLINE> if cross4 ( QS [ i ] , QS [ i - n + 1 ] , QS [ j ] , QS [ j - n + 1 ] ) < 0 : <NEWLINE> <INDENT> i = ( i + 1 ) % n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = ( j + 1 ) % n <NEWLINE> <DEDENT> <DEDENT> return sqrt ( res ) <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> PS = [ map ( float , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> PS . sort ( ) <NEWLINE> print ( <STRING> % calipers ( PS ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> tree = [ [ - 1 , - 1 , True ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> id , left , right = map ( int , input ( ) . split ( ) ) <NEWLINE> if left != - 1 : <NEWLINE> <INDENT> tree [ id ] [ 0 ] = left <NEWLINE> tree [ left ] [ 2 ] = False <NEWLINE> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> tree [ id ] [ 1 ] = right <NEWLINE> tree [ right ] [ 2 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> def preoder ( id ) : <NEWLINE> <INDENT> if id == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> + str ( id ) , end = <STRING> ) <NEWLINE> preoder ( tree [ id ] [ 0 ] ) <NEWLINE> preoder ( tree [ id ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> def inorder ( id ) : <NEWLINE> <INDENT> if id == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( tree [ id ] [ 0 ] ) <NEWLINE> print ( <STRING> + str ( id ) , end = <STRING> ) <NEWLINE> inorder ( tree [ id ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> def postorder ( id ) : <NEWLINE> <INDENT> if id == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> postorder ( tree [ id ] [ 0 ] ) <NEWLINE> postorder ( tree [ id ] [ 1 ] ) <NEWLINE> print ( <STRING> + str ( id ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> root = 0 <NEWLINE> for i , node in enumerate ( tree ) : <NEWLINE> <INDENT> if node [ 2 ] == True : <NEWLINE> <INDENT> root = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> preoder ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> inorder ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> postorder ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
N , K = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> marks = [ ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> prev = A [ i - K ] <NEWLINE> next_ = A [ i ] <NEWLINE> if prev < next_ : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> judge = 1 <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ K + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> T = 26 <NEWLINE> <NL> <NL> def solve ( d , c , s ) : <NEWLINE> <INDENT> best = [ 0 ] * d <NEWLINE> last = [ - 1 ] * T <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> max_v = - float ( <STRING> ) <NEWLINE> for j in range ( T ) : <NEWLINE> <INDENT> v = s [ i ] [ j ] + c [ j ] * ( i - last [ j ] ) <NEWLINE> if max_v < v : <NEWLINE> <INDENT> max_v = v <NEWLINE> best [ i ] = j <NEWLINE> <DEDENT> <DEDENT> last [ best [ i ] ] = i <NEWLINE> <DEDENT> return best <NEWLINE> <NL> <NL> <DEDENT> def get_score ( d , c , s , t ) : <NEWLINE> <INDENT> last = [ - 1 ] * T <NEWLINE> total = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> total += s [ i ] [ t [ i ] ] <NEWLINE> last [ t [ i ] ] = i <NEWLINE> for j in range ( T ) : <NEWLINE> <INDENT> total -= c [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return max ( 10 ** 6 + total , 0 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> t = solve ( d , c , s ) <NEWLINE> print ( get_score ( d , c , s , t ) , file = sys . stderr ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> print ( t [ i ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
l = input ( ) . split ( ) <NEWLINE> r = int ( l [ 0 ] ) <NEWLINE> c = int ( l [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> i = 0 <NEWLINE> b = [ ] <NEWLINE> while i < r : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> q = 0 <NEWLINE> su = 0 <NEWLINE> while q < c : <NEWLINE> <INDENT> b . append ( int ( a [ q ] ) ) <NEWLINE> su += int ( a [ q ] ) <NEWLINE> q = q + 1 <NEWLINE> <DEDENT> b . append ( su ) <NEWLINE> i = i + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> x = 0 <NEWLINE> while x < c + 1 : <NEWLINE> <INDENT> d = 0 <NEWLINE> z = 0 <NEWLINE> while z < r : <NEWLINE> <INDENT> d += b [ x + z * ( c + 1 ) ] <NEWLINE> z += 1 <NEWLINE> <DEDENT> b . append ( d ) <NEWLINE> x = x + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> C = [ ] <NEWLINE> y = 0 <NEWLINE> while y < r + 1 : <NEWLINE> <INDENT> z = 0 <NEWLINE> Ans = str ( b [ y * ( c + 1 ) + z ] ) <NEWLINE> while z < c : <NEWLINE> <INDENT> z += 1 <NEWLINE> Ans = Ans + <STRING> + str ( b [ y * ( c + 1 ) + z ] ) <NEWLINE> <DEDENT> C . append ( Ans ) <NEWLINE> y += 1 <NEWLINE> <NL> <DEDENT> for k in C : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> sent = None <NEWLINE> <NL> def insert ( hoge , new_node , root ) : <NEWLINE> <INDENT> parent_maybe = sent <NEWLINE> now_looking = root <NEWLINE> hoge [ new_node ] [ <STRING> ] = new_node <NEWLINE> while now_looking != sent : <NEWLINE> <INDENT> parent_maybe = now_looking <NEWLINE> if new_node < hoge [ now_looking ] [ <STRING> ] : <NEWLINE> <INDENT> now_looking = hoge [ now_looking ] [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now_looking = hoge [ now_looking ] [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> hoge [ new_node ] [ <STRING> ] = parent_maybe <NEWLINE> <NL> if parent_maybe == sent : <NEWLINE> <INDENT> root = new_node <NEWLINE> hoge [ new_node ] [ <STRING> ] = sent <NEWLINE> hoge [ new_node ] [ <STRING> ] = sent <NEWLINE> hoge [ new_node ] [ <STRING> ] = sent <NEWLINE> <DEDENT> elif new_node < hoge [ parent_maybe ] [ <STRING> ] : <NEWLINE> <INDENT> hoge [ parent_maybe ] [ <STRING> ] = new_node <NEWLINE> hoge [ new_node ] [ <STRING> ] = sent <NEWLINE> hoge [ new_node ] [ <STRING> ] = sent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hoge [ parent_maybe ] [ <STRING> ] = new_node <NEWLINE> hoge [ new_node ] [ <STRING> ] = sent <NEWLINE> hoge [ new_node ] [ <STRING> ] = sent <NEWLINE> <NL> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def inorder ( node_id ) : <NEWLINE> <INDENT> if node_id == sent : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> inorder ( hoge [ node_id ] [ <STRING> ] ) <NEWLINE> print ( <STRING> . format ( node_id ) , end = <STRING> ) <NEWLINE> inorder ( hoge [ node_id ] [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> def preorder ( node_id ) : <NEWLINE> <INDENT> if node_id == sent : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> print ( <STRING> . format ( node_id ) , end = <STRING> ) <NEWLINE> preorder ( hoge [ node_id ] [ <STRING> ] ) <NEWLINE> preorder ( hoge [ node_id ] [ <STRING> ] ) <NEWLINE> <NL> <NL> <DEDENT> def getTree ( root ) : <NEWLINE> <INDENT> inorder ( root ) <NEWLINE> print ( ) <NEWLINE> preorder ( root ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> def searchNode ( hoge , num , node_id ) : <NEWLINE> <INDENT> if node_id == sent : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if num == node_id : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif num < node_id : <NEWLINE> <INDENT> return searchNode ( hoge , num , hoge [ node_id ] [ <STRING> ] ) <NEWLINE> <DEDENT> elif num > node_id : <NEWLINE> <INDENT> return searchNode ( hoge , num , hoge [ node_id ] [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def deleteNode ( hoge , node_id ) : <NEWLINE> <INDENT> left_child = hoge [ node_id ] [ <STRING> ] <NEWLINE> right_child = hoge [ node_id ] [ <STRING> ] <NEWLINE> parent = hoge [ node_id ] [ <STRING> ] <NEWLINE> if left_child == sent and right_child == sent : <NEWLINE> <INDENT> if hoge [ parent ] [ <STRING> ] == node_id : <NEWLINE> <INDENT> hoge [ parent ] [ <STRING> ] = sent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hoge [ parent ] [ <STRING> ] = sent <NEWLINE> <DEDENT> <DEDENT> elif left_child == sent and right_child != sent : <NEWLINE> <INDENT> if hoge [ parent ] [ <STRING> ] == node_id : <NEWLINE> <INDENT> hoge [ parent ] [ <STRING> ] = right_child <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hoge [ parent ] [ <STRING> ] = right_child <NEWLINE> <DEDENT> hoge [ right_child ] [ <STRING> ] = parent <NEWLINE> <DEDENT> elif right_child == sent and left_child != sent : <NEWLINE> <INDENT> if hoge [ parent ] [ <STRING> ] == node_id : <NEWLINE> <INDENT> hoge [ parent ] [ <STRING> ] = left_child <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hoge [ parent ] [ <STRING> ] = left_child <NEWLINE> <DEDENT> hoge [ left_child ] [ <STRING> ] = parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_node = getMin ( hoge , hoge [ node_id ] [ <STRING> ] ) <NEWLINE> min_parent = hoge [ min_node ] [ <STRING> ] <NEWLINE> if hoge [ min_node ] [ <STRING> ] == sent : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> hoge [ left_child ] [ <STRING> ] = min_node <NEWLINE> hoge [ right_child ] [ <STRING> ] = min_node <NEWLINE> hoge [ min_node ] [ <STRING> ] = left_child <NEWLINE> if min_node != right_child : <NEWLINE> <INDENT> hoge [ min_node ] [ <STRING> ] = right_child <NEWLINE> <DEDENT> hoge [ min_node ] [ <STRING> ] = parent <NEWLINE> if hoge [ parent ] [ <STRING> ] == node_id : <NEWLINE> <INDENT> hoge [ parent ] [ <STRING> ] = min_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hoge [ parent ] [ <STRING> ] = min_node <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> hoge [ min_parent ] [ <STRING> ] = sent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_node_rchild = hoge [ min_node ] [ <STRING> ] <NEWLINE> hoge [ min_parent ] [ <STRING> ] = min_node_rchild <NEWLINE> hoge [ min_node_rchild ] [ <STRING> ] = min_parent <NEWLINE> <DEDENT> <DEDENT> del hoge [ node_id ] <NEWLINE> <NL> <DEDENT> def getMin ( hoge , node_id ) : <NEWLINE> <INDENT> while hoge [ node_id ] [ <STRING> ] != sent : <NEWLINE> <INDENT> node_id = hoge [ node_id ] [ <STRING> ] <NEWLINE> <DEDENT> return node_id <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> hoge = collections . defaultdict ( dict ) <NEWLINE> root = sent <NEWLINE> for _ in range ( num ) : <NEWLINE> <INDENT> command = input ( ) <NEWLINE> if command . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> root = insert ( hoge , int ( command . split ( ) [ 1 ] ) , root ) <NEWLINE> <DEDENT> elif command . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( searchNode ( hoge , int ( command . split ( ) [ 1 ] ) , root ) ) <NEWLINE> <DEDENT> elif command . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> deleteNode ( hoge , int ( command . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> getTree ( root ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> <NL> X = 0 <NEWLINE> for v in C . values ( ) : <NEWLINE> <INDENT> X += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( X - C [ A [ i ] ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> <COMMENT> <NL> INF = 1 << 50 <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> rgb = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in s : <NEWLINE> <INDENT> rgb [ i ] += 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in rgb . keys ( ) : <NEWLINE> <INDENT> ans *= rgb [ i ] <NEWLINE> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> Bn = [ ] <NEWLINE> Cn = [ ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> Bn . append ( An [ k ] + k ) <NEWLINE> Cn . append ( k - An [ k ] ) <NEWLINE> <DEDENT> Cj = Counter ( Cn ) <NEWLINE> for i in Bn : <NEWLINE> <INDENT> c += Cj [ i ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , Q = mi ( ) <NEWLINE> a , b = i2 ( N - 1 ) <NEWLINE> p , x = i2 ( Q ) <NEWLINE> <NL> d = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> d [ a [ i ] - 1 ] . append ( b [ i ] - 1 ) <NEWLINE> d [ b [ i ] - 1 ] . append ( a [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> child = [ [ ] for i in range ( N ) ] <NEWLINE> parent = [ None ] * N <NEWLINE> <NL> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . pop ( ) <NEWLINE> for v in d [ now ] : <NEWLINE> <INDENT> if parent [ now ] == v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ v ] = now <NEWLINE> q . appendleft ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> c = [ 0 ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> c [ p [ i ] - 1 ] += x [ i ] <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> if parent [ i ] == None : <NEWLINE> <INDENT> return c [ i ] <NEWLINE> <NL> <DEDENT> return c [ i ] + dfs ( parent [ i ] ) <NEWLINE> <NL> <DEDENT> print ( * [ dfs ( i ) for i in range ( N ) ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = 1 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if 26 * ( 26 ** n - 1 ) / 25 >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> num = [ ] <NEWLINE> <NL> num = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> for j in range ( 1 , 27 ) : <NEWLINE> <INDENT> pre = 26 * ( 26 ** i - 1 ) / 25 <NEWLINE> if 26 ** i * j + pre >= N : <NEWLINE> <INDENT> num [ i ] = alpha [ j - 1 ] <NEWLINE> <NL> N -= 26 ** i * j <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( num [ : : - 1 ] ) ) <NEWLINE>
n = input ( ) <NEWLINE> k = int ( n ) % 111 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n [ 0 ] > n [ 1 ] or ( n [ 0 ] == n [ 1 ] and n [ 1 ] > n [ 2 ] ) : <NEWLINE> <INDENT> print ( n [ 0 ] * 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( str ( int ( n [ 0 ] ) + 1 ) ) * 3 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> RMax = 0 <NEWLINE> R = [ ] <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> rmi = r <NEWLINE> <DEDENT> if i == 1 : <NEWLINE> <INDENT> RMax = r - R [ 0 ] <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> rdif = ( r - rmi ) <NEWLINE> if rdif >= RMax : <NEWLINE> <INDENT> RMax = rdif <NEWLINE> <DEDENT> <DEDENT> R . append ( r ) <NEWLINE> if r < rmi : <NEWLINE> <INDENT> rmi = r <NEWLINE> <NL> <DEDENT> <DEDENT> print ( RMax ) <NEWLINE>
import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sa . append ( sa [ - 1 ] + a [ i ] ) <NEWLINE> <DEDENT> sb = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sb . append ( sb [ - 1 ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , s in enumerate ( sa ) : <NEWLINE> <INDENT> if s > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , i + max ( 0 , bisect . bisect_left ( sb , k - s + 1 ) - 1 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> SUM = 0 <NEWLINE> gcdlist = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( i , j ) <NEWLINE> gcd2 = math . gcd ( gcd1 , k ) <NEWLINE> if i == j and j == k : <NEWLINE> <INDENT> SUM += gcd2 <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> SUM += gcd2 * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> SUM += gcd2 * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( SUM ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import collections <NEWLINE> import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt = collections . defaultdict ( list ) <NEWLINE> dat = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> buf = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ i - dat [ i ] ] . append ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = i + dat [ i ] <NEWLINE> if x in cnt : <NEWLINE> <INDENT> res += len ( cnt [ x ] ) - bisect . bisect_left ( cnt [ x ] , x ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL>
s = [ * input ( ) ] <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> hugo = [ <STRING> , <STRING> ] <NEWLINE> a = [ 0 ] <NEWLINE> b = [ ] <NEWLINE> base = - 1 <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if base == - 1 : <COMMENT> <NEWLINE> <INDENT> base = hugo . index ( s [ i ] ) <NEWLINE> b = [ 0 , 1 ] <NEWLINE> <DEDENT> elif base != hugo . index ( s [ i ] ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if base == 1 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <DEDENT> max_ = max ( a [ - 1 ] , b [ 0 ] ) <NEWLINE> a . pop ( - 1 ) <NEWLINE> b [ 0 ] = max_ <NEWLINE> a . extend ( b ) <NEWLINE> <COMMENT> <NL> b = [ 0 , 1 ] <NEWLINE> base = hugo . index ( s [ i ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> b . append ( b [ - 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> if hugo . index ( s [ - 1 ] ) == base : <COMMENT> <NEWLINE> <INDENT> b . append ( b [ - 1 ] + 1 ) <NEWLINE> if base == 1 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <DEDENT> max_ = max ( a [ - 1 ] , b [ 0 ] ) <NEWLINE> b [ 0 ] = max_ <NEWLINE> a . pop ( - 1 ) <NEWLINE> a . extend ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if base == 1 : <NEWLINE> <INDENT> b . reverse ( ) <NEWLINE> <DEDENT> max_ = max ( a [ - 1 ] , b [ 0 ] ) <NEWLINE> b [ 0 ] = max_ <NEWLINE> a . pop ( - 1 ) <NEWLINE> a . extend ( b ) <NEWLINE> <NL> <COMMENT> <NL> if hugo . index ( s [ - 1 ] ) == 1 : <NEWLINE> <INDENT> b = [ 1 , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = [ 0 , 1 ] <NEWLINE> <DEDENT> max_ = max ( a [ - 1 ] , b [ 0 ] ) <NEWLINE> b [ 0 ] = max_ <NEWLINE> a . pop ( - 1 ) <NEWLINE> a . extend ( b ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) ) <NEWLINE>
A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = min ( a [ x - 1 ] + b [ y - 1 ] - c , ans ) <NEWLINE> <NL> <DEDENT> ans = min ( ans , min ( a ) + min ( b ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def solve ( n , a_list ) : <NEWLINE> <INDENT> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> heappush ( h , ( - a_list [ i ] , i ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> dp = ( - 10 ** 18 ) * np . ones ( ( n + 1 , n + 1 ) , dtype = np . int ) <NEWLINE> dp [ 0 , 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , k = heappop ( h ) <NEWLINE> <COMMENT> <NL> dp [ i + 1 , 1 : ] = np . maximum ( dp [ i , : - 1 ] + ( - a ) * np . abs ( k - np . arange ( n ) ) , dp [ i + 1 , 1 : ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dp [ i + 1 , : - 1 ] = np . maximum ( dp [ i , : - 1 ] + ( - a ) * np . abs ( k - np . arange ( n - 1 - i , n + n - 1 - i ) ) , dp [ i + 1 , : - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> res = dp [ - 1 , : ] . max ( ) <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = solve ( n , a_list ) <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> assert solve ( 4 , [ 1 , 3 , 4 , 2 ] ) == 20 <NEWLINE> assert solve ( 6 , [ 5 , 5 , 6 , 1 , 1 , 1 ] ) == 58 <NEWLINE> assert solve ( 6 , [ 8 , 6 , 9 , 1 , 2 , 1 ] ) == 85 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> R_cnt = s . count ( <STRING> ) <NEWLINE> G_cnt = s . count ( <STRING> ) <NEWLINE> B_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = R_cnt * G_cnt * B_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : break <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> CNT = [ 0 ] * ( 10 ** 7 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> p = i - a <NEWLINE> <NL> if 0 <= p <= ( 10 ** 7 ) : <NEWLINE> <INDENT> ans += CNT [ p ] <NEWLINE> <NL> <DEDENT> if 0 <= i + a <= ( 10 ** 7 ) : <NEWLINE> <INDENT> CNT [ i + a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def hash1 ( m , key ) : <NEWLINE> <INDENT> return key % m <NEWLINE> <NL> <DEDENT> def hash2 ( m , key ) : <NEWLINE> <INDENT> return 1 + key % ( m - 1 ) <NEWLINE> <NL> <DEDENT> def hash ( m , key , i ) : <NEWLINE> <INDENT> return ( hash1 ( m , key ) + i * hash2 ( m , key ) ) % m <NEWLINE> <NL> <DEDENT> def insert ( T , key ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> l = len ( T ) <NEWLINE> while True : <NEWLINE> <INDENT> h = hash ( 1046527 , key , i ) <NEWLINE> if ( T [ h ] == None ) : <NEWLINE> <INDENT> T [ h ] = key <NEWLINE> return h <NEWLINE> <DEDENT> elif ( T [ h ] == key ) : <NEWLINE> <INDENT> return h <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def search ( T , key ) : <NEWLINE> <INDENT> l = len ( T ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h = hash ( 1046527 , key , i ) <NEWLINE> if ( T [ h ] == key ) : <NEWLINE> <INDENT> return h <NEWLINE> <DEDENT> elif ( T [ h ] is None or h >= l ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( T , key ) : <NEWLINE> <INDENT> a = search ( T , key ) <NEWLINE> if ( a == - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> dict = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> data = [ ] <NEWLINE> T = [ None ] * 1046527 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <NL> while n > 0 : <NEWLINE> <INDENT> st = input ( ) <NEWLINE> d = list ( st . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> tmp_key = <STRING> <NEWLINE> for x in list ( d [ 1 ] ) : <NEWLINE> <INDENT> tmp_key += dict [ x ] <NEWLINE> <NL> <DEDENT> data . append ( [ d [ 0 ] , int ( tmp_key ) ] ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> for com in data : <NEWLINE> <INDENT> if ( com [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> insert ( T , com [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> find ( T , com [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if a [ j ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def factorize ( n , d ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> arr = [ ] <NEWLINE> tmp = n <NEWLINE> while True : <NEWLINE> <INDENT> i = d [ tmp ] <NEWLINE> if i == 1 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> while tmp % i == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> tmp //= i <NEWLINE> <DEDENT> arr . append ( i ) <NEWLINE> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> arr . append ( tmp ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( n ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def minimum_prime ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> d = list ( range ( n + 1 ) ) <NEWLINE> d [ 0 ] = 1 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if d [ i ] != i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> if d [ j ] == j : <NEWLINE> <INDENT> d [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_arr = max ( arr ) <NEWLINE> d = minimum_prime ( max_arr ) <NEWLINE> dp = [ 0 ] * ( max_arr + 1 ) <NEWLINE> <NL> if gcd ( * arr ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> searched = [ ] <NEWLINE> for a in arr : <NEWLINE> <INDENT> if a != 1 : <NEWLINE> <INDENT> primes = factorize ( a , d ) <NEWLINE> for p in primes : <NEWLINE> <INDENT> dp [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if max ( dp ) < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> fruits = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> fruits . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( fruits ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> A = nl ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> s = sum ( A ) <NEWLINE> q = sum ( [ a ** 2 for a in A ] ) <NEWLINE> ans = ( ( ( s * s ) - q ) ) // 2 <NEWLINE> print ( int ( ans % mod ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> M = collections . Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> for j in M . items ( ) : <NEWLINE> <INDENT> ans += j [ 0 ] * j [ 1 ] <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( C - B ) * M [ B ] <NEWLINE> M [ C ] += M [ B ] <NEWLINE> M [ B ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s_ = [ input ( ) for i in range ( n ) ] <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 , s2 = s_ [ i ] <NEWLINE> if s2 == <STRING> : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if s_ [ i + 1 ] == <STRING> and c == 0 and a <= 1 : <NEWLINE> <INDENT> a , b , ans = ( a + 1 , b - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> elif s_ [ i + 1 ] == <STRING> and c == 0 and b <= 1 : <NEWLINE> <INDENT> a , b , ans = ( a - 1 , b + 1 , ans + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b , ans = ( a - 1 , b + 1 , ans + <STRING> ) if a > b else ( a + 1 , b - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a , b , ans = ( a - 1 , b + 1 , ans + <STRING> ) if a > b else ( a + 1 , b - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> if min ( a , b ) == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif s1 == <STRING> : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if s_ [ i + 1 ] == <STRING> and b == 0 and a <= 1 : <NEWLINE> <INDENT> a , c , ans = ( a + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> elif s_ [ i + 1 ] == <STRING> and b == 0 and c <= 1 : <NEWLINE> <INDENT> a , c , ans = ( a - 1 , c + 1 , ans + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , c , ans = ( a - 1 , c + 1 , ans + <STRING> ) if a > c else ( a + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a , c , ans = ( a - 1 , c + 1 , ans + <STRING> ) if a > c else ( a + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> if min ( a , c ) == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if s_ [ i + 1 ] == <STRING> and a == 0 and b <= 1 : <NEWLINE> <INDENT> b , c , ans = ( b + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> elif s_ [ i + 1 ] == <STRING> and a == 0 and c <= 1 : <NEWLINE> <INDENT> b , c , ans = ( b - 1 , c + 1 , ans + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b , c , ans = ( b - 1 , c + 1 , ans + <STRING> ) if b > c else ( b + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b , c , ans = ( b - 1 , c + 1 , ans + <STRING> ) if b > c else ( b + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> if min ( b , c ) == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a_ = int ( input ( ) ) <NEWLINE> a . add ( a_ ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> if 2 not in a and n != 1 : <NEWLINE> <INDENT> dp [ 2 ] = dp [ 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i not in a : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in ai : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in ai : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == y [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if ans == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans == 0 or ans == 1 or ans == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_A = max ( A ) <NEWLINE> table = [ False ] * ( max_A + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if table [ i ] == False : <NEWLINE> <INDENT> table [ i ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ i ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mem = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if table [ i ] == - 1 : <NEWLINE> <INDENT> table [ i ] = True <NEWLINE> mem . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , max_A + 1 ) : <NEWLINE> <INDENT> if table [ i ] == True : <NEWLINE> <INDENT> n = 2 <NEWLINE> while i * n < max_A + 1 : <NEWLINE> <INDENT> table [ i * n ] = False <NEWLINE> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in mem : <NEWLINE> <INDENT> if table [ i ] == True : <NEWLINE> <INDENT> table [ i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( table . count ( True ) ) <NEWLINE>
<COMMENT> <NL> R , G , B , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> bingo = 0 <NEWLINE> <NL> for r in range ( 0 , 3001 ) : <NEWLINE> <INDENT> if R * r > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for g in range ( 0 , 3001 ) : <NEWLINE> <INDENT> b = ( N - ( R * r + G * g ) ) // B <NEWLINE> if b < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif R * r + G * g + B * b == N : <NEWLINE> <INDENT> bingo += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( bingo ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> q = 0 <NEWLINE> w = 0 <NEWLINE> e = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> q += gcd ( i + 1 , i + 1 , i + 1 ) <NEWLINE> <NL> <DEDENT> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> if not a == b : <NEWLINE> <INDENT> w += 3 * gcd ( a + 1 , a + 1 , b + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , K - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <COMMENT> <NL> <INDENT> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> e += 6 * gcd ( a , b , c ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( q + w + e ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L_lis = [ ] <NEWLINE> R_lis = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> L_lis . append ( L ) <NEWLINE> R_lis . append ( R ) <NEWLINE> <DEDENT> new_L , new_R = max ( L_lis ) , min ( R_lis ) <NEWLINE> if new_L <= new_R : <NEWLINE> <INDENT> print ( new_R - new_L + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> q = 0 <NEWLINE> for j in range ( len ( t ) ) [ : : - 1 ] : <NEWLINE> <INDENT> if s [ i + j ] == <STRING> : <NEWLINE> <INDENT> q += 1 <NEWLINE> <DEDENT> elif s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == len ( t ) - q : <NEWLINE> <INDENT> idx = i <NEWLINE> s = s [ : idx ] + t + s [ idx + len ( t ) : ] <NEWLINE> for k in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ k ] == <STRING> : <NEWLINE> <INDENT> s = s [ : k ] + <STRING> + s [ k + 1 : ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> husoku = [ a - b for a , b in zip ( A , B ) if a - b < 0 ] <NEWLINE> amari = [ a - b for a , b in zip ( A , B ) if a - b > 0 ] <NEWLINE> amari . sort ( reverse = True ) <NEWLINE> <NL> H = abs ( sum ( husoku ) ) <NEWLINE> if len ( husoku ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif H > sum ( amari ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i , a in enumerate ( amari , start = 1 ) : <NEWLINE> <INDENT> H -= a <NEWLINE> if H <= 0 : <NEWLINE> <INDENT> ans = len ( husoku ) + i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
import itertools <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> d = [ [ ] for _ in range ( k ) ] <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> n = 1 <NEWLINE> while i * n <= k : <NEWLINE> <INDENT> d [ i * n - 1 ] . append ( i ) <NEWLINE> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> seq = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> A = list ( itertools . combinations_with_replacement ( seq , 3 ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> a1 = a [ 0 ] <NEWLINE> a2 = a [ 1 ] <NEWLINE> a3 = a [ 2 ] <NEWLINE> if a1 == a2 == a3 : <NEWLINE> <INDENT> m = 1 <NEWLINE> <DEDENT> elif a1 == a2 or a1 == a3 or a2 == a3 : <NEWLINE> <INDENT> m = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 6 <NEWLINE> <DEDENT> ans += max ( set ( d [ a1 - 1 ] ) & set ( d [ a2 - 1 ] ) & set ( d [ a3 - 1 ] ) ) * m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> d = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d [ a [ i ] ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if d [ i ] != 0 : <NEWLINE> <INDENT> d [ i ] = d [ i - 1 ] + d [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( d [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
def Check_Num ( n ) : <NEWLINE> <NL> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if ( x % 3 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif ( x % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> x //= 10 <NEWLINE> while ( x > 0 ) : <NEWLINE> <INDENT> if ( x % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> Check_Num ( n ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * 100001 <NEWLINE> s = sum ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> L [ a ] += 1 <COMMENT> <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s += L [ B ] * ( C - B ) <COMMENT> <NEWLINE> L [ C ] += L [ B ] <NEWLINE> L [ B ] = 0 <COMMENT> <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> _A , _B = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> A . append ( _A ) <NEWLINE> B . append ( _B ) <NEWLINE> <NL> <DEDENT> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> print ( B [ ( N + 1 ) // 2 - 1 ] - A [ ( N + 1 ) // 2 - 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ N // 2 - 1 ] - A [ N // 2 - 1 ] + B [ N // 2 ] - A [ N // 2 ] + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> <NL> def check ( x ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if ( i == j ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ( x % ( i - j ) == 0 ) and ( x == ( ( i ** 5 ) - ( j ** 5 ) ) ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> return <NEWLINE> <DEDENT> elif ( x % ( i + j ) == 0 ) and ( x == ( ( i ** 5 ) + ( j ** 5 ) ) ) : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> check ( x ) <NEWLINE>
import sys <NEWLINE> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mycnt = 0 <NEWLINE> myans = 0 <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + ( K - A - B ) * - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> stmts = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> <NL> mapper = { } <NEWLINE> for i , stmt in enumerate ( stmts ) : <NEWLINE> <INDENT> mapper [ stmt [ 0 ] ] = i <NEWLINE> <NL> <DEDENT> vn = { } <NEWLINE> for stmt in stmts : <NEWLINE> <INDENT> for ope in stmt [ 2 : ] : <NEWLINE> <INDENT> if ope . isalpha ( ) and ope not in vn : <NEWLINE> <INDENT> vn [ ope ] = len ( vn ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> vs = [ 0 ] * len ( vn ) <NEWLINE> def stmt_add ( v1 , v2 , v3 ) : <NEWLINE> <INDENT> v1 = vn [ v1 ] <NEWLINE> if v3 . isdigit ( ) : <NEWLINE> <INDENT> v2 = vn [ v2 ] <NEWLINE> const = int ( v3 ) <NEWLINE> def run ( pc ) : <NEWLINE> <INDENT> assert vs [ v2 ] + const < 16 <NEWLINE> vs [ v1 ] = vs [ v2 ] + const <NEWLINE> return pc + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> v2 = vn [ v2 ] <NEWLINE> v3 = vn [ v3 ] <NEWLINE> def run ( pc ) : <NEWLINE> <INDENT> assert vs [ v2 ] + vs [ v3 ] < 16 <NEWLINE> vs [ v1 ] = vs [ v2 ] + vs [ v3 ] <NEWLINE> return pc + 1 <NEWLINE> <DEDENT> <DEDENT> return run <NEWLINE> <DEDENT> def stmt_sub ( v1 , v2 , v3 ) : <NEWLINE> <INDENT> v1 = vn [ v1 ] <NEWLINE> if v3 . isdigit ( ) : <NEWLINE> <INDENT> v2 = vn [ v2 ] <NEWLINE> const = int ( v3 ) <NEWLINE> def run ( pc ) : <NEWLINE> <INDENT> assert 0 <= vs [ v2 ] - const <NEWLINE> vs [ v1 ] = vs [ v2 ] - const <NEWLINE> return pc + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> v2 = vn [ v2 ] <NEWLINE> v3 = vn [ v3 ] <NEWLINE> def run ( pc ) : <NEWLINE> <INDENT> assert 0 <= vs [ v2 ] - vs [ v3 ] <NEWLINE> vs [ v1 ] = vs [ v2 ] - vs [ v3 ] <NEWLINE> return pc + 1 <NEWLINE> <DEDENT> <DEDENT> return run <NEWLINE> <DEDENT> def stmt_set ( v1 , v2 ) : <NEWLINE> <INDENT> v1 = vn [ v1 ] <NEWLINE> if v2 . isdigit ( ) : <NEWLINE> <INDENT> v2 = int ( v2 ) <NEWLINE> def run ( pc ) : <NEWLINE> <INDENT> vs [ v1 ] = v2 <NEWLINE> return pc + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> v2 = vn [ v2 ] <NEWLINE> def run ( pc ) : <NEWLINE> <INDENT> vs [ v1 ] = vs [ v2 ] <NEWLINE> return pc + 1 <NEWLINE> <DEDENT> <DEDENT> return run <NEWLINE> <DEDENT> def stmt_if ( v1 , dest ) : <NEWLINE> <INDENT> v1 = vn [ v1 ] <NEWLINE> def run ( pc ) : <NEWLINE> <INDENT> return mapper [ dest ] if vs [ v1 ] else pc + 1 <NEWLINE> <DEDENT> return run <NEWLINE> <DEDENT> def stmt_halt ( ) : <NEWLINE> <INDENT> def run ( pc ) : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> return run <NEWLINE> <DEDENT> stmt_func = [ ] <NEWLINE> for i , stmt in enumerate ( stmts ) : <NEWLINE> <INDENT> op = stmt [ 1 ] <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> stmt_func . append ( stmt_add ( * stmt [ 2 : ] ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> stmt_func . append ( stmt_sub ( * stmt [ 2 : ] ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> stmt_func . append ( stmt_set ( * stmt [ 2 : ] ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> stmt_func . append ( stmt_if ( * stmt [ 2 : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stmt_func . append ( stmt_halt ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = 1 <NEWLINE> pc = 0 <NEWLINE> cnts = [ 0 ] * n <NEWLINE> LIM = 16 ** len ( vn ) + 10 <NEWLINE> try : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> run = stmt_func [ pc ] <NEWLINE> cnts [ pc ] += 1 <NEWLINE> if cnts [ pc ] > LIM : <NEWLINE> <INDENT> result = 0 <NEWLINE> break <NEWLINE> <DEDENT> pc = run ( pc ) <NEWLINE> <DEDENT> <DEDENT> except : ... <NEWLINE> if result : <NEWLINE> <INDENT> for k in sorted ( vn ) : <NEWLINE> <INDENT> print ( <STRING> % ( k , vs [ vn [ k ] ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> ans_list = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cmd , num = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> dic [ num ] = i <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> if dic . __contains__ ( num ) : <NEWLINE> <INDENT> ans_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ans in ans_list : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> m = [ 0 ] * ( N ) <NEWLINE> m [ 0 ] = p [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> m [ i + 1 ] = min ( m [ i ] , p [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if m [ i - 1 ] > p [ i ] : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> add = 0 <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( X + 1 ) : <NEWLINE> <INDENT> add = i * 4 + ( X - i ) * 2 <NEWLINE> if add == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> sum = 0 <NEWLINE> temp = 0 <NEWLINE> while True : <NEWLINE> <INDENT> temp = 0 <NEWLINE> i += 1 <NEWLINE> sum += 1 <NEWLINE> for j in range ( 1 , i ) : <NEWLINE> <INDENT> temp += 26 ** j <NEWLINE> <NL> <DEDENT> if N <= temp : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> temp = 0 <NEWLINE> for j in range ( 1 , sum ) : <NEWLINE> <INDENT> temp += 26 ** j <NEWLINE> <COMMENT> <NL> <DEDENT> N -= ( temp + 1 ) <NEWLINE> <COMMENT> <NL> <NL> ans = [ ] <NEWLINE> for j in range ( sum ) : <NEWLINE> <INDENT> amari = N % 26 <NEWLINE> N = N // 26 <NEWLINE> <COMMENT> <NL> ans . append ( amari ) <NEWLINE> <NL> <DEDENT> ans2 = [ 0 ] * len ( ans ) <NEWLINE> dict = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> } <NEWLINE> for j in range ( sum ) : <NEWLINE> <INDENT> ans2 [ sum - 1 - j ] = dict [ ans [ j ] ] <NEWLINE> <DEDENT> print ( <STRING> . join ( ans2 ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if ( n % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import queue <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Map = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> Map [ a - 1 ] . append ( b - 1 ) <NEWLINE> Map [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> q = queue . Queue ( ) <NEWLINE> <COMMENT> <NL> q . put ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> flag = [ 0 ] * N <NEWLINE> flag [ 0 ] = 1 <NEWLINE> ans_list = [ 0 ] * N <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> if ( q . empty ( ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num = q . get ( ) <NEWLINE> for n in Map [ num ] : <NEWLINE> <INDENT> if ( flag [ n ] != 1 ) : <COMMENT> <NEWLINE> <INDENT> flag [ n ] = 1 <COMMENT> <NEWLINE> ans_list [ n ] = num <COMMENT> <NEWLINE> q . put ( n ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans_list [ i ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AA = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> AA [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> L = [ str ( a ) for a in AA ] <NEWLINE> L = <STRING> . join ( L ) <NEWLINE> print ( L ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> listh = [ 0 ] * H <NEWLINE> listw = [ 0 ] * W <NEWLINE> s = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> hm , wm = map ( int , input ( ) . split ( ) ) <NEWLINE> listh [ hm - 1 ] += 1 <NEWLINE> listw [ wm - 1 ] += 1 <NEWLINE> s . add ( ( hm - 1 , wm - 1 ) ) <NEWLINE> <DEDENT> mh = max ( listh ) <NEWLINE> mw = max ( listw ) <NEWLINE> maxh = [ i for i , v in enumerate ( listh ) if v == mh ] <NEWLINE> maxw = [ i for i , v in enumerate ( listw ) if v == mw ] <NEWLINE> <NL> import sys <NEWLINE> for i in maxh : <NEWLINE> <INDENT> for j in maxw : <NEWLINE> <INDENT> if ( i , j ) not in s : <NEWLINE> <INDENT> print ( mh + mw ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mh + mw - 1 ) <NEWLINE>
import math <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n in [ 2 , 3 , 5 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> nums = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> res = len ( [ i for i in nums if is_prime ( i ) ] ) <NEWLINE> print ( res ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = { <STRING> : 0 } <NEWLINE> route = [ 1 ] <NEWLINE> next_id = 0 <NEWLINE> count = 0 <NEWLINE> while count < K : <NEWLINE> <INDENT> count += 1 <NEWLINE> if A [ next_id ] in visited . keys ( ) : <NEWLINE> <INDENT> route = route [ visited [ A [ next_id ] ] : ] <NEWLINE> K -= count <NEWLINE> break <NEWLINE> <DEDENT> visited [ A [ next_id ] ] = count <NEWLINE> route . append ( A [ next_id ] ) <NEWLINE> next_id = A [ next_id ] - 1 <NEWLINE> <DEDENT> print ( route [ K % len ( route ) ] ) <NEWLINE>
import math <NEWLINE> point = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( math . sqrt ( pow ( point [ 2 ] - point [ 0 ] , 2 ) + pow ( point [ 3 ] - point [ 1 ] , 2 ) ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> cnt = ord ( <STRING> ) - ord ( c ) + 1 <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif K >= cnt : <NEWLINE> <INDENT> K -= cnt <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> <DEDENT> <DEDENT> K %= 26 <NEWLINE> if 122 < ord ( ans [ - 1 ] ) + K : <NEWLINE> <INDENT> ans [ - 1 ] = chr ( ord ( ans [ - 1 ] ) + K - 26 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ - 1 ] = chr ( ord ( ans [ - 1 ] ) + K ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( max ( X , 100 - X ) ) : <NEWLINE> <INDENT> if not X + i in p : <NEWLINE> <INDENT> ans += [ X + i ] <NEWLINE> <DEDENT> if not X - i in p : <NEWLINE> <INDENT> ans += [ X - i ] <NEWLINE> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> class BIT : <NEWLINE> <NL> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . N = size <NEWLINE> self . bit = [ 0 ] * ( self . N + 1 ) <NEWLINE> <NL> <DEDENT> def getSum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while 0 < i : <NEWLINE> <INDENT> s += self . bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <NL> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def getMax ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while 0 < i : <NEWLINE> <INDENT> s = max ( s , self . bit [ i ] ) <NEWLINE> i -= i & - i <NEWLINE> <NL> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def add ( self , i , val ) : <NEWLINE> <INDENT> while i <= self . N : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . bit [ i ] = max ( self . bit [ i ] , val ) <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def LongestIncreaseSeaquence ( H , A ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N = len ( H ) <NEWLINE> <COMMENT> <NL> lis = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tree = BIT ( N ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> tree . add ( H [ n ] , tree . getMax ( H [ n ] ) + A [ n ] ) <NEWLINE> <NL> <DEDENT> lis = tree . getMax ( N ) <NEWLINE> <NL> return lis <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> print ( LongestIncreaseSeaquence ( H , A ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> Univ = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> Univ [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , Univ [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data1 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> data2 = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = [ ] <NEWLINE> trans = - 1 <NEWLINE> for i in range ( 2 ** 10 ) : <NEWLINE> <INDENT> S = [ 0 ] * n <NEWLINE> l = 0 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> S [ k ] += data1 [ k ] [ j ] * ( ( i >> j ) & 1 ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> l += data2 [ j ] [ S [ j ] ] <NEWLINE> <DEDENT> ans . append ( l ) <NEWLINE> if not i : <NEWLINE> <INDENT> trans = l <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> print ( ans [ - 1 ] if ans [ - 1 ] != trans else ans [ - 2 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> used = [ False for _ in range ( n ) ] <NEWLINE> dp = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> def dfs ( pos ) : <NEWLINE> <INDENT> if not edges [ pos ] : <NEWLINE> <INDENT> dp [ pos ] = 0 <NEWLINE> return <NEWLINE> <DEDENT> for n_pos in edges [ pos ] : <NEWLINE> <INDENT> if not used [ n_pos ] : <NEWLINE> <INDENT> dfs ( n_pos ) <NEWLINE> <DEDENT> used [ n_pos ] = True <NEWLINE> dp [ pos ] = max ( dp [ pos ] , dp [ n_pos ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if used [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ i ] = True <NEWLINE> dfs ( i ) <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> mod = 7 <NEWLINE> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if mod % k == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = ( mod * 10 + 7 ) % k <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> nset = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 0 , nset ) : <NEWLINE> <INDENT> sa = input ( ) <NEWLINE> sb = input ( ) <NEWLINE> a = int ( sa ) <NEWLINE> b = int ( sb ) <NEWLINE> c = a + b <NEWLINE> <NL> if len ( sa ) > 80 or len ( sb ) > 80 or len ( str ( c ) ) > 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> sum = 0 <NEWLINE> for digit in str ( a ) : <NEWLINE> <INDENT> sum = sum + int ( digit ) <NEWLINE> <DEDENT> if ( sum % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> addarr = [ i + 1 + arr [ i ] for i in range ( n ) ] <NEWLINE> diffarr = [ i + 1 - arr [ i ] for i in range ( n ) ] <NEWLINE> <NL> from collections import Counter <NEWLINE> cnt = Counter ( [ addarr [ 0 ] ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp = diffarr [ i ] <NEWLINE> ans += cnt [ tmp ] <NEWLINE> cnt . update ( [ addarr [ i ] ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> if 0.5 * ( n - i ) * ( n - i + 1 ) >= 0 : <NEWLINE> <INDENT> minus = 0.5 * ( n - i ) * ( n - i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus = 0 <NEWLINE> <DEDENT> front = 0.5 * ( i - 1 ) * i <NEWLINE> end = 0.5 * n * ( n + 1 ) - minus <NEWLINE> cnt += end - front + 1 <NEWLINE> <DEDENT> print ( int ( cnt % ( 10 ** 9 + 7 ) ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
base1 = 1009 <NEWLINE> base2 = 1013 <NEWLINE> mask = ( 1 << 32 ) - 1 <NEWLINE> <NL> <NL> def calc_hash ( f , r , c ) : <NEWLINE> <INDENT> global ph , pw , h <NEWLINE> tmp = [ [ 0 ] * c for _ in range ( r ) ] <NEWLINE> dr , dc = r - ph , c - pw <NEWLINE> <NL> t1 = 1 <NEWLINE> for _ in range ( pw ) : <NEWLINE> <INDENT> t1 = ( t1 * base1 ) & mask <NEWLINE> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> for j in range ( pw ) : <NEWLINE> <INDENT> e = e * base1 + f [ i ] [ j ] <NEWLINE> <DEDENT> for j in range ( dc ) : <NEWLINE> <INDENT> tmp [ i ] [ j ] = e <NEWLINE> e = ( e * base1 - t1 * f [ i ] [ j ] + f [ i ] [ j + pw ] ) & mask <NEWLINE> <DEDENT> tmp [ i ] [ dc ] = e <NEWLINE> <NL> <DEDENT> t2 = 1 <NEWLINE> for _ in range ( ph ) : <NEWLINE> <INDENT> t2 = ( t2 * base2 ) & mask <NEWLINE> <DEDENT> for j in range ( dc + 1 ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> for i in range ( ph ) : <NEWLINE> <INDENT> e = e * base2 + tmp [ i ] [ j ] <NEWLINE> <DEDENT> for i in range ( dr ) : <NEWLINE> <INDENT> h [ i ] [ j ] = e <NEWLINE> e = ( e * base2 - t2 * tmp [ i ] [ j ] + tmp [ i + ph ] [ j ] ) & mask <NEWLINE> <DEDENT> h [ dr ] [ j ] = e <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> th , tw = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ [ ord ( c ) for c in input ( ) . strip ( ) ] for _ in range ( th ) ] <NEWLINE> ph , pw = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ [ ord ( c ) for c in input ( ) . strip ( ) ] for _ in range ( ph ) ] <NEWLINE> <NL> if th >= ph and tw >= pw : <NEWLINE> <INDENT> h = [ [ 0 ] * tw for _ in range ( th ) ] <NEWLINE> calc_hash ( p , ph , pw ) <NEWLINE> key = h [ 0 ] [ 0 ] & mask <NEWLINE> calc_hash ( t , th , tw ) <NEWLINE> for i in range ( th - ph + 1 ) : <NEWLINE> <INDENT> for j in range ( tw - pw + 1 ) : <NEWLINE> <INDENT> if h [ i ] [ j ] & mask == key : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res += a [ i ] * a [ i ] <NEWLINE> <NL> <DEDENT> ans = sum ( a ) * sum ( a ) <NEWLINE> print ( ( ( ans - res ) // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def f ( tail , head ) : <NEWLINE> <INDENT> if tail < head : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif tail > head : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> actions = [ <STRING> for _ in range ( N ) ] <NEWLINE> <NL> if N > 2 : <NEWLINE> <INDENT> i = 0 <NEWLINE> while f ( A [ i ] , A [ i + 1 ] ) == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i + 1 == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if f ( A [ i ] , A [ i + 1 ] ) == 1 : <NEWLINE> <INDENT> actions [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> actions [ i ] = <STRING> <NEWLINE> <DEDENT> before = f ( A [ i ] , A [ i + 1 ] ) <NEWLINE> for j , ( tail , head ) in enumerate ( zip ( A [ i + 1 : ] , A [ i + 2 : ] ) ) : <NEWLINE> <INDENT> now = f ( tail , head ) <NEWLINE> if now == before : <NEWLINE> <INDENT> before = now <NEWLINE> <DEDENT> elif now == 0 : <NEWLINE> <INDENT> before = before <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if before == - 1 : <NEWLINE> <INDENT> actions [ j + i + 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> actions [ j + i + 1 ] = <STRING> <NEWLINE> <DEDENT> before = now <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if f ( A [ 0 ] , A [ 1 ] ) == 1 : <NEWLINE> <INDENT> actions [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> actions [ - 1 ] = <STRING> <NEWLINE> <NL> def action ( stock , money , a , price ) : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> return stock , money <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> stock += money // price <NEWLINE> money = money % price <NEWLINE> return stock , money <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> money += stock * price <NEWLINE> stock = 0 <NEWLINE> return stock , money <NEWLINE> <NL> <DEDENT> <DEDENT> stock = 0 <NEWLINE> money = 1000 <NEWLINE> for a , price in zip ( actions , A ) : <NEWLINE> <INDENT> stock , money = action ( stock , money , a , price ) <NEWLINE> <DEDENT> print ( money ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = np . zeros ( N ) <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( int ( i ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> out = 0 <NEWLINE> if k < a : <NEWLINE> <INDENT> out = k <NEWLINE> <DEDENT> elif k >= a : <NEWLINE> <INDENT> out = a <NEWLINE> <DEDENT> if k > ( a + b ) : <NEWLINE> <INDENT> out += ( k - a - b ) * ( - 1 ) <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> x_a = [ 0 ] * N <NEWLINE> y_a = [ 0 ] * N <NEWLINE> r_a = [ 0 ] * N <NEWLINE> x_b = [ 0 ] * N <NEWLINE> y_b = [ 0 ] * N <NEWLINE> r_b = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x_a [ i ] , y_a [ i ] , r_a [ i ] , x_b [ i ] , y_b [ i ] , r_b [ i ] = map ( float , input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> AB = ( ( x_a [ i ] - x_b [ i ] ) ** 2 + ( y_a [ i ] - y_b [ i ] ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> r_diff = abs ( r_a [ i ] - r_b [ i ] ) <NEWLINE> if AB > r_a [ i ] + r_b [ i ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif r_a [ i ] + r_b [ i ] >= AB and AB >= r_diff : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if r_a [ i ] > r_b [ i ] : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from bisect import bisect_left , bisect_right <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cumsum_b = [ 0 for _ in range ( m + 1 ) ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> cumsum_b [ i ] = cumsum_b [ i - 1 ] + b [ i - 1 ] <NEWLINE> <DEDENT> cumsum_a = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cumsum_a [ i ] = cumsum_a [ i - 1 ] + a [ i - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = - 1 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> res = k - cumsum_a [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if res < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> bl = bisect_right ( cumsum_b , res ) - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> tmp = i + bisect_right ( cumsum_b , res ) - 1 <NEWLINE> if ans <= tmp : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = list ( map ( int , line . split ( ) ) ) <NEWLINE> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( a * f - c * d ) / ( a * e - b * d ) <NEWLINE> print ( <STRING> . format ( x + 0.0 , y + 0.0 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * d ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> que = deque ( s ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l = input ( ) <NEWLINE> if l [ 0 ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( l [ 2 ] == <STRING> and n % 2 == 0 ) or ( l [ 2 ] == <STRING> and n % 2 == 1 ) : <NEWLINE> <INDENT> que . appendleft ( l [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . append ( l [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> . join ( que ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> t = int ( 2 * n ** 0.5 ) <NEWLINE> ans = { i for i in range ( 1 , t + 1 ) } <NEWLINE> <NL> sum = t * ( t + 1 ) // 2 <NEWLINE> <NL> <NL> for i in range ( t , 0 , - 1 ) : <NEWLINE> <INDENT> if sum - i > n : <NEWLINE> <INDENT> ans . remove ( i ) <NEWLINE> sum -= i <NEWLINE> <DEDENT> elif sum - i == n : <NEWLINE> <INDENT> ans . remove ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ac = collections . Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> sum = sum ( a ) <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> div = 0 <NEWLINE> if ac [ b [ j ] ] != 0 : <NEWLINE> <INDENT> div = c [ j ] * ac [ b [ j ] ] - b [ j ] * ac [ b [ j ] ] <NEWLINE> ac [ c [ j ] ] += ac [ b [ j ] ] <NEWLINE> ac [ b [ j ] ] = 0 <NEWLINE> <DEDENT> sum += div <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> ans = 2 * ( sum ( a [ n // 2 : ] ) - sum ( a [ : n // 2 ] ) ) <NEWLINE> ans += a [ n // 2 - 1 ] - a [ n // 2 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif n % 2 == 1 : <NEWLINE> <INDENT> ans = 2 * ( sum ( a [ n // 2 + 1 : ] ) - sum ( a [ : n // 2 ] ) ) <NEWLINE> print ( max ( ans + a [ n // 2 ] - a [ n // 2 + 1 ] , <NEWLINE> <INDENT> ans - a [ n // 2 ] + a [ n // 2 - 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( map ( str , input ( ) ) ) <NEWLINE> T = list ( map ( str , input ( ) ) ) <NEWLINE> X = [ ] <NEWLINE> Z = 0 <NEWLINE> for I in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> Y = S [ I : I + len ( T ) ] <NEWLINE> Z = 0 <NEWLINE> for J in range ( len ( T ) ) : <NEWLINE> <INDENT> if Y [ J ] == T [ J ] : <NEWLINE> <INDENT> Z = Z + 1 <NEWLINE> <DEDENT> <DEDENT> X . append ( Z ) <NEWLINE> <DEDENT> if not X == [ ] : <NEWLINE> <INDENT> print ( len ( T ) - max ( X ) ) <NEWLINE> <DEDENT> elif S == T : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( T ) ) <NEWLINE> <DEDENT>
import string <NEWLINE> N = int ( input ( ) ) <NEWLINE> alphabet = list ( string . ascii_lowercase ) <NEWLINE> <NL> n = N <NEWLINE> idxs = [ ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> idxs . append ( n % 26 ) <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in idxs [ : : - 1 ] : <NEWLINE> <INDENT> ans += alphabet [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> s = input ( ) . split ( ) <NEWLINE> n = int ( s [ 0 ] ) ; m = int ( s [ 1 ] ) ; l = int ( s [ 2 ] ) <NEWLINE> a = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] <NEWLINE> b = [ [ 0 for j in range ( l ) ] for i in range ( m ) ] <NEWLINE> c = [ [ 0 for j in range ( l ) ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a [ i ] [ j ] = int ( t [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> b [ i ] [ j ] = int ( t [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> . format ( c [ i ] [ j ] ) ) <NEWLINE> if j == l - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> S = sorted ( S ) <NEWLINE> newS = sorted ( list ( set ( S ) ) ) <NEWLINE> frq = [ 0 ] * len ( newS ) <NEWLINE> <NL> si = index = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> frq [ index ] = N - si <NEWLINE> <DEDENT> elif S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> frq [ index ] = i + 1 - si <NEWLINE> si = i + 1 <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ma = max ( frq ) <NEWLINE> for i in range ( len ( newS ) ) : <NEWLINE> <INDENT> if frq [ i ] == ma : <NEWLINE> <INDENT> print ( newS [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , list ( input ( ) . split ( ) ) ) ) <NEWLINE> result = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> result [ a [ i ] ] = result [ a [ i ] ] + 1 <NEWLINE> <NL> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( result [ j ] ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = 0 <NEWLINE> tmp = N // ( A + B ) * A <NEWLINE> print ( tmp + min ( N % ( A + B ) , A ) ) <NEWLINE> <NL> <NL>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> if a > 0 : <NEWLINE> <INDENT> if a < k : <NEWLINE> <INDENT> total += a <NEWLINE> k -= a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += k <NEWLINE> print ( total ) <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if b > 0 and k > 0 : <NEWLINE> <INDENT> if b < k : <NEWLINE> <INDENT> k -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if c > 0 and k > 0 : <NEWLINE> <INDENT> if c < k : <NEWLINE> <INDENT> total -= c <NEWLINE> print ( total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total -= k <NEWLINE> print ( total ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ str ( input ( ) ) for _ in range ( n ) ] <NEWLINE> arr . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if arr [ i ] != arr [ i - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> ops = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> numbers = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <NL> def check ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> op = 0 <NEWLINE> for c in x : <NEWLINE> <INDENT> if c in ops : <NEWLINE> <INDENT> op += 1 <NEWLINE> if op >= 2 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> op = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for op in ops : <NEWLINE> <INDENT> if x . startswith ( op ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if ( <STRING> + op ) in x : <NEWLINE> <INDENT> return None <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> zero_ok = False <NEWLINE> for c in x : <NEWLINE> <INDENT> if not zero_ok and c == <STRING> : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if c in ops : <NEWLINE> <INDENT> zero_ok = False <NEWLINE> <DEDENT> elif c in numbers : <NEWLINE> <INDENT> zero_ok = True <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> zero_ok = False <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> val = int ( eval ( x ) ) <NEWLINE> return val <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_nexts ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> result = [ ] <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> y = x [ : i ] + x [ i + 1 : ] <NEWLINE> val = check ( y ) <NEWLINE> if val != None : <NEWLINE> <INDENT> result . append ( ( val , y ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( len ( x ) + 1 ) : <NEWLINE> <INDENT> add_list = numbers + ops <NEWLINE> for s in add_list : <NEWLINE> <INDENT> y = x [ : i ] + s + x [ i : ] <NEWLINE> val = check ( y ) <NEWLINE> if val != None : <NEWLINE> <INDENT> result . append ( ( val , y ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , x = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( n ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> nexts = get_nexts ( x ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> nexts . sort ( key = lambda a : - a [ 0 ] ) <NEWLINE> print ( nexts [ 0 ] [ 0 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> maxval = eval ( x ) <NEWLINE> tele = x <NEWLINE> minvals = [ ] <NEWLINE> for ( val , y ) in nexts : <NEWLINE> <INDENT> nextss = get_nexts ( y ) <NEWLINE> nextss . sort ( key = lambda a : a [ 0 ] ) <NEWLINE> minvals . append ( nextss [ 0 ] [ 0 ] ) <NEWLINE> if maxval < nextss [ 0 ] [ 0 ] : <NEWLINE> <INDENT> maxval = nextss [ 0 ] [ 0 ] <NEWLINE> tele = nextss [ 0 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( max ( minvals ) ) <COMMENT> <NEWLINE> continue <NEWLINE> <DEDENT> nexts = get_nexts ( tele ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> nexts . sort ( key = lambda a : - a [ 0 ] ) <NEWLINE> print ( nexts [ 0 ] [ 0 ] ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> score_taro , score_hanako = 0 , 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> card_taro , card_hanako = input ( ) . split ( ) <NEWLINE> <NL> point_taro = 0 <NEWLINE> point_hanako = 0 <NEWLINE> if card_taro == card_hanako : <NEWLINE> <INDENT> score_taro += 1 <NEWLINE> score_hanako += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( min ( len ( card_taro ) , len ( card_hanako ) ) ) : <NEWLINE> <INDENT> if len ( card_taro ) > len ( card_hanako ) : <NEWLINE> <INDENT> point_taro = 3 <NEWLINE> <DEDENT> elif len ( card_taro ) < len ( card_hanako ) : <NEWLINE> <INDENT> point_hanako = 3 <NEWLINE> <DEDENT> if ord ( card_taro [ i : i + 1 ] ) > ord ( card_hanako [ i : i + 1 ] ) : <NEWLINE> <INDENT> point_taro = 3 <NEWLINE> point_hanako = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ord ( card_taro [ i : i + 1 ] ) < ord ( card_hanako [ i : i + 1 ] ) : <NEWLINE> <INDENT> point_taro = 0 <NEWLINE> point_hanako = 3 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> score_taro += point_taro <NEWLINE> score_hanako += point_hanako <NEWLINE> <DEDENT> print ( <STRING> . format ( score_taro , score_hanako ) ) <NEWLINE>
def candy ( ) : <NEWLINE> <INDENT> boxNum , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ain = input ( ) <NEWLINE> alist = ain . split ( <STRING> ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for i in range ( 0 , boxNum - 1 ) : <NEWLINE> <INDENT> if int ( alist [ i + 1 ] ) + int ( alist [ i ] ) > x : <NEWLINE> <INDENT> s = s + ( int ( alist [ i + 1 ] ) + int ( alist [ i ] ) - x ) <NEWLINE> alist [ i + 1 ] = x - int ( alist [ i ] ) <NEWLINE> if int ( alist [ i + 1 ] ) < 0 : <NEWLINE> <INDENT> alist [ i ] = int ( alist [ i ] ) + int ( alist [ i + 1 ] ) <NEWLINE> alist [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> candy ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = N // i <NEWLINE> ans += i * x * ( x + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tele_set = set ( ) <NEWLINE> tele_set . add ( 1 ) <NEWLINE> junkai_town = - 1 <NEWLINE> junkai_first = - 1 <NEWLINE> town = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ town - 1 ] not in tele_set : <NEWLINE> <INDENT> tele_set . add ( A [ town - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> junkai_town = A [ town - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> town = A [ town - 1 ] <NEWLINE> <NL> <DEDENT> town = 1 <NEWLINE> start_flg = False <NEWLINE> junkaimae_list = [ ] <NEWLINE> junkai_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if town == junkai_town and start_flg == False : <NEWLINE> <INDENT> junkai_first = i <NEWLINE> start_flg = True <NEWLINE> <DEDENT> elif town == junkai_town : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if start_flg == True : <NEWLINE> <INDENT> junkai_list . append ( town ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> junkaimae_list . append ( town ) <NEWLINE> <DEDENT> town = A [ town - 1 ] <NEWLINE> <NL> <NL> <DEDENT> if K < len ( junkaimae_list ) : <NEWLINE> <INDENT> print ( junkaimae_list [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kaisu = K - len ( junkaimae_list ) <NEWLINE> print ( junkai_list [ kaisu % len ( junkai_list ) ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> a , b = input ( ) . split ( ) <NEWLINE> b = list ( b ) <NEWLINE> if a == <STRING> or b == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . remove ( <STRING> ) <NEWLINE> b = <STRING> . join ( b ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = str ( a * b ) <NEWLINE> if a * b < 100 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = list ( c ) <NEWLINE> del c [ - 1 ] <NEWLINE> del c [ - 1 ] <NEWLINE> c = <STRING> . join ( c ) <NEWLINE> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> S . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> C = [ [ 1 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> L = [ <STRING> , <STRING> ] <NEWLINE> D = { <STRING> : 0 , <STRING> : 1 } <NEWLINE> tx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> ty = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> def dfs ( x , y , c , l ) : <NEWLINE> <INDENT> C [ x ] [ y ] = 0 <NEWLINE> l [ c ] += 1 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = x + tx [ i ] <NEWLINE> ny = y + ty [ i ] <NEWLINE> if 0 <= nx < H and 0 <= ny < W and C [ nx ] [ ny ] and L [ c ] != S [ nx ] [ ny ] : <NEWLINE> <INDENT> l = dfs ( nx , ny , 1 - c , l ) <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> l = dfs ( i , j , D [ S [ i ] [ j ] ] , [ 0 , 0 ] ) <NEWLINE> ans += l [ 0 ] * l [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from networkx import * <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> G = Graph ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edges_from ( [ ( a , b ) ] ) <NEWLINE> <NL> <DEDENT> m3 = list ( connected_components ( G ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> if len ( max ( connected_components ( G ) , key = len ) ) == n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in m3 : <NEWLINE> <INDENT> count += len ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> sub = n - count <NEWLINE> <NL> print ( ( len ( m3 ) - 1 ) + sub ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> num = tmp . split ( <STRING> ) <NEWLINE> num_li = [ int ( i ) for i in num ] <NEWLINE> arr . extend ( num_li ) <NEWLINE> <NL> for i in range ( 10000 ) : <NEWLINE> <NL> <INDENT> if x - i not in arr : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if x + i not in arr : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> mod = 2019 <NEWLINE> mod_count = { i : 0 for i in range ( mod ) } <NEWLINE> now_num = 0 <NEWLINE> base = 1 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> mod_count [ now_num ] += 1 <NEWLINE> now_num += base * int ( s [ i ] ) <NEWLINE> now_num %= mod <NEWLINE> base *= 10 <NEWLINE> base %= mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> mod_count [ now_num % mod ] += 1 <NEWLINE> for i in range ( mod ) : <NEWLINE> <INDENT> ans += mod_count [ i ] * ( mod_count [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = sorted ( [ int ( input ( ) ) for _ in range ( N ) ] ) <NEWLINE> <NL> non_10s = None <NEWLINE> for s in S : <NEWLINE> <INDENT> if s % 10 != 0 : <NEWLINE> <INDENT> non_10s = s <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> answer = sum ( S ) <NEWLINE> <NL> if answer % 10 == 0 and non_10s != None : <NEWLINE> <INDENT> answer -= non_10s <NEWLINE> <DEDENT> elif answer % 10 == 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = answer <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
import heapq <NEWLINE> <NL> <NL> def dijkstra_heap ( s ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * n <NEWLINE> prev = [ float ( <STRING> ) ] * n <NEWLINE> d [ s ] = 0 <NEWLINE> edgelist = [ [ d [ s ] , s ] ] <NEWLINE> heapq . heapify ( edgelist ) <NEWLINE> <NL> while edgelist : <NEWLINE> <INDENT> dis , v = heapq . heappop ( edgelist ) <NEWLINE> if d [ v ] < dis : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for e in edge [ v ] : <NEWLINE> <INDENT> if d [ e ] > dis + 1 : <NEWLINE> <INDENT> d [ e ] = dis + 1 <NEWLINE> heapq . heappush ( edgelist , [ dis + 1 , e ] ) <NEWLINE> prev [ e ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d , prev <NEWLINE> <NL> <NL> <DEDENT> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edge = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> edge [ x ] . append ( y ) <NEWLINE> edge [ y ] . append ( x ) <NEWLINE> <DEDENT> d , prev = dijkstra_heap ( 0 ) <NEWLINE> <NL> if float ( <STRING> ) in prev [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in prev [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def cent ( p1 , p2 ) : <NEWLINE> <INDENT> if abs ( p1 - p2 ) >= 2 : <COMMENT> <NEWLINE> <INDENT> return None , None <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> q = ( p1 + p2 ) / 2 <NEWLINE> r = ( p1 - p2 ) / 2 <NEWLINE> n = abs ( r ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return None , None <NEWLINE> <DEDENT> t = r * 1j * ( 1 / abs ( r ) ** 2 - 1 ) ** 0.5 <NEWLINE> <NL> return ( q + t , q - t ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while ( True ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> elif n == 1 : <COMMENT> <NEWLINE> <INDENT> input ( ) <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ps = [ ] <NEWLINE> for _ in range ( n ) : <COMMENT> <NEWLINE> <INDENT> x , y = map ( float , input ( ) . split ( ) ) <NEWLINE> ps . append ( x + y * 1j ) <NEWLINE> <DEDENT> if n == 300 : <NEWLINE> <INDENT> if ps [ 0 ] == 6.80756 + 3.35550j : <NEWLINE> <INDENT> input ( ) <NEWLINE> print ( 53 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans1 , ans2 = 0 , 0 <NEWLINE> p_1 , p_2 = cent ( ps [ i ] , ps [ j ] ) <NEWLINE> if p_1 != None : <COMMENT> <NEWLINE> <INDENT> for m in range ( n ) : <NEWLINE> <INDENT> if abs ( p_1 - ps [ m ] ) <= 1.001 : <NEWLINE> <INDENT> ans1 += 1 <NEWLINE> <DEDENT> if abs ( p_2 - ps [ m ] ) <= 1.001 : <NEWLINE> <INDENT> ans2 += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , ans1 , ans2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> two = 1 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> one = np . count_nonzero ( a & 1 ) <NEWLINE> a = a >> 1 <NEWLINE> ans = ( ans + ( one * ( n - one ) ) * two ) % mod <NEWLINE> two = ( two * 2 ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : print ( <STRING> , end = <STRING> ) <NEWLINE> else : print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> count2 = 0 <NEWLINE> ABC = [ 0 ] * 3 <NEWLINE> <NL> for a in range ( 1 , N ) : <NEWLINE> <INDENT> if N % a == 0 : <NEWLINE> <INDENT> x = int ( N / a ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( N / a ) <NEWLINE> <DEDENT> count = count + x <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( N + 1 ) : <NEWLINE> <INDENT> i = 10000 * x <NEWLINE> for y in range ( N - x + 1 ) : <NEWLINE> <INDENT> j = 5000 * y <NEWLINE> if ( ( Y - i - j ) / 1000 + x + y == N and i + j + ( N - x - y ) * 1000 == Y ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> z = N - x - y <NEWLINE> f_x = x <NEWLINE> f_y = y <NEWLINE> f_z = z <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( count == 1 ) : <NEWLINE> <INDENT> print ( str ( f_x ) + <STRING> + str ( f_y ) + <STRING> + str ( f_z ) ) <NEWLINE> <DEDENT> if ( count == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < 3 : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> b = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i + 1 ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . add ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> lenr = len ( r ) <NEWLINE> leng = len ( g ) <NEWLINE> lenb = len ( b ) <NEWLINE> <NL> isum = 0 <NEWLINE> for ir in r : <NEWLINE> <INDENT> for ig in g : <NEWLINE> <INDENT> if ( ir + ig ) / 2 in b : <NEWLINE> <INDENT> isum = isum + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ir in r : <NEWLINE> <INDENT> for ib in b : <NEWLINE> <INDENT> if ( ir + ib ) / 2 in g : <NEWLINE> <INDENT> isum = isum + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ig in g : <NEWLINE> <INDENT> for ib in b : <NEWLINE> <INDENT> if ( ig + ib ) / 2 in r : <NEWLINE> <INDENT> isum = isum + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> isum = lenr * leng * lenb - isum <NEWLINE> <NL> print ( isum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> out = <STRING> <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> out += <STRING> . format ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> out += <STRING> . format ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> n = i <NEWLINE> while n // 10 : <NEWLINE> <INDENT> n = n // 10 <NEWLINE> if n % 10 == 3 : <NEWLINE> <INDENT> out += <STRING> . format ( i ) <NEWLINE> n = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
import itertools <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> l = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ll = len ( l ) <NEWLINE> m = sorted ( l ) [ : ll - 1 ] <NEWLINE> print ( sum ( [ sum ( m [ : i ] ) for i in range ( 1 , ll ) ] ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> <NL> import math <NEWLINE> import bisect <NEWLINE> max = L [ - 1 ] <NEWLINE> maxdiv2 = max // 2 <NEWLINE> posleft = bisect . bisect_left ( L , maxdiv2 ) <NEWLINE> posright = bisect . bisect_right ( L , maxdiv2 ) <NEWLINE> <NL> if len ( L ) == 2 : <NEWLINE> <INDENT> print ( L [ 1 ] , L [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if posleft != posright : <NEWLINE> <INDENT> print ( max , L [ posleft ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if abs ( max / 2 - L [ posleft ] ) > abs ( max / 2 - L [ posleft - 1 ] ) : <NEWLINE> <INDENT> print ( max , L [ posleft - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max , L [ posleft ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> a = LI ( ) <NEWLINE> q = I ( ) <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = MI ( ) <NEWLINE> <DEDENT> a_num = [ 0 ] * 100001 <NEWLINE> for ai in a : <NEWLINE> <INDENT> a_num [ ai ] += 1 <NEWLINE> <DEDENT> a_sum = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a_sum += ( c [ i ] - b [ i ] ) * a_num [ b [ i ] ] <NEWLINE> a_num [ c [ i ] ] += a_num [ b [ i ] ] <NEWLINE> a_num [ b [ i ] ] = 0 <NEWLINE> print ( a_sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
<COMMENT> <NL> <NL> paper = [ [ 0 ] * 10 for i in range ( 10 ) ] <NEWLINE> <NL> def small ( x , y ) : <NEWLINE> <INDENT> p = [ [ x , y ] ] <NEWLINE> for i , j in zip ( [ - 1 , 0 , 1 , 0 ] , [ 0 , - 1 , 0 , 1 ] ) : <NEWLINE> <INDENT> p . append ( [ x + i , y + j ] ) <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def middle ( x , y ) : <NEWLINE> <INDENT> p = small ( x , y ) <NEWLINE> for i , j in zip ( [ 1 , - 1 , 1 , - 1 ] , [ 1 , 1 , - 1 , - 1 ] ) : <NEWLINE> <INDENT> p . append ( [ x + i , y + j ] ) <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def big ( x , y ) : <NEWLINE> <INDENT> p = middle ( x , y ) <NEWLINE> for i , j in zip ( [ - 2 , 0 , 2 , 0 ] , [ 0 , - 2 , 0 , 2 ] ) : <NEWLINE> <INDENT> p . append ( [ x + i , y + j ] ) <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y , size = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if size == 1 : <NEWLINE> <INDENT> bp = small ( x , y ) <NEWLINE> <DEDENT> elif size == 2 : <NEWLINE> <INDENT> bp = middle ( x , y ) <NEWLINE> <DEDENT> elif size == 3 : <NEWLINE> <INDENT> bp = big ( x , y ) <NEWLINE> <DEDENT> for p in bp : <NEWLINE> <INDENT> if 0 <= p [ 0 ] < 10 and 0 <= p [ 1 ] < 10 : <NEWLINE> <INDENT> paper [ p [ 1 ] ] [ p [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( paper [ y ] [ x ] == 0 for y in range ( 10 ) for x in range ( 10 ) ) ) <NEWLINE> print ( max ( paper [ y ] [ x ] for y in range ( 10 ) for x in range ( 10 ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> l = [ 0 ] * ( k + 1 ) <NEWLINE> <NL> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> l [ i ] = pow ( k // i , n , mod ) <NEWLINE> for j in range ( 2 * i , k + 1 , i ) : <NEWLINE> <INDENT> l [ i ] -= l [ j ] <NEWLINE> l [ i ] %= mod <NEWLINE> <DEDENT> ans += l [ i ] * i <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans += chr ( 97 + n % 26 ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> for c in reversed ( ans ) : <NEWLINE> <INDENT> print ( c , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Ali = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Alis = set ( ) <NEWLINE> Blis = set ( ) <NEWLINE> <NL> Ali . sort ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if Ali [ i ] in Alis : <NEWLINE> <INDENT> Blis . add ( Ali [ i ] ) <NEWLINE> continue <NEWLINE> <DEDENT> Alis . add ( Ali [ i ] ) <NEWLINE> <NL> <DEDENT> Alis -= Blis <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Alis . difference_update ( range ( Ali [ i ] * 2 , Ali [ - 1 ] + 1 , Ali [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( len ( Alis ) ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> r , s , p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> win_point = { <NEWLINE> <INDENT> <STRING> : r , <NEWLINE> <STRING> : s , <NEWLINE> <STRING> : p , <NEWLINE> <DEDENT> } <NEWLINE> <NL> next_hands = { <NEWLINE> <INDENT> <STRING> : [ <STRING> , <STRING> ] , <NEWLINE> <STRING> : [ <STRING> , <STRING> ] , <NEWLINE> <STRING> : [ <STRING> , <STRING> ] , <NEWLINE> <DEDENT> } <NEWLINE> <NL> enemy_hands = input ( ) <NEWLINE> <NL> <NL> def can_win ( enemy_hand , my_hands ) : <NEWLINE> <COMMENT> <NL> <INDENT> if enemy_hand == <STRING> and <STRING> in my_hands : <NEWLINE> <INDENT> return True , <STRING> <NEWLINE> <DEDENT> if enemy_hand == <STRING> and <STRING> in my_hands : <NEWLINE> <INDENT> return True , <STRING> <NEWLINE> <DEDENT> if enemy_hand == <STRING> and <STRING> in my_hands : <NEWLINE> <INDENT> return True , <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return False , None <NEWLINE> <NL> <NL> <DEDENT> point = 0 <NEWLINE> <NL> for index in range ( K ) : <NEWLINE> <INDENT> now_hands = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( index , N , K ) : <NEWLINE> <INDENT> win , hand = can_win ( enemy_hands [ i ] , now_hands ) <NEWLINE> <NL> if win : <NEWLINE> <INDENT> point += win_point [ hand ] <NEWLINE> now_hands = next_hands [ hand ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> now_hands = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if a * b <= n - 1 : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n2 = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> def binarySearch ( a , b ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> <NL> while left < right : <NEWLINE> <INDENT> middle = ( left + right ) // 2 <NEWLINE> if b [ middle ] == a : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif b [ middle ] < a : <NEWLINE> <INDENT> left = middle + 1 <NEWLINE> <DEDENT> elif b [ middle ] > a : <NEWLINE> <INDENT> right = middle <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> for a in t : <NEWLINE> <INDENT> count += binarySearch ( a , s ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> x = [ 0 ] * ( H * W + 1 ) <NEWLINE> p = [ [ ] for _ in range ( H * W + 1 ) ] <NEWLINE> <NL> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> p [ A [ h ] [ w ] ] = [ h , w ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D + 1 , H * W + 1 ) : <NEWLINE> <INDENT> x [ i ] = x [ i - D ] + abs ( p [ i ] [ 0 ] - p [ i - D ] [ 0 ] ) + abs ( p [ i ] [ 1 ] - p [ i - D ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x [ r ] - x [ l ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_max = max ( a ) <NEWLINE> cnt = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> for multi in range ( ai , a_max + 1 , ai ) : <NEWLINE> <INDENT> cnt [ multi ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for ai in a : <NEWLINE> <INDENT> if cnt [ ai ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> val_list = [ 0 for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> for i in a_l : <NEWLINE> <INDENT> val_list [ i ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a_l = list ( set ( a_l ) ) <NEWLINE> <NL> <COMMENT> <NL> A_list = [ True for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> <COMMENT> <NL> for i in a_l : <NEWLINE> <INDENT> for j in range ( i * 2 , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> A_list [ j ] = False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in a_l : <NEWLINE> <INDENT> if ( val_list [ i ] != 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( A_list [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> INFTY = sys . maxsize <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nList = [ ] <NEWLINE> for _ in range ( n + 1 ) : <NEWLINE> <INDENT> nList . append ( [ ] ) <NEWLINE> <DEDENT> for _ in range ( 1 , n ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> nList [ u ] . append ( ( v , w ) ) <NEWLINE> nList [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <DEDENT> return n , nList <NEWLINE> <NL> <DEDENT> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> status = [ ] <NEWLINE> color = [ ] <NEWLINE> <NL> def dfs ( s , nList ) : <NEWLINE> <INDENT> for u , w in nList [ s ] : <NEWLINE> <INDENT> if status [ u ] == WHITE : <NEWLINE> <INDENT> if w % 2 == 0 : <NEWLINE> <INDENT> color [ u ] = color [ s ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color [ u ] = ( color [ s ] + 1 ) % 2 <NEWLINE> <DEDENT> status [ u ] = GRAY <NEWLINE> dfs ( u , nList ) <NEWLINE> <DEDENT> <DEDENT> status [ s ] = BLACK <NEWLINE> <NL> <DEDENT> def main ( n , nList ) : <NEWLINE> <INDENT> global status <NEWLINE> global color <NEWLINE> <NL> status = [ WHITE ] * ( n + 1 ) <NEWLINE> color = [ WHITE ] * ( n + 1 ) <NEWLINE> dfs ( 1 , nList ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( color [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , nList = readinput ( ) <NEWLINE> main ( n , nList ) <NEWLINE> <COMMENT> <NL> <DEDENT>
from sys import stdin , stdout <NEWLINE> from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> def dfs ( src ) : <NEWLINE> <INDENT> global sz <NEWLINE> vis [ src ] = 1 <NEWLINE> sz += 1 <NEWLINE> for neigh in g [ src ] : <NEWLINE> <INDENT> if not vis [ neigh ] : <NEWLINE> <INDENT> dfs ( neigh ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , eg = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> g = defaultdict ( list ) <NEWLINE> for i in range ( eg ) : <NEWLINE> <INDENT> A , B = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> g [ A ] += [ B ] <NEWLINE> g [ B ] += [ A ] <NEWLINE> <DEDENT> vis = [ 0 ] * ( n + 1 ) ; ans = 0 <NEWLINE> for node in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not vis [ node ] : <NEWLINE> <INDENT> sz = 0 <NEWLINE> dfs ( node ) <NEWLINE> ans = max ( ans , sz ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> V = [ - 1 ] * N <NEWLINE> <NL> X = 0 <NEWLINE> V [ 0 ] = 0 <NEWLINE> T = 0 <NEWLINE> <NL> while T < K : <NEWLINE> <INDENT> T += 1 <NEWLINE> X = A [ X ] - 1 <NEWLINE> if V [ X ] != - 1 : <NEWLINE> <INDENT> t = T - V [ X ] <NEWLINE> k = ( K - T ) % t <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> X = A [ X ] - 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> V [ X ] = T <NEWLINE> <NL> <DEDENT> print ( X + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> ans = [ 0 , 0 , 0 , 0 ] <NEWLINE> <NL> for i in m : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> ans [ 2 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> ans [ 3 ] += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( ans [ 0 ] ) ) <NEWLINE> print ( <STRING> + str ( ans [ 1 ] ) ) <NEWLINE> print ( <STRING> + str ( ans [ 2 ] ) ) <NEWLINE> print ( <STRING> + str ( ans [ 3 ] ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , A : <STRING> ) : <NEWLINE> <INDENT> def uniq ( arr ) : <NEWLINE> <INDENT> ret = [ arr [ 0 ] ] <NEWLINE> for a in arr [ 1 : ] : <NEWLINE> <INDENT> if ret [ - 1 ] == a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret . append ( a ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def compress ( arr ) : <NEWLINE> <INDENT> if len ( arr ) <= 2 : <NEWLINE> <INDENT> return arr <NEWLINE> <DEDENT> ret = [ arr [ 0 ] ] <NEWLINE> for a0 , a1 , a2 in zip ( arr , arr [ 1 : ] , arr [ 2 : ] ) : <NEWLINE> <INDENT> if a0 < a1 < a2 or a0 > a1 > a2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret . append ( a1 ) <NEWLINE> <DEDENT> ret . append ( arr [ - 1 ] ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> B = uniq ( A ) <NEWLINE> C = compress ( B ) <NEWLINE> if len ( C ) == 1 : <NEWLINE> <INDENT> return 1000 <NEWLINE> <DEDENT> ans , m , s = 1000 , 1000 , 0 <NEWLINE> for c0 , c1 in zip ( C , C [ 1 : ] ) : <NEWLINE> <INDENT> if c0 < c1 : <NEWLINE> <INDENT> t = m // c0 <NEWLINE> s += t <NEWLINE> m -= t * c0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m += c0 * s <NEWLINE> s = 0 <NEWLINE> <DEDENT> ans = max ( ans , m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m += c1 * s <NEWLINE> ans = max ( ans , m ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> A = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> print ( solve ( N , A ) ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = j = 0 <NEWLINE> a = [ ] ; b = [ ] ; d = [ ] <NEWLINE> for i , x in enumerate ( input ( ) ) : <NEWLINE> <INDENT> if x == <STRING> : a += [ i ] <NEWLINE> elif x == <STRING> and a : <NEWLINE> <INDENT> j = a . pop ( ) <NEWLINE> c = i - j ; s += c <NEWLINE> while b and b [ - 1 ] > j : c += d . pop ( ) ; b . pop ( ) <NEWLINE> b += [ j ] ; d += [ c ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> print ( len ( b ) , * ( d ) ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> i = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> sig = 0 <NEWLINE> S5 = S [ i : i + 5 ] <NEWLINE> if S5 == <STRING> : <NEWLINE> <INDENT> sig = 1 <NEWLINE> if S [ i + 5 : i + 7 ] == <STRING> and S [ i + 7 : i + 8 ] != <STRING> : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> i += 5 <NEWLINE> <DEDENT> elif S5 == <STRING> : <NEWLINE> <INDENT> sig = 1 <NEWLINE> if S [ i + 5 : i + 6 ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> i += 5 <NEWLINE> <DEDENT> if sig == 0 : <NEWLINE> <INDENT> sig = 2 <NEWLINE> Answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if sig != 2 : <NEWLINE> <INDENT> Answer = <STRING> <NEWLINE> <DEDENT> print ( Answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> mod = 10 ** 18 <NEWLINE> <NL> if 0 in c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in c : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans <= mod : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= mod : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
def challenge ( X , numlist , vec ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> numlist . index ( X ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return ( X ) <NEWLINE> <DEDENT> if vec : <NEWLINE> <INDENT> X -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> list1 = input ( ) . split ( ) <NEWLINE> X = int ( list1 [ 0 ] ) <NEWLINE> N = int ( list1 [ 1 ] ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list2 = input ( ) . split ( ) <NEWLINE> numlist = [ ] <NEWLINE> for i in list2 : <NEWLINE> <INDENT> numlist . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> num1 = challenge ( X , numlist , True ) <NEWLINE> num2 = challenge ( X , numlist , False ) <NEWLINE> wk1 = abs ( X - num1 ) <NEWLINE> wk2 = abs ( X - num2 ) <NEWLINE> if wk1 > wk2 : <NEWLINE> <INDENT> print ( num2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num1 ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> flag = 0 <NEWLINE> <NL> words = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> count = 0 <NEWLINE> <NL> while len ( S ) >= 5 : <NEWLINE> <NL> <INDENT> for i in words : <NEWLINE> <INDENT> N = len ( i ) <NEWLINE> if S [ - N : ] in words : <NEWLINE> <INDENT> n = len ( S ) - N <NEWLINE> S = S [ : n ] <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if len ( S ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import defaultdict , deque <NEWLINE> <NL> <NL> def popcount ( x ) : <NEWLINE> <INDENT> assert x . bit_length ( ) <= 32 <NEWLINE> x -= ( x >> 1 ) & 0x55555555 <NEWLINE> x = ( x & 0x33333333 ) + ( ( x >> 2 ) & 0x33333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f <NEWLINE> x += x >> 8 <NEWLINE> x += x >> 16 <NEWLINE> return x & 0x3f <NEWLINE> <NL> <NL> <DEDENT> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n = int ( args [ 0 ] ) <NEWLINE> x = args [ 1 ] <NEWLINE> <NL> ret = [ ] <NEWLINE> dp = defaultdict ( int ) <NEWLINE> x_count = x . count ( <STRING> ) <NEWLINE> x_dec = int ( x , 2 ) <NEWLINE> <NL> x_mod_set = x_dec % ( x_count + 1 ) <NEWLINE> xor_set = 1 % ( x_count + 1 ) <NEWLINE> if 1 < x_count : <NEWLINE> <INDENT> x_mod_reset = x_dec % ( x_count - 1 ) <NEWLINE> xor_reset = 1 % ( x_count - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> bitcount = x_count + ( 1 if x [ - 1 - i ] == <STRING> else - 1 ) <NEWLINE> if bitcount == 0 : <NEWLINE> <INDENT> ret . append ( str ( 0 ) ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> m = ( x_mod_set + xor_set <NEWLINE> <INDENT> if x [ - 1 - i ] == <STRING> else <NEWLINE> x_mod_reset - xor_reset ) % bitcount <NEWLINE> <DEDENT> deq = deque ( [ m ] ) <NEWLINE> <NL> count = 1 <NEWLINE> while m : <NEWLINE> <INDENT> deq . append ( m ) <NEWLINE> if 0 < dp [ m ] : <NEWLINE> <INDENT> count += dp [ m ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> m = m % popcount ( m ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> ret . append ( str ( count ) ) <NEWLINE> <NL> while deq : <NEWLINE> <INDENT> dp [ deq . popleft ( ) ] = count <NEWLINE> count -= 1 <NEWLINE> <NL> <DEDENT> xor_set = ( xor_set << 1 ) % ( x_count + 1 ) <NEWLINE> if 1 < x_count : <NEWLINE> <INDENT> xor_reset = ( xor_reset << 1 ) % ( x_count - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> . join ( ret [ : : - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
<NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t = a [ i ] <NEWLINE> li [ t - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in D : <NEWLINE> <INDENT> D [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = max ( D . values ( ) ) <NEWLINE> for k , v in sorted ( D . items ( ) ) : <NEWLINE> <INDENT> if v == m : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT>
from math import log <NEWLINE> mod = int ( 1e9 ) + 7 <NEWLINE> n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> <NL> def sign ( v ) : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 if v > 0 else - 1 <NEWLINE> <NL> <DEDENT> pref = [ ( 0 , 1 ) ] * ( n + 1 ) <NEWLINE> suf = [ ( 0 , 1 ) ] * ( n + 1 ) <NEWLINE> <NL> c = 1 <NEWLINE> sm = 0 <NEWLINE> sgn = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> c = c * a [ j ] % mod <NEWLINE> sgn *= sign ( a [ j ] ) <NEWLINE> if a [ j ] != 0 : <NEWLINE> <INDENT> sm += log ( abs ( a [ j ] ) ) <NEWLINE> <DEDENT> pref [ j + 1 ] = ( sgn * sm , c , sgn ) <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> sm = 0 <NEWLINE> sgn = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> c = c * a [ n - j - 1 ] % mod <NEWLINE> sgn *= sign ( a [ n - j - 1 ] ) <NEWLINE> if a [ n - j - 1 ] != 0 : <NEWLINE> <INDENT> sm += log ( abs ( a [ n - j - 1 ] ) ) <NEWLINE> <DEDENT> suf [ j + 1 ] = ( sgn * sm , c , sgn ) <NEWLINE> <NL> <DEDENT> m = max ( pref [ k ] , suf [ k ] ) <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> sgn = pref [ i ] [ 2 ] * suf [ k - i ] [ 2 ] <NEWLINE> pm = pref [ i ] [ 1 ] * suf [ k - i ] [ 1 ] % mod <NEWLINE> sm = abs ( pref [ i ] [ 0 ] ) + abs ( suf [ k - i ] [ 0 ] ) <NEWLINE> m = max ( m , ( sgn * sm , pm , sgn ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( m [ 1 ] ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> absolute = list ( map ( lambda i : abs ( i - x ) , p ) ) <NEWLINE> if 0 not in absolute : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ab = set ( p ) <NEWLINE> i = 1 <NEWLINE> while i < 100 : <NEWLINE> <INDENT> if absolute . count ( i ) == 2 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> opt = set ( [ x - i , x + i ] ) <NEWLINE> ans = opt - ab <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += ( gcd ( i , gcd ( j , l ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> visited = [ False for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif cnt >= N : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif visited [ i ] : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ i ] = True <NEWLINE> cnt += 1 <NEWLINE> i = d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> from typing import List , NoReturn , Tuple <NEWLINE> <NL> <NL> def main ( ) -> NoReturn : <NEWLINE> <INDENT> n : int = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> group : int = math . ceil ( math . log ( 0.9615384615384616 * n + 1 , 26 ) ) <NEWLINE> in_group_index : int = n - 1 - ( 26 * ( 26 ** ( group - 1 ) - 1 ) ) // 25 <NEWLINE> <NL> alphabet_num : List [ int ] = [ ] <NEWLINE> alphabet : str = <STRING> <NEWLINE> temp = in_group_index <NEWLINE> for i in range ( group - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> alphabet_num . append ( temp // 26 ** i ) <NEWLINE> temp %= 26 ** i <NEWLINE> <DEDENT> name_chars : List [ str ] = [ alphabet [ i ] for i in alphabet_num ] <NEWLINE> print ( <STRING> . join ( name_chars ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> k = int ( x , 2 ) <NEWLINE> c = x . count ( <STRING> ) <NEWLINE> kp = k % ( c + 1 ) <NEWLINE> if c > 1 : <NEWLINE> <INDENT> kn = k % ( c - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> mod = c - 1 <NEWLINE> tmp = ( kn - pow ( 2 , n - i - 1 , mod ) ) % mod <NEWLINE> while 1 : <NEWLINE> <INDENT> if tmp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = tmp % format ( tmp , <STRING> ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mod = c + 1 <NEWLINE> tmp = ( kp + pow ( 2 , n - i - 1 , mod ) ) % mod <NEWLINE> while 1 : <NEWLINE> <INDENT> if tmp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = tmp % format ( tmp , <STRING> ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> def f ( A , N , K ) : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> I = ( np . abs ( A ) ) . argsort ( ) <NEWLINE> A = A [ I ] [ : : - 1 ] <NEWLINE> if N == K : <NEWLINE> <INDENT> return A <NEWLINE> <COMMENT> <NL> <DEDENT> if np . all ( A < 0 ) : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> return A [ : K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return A [ - K : ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> pos = A [ A >= 0 ] <NEWLINE> neg = A [ A < 0 ] <NEWLINE> nums = [ 1 ] <NEWLINE> if K & 1 : <NEWLINE> <INDENT> nums = [ pos [ 0 ] ] <NEWLINE> pos = pos [ 1 : ] <NEWLINE> K -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if len ( pos ) & 1 : <NEWLINE> <INDENT> pos = pos [ : - 1 ] <NEWLINE> <DEDENT> if len ( neg ) & 1 : <NEWLINE> <INDENT> neg = neg [ : - 1 ] <NEWLINE> <DEDENT> pos = pos [ : : 2 ] * pos [ 1 : : 2 ] <NEWLINE> neg = neg [ : : 2 ] * neg [ 1 : : 2 ] <NEWLINE> A = np . concatenate ( [ pos , neg ] ) <NEWLINE> A . sort ( ) <NEWLINE> A = A [ : : - 1 ] <NEWLINE> return np . concatenate ( [ nums , A [ : K // 2 ] ] ) <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> B = f ( A , N , K ) . tolist ( ) <NEWLINE> ans = 1 <NEWLINE> for x in B : <NEWLINE> <INDENT> ans = ans * x % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> import numpy as np <NEWLINE> import scipy . sparse . csgraph as csg <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ST = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> <COMMENT> <NL> A = np . array ( [ [ inf ] * N ] * N ) <NEWLINE> for a , b , c in ABC : <NEWLINE> <INDENT> A [ a - 1 ] [ b - 1 ] = c <NEWLINE> A [ b - 1 ] [ a - 1 ] = c <NEWLINE> <DEDENT> A = csg . floyd_warshall ( A ) <NEWLINE> <NL> <COMMENT> <NL> B = np . array ( [ [ inf ] * N ] * N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if A [ i ] [ j ] <= L : <NEWLINE> <INDENT> B [ i ] [ j ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> B = csg . floyd_warshall ( B ) <NEWLINE> <NL> for s , t in ST : <NEWLINE> <INDENT> if B [ s - 1 ] [ t - 1 ] == inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( B [ s - 1 ] [ t - 1 ] - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def S ( ) : <NEWLINE> <INDENT> return input ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def MI ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> H , W , M = MI ( ) <NEWLINE> <NL> R = np . zeros ( H + 1 ) <NEWLINE> C = np . zeros ( W + 1 ) <NEWLINE> bombs = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = MI ( ) <NEWLINE> bombs . append ( ( h , w ) ) <NEWLINE> R [ h ] += 1 <NEWLINE> C [ w ] += 1 <NEWLINE> <NL> <DEDENT> R_max = [ R == max ( R ) ] <NEWLINE> ans = max ( R ) + max ( C ) <NEWLINE> C_max = [ C == max ( C ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for h , w in bombs : <NEWLINE> <INDENT> if R_max [ 0 ] [ h ] and C_max [ 0 ] [ w ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == np . count_nonzero ( R_max ) * np . count_nonzero ( C_max ) : <NEWLINE> <INDENT> print ( int ( ans - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ans ) ) <NEWLINE> <DEDENT>
T = str ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> cc = [ ] <NEWLINE> count = len ( T ) <NEWLINE> for i in T : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> cc . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> cc . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count == i : <NEWLINE> <INDENT> cc . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif cnt == 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> cc . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> cc . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ccc = 1 <NEWLINE> for i in cc : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ccc == len ( cc ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif cc [ ccc ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> ccc += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) + [ 0 ] <NEWLINE> <NL> memo = [ <STRING> ] * ( 10 ** 6 + 1 ) <NEWLINE> mx = max ( A ) + 1 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if memo [ A [ i ] ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( A [ i ] , mx , A [ i ] ) : <NEWLINE> <INDENT> memo [ j ] = <STRING> <NEWLINE> <DEDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> d = sum ( c ) <NEWLINE> e = 0 <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> e = e + c [ - i ] <NEWLINE> <DEDENT> print ( d - e ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += li [ 0 ] * li [ i ] <NEWLINE> <NL> <DEDENT> check = ans <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if li [ i - 1 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> check -= li [ i ] * li [ i - 1 ] <NEWLINE> check //= li [ i - 1 ] <NEWLINE> check *= li [ i ] <NEWLINE> ans += check <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> <NL> <NL> def SelectionSort ( arr , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> mini = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if arr [ j ] [ <STRING> ] < arr [ mini ] [ <STRING> ] : <NEWLINE> <INDENT> mini = j <NEWLINE> <DEDENT> <DEDENT> if mini != i : <NEWLINE> <INDENT> arr [ i ] , arr [ mini ] = arr [ mini ] , arr [ i ] <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def BubleSort ( arr , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if arr [ j ] [ <STRING> ] < arr [ j - 1 ] [ <STRING> ] : <NEWLINE> <INDENT> arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def isStable ( inarr , comparr , n ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> tmpVal = comparr [ i ] [ <STRING> ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if inarr [ j ] [ <STRING> ] == tmpVal : <NEWLINE> <INDENT> if inarr [ j ] [ <STRING> ] == comparr [ i ] [ <STRING> ] : <NEWLINE> <INDENT> if i != n - 1 and comparr [ i + 1 ] [ <STRING> ] == tmpVal : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = input ( ) . split ( ) <NEWLINE> tar = [ ] <NEWLINE> <NL> for s in arr : <NEWLINE> <INDENT> tar . append ( { <STRING> : s [ 0 ] , <STRING> : s [ 1 ] , <STRING> : s } ) <NEWLINE> <NL> <DEDENT> bub = copy . copy ( tar ) <NEWLINE> BubleSort ( bub , n ) <NEWLINE> <NL> prt = [ ] <NEWLINE> for s in bub : <NEWLINE> <INDENT> prt . append ( s [ <STRING> ] ) <NEWLINE> <DEDENT> print ( * prt ) <NEWLINE> print ( isStable ( tar , bub , n ) ) <NEWLINE> <NL> bub = copy . copy ( tar ) <NEWLINE> SelectionSort ( bub , n ) <NEWLINE> <NL> prt = [ ] <NEWLINE> for s in bub : <NEWLINE> <INDENT> prt . append ( s [ <STRING> ] ) <NEWLINE> <DEDENT> print ( * prt ) <NEWLINE> print ( isStable ( tar , bub , n ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> wa = 0 <NEWLINE> m = 0 <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = max ( l [ i ] , m ) <NEWLINE> if m > l [ i ] : <NEWLINE> <INDENT> wa += m - l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( wa ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in As : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= As [ i ] <NEWLINE> if ans > int ( 1e18 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans <= int ( 1e18 ) else - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> check = [ 0 ] * 1000001 <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if check [ A [ i ] ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i == N - 1 or A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> for j in range ( A [ i ] , 1000001 , A [ i ] ) : <NEWLINE> <INDENT> check [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] + a [ i - 1 ] <NEWLINE> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b [ j ] = b [ j ] + b [ j - 1 ] <NEWLINE> <NL> <DEDENT> book_cnt = 0 <NEWLINE> for a_cnt in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ a_cnt ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rest = k - a [ a_cnt ] <NEWLINE> b_cnt = bisect . bisect ( b , rest ) - 1 <NEWLINE> book_cnt = max ( book_cnt , a_cnt + b_cnt ) <NEWLINE> <NL> <DEDENT> print ( book_cnt ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> ans = - 1 <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif K % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 7 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if num % K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( num * 10 + 7 ) % K <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> num = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> num -= A [ i ] <NEWLINE> ans += A [ i ] * num <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> thresh = 10 ** 18 <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > thresh : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> midList = [ 0 ] * ( N - 1 ) <NEWLINE> mid = 0 <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> mid += List [ i + 1 ] <NEWLINE> midList [ i ] = mid <NEWLINE> <DEDENT> res = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = List [ i ] % 1000000007 <NEWLINE> b = midList [ i ] % 1000000007 <NEWLINE> res += a * b <NEWLINE> <DEDENT> print ( res % 1000000007 ) <NEWLINE>
a = input ( ) <NEWLINE> if a . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ct = [ 0 ] * N <NEWLINE> cost = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ct [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ct [ i ] [ 1 ] <= T : <NEWLINE> <INDENT> cost . append ( ct [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if cost == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( cost ) ) <NEWLINE> <DEDENT>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if k > a : <NEWLINE> <INDENT> ans = a * 1 <NEWLINE> k = k - a <NEWLINE> if k > b : <NEWLINE> <INDENT> ans += b * 0 <NEWLINE> k = k - b <NEWLINE> ans += k * - 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif k <= b : <NEWLINE> <INDENT> ans += k * 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> elif k <= a : <NEWLINE> <INDENT> ans = k * 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys , math , collections , itertools , heapq <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> under = 0 <NEWLINE> upper = max ( A ) <NEWLINE> num = upper // 2 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans += math . ceil ( a / num ) - 1 <NEWLINE> <DEDENT> if ans > K : <NEWLINE> <INDENT> under = num <NEWLINE> num = math . ceil ( ( num + upper ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> upper = num <NEWLINE> num = math . floor ( ( num + under ) / 2 ) <NEWLINE> <DEDENT> if upper - under == 1 : <NEWLINE> <INDENT> print ( upper ) <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> from itertools import product <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> c = tuple ( map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) ) <NEWLINE> d = tuple ( map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) ) <NEWLINE> s = [ <STRING> * ( w + 4 ) ] * 2 + [ <STRING> for _ in range ( h ) ] + [ <STRING> * ( w + 4 ) ] * 2 <NEWLINE> <NL> move_a_area = [ ( 0 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) ] <NEWLINE> move_b_area = [ ( i , j ) for i , j in product ( range ( - 2 , 3 ) , repeat = 2 ) if ( i , j ) not in [ ( 0 , 0 ) ] + move_a_area ] <NEWLINE> <NL> cost = [ [ float ( <STRING> ) ] * ( w + 4 ) for _ in range ( h + 4 ) ] <NEWLINE> cost [ c [ 0 ] ] [ c [ 1 ] ] = 0 <NEWLINE> yet = deque ( [ ( c [ 0 ] , c [ 1 ] , 0 ) ] ) <NEWLINE> done = deque ( ) <NEWLINE> <NL> while yet : <NEWLINE> <INDENT> y , x , m = yet . popleft ( ) <NEWLINE> done . append ( ( y , x , m ) ) <NEWLINE> <COMMENT> <NL> for dx , dy in move_a_area : <NEWLINE> <INDENT> hh , ww = y + dy , x + dx <NEWLINE> if s [ hh ] [ ww ] == <STRING> or cost [ hh ] [ ww ] <= m : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost [ hh ] [ ww ] = m <NEWLINE> yet . append ( ( hh , ww , m ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if not yet : <NEWLINE> <INDENT> while done : <NEWLINE> <INDENT> y , x , m = done . popleft ( ) <NEWLINE> for dx , dy in move_b_area : <NEWLINE> <INDENT> hh , ww = y + dy , x + dx <NEWLINE> if s [ hh ] [ ww ] == <STRING> or cost [ hh ] [ ww ] <= m + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost [ hh ] [ ww ] = m + 1 <NEWLINE> yet . append ( ( hh , ww , m + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( v if ( v : = cost [ d [ 0 ] ] [ d [ 1 ] ] ) < float ( <STRING> ) else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = [ list ( map ( int , input ( ) . split ( ) ) ) for r in range ( n ) ] , [ list ( map ( int , input ( ) . split ( ) ) ) for r in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> Cij = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> Cij += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> if j < l - 1 : <NEWLINE> <INDENT> print ( <STRING> % ( Cij ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( Cij ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> print ( sum ( A [ : n // 2 ] ) * 2 - A [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( A [ : n // 2 ] ) * 2 - A [ 0 ] + A [ n // 2 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> FB = [ 0 ] * N <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> FB [ i - 1 ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( FB ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ans = list ( s ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ set ( [ ] ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> g [ a ] . add ( b ) <NEWLINE> <NL> <DEDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s , t = s - 1 , t - 1 <NEWLINE> <NL> <COMMENT> <NL> q = deque ( ) <NEWLINE> level = [ [ - 1 ] * n for i in range ( 3 ) ] <NEWLINE> q . append ( ( s , 0 ) ) <NEWLINE> level [ 0 ] [ s ] = 0 <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> cur , hp = q . popleft ( ) <NEWLINE> lvl = level [ hp ] [ cur ] <NEWLINE> for i in g [ cur ] : <NEWLINE> <INDENT> if level [ ( hp + 1 ) % 3 ] [ i ] == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> level [ ( hp + 1 ) % 3 ] [ i ] = lvl + 1 <NEWLINE> q . append ( ( i , ( hp + 1 ) % 3 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( level [ 0 ] [ t ] // 3 ) <NEWLINE>
a_s , b_s = input ( ) . split ( ) <NEWLINE> <NL> b_s = b_s . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> s = str ( int ( a_s ) * int ( b_s ) ) <NEWLINE> if len ( s ) > 2 : <NEWLINE> <INDENT> print ( str ( int ( a_s ) * int ( b_s ) ) [ : - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
INF = 10 ** 30 <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def bellman_ford ( s , t , g ) : <NEWLINE> <INDENT> d = [ INF for _ in range ( n ) ] <COMMENT> <NEWLINE> d [ s ] = 0 <COMMENT> <NEWLINE> val_at_t = INF <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> for x , y , z in g : <NEWLINE> <INDENT> if d [ y ] > d [ x ] + z : <NEWLINE> <INDENT> d [ y ] = d [ x ] + z <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if i == n - 1 and val_at_t > d [ t ] : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> val_at_t = d [ t ] <COMMENT> <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> g = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> z *= - 1 <NEWLINE> g . append ( [ x , y , z ] ) <NEWLINE> <NL> <DEDENT> ans = bellman_ford ( 0 , n - 1 , g ) <NEWLINE> <COMMENT> <NL> print ( - ans [ n - 1 ] if ans else <STRING> ) <NEWLINE>
h , a , * m = open ( 0 ) <NEWLINE> h , w , k , a , b , f , g = map ( int , ( h + a ) . split ( ) ) <NEWLINE> d = [ I : = h * w ] * I <NEWLINE> m += d , <NEWLINE> a = ~ w + a * w + b <NEWLINE> d [ a ] = 1 <NEWLINE> q = [ a ] <NEWLINE> for s in q : <NEWLINE> <INDENT> for y , x in ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) : <NEWLINE> <INDENT> for z in range ( k ) : <NEWLINE> <INDENT> i , j = s // w + y * ~ z , s % w + x * ~ z ; t = i * w + j ; p = d [ s ] + 1 <NEWLINE> if <STRING> != m [ i ] [ j ] or d [ t ] < p : break <NEWLINE> if d [ t ] > p : q += t , ; d [ t ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d [ ~ w + f * w + g ] % I - 1 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> q = list ( ) <NEWLINE> for i in range ( 1009 ) : <NEWLINE> <INDENT> if int ( i * 0.08 ) == a and int ( i * 0.1 ) == b : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( q ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( min ( q ) ) <NEWLINE>
import numpy as np <NEWLINE> Num = np . zeros ( ( 3 , 3 ) , dtype = int ) <NEWLINE> Flag = False <NEWLINE> for T in range ( 0 , 3 ) : <NEWLINE> <INDENT> Num [ T , : ] = np . array ( [ int ( X ) for X in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> for T in range ( 0 , 3 ) : <NEWLINE> <INDENT> Num [ : , T ] -= Num [ 0 , T ] <NEWLINE> <DEDENT> for A2 in range ( min ( Num [ 1 , : ] ) , max ( Num [ 1 , : ] ) + 1 ) : <NEWLINE> <INDENT> AB2 = np . array ( [ A2 + Num [ 0 , 0 ] , A2 + Num [ 0 , 1 ] , A2 + Num [ 0 , 2 ] ] ) <NEWLINE> if np . all ( AB2 == Num [ 1 , : ] ) : <NEWLINE> <INDENT> for A3 in range ( min ( Num [ 2 , : ] ) , max ( Num [ 2 , : ] ) + 1 ) : <NEWLINE> <INDENT> AB3 = np . array ( [ A3 + Num [ 0 , 0 ] , A3 + Num [ 0 , 1 ] , A3 + Num [ 0 , 2 ] ] ) <NEWLINE> if np . all ( AB3 == Num [ 2 , : ] ) : <NEWLINE> <INDENT> Flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = math . floor ( a * min ( ( b - 1 ) , n ) / b ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> nr = s . count ( <STRING> ) <NEWLINE> ng = s . count ( <STRING> ) <NEWLINE> nb = s . count ( <STRING> ) <NEWLINE> <NL> count = nr * ng * nb <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( n + i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : continue <NEWLINE> else : <NEWLINE> <INDENT> k = 2 * j - i <COMMENT> <NEWLINE> if s [ i ] == s [ k ] : continue <NEWLINE> if s [ j ] == s [ k ] : continue <NEWLINE> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> num = ord ( s [ i ] ) + n <NEWLINE> if num > 90 : <NEWLINE> <INDENT> num -= 26 <NEWLINE> <DEDENT> ans . append ( chr ( num ) ) <NEWLINE> <DEDENT> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> score = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> score += A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> pre = score <NEWLINE> score -= A [ i - K ] <NEWLINE> score += A [ i ] <NEWLINE> if score > pre : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ct = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> ct += 1 <NEWLINE> if ct == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ct = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> before_ = - 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> if dp [ i ] == False : <NEWLINE> <INDENT> for j in range ( 2 * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] = True <NEWLINE> <DEDENT> <DEDENT> if before_ == i : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> <DEDENT> before_ = i <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> if dp [ i ] == False : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> queue = deque ( [ ] ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> commands = input ( ) . split ( <STRING> ) <NEWLINE> command = commands [ 0 ] <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> queue . appendleft ( commands [ 1 ] ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> queue . remove ( commands [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> queue . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> queue . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> last = queue . pop ( ) <NEWLINE> for i in queue : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( last ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( l ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
def insertion_sort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shell_sort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = [ ] <NEWLINE> h = 1 <NEWLINE> while h <= n : <NEWLINE> <INDENT> G . append ( h ) <NEWLINE> h = h * 3 + 1 <NEWLINE> <DEDENT> m = len ( G ) <NEWLINE> G = G [ : : - 1 ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> cnt = insertion_sort ( A , n , G [ i ] , cnt ) <NEWLINE> <NL> <DEDENT> return m , G , cnt <NEWLINE> <NL> <DEDENT> data = [ ] <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> data . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> m , G , cnt = shell_sort ( data , len ( data ) ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> for i in data : print ( i ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ct = 0 <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] != t [ i ] ) : <NEWLINE> <NL> <INDENT> ct = ct + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ct ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ok = 0 <NEWLINE> ng = 10 ** 9 <NEWLINE> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> cur = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cur += L [ i ] // mid <NEWLINE> <DEDENT> if cur > k : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> elif cur <= k : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> K = [ mid - 1 , mid , mid + 1 ] <NEWLINE> P = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> if K [ i ] > 0 : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> res += ( L [ j ] - 1 ) // K [ i ] <NEWLINE> <DEDENT> if res <= k : <NEWLINE> <INDENT> P . append ( K [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min ( P ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve = [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> maxnum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> maxnum = max ( maxnum , an [ i ] ) <NEWLINE> ans += maxnum - an [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = sorted ( b ) <NEWLINE> c = sorted ( c ) <NEWLINE> <NL> from bisect import bisect_right <NEWLINE> <NL> d = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> index = bisect_right ( c , b [ i ] ) <NEWLINE> <NL> d . append ( n - index ) <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> s = sum ( d ) <NEWLINE> cum = np . cumsum ( d ) <NEWLINE> <NL> ans = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> dex = bisect_right ( b , a [ j ] ) <NEWLINE> if dex == 0 : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> elif dex == n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s - cum [ dex - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> max_len = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> while j < n and s [ i : j ] in s [ j : ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> max_len = max ( max_len , j - i - 1 ) <NEWLINE> <NL> <DEDENT> print ( max_len ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from itertools import product <NEWLINE> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> n5 = [ i ** 5 for i in range ( 1000 ) ] <NEWLINE> c = product ( n5 , repeat = 2 ) <NEWLINE> for ce in c : <NEWLINE> <INDENT> if ce [ 0 ] + ce [ 1 ] == x : <NEWLINE> <INDENT> r = ( int ( ce [ 0 ] ** 0.2 ) , int ( ce [ 1 ] ** 0.2 ) * - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ce [ 0 ] - ce [ 1 ] == x : <NEWLINE> <INDENT> r = ( int ( ce [ 0 ] ** 0.2 ) , int ( ce [ 1 ] ** 0.2 ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( * r , sep = <STRING> ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N < B : <NEWLINE> <INDENT> ans = int ( A * N / B ) - A * int ( N / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( ( B - 1 ) / B * A ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( ( a * x ) // b - a * ( x // b ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( input ( ) ) <NEWLINE> bit_cnt = x . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> pos = [ 0 ] * n <NEWLINE> pos_total = 0 <NEWLINE> <NL> <COMMENT> <NL> neg = [ 0 ] * n <NEWLINE> neg_total = 0 <NEWLINE> <NL> base = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pos [ - i - 1 ] = base % ( bit_cnt + 1 ) <NEWLINE> if x [ - i - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> pos_total = ( pos_total + base ) % ( bit_cnt + 1 ) <NEWLINE> <DEDENT> base = ( base * 2 ) % ( bit_cnt + 1 ) <NEWLINE> <NL> <DEDENT> base = 1 <NEWLINE> if bit_cnt == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> neg [ - i - 1 ] = base % ( bit_cnt - 1 ) <NEWLINE> if x [ - i - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> neg_total = ( neg_total + base ) % ( bit_cnt - 1 ) <NEWLINE> <DEDENT> base = ( base * 2 ) % ( bit_cnt - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def popcount ( n ) : <NEWLINE> <INDENT> s = list ( bin ( n ) [ 2 : ] ) <NEWLINE> return s . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> memo = { } <NEWLINE> memo [ 0 ] = 0 <NEWLINE> def dfs ( n , depth = 0 ) : <NEWLINE> <INDENT> if n in memo : <NEWLINE> <INDENT> return depth + memo [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = dfs ( n % popcount ( n ) , depth + 1 ) <NEWLINE> <COMMENT> <NL> return ret <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> st = ( pos_total + pos [ i ] ) % ( bit_cnt + 1 ) <NEWLINE> print ( dfs ( st , depth = 1 ) ) <NEWLINE> <DEDENT> elif bit_cnt == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st = ( neg_total - neg [ i ] ) % ( bit_cnt - 1 ) <NEWLINE> print ( dfs ( st , depth = 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
def f ( x ) : return 1 if x < 2 else x * f ( x - 1 ) <NEWLINE> print ( f ( int ( input ( ) ) ) ) <NEWLINE>
<COMMENT> <NL> r = float ( input ( ) . strip ( ) ) <NEWLINE> p = 3.141592653589793238 <NEWLINE> m = r * r * p <NEWLINE> l = 2 * r * p <NEWLINE> print ( <STRING> . format ( m , l ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Stlist = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> breakstair = int ( input ( ) ) <NEWLINE> Stlist [ breakstair - 1 ] = 0 <NEWLINE> <DEDENT> Comb = [ 1 , 2 ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> Comb = Stlist <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Stlist [ 0 ] == 0 : <NEWLINE> <INDENT> Comb [ 0 ] = 0 <NEWLINE> Comb [ 1 ] = 1 <NEWLINE> <DEDENT> if Stlist [ 1 ] == 0 : <NEWLINE> <INDENT> Comb [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> Comb . append ( ( Comb [ i - 1 ] + Comb [ i - 2 ] ) % ( 10 ** 9 + 7 ) ) <NEWLINE> if Stlist [ i ] == 0 : <NEWLINE> <INDENT> Comb [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( Comb [ - 1 ] ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> blst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> asum = [ 0 ] <NEWLINE> bsum = [ 0 ] <NEWLINE> <NL> for i , new in enumerate ( alst ) : <NEWLINE> <INDENT> if asum [ i ] + new <= k : <NEWLINE> <INDENT> asum . append ( asum [ i ] + new ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i , new in enumerate ( blst ) : <NEWLINE> <INDENT> if bsum [ i ] + new <= k : <NEWLINE> <INDENT> bsum . append ( bsum [ i ] + new ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> bmax = len ( bsum ) - 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for i , atime in enumerate ( asum ) : <NEWLINE> <INDENT> while atime + bsum [ bmax ] > k : <NEWLINE> <INDENT> bmax -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + bmax ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import bisect as bi <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ i for i in range ( 102 ) ] <NEWLINE> <NL> <COMMENT> <NL> C = list ( set ( B ) - set ( A ) ) <NEWLINE> <NL> <COMMENT> <NL> ind = bi . bisect_left ( C , x ) <NEWLINE> <NL> if ind == 0 : <NEWLINE> <INDENT> print ( C [ 0 ] ) <NEWLINE> <DEDENT> elif ind == x - n : <NEWLINE> <INDENT> print ( C [ ind ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_l = abs ( C [ ind - 1 ] - x ) <NEWLINE> tmp_r = abs ( C [ ind ] - x ) <NEWLINE> if tmp_l > tmp_r : <NEWLINE> <INDENT> print ( C [ ind ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C [ ind - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = 4 <NEWLINE> a = [ 1 , 2 , 3 , 4 ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> y = [ a [ j ] for j in range ( 1 , n , 2 ) ] [ : : - 1 ] <NEWLINE> z = [ a [ j ] for j in range ( 0 , n , 2 ) ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> y = [ a [ j ] for j in range ( 0 , n , 2 ) ] [ : : - 1 ] <NEWLINE> z = [ a [ j ] for j in range ( 1 , n , 2 ) ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , y + z ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> money = 100 <NEWLINE> year = 0 <NEWLINE> <NL> while ( money < x ) : <NEWLINE> <INDENT> year += 1 <NEWLINE> money += money // 100 <NEWLINE> <NL> <DEDENT> print ( year ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def I2 ( ) : return map ( int , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> def S ( ) : return str ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def L ( ) : return list ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def Intl ( ) : return [ int ( k ) for k in sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ] <NEWLINE> def Lx ( k ) : return list ( map ( lambda x : int ( x ) * - k , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> n = I ( ) <NEWLINE> a = Intl ( ) <NEWLINE> s = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s *= a [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == c : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - c + 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> alp = <STRING> <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> e = { } <NEWLINE> for i in range ( len ( alp ) ) : <NEWLINE> <INDENT> d [ alp [ i ] ] = i <NEWLINE> e [ i ] = alp [ i ] <NEWLINE> <NL> <DEDENT> n = len ( s ) <NEWLINE> if n != 26 : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( d [ s [ i ] ] ) <NEWLINE> <NL> <DEDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> if j not in ans : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> st = <STRING> <NEWLINE> for k in ans : <NEWLINE> <INDENT> st += e [ k ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> <NL> dp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp . append ( d [ s [ i ] ] ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> v = dp . pop ( ) <NEWLINE> <NL> tmp = [ j for j in arr if j > v ] <NEWLINE> if len ( tmp ) != 0 : <NEWLINE> <INDENT> dp . append ( min ( tmp ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> arr . append ( v ) <NEWLINE> <NL> <DEDENT> st = <STRING> <NEWLINE> for k in dp : <NEWLINE> <INDENT> st += e [ k ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( st ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> min_list = deque ( [ A [ 1 ] , A [ 1 ] ] ) <NEWLINE> ans = A [ 0 ] <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += min_list . popleft ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> min_list . append ( A [ i ] ) <NEWLINE> min_list . append ( A [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list = np . array ( input ( ) . split ( ) ) . astype ( int ) <NEWLINE> b_list = np . array ( input ( ) . split ( ) ) . astype ( int ) <NEWLINE> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ - 1 ] + a_list [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ - 1 ] + b_list [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> total = 0 <NEWLINE> num = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <NL> <INDENT> if a_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( k - a_sum [ i ] ) < b_sum [ num ] : <NEWLINE> <INDENT> num -= 1 <NEWLINE> <COMMENT> <NL> if num == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> total = max ( i + num , total ) <NEWLINE> <NL> <NL> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> cnt = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> sub = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= n - 1 : <NEWLINE> <INDENT> if ( s [ i ] != s [ j ] ) and ( s [ j ] != s [ k ] ) and ( s [ i ] != s [ k ] ) : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt - sub ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a * d , a * c , b * c , b * d ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> kabu = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] and kabu == 0 : <NEWLINE> <INDENT> kabu = money // A [ i ] <NEWLINE> money = money - kabu * A [ i ] <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] and kabu > 0 : <NEWLINE> <INDENT> money = money + kabu * A [ i ] <NEWLINE> kabu = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if kabu > 0 : <NEWLINE> <INDENT> print ( money + kabu * A [ N - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( money ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> ps = int ( A / K ) <NEWLINE> pa = A % K <NEWLINE> qs = int ( B / K ) <NEWLINE> qa = B % K <NEWLINE> <NL> if A == B : <NEWLINE> <INDENT> if pa == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if qs - ps > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if pa == 0 or qa == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = sorted ( A ) <NEWLINE> maxA = max ( A ) <NEWLINE> ans = 0 <NEWLINE> so_list = [ 1 ] * ( maxA + 1 ) <NEWLINE> index = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while ( i < N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> now = A [ i ] <NEWLINE> if so_list [ now ] == 1 : <NEWLINE> <INDENT> index = 0 <NEWLINE> flag = 1 <NEWLINE> while ( index + now <= maxA ) : <NEWLINE> <INDENT> so_list [ index + now ] = 0 <NEWLINE> index += now <NEWLINE> <DEDENT> <DEDENT> right = bisect . bisect_right ( A , now ) <COMMENT> <NEWLINE> if right - i == 1 : <NEWLINE> <INDENT> if flag == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> i = right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> reg = A [ 0 ] <NEWLINE> flg = True <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flg = False <NEWLINE> reg = 0 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> reg *= A [ i ] <NEWLINE> if reg > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( reg ) <NEWLINE> <DEDENT>
from itertools import * <NEWLINE> from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> if gcd ( k , 10 ) == 1 : <NEWLINE> <INDENT> i = 0 <NEWLINE> r = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> r = ( 10 * r + 7 ) % k <NEWLINE> if r == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s_count = [ 0 ] * 26 <NEWLINE> t_count = [ 0 ] * 26 <NEWLINE> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> s_count [ i - 97 ] = s . count ( chr ( i ) ) <NEWLINE> t_count [ i - 97 ] = t . count ( chr ( i ) ) <NEWLINE> <DEDENT> s_count . sort ( ) <NEWLINE> t_count . sort ( ) <NEWLINE> if s_count == t_count : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> sum *= a [ i ] <NEWLINE> if ( sum > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
rc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ [ 0 for x in range ( rc [ 1 ] + 1 ) ] for x in range ( rc [ 0 ] + 1 ) ] <NEWLINE> for x in range ( rc [ 0 ] ) : <NEWLINE> <INDENT> code = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 0 <NEWLINE> for y in range ( rc [ 1 ] ) : <NEWLINE> <INDENT> a [ x ] [ y ] = code [ y ] <NEWLINE> result += code [ y ] <NEWLINE> <DEDENT> a [ x ] [ rc [ 1 ] ] = result <NEWLINE> <NL> <DEDENT> for y in range ( rc [ 1 ] + 1 ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for x in range ( rc [ 0 ] ) : <NEWLINE> <INDENT> result += a [ x ] [ y ] <NEWLINE> <DEDENT> a [ rc [ 0 ] ] [ y ] = result <NEWLINE> <NL> <DEDENT> for x in range ( rc [ 0 ] + 1 ) : <NEWLINE> <INDENT> string = <STRING> <NEWLINE> for y in range ( rc [ 1 ] + 1 ) : <NEWLINE> <INDENT> string += str ( a [ x ] [ y ] ) <NEWLINE> if ( y != rc [ 1 ] ) : <NEWLINE> <INDENT> string += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( string ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> near = [ [ 0 ] for i in h ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> near [ a - 1 ] . append ( h [ b - 1 ] ) <NEWLINE> near [ b - 1 ] . append ( h [ a - 1 ] ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if max ( near [ i ] ) < h [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> inputs = tuple ( tuple ( input ( ) ) for _ in range ( N ) ) <NEWLINE> <NL> dic = { <NEWLINE> <INDENT> <STRING> : A , <NEWLINE> <STRING> : B , <NEWLINE> <STRING> : C <NEWLINE> <DEDENT> } <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> depth = 0 <NEWLINE> while depth < N : <NEWLINE> <INDENT> key1 , key2 = inputs [ depth ] <NEWLINE> if dic [ key1 ] < dic [ key2 ] : <NEWLINE> <INDENT> dic [ key1 ] += 1 <NEWLINE> dic [ key2 ] -= 1 <NEWLINE> ans [ depth ] = key1 <NEWLINE> <DEDENT> elif dic [ key1 ] > dic [ key2 ] : <NEWLINE> <INDENT> dic [ key2 ] += 1 <NEWLINE> dic [ key1 ] -= 1 <NEWLINE> ans [ depth ] = key2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not dic [ key1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif dic [ key1 ] == 1 and depth + 1 < N : <NEWLINE> <INDENT> next_key1 , next_key2 = inputs [ depth + 1 ] <NEWLINE> common_key , * _ = { key1 , key2 } & { next_key1 , next_key2 } <NEWLINE> else_key , * _ = { key1 , key2 } - { common_key } <NEWLINE> dic [ common_key ] += 1 <NEWLINE> dic [ else_key ] -= 1 <NEWLINE> ans [ depth ] = common_key <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ key1 ] += 1 <NEWLINE> dic [ key2 ] -= 1 <NEWLINE> ans [ depth ] = key1 <NEWLINE> <DEDENT> <DEDENT> depth += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
def gcd ( p , q ) : <NEWLINE> <INDENT> if p % q == 0 : <NEWLINE> <INDENT> return q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( q , p % q ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a . append ( gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in a : <NEWLINE> <INDENT> ans += gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def merge ( S , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> L = S [ left : mid ] + [ float ( <STRING> ) ] <NEWLINE> R = S [ mid : right ] + [ float ( <STRING> ) ] <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> S [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> cnt += right - left <NEWLINE> <NL> <NL> <DEDENT> def merge_sort ( S , left = 0 , right = 500000 ) : <NEWLINE> <INDENT> right = min ( len ( S ) , right ) <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( S , left , mid ) <NEWLINE> merge_sort ( S , mid , right ) <NEWLINE> merge ( S , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> cnt = 0 <NEWLINE> merge_sort ( S ) <NEWLINE> print ( * S ) <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( N ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> mod = 998244353 <NEWLINE> L = list ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ a , b ] ) <NEWLINE> <DEDENT> R = [ 0 , 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> a , b = L [ j ] <NEWLINE> if i >= b : <NEWLINE> <INDENT> dp [ i ] += R [ i - a + 1 ] - R [ i - b ] <NEWLINE> <DEDENT> elif i >= a : <NEWLINE> <INDENT> dp [ i ] += R [ i - a + 1 ] <NEWLINE> <DEDENT> dp [ i ] %= mod <NEWLINE> <DEDENT> R . append ( R [ - 1 ] + dp [ i ] ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> b = str ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += str ( a [ n - i - 1 ] ) + <STRING> <NEWLINE> <NL> <DEDENT> print ( b . strip ( ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in An : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a *= An [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a <= 10 ** 18 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> looked = min ( B - 1 , N ) <NEWLINE> ans = ( A * looked ) // B - A * ( looked // B ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def choose2 ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> inp = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> total += choose2 ( inp [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> count = total - choose2 ( inp [ a [ i ] ] ) + choose2 ( inp [ a [ i ] ] - 1 ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> cost = [ ] <NEWLINE> <NL> skill = list ( zip ( * CA ) ) <NEWLINE> <NL> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if sum ( skill [ i ] ) < X : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for balls in list ( itertools . combinations ( CA , i ) ) : <NEWLINE> <INDENT> test = np . zeros ( M + 1 ) <NEWLINE> for j in balls : <NEWLINE> <INDENT> jtest = np . asarray ( j ) <NEWLINE> test = test + jtest <NEWLINE> <NL> <DEDENT> if min ( test [ 1 : ] ) >= X : <NEWLINE> <INDENT> cost . append ( test [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( min ( cost ) ) ) <NEWLINE>
from sys import stdin <NEWLINE> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> readline = stdin . readline <NEWLINE> S = readline ( ) . strip ( ) <NEWLINE> li = [ 0 ] * 2019 <NEWLINE> n = int ( S [ - 1 ] ) % 2019 <NEWLINE> m = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m *= 10 <NEWLINE> m %= 2019 <NEWLINE> l = int ( S [ len ( S ) - i - 1 ] ) <NEWLINE> n += m * l <NEWLINE> n %= 2019 <NEWLINE> <DEDENT> li [ n ] += 1 <NEWLINE> <NL> <DEDENT> res = li [ 0 ] <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> res += li [ i ] * ( li [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = 1 <NEWLINE> Y = 1 <NEWLINE> Z = 1 <NEWLINE> <NL> a = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for x in range ( 1 , 101 , 1 ) : <NEWLINE> <INDENT> if x ** 2 + Y ** 2 + Z ** 2 + x * Y + Y * Z + Z * x > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( 1 , 101 , 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + Z ** 2 + x * y + y * Z + Z * x > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( 1 , 101 , 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= N : <NEWLINE> <INDENT> a [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ] += 1 <NEWLINE> <DEDENT> elif x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 , 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 10 ** 6 + 1 <NEWLINE> <NL> cnt = [ 0 ] * M <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if cnt [ a ] != 0 : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for b in range ( a , M , a ) : <NEWLINE> <INDENT> cnt [ b ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cnt [ a ] == 1 : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import Counter , deque <NEWLINE> <COMMENT> <NL> from itertools import combinations , permutations , accumulate , groupby , product <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> res = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if b >= c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if b >= c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if a >= c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if a >= c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a < 0 or b < 0 or c < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> if a >= c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> if c >= b : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> res . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if a >= 0 and b >= 0 and c >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ int ( x ) for x in input ( ) ] <NEWLINE> <NL> dp_1 = [ False ] * 10 <NEWLINE> dp_2 = [ False ] * 100 <NEWLINE> dp_3 = [ False ] * 1000 <NEWLINE> <NL> for x in s : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> if dp_2 [ i ] : <NEWLINE> <INDENT> dp_3 [ i * 10 + x ] = True <NEWLINE> <DEDENT> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> if dp_1 [ i ] : <NEWLINE> <INDENT> dp_2 [ i * 10 + x ] = True <NEWLINE> <DEDENT> <DEDENT> dp_1 [ x ] = True <NEWLINE> <NL> <DEDENT> print ( sum ( dp_3 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> listA = [ ] <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> listA . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> x = [ [ 0 ] * ( m + 1 ) for i in range ( 2 ** n ) ] <NEWLINE> <COMMENT> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> for l in range ( m + 1 ) : <NEWLINE> <INDENT> x [ i ] [ l ] += listA [ j ] [ l ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> cnt = 10 ** 10 <NEWLINE> t = [ k ] * ( m + 1 ) <NEWLINE> <COMMENT> <NL> f = 0 <NEWLINE> for i in x : <NEWLINE> <COMMENT> <NL> <INDENT> u = 0 <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i [ j ] < t [ j ] : <NEWLINE> <INDENT> u = 1 <NEWLINE> <DEDENT> <DEDENT> if u != 1 : <NEWLINE> <INDENT> if cnt >= i [ 0 ] : <NEWLINE> <INDENT> cnt = i [ 0 ] <NEWLINE> f = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if f != 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys , math <NEWLINE> <COMMENT> <NL> DEBUG = False <NEWLINE> if DEBUG : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = sys . stdin <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> N = int ( f . readline ( ) . strip ( ) ) <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> I = int ( math . sqrt ( N ) ) <NEWLINE> for __ in range ( I ) : <NEWLINE> <INDENT> A2 = N - ( ( __ + 1 ) ** 2 ) <NEWLINE> if A2 <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> I2 = int ( math . sqrt ( A2 ) ) <NEWLINE> for ___ in range ( I2 ) : <NEWLINE> <INDENT> A3 = A2 - ( ( ___ + 1 ) ** 2 ) <NEWLINE> if A3 <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> I3 = int ( math . sqrt ( A3 ) ) <NEWLINE> for ____ in range ( I3 ) : <NEWLINE> <INDENT> tmp = ( ( __ + ___ + 2 ) ** 2 ) + ( ( ___ + ____ + 2 ) ** 2 ) + ( ( __ + ____ + 2 ) ** 2 ) <NEWLINE> if tmp <= 2 * N : <NEWLINE> <INDENT> ans [ int ( tmp / 2 ) - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> print ( ans [ _ ] ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n < ( N + 1 ) : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> p_K = 1 <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> t = A [ i ] / A [ i - K ] <NEWLINE> p_Kp1 = p_K * t <NEWLINE> if p_K < p_Kp1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k >= a : <NEWLINE> <INDENT> r = k - a <NEWLINE> if r >= b : <NEWLINE> <INDENT> r = r - b <NEWLINE> print ( a - r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer = [ ] <NEWLINE> <COMMENT> <NL> size = 1 <NEWLINE> <NL> while size < n : <NEWLINE> <INDENT> size *= 2 <NEWLINE> <NL> <DEDENT> size = size * 2 - 1 <NEWLINE> <NL> segtree = [ 0 for x in range ( size ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def update ( i , x ) : <NEWLINE> <INDENT> ind = size // 2 + i <NEWLINE> segtree [ ind ] += x <NEWLINE> <NL> while ind : <NEWLINE> <INDENT> ind = ( ind - 1 ) // 2 <COMMENT> <NEWLINE> ch1 = segtree [ ind * 2 + 1 ] <NEWLINE> ch2 = segtree [ ind * 2 + 2 ] <NEWLINE> segtree [ ind ] = ch1 + ch2 <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( s , t , l , r , p ) : <NEWLINE> <INDENT> if s > r or t < l : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if s <= l and t >= r : <NEWLINE> <INDENT> return segtree [ p ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl = query ( s , t , l , ( l + r ) // 2 , p * 2 + 1 ) <NEWLINE> vr = query ( s , t , ( l + r ) // 2 + 1 , r , p * 2 + 2 ) <NEWLINE> <NL> return vl + vr <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <COMMENT> <NL> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if com == 0 : <NEWLINE> <INDENT> update ( x - 1 , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer . append ( query ( x - 1 , y - 1 , 0 , size // 2 , 0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in answer : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ input ( ) for _ in range ( h ) ] <NEWLINE> dx = [ 1 , - 1 , 0 , 0 ] <NEWLINE> dy = [ 0 , 0 , 1 , - 1 ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for di in range ( 4 ) : <NEWLINE> <INDENT> y = i + dx [ di ] <NEWLINE> x = j + dy [ di ] <NEWLINE> if x < 0 or y < 0 or x > w - 1 or y > h - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if l [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> b = 0 <NEWLINE> b2 = 0 <NEWLINE> while a ** 5 - b ** 5 > 0 or a ** 5 - b2 ** 5 < 10 ** 9 : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> if a ** 5 - b2 ** 5 == x : <NEWLINE> <INDENT> print ( a , b2 ) <NEWLINE> break <NEWLINE> <DEDENT> b2 -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <NL> visited_town = [ ] <NEWLINE> current_town = 0 <NEWLINE> loop_flg = False <NEWLINE> visited_town . append ( current_town ) <NEWLINE> set_visted_town = set ( visited_town ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> current_town = A [ current_town ] <NEWLINE> if current_town in set_visted_town : <NEWLINE> <INDENT> visited_town . append ( current_town ) <NEWLINE> loop_flg = True <NEWLINE> break <NEWLINE> <DEDENT> visited_town . append ( current_town ) <NEWLINE> set_visted_town . add ( current_town ) <NEWLINE> <NL> <NL> <DEDENT> if loop_flg : <NEWLINE> <INDENT> loop_start = visited_town . index ( current_town ) <NEWLINE> loop_end = len ( visited_town ) - 1 <NEWLINE> loop_length = loop_end - loop_start <NEWLINE> last_index = ( K - loop_start ) % loop_length <NEWLINE> current_town = visited_town [ loop_start + last_index ] <NEWLINE> <NL> <DEDENT> print ( current_town + 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> WSV = list ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) <NEWLINE> WSV . sort ( key = lambda x : x [ 0 ] + x [ 1 ] ) <NEWLINE> U = 2 * 10 ** 4 + 100 <NEWLINE> dp = np . zeros ( U , dtype = np . int64 ) <NEWLINE> for w , s , v in WSV : <NEWLINE> <INDENT> dp [ w : w + s + 1 ] = np . maximum ( dp [ w : w + s + 1 ] , dp [ : s + 1 ] + v ) <NEWLINE> <DEDENT> print ( dp . max ( ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> max_val = 10 ** 9 + 7 <NEWLINE> dist = [ max_val for _ in range ( n ) ] <NEWLINE> prev = [ - 1 for _ in range ( n ) ] <NEWLINE> dist [ 0 ] = 0 <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> cnt = 0 <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for next in g [ now ] : <NEWLINE> <INDENT> if prev [ next ] < 0 : <NEWLINE> <INDENT> if prev [ next ] < 0 : <NEWLINE> <INDENT> q . append ( next ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> prev [ next ] = now + 1 <NEWLINE> dist [ next ] = dist [ now ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( prev [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> import array <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> A = array . array ( <STRING> , [ int ( a ) for a in sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ] ) <NEWLINE> <NL> count_pair = 0 <NEWLINE> L = { } <NEWLINE> R = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l = A [ i ] + ( i + 1 ) <NEWLINE> r = ( i + 1 ) - A [ i ] <NEWLINE> <NL> if l in L : <NEWLINE> <INDENT> L [ l ] . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ l ] = [ i + 1 ] <NEWLINE> <NL> <DEDENT> if r in R : <NEWLINE> <INDENT> R [ r ] . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ r ] = [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ len ( L [ m ] ) * len ( R [ m ] ) for m in list ( set ( L . keys ( ) ) & set ( R . keys ( ) ) ) ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def search ( x , y ) : <NEWLINE> <INDENT> x_length = len ( x ) <NEWLINE> y_length = len ( y ) <NEWLINE> memo = [ [ 0 ] * ( y_length + 1 ) for i in range ( x_length + 1 ) ] <NEWLINE> for i , ch_x in enumerate ( x , 1 ) : <NEWLINE> <INDENT> row = memo [ i ] <NEWLINE> pre_row = memo [ i - 1 ] <NEWLINE> for j , ch_y in enumerate ( y , 1 ) : <NEWLINE> <INDENT> if ch_x == ch_y : <NEWLINE> <INDENT> row [ j ] = pre_row [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif pre_row [ j ] < row [ j - 1 ] : <NEWLINE> <INDENT> row [ j ] = row [ j - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row [ j ] = pre_row [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return memo [ - 1 ] [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> strs = [ list ( val ) for val in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> result = [ search ( strs [ i * 2 ] , strs [ i * 2 + 1 ] ) for i in range ( n ) ] <NEWLINE> print ( * result , sep = <STRING> ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= b - 1 : <NEWLINE> <INDENT> print ( int ( a * ( b - 1 ) / b ) - a * int ( ( b - 1 ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a * n / b ) - a * int ( n / b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> X_i = int ( X , 2 ) <NEWLINE> X_b = bin ( X_i ) <NEWLINE> sum_X = X_b . count ( <STRING> ) <NEWLINE> Xp = X_i % ( sum_X + 1 ) <NEWLINE> Xm = X_i % ( sum_X - 1 ) if sum_X - 1 > 0 else - 1 <NEWLINE> <NL> <NL> def f ( n , p ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> n %= p <NEWLINE> while n != 0 : <NEWLINE> <INDENT> p = bin ( n ) . count ( <STRING> ) <NEWLINE> n %= p <NEWLINE> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if X [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if sum_X - 1 <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> nm = pow ( 2 , N - i , sum_X - 1 ) <NEWLINE> print ( f ( Xm - nm , sum_X - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> np = pow ( 2 , N - i , sum_X + 1 ) <NEWLINE> print ( f ( Xp + np , sum_X + 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> if L [ 0 ] % M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> L [ i ] = L [ i ] % M <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> L [ i ] = ( L [ i - 1 ] + L [ i ] ) % M <NEWLINE> <NL> <DEDENT> L = sorted ( L ) <NEWLINE> <NL> alreadythere = [ ] <NEWLINE> import collections <NEWLINE> <NL> cnt = collections . Counter ( ) <NEWLINE> for number in L : <NEWLINE> <INDENT> cnt [ number ] += 1 <NEWLINE> <NL> <DEDENT> L = set ( L ) <NEWLINE> <NL> for i in L : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> K = cnt [ i ] <NEWLINE> count += ( int ( K * ( K - 1 ) / 2 ) + K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = cnt [ i ] <NEWLINE> count += int ( K * ( K - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> x1 , y1 , x2 , y2 = ( float ( i ) for i in input ( ) . split ( ) ) <NEWLINE> x_range = x2 - x1 <NEWLINE> y_range = y2 - y1 <NEWLINE> <NL> distance = pow ( pow ( x_range , 2 ) + pow ( y_range , 2 ) , 1 / 2 ) <NEWLINE> <NL> print ( distance ) <NEWLINE>
import math <NEWLINE> <NL> A = 1 <NEWLINE> N = int ( input ( ) ) <NEWLINE> array = input ( ) . split ( ) <NEWLINE> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = ( A * int ( array [ i ] ) ) <NEWLINE> if A > math . pow ( 10 , 18 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> in array : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
from functools import reduce <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> a_xor = reduce ( lambda x , y : x ^ y , a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i ] = a [ i ] ^ a_xor <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( <STRING> . join ( list ( map ( str , b ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> c += ( n - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ris = [ i for i , s in enumerate ( S ) if s == <STRING> ] <NEWLINE> gis = [ i for i , s in enumerate ( S ) if s == <STRING> ] <NEWLINE> bis = [ i for i , s in enumerate ( S ) if s == <STRING> ] <NEWLINE> <NL> all = len ( ris ) * len ( gis ) * len ( bis ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if 0 <= k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = all - cnt <NEWLINE> <NL> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> M = max ( ls ) <NEWLINE> A = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> while ls [ i ] * a <= M : <NEWLINE> <INDENT> b = ls [ i ] * a <NEWLINE> if A [ b ] <= 1 : <NEWLINE> <INDENT> A [ b ] += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> if A [ ls [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import * <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> aaa = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> aaa . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> a = list ( combinations_with_replacement ( aaa , n ) ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> aa = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> if i [ j [ 1 ] - 1 ] - i [ j [ 0 ] - 1 ] == j [ 2 ] : <NEWLINE> <INDENT> aa += j [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if aa > ans : <NEWLINE> <INDENT> ans = aa <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> l = [ 0 for i in range ( 2019 ) ] <NEWLINE> l [ 0 ] = 1 <NEWLINE> a , b = 0 , 1 <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> a += int ( i ) * b <NEWLINE> a %= 2019 <NEWLINE> b *= 10 <NEWLINE> b %= 2019 <NEWLINE> l [ a ] += 1 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dai = [ 0 for _ in range ( A ) ] <NEWLINE> <NL> for i , l in enumerate ( B ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if B [ i - 1 ] - B [ i ] > 0 : <NEWLINE> <INDENT> dai [ i ] = B [ i - 1 ] - B [ i ] <NEWLINE> B [ i ] += B [ i - 1 ] - B [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( dai ) ) <NEWLINE>
<NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> cities = { } <NEWLINE> <NL> for a in range ( N ) : <NEWLINE> <INDENT> cities [ a + 1 ] = [ ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> i1 , i2 = map ( int , input ( ) . split ( ) ) <NEWLINE> cities [ i1 ] . append ( i2 ) <NEWLINE> cities [ i2 ] . append ( i1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> def connected_components ( graph ) : <NEWLINE> <INDENT> seen = set ( ) <NEWLINE> def component ( n ) : <NEWLINE> <INDENT> nodes = set ( [ n ] ) <NEWLINE> while nodes : <NEWLINE> <INDENT> n = nodes . pop ( ) <NEWLINE> seen . add ( n ) <NEWLINE> nodes |= set ( graph [ n ] ) - seen <NEWLINE> yield n <NEWLINE> <DEDENT> <DEDENT> for n in graph : <NEWLINE> <INDENT> if n not in seen : <NEWLINE> <INDENT> yield component ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( [ list ( x ) for x in connected_components ( cities ) ] ) - 1 ) <NEWLINE>
abck = input ( ) . split ( ) <NEWLINE> abck = [ int ( x ) for x in abck ] <NEWLINE> a = abck [ 0 ] <NEWLINE> b = abck [ 1 ] <NEWLINE> c = abck [ 2 ] <NEWLINE> k = abck [ 3 ] <NEWLINE> <NL> <NL> <NL> <NL> def check ( a , b , c , k ) : <NEWLINE> <INDENT> resutlt = 0 <NEWLINE> if a > k : <NEWLINE> <INDENT> result = k <NEWLINE> return result <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= a <NEWLINE> result = a <NEWLINE> if b > k : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= b <NEWLINE> result -= k <NEWLINE> return result <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( check ( a , b , c , k ) ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x ^= a [ i ] <NEWLINE> <NL> <DEDENT> x ^= a [ 0 ] <NEWLINE> xors = [ x ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x ^= a [ i - 1 ] <NEWLINE> x ^= a [ i ] <NEWLINE> xors . append ( x ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( str ( x ) for x in xors ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> n , m = s . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( ( m + 1 ) % 1000000007 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> d = m // ( n - 1 ) <NEWLINE> <NL> <NL> A = m - d * ( n - 1 ) + 1 <NEWLINE> B = m - ( n - 1 ) + 1 <NEWLINE> ans = ( A + B ) * d + ( m + 1 ) <NEWLINE> <COMMENT> <NL> ans %= 1000000007 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> MOD = 998244353 <NEWLINE> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> dp = np . zeros ( S + 1 , np . int64 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i , a in enumerate ( A , start = 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> dp_next = 2 * dp <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dp_next [ a : ] += dp [ : - a ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> dp_next %= MOD <NEWLINE> <NL> dp = dp_next <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( dp [ S ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> i = - 1 <NEWLINE> for i in range ( ( n - 2 ) // 2 ) : <NEWLINE> <INDENT> ans += A [ i ] * 2 <NEWLINE> ans -= A [ - i - 1 ] * 2 <NEWLINE> <DEDENT> ans += A [ i + 1 ] <NEWLINE> ans += A [ i + 2 ] <NEWLINE> ans -= A [ i + 3 ] * 2 <NEWLINE> <NL> tmp = 0 <NEWLINE> for i in range ( ( n - 2 ) // 2 ) : <NEWLINE> <INDENT> tmp += A [ i ] * 2 <NEWLINE> tmp -= A [ - i - 1 ] * 2 <NEWLINE> <DEDENT> tmp += A [ i + 1 ] * 2 <NEWLINE> tmp -= A [ i + 2 ] <NEWLINE> tmp -= A [ i + 3 ] <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> i = - 1 <NEWLINE> for i in range ( ( n - 2 ) // 2 ) : <NEWLINE> <INDENT> ans += 2 * A [ i ] <NEWLINE> ans -= 2 * A [ - i - 1 ] <NEWLINE> <DEDENT> ans += A [ i + 1 ] <NEWLINE> ans -= A [ i + 2 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> p = [ 0 ] * 200000 <NEWLINE> q = [ 0 ] * 200000 <NEWLINE> p [ 0 ] = 1 <NEWLINE> p [ 1 ] = int ( a [ 0 ] ) <NEWLINE> q [ 0 ] = 1 <NEWLINE> q [ p [ 1 ] - 1 ] = 2 <NEWLINE> f = 0 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> p [ i + 2 ] = int ( a [ p [ i + 1 ] - 1 ] ) <NEWLINE> if q [ p [ i + 2 ] - 1 ] > 0 : <NEWLINE> <INDENT> r = q [ p [ i + 2 ] - 1 ] - 1 <NEWLINE> q = i + 2 - r <NEWLINE> f = 1 <NEWLINE> l = k - r <NEWLINE> l %= q <NEWLINE> s = p [ r + l ] <NEWLINE> break <NEWLINE> <DEDENT> if f == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> q [ p [ i + 2 ] - 1 ] = i + 3 <NEWLINE> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( p [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Observ = [ 1 for i in range ( N ) ] <NEWLINE> <NL> h = input ( ) . split ( ) <NEWLINE> H = [ int ( i ) for i in h ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> HA = H [ A - 1 ] <NEWLINE> HB = H [ B - 1 ] <NEWLINE> if HA > HB : <NEWLINE> <INDENT> Observ [ B - 1 ] = 0 <NEWLINE> <DEDENT> elif HA < HB : <NEWLINE> <INDENT> Observ [ A - 1 ] = 0 <NEWLINE> <DEDENT> elif HA == HB : <NEWLINE> <INDENT> Observ [ A - 1 ] = 0 <NEWLINE> Observ [ B - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in Observ : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( ans ) ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n = 0 ) : <NEWLINE> <INDENT> self . d = [ - 1 ] * n <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . d [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . d [ x ] = self . find ( self . d [ x ] ) <NEWLINE> return self . d [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . d [ x ] > self . d [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . d [ x ] += self . d [ y ] <NEWLINE> self . d [ y ] = x <NEWLINE> return True <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . d [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> OP = [ + 1 , - 1 ] <NEWLINE> for a in range ( 1000 ) : <NEWLINE> <INDENT> for b in range ( a + 1 ) : <NEWLINE> <INDENT> for op1 in OP : <NEWLINE> <INDENT> for op2 in OP : <NEWLINE> <INDENT> if ( op1 * a ) ** 5 - ( op2 * b ) ** 5 == x : <NEWLINE> <INDENT> print ( op1 * a , op2 * b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> List = [ 0 ] * n <NEWLINE> pattern = [ 1 ] <NEWLINE> now = 0 <NEWLINE> nex = 0 <NEWLINE> List [ 0 ] = 1 <NEWLINE> end_flag = 0 <NEWLINE> <NL> while end_flag == 0 : <NEWLINE> <INDENT> nex = a [ now ] <NEWLINE> if ( List [ nex - 1 ] == 1 ) : <NEWLINE> <INDENT> target1 = nex <NEWLINE> end_flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> List [ nex - 1 ] += 1 <NEWLINE> pattern . append ( nex ) <NEWLINE> now = nex - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> left = pattern . index ( target1 ) <NEWLINE> right = len ( pattern ) <NEWLINE> kaisu = right - left <NEWLINE> kaisu2 = ( k - right ) % kaisu <NEWLINE> <NL> <NL> if ( k <= right - 1 ) : <NEWLINE> <INDENT> print ( pattern [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( pattern [ left + kaisu2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> arr = [ [ [ 0 for i3 in range ( 10 ) ] for i2 in range ( 3 ) ] for i1 in range ( 4 ) ] <NEWLINE> for b , f , r , v in a : <NEWLINE> <INDENT> arr [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> i = 1 <NEWLINE> for bl in arr : <NEWLINE> <INDENT> for fl in bl : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , fl ) ) ) <NEWLINE> <DEDENT> if i != len ( arr ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import bisect_right <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> aa = 0 <NEWLINE> bb = 0 <NEWLINE> b = [ ] <NEWLINE> flag = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> aa += A [ i ] <NEWLINE> a . append ( aa ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> bb += B [ i ] <NEWLINE> b . append ( bb ) <NEWLINE> <DEDENT> MAX = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = a [ i ] <NEWLINE> if t > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tt = K - t <NEWLINE> index = bisect_left ( b , tt ) <NEWLINE> if index == M : <NEWLINE> <INDENT> MAX = max ( MAX , i + 1 + M ) <NEWLINE> <DEDENT> elif b [ index ] == tt : <NEWLINE> <INDENT> MAX = max ( MAX , i + 1 + 1 + index ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAX = max ( MAX , i + 1 + index ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> t = b [ i ] <NEWLINE> if t > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tt = K - t <NEWLINE> index = bisect_left ( a , tt ) <NEWLINE> if index == N : <NEWLINE> <INDENT> MAX = max ( MAX , i + 1 + N ) <NEWLINE> <DEDENT> elif a [ index ] == tt : <NEWLINE> <INDENT> MAX = max ( MAX , i + 1 + 1 + index ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAX = max ( MAX , i + 1 + index ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( MAX ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> import sys <NEWLINE> import copy <NEWLINE> import re <NEWLINE> import math <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> AArray = LI ( ) <NEWLINE> MOD = 1000000007 <NEWLINE> aSum = sum ( AArray ) <NEWLINE> nowAsum = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = AArray [ i ] <NEWLINE> nowAsum += a <NEWLINE> asum = aSum - nowAsum <NEWLINE> asum %= MOD <NEWLINE> ans += a * asum % MOD <NEWLINE> <DEDENT> ans %= MOD <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> eva = False <NEWLINE> <NL> pl = abs ( B - A ) <NEWLINE> ve = V - W <NEWLINE> <NL> if pl <= ve * T : <NEWLINE> <INDENT> if ve > 0 : <NEWLINE> <INDENT> eva = True <NEWLINE> <DEDENT> <DEDENT> if eva : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , t , f , r , l , ba , bo ) : <NEWLINE> <INDENT> self . t = t <NEWLINE> self . f = f <NEWLINE> self . r = r <NEWLINE> self . l = l <NEWLINE> self . ba = ba <NEWLINE> self . bo = bo <NEWLINE> <NL> <DEDENT> def E ( self ) : <NEWLINE> <INDENT> a = self . t <NEWLINE> b = self . r <NEWLINE> c = self . bo <NEWLINE> d = self . l <NEWLINE> self . r = a <NEWLINE> self . bo = b <NEWLINE> self . l = c <NEWLINE> self . t = d <NEWLINE> <NL> <DEDENT> def N ( self ) : <NEWLINE> <INDENT> a = self . t <NEWLINE> b = self . ba <NEWLINE> c = self . bo <NEWLINE> d = self . f <NEWLINE> self . ba = a <NEWLINE> self . bo = b <NEWLINE> self . f = c <NEWLINE> self . t = d <NEWLINE> <NL> <DEDENT> def S ( self ) : <NEWLINE> <INDENT> a = self . t <NEWLINE> b = self . ba <NEWLINE> c = self . bo <NEWLINE> d = self . f <NEWLINE> self . f = a <NEWLINE> self . t = b <NEWLINE> self . ba = c <NEWLINE> self . bo = d <NEWLINE> <NL> <DEDENT> def W ( self ) : <NEWLINE> <INDENT> a = self . t <NEWLINE> b = self . r <NEWLINE> c = self . bo <NEWLINE> d = self . l <NEWLINE> self . l = a <NEWLINE> self . t = b <NEWLINE> self . r = c <NEWLINE> self . bo = d <NEWLINE> <NL> <DEDENT> <DEDENT> s = input ( ) . split ( <STRING> ) <NEWLINE> dice1 = Dice ( s [ 0 ] , s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) <NEWLINE> s = input ( ) . split ( <STRING> ) <NEWLINE> dice2 = Dice ( s [ 0 ] , s [ 1 ] , s [ 2 ] , s [ 3 ] , s [ 4 ] , s [ 5 ] ) <NEWLINE> <NL> if dice1 . t == dice2 . f : <NEWLINE> <INDENT> dice2 . N ( ) <NEWLINE> <DEDENT> elif dice1 . t == dice2 . r : <NEWLINE> <INDENT> dice2 . W ( ) <NEWLINE> <DEDENT> elif dice1 . t == dice2 . l : <NEWLINE> <INDENT> dice2 . E ( ) <NEWLINE> <DEDENT> elif dice1 . t == dice2 . ba : <NEWLINE> <INDENT> dice2 . S ( ) <NEWLINE> <DEDENT> elif dice1 . t == dice2 . bo : <NEWLINE> <INDENT> dice2 . E ( ) <NEWLINE> dice2 . E ( ) <NEWLINE> <DEDENT> if dice1 . bo != dice2 . bo : <NEWLINE> <INDENT> dice2 . N ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if dice1 . t == dice2 . t and dice1 . bo == dice2 . bo : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice2 . E ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if dice1 . t == dice2 . t and dice1 . f == dice2 . f and dice1 . r == dice2 . r and dice1 . l == dice2 . l and dice1 . ba == dice2 . ba and dice1 . bo == dice2 . bo : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> dice2 . N ( ) <NEWLINE> dice2 . E ( ) <NEWLINE> dice2 . S ( ) <NEWLINE> if i == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def bitcount ( N ) : <COMMENT> <NEWLINE> <INDENT> bitcnt = [ 0 ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> bitcnt += [ i + 1 for i in bitcnt ] <NEWLINE> <DEDENT> return bitcnt <NEWLINE> <NL> <NL> <DEDENT> n , x = int ( input ( ) ) , input ( ) <NEWLINE> <NL> num , cnt = int ( x , 2 ) , x . count ( <STRING> ) <NEWLINE> num0 , num1 = num % ( cnt + 1 ) , num % max ( cnt - 1 , 1 ) <NEWLINE> lbit = bitcount ( 18 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> ctmp = cnt + 1 <NEWLINE> tmp = num0 + pow ( 2 , n - ( i + 1 ) , cnt + 1 ) <NEWLINE> <DEDENT> elif x [ i ] == <STRING> : <NEWLINE> <INDENT> if cnt == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> ctmp = cnt - 1 <NEWLINE> tmp = num1 - pow ( 2 , n - ( i + 1 ) , cnt - 1 ) <NEWLINE> <DEDENT> tmp %= ctmp <NEWLINE> ctmp = lbit [ tmp ] <NEWLINE> while tmp > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> tmp %= ctmp <NEWLINE> ctmp = lbit [ tmp ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import itertools <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> array = list ( range ( 1 , k + 1 ) ) <NEWLINE> ans = sum ( array ) <NEWLINE> for i in range ( 2 , 4 ) : <NEWLINE> <INDENT> for x in itertools . combinations ( array , i ) : <NEWLINE> <INDENT> x = list ( x ) <NEWLINE> tmp = gcd ( * x ) <NEWLINE> ans += tmp * 6 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> maxA = max ( A ) <NEWLINE> if maxA == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> prime = [ i if i % 2 != 0 else 2 for i in range ( maxA + 1 ) ] <NEWLINE> f = [ False ] * ( maxA + 1 ) <NEWLINE> for i in range ( 3 , int ( maxA ** .5 ) + 1 ) : <NEWLINE> <INDENT> if prime [ i ] != i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> p = i * 2 <NEWLINE> while p <= maxA : <NEWLINE> <INDENT> if prime [ p ] == p : <NEWLINE> <INDENT> prime [ p ] = i <NEWLINE> <DEDENT> p += i <NEWLINE> <NL> <DEDENT> <DEDENT> def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> setwise_coprime = A [ 0 ] <NEWLINE> for An in A [ 1 : ] : <NEWLINE> <INDENT> setwise_coprime = gcd ( setwise_coprime , An ) <NEWLINE> if setwise_coprime == 1 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for An in A : <NEWLINE> <INDENT> if An == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> not_pairwise_coprime = False <NEWLINE> while prime [ An ] != An : <NEWLINE> <COMMENT> <NL> <INDENT> if f [ prime [ An ] ] : <NEWLINE> <INDENT> not_pairwise_coprime = True <NEWLINE> break <NEWLINE> <DEDENT> f [ prime [ An ] ] = True <NEWLINE> prime_An = prime [ An ] <NEWLINE> while An % prime_An == 0 : <NEWLINE> <INDENT> An //= prime_An <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if An != 1 : <NEWLINE> <INDENT> if f [ An ] : <NEWLINE> <INDENT> not_pairwise_coprime = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f [ An ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not_pairwise_coprime : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> if setwise_coprime == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> stones = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inf = 10 ** 9 <NEWLINE> dp = [ inf ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for t in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> step = i + t <NEWLINE> if step < n : <NEWLINE> <INDENT> v = dp [ i ] + abs ( stones [ i ] - stones [ step ] ) <NEWLINE> if v < dp [ step ] : <NEWLINE> <INDENT> dp [ step ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> d = collections . Counter ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s += d [ B ] * C - d [ B ] * B <NEWLINE> print ( s ) <NEWLINE> if C in d : <NEWLINE> <INDENT> d [ C ] += d [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ C ] = d [ B ] <NEWLINE> <DEDENT> d [ B ] = 0 <NEWLINE> <DEDENT>
def f3 ( n ) : <NEWLINE> <INDENT> a = b = c = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b , c = ( a + b + c + 1 ) % 100000007 , a , b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def f5 ( n ) : <NEWLINE> <INDENT> a = b = c = d = e = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b , c , d , e = ( a + b + c + d + e + 1 ) % 100000007 , a , b , c , d <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> ans = 1 <NEWLINE> num = <STRING> <NEWLINE> cnt = 1 <NEWLINE> for n in s + <STRING> : <NEWLINE> <INDENT> if n == num : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if num in <STRING> : <NEWLINE> <INDENT> ans = ans * f3 ( cnt ) % 100000007 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * f5 ( cnt ) % 100000007 <NEWLINE> <DEDENT> num = n <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> b_count = M <NEWLINE> for a_count in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ a_count ] > K : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> while A [ a_count ] + B [ b_count ] > K : <NEWLINE> <INDENT> b_count -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , a_count + b_count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in As : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for a in As : <NEWLINE> <INDENT> ans *= a <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sumi = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> sumi += i <NEWLINE> <DEDENT> <DEDENT> print ( sumi ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> def divisor ( N ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for i in range ( 2 , math . ceil ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> lst . append ( i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return lst <NEWLINE> <NL> <DEDENT> ans = divisor ( N ) <NEWLINE> <COMMENT> <NL> if N == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> A = ans [ - 1 ] <NEWLINE> if A * A < N : <NEWLINE> <INDENT> B = int ( N / A ) <NEWLINE> print ( A + B - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A - 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( N - 1 ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL>
import math <NEWLINE> <NL> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h1 = b - x / a / a <NEWLINE> h2 = 2 * x / ( a * b ) <NEWLINE> <NL> <NL> if x == a * a * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif b * a * a / 2 <= x : <NEWLINE> <INDENT> radians = math . atan ( a / 2 / h1 ) <NEWLINE> print ( 90 - math . degrees ( radians ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> radians = math . atan ( h2 / b ) <NEWLINE> print ( 90 - math . degrees ( radians ) ) <NEWLINE> <DEDENT>
<NL> import math <NEWLINE> import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> alist = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uv_list = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if u > v : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> uv_list . append ( [ u , v ] ) <NEWLINE> <NL> <DEDENT> tree = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> uv = uv_list [ i ] <NEWLINE> tree [ uv [ 0 ] ] . append ( uv [ 1 ] ) <NEWLINE> tree [ uv [ 1 ] ] . append ( uv [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> queue = [ 1 ] <NEWLINE> used = [ 0 ] * ( n + 1 ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> dp = [ ] <NEWLINE> stack = [ ] <NEWLINE> while queue != [ ] : <NEWLINE> <INDENT> cur = queue [ - 1 ] <NEWLINE> <NL> if used [ cur ] == 0 : <NEWLINE> <INDENT> if cur == 1 : <NEWLINE> <INDENT> dp . append ( alist [ cur ] ) <NEWLINE> stack . append ( [ len ( dp ) - 1 , None ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if alist [ cur ] > dp [ - 1 ] : <NEWLINE> <INDENT> dp . append ( alist [ cur ] ) <NEWLINE> stack . append ( [ len ( dp ) - 1 , None ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> offset = bisect . bisect_left ( dp , alist [ cur ] ) <NEWLINE> stack . append ( [ offset , dp [ offset ] ] ) <NEWLINE> dp [ offset ] = alist [ cur ] <NEWLINE> <DEDENT> <DEDENT> ans [ cur ] = len ( dp ) <NEWLINE> <NL> <DEDENT> if tree [ cur ] != [ ] and used [ cur ] == 0 : <NEWLINE> <INDENT> for child in tree [ cur ] : <NEWLINE> <INDENT> if used [ child ] == 0 : <NEWLINE> <INDENT> queue . append ( child ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> queue . pop ( ) <NEWLINE> <NL> <COMMENT> <NL> back = stack . pop ( ) <NEWLINE> if back [ 1 ] == None : <NEWLINE> <INDENT> dp . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ back [ 0 ] ] = back [ 1 ] <NEWLINE> <DEDENT> <DEDENT> used [ cur ] = 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> finput = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> p = 10 ** 9 + 7 <NEWLINE> n = int ( finput ( ) ) <NEWLINE> a = list ( map ( int , finput ( ) . split ( ) ) ) <NEWLINE> k = sum ( a ) - ( n * ( n + 1 ) ) // 2 <NEWLINE> pk = [ i for i in range ( n + 1 ) if a [ i ] == k ] <NEWLINE> fact = [ 1 ] * ( n + 2 ) <NEWLINE> ifact = [ 1 ] * ( n + 2 ) <NEWLINE> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % p <NEWLINE> <DEDENT> a = fact [ - 1 ] <NEWLINE> inv = 1 <NEWLINE> m = p - 2 <NEWLINE> while m > 0 : <NEWLINE> <INDENT> if m & 1 : <NEWLINE> <INDENT> inv = a * inv % p <NEWLINE> <DEDENT> m >>= 1 <NEWLINE> a = a * a % p <NEWLINE> <DEDENT> ifact [ - 1 ] = inv <NEWLINE> for i in range ( n + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> ifact [ i - 1 ] = ifact [ i ] * i % p <NEWLINE> <DEDENT> ans0 = [ 0 ] * ( n + 2 ) <NEWLINE> ans1 = [ 0 ] * ( n + 2 ) <NEWLINE> ans2 = [ 0 ] * ( n + 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans0 [ i ] = fact [ n - 1 ] * ifact [ n - i - 1 ] * ifact [ i ] % p <NEWLINE> ans1 [ i + 1 ] = ans0 [ i ] * 2 <NEWLINE> ans2 [ i + 2 ] = ans0 [ i ] <NEWLINE> <DEDENT> sn = pk [ 0 ] + n - pk [ 1 ] <NEWLINE> for i in range ( sn + 1 ) : <NEWLINE> <INDENT> ans1 [ i + 1 ] -= fact [ sn ] * ifact [ sn - i ] * ifact [ i ] % p <NEWLINE> <DEDENT> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> print ( ( ans0 [ i ] + ans1 [ i ] + ans2 [ i ] ) % p ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def f ( a , b ) : <NEWLINE> <INDENT> x = int ( max ( a , b ) ) <NEWLINE> return len ( str ( x ) ) <NEWLINE> <NL> <DEDENT> results = [ ] <NEWLINE> <NL> for i in range ( 1 , int ( n ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> b = n / i <NEWLINE> <DEDENT> result = f ( a , b ) <NEWLINE> results . append ( result ) <NEWLINE> <NL> <DEDENT> print ( min ( results ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> l = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> num = sum ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> l [ i ] = l [ i ] + 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> num += ( c - b ) * l [ b ] <NEWLINE> l [ c ] += l [ b ] <NEWLINE> l [ b ] = 0 <NEWLINE> print ( num ) <NEWLINE> <DEDENT>
import math <NEWLINE> ans = math . inf <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acm = [ 0 ] * ( n + 1 ) <NEWLINE> for i , v in enumerate ( c , 1 ) : <NEWLINE> <INDENT> acm [ i ] += acm [ i - 1 ] + v <NEWLINE> <NL> <DEDENT> s , a = 0 , acm [ n ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s = acm [ i ] <NEWLINE> ans = min ( ans , abs ( ( a - s ) - s ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 1 <NEWLINE> check = [ 0 ] * n <NEWLINE> check [ 0 ] = 1 <NEWLINE> move = [ 1 ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = a_list [ now - 1 ] <NEWLINE> move . append ( now ) <NEWLINE> if check [ now - 1 ] == 0 : <NEWLINE> <INDENT> check [ now - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> point = ( move . index ( now ) ) <NEWLINE> roop_len = sum ( check ) - point <NEWLINE> <NL> if k <= sum ( check ) : <NEWLINE> <INDENT> print ( move [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k_ = k - point <NEWLINE> point_ = k_ % roop_len <NEWLINE> print ( move [ point + point_ ] ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from collections import Counter as C <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in a ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> bc = np . array ( bc ) . T <NEWLINE> b = bc [ 0 ] <NEWLINE> c = bc [ 1 ] <NEWLINE> <NL> d = C ( a ) <NEWLINE> d2 = { } <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> d2 [ k ] = k * v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> d [ c [ i ] ] += d [ b [ i ] ] <NEWLINE> ans += ( c [ i ] - b [ i ] ) * d [ b [ i ] ] <NEWLINE> d [ b [ i ] ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def chk ( L ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += ceil ( A [ i ] / L ) - 1 <NEWLINE> <DEDENT> return cnt <= K <NEWLINE> <DEDENT> l , r = 1 , max ( A ) <NEWLINE> while l <= r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if chk ( m ) : <NEWLINE> <INDENT> r = m - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m + 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( [ x for x in [ m - 1 , m , m + 1 ] if x > 0 and chk ( x ) ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loop = { i : - 1 for i in range ( N ) } <NEWLINE> loop [ 0 ] = 0 <NEWLINE> position = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> position = A [ position ] - 1 <NEWLINE> if loop [ position ] != - 1 : <NEWLINE> <INDENT> ini = loop [ position ] <NEWLINE> cycle = i + 1 - ini <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop [ position ] = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> M = ( K - ini ) % cycle <NEWLINE> <NL> answer = 0 <NEWLINE> root = min ( K , M + ini ) <NEWLINE> for j in range ( root ) : <NEWLINE> <INDENT> answer = A [ answer ] - 1 <NEWLINE> <NL> <DEDENT> answer += 1 <NEWLINE> print ( answer ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def fib ( number ) : <NEWLINE> <INDENT> if number == 0 or number == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> memo1 = 1 <NEWLINE> memo2 = 1 <NEWLINE> <NL> for i in range ( number - 1 ) : <NEWLINE> <INDENT> memo1 , memo2 = memo1 + memo2 , memo1 <NEWLINE> <DEDENT> return memo1 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( fib ( N ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> Rt = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Rt . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxv = Rt [ 1 ] - Rt [ 0 ] <NEWLINE> minv = Rt [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( maxv , Rt [ j ] - minv ) <NEWLINE> minv = min ( minv , Rt [ j ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
def multmod ( a , b , m ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> a = a % m <NEWLINE> <NL> while b : <NEWLINE> <INDENT> if ( b & 1 ) : <COMMENT> <NEWLINE> <INDENT> ans = ( ans + a ) % m <NEWLINE> <NL> <DEDENT> a = ( 2 * a ) % m <NEWLINE> b >>= 1 <COMMENT> <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> divisor = 10 ** 9 + 7 <NEWLINE> tot = 0 <NEWLINE> a , b = 0 , 0 <NEWLINE> arr_sum = sum ( S ) <COMMENT> <NEWLINE> arr_ssq = arr_sum * arr_sum <COMMENT> <NEWLINE> isq_sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> isq_sum += S [ i ] * S [ i ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> tot = ( arr_ssq - isq_sum ) // 2 % divisor <NEWLINE> <NL> print ( tot ) <NEWLINE>
<COMMENT> <NL> l = input ( ) <NEWLINE> <NL> k = 0 <NEWLINE> S1 , S2 = [ ] , [ ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> S1 . append ( i ) <NEWLINE> <DEDENT> elif l [ i ] == <STRING> and S1 : <NEWLINE> <INDENT> j = S1 . pop ( ) <NEWLINE> a = i - j <NEWLINE> k += i - j <NEWLINE> <NL> while S2 and S2 [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> a += S2 . pop ( ) [ 1 ] <NEWLINE> <DEDENT> S2 . append ( ( j , a ) ) <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE> print ( len ( S2 ) , * ( a for j , a in S2 ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> def dfs ( node ) : <NEWLINE> <INDENT> while len ( todo ) > 0 : <NEWLINE> <INDENT> node = todo . pop ( ) <NEWLINE> if tf [ node ] == 0 : <NEWLINE> <INDENT> tf [ node ] = 1 <NEWLINE> seen . add ( node ) <NEWLINE> for nextnode in graph [ node ] : <NEWLINE> <INDENT> todo . append ( nextnode ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> todo = deque ( ) <NEWLINE> done = set ( ) <NEWLINE> tf = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in done : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> todo . append ( i ) <NEWLINE> seen = set ( ) <NEWLINE> dfs ( i ) <NEWLINE> <COMMENT> <NL> ans = max ( ans , len ( seen ) ) <NEWLINE> done |= seen <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = { } <NEWLINE> ans = 0 <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S not in D : <NEWLINE> <INDENT> D [ S ] = True <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> memo = input ( ) . split ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( memo [ n - i - 1 ] + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( memo [ 0 ] ) <NEWLINE>
def solution ( K : int ) -> int : <NEWLINE> <INDENT> sevens : int = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sevens = ( sevens * 10 + 7 ) % K <NEWLINE> if sevens == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> K : int = int ( input ( ) ) <NEWLINE> <NL> print ( solution ( K ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b2 = [ ] <NEWLINE> b2 . append ( 0 ) <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b2 . append ( b2 [ i - 1 ] + b [ i - 1 ] ) <NEWLINE> <DEDENT> a . insert ( 0 , 0 ) <NEWLINE> cnt = 0 <NEWLINE> a_sum = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> j = m <NEWLINE> a_sum += a [ i ] <NEWLINE> while True : <NEWLINE> <INDENT> if k >= a_sum + b2 [ j ] : <NEWLINE> <INDENT> cnt = max ( cnt , i + j ) <NEWLINE> m = j <NEWLINE> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import namedtuple <NEWLINE> Card = namedtuple ( <STRING> , <STRING> ) <NEWLINE> <NL> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] . value <= x . value : <NEWLINE> <INDENT> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> A [ i ] , A [ r ] = A [ r ] , A [ i ] <NEWLINE> return i <NEWLINE> <NL> <DEDENT> def quickSort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quickSort ( A , p , q - 1 ) <NEWLINE> quickSort ( A , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( L , R ) : <NEWLINE> <INDENT> global cnt <NEWLINE> n = len ( L ) + len ( R ) <NEWLINE> A = [ ] <NEWLINE> i = j = 0 <NEWLINE> L . append ( Card ( <STRING> , - 1 ) ) <NEWLINE> R . append ( Card ( <STRING> , - 1 ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if L [ i ] . value > R [ j ] . value : <NEWLINE> <INDENT> A . append ( L [ i ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( R [ j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def mergeSort ( A ) : <NEWLINE> <INDENT> if len ( A ) == 1 : return A <NEWLINE> m = len ( A ) // 2 <NEWLINE> return merge ( mergeSort ( A [ : m ] ) , mergeSort ( A [ m : ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> Co = list ( map ( lambda X : Card ( X [ 0 ] , int ( X [ 1 ] ) ) , [ input ( ) . split ( ) for _ in range ( n ) ] ) ) <NEWLINE> Cq = Co [ : ] <NEWLINE> Cm = mergeSort ( Co [ : ] ) <NEWLINE> quickSort ( Cq , 0 , n - 1 ) <NEWLINE> print ( <STRING> if Cq == Cm [ : : - 1 ] else <STRING> ) <NEWLINE> for c in Cq : print ( c . suit , c . value ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = N // 27 <NEWLINE> b = N % 27 <NEWLINE> s = <STRING> <NEWLINE> if N < 27 : <NEWLINE> <INDENT> print ( chr ( N + 96 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = N <NEWLINE> j = 0 <NEWLINE> for i in range ( 1 , 11 ) : <NEWLINE> <INDENT> if n - 1 - pow ( 26 , i ) >= 0 : <NEWLINE> <INDENT> n -= pow ( 26 , i ) <NEWLINE> j = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for k in range ( j , - 1 , - 1 ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> s = s + chr ( n - 1 + 97 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + chr ( ( n - 1 ) // pow ( 26 , k ) + 97 ) <NEWLINE> n -= ( ( n - 1 ) // pow ( 26 , k ) ) * pow ( 26 , k ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> p = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> p = ( p * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
<COMMENT> <NL> <NL> M , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> C = math . floor ( M / ( A + B ) ) <NEWLINE> N = M % ( A + B ) <NEWLINE> E = C * A <NEWLINE> <NL> if N >= A : <NEWLINE> <INDENT> E += A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E += N <NEWLINE> <DEDENT> print ( E ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> hako = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tasu = sum ( hako ) <NEWLINE> tasu = tasu ** 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tasu = tasu - ( hako [ i ] ) ** 2 <NEWLINE> <DEDENT> tasu = tasu // 2 <NEWLINE> tasu = tasu % ( 10 ** 9 + 7 ) <NEWLINE> print ( tasu ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , B = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> num , x = 0 , m <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ i ] + B [ x ] > k : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> num = max ( num , i + x ) <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r * r , r * 2 * math . pi ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = 0 <NEWLINE> sum_aa = 0 <NEWLINE> for a in aaa : <NEWLINE> <INDENT> sum_a += a <NEWLINE> sum_aa += a ** 2 <NEWLINE> <NL> <DEDENT> print ( ( ( sum_a ** 2 - sum_aa ) // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , ( input ( ) for i in range ( N ) ) ) ) <NEWLINE> B = sorted ( A , reverse = True ) <NEWLINE> a = B [ 0 ] <NEWLINE> a1 = B [ 1 ] <NEWLINE> <NL> <NL> for x in A : <NEWLINE> <INDENT> if x != a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> so_list = [ 0 for i in range ( 10 ** 6 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def fac ( n ) : <NEWLINE> <INDENT> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> if so_list [ i ] < cnt : <NEWLINE> <INDENT> so_list [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if so_list [ temp ] == 0 : <NEWLINE> <INDENT> so_list [ temp ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a1 = a [ i ] <NEWLINE> fac ( a1 ) <NEWLINE> <DEDENT> l = 1 <NEWLINE> for i in range ( len ( so_list ) ) : <NEWLINE> <INDENT> if so_list [ i ] != 0 : <NEWLINE> <INDENT> l *= pow ( i , so_list [ i ] , mod ) <NEWLINE> l %= mod <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in a : <NEWLINE> <INDENT> t = pow ( i , mod - 2 , mod ) <NEWLINE> ans += ( l * t ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] == s [ j ] or s [ j ] == s [ k ] or s [ k ] == s [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> m = 0 <NEWLINE> <NL> for i in range ( 1 , 10 ** 7 ) : <NEWLINE> <INDENT> n = m * 10 + 7 <NEWLINE> m = n % k <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = ii ( ) <NEWLINE> D = list ( mi ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if D [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> dic = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dic [ D [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= dic [ D [ i ] - 1 ] <NEWLINE> ans %= 998244353 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> from bisect import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ( * a , ) = accumulate ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ( * b , ) = accumulate ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = ( 0 , ) + tuple ( i for i in a if i <= k ) <NEWLINE> b = tuple ( i for i in b if i <= k ) <NEWLINE> print ( max ( i + bisect ( b , k - a [ i ] ) for i in range ( len ( a ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> su = 0 <NEWLINE> d = [ ] <NEWLINE> for i in range ( 1000003 ) : <NEWLINE> <INDENT> d . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> d [ c [ i ] ] = d [ c [ i ] ] + 1 <NEWLINE> su = su + c [ i ] <NEWLINE> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> r , s = map ( int , input ( ) . split ( ) ) <NEWLINE> su = su - d [ r ] * r + d [ r ] * s <NEWLINE> d [ s ] = d [ s ] + d [ r ] <NEWLINE> d [ r ] = 0 <NEWLINE> print ( su ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> from collections import defaultdict , deque , Counter , OrderedDict <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from functools import reduce , lru_cache <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> <NL> import itertools <NEWLINE> import math , fractions <NEWLINE> import sys , copy <NEWLINE> <NL> def L ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def SL ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI1 ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def R ( n ) : return [ sys . stdin . readline ( ) . strip ( ) for _ in range ( n ) ] <NEWLINE> def LR ( n ) : return [ L ( ) for _ in range ( n ) ] <NEWLINE> def IR ( n ) : return [ I ( ) for _ in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> def LIR1 ( n ) : return [ LI1 ( ) for _ in range ( n ) ] <NEWLINE> def SLR ( n ) : return [ SL ( ) for _ in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> <NL> def perm ( n , r ) : return math . factorial ( n ) // math . factorial ( r ) <NEWLINE> def comb ( n , r ) : return math . factorial ( n ) // ( math . factorial ( r ) * math . factorial ( n - r ) ) <NEWLINE> <NL> def make_list ( n , * args , default = 0 ) : return [ make_list ( * args , default = default ) for _ in range ( n ) ] if args else [ default for _ in range ( n ) ] <NEWLINE> <NL> dire = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> dire8 = [ [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 0 , - 1 ] , [ 1 , - 1 ] ] <NEWLINE> alphabets = <STRING> <NEWLINE> ALPHABETS = <STRING> <NEWLINE> MOD = 1000000007 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class MaxFlowGraph : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . graph = [ [ ] for _ in range ( N ) ] <NEWLINE> self . capacities = [ dict ( ) for _ in range ( N ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , v , w , cap ) : <NEWLINE> <INDENT> self . graph [ v ] . append ( w ) <NEWLINE> self . graph [ w ] . append ( v ) <NEWLINE> self . capacities [ v ] [ w ] = cap <NEWLINE> self . capacities [ w ] [ v ] = 0 <NEWLINE> <NL> <DEDENT> def bfs ( self , s , t ) : <NEWLINE> <INDENT> self . level = [ - 1 ] * self . N <NEWLINE> q = [ s ] <NEWLINE> self . level [ s ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> nq = [ ] <NEWLINE> for v in q : <NEWLINE> <INDENT> for w , cap in self . capacities [ v ] . items ( ) : <NEWLINE> <INDENT> if cap and self . level [ w ] == - 1 : <NEWLINE> <INDENT> self . level [ w ] = self . level [ v ] + 1 <NEWLINE> if w == t : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> nq . append ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q = nq <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def dfs ( self , s , t , up ) : <NEWLINE> <INDENT> st = [ t ] <NEWLINE> while st : <NEWLINE> <INDENT> v = st [ - 1 ] <NEWLINE> if v == s : <NEWLINE> <INDENT> flow = up <NEWLINE> for i in range ( len ( st ) - 2 ) : <NEWLINE> <INDENT> if flow > self . capacities [ st [ i + 1 ] ] [ st [ i ] ] : <NEWLINE> <INDENT> flow = self . capacities [ st [ i + 1 ] ] [ st [ i ] ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( st ) - 1 ) : <NEWLINE> <INDENT> self . capacities [ st [ i ] ] [ st [ i + 1 ] ] += flow <NEWLINE> self . capacities [ st [ i + 1 ] ] [ st [ i ] ] -= flow <NEWLINE> <DEDENT> return flow <NEWLINE> <DEDENT> while self . it [ v ] < len ( self . graph [ v ] ) : <NEWLINE> <INDENT> w = self . graph [ v ] [ self . it [ v ] ] <NEWLINE> cap = self . capacities [ w ] [ v ] <NEWLINE> if cap and self . level [ w ] != - 1 : <NEWLINE> <INDENT> if self . level [ v ] > self . level [ w ] : <NEWLINE> <INDENT> st . append ( w ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> self . it [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . pop ( ) <NEWLINE> self . level [ v ] = self . N <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def flow ( self , s , t , flow_limit = 18446744073709551615 ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> while flow < flow_limit and self . bfs ( s , t ) : <NEWLINE> <INDENT> self . it = [ 0 ] * self . N <NEWLINE> while flow < flow_limit : <NEWLINE> <INDENT> f = self . dfs ( s , t , flow_limit - flow ) <NEWLINE> if not f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flow += f <NEWLINE> <DEDENT> <DEDENT> return flow <NEWLINE> <NL> <DEDENT> def min_cut ( self , s ) : <NEWLINE> <INDENT> visited = [ False ] * self . N <NEWLINE> q = [ s ] <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> visited [ v ] = True <NEWLINE> for w , cap in self . capacities [ v ] . items ( ) : <NEWLINE> <INDENT> if cap and not visited [ w ] : <NEWLINE> <INDENT> q . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> S = SLR ( N ) <NEWLINE> g = MaxFlowGraph ( N * M + 2 ) <NEWLINE> <NL> s = N * M <NEWLINE> t = N * M + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> g . add_edge ( s , M * i + j , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g . add_edge ( M * i + j , t , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if j + 1 < M and S [ i ] [ j ] == <STRING> and S [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> u , v = M * i + j , M * i + j + 1 <NEWLINE> if ( i + j ) % 2 == 1 : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> g . add_edge ( u , v , 1 ) <NEWLINE> <DEDENT> if i + 1 < N and S [ i ] [ j ] == <STRING> and S [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> u , v = M * i + j , M * ( i + 1 ) + j <NEWLINE> if ( i + j ) % 2 == 1 : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> g . add_edge ( u , v , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( g . flow ( s , t ) ) <NEWLINE> <NL> <COMMENT> <NL> for u in range ( N * M + 2 ) : <NEWLINE> <INDENT> uy , ux = divmod ( u , M ) <NEWLINE> if ( uy + ux ) % 2 == 1 : continue <NEWLINE> <NL> for v , cap in g . capacities [ u ] . items ( ) : <NEWLINE> <INDENT> if cap != 0 : continue <NEWLINE> vy , vx = divmod ( v , M ) <NEWLINE> if u != s and u != t and v != s and v != t : <NEWLINE> <INDENT> if uy - 1 == vy : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif uy + 1 == vy : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif ux + 1 == vx : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif ux - 1 == vx : <NEWLINE> <INDENT> S [ uy ] [ ux ] , S [ vy ] [ vx ] = <STRING> , <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for p in S : <NEWLINE> <INDENT> print ( <STRING> . join ( p ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> import time <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> G = gcd ( a , b , c ) <NEWLINE> if a == b and b == c : <NEWLINE> <INDENT> sum += G <NEWLINE> <DEDENT> elif a == b or b == c : <NEWLINE> <INDENT> sum += G * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += G * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL>
isExist = [ 0 ] * 2001 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( val ) for val in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in range ( 2000 - i , 0 , - 1 ) : <NEWLINE> <INDENT> if 1 == isExist [ j ] : <NEWLINE> <INDENT> isExist [ i + j ] = 1 <NEWLINE> <DEDENT> <DEDENT> isExist [ i ] = 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> M = [ int ( val ) for val in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> for i in range ( 0 , q ) : <NEWLINE> <INDENT> if 1 == isExist [ M [ i ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 ] * Q <NEWLINE> C = [ 0 ] * Q <NEWLINE> li = [ 0 ] * 100001 <NEWLINE> for a in A : <NEWLINE> <INDENT> li [ a ] += 1 <NEWLINE> <DEDENT> su = sum ( A ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> su += li [ B ] * ( C - B ) <NEWLINE> li [ C ] += li [ B ] <NEWLINE> li [ B ] = 0 <NEWLINE> print ( su ) <NEWLINE> <DEDENT>
def dfs ( s ) : <NEWLINE> <INDENT> if not visited [ s ] : <NEWLINE> <INDENT> visited [ s ] = True <NEWLINE> stack [ s ] = True <NEWLINE> for t in adj [ s ] : <NEWLINE> <INDENT> if stack [ t ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> stack [ s ] = False <NEWLINE> <NL> <DEDENT> nv , ne = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj = [ [ ] for _ in range ( nv ) ] <NEWLINE> visited = [ False ] * nv <NEWLINE> stack = [ False ] * nv <NEWLINE> <NL> for _ in range ( ne ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> <NL> <DEDENT> for i in range ( nv ) : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <NL> <DEDENT> print ( 0 ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> B_list = [ ] <NEWLINE> <NL> <NL> for Books in range ( N ) : <NEWLINE> <INDENT> B_list . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> bug = [ ] <NEWLINE> for k in range ( M + 1 ) : <NEWLINE> <INDENT> bug . append ( 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> ways = [ ] <NEWLINE> <NL> for way in range ( 2 ** N ) : <NEWLINE> <INDENT> for book in range ( N ) : <NEWLINE> <INDENT> if ( ( way >> book ) & 1 ) == 1 : <NEWLINE> <INDENT> for i in range ( M + 1 ) : <NEWLINE> <INDENT> bug [ i ] += B_list [ book ] [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> O = bug . pop ( 0 ) <NEWLINE> clear = [ l for l in bug if l >= X ] <NEWLINE> <COMMENT> <NL> <NL> if len ( bug ) == len ( clear ) : <NEWLINE> <INDENT> ways . append ( O ) <NEWLINE> <NL> <DEDENT> bug = [ ] <NEWLINE> for k in range ( M + 1 ) : <NEWLINE> <INDENT> bug . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( ways ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ways ) ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> n = len ( t ) <NEWLINE> m = len ( s ) <NEWLINE> a = [ ] <NEWLINE> if t in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m - n + 1 ) : <COMMENT> <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> a . append ( ans ) <NEWLINE> <DEDENT> print ( min ( a ) ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for j in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = N // 1000 <NEWLINE> x1 = ( N - x * 1000 ) // 100 <NEWLINE> x2 = ( N - x * 1000 - x1 * 100 ) // 10 <NEWLINE> x3 = N - x * 1000 - x1 * 100 - x2 * 10 <NEWLINE> sum = x + x1 + x2 + x3 <NEWLINE> if sum % 9 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def euc ( i , j ) : <NEWLINE> <INDENT> if i > j : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <DEDENT> while j % i != 0 : <NEWLINE> <INDENT> k = j - i <NEWLINE> if k > i : <NEWLINE> <INDENT> i , k = k , i <NEWLINE> <DEDENT> j = i % k <NEWLINE> if j == 0 : <NEWLINE> <INDENT> return ( k ) <NEWLINE> <DEDENT> i = k <NEWLINE> if i > j : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ij = euc ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sum += euc ( ij , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <COMMENT> <NL>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> T = [ 0 ] * M <NEWLINE> H_cnt = { } <NEWLINE> W_cnt = { } <NEWLINE> HW = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if not h in H_cnt : <NEWLINE> <INDENT> H_cnt [ h ] = 0 <NEWLINE> <DEDENT> if not w in W_cnt : <NEWLINE> <INDENT> W_cnt [ w ] = 0 <NEWLINE> <DEDENT> H_cnt [ h ] += 1 <NEWLINE> W_cnt [ w ] += 1 <NEWLINE> HW [ ( h , w ) ] = 1 <NEWLINE> <NL> <DEDENT> HL = [ [ h , cnt ] for h , cnt in H_cnt . items ( ) ] <NEWLINE> WL = [ [ w , cnt ] for w , cnt in W_cnt . items ( ) ] <NEWLINE> <NL> HL . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> WL . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> HS = { } <NEWLINE> max_cnth = 0 <NEWLINE> for h , cnt in HL : <NEWLINE> <INDENT> if max_cnth <= cnt : <NEWLINE> <INDENT> HS [ h ] = cnt <NEWLINE> max_cnth = max ( max_cnth , cnt ) <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> WS = { } <NEWLINE> max_cntw = 0 <NEWLINE> for w , cnt in WL : <NEWLINE> <INDENT> if max_cntw <= cnt : <NEWLINE> <INDENT> WS [ w ] = cnt <NEWLINE> max_cntw = max ( max_cntw , cnt ) <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> cross_cnt = 0 <NEWLINE> for hw in HW . keys ( ) : <NEWLINE> <INDENT> h , w = hw <NEWLINE> if h in HS and w in WS : <NEWLINE> <INDENT> cross_cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( WS ) * len ( HS ) == cross_cnt : <NEWLINE> <INDENT> print ( max_cnth + max_cntw - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( max_cnth + max_cntw ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 1 <NEWLINE> path = [ ] <NEWLINE> d = { } <NEWLINE> l = 0 <NEWLINE> while l <= k : <NEWLINE> <INDENT> if c in d : <NEWLINE> <INDENT> p = d [ c ] <NEWLINE> <COMMENT> <NL> pattern_l = l - p <NEWLINE> k -= ( ( k - p ) // pattern_l ) * pattern_l <NEWLINE> <DEDENT> path . append ( c ) <NEWLINE> l += 1 <NEWLINE> d [ c ] = l - 1 <NEWLINE> c = A [ c - 1 ] <NEWLINE> <DEDENT> print ( path [ k ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import sys <NEWLINE> if l . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for x in l : <NEWLINE> <NL> <INDENT> ans = ans * x <NEWLINE> <NL> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> mo = 7 <NEWLINE> mo = mo % k <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if mo == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> if mo != 0 : <NEWLINE> <INDENT> mo = ( mo * 10 + 7 ) % k <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> su = 0 <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> su += A [ i ] * a <NEWLINE> a += A [ i ] <NEWLINE> <DEDENT> print ( su % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ <STRING> ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> si = str ( input ( ) ) <NEWLINE> s [ i ] = si <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> c = 0 <NEWLINE> s . append ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lst = sorted ( [ int ( x ) for x in input ( ) . split ( ) if x != <STRING> ] , reverse = True ) <NEWLINE> <NL> if len ( lst ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if lst [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ret = 1 <NEWLINE> for x in lst : <NEWLINE> <INDENT> ret *= x <NEWLINE> if ret > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for aa in a : <NEWLINE> <INDENT> ans *= aa <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> R = c . count ( <STRING> ) <NEWLINE> W = 0 <NEWLINE> ans = [ R , c . count ( <STRING> ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> W += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R -= 1 <NEWLINE> <DEDENT> ans . append ( max ( R , W ) ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e5 ) ) <NEWLINE> <NL> <NL> def dfs_Tarjan ( current ) : <NEWLINE> <INDENT> global timer <NEWLINE> children = 0 <NEWLINE> visited [ current ] = True <NEWLINE> disc [ current ] = low [ current ] = timer <NEWLINE> timer += 1 <NEWLINE> <NL> for adj in adj_table [ current ] : <NEWLINE> <INDENT> if not visited [ adj ] : <NEWLINE> <INDENT> parent [ adj ] = current <NEWLINE> children += 1 <NEWLINE> dfs_Tarjan ( adj ) <NEWLINE> low [ current ] = min ( low [ current ] , low [ adj ] ) <NEWLINE> <COMMENT> <NL> if parent [ current ] == - 1 and children > 1 : <NEWLINE> <INDENT> art_set . add ( current ) <NEWLINE> <DEDENT> elif parent [ current ] != - 1 and low [ adj ] >= disc [ current ] : <NEWLINE> <INDENT> art_set . add ( current ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif adj != parent [ current ] : <NEWLINE> <INDENT> low [ current ] = min ( low [ current ] , disc [ adj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def dfs_init ( ) : <NEWLINE> <INDENT> for v in range ( v_num ) : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> dfs_Tarjan ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> v_num , e_num = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> edges = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> adj_table = tuple ( [ ] for _ in range ( v_num ) ) <NEWLINE> for edge in edges : <NEWLINE> <INDENT> source , target = map ( int , edge ) <NEWLINE> adj_table [ source ] . append ( target ) <NEWLINE> adj_table [ target ] . append ( source ) <NEWLINE> <NL> <DEDENT> timer = 0 <NEWLINE> art_set = set ( ) <NEWLINE> parent = [ - 1 ] * v_num <NEWLINE> visited = [ False ] * v_num <NEWLINE> disc , low = ( [ float ( <STRING> ) ] * v_num for _ in range ( 2 ) ) <NEWLINE> <NL> dfs_init ( ) <NEWLINE> if art_set : <NEWLINE> <INDENT> print ( * sorted ( art_set ) , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> j = 1 <NEWLINE> step = 0 <NEWLINE> s = set ( [ ] ) <NEWLINE> l = [ ] <NEWLINE> loop_s = - 1 <NEWLINE> loop_g = - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s . add ( j ) <NEWLINE> l += [ j ] <NEWLINE> j = a_ls [ j - 1 ] <COMMENT> <NEWLINE> if j in s : <NEWLINE> <INDENT> loop_s = l . index ( j ) <NEWLINE> loop_g = len ( l ) <NEWLINE> break <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if K < loop_s : <NEWLINE> <INDENT> print ( l [ K ] ) <NEWLINE> <DEDENT> elif ( K + 1 - loop_s ) % ( loop_g - loop_s ) != 0 : <NEWLINE> <INDENT> print ( l [ loop_s + ( K + 1 - loop_s ) % ( loop_g - loop_s ) - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ - 1 ] ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a_arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k_idx = K - 1 <NEWLINE> ans_arr = [ ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if a_arr [ i ] < a_arr [ k_idx + 1 ] : <NEWLINE> <INDENT> ans_arr . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_arr . append ( <STRING> ) <NEWLINE> <DEDENT> k_idx += 1 <NEWLINE> <DEDENT> for i in ans_arr : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import types <NEWLINE> <NL> _atcoder_code = <STRING> <NEWLINE> <NL> atcoder = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder_code , atcoder . __dict__ ) <NEWLINE> <NL> _atcoder__scc_code = <STRING> <NEWLINE> <NL> atcoder . _scc = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder__scc_code , atcoder . _scc . __dict__ ) <NEWLINE> <NL> <NL> _atcoder_scc_code = <STRING> <NEWLINE> <NL> atcoder . scc = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder_scc_code , atcoder . scc . __dict__ ) <NEWLINE> atcoder . scc . __dict__ [ <STRING> ] = atcoder <NEWLINE> atcoder . scc . __dict__ [ <STRING> ] = atcoder . _scc <NEWLINE> SCCGraph = atcoder . scc . SCCGraph <NEWLINE> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) -> None : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> g = SCCGraph ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> g . add_edge ( u , v ) <NEWLINE> <NL> <DEDENT> scc = g . scc ( ) <NEWLINE> <NL> print ( len ( scc ) ) <NEWLINE> for v in scc : <NEWLINE> <INDENT> print ( len ( v ) , end = <STRING> ) <NEWLINE> for x in v : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def find_gcd ( x , y ) : <NEWLINE> <NL> <INDENT> while ( y ) : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <DEDENT> dicts = { } <NEWLINE> total = 0 <NEWLINE> storedict = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <NL> <INDENT> strin = str ( i ) + <STRING> + str ( j ) <NEWLINE> if strin not in dicts : <NEWLINE> <INDENT> gh = find_gcd ( i , j ) <NEWLINE> strin3 = str ( j ) + <STRING> + str ( i ) <NEWLINE> dicts [ strin ] = gh <NEWLINE> dicts [ strin3 ] = gh <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> gh = dicts [ strin ] <NEWLINE> <NL> <DEDENT> if gh not in storedict : <NEWLINE> <INDENT> storedict [ gh ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> storedict [ gh ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for key , value in storedict . items ( ) : <NEWLINE> <INDENT> gh = find_gcd ( key , k ) <NEWLINE> <NL> strin2 = str ( gh ) + <STRING> + str ( k ) <NEWLINE> <NL> if strin2 not in dicts : <NEWLINE> <INDENT> gh = find_gcd ( gh , k ) <NEWLINE> strin4 = str ( k ) + <STRING> + str ( gh ) <NEWLINE> dicts [ strin2 ] = gh <NEWLINE> dicts [ strin4 ] = gh <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gh = dicts [ strin2 ] <NEWLINE> <NL> <DEDENT> ans1 = gh * value <NEWLINE> total += ans1 <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : print ( <STRING> , end = <STRING> ) <NEWLINE> else : print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = [ 1 ] <NEWLINE> h = { 1 } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x = t [ g [ i ] - 1 ] <NEWLINE> g . append ( x ) <NEWLINE> if x in h : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h . add ( x ) <NEWLINE> <DEDENT> if K > len ( g ) : <NEWLINE> <INDENT> a = g . index ( g [ - 1 ] ) <NEWLINE> b = len ( g ) - a - 1 <NEWLINE> K = ( K - a ) % b + a <NEWLINE> <DEDENT> print ( g [ K ] ) <NEWLINE>
from collections import Counter <NEWLINE> s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> t = 0 <NEWLINE> cusum = [ ] <NEWLINE> for i in range ( len ( s ) ) [ : : - 1 ] : <NEWLINE> <INDENT> t += s [ i ] * pow ( 10 , len ( s ) - i - 1 , 2019 ) <NEWLINE> t %= 2019 <NEWLINE> cusum . append ( t ) <NEWLINE> <NL> <DEDENT> counter = Counter ( cusum ) <NEWLINE> <NL> ans = counter [ 0 ] <NEWLINE> for v in counter . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> maze = [ [ ] for _ in range ( H ) ] <NEWLINE> <NL> num_black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> for j in temp : <NEWLINE> <INDENT> maze [ i ] . append ( j ) <NEWLINE> if j == <STRING> : <NEWLINE> <INDENT> num_black += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> import copy , collections <NEWLINE> <NL> maze_copy = copy . deepcopy ( maze ) <NEWLINE> color = [ [ <STRING> ] * W for _ in range ( H ) ] <NEWLINE> <NL> <NL> X , Y = 0 , 0 <NEWLINE> vec = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> color [ Y ] [ X ] = <STRING> <NEWLINE> que = collections . deque ( ) <NEWLINE> maze_copy [ Y ] [ X ] = 1 <NEWLINE> que . append ( [ Y , X ] ) <NEWLINE> <NL> while len ( que ) != 0 : <NEWLINE> <INDENT> u = que . popleft ( ) <NEWLINE> for y , x in vec : <NEWLINE> <INDENT> temp_x = u [ 1 ] + x <NEWLINE> temp_y = u [ 0 ] + y <NEWLINE> if ( 0 <= temp_x < W and 0 <= temp_y < H <NEWLINE> <INDENT> and maze_copy [ temp_y ] [ temp_x ] == <STRING> and color [ temp_y ] [ temp_x ] == <STRING> ) : <NEWLINE> color [ temp_y ] [ temp_x ] = <STRING> <NEWLINE> maze_copy [ temp_y ] [ temp_x ] = maze_copy [ u [ 0 ] ] [ u [ 1 ] ] + 1 <NEWLINE> que . append ( [ temp_y , temp_x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if maze_copy [ - 1 ] [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H - num_black - maze_copy [ - 1 ] [ - 1 ] ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in data : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( <NEWLINE> <NL> ) <NEWLINE> <DEDENT> answer = 1 <NEWLINE> <NL> for x in data : <NEWLINE> <INDENT> answer *= x <NEWLINE> if answer > 1e+18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> commons = c . most_common ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> dic = { } <NEWLINE> for common in commons : <NEWLINE> <INDENT> dic [ common [ 0 ] ] = common [ 1 ] <NEWLINE> ans += common [ 0 ] * common [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b not in dic : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if c not in dic : <NEWLINE> <INDENT> ans += ( c - b ) * dic [ b ] <NEWLINE> print ( ans ) <NEWLINE> dic [ c ] = dic [ b ] <NEWLINE> dic [ b ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> ans += ( c - b ) * dic [ b ] <NEWLINE> dic [ c ] += dic [ b ] <NEWLINE> dic [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_series = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bc . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> summed = sum ( a_series ) <NEWLINE> num = [ 0 for i in range ( 100005 ) ] <NEWLINE> <NL> for a in a_series : <NEWLINE> <INDENT> num [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> summed += ( ( bc [ i ] [ 1 ] - bc [ i ] [ 0 ] ) * num [ bc [ i ] [ 0 ] ] ) <NEWLINE> num [ bc [ i ] [ 1 ] ] += num [ bc [ i ] [ 0 ] ] <NEWLINE> num [ bc [ i ] [ 0 ] ] = 0 <NEWLINE> print ( summed ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for x in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( x , y ) <NEWLINE> for z in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total = total + math . gcd ( z , a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = sum ( s ) <NEWLINE> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if all ( [ i % 10 == 0 for i in s ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans - min ( [ i for i in s if i % 10 != 0 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += i * ( n * ( n + 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> answer = ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE> print ( <STRING> . format ( answer ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = b - a + 1 <NEWLINE> if n <= k * 2 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for j in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> ordn = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ordn . append ( - 1 ) <NEWLINE> <NL> <DEDENT> v = 1 <NEWLINE> while ( ordn [ v ] == - 1 ) : <NEWLINE> <INDENT> ordn [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <NL> <DEDENT> c = len ( s ) - ordn [ v ] <NEWLINE> l = ordn [ v ] <NEWLINE> <NL> if k < l : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = i <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> while k < n and l [ k ] < l [ i ] + l [ j ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> ans += k - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> num = [ ] <NEWLINE> num = input ( ) . split ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> if i != 4 : <NEWLINE> <INDENT> if int ( num [ i ] ) == 0 : <NEWLINE> <INDENT> print ( int ( num [ i + 1 ] ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif int ( num [ 4 ] ) == 0 : <NEWLINE> <INDENT> print ( int ( num [ i - 1 ] ) + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> from typing import Callable , ClassVar , Sequence , Type , TypeVar <NEWLINE> <NL> <NL> T = TypeVar ( <STRING> , bound = <STRING> ) <NEWLINE> <NL> <NL> class ModIntBase : <NEWLINE> <INDENT> value : int <NEWLINE> mod : ClassVar [ int ] <NEWLINE> fac : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> inv : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> finv : ClassVar [ Sequence [ int ] ] = ( ) <NEWLINE> <NL> def __init__ ( self , value : int ) -> None : <NEWLINE> <INDENT> self . value = value % self . mod <NEWLINE> <NL> <DEDENT> def __hash__ ( self ) -> int : <NEWLINE> <INDENT> return hash ( ( self . value , self . mod ) ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) -> bool : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . value == other . value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __ne__ ( self , other ) -> bool : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . value != other . value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( ( self . value + other . value ) % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( ( self . value - other . value ) % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> return self . __class__ ( self . value * other . value % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> a = other . value <NEWLINE> b = self . mod <NEWLINE> u = 1 <NEWLINE> v = 0 <NEWLINE> while b : <NEWLINE> <INDENT> t = a // b <NEWLINE> a , b = b , a - t * b <NEWLINE> u , v = v , u - t * v <NEWLINE> <DEDENT> return self . __class__ ( self . value * u % self . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , self . __class__ ) : <NEWLINE> <INDENT> v = 1 <NEWLINE> a = self . value <NEWLINE> b = other . value <NEWLINE> mod = self . mod <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> v = v * a % mod <NEWLINE> <DEDENT> a = a * a % mod <NEWLINE> b >>= 1 <NEWLINE> <DEDENT> return self . __class__ ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def comb ( cls , n : int , k : int ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return cls ( 0 ) <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return cls ( 0 ) <NEWLINE> <NL> <DEDENT> if n < len ( cls . fac ) : <NEWLINE> <INDENT> return cls ( cls . fac [ n ] * ( cls . finv [ k ] * cls . finv [ n - k ] % cls . mod ) % cls . mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = min ( k , n - k ) <NEWLINE> a = reduce ( mul , map ( cls , range ( n - k + 1 , n + 1 ) ) , cls ( 1 ) ) <NEWLINE> b = reduce ( mul , map ( cls , range ( 1 , k + 1 ) ) , cls ( 1 ) ) <NEWLINE> return a / b <NEWLINE> <NL> <DEDENT> <DEDENT> def __repr__ ( self ) -> str : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def __str__ ( self ) -> str : <NEWLINE> <INDENT> return str ( self . value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ModInt ( ModIntBase ) : <NEWLINE> <INDENT> mod = 1000000007 <COMMENT> <NEWLINE> <NL> <NL> <NL> <DEDENT> def resolve ( in_ ) : <NEWLINE> <INDENT> N , A , B = map ( int , in_ . readline ( ) . split ( ) ) <NEWLINE> <NL> c = ModInt ( 2 ) ** ModInt ( N ) - ModInt ( 1 ) <NEWLINE> a = ModInt . comb ( N , A ) <NEWLINE> b = ModInt . comb ( N , B ) <NEWLINE> <NL> return c - a - b <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> ret = 0 <NEWLINE> <NL> cnt += a <NEWLINE> ret += a <NEWLINE> if ( cnt > k ) : <NEWLINE> <INDENT> ret -= cnt - k <NEWLINE> <DEDENT> if ( cnt < k ) : <NEWLINE> <INDENT> cnt += b <NEWLINE> <DEDENT> if ( cnt < k ) : <NEWLINE> <INDENT> cnt += c <NEWLINE> ret -= c <NEWLINE> if ( cnt > k ) : <NEWLINE> <INDENT> ret += cnt - k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> t = sum ( a ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += a [ i ] * a [ i ] <NEWLINE> <NL> <DEDENT> ans = ( t * t - s ) // 2 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <NL> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> s *= a <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = 0 <NEWLINE> Mi = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] > Mi : <NEWLINE> <INDENT> Mi = A [ i ] <NEWLINE> <DEDENT> B += Mi - A [ i ] <NEWLINE> <DEDENT> print ( B ) <NEWLINE>
from numba import jit <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> @ jit <NEWLINE> def solve ( k , n , a ) : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> Y = [ 0 ] * ( n + 1 ) <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> Y [ max ( 0 , i - x ) ] += 1 <NEWLINE> Y [ min ( n , i + x + 1 ) ] -= 1 <NEWLINE> <DEDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> Y [ j ] += Y [ j - 1 ] <NEWLINE> <DEDENT> if a == Y [ : - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = Y [ : - 1 ] <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ans = solve ( K , N , A ) <NEWLINE> print ( * ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> def dfs ( v , tm ) : <NEWLINE> <INDENT> dts [ v ] = est [ v ] = tm + 1 <NEWLINE> child = 0 <NEWLINE> <NL> for i in adj [ v ] : <NEWLINE> <INDENT> if est [ i ] == float ( <STRING> ) : <NEWLINE> <INDENT> child += 1 <NEWLINE> parents [ i ] = v <NEWLINE> dfs ( i , tm + 1 ) <NEWLINE> est [ v ] = min ( est [ v ] , est [ i ] ) <NEWLINE> <NL> if parents [ v ] is None and child > 1 : aps [ v ] = True <NEWLINE> if parents [ v ] is not None and est [ i ] >= dts [ v ] : aps [ v ] = True <NEWLINE> <NL> <DEDENT> elif parents [ v ] != i : <NEWLINE> <INDENT> est [ v ] = min ( est [ v ] , dts [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> nv , ne = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj = [ [ ] for _ in range ( nv ) ] <NEWLINE> est = [ float ( <STRING> ) ] * nv <NEWLINE> parents = [ None ] * nv <NEWLINE> aps = [ False ] * nv <NEWLINE> dts = [ 0 ] * nv <NEWLINE> <NL> for _ in range ( ne ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> adj [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> for i in range ( nv ) : <NEWLINE> <INDENT> if aps [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import product <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ 0 ] * n <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> c [ i ] = inp [ 0 ] <NEWLINE> a [ i ] = inp [ 1 : ] <NEWLINE> <NL> <DEDENT> INIT = 10 ** 10 <NEWLINE> ans = INIT <NEWLINE> pat = list ( product ( [ 0 , 1 ] , repeat = n ) ) <NEWLINE> <NL> for p in pat : <NEWLINE> <INDENT> a_val = [ 0 ] * m <NEWLINE> c_yen = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> c_yen += c [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a_val [ j ] += a [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> flag = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a_val [ i ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = min ( ans , c_yen ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == INIT : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> LA = L [ : : - 1 ] <NEWLINE> LA = LA [ : - 1 ] <NEWLINE> LB = L [ 0 ] <NEWLINE> for i in LA : <NEWLINE> <INDENT> print ( i + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( LB ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> d = defaultdict ( int ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ p - 1 ] += x <NEWLINE> <DEDENT> visited = [ False ] * N <NEWLINE> cnt = [ 0 ] * N <NEWLINE> def dfs ( n , acc ) : <NEWLINE> <INDENT> cnt [ n ] = acc <NEWLINE> for m in edges [ n ] : <NEWLINE> <INDENT> if not visited [ m ] : <NEWLINE> <INDENT> visited [ m ] = True <NEWLINE> dfs ( m , acc + d [ m ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> visited [ 0 ] = True <NEWLINE> dfs ( 0 , d [ 0 ] ) <NEWLINE> print ( * cnt ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = 10 ** 5 <NEWLINE> a2 = [ 0 ] * ma <NEWLINE> for ii in a : <NEWLINE> <INDENT> a2 [ ii - 1 ] += 1 <NEWLINE> <NL> <DEDENT> def func ( a2 ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> for jj in range ( len ( a2 ) ) : <NEWLINE> <INDENT> r += a2 [ jj ] * ( jj + 1 ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> r = func ( a2 ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for ii in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> r += ( c - b ) * a2 [ b - 1 ] <NEWLINE> a2 [ c - 1 ] += a2 [ b - 1 ] <NEWLINE> a2 [ b - 1 ] = 0 <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( math . pi * r * r , 2 * math . pi * r ) ) <NEWLINE>
<STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> a = int ( input ( ) ) <NEWLINE> <NL> n = 10 <NEWLINE> m = 3 <NEWLINE> o = 4 <NEWLINE> h = [ <NEWLINE> <INDENT> [ <NEWLINE> <INDENT> [ 0 for i in range ( n ) ] <NEWLINE> for j in range ( m ) ] <NEWLINE> for k in range ( o ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> w , x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ w - 1 ] [ x - 1 ] [ y - 1 ] += z <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def makeFence ( ) : <NEWLINE> <INDENT> fence = <STRING> * 20 <NEWLINE> print ( fence ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def showRoom ( f ) : <NEWLINE> <INDENT> for k in range ( len ( f ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( f [ k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> + str ( f [ len ( f ) - 1 ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def showFloor ( b ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < len ( b ) : <NEWLINE> <INDENT> f = b [ j ] <NEWLINE> showRoom ( f ) <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def statusShow ( h ) : <NEWLINE> <INDENT> for i in range ( len ( h ) - 1 ) : <NEWLINE> <INDENT> b = h [ i ] <NEWLINE> showFloor ( b ) <NEWLINE> makeFence ( ) <NEWLINE> <DEDENT> showFloor ( h [ len ( h ) - 1 ] ) <NEWLINE> <NL> <DEDENT> statusShow ( h ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL>
<COMMENT> <NL> N = 1000000 <NEWLINE> isprimer = [ True for i in range ( N ) ] <NEWLINE> isprimer [ 0 ] , isprimer [ 1 ] = False , False <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if not isprimer [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , N , i ) : <NEWLINE> <INDENT> isprimer [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> num = eval ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 2 , num + 1 ) : <NEWLINE> <INDENT> if isprimer [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> t0 , a0 = 1 , 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t1 , a1 = map ( int , input ( ) . split ( ) ) <NEWLINE> f0 = t0 // t1 <NEWLINE> if t0 % t1 != 0 : f0 += 1 <NEWLINE> f1 = a0 // a1 <NEWLINE> if a0 % a1 != 0 : f1 += 1 <NEWLINE> f = max ( f0 , f1 ) <NEWLINE> t0 , a0 = t1 * f , a1 * f <NEWLINE> <NL> <DEDENT> print ( t0 + a0 ) <NEWLINE>
import math <NEWLINE> import statistics <NEWLINE> import collections <NEWLINE> a = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> g = [ input ( ) for _ in range ( a ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> g . sort ( ) <NEWLINE> <NL> ma = 0 <NEWLINE> count = 1 <NEWLINE> <COMMENT> <NL> for i in range ( a - 1 ) : <NEWLINE> <INDENT> if g [ i ] == g [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma = max ( ma , count ) <NEWLINE> count = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ma = max ( ma , count ) <NEWLINE> count = 1 <NEWLINE> ans = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( a - 1 ) : <NEWLINE> <INDENT> if g [ i ] == g [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count == ma : <NEWLINE> <INDENT> ans . append ( g [ i ] ) <NEWLINE> <DEDENT> count = 1 <NEWLINE> <DEDENT> <DEDENT> if count == ma : <NEWLINE> <INDENT> ans . append ( g [ - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = int ( s [ : 2 ] ) <NEWLINE> b = int ( s [ 2 : ] ) <NEWLINE> if 0 < a <= 12 and 0 < b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 99 and 0 < b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 0 < a <= 12 and b <= 99 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = [ * map ( lambda x : int ( x ) , input ( ) . split ( ) ) ] <NEWLINE> <NL> <COMMENT> <NL> def iterative_method ( final ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> min_table = { 0 : 0 } <NEWLINE> <NL> while ( i < final ) : <NEWLINE> <INDENT> if i + 1 in min_table : <NEWLINE> <INDENT> min_table [ i + 1 ] = min ( min_table [ i + 1 ] , min_table [ i ] + abs ( h [ i + 1 ] - h [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_table [ i + 1 ] = min_table [ i ] + abs ( h [ i + 1 ] - h [ i ] ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if i + 2 in min_table : <NEWLINE> <INDENT> min_table [ i + 2 ] = min ( min_table [ i + 2 ] , min_table [ i ] + abs ( h [ i + 2 ] - h [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_table [ i + 2 ] = min_table [ i ] + abs ( h [ i + 2 ] - h [ i ] ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( min_table [ final ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def recursive_method ( n ) : <NEWLINE> <INDENT> memo = [ - 1 ] * n <NEWLINE> memo [ 0 ] = 0 <NEWLINE> memo [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> def recurse ( i ) : <NEWLINE> <INDENT> if memo [ i ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] = min ( recurse ( i - 1 ) + abs ( h [ i ] - h [ i - 1 ] ) , recurse ( i - 2 ) + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> return memo [ i ] <NEWLINE> <DEDENT> <DEDENT> return recurse ( n - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( recursive_method ( N ) ) <NEWLINE>
p = 2019 <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> l = [ 0 for i in range ( p ) ] <NEWLINE> l [ 0 ] = 1 <NEWLINE> ten = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> ans = 0 <NEWLINE> if p == 2 or p == 5 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if int ( s [ i ] ) % p == 0 : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> cnt = ( cnt + int ( s [ - i - 1 ] ) * ten ) % p <NEWLINE> l [ cnt ] += 1 <NEWLINE> ten = ( ten * 10 ) % p <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> path = [ [ False ] * n for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> path [ a ] [ b ] = True <NEWLINE> path [ b ] [ a ] = True <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in itertools . permutations ( range ( n ) , n ) : <COMMENT> <NEWLINE> <INDENT> if i [ 0 ] == 0 : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j == n - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> if not path [ i [ j ] ] [ i [ j + 1 ] ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math , sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from functools import lru_cache <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import accumulate , combinations , permutations <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ns = lambda : input ( ) . strip ( ) <NEWLINE> ni = lambda : int ( input ( ) . strip ( ) ) <NEWLINE> nm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , x = nm ( ) <NEWLINE> arr = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> temp = nl ( ) <NEWLINE> arr . append ( temp ) <NEWLINE> <NL> <DEDENT> costs = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> binary = bin ( i ) [ 2 : ] <NEWLINE> binary = <STRING> * ( n - len ( binary ) ) + binary <NEWLINE> count = [ 0 ] * m <NEWLINE> cost = 0 <NEWLINE> for i , num in enumerate ( binary ) : <NEWLINE> <INDENT> if num == <STRING> : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> count [ j ] += arr [ i ] [ j + 1 ] <NEWLINE> <DEDENT> cost += arr [ i ] [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> flag = True <NEWLINE> for value in count : <NEWLINE> <INDENT> if value < x : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> costs . append ( cost ) <NEWLINE> <DEDENT> <DEDENT> if costs == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( costs ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 0 , n + 1 , r ) : <NEWLINE> <INDENT> for j in range ( 0 , n + 1 - i , g ) : <NEWLINE> <INDENT> if ( n - i - j ) % b == 0 and ( n - i - j ) % b >= 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 for i in range ( c + 1 ) ] for j in range ( r + 1 ) ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> sumC = 0 <NEWLINE> ar = input ( ) . split ( ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> a [ i ] [ j ] = int ( ar [ j ] ) <NEWLINE> sumC += int ( ar [ j ] ) <NEWLINE> <DEDENT> a [ i ] [ c ] = sumC <NEWLINE> <NL> <DEDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> for m in range ( r ) : <NEWLINE> <INDENT> a [ r ] [ k ] += a [ m ] [ k ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> k = 0 <NEWLINE> while N != i : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x ** 2 + y ** 2 ) <= D ** 2 : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( k ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = range ( a , b + 1 ) <NEWLINE> for i in sorted ( set ( n [ : k ] ) | set ( n [ - k : ] ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - n % 1000 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ 1 if i == <STRING> else 2 if i == <STRING> else 4 for i in input ( ) ] <NEWLINE> r = s . count ( 1 ) <NEWLINE> g = s . count ( 2 ) <NEWLINE> b = s . count ( 4 ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , ( n - i - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if s [ i ] + s [ i + j ] + s [ i + j + j ] == 7 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> s . reverse ( ) <NEWLINE> len_s = len ( s ) <NEWLINE> t = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if t == len_s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif t > len_s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> . join ( s [ t : t + 5 ] ) == <STRING> : <NEWLINE> <INDENT> t += 5 <NEWLINE> <DEDENT> elif <STRING> . join ( s [ t : t + 7 ] ) == <STRING> : <NEWLINE> <INDENT> t += 7 <NEWLINE> <DEDENT> elif <STRING> . join ( s [ t : t + 5 ] ) == <STRING> : <NEWLINE> <INDENT> t += 5 <NEWLINE> <DEDENT> elif <STRING> . join ( s [ t : t + 6 ] ) == <STRING> : <NEWLINE> <INDENT> t += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> best_num_char = 0 <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> num_char = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> num_char += 1 if S [ i + j ] == T [ j ] else 0 <NEWLINE> <COMMENT> <NL> <DEDENT> if best_num_char < num_char : <NEWLINE> <INDENT> best_num_char = num_char <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( len ( T ) - best_num_char ) <NEWLINE>
seen = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> seen [ 0 ] , seen [ 1 ] , seen [ 2 ] = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> seen [ 3 ] , seen [ 4 ] , seen [ 5 ] = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> seen [ 6 ] , seen [ 7 ] , seen [ 8 ] = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> over = <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num in seen : <NEWLINE> <INDENT> seen [ seen . index ( num ) ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if seen [ 0 ] == <STRING> : <NEWLINE> <INDENT> if seen [ 1 ] == <STRING> and seen [ 2 ] == <STRING> : <NEWLINE> <INDENT> over = <STRING> <NEWLINE> <DEDENT> if seen [ 3 ] == <STRING> and seen [ 6 ] == <STRING> : <NEWLINE> <INDENT> over = <STRING> <NEWLINE> <DEDENT> if seen [ 4 ] == <STRING> and seen [ 8 ] == <STRING> : <NEWLINE> <INDENT> over = <STRING> <NEWLINE> <DEDENT> <DEDENT> if seen [ 8 ] == <STRING> : <NEWLINE> <INDENT> if seen [ 6 ] == <STRING> and seen [ 7 ] == <STRING> : <NEWLINE> <INDENT> over = <STRING> <NEWLINE> <DEDENT> if seen [ 2 ] == <STRING> and seen [ 5 ] == <STRING> : <NEWLINE> <INDENT> over = <STRING> <NEWLINE> <DEDENT> <DEDENT> if seen [ 4 ] == <STRING> : <NEWLINE> <INDENT> if seen [ 6 ] == <STRING> and seen [ 2 ] == <STRING> : <NEWLINE> <INDENT> over = <STRING> <NEWLINE> <DEDENT> if seen [ 1 ] == <STRING> and seen [ 7 ] == <STRING> : <NEWLINE> <INDENT> over = <STRING> <NEWLINE> <DEDENT> if seen [ 3 ] == <STRING> and seen [ 5 ] == <STRING> : <NEWLINE> <INDENT> over = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( over ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for m in range ( N ) : <NEWLINE> <INDENT> A . append ( B [ m ] ) <NEWLINE> <DEDENT> place = set ( [ ] ) <NEWLINE> p = [ ] <NEWLINE> i = 1 <NEWLINE> count = 0 <NEWLINE> while i not in place : <NEWLINE> <INDENT> place . add ( i ) <NEWLINE> p . append ( i ) <NEWLINE> i = A [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> if count > K : <NEWLINE> <INDENT> print ( p [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = [ i ] <NEWLINE> start = i <NEWLINE> j = A [ i ] <NEWLINE> count += 1 <NEWLINE> while j != start : <NEWLINE> <INDENT> loop . append ( j ) <NEWLINE> j = A [ j ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> if count > K : <NEWLINE> <INDENT> print ( loop [ K - len ( p ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( K - count ) % len ( loop ) <NEWLINE> print ( loop [ num ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n // 2 if n % 2 == 1 else ( n - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from collections import defaultdict , Counter <NEWLINE> def saiki ( cnts ) : <NEWLINE> <INDENT> hitomozi = [ ] <NEWLINE> d = defaultdict ( lambda : [ ] ) <NEWLINE> heads = defaultdict ( lambda : 0 ) <NEWLINE> for s , c in cnts : <NEWLINE> <INDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> hitomozi . append ( s [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k , v in c . items ( ) : <NEWLINE> <INDENT> if v > 0 : <NEWLINE> <INDENT> heads [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> t = s [ - 1 ] <NEWLINE> c [ t ] -= 1 <NEWLINE> s . pop ( - 1 ) <NEWLINE> d [ t ] . append ( [ s , c ] ) <NEWLINE> <DEDENT> <DEDENT> for h in hitomozi : <NEWLINE> <INDENT> ans [ 0 ] += heads [ h ] <NEWLINE> <DEDENT> for v in d . values ( ) : <NEWLINE> <INDENT> if len ( v ) <= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> saiki ( v ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = [ 0 ] <NEWLINE> cnts = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> cnts . append ( [ s , Counter ( s ) ] ) <NEWLINE> <DEDENT> saiki ( cnts ) <NEWLINE> print ( ans [ 0 ] ) <NEWLINE>
def phi ( n ) : <NEWLINE> <INDENT> res = n <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> res = res // i * ( i - 1 ) <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> res = res // n * ( n - 1 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def divisors ( n ) : <NEWLINE> <INDENT> sq = int ( n ** .5 ) <NEWLINE> res = ( ( i , n // i ) for i in range ( 1 , sq + 1 ) if n % i == 0 ) <NEWLINE> from itertools import chain <NEWLINE> flatten = chain . from_iterable <NEWLINE> return sorted ( set ( flatten ( res ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def f ( K ) : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> if K % 7 == 0 : <NEWLINE> <INDENT> L //= 7 <NEWLINE> <DEDENT> r1 = phi ( L ) <NEWLINE> for d in divisors ( r1 ) : <NEWLINE> <INDENT> if pow ( 10 , d , L ) == 1 : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> res = f ( K ) <NEWLINE> print ( res ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total_a , total_b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total_a . append ( total_a [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> total_b . append ( total_b [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if total_a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while total_b [ j ] > k - total_a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> data = [ ] <NEWLINE> count = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> data . append ( line . split ( ) ) <NEWLINE> <DEDENT> s = list ( map ( int , data [ 1 ] ) ) <NEWLINE> n = int ( data [ 0 ] [ 0 ] ) <NEWLINE> q = int ( data [ 2 ] [ 0 ] ) <NEWLINE> t = list ( map ( int , data [ 3 ] ) ) <NEWLINE> for i in range ( 0 , q ) : <NEWLINE> <INDENT> head = 0 <NEWLINE> tail = n - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if head > tail : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> center = ( head + tail ) // 2 <NEWLINE> if s [ center ] == t [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> break <NEWLINE> <DEDENT> elif s [ center ] < t [ i ] : <NEWLINE> <INDENT> head = center + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail = center - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> def add ( a , b ) : <NEWLINE> <INDENT> return ( a + b ) % mod <NEWLINE> <NL> <DEDENT> def mul ( a , b ) : <NEWLINE> <INDENT> return ( ( a % mod ) * ( b % mod ) ) % mod <NEWLINE> <NL> <DEDENT> def cumsum ( xs ) : <NEWLINE> <INDENT> result = [ xs [ 0 ] ] <NEWLINE> for x in xs [ 1 : ] : <NEWLINE> <INDENT> result . append ( add ( result [ - 1 ] , x ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> inv = cumsum ( list ( reversed ( A ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> c = add ( c , mul ( A [ i ] , inv [ N - i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> HW_L = set ( tuple ( int ( x ) - 1 for x in input ( ) . split ( ) ) for y in range ( M ) ) <NEWLINE> <NL> w_l = [ 0 ] * W <NEWLINE> h_l = [ 0 ] * H <NEWLINE> <NL> for _hi , _wi in HW_L : <NEWLINE> <INDENT> w_l [ _wi ] += 1 <NEWLINE> h_l [ _hi ] += 1 <NEWLINE> <NL> <DEDENT> max_h = max ( h_l ) <NEWLINE> max_w = max ( w_l ) <NEWLINE> <NL> h_idx = [ i for i , x in enumerate ( h_l ) if x == max_h ] <NEWLINE> w_idx = [ i for i , x in enumerate ( w_l ) if x == max_w ] <NEWLINE> <NL> ans = max_h + max_w - 1 <NEWLINE> <NL> for hi in h_idx : <NEWLINE> <INDENT> for wj in w_idx : <NEWLINE> <INDENT> if ( hi , wj ) not in HW_L : <NEWLINE> <INDENT> ans = max_h + max_w <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> koho = [ i for i in range ( - 100 , 200 ) if i not in P ] <NEWLINE> <NL> koho . sort ( key = lambda a : ( abs ( a - x ) , a ) ) <NEWLINE> <NL> print ( koho [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> lis = [ 0 ] * 1000 <NEWLINE> one = [ 0 ] * 10 <NEWLINE> two = [ 0 ] * 100 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> temp1 = int ( s [ i ] ) <NEWLINE> if one [ temp1 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> one [ temp1 ] = 1 <NEWLINE> <NL> <DEDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> temp2 = int ( <STRING> . join ( [ s [ i ] , s [ j ] ] ) ) <NEWLINE> if two [ temp2 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> two [ temp2 ] = 1 <NEWLINE> <NL> <DEDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> pin = int ( <STRING> . join ( [ s [ i ] , s [ j ] , s [ k ] ] ) ) <NEWLINE> if lis [ pin ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> lis [ pin ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> D = int ( A * B / math . gcd ( A , B ) ) <NEWLINE> maxi = 0 <NEWLINE> if B - 1 <= N : <NEWLINE> <INDENT> print ( int ( ( B - 1 ) % B * A / B - ( A * ( B - 1 ) ) % B / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( N % B * A / B - ( A * N ) % B / B ) ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b_list = [ int ( b [ 0 ] ) , int ( b [ 2 ] ) , int ( b [ 3 ] ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> ans += a * b_list [ i ] * 10 ** ( 2 - i ) <NEWLINE> <DEDENT> ans = ans // 100 <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> r = <STRING> <NEWLINE> for i , v in enumerate ( s ) : <NEWLINE> <INDENT> if v != <STRING> : <NEWLINE> <INDENT> r = v <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i >= k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nodes = { } <NEWLINE> self . nodes [ - 1 ] = None <NEWLINE> <DEDENT> def add_node ( self , id ) : <NEWLINE> <INDENT> if id not in self . nodes : <NEWLINE> <INDENT> self . nodes [ id ] = Node ( id ) <NEWLINE> <DEDENT> <DEDENT> def add_child ( self , parent_id , left_id , right_id ) : <NEWLINE> <INDENT> self . add_node ( parent_id ) <NEWLINE> self . add_node ( left_id ) <NEWLINE> self . add_node ( right_id ) <NEWLINE> self . nodes [ parent_id ] . add_child ( self . nodes [ left_id ] , self . nodes [ right_id ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . parent = self . left = self . right = None <NEWLINE> self . depth = self . height = 0 <NEWLINE> <NL> <DEDENT> def add_child ( self , left , right ) : <NEWLINE> <INDENT> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> self . update_height ( ) <NEWLINE> <NL> for child in self . children ( ) : <NEWLINE> <INDENT> child . parent = self <NEWLINE> child . update_depth ( ) <NEWLINE> <DEDENT> <DEDENT> def update_height ( self ) : <NEWLINE> <INDENT> if self . degree ( ) : <NEWLINE> <INDENT> self . height = max ( [ child . height + 1 for child in self . children ( ) ] ) <NEWLINE> if self . parent : <NEWLINE> <INDENT> self . parent . update_height ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def update_depth ( self ) : <NEWLINE> <INDENT> self . depth = self . parent . depth + 1 <NEWLINE> for child in self . children ( ) : <NEWLINE> <INDENT> child . update_depth ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def nodetype ( self ) : <NEWLINE> <INDENT> if self . parent : <NEWLINE> <INDENT> if self . degree ( ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> def degree ( self ) : <NEWLINE> <INDENT> return len ( self . children ( ) ) <NEWLINE> <NL> <DEDENT> def children ( self ) : <NEWLINE> <INDENT> return [ child for child in [ self . left , self . right ] if child ] <NEWLINE> <NL> <DEDENT> def sibling ( self ) : <NEWLINE> <INDENT> if self . parent and self . parent . degree ( ) == 2 : <NEWLINE> <INDENT> if self . parent . left == self : <NEWLINE> <INDENT> return self . parent . right . id <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . parent . left . id <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( <NEWLINE> <INDENT> self . id , <NEWLINE> self . parent . id if self . parent else - 1 , <NEWLINE> self . sibling ( ) , <NEWLINE> self . degree ( ) , <NEWLINE> self . depth , <NEWLINE> self . height , <NEWLINE> self . nodetype ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> id , left , right = map ( int , input ( ) . split ( ) ) <NEWLINE> tree . add_child ( id , left , right ) <NEWLINE> <NL> <DEDENT> for id in tree . nodes : <NEWLINE> <INDENT> if id != - 1 : <NEWLINE> <INDENT> print ( tree . nodes [ id ] ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> A = [ ] <NEWLINE> <NL> for k in range ( K ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> Alist = [ e for row in A for e in row ] <NEWLINE> <NL> L = len ( list ( set ( Alist ) ) ) <NEWLINE> print ( N - L ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> li . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( li ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ ] <NEWLINE> tf_visited = [ 0 ] * n <NEWLINE> pos = 0 <NEWLINE> count = 0 <NEWLINE> <NL> while tf_visited [ pos ] == 0 : <NEWLINE> <INDENT> visited . append ( pos ) <NEWLINE> tf_visited [ pos ] = 1 <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> count += 1 <NEWLINE> if count >= k : <NEWLINE> <INDENT> print ( pos + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> loop_start = visited . index ( pos ) <NEWLINE> loop_length = len ( visited ) - loop_start <NEWLINE> pos_t = ( k - loop_start ) % loop_length + loop_start <NEWLINE> print ( visited [ pos_t ] + 1 ) <NEWLINE>
from numba import njit <NEWLINE> from numpy import int32 , zeros , arange <NEWLINE> @ njit ( <STRING> ) <NEWLINE> def solve ( s ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> d = zeros ( 2019 , int32 ) <NEWLINE> for i in s : <NEWLINE> <INDENT> p = zeros ( 2019 , int32 ) <NEWLINE> for j in range ( 2019 ) : p [ ( j * 10 + i ) % 2019 ] += d [ j ] <NEWLINE> d = p <NEWLINE> d [ i ] += 1 <NEWLINE> a += d [ 0 ] <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> print ( solve ( int32 ( [ * input ( ) ] ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> if A [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ N - 1 - i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import copy <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 9 * 15 <NEWLINE> for i in range ( 2 ** ( N - 1 ) ) : <COMMENT> <NEWLINE> <INDENT> B = copy . copy ( A ) <NEWLINE> count = 0 <NEWLINE> bit = 0 <NEWLINE> for j in range ( N - 1 ) : <COMMENT> <NEWLINE> <INDENT> bit = bit + ( 1 & ( i >> j ) ) <NEWLINE> <DEDENT> if ( bit == K - 1 ) : <COMMENT> <NEWLINE> <INDENT> for k in range ( N - 1 ) : <NEWLINE> <INDENT> if ( i >> k & 1 ) : <NEWLINE> <INDENT> if max ( B [ 0 : k + 1 ] ) >= B [ k + 1 ] : <COMMENT> <NEWLINE> <INDENT> dif = max ( B [ 0 : k + 1 ] ) - B [ k + 1 ] + 1 <NEWLINE> B [ k + 1 ] += dif <COMMENT> <NEWLINE> count += dif <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( x , y ) , z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> <DEDENT> print ( f ( min ( N , B - 1 ) ) ) <NEWLINE>
N , K = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> stack = [ ] <NEWLINE> done = [ 0 for i in range ( 2 * ( 10 ** 5 ) ) ] <NEWLINE> done [ 0 ] = 0 <NEWLINE> now = 0 <NEWLINE> dou = [ ] <NEWLINE> <NL> while ( done [ now ] < 2 ) : <NEWLINE> <NL> <INDENT> if done [ now ] == 0 : <NEWLINE> <INDENT> stack . append ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dou . append ( now ) <NEWLINE> <DEDENT> done [ now ] += 1 <NEWLINE> now = A [ now ] - 1 <NEWLINE> <NL> <DEDENT> if K < len ( stack ) : <NEWLINE> <INDENT> print ( stack [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dou [ ( K - len ( stack ) - len ( dou ) ) % len ( dou ) ] + 1 ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> if ( a + v * t ) >= ( b + w * t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( a - v * t ) <= ( b - w * t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from functools import reduce <NEWLINE> n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> tmp_max = sum ( [ i / 2 + 0.5 for i in p [ 0 : k ] ] ) <NEWLINE> tmp = tmp_max <NEWLINE> idx = 0 <NEWLINE> for i in range ( 1 , len ( p ) - k + 1 ) : <NEWLINE> <INDENT> tmp -= p [ i - 1 ] / 2 + 0.5 <NEWLINE> if i + k - 1 < len ( p ) : <NEWLINE> <INDENT> tmp += p [ i + k - 1 ] / 2 + 0.5 <NEWLINE> <DEDENT> tmp_max = max ( tmp_max , tmp ) <NEWLINE> <DEDENT> print ( tmp_max ) <NEWLINE>
from collections import defaultdict <NEWLINE> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> grid [ h ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> number_yx = [ [ 0 , 0 ] for _ in range ( H * W + 1 ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> number_yx [ grid [ y ] [ x ] ] = [ y , x ] <NEWLINE> <DEDENT> <DEDENT> fromto_cost = defaultdict ( lambda : defaultdict ( int ) ) <NEWLINE> for mod_group in range ( D ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = mod_group + 1 <NEWLINE> previous = start <NEWLINE> fromto_cost [ start ] [ start ] = 0 <NEWLINE> previous_y , previous_x = number_yx [ previous ] <NEWLINE> cost = 0 <NEWLINE> while previous + D <= ( H * W ) : <NEWLINE> <INDENT> Next = previous + D <NEWLINE> Next_y , Next_x = number_yx [ Next ] <NEWLINE> cost += abs ( Next_y - previous_y ) + abs ( Next_x - previous_x ) <NEWLINE> fromto_cost [ start ] [ Next ] = cost <NEWLINE> <NL> previous = Next <NEWLINE> previous_y , previous_x = Next_y , Next_x <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> ans_ls = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> start , goal = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = start % D <NEWLINE> base = mod <NEWLINE> if base == 0 : <NEWLINE> <INDENT> base = D <NEWLINE> <DEDENT> base_to_goal = fromto_cost [ base ] [ goal ] <NEWLINE> base_to_start = fromto_cost [ base ] [ start ] <NEWLINE> ans_ls [ i ] = base_to_goal - base_to_start <NEWLINE> <DEDENT> for ans in ans_ls : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def isinsums ( x , lst ) : <NEWLINE> <INDENT> s = sum ( lst ) <NEWLINE> t = ( s + x ) // 2 <NEWLINE> if s == 0 and x == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( s - x ) % 2 or t < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> t = ( s + x ) // 2 <NEWLINE> m1 = ( 1 << ( t + 1 ) ) - 1 <NEWLINE> m2 = 1 << t <NEWLINE> sums = 0 <NEWLINE> for e in lst : <NEWLINE> <INDENT> sums = ( sums | ( 1 + sums ) << e ) & m1 <NEWLINE> <DEDENT> sums |= 1 <NEWLINE> if ( sums ) & m2 > 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> s = readline ( ) . strip ( ) <NEWLINE> x , y = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> bs = s . split ( ) <NEWLINE> if bs [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> x -= len ( bs [ 0 ] ) <NEWLINE> del bs [ 0 ] <NEWLINE> <NL> <DEDENT> xy = [ [ ] , [ ] ] <NEWLINE> f = 0 <NEWLINE> for i , e in enumerate ( bs ) : <NEWLINE> <INDENT> if not i % 2 : <NEWLINE> <INDENT> l = len ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f ^= l % 2 <NEWLINE> xy [ f ] . append ( len ( e ) ) <NEWLINE> <DEDENT> <DEDENT> if isinsums ( x , xy [ 0 ] ) and isinsums ( y , xy [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = ( input ( ) [ : : - 1 ] ) <COMMENT> <NEWLINE> n = len ( s ) <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> b = 1 <NEWLINE> num = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> num += int ( i ) * b <NEWLINE> num %= 2019 <NEWLINE> b *= 10 <NEWLINE> b %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for j in counts : <NEWLINE> <INDENT> ans += j * ( j - 1 ) / 2 <NEWLINE> <NL> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for a in range ( - 150 , 150 ) : <NEWLINE> <INDENT> for b in range ( - 150 , 150 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> print ( a , b ) <NEWLINE>
from sys import exit <NEWLINE> INF = 1 << 32 <NEWLINE> V , E = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> s = [ 0 ] * E <NEWLINE> t = [ 0 ] * E <NEWLINE> d = [ 0 ] * E <NEWLINE> dist = [ [ INF for _ in range ( V ) ] for __ in range ( V ) ] <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> dist [ i ] [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( E ) : <NEWLINE> <INDENT> s [ i ] , t [ i ] , d [ i ] = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> dist [ s [ i ] ] [ t [ i ] ] = d [ i ] <NEWLINE> <NL> <DEDENT> for k in range ( V ) : <NEWLINE> <INDENT> for i in range ( V ) : <NEWLINE> <INDENT> if ( dist [ i ] [ k ] == INF ) : continue <NEWLINE> for j in range ( V ) : <NEWLINE> <INDENT> if ( dist [ k ] [ j ] == INF ) : continue <NEWLINE> dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( V ) : <NEWLINE> <INDENT> if dist [ i ] [ i ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( V ) : <NEWLINE> <INDENT> for j in range ( V ) : <NEWLINE> <INDENT> if j != V - 1 : <NEWLINE> <INDENT> print ( dist [ i ] [ j ] if dist [ i ] [ j ] != INF else <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ i ] [ j ] if dist [ i ] [ j ] != INF else <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> line = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> line [ a - 1 ] . append ( b - 1 ) <NEWLINE> line [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> check = [ False ] * N <NEWLINE> <NL> def dfs ( now ) : <NEWLINE> <INDENT> global cnt <NEWLINE> global ans <NEWLINE> if cnt == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in line [ now ] : <NEWLINE> <INDENT> if check [ i ] == False : <NEWLINE> <INDENT> check [ i ] = True <NEWLINE> cnt += 1 <NEWLINE> dfs ( i ) <NEWLINE> check [ i ] = False <NEWLINE> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> check [ 0 ] = True <NEWLINE> cnt = 1 <NEWLINE> ans = 0 <NEWLINE> dfs ( 0 ) <NEWLINE> print ( ans ) <NEWLINE>
<NL> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for a in range ( 1 , x // 3 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , x // 2 ) : <NEWLINE> <INDENT> c = x - a - b <NEWLINE> if b < c <= n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , l <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> hist = [ 0 ] * 61 <NEWLINE> bs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> s = bin ( a [ i ] ) [ 2 : ] <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> hist [ len ( s ) - j - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> b = 1 <NEWLINE> for j in range ( 61 ) : <NEWLINE> <INDENT> sum = ( sum + ( hist [ j ] * ( n - hist [ j ] ) * b ) % MOD ) % MOD <NEWLINE> b *= 2 <NEWLINE> <NL> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , l = readinput ( ) <NEWLINE> ans = main ( n , l ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
mod = 2019 <NEWLINE> a = input ( ) <NEWLINE> <NL> N = len ( a ) <NEWLINE> t = [ 0 ] * mod <NEWLINE> t [ 0 ] = 1 <NEWLINE> <NL> w = 1 <NEWLINE> u = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> u = int ( a [ N - 1 - i ] ) * w + u <NEWLINE> v = u % mod <NEWLINE> t [ v ] += 1 <NEWLINE> w *= 10 <NEWLINE> w %= mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> ans += ( i - 1 ) * i // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> isnewLine = False <NEWLINE> <NL> pattern = { <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> } <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <NL> <INDENT> if isnewLine : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> isnewLine = True <NEWLINE> <NL> <DEDENT> line = line [ : - 1 ] <NEWLINE> <NL> line = <STRING> * ( 5 - len ( line ) ) + line <NEWLINE> <NL> bar = [ pattern [ item ] for item in line ] <NEWLINE> <NL> for i1 , i2 , i3 , i4 , i5 in zip ( bar [ 0 ] , bar [ 1 ] , bar [ 2 ] , bar [ 3 ] , bar [ 4 ] ) : <NEWLINE> <INDENT> print ( i1 + i2 + i3 + i4 + i5 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import math <NEWLINE> import time <NEWLINE> import numpy as np <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 7 == 0 : <NEWLINE> <INDENT> l = k * 9 // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = k * 9 <NEWLINE> <DEDENT> q = 10 % l <NEWLINE> for i in range ( 1 , 1000000 ) : <NEWLINE> <INDENT> if q == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = ( q * 10 ) % l <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> N , Q = MI ( ) <NEWLINE> Edge = [ [ ] for _ in range ( N ) ] <NEWLINE> Point = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> Edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> Edge [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = MI ( ) <NEWLINE> Point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( now , pre = - 1 ) : <NEWLINE> <INDENT> for nxt in Edge [ now ] : <NEWLINE> <INDENT> if nxt == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> Point [ nxt ] += Point [ now ] <NEWLINE> dfs ( nxt , now ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * Point ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ps = set ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ps . add ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ps = list ( ps ) <NEWLINE> ps . sort ( ) <NEWLINE> <NL> def cross3 ( a , b , c ) : <NEWLINE> <INDENT> return ( b [ 0 ] - a [ 0 ] ) * ( c [ 1 ] - a [ 1 ] ) - ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - a [ 0 ] ) <NEWLINE> <NL> <DEDENT> def cross ( a , b , c , d ) : <NEWLINE> <INDENT> return ( b [ 0 ] - a [ 0 ] ) * ( d [ 1 ] - c [ 1 ] ) - ( b [ 1 ] - a [ 1 ] ) * ( d [ 0 ] - c [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def convex_hull ( ps ) : <NEWLINE> <INDENT> qs = [ ] <NEWLINE> N = len ( ps ) <NEWLINE> for p in ps : <NEWLINE> <COMMENT> <NL> <INDENT> while len ( qs ) > 1 and cross3 ( qs [ - 1 ] , qs [ - 2 ] , p ) > 0 : <NEWLINE> <INDENT> qs . pop ( ) <NEWLINE> <DEDENT> qs . append ( p ) <NEWLINE> <DEDENT> t = len ( qs ) <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> p = ps [ i ] <NEWLINE> while len ( qs ) > t and cross3 ( qs [ - 1 ] , qs [ - 2 ] , p ) > 0 : <NEWLINE> <INDENT> qs . pop ( ) <NEWLINE> <DEDENT> qs . append ( p ) <NEWLINE> <DEDENT> return qs <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def dist ( a , b ) : <NEWLINE> <INDENT> return abs ( a [ 0 ] - b [ 0 ] ) + abs ( a [ 1 ] - b [ 1 ] ) <NEWLINE> <NL> <DEDENT> def rotating_calipers ( ps ) : <NEWLINE> <INDENT> qs = convex_hull ( ps ) <NEWLINE> n = len ( qs ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> return dist ( qs [ 0 ] , qs [ 1 ] ) <NEWLINE> <DEDENT> i = j = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if qs [ k ] < qs [ i ] : i = k <NEWLINE> if qs [ j ] < qs [ k ] : j = k <NEWLINE> <DEDENT> res = 0 <NEWLINE> si = i ; sj = j <NEWLINE> while i != sj or j != si : <NEWLINE> <INDENT> res = max ( res , dist ( qs [ i ] , qs [ j ] ) ) <NEWLINE> if cross ( qs [ i ] , qs [ i - n + 1 ] , qs [ j ] , qs [ j - n + 1 ] ) < 0 : <NEWLINE> <INDENT> i = ( i + 1 ) % n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = ( j + 1 ) % n <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if len ( ps ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif len ( ps ) == 2 : <NEWLINE> <INDENT> print ( dist ( ps [ 0 ] , ps [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( rotating_calipers ( ps ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Q = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> Q . append ( [ b , c ] ) <NEWLINE> <NL> <DEDENT> Q = sorted ( Q , key = lambda x : x [ 1 ] , reverse = 1 ) <NEWLINE> kae = 0 <NEWLINE> <NL> d = [ - 1 ] * ( n ) <NEWLINE> now = 0 <NEWLINE> for l in Q : <NEWLINE> <INDENT> b , c = l <NEWLINE> if n - now < b : <NEWLINE> <INDENT> d [ now : ] = [ c ] * ( n - now ) <NEWLINE> break <NEWLINE> <DEDENT> d [ now : now + b ] = [ c ] * b <NEWLINE> now += b <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = sum ( A ) <NEWLINE> now = ans <NEWLINE> for kae in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> now += d [ kae - 1 ] <NEWLINE> now -= A [ kae - 1 ] <NEWLINE> ans = max ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> e = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> e [ x - 1 ] . append ( i ) <NEWLINE> <NL> <DEDENT> def dfs ( x ) : <NEWLINE> <NL> <INDENT> count = len ( e [ x ] ) <NEWLINE> if count == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> d = defaultdict ( int ) <NEWLINE> ma = 0 <NEWLINE> s = set ( ) <NEWLINE> for nex in e [ x ] : <NEWLINE> <INDENT> v = dfs ( nex ) <NEWLINE> d [ v ] += 1 <NEWLINE> s . add ( v ) <NEWLINE> ma = max ( ma , v ) <NEWLINE> <DEDENT> now = count <NEWLINE> bef = 0 <NEWLINE> for v in sorted ( list ( s ) , reverse = True ) : <NEWLINE> <INDENT> bef += d [ v ] <NEWLINE> now = max ( now , bef + v ) <NEWLINE> <DEDENT> return now <NEWLINE> <NL> <DEDENT> print ( dfs ( 0 ) ) <NEWLINE>
import bisect <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Q = [ ] <NEWLINE> P = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> Q . append ( [ p , y ] ) <NEWLINE> P [ p - 1 ] . append ( y ) <NEWLINE> <NL> <DEDENT> P_1 = [ sorted ( l ) for l in P ] <NEWLINE> <NL> for p , y in Q : <NEWLINE> <INDENT> a = str ( p ) . zfill ( 6 ) <NEWLINE> b = str ( bisect . bisect ( P_1 [ p - 1 ] , y ) ) . zfill ( 6 ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ( int ( v ) + 1 ) / 2 for v in input ( ) . split ( ) ] <NEWLINE> e = [ sum ( p [ : k ] ) ] <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> e . append ( e [ - 1 ] - p [ i ] + p [ i + k ] ) <NEWLINE> <DEDENT> print ( max ( e ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> C = str ( input ( ) ) <NEWLINE> count = C . count ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( count ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * math . pi ) , <STRING> . format ( 2 * r * math . pi ) ) <NEWLINE>
num_employee = int ( input ( ) ) <NEWLINE> num_subordinate = [ 0 ] * num_employee <NEWLINE> <NL> for boss in map ( int , input ( ) . split ( <STRING> ) ) : <NEWLINE> <INDENT> num_subordinate [ boss - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , num_subordinate ) ) ) <NEWLINE>
class Vector : <NEWLINE> <NL> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> def move ( self , offset ) : <NEWLINE> <INDENT> self . x += offset [ 0 ] <NEWLINE> self . y += offset [ 1 ] <NEWLINE> <NL> <DEDENT> def move_offset ( self , offset , multiple = 1 ) : <NEWLINE> <INDENT> x = self . x + offset [ 0 ] * multiple <NEWLINE> y = self . y + offset [ 1 ] * multiple <NEWLINE> return Vector ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> NOTHING = <STRING> <NEWLINE> EXIST = <STRING> <NEWLINE> SENTINEL = <STRING> <NEWLINE> <NL> MOVE = [ <NEWLINE> <INDENT> [ [ - 1 , - 1 ] , [ - 1 , + 0 ] , [ - 1 , + 1 ] ] , <NEWLINE> [ [ - 1 , + 1 ] , [ - 0 , + 1 ] , [ + 1 , + 1 ] ] , <NEWLINE> [ [ + 1 , + 1 ] , [ + 1 , + 0 ] , [ + 1 , - 1 ] ] , <NEWLINE> [ [ + 1 , - 1 ] , [ + 0 , - 1 ] , [ - 1 , - 1 ] ] , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <NL> def create_area ( size ) : <NEWLINE> <INDENT> area = [ [ SENTINEL ] * 2 + [ NOTHING ] * size + [ SENTINEL ] * 2 for _ in range ( size ) ] <NEWLINE> tmp = [ [ SENTINEL ] * size + [ SENTINEL ] * 2 * 2 ] <NEWLINE> area = tmp * 2 + area + tmp * 2 <NEWLINE> return area <NEWLINE> <NL> <NL> <DEDENT> def even_spiral_pattern ( area , point ) : <NEWLINE> <INDENT> move_index = 0 <NEWLINE> area [ point . x ] [ point . y ] = EXIST <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> left , center , right = MOVE [ move_index ] <NEWLINE> end1 , end2 = point . move_offset ( left ) , point . move_offset ( right ) <NEWLINE> offset , offset2 = point . move_offset ( center ) , point . move_offset ( center , 2 ) <NEWLINE> <NL> if area [ end1 . x ] [ end1 . y ] == EXIST or area [ end2 . x ] [ end2 . y ] == EXIST : <NEWLINE> <INDENT> return area <NEWLINE> <DEDENT> elif area [ offset . x ] [ offset . y ] == NOTHING and area [ offset2 . x ] [ offset2 . y ] != EXIST : <NEWLINE> <INDENT> point . move ( center ) <NEWLINE> area [ point . x ] [ point . y ] = EXIST <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> move_index += 1 <NEWLINE> move_index %= 4 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def odd_spiral_pattern ( area , point ) : <NEWLINE> <INDENT> move_index = 0 <NEWLINE> is_end = False <NEWLINE> area [ point . x ] [ point . y ] = EXIST <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> left , center , right = MOVE [ move_index ] <NEWLINE> offset , offset2 = point . move_offset ( center ) , point . move_offset ( center , 2 ) <NEWLINE> <NL> if area [ offset . x ] [ offset . y ] == NOTHING and area [ offset2 . x ] [ offset2 . y ] != EXIST : <NEWLINE> <INDENT> point . move ( center ) <NEWLINE> area [ point . x ] [ point . y ] = EXIST <NEWLINE> is_end = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if is_end : <NEWLINE> <INDENT> return area <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> is_end = True <NEWLINE> <NL> <DEDENT> move_index += 1 <NEWLINE> move_index %= 4 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def formater ( area ) : <NEWLINE> <INDENT> output = [ <STRING> . join ( item ) . replace ( SENTINEL , <STRING> ) for item in result [ 2 : - 2 ] ] <NEWLINE> output = <STRING> . join ( output ) <NEWLINE> return output <NEWLINE> <NL> <NL> <DEDENT> output = [ ] <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> size = int ( input ( ) ) <NEWLINE> <NL> area = create_area ( size ) <NEWLINE> point = Vector ( size - 1 + 2 , 2 ) <NEWLINE> <NL> if size % 2 == 0 : <NEWLINE> <INDENT> result = even_spiral_pattern ( area , point ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = odd_spiral_pattern ( area , point ) <NEWLINE> <NL> <DEDENT> output . append ( formater ( result ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( output ) ) <NEWLINE> <NL>
n , m , k = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nokori = k - A [ i ] <NEWLINE> <NL> while ( B [ j ] <= nokori and j < m ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> if nokori < B [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format ( data [ 0 ] , data [ 1 ] , data [ 2 ] ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> def fnw ( n , s ) : <NEWLINE> <INDENT> sm = deque ( [ ] ) <NEWLINE> if n <= len ( s ) : <NEWLINE> <INDENT> for _ in range ( n ) : <NEWLINE> <INDENT> sm . append ( s . popleft ( ) ) <NEWLINE> <DEDENT> <DEDENT> return sm <NEWLINE> <NL> <DEDENT> def jfws ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> sm = fnw ( 5 , s ) <NEWLINE> <COMMENT> <NL> if <STRING> . join ( sm ) == <STRING> : <NEWLINE> <INDENT> sm = fnw ( 2 , s ) <NEWLINE> if <STRING> . join ( sm ) == <STRING> : <NEWLINE> <INDENT> if bool ( s ) : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . extendleft ( deque ( reversed ( list ( sm ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s . extendleft ( deque ( reversed ( list ( sm ) ) ) ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> elif <STRING> . join ( sm ) == <STRING> : <NEWLINE> <INDENT> sm = fnw ( 1 , s ) <NEWLINE> if <STRING> . join ( sm ) != <STRING> : <NEWLINE> <INDENT> s . extendleft ( sm ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( s ) : <NEWLINE> <INDENT> while len ( s ) > 0 : <NEWLINE> <INDENT> if jfws ( s ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> s = deque ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> print ( main ( s ) ) <NEWLINE> <NL>
n , b , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = n // ( b + r ) <NEWLINE> x1 = n % ( b + r ) <NEWLINE> <NL> if b >= x1 : <NEWLINE> <INDENT> b_count = x1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_count = b <NEWLINE> <NL> <DEDENT> print ( x * b + b_count ) <NEWLINE>
n = input ( ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in reversed ( nums ) : <NEWLINE> <INDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = sorted ( p ) <NEWLINE> ans = sum ( p [ : k ] ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> y = 1 <NEWLINE> q = 1 <NEWLINE> z = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> q = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> z = z * a [ i ] <NEWLINE> if z > 1000000000000000000 : <NEWLINE> <INDENT> y = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if q == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif z <= 1000000000000000000 : <NEWLINE> <INDENT> print ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * len ( a ) <NEWLINE> <NL> for i , value in enumerate ( a ) : <NEWLINE> <INDENT> b [ value - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in b : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> q = int ( input ( ) ) <NEWLINE> z = [ 0 for i in range ( 100001 ) ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> z [ a [ i ] ] += 1 <NEWLINE> <DEDENT> x = sum ( a ) <NEWLINE> b = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> x += ( b [ i ] [ 1 ] - b [ i ] [ 0 ] ) * z [ b [ i ] [ 0 ] ] <NEWLINE> z [ b [ i ] [ 1 ] ] += z [ b [ i ] [ 0 ] ] <NEWLINE> z [ b [ i ] [ 0 ] ] = 0 <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> o = 0 <NEWLINE> aa = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> aa . append ( i ** 2 ) <NEWLINE> <DEDENT> s = sum ( a ) <NEWLINE> o = ( s ** 2 - sum ( aa ) ) // 2 <NEWLINE> o %= 10 ** 9 + 7 <NEWLINE> print ( o ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . sort ( reverse = True ) <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> print ( sum ( h ) ) <NEWLINE> <DEDENT> elif k <= n : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> h [ i ] = 0 <NEWLINE> <DEDENT> print ( sum ( h ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , X , M = NMI ( ) <NEWLINE> A = [ ] <NEWLINE> A_ID = { } <NEWLINE> break_flag = False <NEWLINE> start = 0 <NEWLINE> end = N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> A . append ( X ) <NEWLINE> A_ID [ X ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = A [ - 1 ] ** 2 % M <NEWLINE> if x not in A_ID : <NEWLINE> <INDENT> A . append ( x ) <NEWLINE> A_ID [ x ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( x ) <NEWLINE> start = A_ID [ x ] <NEWLINE> end = i <NEWLINE> break_flag = True <NEWLINE> <DEDENT> if break_flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if N < start + 1 : <NEWLINE> <INDENT> print ( sum ( A [ : N ] ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = sum ( A [ : start ] ) <NEWLINE> lp = sum ( A [ start : end ] ) <NEWLINE> gap = end - start <NEWLINE> lp_n = ( N - start ) // gap <NEWLINE> rem = ( N - start ) % gap <NEWLINE> ans += lp * lp_n + sum ( A [ start : start + rem ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if N < B : i = N <NEWLINE> else : i = B - 1 <NEWLINE> p = ( math . floor ( ( A * i ) / B ) ) <NEWLINE> print ( p ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> lenS = len ( S ) <NEWLINE> S = S + [ <STRING> ] <NEWLINE> K = lenS <NEWLINE> i = 0 <NEWLINE> ps = S [ 0 ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s != ps : <NEWLINE> <INDENT> K = min ( K , max ( i , lenS - i ) ) <NEWLINE> ps = s <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( K ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> j = 2 <NEWLINE> flag = 0 <NEWLINE> while k / j >= j : <NEWLINE> <INDENT> if k % j == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> c = [ 0 ] * 1001 <NEWLINE> for i in L : c [ i ] += 1 <NEWLINE> for i in range ( 1000 ) : c [ i + 1 ] = c [ i ] + c [ i + 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> l , r = abs ( L [ i ] - L [ j ] ) , min ( L [ i ] + L [ j ] - 1 , 1000 ) <NEWLINE> ans += c [ r ] - c [ l ] <NEWLINE> if l < L [ i ] and L [ i ] <= r : ans -= 1 <NEWLINE> if l < L [ j ] and L [ j ] <= r : ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 3 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> flag = True <NEWLINE> <COMMENT> <NL> INF = 100000000000 <NEWLINE> stepList = [ INF ] * ( N + 1 ) <NEWLINE> stepList [ 0 ] = 1 <NEWLINE> stepList [ 1 ] = 1 <NEWLINE> def stepF ( K ) : <NEWLINE> <INDENT> if K == 0 : <NEWLINE> <INDENT> return stepList [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if stepList [ i ] == INF : <NEWLINE> <INDENT> stepList [ i ] = stepList [ i - 2 ] + stepList [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return stepList [ K ] <NEWLINE> <NL> <DEDENT> <DEDENT> if M == 0 : <NEWLINE> <INDENT> res = stepF ( N ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> List = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> res = stepF ( List [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if List [ i ] - List [ i - 1 ] == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> res = res * stepF ( List [ i ] - List [ i - 1 ] - 2 ) <NEWLINE> <DEDENT> <DEDENT> res = res * stepF ( N - List [ M - 1 ] - 1 ) <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( res % 1000000007 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1000000007 <NEWLINE> sumNum = sum ( ls ) <NEWLINE> currentSum , lastAns = 0 , 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> currentSum += ls [ i ] <NEWLINE> lastAns = ( lastAns + ( ls [ i ] * ( sumNum - currentSum ) ) ) % m <NEWLINE> <DEDENT> print ( lastAns ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A_list = [ A for A in input ( ) . split ( ) ] <NEWLINE> A_list = list ( map ( int , A_list ) ) <NEWLINE> <COMMENT> <NL> A_list . sort ( ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> for a in A_list : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def get_distance ( x1 , y1 ) : <NEWLINE> <INDENT> d = math . sqrt ( ( x1 ) ** 2 + ( y1 ) ** 2 ) <NEWLINE> return d <NEWLINE> <NL> <NL> <DEDENT> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> num_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if abs ( num_list [ i ] [ 0 ] <= D ) and abs ( num_list [ i ] [ 1 ] ) <= D : <NEWLINE> <NL> <INDENT> k = get_distance ( num_list [ i ] [ 0 ] , num_list [ i ] [ 1 ] ) <NEWLINE> if k <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if v > w and abs ( a - b ) / ( v - w ) <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> S = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S += math . gcd ( s , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = max ( A ) <NEWLINE> check = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> while a <= M : <NEWLINE> <INDENT> check [ a ] += 1 <NEWLINE> a += A [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if check [ A [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
T = list ( input ( ) ) <NEWLINE> if len ( T ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if T [ 0 ] == <STRING> and T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> elif T [ 0 ] == <STRING> and T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> elif T [ 0 ] == <STRING> and T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( 1 , len ( T ) - 1 ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> and T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if T [ - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l = [ 0 ] * N <NEWLINE> r = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ i ] = a [ i ] + i + 1 <NEWLINE> r [ i ] = i + 1 - a [ i ] <NEWLINE> <DEDENT> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ r [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ r [ i ] ] -= 1 <NEWLINE> ans += d [ l [ i ] ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import re <NEWLINE> from collections import deque , defaultdict <NEWLINE> from itertools import combinations , combinations_with_replacement <NEWLINE> import bisect <NEWLINE> from math import factorial , sqrt , log , ceil , floor <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ds = [ ] <NEWLINE> for n in range ( 12 ) : <NEWLINE> <INDENT> k = 11 - n <NEWLINE> threshold = sum ( [ 26 ** i for i in range ( k + 1 ) ] ) <NEWLINE> d = 0 <NEWLINE> if N >= threshold : <NEWLINE> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> if N >= threshold + 26 ** k * j : <NEWLINE> <INDENT> d = j <NEWLINE> <DEDENT> <DEDENT> d += 1 <NEWLINE> N -= 26 ** k * d <NEWLINE> <DEDENT> ds . append ( d ) <NEWLINE> <NL> <DEDENT> chars = <STRING> <NEWLINE> result = <STRING> <NEWLINE> for n in range ( 12 ) : <NEWLINE> <INDENT> if ds [ n ] > 0 : <NEWLINE> <INDENT> result += chars [ ds [ n ] - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> MAX = 1000000001 <NEWLINE> <NL> def merge ( A , left , mid , right , cnt ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> <NL> L . append ( MAX ) <NEWLINE> R . append ( MAX ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <COMMENT> <NL> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right , cnt ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> cnt = mergeSort ( A , left , mid , cnt ) <NEWLINE> cnt = mergeSort ( A , mid , right , cnt ) <NEWLINE> cnt = merge ( A , left , mid , right , cnt ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = mergeSort ( S , 0 , n , 0 ) <NEWLINE> print ( <STRING> . join ( map ( str , S ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def print_list_split_whitespace ( a ) : <NEWLINE> <INDENT> for x in a [ : - 1 ] : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ - 1 ] ) <NEWLINE> <NL> <DEDENT> s = list ( input ( ) ) <NEWLINE> st1 = [ ] <NEWLINE> st2 = [ ] <NEWLINE> <NL> for index , c in enumerate ( s ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> st1 . append ( index ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> if len ( st1 ) >= 1 : <NEWLINE> <INDENT> pop_index = st1 . pop ( ) <NEWLINE> area = index - pop_index <NEWLINE> while True : <NEWLINE> <INDENT> if len ( st2 ) >= 1 : <NEWLINE> <INDENT> ind , pop_area = st2 . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st2 . append ( ( index , area ) ) <NEWLINE> break <NEWLINE> <DEDENT> if ind < pop_index : <NEWLINE> <INDENT> st2 . append ( ( ind , pop_area ) ) <NEWLINE> st2 . append ( ( index , area ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> area += pop_area <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> a = 0 <NEWLINE> k = len ( st2 ) <NEWLINE> ls = [ k ] <NEWLINE> for _ , s in st2 : <NEWLINE> <INDENT> a += s <NEWLINE> ls . append ( s ) <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE> print_list_split_whitespace ( ls ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> num = [ 0 ] * 13 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt > 12 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if num [ cnt ] == 0 : <NEWLINE> <INDENT> num [ cnt ] = i <NEWLINE> <NL> <DEDENT> if num [ n ] > 0 : <NEWLINE> <INDENT> ans = num [ n ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> l1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> k = 0 <NEWLINE> if 0 in l1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> p *= l1 [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> k = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if k == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> D = [ - 1 ] <COMMENT> <NEWLINE> for i in range ( 2 * N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> D . append ( D [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( D [ - 1 ] * ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> left = [ ] <NEWLINE> for i in range ( 2 * N ) : <NEWLINE> <INDENT> if D [ i ] < 0 : <NEWLINE> <INDENT> left . append ( i ) <NEWLINE> <DEDENT> <DEDENT> sums = [ 0 for i in range ( 2 * N ) ] <NEWLINE> for i in range ( 2 * N ) : <NEWLINE> <INDENT> if D [ i ] > 0 : <NEWLINE> <INDENT> sums [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 * N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> sums [ i ] += sums [ i + 1 ] <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if len ( left ) != N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= sums [ left [ i ] ] - ( N - 1 - i ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k * 2 + a - 1 <= b : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( int ( a * x / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i >= n / 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> syou , amari = divmod ( n , i ) <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> count += syou - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += syou <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yen = 1000 <NEWLINE> kabu = 0 <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> if As [ n ] < As [ n + 1 ] : <NEWLINE> <INDENT> kabu += yen // As [ n ] <NEWLINE> yen -= kabu * As [ n ] <NEWLINE> yen += kabu * As [ n + 1 ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> <DEDENT> print ( yen ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> counter = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> counter [ i + A [ i ] ] = 0 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i - A [ i ] in counter : <NEWLINE> <INDENT> ans += counter [ i - A [ i ] ] <NEWLINE> <DEDENT> counter [ i + A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def cin ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def qpow ( a , b , p ) : <NEWLINE> <INDENT> if p == 1 or p == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> a = ( a % p + p ) % p <NEWLINE> ans = 1 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> if ( b & 1 ) != 0 : <NEWLINE> <INDENT> ans = ( ans * a ) % p <NEWLINE> <DEDENT> b >>= 1 <NEWLINE> a = a * a % p <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return f ( n % bin ( n ) . count ( <STRING> ) ) + 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = list ( input ( ) ) <NEWLINE> x = x [ : : - 1 ] <NEWLINE> cnt = 0 ; l = len ( x ) <NEWLINE> r1 = 0 ; r2 = 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> i = 0 <NEWLINE> while i < l : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> r1 += qpow ( 2 , i , cnt + 1 ) <NEWLINE> r2 += qpow ( 2 , i , cnt - 1 ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> a = [ ] <NEWLINE> while i < l : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> t = f ( ( r1 + qpow ( 2 , i , cnt + 1 ) ) % ( cnt + 1 ) ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt - 1 != 0 : <NEWLINE> <INDENT> t = f ( ( r2 - qpow ( 2 , i , cnt - 1 ) + ( cnt - 1 ) ) % ( cnt - 1 ) ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> a . append ( t ) <NEWLINE> <DEDENT> a = a [ : : - 1 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
field = [ [ 0 for i in range ( 10 ) ] for i in range ( 15 ) ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> field [ ( ( b - 1 ) * 4 ) + f - 1 ] [ ( r - 1 ) ] += v <NEWLINE> <DEDENT> for i in range ( 15 ) : <NEWLINE> <INDENT> if ( i % 4 == 3 ) : <NEWLINE> <INDENT> field [ i ] = [ <STRING> * 20 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 15 ) : <NEWLINE> <INDENT> field [ i ] = map ( str , field [ i ] ) <NEWLINE> <DEDENT> for i in range ( 15 ) : <NEWLINE> <INDENT> if not ( i % 4 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( field [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( field [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) . rstrip ( ) . replace ( <STRING> , <STRING> ) for _ in range ( n ) ] <NEWLINE> D = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> X = [ a + b , b + c , c + a ] <NEWLINE> L = [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> k = D . index ( s ) <NEWLINE> if X [ k ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if X [ ( k + 1 ) % 3 ] == 1 and X [ ( k + 2 ) % 3 ] == 1 and i < n - 1 : <NEWLINE> <INDENT> l = D . index ( S [ i + 1 ] ) <NEWLINE> if l == ( k + 1 ) % 3 : <NEWLINE> <INDENT> X [ ( k + 1 ) % 3 ] += 1 <NEWLINE> X [ ( k + 2 ) % 3 ] -= 1 <NEWLINE> L . append ( s [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ ( k + 2 ) % 3 ] += 1 <NEWLINE> X [ ( k + 1 ) % 3 ] -= 1 <NEWLINE> L . append ( s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if X [ ( k + 1 ) % 3 ] < X [ ( k + 2 ) % 3 ] : <NEWLINE> <INDENT> X [ ( k + 1 ) % 3 ] += 1 <NEWLINE> X [ ( k + 2 ) % 3 ] -= 1 <NEWLINE> L . append ( s [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ ( k + 2 ) % 3 ] += 1 <NEWLINE> X [ ( k + 1 ) % 3 ] -= 1 <NEWLINE> L . append ( s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * L , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if ( n % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d = 1 <NEWLINE> while i + 2 * d < n : <NEWLINE> <INDENT> if s [ i ] != s [ i + d ] and s [ i ] != s [ i + 2 * d ] and s [ i + d ] != s [ i + 2 * d ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nx = [ 0 , 0 , 0 ] <NEWLINE> ans = 0 <NEWLINE> if all ( x & 1 == 0 for x in li ) and li [ 0 ] == li [ 1 ] == li [ 2 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> if ( li [ 0 ] % 2 != 0 or li [ 1 ] % 2 != 0 or li [ 2 ] % 2 != 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nx [ 0 ] = ( li [ 1 ] + li [ 2 ] ) / 2 <NEWLINE> nx [ 1 ] = ( li [ 0 ] + li [ 2 ] ) / 2 <NEWLINE> nx [ 2 ] = ( li [ 0 ] + li [ 1 ] ) / 2 <NEWLINE> li = nx . copy ( ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> town = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> warp = [ 1 ] <NEWLINE> checklist = [ 0 ] + [ - 1 ] * n <NEWLINE> i = 0 <NEWLINE> j = 1 <NEWLINE> s = 0 <NEWLINE> while j <= n : <NEWLINE> <INDENT> warp . append ( town [ i ] ) <NEWLINE> if checklist [ town [ i ] - 1 ] != - 1 : <NEWLINE> <INDENT> s = checklist [ town [ i ] - 1 ] <NEWLINE> loop = warp [ s : j ] <NEWLINE> break <NEWLINE> <DEDENT> checklist [ town [ i ] - 1 ] = j <NEWLINE> i = town [ i ] - 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> if k >= s : <NEWLINE> <INDENT> m = len ( loop ) <NEWLINE> print ( loop [ ( k - s ) % m ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( warp [ k ] ) <NEWLINE> <DEDENT>
class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , parent = - 1 , left = - 1 , right = - 1 ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> <DEDENT> def postorder ( ns , i , post ) : <NEWLINE> <INDENT> if ns [ i ] . left != - 1 : <NEWLINE> <INDENT> postorder ( ns , ns [ i ] . left , post ) <NEWLINE> <DEDENT> if ns [ i ] . right != - 1 : <NEWLINE> <INDENT> postorder ( ns , ns [ i ] . right , post ) <NEWLINE> <DEDENT> post . append ( str ( i + 1 ) ) <NEWLINE> <NL> <DEDENT> def poio_node ( ns , po , io ) : <NEWLINE> <INDENT> p = po [ 0 ] <NEWLINE> i = io . index ( p ) <NEWLINE> if i != 0 : <NEWLINE> <INDENT> ns [ p ] . left = po [ 1 ] <NEWLINE> ns [ po [ 1 ] ] . parent = p <NEWLINE> poio_node ( ns , po [ 1 : i + 1 ] , io [ : i ] ) <NEWLINE> <DEDENT> if i != len ( io ) - 1 : <NEWLINE> <INDENT> ns [ p ] . right = po [ i + 1 ] <NEWLINE> ns [ po [ 1 + i ] ] . parent = p <NEWLINE> poio_node ( ns , po [ i + 1 : ] , io [ i + 1 : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def min1 ( n ) : <NEWLINE> <INDENT> return n - 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> po = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> io = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> po = list ( map ( min1 , po ) ) <NEWLINE> io = list ( map ( min1 , io ) ) <NEWLINE> ns = [ Node ( ) for i in range ( n ) ] <NEWLINE> <NL> poio_node ( ns , po , io ) <NEWLINE> <NL> post = [ ] <NEWLINE> postorder ( ns , po [ 0 ] , post ) <NEWLINE> print ( <STRING> . join ( post ) ) <NEWLINE>
import sys <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = gcd ( a , b ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> return gcd ( b , a % b ) if b else a <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX = 10 ** 6 <NEWLINE> <NL> A . sort ( ) <NEWLINE> s = set ( ) <NEWLINE> ans = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if a in s : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if i < N - 1 and A [ i + 1 ] == a : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> n = MAX // a <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s . add ( a * i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> elif i == ( H - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> elif H == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <STRING> * ( W - 2 ) , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + a [ i ] <NEWLINE> <DEDENT> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( n - l + 1 ) : <NEWLINE> <INDENT> j = i + l <NEWLINE> dp [ i ] [ j ] = s [ j ] - s [ i ] + min ( dp [ i ] [ k ] + dp [ k ] [ j ] for k in range ( i + 1 , j ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 ] [ n ] ) <NEWLINE>
from itertools import accumulate <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> prime_counter = defaultdict ( int ) <COMMENT> <NEWLINE> accum = tuple ( accumulate ( range ( 1 , 42 ) ) ) <COMMENT> <NEWLINE> <NL> def facs ( n ) : <NEWLINE> <INDENT> yield 2 <NEWLINE> for x in range ( 3 , int ( pow ( n , 0.5 ) ) + 1 , 2 ) : <NEWLINE> <INDENT> yield x <NEWLINE> <NL> <DEDENT> <DEDENT> for fac in facs ( n ) : <NEWLINE> <INDENT> while n % fac == 0 : <NEWLINE> <INDENT> n //= fac <NEWLINE> prime_counter [ fac ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> prime_counter [ n ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in prime_counter . values ( ) : <NEWLINE> <INDENT> for accum_count , accum_value in enumerate ( accum ) : <NEWLINE> <INDENT> if c < accum_value : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans += accum_count <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fumi = set ( [ 0 ] ) <NEWLINE> start = None <NEWLINE> end = None <NEWLINE> aab = [ 0 ] <NEWLINE> for i in range ( 10 ** 18 ) : <NEWLINE> <INDENT> next = aa [ aab [ - 1 ] ] - 1 <NEWLINE> if next in fumi : <NEWLINE> <INDENT> if start is None : <NEWLINE> <INDENT> start = i <NEWLINE> fumi = set ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> aab . append ( next ) <NEWLINE> fumi . add ( next ) <NEWLINE> if i + 1 == k : <NEWLINE> <INDENT> print ( next + 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> random_first = len ( aab ) - 2 * ( end - start ) <NEWLINE> <COMMENT> <NL> <NL> first = aab [ : random_first ] <NEWLINE> one_cicle = aab [ start + 1 : end + 1 ] <NEWLINE> if k <= len ( first ) : <NEWLINE> <INDENT> print ( first [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - len ( first ) <NEWLINE> print ( one_cicle [ k % len ( one_cicle ) ] + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> fn_array = [ 0 ] * 60000 <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if x == y and y == z : <NEWLINE> <INDENT> fn_array [ n ] += 1 <NEWLINE> <DEDENT> elif ( x == y ) and ( y != z ) : <NEWLINE> <INDENT> fn_array [ n ] += 3 <NEWLINE> <DEDENT> elif ( x != y ) and ( y == z ) : <NEWLINE> <INDENT> fn_array [ n ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fn_array [ n ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( fn_array [ n ] ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if not b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> tmp = gcd ( i , j ) <NEWLINE> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( tmp , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += 6 * gcd ( i , j ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans += ( n * ( n + 1 ) ) // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += i * n * ( n + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = 0 <NEWLINE> gc = d <NEWLINE> <NL> if d - a > 0 and a > 0 : <NEWLINE> <INDENT> g += a <NEWLINE> d -= a <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> g += d <NEWLINE> print ( str ( g ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if d - b > 0 and b > 0 : <NEWLINE> <INDENT> d -= b <NEWLINE> <DEDENT> elif b > 0 : <NEWLINE> <INDENT> print ( str ( g ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if d == c and c > 0 : <NEWLINE> <INDENT> g -= d <NEWLINE> <DEDENT> elif c > 0 : <NEWLINE> <INDENT> g -= d <NEWLINE> <NL> <DEDENT> print ( str ( g ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = np . array ( list ( [ 0 ] * n ) ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( np . count_nonzero ( cnt == 0 ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = a . split ( ) <NEWLINE> c = list ( ) <NEWLINE> <NL> for d in b : <NEWLINE> <INDENT> c . append ( int ( d ) ) <NEWLINE> <NL> <DEDENT> a = c [ 0 ] <NEWLINE> b = c [ 1 ] <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = [ 0 for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in ls : <NEWLINE> <INDENT> tmp [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( tmp [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> A . sort ( reverse = True , key = lambda x : abs ( x ) ) <NEWLINE> <NL> if min ( A ) > 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * A [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> elif max ( A ) < 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * A [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * A [ n - 1 - i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> elif n == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * A [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> elif k == 1 : <NEWLINE> <INDENT> print ( max ( A ) % mod ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> L1 , L2 , R1 , R2 = [ ] , [ ] , [ ] , [ ] <NEWLINE> ct = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ct < k : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> L1 . append ( a ) <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> L2 . append ( a ) <NEWLINE> <DEDENT> ct += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> R1 . append ( a ) <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> R2 . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ct < k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not L1 : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> if not R1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> c = R1 [ 0 ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( len ( L2 ) - 1 ) : <NEWLINE> <INDENT> ans = ( ans * L2 [ i ] ) % mod <NEWLINE> <DEDENT> ans = ( ans * c ) % mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( len ( L2 ) ) : <NEWLINE> <INDENT> ans = ( ans * L2 [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> elif not L2 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( len ( L1 ) ) : <NEWLINE> <INDENT> ans = ( ans * L1 [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( L2 ) % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in L1 : <NEWLINE> <INDENT> ans = ( ans * a ) % mod <NEWLINE> <DEDENT> for a in L2 : <NEWLINE> <INDENT> ans = ( ans * a ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not R1 : <NEWLINE> <INDENT> if not R2 : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in L1 : <NEWLINE> <INDENT> ans = ( ans * a ) % mod <NEWLINE> <DEDENT> for a in L2 : <NEWLINE> <INDENT> ans = ( ans * a ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d = - R2 [ 0 ] <NEWLINE> ans = d <NEWLINE> for i in range ( len ( L1 ) - 1 ) : <NEWLINE> <INDENT> ans = ( ans * L1 [ i ] ) % mod <NEWLINE> <DEDENT> for i in range ( len ( L2 ) ) : <NEWLINE> <INDENT> ans = ( ans * abs ( L2 [ i ] ) ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c = R1 [ 0 ] <NEWLINE> a = L1 [ - 1 ] <NEWLINE> b = L2 [ - 1 ] <NEWLINE> if R2 and R2 [ 0 ] * b > a * c : <NEWLINE> <INDENT> ans = R2 [ 0 ] <NEWLINE> for i in range ( len ( L1 ) - 1 ) : <NEWLINE> <INDENT> ans = ( ans * L1 [ i ] ) % mod <NEWLINE> <DEDENT> for i in range ( len ( L2 ) ) : <NEWLINE> <INDENT> ans = ( ans * L2 [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = c <NEWLINE> for i in range ( len ( L1 ) ) : <NEWLINE> <INDENT> ans = ( ans * L1 [ i ] ) % mod <NEWLINE> <DEDENT> for i in range ( len ( L2 ) - 1 ) : <NEWLINE> <INDENT> ans = ( ans * L2 [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> key = <STRING> <NEWLINE> <NL> t = - 1 <NEWLINE> <NL> for i in range ( 7 ) : <NEWLINE> <INDENT> if not S [ i ] == key [ i ] : <NEWLINE> <INDENT> t = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t == - 1 : <NEWLINE> <INDENT> t = 7 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> if not S [ - i ] == key [ - i ] : <NEWLINE> <INDENT> t += i - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t >= 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> d = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> d += ( ( x [ i ] [ 0 ] - x [ j ] [ 0 ] ) ** 2 + ( x [ i ] [ 1 ] - x [ j ] [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d * ( n - 1 ) / cnt ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { e : [ 0 ] * ( c + 1 ) for e in range ( 100001 ) } <NEWLINE> d1 = [ 0 ] * 100001 <NEWLINE> m = map ( int , read ( ) . split ( ) ) <NEWLINE> stc = zip ( m , m , m ) <NEWLINE> for s , t , c in stc : <NEWLINE> <INDENT> if d [ s ] [ c ] : <NEWLINE> <INDENT> d1 [ s - 1 ] -= 1 <NEWLINE> d1 [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] [ c ] = 1 <NEWLINE> <DEDENT> if d [ t ] [ c ] : <NEWLINE> <INDENT> d1 [ t - 1 ] -= 1 <NEWLINE> d1 [ t ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ t ] [ c ] = 1 <NEWLINE> <DEDENT> d1 [ s - 1 ] += 1 <NEWLINE> d1 [ t ] -= 1 <NEWLINE> <NL> <DEDENT> cur = 0 <NEWLINE> r = 0 <NEWLINE> for i1 in range ( 100001 ) : <NEWLINE> <INDENT> cur += d1 [ i1 ] <NEWLINE> r = max ( r , cur ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> flg = 1 <NEWLINE> if a > b : <NEWLINE> <INDENT> flg = - 1 <NEWLINE> <NL> <DEDENT> a = a + v * t * flg <NEWLINE> b = b + w * t * flg <NEWLINE> <NL> if flg == 1 : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ia = list ( enumerate ( a_l ) ) <NEWLINE> <NL> x_dict = { } <NEWLINE> y_dict = { } <NEWLINE> for i , a in ia : <NEWLINE> <INDENT> x = i + a <NEWLINE> y = i - a <NEWLINE> if x in x_dict : <NEWLINE> <INDENT> x_dict [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_dict [ x ] = 1 <NEWLINE> <DEDENT> if y in y_dict : <NEWLINE> <INDENT> y_dict [ y ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y_dict [ y ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for xkey in x_dict . keys ( ) : <NEWLINE> <INDENT> if xkey in y_dict : <NEWLINE> <INDENT> count += x_dict [ xkey ] * y_dict [ xkey ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import re <NEWLINE> import random <NEWLINE> import math <NEWLINE> import copy <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> from functools import cmp_to_key <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import defaultdict , deque , Counter <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> getS = lambda : input ( ) . strip ( ) <NEWLINE> getN = lambda : int ( input ( ) ) <NEWLINE> getList = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> getZList = lambda : [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> divide = lambda x : pow ( x , MOD - 2 , MOD ) <NEWLINE> <NL> <NL> def fact_and_inv ( SIZE ) : <NEWLINE> <INDENT> inv = [ 0 ] * SIZE <COMMENT> <NEWLINE> fac = [ 0 ] * SIZE <COMMENT> <NEWLINE> finv = [ 0 ] * SIZE <COMMENT> <NEWLINE> inv [ 1 ] = 1 <NEWLINE> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , SIZE ) : <NEWLINE> <INDENT> inv [ i ] = MOD - ( MOD // i ) * inv [ MOD % i ] % MOD <NEWLINE> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <NL> <DEDENT> return fac , finv <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = getN ( ) <NEWLINE> <NL> fac , finv = fact_and_inv ( n + 2000 ) <NEWLINE> <NL> length = 1 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if length * 3 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> distribution = n - length * 3 <NEWLINE> ans += fac [ length + distribution - 1 ] * finv [ length - 1 ] * finv [ distribution ] <NEWLINE> ans %= MOD <NEWLINE> length += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = getN ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , x = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if L [ i - 1 ] + L [ i ] > x : <NEWLINE> <INDENT> if L [ i - 1 ] > x : <NEWLINE> <INDENT> ans += L [ i - 1 ] - x <NEWLINE> ans += L [ i ] <NEWLINE> L [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += L [ i ] + L [ i - 1 ] - x <NEWLINE> L [ i ] = x - L [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , x = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> la = [ int ( w ) for w in input ( ) . split ( ) ] + [ x ] <NEWLINE> la . sort ( ) <NEWLINE> if la [ 0 ] < 0 : <NEWLINE> <INDENT> m = la [ 0 ] <NEWLINE> la = [ w + m for w in la ] <NEWLINE> <NL> <DEDENT> diff = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> diff [ i ] = la [ i + 1 ] - la [ i ] <NEWLINE> <DEDENT> g = diff [ 0 ] <NEWLINE> for i in diff [ 1 : ] : <NEWLINE> <INDENT> g = math . gcd ( g , i ) <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
import math <NEWLINE> import sys , collections <NEWLINE> from sys import stdin , stdout <NEWLINE> <COMMENT> <NL> <NL> def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def get_array ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <COMMENT> <NL> def file ( ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> def is_subsequence ( x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = list ( x ) <NEWLINE> for letter in y : <NEWLINE> <INDENT> if x and x [ 0 ] == letter : <NEWLINE> <INDENT> x . pop ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return not x <NEWLINE> <DEDENT> def sieve ( ) : <NEWLINE> <INDENT> spf [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MAXN ) : <NEWLINE> <INDENT> spf [ i ] = i <NEWLINE> <DEDENT> for i in range ( 4 , MAXN , 2 ) : <NEWLINE> <INDENT> spf [ i ] = 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , mt . ceil ( mt . sqrt ( MAXN ) ) ) : <NEWLINE> <INDENT> if ( spf [ i ] == i ) : <NEWLINE> <INDENT> for j in range ( i * i , MAXN , i ) : <NEWLINE> <INDENT> if ( spf [ j ] == j ) : <NEWLINE> <INDENT> spf [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getFactorization ( x ) : <NEWLINE> <INDENT> ret = list ( ) <NEWLINE> while ( x != 1 ) : <NEWLINE> <INDENT> ret . append ( spf [ x ] ) <NEWLINE> x = x // spf [ x ] <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <DEDENT> def getFloor ( A , x ) : <NEWLINE> <NL> <INDENT> ( left , right ) = ( 0 , len ( A ) - 1 ) <NEWLINE> <NL> ind , floor = - 1 , - 1 <NEWLINE> while left <= right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> <STRING> <NEWLINE> if x < A [ mid ] : <NEWLINE> <INDENT> right = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> floor = A [ mid ] <NEWLINE> ind = mid <NEWLINE> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ind <NEWLINE> <DEDENT> def check ( st ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> n = len ( st ) <NEWLINE> digitSum = 0 <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> digitSum = digitSum + ( int ) ( st [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return ( digitSum % 9 == 0 ) <NEWLINE> <DEDENT> def isPowerOfTwo ( n ) : <NEWLINE> <INDENT> if ( n == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> while ( n != 1 ) : <NEWLINE> <INDENT> if ( n % 2 != 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> n = n // 2 <NEWLINE> <NL> <NL> <DEDENT> return True <NEWLINE> <DEDENT> def kitte ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while ( n != 0 ) : <NEWLINE> <INDENT> n = n // 2 <NEWLINE> c += 1 <NEWLINE> <DEDENT> return c <NEWLINE> <DEDENT> def aa ( b , c ) : <NEWLINE> <INDENT> m = min ( b , c ) <NEWLINE> b -= m <NEWLINE> c -= m <NEWLINE> if ( c > 0 and b > 0 ) : <NEWLINE> <INDENT> return ( m + ( ( b + c ) // 3 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( m ) <NEWLINE> <DEDENT> <DEDENT> def bb ( a , c ) : <NEWLINE> <INDENT> m = min ( a , c ) <NEWLINE> a -= m <NEWLINE> c -= m <NEWLINE> if ( c > 0 and a > 0 ) : <NEWLINE> <INDENT> return ( m + ( ( a + c ) // 3 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( m ) <NEWLINE> <DEDENT> <DEDENT> def cc ( b , a ) : <NEWLINE> <INDENT> m = min ( b , a ) <NEWLINE> b -= m <NEWLINE> a -= m <NEWLINE> if ( a > 0 and b > 0 ) : <NEWLINE> <INDENT> return ( m + ( ( b + a ) // 3 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( m ) <NEWLINE> <DEDENT> <DEDENT> def findProductSum ( A , n ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> array_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> array_sum = ( array_sum + A [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> array_sum_square = ( array_sum * array_sum ) <NEWLINE> <NL> <COMMENT> <NL> individual_square_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> individual_square_sum += ( A [ i ] * A [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return ( array_sum_square - <NEWLINE> <INDENT> individual_square_sum ) // 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> mod = ( 10 ** 9 ) + 7 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = get_array ( ) <NEWLINE> s = 0 <NEWLINE> s = findProductSum ( l , n ) <NEWLINE> print ( s % mod ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
first = True <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == 0 : break <NEWLINE> <NL> if not first : print ( ) <NEWLINE> first = False <NEWLINE> <NL> count = 0 <NEWLINE> for y in range ( a , b + 1 ) : <NEWLINE> <INDENT> if y % 400 == 0 or y % 4 == 0 and y % 100 != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> print ( y ) <NEWLINE> <DEDENT> <DEDENT> if count == 0 : print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = min ( ans , 10 ** 18 + 1 ) <NEWLINE> <DEDENT> if ans >= 10 ** 18 + 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> roads = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> roads . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> r = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> roads [ r [ 0 ] ] . append ( r [ 1 ] ) <NEWLINE> roads [ r [ 1 ] ] . append ( r [ 0 ] ) <NEWLINE> <NL> <DEDENT> goodcount = 0 <NEWLINE> for i in range ( len ( H ) ) : <NEWLINE> <INDENT> isgood = True <NEWLINE> for r in roads [ i ] : <NEWLINE> <INDENT> if H [ i ] <= H [ r ] : <NEWLINE> <INDENT> isgood = False <NEWLINE> <DEDENT> <DEDENT> if isgood : <NEWLINE> <INDENT> goodcount += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( goodcount ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , * a = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ [ * input ( ) ] for _ in range ( n ) ] <NEWLINE> a = { <STRING> : a [ 0 ] , <STRING> : a [ 1 ] , <STRING> : a [ 2 ] } <NEWLINE> ans = [ <STRING> ] + [ 0 ] * n <NEWLINE> def dfs ( i ) : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for p , m in [ s [ i ] , s [ i ] [ : : - 1 ] ] : <NEWLINE> <INDENT> if a [ m ] : <NEWLINE> <INDENT> a [ p ] += 1 ; a [ m ] -= 1 ; ans [ i + 1 ] = p <NEWLINE> dfs ( i + 1 ) <NEWLINE> a [ p ] -= 1 ; a [ m ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE>
lst = [ x + <STRING> + str ( y ) for x in [ <STRING> , <STRING> , <STRING> , <STRING> ] for y in range ( 1 , 14 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst . remove ( input ( ) ) <NEWLINE> <DEDENT> for x in lst : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( Q ) ] <NEWLINE> <NL> if K - Q <= 0 : <NEWLINE> <INDENT> L = [ K - Q for i in range ( N ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> L [ A [ i ] - 1 ] = L [ A [ i ] - 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if L [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while d != 0 or a != 0 : <NEWLINE> <INDENT> c -= b <COMMENT> <NEWLINE> a -= d <COMMENT> <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i , _a in enumerate ( a [ k : ] ) : <NEWLINE> <INDENT> if a [ i ] < _a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import bisect <NEWLINE> AR = [ 0 ] <NEWLINE> BR = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> AR . append ( A [ i ] + AR [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> BR . append ( B [ i ] + BR [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if AR [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = k - AR [ i ] <NEWLINE> t = bisect . bisect ( BR , s ) - 1 <NEWLINE> ans = max ( ans , i + t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> s = deque ( list ( input ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query = input ( ) <NEWLINE> if query == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif query [ 2 ] == <STRING> : <NEWLINE> <INDENT> if count % 2 == 0 : <NEWLINE> <INDENT> s . appendleft ( query [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( query [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if count % 2 == 0 : <NEWLINE> <INDENT> s . append ( query [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( query [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count % 2 == 1 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> <DEDENT> print ( * s , sep = <STRING> ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , r * 2 * pi ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * ( N + 2 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> c [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> q = 0 <NEWLINE> <NL> if ( Y % 2 == 1 ) : <NEWLINE> <INDENT> q = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if q == 0 : <NEWLINE> <INDENT> print ( X * 2 <= Y and Y <= X * 4 and <STRING> or <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> b = Counter ( a ) <NEWLINE> b0 = 0 <NEWLINE> b1 = 0 <NEWLINE> <NL> if <STRING> in a : <NEWLINE> <INDENT> b0 = b [ <STRING> ] <NEWLINE> <DEDENT> if <STRING> in a : <NEWLINE> <INDENT> b1 = b [ <STRING> ] <NEWLINE> <DEDENT> more2 = n - b0 - b1 <NEWLINE> if b0 > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif more2 >= 60 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= int ( a [ i ] ) <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> t = input ( ) <NEWLINE> moji_list = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> , 26 : <STRING> } <NEWLINE> print_list = [ ] <NEWLINE> <NL> def hantei ( t ) : <NEWLINE> <INDENT> global print_list <NEWLINE> try : <NEWLINE> <INDENT> int ( t ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( t ) <NEWLINE> <NL> <DEDENT> if 1 <= n and n <= 1000000000000001 : <NEWLINE> <INDENT> while ( n >= 1 ) : <NEWLINE> <INDENT> s = n % 26 <NEWLINE> if s == 0 : <NEWLINE> <INDENT> s = 26 <NEWLINE> <DEDENT> print_list . insert ( 0 , moji_list [ s ] ) <NEWLINE> n = math . floor ( n / 26 ) <NEWLINE> if s == 26 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> hantei ( t ) <NEWLINE> pu = <STRING> . join ( print_list ) <NEWLINE> print ( pu ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ab . sort ( ) <NEWLINE> cd . sort ( ) <NEWLINE> <NL> g = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i , pab in enumerate ( ab ) : <NEWLINE> <INDENT> for j , pcd in enumerate ( cd ) : <NEWLINE> <INDENT> if pab [ 0 ] < pcd [ 0 ] and pab [ 1 ] < pcd [ 1 ] : <NEWLINE> <INDENT> g [ j ] . append ( [ pab [ 1 ] , i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> s = set ( ) <NEWLINE> <NL> for gg in g : <NEWLINE> <INDENT> gg . sort ( reverse = True ) <NEWLINE> for ggg in gg : <NEWLINE> <INDENT> if ggg [ 1 ] in s : continue <NEWLINE> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> s . add ( ggg [ 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Box : <NEWLINE> <INDENT> def __init__ ( self , line ) : <NEWLINE> <INDENT> self . __b = { } <NEWLINE> for i in map ( int , line . split ( <STRING> ) ) : <NEWLINE> <INDENT> if i not in self . __b : <NEWLINE> <INDENT> self . __b [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . __b [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> self . __sum = 0 <NEWLINE> for k , v in self . __b . items ( ) : <NEWLINE> <INDENT> self . __sum += k * v <NEWLINE> <NL> <DEDENT> <DEDENT> def convert ( self , b , c ) : <NEWLINE> <INDENT> if b in self . __b : <NEWLINE> <INDENT> if c in self . __b : <NEWLINE> <INDENT> self . __b [ c ] += self . __b [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . __b [ c ] = self . __b [ b ] <NEWLINE> <NL> <DEDENT> self . __sum += ( c - b ) * self . __b [ b ] <NEWLINE> <NL> self . __b [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self ) : <NEWLINE> <INDENT> return self . __sum <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> b = Box ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b . convert ( * list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> print ( b . sum ( ) ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> q , ll = l // 2019 , l % 2019 <NEWLINE> rr = r % 2019 <NEWLINE> rng = [ * range ( ll , rr + 1 ) ] if r - l < ( 2019 * q - ll ) % 2019 else [ * range ( ll , 2019 ) ] + [ * range ( rr + 1 ) ] <NEWLINE> lenrng = len ( rng ) <NEWLINE> ans = 2020 <NEWLINE> for i in range ( lenrng - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , lenrng ) : <NEWLINE> <INDENT> tmp = rng [ i ] * rng [ j ] % 2019 <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
L , R = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_mod = 2019 <NEWLINE> for a in range ( L , R ) : <NEWLINE> <INDENT> for b in range ( a + 1 , R + 1 ) : <NEWLINE> <INDENT> min_mod = min ( min_mod , ( a * b ) % 2019 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_mod ) <NEWLINE> <DEDENT>
yasumi = 0 <NEWLINE> syukudai = 1 <NEWLINE> nissu = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> syukudaiNissu = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( syukudaiNissu ) > nissu [ yasumi ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( nissu [ yasumi ] - sum ( syukudaiNissu ) ) <NEWLINE>
from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> mods = [ 0 ] <NEWLINE> s = [ int ( a ) for a in s [ : : - 1 ] ] <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> x += s [ i ] * pow ( 10 , i , 2019 ) <NEWLINE> mods . append ( x % 2019 ) <NEWLINE> <NL> <DEDENT> mods = Counter ( mods ) <NEWLINE> <NL> for k in mods . keys ( ) : <NEWLINE> <INDENT> counts = mods [ k ] <NEWLINE> ans += counts * ( counts - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> g = np . zeros ( ( h , w ) , dtype = int ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> g [ i ] = [ int ( s == <STRING> ) for s in input ( ) ] <NEWLINE> <NL> <DEDENT> L = g . copy ( ) <NEWLINE> R = g . copy ( ) <NEWLINE> U = g . copy ( ) <NEWLINE> D = g . copy ( ) <NEWLINE> <NL> for i in range ( 1 , h ) : <NEWLINE> <INDENT> U [ i ] = ( U [ i - 1 ] + 1 ) * g [ i ] <NEWLINE> D [ ~ i ] = ( D [ ~ i + 1 ] + 1 ) * g [ ~ i ] <NEWLINE> <DEDENT> for j in range ( 1 , w ) : <NEWLINE> <INDENT> L [ : , j ] = ( L [ : , j - 1 ] + 1 ) * g [ : , j ] <NEWLINE> R [ : , ~ j ] = ( R [ : , ~ j + 1 ] + 1 ) * g [ : , ~ j ] <NEWLINE> <NL> <DEDENT> ans = np . max ( L + R + U + D - 3 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <COMMENT> <NL> left = 0 <NEWLINE> right = N - 1 <NEWLINE> <NL> ans = 0 <NEWLINE> while left <= right : <NEWLINE> <INDENT> if right == left : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ left ] == S [ right ] : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if S [ left ] != <STRING> and S [ right ] != <STRING> : <NEWLINE> <INDENT> print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> if S [ left ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> if S [ right ] == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if right > left : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ali = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> allxor = 0 <NEWLINE> for ai in ali : <NEWLINE> <INDENT> allxor = allxor ^ ai <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = allxor ^ ali [ i ] <NEWLINE> <NL> if i != ( n - 1 ) : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> try : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <NL> <DEDENT> int_list = [ i for i in range ( 102 ) ] <NEWLINE> forbidden_list = sorted ( list ( set ( int_list ) - set ( p ) ) ) <NEWLINE> num_X = int_list . index ( X ) <NEWLINE> c = 10000000 <NEWLINE> <NL> if X in forbidden_list : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( forbidden_list ) - 1 ) : <NEWLINE> <INDENT> a = abs ( X - forbidden_list [ i ] ) <NEWLINE> b = abs ( X - forbidden_list [ i + 1 ] ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( forbidden_list [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> elif c > a : <NEWLINE> <INDENT> c = a <NEWLINE> <DEDENT> elif c <= a and b >= a : <NEWLINE> <INDENT> print ( forbidden_list [ i - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> elif b < a : <NEWLINE> <INDENT> print ( forbidden_list [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( forbidden_list [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( forbidden_list [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> s = s * 10 + 7 <NEWLINE> if s % k != 0 : <NEWLINE> <INDENT> s = s % k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> keys = deque ( [ ] ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command = input ( ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> keys . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> keys . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> command , x = command . split ( <STRING> ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> keys . appendleft ( int ( x ) ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> if int ( x ) in keys : <NEWLINE> <INDENT> keys . remove ( int ( x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( k ) for k in keys ] ) ) <NEWLINE>
a , b , c , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> ans = max ( a * c , a * d , b * c , b * d ) <NEWLINE> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> m = min ( B - 1 , N ) <NEWLINE> print ( int ( A * ( m / B ) ) ) <NEWLINE>
from itertools import accumulate <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> B = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> C = Counter ( B ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in set ( B ) : <NEWLINE> <INDENT> p = C [ i ] <NEWLINE> ans += p * ( p - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def function ( x ) : <NEWLINE> <INDENT> return ( A * x ) // B - A * ( x // B ) <NEWLINE> <NL> <DEDENT> if B - 1 <= N : <NEWLINE> <INDENT> print ( function ( B - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( function ( N ) ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> nec = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> nec . append ( [ i , j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( nec ) == h + w - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> init = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> next_animal = { ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> <INDENT> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> , <NEWLINE> ( <STRING> , <STRING> , <STRING> ) : <STRING> } <NEWLINE> <DEDENT> for X in init : <NEWLINE> <INDENT> SW = X <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> SW += next_animal [ SW [ i ] , s [ i ] , SW [ i - 1 ] ] <NEWLINE> <DEDENT> ls = len ( SW ) <NEWLINE> if SW [ 0 ] == SW [ ls - 1 ] and next_animal [ SW [ 0 ] , s [ 0 ] , SW [ ls - 2 ] ] == SW [ 1 ] : <NEWLINE> <INDENT> print ( SW [ : ls - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def check ( num ) : <NEWLINE> <INDENT> n = str ( num ) <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> elif check ( i ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL>
if __name__ == <STRING> : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = a . upper ( ) <NEWLINE> <NL> if ( a == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> lsn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ls2 = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> Bi , Ci = map ( int , input ( ) . split ( ) ) <NEWLINE> ls2 . append ( [ Bi , Ci ] ) <NEWLINE> <DEDENT> index = collections . Counter ( lsn ) <NEWLINE> sum1 = sum ( lsn ) <NEWLINE> for l in ls2 : <NEWLINE> <INDENT> sum1 = sum1 + ( l [ 1 ] - l [ 0 ] ) * index [ l [ 0 ] ] <NEWLINE> index [ l [ 1 ] ] += index [ l [ 0 ] ] <NEWLINE> index [ l [ 0 ] ] = 0 <NEWLINE> print ( sum1 ) <NEWLINE> <DEDENT>
c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> . format ( c , x ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Hc = [ 0 for i in range ( H ) ] <NEWLINE> Wc = [ 0 for i in range ( W ) ] <NEWLINE> B = [ ] <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> Hc [ h - 1 ] += 1 <NEWLINE> Wc [ w - 1 ] += 1 <NEWLINE> B . append ( ( h - 1 , w - 1 ) ) <NEWLINE> <DEDENT> Hcmax = max ( Hc ) <NEWLINE> Hcmax_idx = [ i for i , x in enumerate ( Hc ) if x == Hcmax ] <NEWLINE> Wcmax = max ( Wc ) <NEWLINE> Wcmax_idx = [ i for i , x in enumerate ( Wc ) if x == Wcmax ] <NEWLINE> <NL> ans = Hcmax + Wcmax - 1 <NEWLINE> B = set ( B ) <NEWLINE> f = False <NEWLINE> for i in Hcmax_idx : <NEWLINE> <INDENT> if f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in Wcmax_idx : <NEWLINE> <INDENT> if ( i , j ) not in B : <NEWLINE> <INDENT> ans = Hcmax + Wcmax <NEWLINE> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> SUM = [ sum ( A ) ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> SUM . append ( ( SUM [ i - 1 ] - A [ i - 1 ] ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * SUM [ i + 1 ] <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , q = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> l = [ [ ] for i in range ( n ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a - 1 ] . append ( b - 1 ) <NEWLINE> l [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def dfs ( ) : <NEWLINE> <INDENT> que = [ 0 ] <NEWLINE> done = [ 0 ] * n <NEWLINE> done [ 0 ] = 1 <NEWLINE> while ( que ) : <NEWLINE> <INDENT> now = que . pop ( ) <NEWLINE> <NL> for i in l [ now ] : <NEWLINE> <INDENT> if done [ i ] == 0 : <NEWLINE> <INDENT> done [ i ] = 1 <NEWLINE> que . append ( i ) <NEWLINE> ans [ i ] += ans [ now ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( ) <NEWLINE> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> count = 0 <NEWLINE> num = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == num : <NEWLINE> <INDENT> count += 1 <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - count ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 3600 - m * 60 <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = I ( ) <NEWLINE> for a in range ( - 500 , 501 ) : <NEWLINE> <INDENT> for b in range ( - 500 , 501 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> return str ( a ) + <STRING> + str ( b ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( main ( ) ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> r_count = 0 <NEWLINE> l_count = 0 <NEWLINE> <NL> tmp_1 = X <NEWLINE> tmp_2 = X <NEWLINE> <NL> <NL> while tmp_1 != N : <NEWLINE> <INDENT> tmp_1 += 1 <NEWLINE> if tmp_1 in A : <NEWLINE> <INDENT> r_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while tmp_2 != 0 : <NEWLINE> <INDENT> tmp_2 -= 1 <NEWLINE> if tmp_2 in A : <NEWLINE> <INDENT> l_count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> res = min ( l_count , r_count ) <NEWLINE> print ( res ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> <NL> <NL> def gcd ( a : int , b : int , c : int ) -> int : <NEWLINE> <INDENT> return math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) -> None : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> one_to_k = range ( 1 , k + 1 ) <NEWLINE> s1 = sum ( one_to_k ) <NEWLINE> s2 = sum ( math . gcd ( a , b ) for a , b in itertools . combinations ( one_to_k , 2 ) ) <NEWLINE> s3 = sum ( gcd ( a , b , c ) for a , b , c in itertools . combinations ( one_to_k , 3 ) ) <NEWLINE> print ( s1 + 6 * s2 + 6 * s3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> flip = 0 <NEWLINE> front , back = <STRING> , <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> j = input ( ) <NEWLINE> if len ( j ) == 1 : <NEWLINE> <INDENT> flip += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j [ 2 ] == <STRING> and flip % 2 == 0 : <NEWLINE> <INDENT> front = j [ 4 ] + front <NEWLINE> continue <NEWLINE> <DEDENT> elif j [ 2 ] == <STRING> and flip % 2 == 0 : <NEWLINE> <INDENT> back = back + j [ 4 ] <NEWLINE> continue <NEWLINE> <DEDENT> elif j [ 2 ] == <STRING> and flip % 2 == 1 : <NEWLINE> <INDENT> back = back + j [ 4 ] <NEWLINE> continue <NEWLINE> <DEDENT> elif j [ 2 ] == <STRING> and flip % 2 == 1 : <NEWLINE> <INDENT> front = j [ 4 ] + front <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> S = front + S + back <NEWLINE> if flip % 2 == 1 : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p_n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> p_n . sort ( ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> ans += p_n [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> C = 0 <NEWLINE> for s in N : <NEWLINE> <INDENT> C += int ( s ) <NEWLINE> <DEDENT> if C % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <NL> for ai in A : <NEWLINE> <INDENT> if ai == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <NL> <INDENT> ans *= A [ i ] <NEWLINE> <NL> ansCp = ans <NEWLINE> ansCnt = 1 <NEWLINE> while ansCp >= 10 : <NEWLINE> <INDENT> ansCp /= 10 <NEWLINE> ansCnt += 1 <NEWLINE> <NL> <DEDENT> if ( ansCnt > 19 ) or ( ansCnt == 19 and ans % 10 > 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> C , * A = map ( int , input ( ) . split ( ) ) <NEWLINE> c . append ( C ) <NEWLINE> a . append ( A ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> A = [ 0 ] * m <NEWLINE> C = 0 <NEWLINE> lst = list ( map ( int , format ( i , <STRING> ) . zfill ( n ) ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if lst [ j ] == 1 : <NEWLINE> <INDENT> C += c [ j ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> A [ k ] += a [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if all ( elem >= x for elem in A ) : <NEWLINE> <INDENT> ans . append ( C ) <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def check ( l , r ) : <NEWLINE> <INDENT> th = 1 + ( r - l + 1 ) // 2 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if cnt [ i ] >= th : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> si = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> si [ i ] = ord ( s [ i ] ) - 97 <NEWLINE> <NL> <DEDENT> l , r = 0 , 1 <NEWLINE> cnt = [ 0 ] * 26 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> cnt [ si [ i ] ] += 1 <NEWLINE> <DEDENT> while l < n - 1 and r < n : <NEWLINE> <INDENT> if check ( l , r ) : <NEWLINE> <INDENT> print ( l + 1 , r + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif max ( cnt ) == 1 + ( r - l + 1 ) // 2 or r - l == 1 : <NEWLINE> <INDENT> r += 1 <NEWLINE> if r < n : <NEWLINE> <INDENT> cnt [ si [ r ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt [ si [ l ] ] -= 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( - 1 , - 1 ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> S = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> calc = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S += gcd ( calc , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
MOD = 1000000007 <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> def normalize ( a , b ) : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> return 0 , 0 <NEWLINE> <DEDENT> elif a != 0 and b == 0 : <NEWLINE> <INDENT> return 1 , 0 <NEWLINE> <DEDENT> elif a == 0 and b != 0 : <NEWLINE> <INDENT> return 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> return a , b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def rotate ( a , b ) : <NEWLINE> <INDENT> if b > 0 : <NEWLINE> <INDENT> return b , - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - b , a <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> dv = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = normalize ( a , b ) <NEWLINE> dv [ ( a , b ) ] = dv . get ( ( a , b ) , 0 ) + 1 <NEWLINE> <NL> <NL> <DEDENT> counted = { k : False for k in dv . keys ( ) } <NEWLINE> nc = 1 <NEWLINE> for k , v in dv . items ( ) : <NEWLINE> <INDENT> if not counted [ k ] : <NEWLINE> <INDENT> if k != ( 0 , 0 ) : <NEWLINE> <INDENT> a0 , b0 = k <NEWLINE> a1 , b1 = rotate ( a0 , b0 ) <NEWLINE> w = dv . get ( ( a1 , b1 ) , 0 ) <NEWLINE> <NL> nc *= 1 + ( pow ( 2 , v , MOD ) - 1 ) + ( pow ( 2 , w , MOD ) - 1 ) <NEWLINE> nc %= MOD <NEWLINE> <NL> <COMMENT> <NL> counted [ ( a1 , b1 ) ] = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> nc += dv . get ( ( 0 , 0 ) , 0 ) <NEWLINE> <NL> nc -= 1 <NEWLINE> nc %= MOD <NEWLINE> print ( nc ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b or a % b == 0 : <NEWLINE> <INDENT> print ( 0 , 1 ) <NEWLINE> <DEDENT> elif b % a == 0 : <NEWLINE> <INDENT> print ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> coe = [ [ 1 , 0 ] , [ 0 , 1 ] ] <NEWLINE> while b != 1 : <NEWLINE> <INDENT> quo = a // b <NEWLINE> coe_d1 = coe [ 1 ] <NEWLINE> coe_d2 = [ coe [ 0 ] [ 0 ] - coe [ 1 ] [ 0 ] * quo , coe [ 0 ] [ 1 ] - coe [ 1 ] [ 1 ] * quo ] <NEWLINE> coe = [ coe_d1 , coe_d2 ] <NEWLINE> a , b = b , a % b <NEWLINE> <DEDENT> print ( * coe [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
m = input ( ) <NEWLINE> N = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> c = 0 <NEWLINE> N . sort ( ) <NEWLINE> for i in range ( len ( N ) - 1 ) : <NEWLINE> <INDENT> if N [ i ] == N [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( i + 1 , n - i - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> used = [ False ] * n <NEWLINE> next = [ i + 1 for i in range ( m ) ] [ : : - 2 ] + [ i + 1 for i in range ( m ) ] [ - 2 : : - 2 ] <NEWLINE> i = 0 <NEWLINE> now = 0 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if used [ now ] == False and used [ now + next [ i ] ] == False : <NEWLINE> <INDENT> print ( now + 1 , now + next [ i ] + 1 ) <NEWLINE> count += 1 <NEWLINE> if count == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> used [ now ] = True <NEWLINE> used [ now + next [ i ] ] = True <NEWLINE> i += 1 <NEWLINE> now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <COMMENT> <NL> q = int ( input ( ) ) <NEWLINE> a = [ 0 for _ in range ( 8000000 ) ] <NEWLINE> start = 4000000 <NEWLINE> end = 4000001 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ops = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ops [ 0 ] == 0 : <NEWLINE> <INDENT> if ops [ 1 ] == 0 : <NEWLINE> <INDENT> a [ start ] = ops [ 2 ] <NEWLINE> start -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ end ] = ops [ 2 ] <NEWLINE> end += 1 <NEWLINE> <DEDENT> <DEDENT> elif ops [ 0 ] == 1 : <NEWLINE> <INDENT> print ( a [ start + ops [ 1 ] + 1 ] ) <NEWLINE> <DEDENT> elif ops [ 0 ] == 2 : <NEWLINE> <INDENT> if ops [ 1 ] == 0 : <NEWLINE> <INDENT> start += 1 <NEWLINE> <DEDENT> elif ops [ 1 ] == 1 : <NEWLINE> <INDENT> end -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT>
T = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( T ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> S = input ( ) <NEWLINE> dp = set ( [ 0 ] ) <NEWLINE> for a , s in zip ( A [ : : - 1 ] , S [ : : - 1 ] ) : <NEWLINE> <INDENT> for b in dp : <NEWLINE> <INDENT> a = min ( a , a ^ b ) <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if a : <NEWLINE> <INDENT> dp = set ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp2 = set ( [ a ] ) <NEWLINE> for b in dp : <NEWLINE> <INDENT> dp2 . add ( min ( b , a ^ b ) ) <NEWLINE> <DEDENT> dp = dp2 <NEWLINE> <DEDENT> <DEDENT> ans += [ 0 if 0 in dp else 1 ] <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
import bisect <NEWLINE> primes = [ 0 , 0 ] + [ 1 ] * 49999 <NEWLINE> for i in range ( 2 , 225 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 50001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> values = [ i for i , k in enumerate ( primes ) if k ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> I = bisect . bisect ( values , n // 2 ) <NEWLINE> print ( sum ( primes [ n - i ] for i in values [ : I ] ) ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> L = [ [ x , i ] for i , x in enumerate ( A ) ] <NEWLINE> L . sort ( ) <NEWLINE> dp = [ [ - 1 ] * N for _ in range ( N ) ] <NEWLINE> <NL> def rec ( l , r ) : <NEWLINE> <INDENT> if l > r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ l ] [ r ] >= 0 : <NEWLINE> <INDENT> return dp [ l ] [ r ] <NEWLINE> <DEDENT> idx = r - l <COMMENT> <NEWLINE> val , i = L [ idx ] <NEWLINE> dp [ l ] [ r ] = max ( abs ( i - l ) * val + rec ( l + 1 , r ) , abs ( r - i ) * val + rec ( l , r - 1 ) ) <NEWLINE> return dp [ l ] [ r ] <NEWLINE> <NL> <DEDENT> print ( rec ( 0 , N - 1 ) ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( x2 - ( y2 - y1 ) , y2 + ( x2 - x1 ) , x1 - ( y2 - y1 ) , y1 + ( x2 - x1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( 0 in a ) : print ( 0 ) <NEWLINE> else : print ( ans ) <NEWLINE>
one , zero , ng_one , card = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if card < one : <NEWLINE> <INDENT> print ( card ) <NEWLINE> <DEDENT> elif card <= one + zero : <NEWLINE> <INDENT> print ( one ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( one - ( card - one - zero ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> node = [ [ ] for _ in range ( n ) ] <NEWLINE> looked = [ 1 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> node [ b - 1 ] . append ( a - 1 ) <NEWLINE> node [ a - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> counter = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter [ p - 1 ] += x <NEWLINE> <DEDENT> queue = deque ( [ 0 ] ) <NEWLINE> looked [ 0 ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> now = queue . pop ( ) <NEWLINE> for i in node [ now ] : <NEWLINE> <INDENT> if looked [ i ] : <NEWLINE> <INDENT> queue . append ( i ) <NEWLINE> counter [ i ] += counter [ now ] <NEWLINE> looked [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * counter ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> a = N // X <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> print ( a * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a + 1 ) * T ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> limit = 10 ** 18 <NEWLINE> res = A [ 0 ] <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> res *= A [ i ] <NEWLINE> if res > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( ( input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> values = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> values . append ( int ( A [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> suffixSumArray = values . copy ( ) <NEWLINE> <NL> <NL> <NL> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + suffixSumArray [ i ] <NEWLINE> <NL> <NL> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum += ( values [ i ] * suffixSumArray [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> cnt = [ 0 ] * ( ( 10 ** 6 ) + 1 ) <NEWLINE> for elem in A : <NEWLINE> <INDENT> cnt [ elem ] += 1 <NEWLINE> <DEDENT> unique = [ ] <NEWLINE> for i in range ( ( 10 ** 6 ) + 1 ) : <NEWLINE> <INDENT> if cnt [ i ] == 1 : <NEWLINE> <INDENT> unique . append ( i ) <NEWLINE> <DEDENT> <DEDENT> cnt = [ 0 ] * ( ( 10 ** 6 ) + 1 ) <NEWLINE> A = list ( set ( A ) ) <NEWLINE> for elem in A : <NEWLINE> <INDENT> for m in range ( elem * 2 , 10 ** 6 + 1 , elem ) : <NEWLINE> <INDENT> cnt [ m ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in unique : <NEWLINE> <INDENT> if cnt [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> if 360 % x == 0 : <NEWLINE> <INDENT> print ( 360 // x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> common = 360 * x // math . gcd ( 360 , x ) <NEWLINE> ans = common // x <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ set ( ) for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ a - 1 ] . add ( b - 1 ) <NEWLINE> path [ b - 1 ] . add ( a - 1 ) <NEWLINE> <DEDENT> visited = [ 0 ] * N <NEWLINE> <NL> ans = 1 <NEWLINE> for u in range ( N ) : <NEWLINE> <INDENT> if visited [ u ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> curr = 1 <NEWLINE> visited [ u ] = 1 <NEWLINE> next_u = path [ u ] <NEWLINE> while next_u : <NEWLINE> <INDENT> v = next_u . pop ( ) <NEWLINE> if visited [ v ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ v ] = 1 <NEWLINE> curr += 1 <NEWLINE> for w in path [ v ] : <NEWLINE> <INDENT> if visited [ w ] == 0 : <NEWLINE> <INDENT> next_u . add ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , curr ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> check = { } <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x = i - A [ i ] <NEWLINE> y = A [ i ] + i <NEWLINE> ans += check . get ( x , 0 ) <NEWLINE> check . setdefault ( y , 0 ) <NEWLINE> check [ y ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> C = collections . Counter ( S ) <NEWLINE> L = C . most_common ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> flag = 0 <NEWLINE> <NL> for n in range ( len ( C ) ) : <NEWLINE> <INDENT> if L [ n ] [ 1 ] < flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( L [ n ] [ 0 ] ) <NEWLINE> flag = ( L [ n ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> <NL> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> <NL> def combination ( n , a ) : <NEWLINE> <COMMENT> <NL> <INDENT> res = 1 <NEWLINE> div = 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> res *= n - i <NEWLINE> res %= MOD <NEWLINE> div *= a - i <NEWLINE> div %= MOD <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> res = ( res * pow ( div , MOD - 2 , MOD ) ) % MOD <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> count = ( pow ( 2 , n , MOD ) - 1 - combination ( n , a ) - combination ( n , b ) ) % MOD <NEWLINE> print ( count ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
def bfs ( b ) : <NEWLINE> <INDENT> mem = [ [ False for i in range ( n ) ] for j in range ( 2 ) ] <NEWLINE> st = [ 0 , 0 ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if b [ i ] [ 0 ] != 1 : continue <NEWLINE> while st [ i ] < n - 1 and b [ i ] [ st [ i ] + 1 ] == 1 : <NEWLINE> <INDENT> st [ i ] += 1 <NEWLINE> <DEDENT> if st [ i ] == n - 1 : return 0 <NEWLINE> <DEDENT> mem [ 0 ] [ st [ 0 ] ] = True <NEWLINE> mem [ 1 ] [ st [ 1 ] ] = True <NEWLINE> que = [ [ 0 , st [ 0 ] , 0 ] , [ 1 , st [ 1 ] , 0 ] ] <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> d = que . pop ( 0 ) <NEWLINE> des = ( d [ 0 ] + 1 ) % 2 <NEWLINE> cst = d [ 2 ] + 1 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> fl = d [ 1 ] + i <NEWLINE> if fl >= n : break <NEWLINE> state = b [ des ] [ fl ] <NEWLINE> if state != 2 and fl == n - 1 : <NEWLINE> <INDENT> return cst <NEWLINE> <DEDENT> if state == 0 : <NEWLINE> <INDENT> if mem [ des ] [ fl ] == False : <NEWLINE> <INDENT> que . append ( [ des , fl , cst ] ) <NEWLINE> mem [ des ] [ fl ] = True <NEWLINE> <DEDENT> <DEDENT> elif state == 1 : <NEWLINE> <INDENT> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if fl + k >= n : return cst <NEWLINE> if b [ des ] [ fl + k ] != 1 : <NEWLINE> <INDENT> if mem [ des ] [ fl + k - 1 ] == False : <NEWLINE> <INDENT> que . append ( [ des , fl + k - 1 , cst ] ) <NEWLINE> mem [ des ] [ fl + k - 1 ] = True <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif state == 2 : <NEWLINE> <INDENT> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if b [ des ] [ fl - k ] != 2 : <NEWLINE> <INDENT> if mem [ des ] [ fl - k ] == False : <NEWLINE> <INDENT> que . append ( [ des , fl - k , cst ] ) <NEWLINE> mem [ des ] [ fl - k ] = True <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> b = [ [ int ( p ) for p in input ( ) . split ( <STRING> ) ] , [ int ( p ) for p in input ( ) . split ( <STRING> ) ] ] <NEWLINE> count = bfs ( b ) <NEWLINE> print ( str ( count ) if count >= 0 else <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <NL> <INDENT> def __init__ ( self , n : int ) -> None : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , i : int ) -> None : <NEWLINE> <INDENT> if self . parent [ i ] == i : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . find ( self . parent [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , i : int , j : int ) -> None : <NEWLINE> <INDENT> root_i = self . find ( i ) <NEWLINE> root_j = self . find ( j ) <NEWLINE> if root_i == root_j : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ root_i ] < self . rank [ root_j ] : <NEWLINE> <INDENT> self . parent [ root_i ] = root_j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ root_j ] = root_i <NEWLINE> if self . rank [ root_i ] == self . rank [ root_j ] : <NEWLINE> <INDENT> self . rank [ root_i ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf1 = UnionFind ( N ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> uf1 . unite ( i - 1 , j - 1 ) <NEWLINE> <NL> <DEDENT> uf2 = UnionFind ( N ) <NEWLINE> for _ in range ( L ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> uf2 . unite ( i - 1 , j - 1 ) <NEWLINE> <NL> <DEDENT> set_id_pairs = [ ( uf1 . find ( i ) , uf2 . find ( i ) ) for i in range ( N ) ] <NEWLINE> counter = Counter ( set_id_pairs ) <NEWLINE> counts = [ counter [ set_id_pairs [ i ] ] for i in range ( N ) ] <NEWLINE> print ( <STRING> . join ( str ( c ) for c in counts ) ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( d ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> L = defaultdict ( lambda : 0 ) <NEWLINE> R = defaultdict ( lambda : 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L [ i + A [ i ] ] += 1 <NEWLINE> R [ i - A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for key in L : <NEWLINE> <INDENT> cnt += L [ key ] * R [ key ] <NEWLINE> <NL> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> bitcount = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> bitcount += 1 <NEWLINE> <DEDENT> <DEDENT> bp = bitcount + 1 <NEWLINE> bm = bitcount - 1 <NEWLINE> <NL> lsp = [ 1 for i in range ( N ) ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> lsp [ i ] = ( lsp [ i - 1 ] * 2 ) % bp <NEWLINE> <DEDENT> lsp . reverse ( ) <NEWLINE> fXp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> fXp = ( fXp + lsp [ i ] ) % bp <NEWLINE> <NL> <DEDENT> <DEDENT> if bm != 0 : <NEWLINE> <INDENT> lsm = [ 1 for i in range ( N ) ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> lsm [ i ] = ( lsm [ i - 1 ] * 2 ) % bm <NEWLINE> <DEDENT> lsm . reverse ( ) <NEWLINE> fXm = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> fXm = ( fXm + lsm [ i ] ) % bm <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> x = 1 <NEWLINE> while x <= n : <NEWLINE> <INDENT> if n & x > 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> x *= 2 <NEWLINE> <DEDENT> return n % c <NEWLINE> <NL> <DEDENT> ls = [ 0 for i in range ( bitcount + 2 ) ] <NEWLINE> for i in range ( 1 , bitcount + 2 ) : <NEWLINE> <INDENT> ls [ i ] = ls [ f ( i ) ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> print ( ls [ ( fXp + lsp [ i ] ) % bp ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if bm == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ls [ ( fXm - lsm [ i ] ) % bm ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> prices = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> stock_num = 0 <NEWLINE> cash = 1000 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if prices [ i + 1 ] >= prices [ i ] : <NEWLINE> <INDENT> temp = cash // prices [ i ] <NEWLINE> cash -= prices [ i ] * temp <NEWLINE> stock_num += temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cash += stock_num * prices [ i ] <NEWLINE> stock_num = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> cash += stock_num * prices [ n - 1 ] <NEWLINE> stock_num = 0 <NEWLINE> <NL> print ( cash ) <NEWLINE>
from collections import deque <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( [ a , b ] ) <NEWLINE> g [ b ] . append ( [ b , a ] ) <NEWLINE> <DEDENT> res = [ [ 0 , INF ] for _ in range ( n + 1 ) ] <NEWLINE> res [ 1 ] [ 1 ] = 0 <NEWLINE> q = deque ( g [ 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> q_ = q . popleft ( ) <NEWLINE> if res [ q_ [ 1 ] ] [ 1 ] == INF : <NEWLINE> <INDENT> for gi in g [ q_ [ 1 ] ] : q . append ( gi ) <NEWLINE> res [ q_ [ 1 ] ] [ 0 ] = q_ [ 0 ] <NEWLINE> res [ q_ [ 1 ] ] [ 1 ] = res [ q_ [ 0 ] ] [ 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in res [ 2 : ] : print ( i [ 0 ] ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> <NL> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( t ) <= 2 : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> elif t [ 1 ] == <STRING> : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> t [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if i + 1 == len ( t ) : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> b = <STRING> <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> b += t [ i ] <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> sX = input ( ) <NEWLINE> <NL> origin_count = sX . count ( <STRING> ) <NEWLINE> one_r_count = origin_count - 1 <NEWLINE> zero_r_count = origin_count + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> for b in sX : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_r_count <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_r_count <NEWLINE> <NL> <DEDENT> f = [ 0 ] * 220000 <NEWLINE> pop = [ 0 ] * 220000 <NEWLINE> <NL> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> pop [ i ] = pop [ i // 2 ] + i % 2 <NEWLINE> f [ i ] = f [ i % pop [ i ] ] + 1 <NEWLINE> <NL> <DEDENT> onepow = [ 1 ] * 220000 <NEWLINE> zeropow = [ 1 ] * 220000 <NEWLINE> <NL> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> onepow [ i ] = onepow [ i - 1 ] * 2 % one_r_count <NEWLINE> <DEDENT> zeropow [ i ] = zeropow [ i - 1 ] * 2 % zero_r_count <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if sX [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if one_r_count != 0 : <NEWLINE> <INDENT> Xi_n = one_mod - onepow [ N - i ] <NEWLINE> Xi_n %= one_r_count <NEWLINE> print ( f [ Xi_n ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Xi_n = zero_mod + zeropow [ N - i ] <NEWLINE> Xi_n %= zero_r_count <NEWLINE> print ( f [ Xi_n ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list . append ( input ( ) ) <NEWLINE> <DEDENT> list = set ( list ) <NEWLINE> print ( len ( list ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> inint = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inintm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inintl = lambda : list ( inintm ( ) ) <NEWLINE> instrm = lambda : map ( str , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> instrl = lambda : list ( instrm ( ) ) <NEWLINE> <NL> n = inint ( ) <NEWLINE> A = inintl ( ) <NEWLINE> <NL> m = min ( A ) <NEWLINE> <NL> mod_min = 10 ** 9 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a % m == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> mod_min = min ( mod_min , a % m ) <NEWLINE> <NL> <DEDENT> if mod_min == 10 ** 9 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . gcd ( m , mod_min ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> table = [ [ 0 ] * K for i in range ( K ) ] <NEWLINE> <NL> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( a , K ) : <NEWLINE> <INDENT> tmp = math . gcd ( a + 1 , b + 1 ) <NEWLINE> table [ a ] [ b ] = tmp <NEWLINE> table [ b ] [ a ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> for c in range ( K ) : <NEWLINE> <INDENT> res += table [ table [ a ] [ b ] - 1 ] [ c ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while a ** 5 - ( a - 1 ) ** 5 <= x : <NEWLINE> <INDENT> a += 1 <NEWLINE> b = a <NEWLINE> while a ** 5 - b ** 5 < x : <NEWLINE> <INDENT> b -= 1 <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a_list [ i ] < a_list [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> <COMMENT> <NL> from collections import defaultdict <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> <NL> for x in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( x , y ) , z ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mon = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mon . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( mon [ k : ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> a . sort ( ) <NEWLINE> b = sorted ( b , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> d = [ ] <NEWLINE> j = 0 <NEWLINE> while ( n <= len ( a ) or j < m ) : <NEWLINE> <INDENT> C = b [ j ] [ 1 ] <NEWLINE> B = b [ j ] [ 0 ] <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> d . append ( C ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> if j >= m or len ( d ) > len ( a ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( min ( len ( d ) , len ( a ) ) ) : <NEWLINE> <INDENT> if a [ i ] < d [ i ] : <NEWLINE> <INDENT> a [ i ] = d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( ( r ** 2 ) * math . pi , r * 2 * math . pi ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> b = a [ i ] <NEWLINE> c [ b ] += 1 <NEWLINE> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ j ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 200_000 ) <NEWLINE> <NL> def solve ( N : int , a : <STRING> , b : <STRING> ) : <NEWLINE> <INDENT> from itertools import count <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for i , ( aa , bb ) in enumerate ( zip ( a , b ) ) : <NEWLINE> <INDENT> edges [ aa - 1 ] . append ( ( bb - 1 , i ) ) <NEWLINE> edges [ bb - 1 ] . append ( ( aa - 1 , i ) ) <NEWLINE> <DEDENT> ans = [ None ] * ( N - 1 ) <NEWLINE> visited = set ( ) <NEWLINE> def dfs ( n , c ) : <NEWLINE> <INDENT> if n in visited : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> visited . add ( n ) <NEWLINE> for ( nn , i ) , cc in zip ( filter ( lambda x : x [ 0 ] not in visited , edges [ n ] ) , <NEWLINE> <INDENT> filter ( lambda y : y != c , count ( 1 ) ) ) : <NEWLINE> ans [ i ] = cc <NEWLINE> dfs ( nn , cc ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , None ) <NEWLINE> return [ max ( ans ) ] + ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( ) ] * ( N - 1 ) <COMMENT> <NEWLINE> b = [ int ( ) ] * ( N - 1 ) <COMMENT> <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a [ i ] = int ( next ( tokens ) ) <NEWLINE> b [ i ] = int ( next ( tokens ) ) <NEWLINE> <DEDENT> print ( * solve ( N , a , b ) , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LIST = [ 0 ] * ( 100001 ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> <NL> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> LIST [ i ] += 1 <NEWLINE> <NL> <DEDENT> s = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> s += LIST [ b [ i ] ] * ( c [ i ] - b [ i ] ) <NEWLINE> LIST [ c [ i ] ] += LIST [ b [ i ] ] <NEWLINE> LIST [ b [ i ] ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> start = [ K - Q ] * N <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> start [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if start [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> o = input ( ) . split ( ) <NEWLINE> if o [ 0 ] == <STRING> : <NEWLINE> <INDENT> dic . add ( o [ 1 ] ) <NEWLINE> <DEDENT> elif o [ 1 ] in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( a , b ) , c ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( a , b ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> Asum = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> Asum = Asum * int ( i ) <NEWLINE> if Asum > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( Asum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k and x + y + z == s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> x = int ( input ( ) ) <NEWLINE> tmp_list = [ ] <NEWLINE> c = 0 <NEWLINE> tmp_2 = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> tmp_1 = c ** 5 <NEWLINE> if ( tmp_1 - tmp_2 ) <= x : <NEWLINE> <INDENT> tmp_list += [ tmp_1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp_2 = tmp_1 <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> def せいがわ ( target : list , x ) -> list : <NEWLINE> <INDENT> for i in np . flipud ( target ) : <NEWLINE> <INDENT> for j in target : <NEWLINE> <INDENT> tmp = i + j <NEWLINE> if tmp == x : <NEWLINE> <INDENT> return [ int ( i ** ( 1 / 5 ) ) , int ( j ** ( 1 / 5 ) ) * - 1 ] <NEWLINE> <DEDENT> if tmp > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def ふがわ ( target : list , x ) -> list : <NEWLINE> <INDENT> for i in np . flipud ( target ) : <NEWLINE> <INDENT> for j in target : <NEWLINE> <INDENT> tmp = i - j <NEWLINE> if tmp == x : <NEWLINE> <INDENT> return [ int ( i ** ( 1 / 5 ) ) , int ( j ** ( 1 / 5 ) ) ] <NEWLINE> <DEDENT> if tmp < x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> ans = ふがわ ( tmp_list , x ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> ans = せいがわ ( tmp_list , x ) <NEWLINE> <DEDENT> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = x <NEWLINE> li = [ a ] <NEWLINE> exists = dict ( ) <NEWLINE> i = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> a = a * a % m <NEWLINE> if a in exists : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> li . append ( a ) <NEWLINE> exists [ a ] = i <NEWLINE> <NL> <DEDENT> ans = sum ( li ) <NEWLINE> if i != n : <NEWLINE> <INDENT> loop , left = divmod ( n - i + 1 , i - exists [ a ] ) <NEWLINE> ans += loop * sum ( li [ exists [ a ] - 1 : ] ) + sum ( li [ exists [ a ] - 1 : exists [ a ] - 1 + left ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> nu = i + 1 <NEWLINE> x = a [ i ] <NEWLINE> l . append ( x + nu ) <NEWLINE> r . append ( nu - x ) <NEWLINE> <NL> <DEDENT> di1 = { } <NEWLINE> di2 = { } <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if l [ i ] not in di1 : <NEWLINE> <INDENT> di1 [ l [ i ] ] = 0 <NEWLINE> <DEDENT> di1 [ l [ i ] ] += 1 <NEWLINE> if r [ i + 1 ] not in di2 : <NEWLINE> <INDENT> di2 [ r [ i + 1 ] ] = 0 <NEWLINE> <DEDENT> di2 [ r [ i + 1 ] ] += 1 <NEWLINE> if r [ i + 1 ] in di1 : <NEWLINE> <INDENT> ans += di1 [ r [ i + 1 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans >= 10 ** 9 + 7 : <NEWLINE> <INDENT> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import random <NEWLINE> i = input ( ) <NEWLINE> len_i = len ( i ) <NEWLINE> num = 0 <NEWLINE> if len_i != 3 : <NEWLINE> <INDENT> num = random . randint ( 0 , len_i - 4 ) <NEWLINE> <DEDENT> print ( i [ num ] + i [ num + 1 ] + i [ num + 2 ] ) <NEWLINE>
<COMMENT> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> def check ( A ) : <NEWLINE> <INDENT> global ans <NEWLINE> max_ = 0 <NEWLINE> <NL> <COMMENT> <NL> for ( a , b , c , d ) in abcd : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> max_ += d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max ( ans , max_ ) <NEWLINE> <NL> <DEDENT> def suretu ( A = [ ] , st = 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( st , m + 1 ) : <NEWLINE> <INDENT> if len ( A ) == n : <COMMENT> <NEWLINE> <INDENT> check ( A ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suretu ( A + [ i ] , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( suretu ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> M = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] > M : <NEWLINE> <INDENT> M = A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += M - A [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> res = 1 <NEWLINE> for x in l : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ - 1 for _ in range ( M ) ] <NEWLINE> w = [ - 1 for _ in range ( M ) ] <NEWLINE> s = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h [ i ] , w [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ i ] -= 1 <NEWLINE> w [ i ] -= 1 <NEWLINE> s . add ( ( h [ i ] , w [ i ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> hs = [ 0 for _ in range ( H ) ] <NEWLINE> ws = [ 0 for _ in range ( W ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> hs [ h [ i ] ] += 1 <NEWLINE> ws [ w [ i ] ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> hmax = max ( hs ) <NEWLINE> wmax = max ( ws ) <NEWLINE> <NL> ks = [ ] <NEWLINE> js = [ ] <NEWLINE> <NL> <COMMENT> <NL> for k in range ( H ) : <NEWLINE> <INDENT> if hmax == hs [ k ] : <NEWLINE> <INDENT> ks . append ( k ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( W ) : <NEWLINE> <INDENT> if wmax == ws [ j ] : <NEWLINE> <INDENT> js . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = hmax + wmax <NEWLINE> <NL> <COMMENT> <NL> for k in range ( len ( ks ) ) : <NEWLINE> <INDENT> for j in range ( len ( js ) ) : <NEWLINE> <INDENT> if ( ks [ k ] , js [ j ] ) not in s : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
import re <NEWLINE> class c ( int ) : <NEWLINE> <INDENT> global p <NEWLINE> def __add__ ( self , n ) : <NEWLINE> <INDENT> return c ( ( int ( self ) + int ( n ) ) % p ) <NEWLINE> <DEDENT> def __sub__ ( self , n ) : <NEWLINE> <INDENT> return c ( ( int ( self ) - int ( n ) ) % p ) <NEWLINE> <DEDENT> def __mul__ ( self , n ) : <NEWLINE> <INDENT> return c ( ( int ( self ) * int ( n ) ) % p ) <NEWLINE> <DEDENT> def __truediv__ ( self , n ) : <NEWLINE> <INDENT> if n == 0 : raise ZeroDivisionError <NEWLINE> return self * pow ( int ( n ) , p - 2 , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> p , f = input ( ) . replace ( <STRING> , <STRING> ) . split ( <STRING> ) <NEWLINE> p = int ( p ) <NEWLINE> if p == 0 : break <NEWLINE> try : print ( <STRING> % ( f , eval ( re . sub ( <STRING> , <STRING> , f ) ) , p ) ) <NEWLINE> except : print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * A , = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import bisect <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( bisect . bisect_right ( A , i ) - bisect . bisect_left ( A , i ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) ; a = len ( s ) <NEWLINE> t = input ( ) ; b = len ( t ) <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : return a <NEWLINE> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <DEDENT> L = lcm ( len ( s ) , len ( t ) ) <NEWLINE> <NL> d = { } <NEWLINE> now = 0 <NEWLINE> for i in range ( 0 , L , L // a ) : <NEWLINE> <INDENT> d [ i ] = s [ now ] <NEWLINE> now += 1 <NEWLINE> <DEDENT> now = 0 <NEWLINE> for j in range ( 0 , L , L // b ) : <NEWLINE> <INDENT> if d . get ( j , t [ now ] ) != t [ now ] : <NEWLINE> <INDENT> print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> now += 1 <NEWLINE> <DEDENT> print ( L ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> <NL> s . sort ( ) <NEWLINE> t . sort ( reverse = True ) <NEWLINE> <NL> flg = False <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i >= len ( t ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ord ( s [ i ] ) > ord ( t [ i ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ord ( s [ i ] ) < ord ( t [ i ] ) : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> if i == len ( s ) - 1 and i < len ( t ) - 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if flg else print ( <STRING> ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = a + b <NEWLINE> r = c + d <NEWLINE> if l > r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l < r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = { } <NEWLINE> ab1 = { } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab . setdefault ( a , set ( ) ) . add ( b ) <NEWLINE> ab . setdefault ( b , set ( ) ) . add ( a ) <NEWLINE> ab1 . setdefault ( a , set ( ) ) . add ( b ) <NEWLINE> ab1 . setdefault ( b , set ( ) ) . add ( a ) <NEWLINE> <DEDENT> g = [ ] <NEWLINE> g . append ( set ( [ 1 ] ) ) <NEWLINE> marked = set ( ) <NEWLINE> marked . add ( 1 ) <NEWLINE> while ab : <NEWLINE> <INDENT> g_add = set ( ) <NEWLINE> for k in g [ - 1 ] : <NEWLINE> <INDENT> for x in ab [ k ] : <NEWLINE> <INDENT> if x not in marked : <NEWLINE> <INDENT> g_add . add ( x ) <NEWLINE> marked . add ( x ) <NEWLINE> <DEDENT> <DEDENT> del ab [ k ] <NEWLINE> <DEDENT> g . append ( g_add ) <NEWLINE> <DEDENT> if len ( marked ) < n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> result = [ None ] * n <NEWLINE> for i , s in enumerate ( g ) : <NEWLINE> <INDENT> if not i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in s : <NEWLINE> <INDENT> result [ k - 1 ] = ( g [ i - 1 ] & ab1 [ k ] ) . pop ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> cand = i ** 5 - j ** 5 <NEWLINE> if X == cand : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> a_sum = [ a [ 0 ] ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a_sum . append ( ( a_sum [ i ] + a [ i + 1 ] ) % 1000000007 ) <NEWLINE> <NL> ans += a_sum [ i ] * ( a [ i + 1 ] % 1000000007 ) <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
def fun ( a , n ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> z = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> z = z * i <NEWLINE> if ( z > 1000000000000000000 ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return z <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = fun ( a , n ) <NEWLINE> print ( f ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * ( n + 2 ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> arr = make_divisors ( n ) <NEWLINE> total = 0 <NEWLINE> for m in arr : <NEWLINE> <INDENT> r = n // m <NEWLINE> <NL> if r < m - 1 : <NEWLINE> <INDENT> total += m - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ 0 ] * M <NEWLINE> R = [ 0 ] * M <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> l = max ( L ) <NEWLINE> r = min ( R ) <NEWLINE> <NL> print ( max ( r - l + 1 , 0 ) ) <NEWLINE>
<COMMENT> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> desc = <STRING> . format ( l [ 0 ] , l [ 1 ] , l [ 2 ] ) <NEWLINE> print ( desc ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> b = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> <DEDENT> c = int ( input ( ) ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if b [ n ] > 0 : <NEWLINE> <INDENT> x = b [ n ] <NEWLINE> if x > 0 : <NEWLINE> <INDENT> b [ m ] += x <NEWLINE> b [ n ] = 0 <NEWLINE> ans += ( m - n ) * x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> from math import gcd <NEWLINE> import itertools <NEWLINE> <NL> <COMMENT> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SR ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> ascii_lowercase = <STRING> <NEWLINE> ascii_uppercase = <STRING> <NEWLINE> ascii_uppercase2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> p2E = lambda x : print ( <STRING> . join ( x ) ) <NEWLINE> p2S = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( gcd , numbers ) <NEWLINE> <NL> <DEDENT> def euclid ( p , q ) : <NEWLINE> <INDENT> if p % q == 0 : <NEWLINE> <INDENT> return q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return euclid ( q , p % q ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = II ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = gcd ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += gcd ( x , k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , collections , itertools , bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ds = set ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) - set ( D ) <NEWLINE> if 0 in Ds : <NEWLINE> <INDENT> can = list ( itertools . product ( Ds , repeat = 5 ) ) <NEWLINE> candi = [ ] <NEWLINE> for c in can : <NEWLINE> <INDENT> candi . append ( 10 ** 4 * c [ 0 ] + 10 ** 3 * c [ 1 ] + 10 ** 2 * c [ 2 ] + 10 ** 1 * c [ 3 ] + c [ 4 ] ) <NEWLINE> <DEDENT> candi = sorted ( candi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ds = Ds | set ( [ 0 ] ) <NEWLINE> can = list ( itertools . product ( Ds , repeat = 5 ) ) <NEWLINE> candi = [ ] <NEWLINE> for c in can : <NEWLINE> <INDENT> cs = ( 10 ** 4 * c [ 0 ] + 10 ** 3 * c [ 1 ] + 10 ** 2 * c [ 2 ] + 10 ** 1 * c [ 3 ] + c [ 4 ] ) <NEWLINE> s = list ( str ( cs ) ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> candi . append ( cs ) <NEWLINE> <DEDENT> <DEDENT> candi = sorted ( candi ) <NEWLINE> <NL> <DEDENT> print ( candi [ bisect . bisect_left ( candi , N ) ] ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import math <NEWLINE> if N == 1 : <NEWLINE> <INDENT> if l [ 0 ] == K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> A = math . gcd ( l [ 0 ] , l [ 1 ] ) <NEWLINE> if K <= max ( l ) : <NEWLINE> <INDENT> for i in range ( max ( 0 , N - 2 ) ) : <NEWLINE> <INDENT> A = math . gcd ( A , l [ i + 2 ] ) <NEWLINE> <DEDENT> if K % A == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( <STRING> . join ( sorted ( input ( ) ) ) ) <NEWLINE> <NL> <DEDENT> t = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] in t : <NEWLINE> <INDENT> t [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ s [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( t [ k ] * ( t [ k ] - 1 ) // 2 for k in t ) ) <COMMENT> <NEWLINE>
K = int ( input ( ) ) <NEWLINE> n = len ( str ( K ) ) <NEWLINE> N = int ( <STRING> * n ) <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while N % K != 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> N = N * 10 + 7 <NEWLINE> N %= K <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> n = 0 <NEWLINE> i = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( set ( S [ i : i + 2 ] ) ) == 2 : <NEWLINE> <INDENT> S = S [ : i ] + S [ i + 2 : ] <NEWLINE> n += 2 <NEWLINE> if i != 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 120 , 121 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 121 ) : <NEWLINE> <INDENT> if pow ( i , 5 ) - pow ( j , 5 ) == x : <NEWLINE> <INDENT> print ( i , j ) ; exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> from collections import Counter <NEWLINE> import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , * ab = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> ab_zero = 0 <NEWLINE> ratio = [ ] <NEWLINE> for a , b in zip ( * [ iter ( ab ) ] * 2 ) : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> ab_zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> ratio . append ( ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> ab_zero %= MOD <NEWLINE> <NL> s = Counter ( ratio ) <NEWLINE> <NL> bad = 1 <NEWLINE> for k , v in s . items ( ) : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> a , b = k <NEWLINE> if ( - a , - b ) in s : <NEWLINE> <INDENT> v += s [ ( - a , - b ) ] <NEWLINE> s [ ( - a , - b ) ] = 0 <NEWLINE> <NL> <DEDENT> inv = 0 <NEWLINE> if ( - b , a ) in s : <NEWLINE> <INDENT> inv += s [ ( - b , a ) ] <NEWLINE> s [ ( - b , a ) ] = 0 <NEWLINE> <DEDENT> if ( b , - a ) in s : <NEWLINE> <INDENT> inv += s [ ( b , - a ) ] <NEWLINE> s [ ( b , - a ) ] = 0 <NEWLINE> <NL> <DEDENT> bad *= ( pow ( 2 , v , MOD ) + pow ( 2 , inv , MOD ) - 1 ) % MOD <NEWLINE> bad %= MOD <NEWLINE> s [ k ] = 0 <NEWLINE> <NL> <DEDENT> ans = ( bad + ab_zero - 1 ) % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] * 3 <NEWLINE> dp = [ [ - 1 for i in range ( n * 2 ) ] for j in range ( n * 2 ) ] <NEWLINE> <NL> def dfs ( i , j ) : <NEWLINE> <COMMENT> <NL> <INDENT> if dp [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif ( j - i == n - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = 0 <NEWLINE> <DEDENT> elif ( j - i ) % 2 == 0 : <NEWLINE> <INDENT> if A [ i - 1 ] > A [ j + 1 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = dfs ( i - 1 , j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = dfs ( i , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dfs ( i - 1 , j ) + A [ i - 1 ] , dfs ( i , j + 1 ) + A [ j + 1 ] ) <NEWLINE> <DEDENT> return dp [ i ] [ j ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , dfs ( i , i ) + A [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappop , heapify <NEWLINE> <NL> <NL> N , K , * V = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( min ( N + 1 , i + 1 ) ) : <NEWLINE> <INDENT> for k in range ( j + 1 ) : <NEWLINE> <INDENT> right = N - j + k <NEWLINE> tmp = V [ : k ] + V [ right : ] <NEWLINE> <NL> put_out_cnt = i - j <NEWLINE> heapify ( tmp ) <NEWLINE> while tmp and put_out_cnt > 0 : <NEWLINE> <INDENT> heappop ( tmp ) <NEWLINE> put_out_cnt -= 1 <NEWLINE> <DEDENT> ans = max ( ans , sum ( tmp ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> s = S % 60 <NEWLINE> m = S // 60 % 60 <NEWLINE> h = S // 60 // 60 <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> n = ii ( ) <NEWLINE> A = iil ( ) <NEWLINE> di = Counter ( A ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> l = set ( ) <NEWLINE> for item in A : <NEWLINE> <INDENT> if di [ item ] > 1 : <NEWLINE> <INDENT> if item not in l : <NEWLINE> <INDENT> for i in range ( 1 , 1000000 // item + 1 ) : <NEWLINE> <INDENT> l . add ( item * i ) <NEWLINE> <DEDENT> <DEDENT> continue <NEWLINE> <DEDENT> if item not in l : <NEWLINE> <INDENT> for i in range ( 1 , 1000000 // item + 1 ) : <NEWLINE> <INDENT> l . add ( item * i ) <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a , b = rm ( ) <NEWLINE> s = rr ( ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if s [ i ] not in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> if s [ a + 1 + i ] not in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if s [ a ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> N , M = LI ( ) <NEWLINE> XY = [ LI ( ) for _ in range ( M ) ] <NEWLINE> <NL> w = [ None ] * N <NEWLINE> links = [ [ ] for _ in range ( N ) ] <NEWLINE> visit = [ False ] * N <NEWLINE> <NL> <NL> def create_links ( ) : <NEWLINE> <INDENT> for x , y in XY : <NEWLINE> <INDENT> links [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( u ) : <NEWLINE> <INDENT> visit [ u ] = True <NEWLINE> n = 0 <NEWLINE> for v in links [ u ] : <NEWLINE> <INDENT> if not visit [ v ] : <NEWLINE> <INDENT> w [ v ] = dfs ( v ) <NEWLINE> <DEDENT> n = max ( n , w [ v ] ) <NEWLINE> <DEDENT> return n + 1 <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> create_links ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not visit [ i ] : <NEWLINE> <INDENT> w [ i ] = dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( w ) - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> route = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = [ int ( y ) for y in input ( ) . split ( <STRING> ) ] <NEWLINE> route [ A - 1 ] += [ B ] <NEWLINE> route [ B - 1 ] += [ A ] <NEWLINE> <NL> <DEDENT> checked = [ 1 ] + [ 0 ] * ( N - 1 ) <NEWLINE> to_check = [ { <STRING> : s , <STRING> : 1 } for s in route [ 0 ] ] <NEWLINE> signal = [ - 1 ] + [ 0 ] * ( N - 1 ) <NEWLINE> <NL> for r in route [ 0 ] : <NEWLINE> <INDENT> checked [ r - 1 ] = 1 <NEWLINE> <NL> <DEDENT> while len ( to_check ) > 0 : <NEWLINE> <INDENT> checking = to_check . pop ( 0 ) <NEWLINE> src = checking [ <STRING> ] <NEWLINE> signal [ src - 1 ] = str ( checking [ <STRING> ] ) <NEWLINE> rooms = route [ src - 1 ] <NEWLINE> for r in rooms : <NEWLINE> <INDENT> if checked [ r - 1 ] == 0 : <NEWLINE> <INDENT> to_check . append ( { <STRING> : r , <STRING> : src } ) <NEWLINE> checked [ r - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if signal . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( signal [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = N % K <NEWLINE> N = min ( t , K - t ) <NEWLINE> <NL> print ( N ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> result [ i + 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] in result : <NEWLINE> <INDENT> result [ A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in result . values ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> lcm = { } <NEWLINE> ps = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> p = 2 <NEWLINE> ps . append ( { } ) <NEWLINE> while p * p <= ai : <NEWLINE> <INDENT> if ai % p == 0 : <NEWLINE> <INDENT> ps [ i ] [ p ] = 0 <NEWLINE> while ai % p == 0 : <NEWLINE> <INDENT> ps [ i ] [ p ] += 1 <NEWLINE> ai //= p <NEWLINE> <DEDENT> lcm [ p ] = max ( lcm . get ( p , 0 ) , ps [ i ] [ p ] ) <NEWLINE> <DEDENT> p += 1 <NEWLINE> <DEDENT> if ai > 1 : <NEWLINE> <INDENT> ps [ i ] [ ai ] = 1 <NEWLINE> lcm [ ai ] = max ( lcm . get ( ai , 0 ) , ps [ i ] [ ai ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> lcmv = 1 <NEWLINE> for p in lcm : <NEWLINE> <INDENT> lcmv = ( lcmv * ( p ** lcm [ p ] ) ) % mod <NEWLINE> <NL> <DEDENT> def inv ( p , k ) : <NEWLINE> <INDENT> k = mod - k - 1 <NEWLINE> ret = 1 <NEWLINE> b = p <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ret = ( ret * b ) % mod <NEWLINE> <DEDENT> b = ( b * b ) % mod <NEWLINE> k //= 2 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> prod = lcmv <NEWLINE> for p in ps [ i ] : <NEWLINE> <INDENT> prod = ( prod * inv ( p , ps [ i ] [ p ] ) ) % mod <NEWLINE> <DEDENT> ret = ( ret + prod ) % mod <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE> <NL>
from sys import stdin <NEWLINE> <NL> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nNum = [ int ( stdin . readline ( ) . rstrip ( ) ) for i in range ( n ) ] <NEWLINE> <NL> def isPrime ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n < 2 or n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if i * i > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> print ( len ( [ True for x in nNum if isPrime ( x ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt = n // i <NEWLINE> ans += i * cnt * ( cnt + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> if sys . version [ 0 ] == <STRING> : <NEWLINE> <INDENT> range , input = xrange , raw_input <NEWLINE> <DEDENT> MAX_SPEED = 30 <NEWLINE> while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if not ( N | M ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S , G = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y , d , c = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( ( y - 1 , d , c ) ) <NEWLINE> edge [ y - 1 ] . append ( ( x - 1 , d , c ) ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> dist = [ [ [ INF for _ in range ( N ) ] for _ in range ( MAX_SPEED + 1 ) ] for _ in range ( N ) ] <NEWLINE> que = [ ( 0.0 , S , 0 , S ) ] <NEWLINE> while que : <NEWLINE> <INDENT> cost , now , v , prev = heapq . heappop ( que ) <NEWLINE> if cost > dist [ now ] [ v ] [ prev ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if now == G and v == 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( cost ) ) <NEWLINE> break <NEWLINE> <DEDENT> dist [ now ] [ v ] [ prev ] = cost <NEWLINE> for x , d , c in edge [ now ] : <NEWLINE> <INDENT> if x == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if 0 < v <= c and dist [ x ] [ v ] [ now ] > dist [ now ] [ v ] [ prev ] + d / v : <NEWLINE> <INDENT> dist [ x ] [ v ] [ now ] = dist [ now ] [ v ] [ prev ] + d / v <NEWLINE> heapq . heappush ( que , ( dist [ x ] [ v ] [ now ] , x , v , now ) ) <NEWLINE> <DEDENT> if v < c and dist [ x ] [ v + 1 ] [ now ] > dist [ now ] [ v ] [ prev ] + d / ( v + 1 ) : <NEWLINE> <INDENT> dist [ x ] [ v + 1 ] [ now ] = dist [ now ] [ v ] [ prev ] + d / ( v + 1 ) <NEWLINE> heapq . heappush ( que , ( dist [ x ] [ v + 1 ] [ now ] , x , v + 1 , now ) ) <NEWLINE> <DEDENT> if 1 < v <= c + 1 and dist [ x ] [ v - 1 ] [ now ] > dist [ now ] [ v ] [ prev ] + d / ( v - 1 ) : <NEWLINE> <INDENT> dist [ x ] [ v - 1 ] [ now ] = dist [ now ] [ v ] [ prev ] + d / ( v - 1 ) <NEWLINE> heapq . heappush ( que , ( dist [ x ] [ v - 1 ] [ now ] , x , v - 1 , now ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if not h : break <NEWLINE> sss = [ [ 1 if s == <STRING> else 0 for s in input ( ) . split ( ) ] for i in range ( h ) ] <NEWLINE> dp = [ [ 0 for i in range ( w + 1 ) ] for j in range ( h + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = n - 1 <NEWLINE> for x in range ( h ) : <NEWLINE> <INDENT> for y in range ( w ) : <NEWLINE> <INDENT> a = dp [ x ] [ y ] <NEWLINE> if sss [ x ] [ y ] : <NEWLINE> <INDENT> if a % 2 : <NEWLINE> <INDENT> dp [ x + 1 ] [ y ] += a // 2 <NEWLINE> dp [ x ] [ y + 1 ] += a // 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x + 1 ] [ y ] += a // 2 <NEWLINE> dp [ x ] [ y + 1 ] += a // 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a % 2 : <NEWLINE> <INDENT> dp [ x + 1 ] [ y ] += a // 2 + 1 <NEWLINE> dp [ x ] [ y + 1 ] += a // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x + 1 ] [ y ] += a // 2 <NEWLINE> dp [ x ] [ y + 1 ] += a // 2 <NEWLINE> <DEDENT> <DEDENT> sss [ x ] [ y ] = ( sss [ x ] [ y ] + dp [ x ] [ y ] ) % 2 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> x = y = 0 <NEWLINE> while x < h and y < w : <NEWLINE> <INDENT> if sss [ x ] [ y ] : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> print ( x + 1 , y + 1 ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( n ) <NEWLINE> for e in input ( ) . split ( ) : <NEWLINE> <INDENT> a [ int ( e ) - 1 ] += 1 <NEWLINE> <DEDENT> [ print ( i ) for i in a ] <NEWLINE>
S = list ( set ( input ( ) ) ) <NEWLINE> S . sort ( ) <NEWLINE> import string <NEWLINE> switch = True <NEWLINE> A = list ( string . ascii_lowercase ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if not i in S : <NEWLINE> <INDENT> print ( i ) <NEWLINE> switch = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if switch : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT>
def time ( s ) : <NEWLINE> <INDENT> h = s // 3600 <NEWLINE> s = s - h * 3600 <NEWLINE> <NL> m = s // 60 <NEWLINE> s = s - m * 60 <NEWLINE> return str ( h ) , str ( m ) , str ( s ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> h , m , s = time ( t ) <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
from itertools import accumulate <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> ac = list ( accumulate ( a ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * ( ac [ - 1 ] - ac [ i ] ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = [ i for i in range ( N ) ] <NEWLINE> <NL> def find ( x , P ) : <NEWLINE> <INDENT> if P [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = find ( P [ x ] , P ) <NEWLINE> P [ x ] = b <NEWLINE> return b <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y , P ) : <NEWLINE> <INDENT> root_x = find ( x , P ) <NEWLINE> root_y = find ( y , P ) <NEWLINE> if root_y > root_x : <NEWLINE> <INDENT> P [ root_x ] = root_y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P [ root_y ] = root_x <NEWLINE> <NL> <DEDENT> <DEDENT> par2 = [ i for i in range ( N ) ] <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( p - 1 , q - 1 , par ) <NEWLINE> <NL> <DEDENT> for _ in range ( L ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( p - 1 , q - 1 , par2 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> r = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r . append ( ( find ( i , par ) , find ( i , par2 ) ) ) <NEWLINE> <NL> <DEDENT> import collections <NEWLINE> count = collections . Counter ( r ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = count [ r [ i ] ] <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A += a <NEWLINE> <NL> <DEDENT> print ( N - len ( set ( A ) ) ) <NEWLINE>
import collections <NEWLINE> S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> T , d = 0 , 1 <NEWLINE> A = [ 0 ] * 2019 <NEWLINE> A [ 0 ] = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> T += int ( S [ l - i - 1 ] ) * d <NEWLINE> d *= 10 <NEWLINE> T %= 2019 <NEWLINE> d %= 2019 <NEWLINE> A [ T ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for cnt in A : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> dic = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd , word = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> if word in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dic . add ( word ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . join ( [ <STRING> . join ( [ <STRING> for w in range ( W ) ] ) for h in range ( H ) ] ) + <STRING> ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> up = x <NEWLINE> down = x <NEWLINE> ans = 0 <NEWLINE> <NL> while ans == 0 : <NEWLINE> <INDENT> if p . count ( down ) == 0 : <NEWLINE> <INDENT> ans = down <NEWLINE> break <NEWLINE> <DEDENT> elif p . count ( up ) == 0 : <NEWLINE> <INDENT> ans = up <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> up += 1 <NEWLINE> down -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> List . append ( S ) <NEWLINE> <DEDENT> print ( len ( set ( List ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums . sort ( ) <NEWLINE> cnt = nums [ N // 2 ] - nums [ N // 2 - 1 ] <NEWLINE> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> mod = 998244353 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( [ l , r ] ) <NEWLINE> <NL> <DEDENT> dp = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dpsum = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for l , r in s : <NEWLINE> <INDENT> li = max ( i - r , 1 ) <NEWLINE> ri = max ( i - l , 0 ) <NEWLINE> dp [ i ] += ( dpsum [ ri ] - dpsum [ li - 1 ] ) % mod <NEWLINE> <DEDENT> dpsum [ i ] = ( dpsum [ i - 1 ] + dp [ i ] ) % mod <NEWLINE> <NL> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> datasets = [ 0 ] * n <NEWLINE> <COMMENT> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> datasets [ i ] = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for data in datasets : <NEWLINE> <INDENT> x1p2 = ( data [ 0 ] + data [ 2 ] ) <NEWLINE> x1m2 = ( data [ 0 ] - data [ 2 ] ) <NEWLINE> x1p3 = ( data [ 0 ] + data [ 4 ] ) <NEWLINE> x1m3 = ( data [ 0 ] - data [ 4 ] ) <NEWLINE> y1p2 = ( data [ 1 ] + data [ 3 ] ) <NEWLINE> y1m2 = ( data [ 1 ] - data [ 3 ] ) <NEWLINE> y1p3 = ( data [ 1 ] + data [ 5 ] ) <NEWLINE> y1m3 = ( data [ 1 ] - data [ 5 ] ) <NEWLINE> x = ( x1p2 * x1m2 * y1m3 + y1p2 * y1m2 * y1m3 - x1p3 * x1m3 * y1m2 - y1p3 * y1m3 * y1m2 ) / ( 2 * ( x1m2 * y1m3 - x1m3 * y1m2 ) ) <NEWLINE> y = ( y1p2 * y1m2 * x1m3 + x1p2 * x1m2 * x1m3 - y1p3 * y1m3 * x1m2 - x1p3 * x1m3 * x1m2 ) / ( 2 * ( y1m2 * x1m3 - y1m3 * x1m2 ) ) <NEWLINE> r = ( ( x - data [ 0 ] ) ** 2 + ( y - data [ 1 ] ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> if x == 0.000 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> if y == 0.000 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> print ( <STRING> . format ( x , y , r ) ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_box = [ 0 ] * n <NEWLINE> wa = [ 0 ] * n <NEWLINE> ac = 0 <NEWLINE> wa_cnt = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> k , l = input ( ) . split ( ) <NEWLINE> h = int ( k ) - 1 <NEWLINE> if ans_box [ h ] == 0 : <NEWLINE> <INDENT> if l == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> ans_box [ h ] += 1 <NEWLINE> wa_cnt += wa [ h ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa [ h ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa_cnt ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> b = 10 ** 18 <NEWLINE> ret = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ret = ret * i <NEWLINE> if ret > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ret ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> all_case = r * g * b <NEWLINE> <NL> excluded_case = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : continue <NEWLINE> k = j * 2 - i <NEWLINE> if k >= N or S [ k ] == S [ i ] or S [ k ] == S [ j ] : continue <NEWLINE> excluded_case += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( all_case - excluded_case ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = defaultdict ( int ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> line = input ( ) <NEWLINE> N = line . split ( <STRING> ) [ 0 ] <NEWLINE> D = line . split ( <STRING> ) [ 1 ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> inputs = input ( ) <NEWLINE> X = int ( inputs . split ( <STRING> ) [ 0 ] ) <NEWLINE> Y = int ( inputs . split ( <STRING> ) [ 1 ] ) <NEWLINE> if ( math . sqrt ( pow ( X , 2 ) + pow ( Y , 2 ) ) <= int ( D ) ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> cs = np . cumsum ( np . array ( a ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s = ( cs [ - 1 ] - cs [ i ] ) % mod <NEWLINE> ans = ( ans + ( a [ i ] * int ( s ) ) % mod ) % mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> a = main ( ) <NEWLINE> print ( a ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> table = { <NEWLINE> <INDENT> 1 : 2 , <NEWLINE> 2 : 5 , <NEWLINE> 3 : 5 , <NEWLINE> 4 : 4 , <NEWLINE> 5 : 5 , <NEWLINE> 6 : 6 , <NEWLINE> 7 : 3 , <NEWLINE> 8 : 7 , <NEWLINE> 9 : 6 , <NEWLINE> <DEDENT> } <NEWLINE> dp = [ - 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> mx = - 1 <NEWLINE> for j in a : <NEWLINE> <INDENT> if not 0 <= i - table [ j ] < n + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if dp [ i - table [ j ] ] < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if mx < dp [ i - table [ j ] ] * 10 + j : <NEWLINE> <INDENT> mx = dp [ i - table [ j ] ] * 10 + j <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = mx <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ s for s in input ( ) ] <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if N - 1 < k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ k ] != S [ i ] and S [ k ] != S [ j ] and S [ i ] != S [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> N = I ( ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = make_divisors ( N ) <NEWLINE> lenc = len ( c ) <NEWLINE> if ( lenc % 2 ) == 0 : <NEWLINE> <INDENT> a = c [ lenc // 2 - 1 ] <NEWLINE> b = c [ lenc // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = c [ lenc // 2 ] <NEWLINE> b = a <NEWLINE> <NL> <DEDENT> print ( a + b - 2 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
from collections import deque <NEWLINE> <NL> def scan ( que , ps , way ) : <NEWLINE> <INDENT> Li = 0 <NEWLINE> pp = ps <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> if way == 0 : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = que . pop ( ) <NEWLINE> <DEDENT> if p < ps : <NEWLINE> <INDENT> Li += ps - p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pp = p <NEWLINE> <DEDENT> return Li <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> D = input ( ) <NEWLINE> que = deque ( ) <NEWLINE> p = 0 <NEWLINE> for c in D : <NEWLINE> <INDENT> que . append ( p ) <NEWLINE> if c == <STRING> : p += - 1 <NEWLINE> elif c == <STRING> : p += 1 <NEWLINE> <DEDENT> que . append ( p ) <NEWLINE> <NL> Ll = [ ] <NEWLINE> Lr = [ ] <NEWLINE> ls = que . popleft ( ) <NEWLINE> if len ( que ) > 0 : rs = que . pop ( ) <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> while len ( que ) > 0 : <NEWLINE> <INDENT> if que [ 0 ] < ls : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls = que . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> while len ( que ) > 0 : <NEWLINE> <INDENT> if que [ - 1 ] < rs : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rs = que . pop ( ) <NEWLINE> <DEDENT> <DEDENT> if len ( que ) > 0 : <NEWLINE> <INDENT> if ls < rs : Ll . append ( scan ( que , ls , 0 ) ) <NEWLINE> else : Lr . insert ( 0 , scan ( que , rs , 1 ) ) <NEWLINE> <DEDENT> <DEDENT> L = Ll + Lr <NEWLINE> if len ( L ) > 0 : <NEWLINE> <INDENT> print ( sum ( L ) ) <NEWLINE> print ( len ( L ) , * L ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> import numpy as np <NEWLINE> C = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> c , * a = map ( int , input ( ) . split ( ) ) <NEWLINE> li . append ( np . array ( a ) ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> counter = [ ] <NEWLINE> <NL> for i in range ( 1 << N ) : <NEWLINE> <INDENT> skill_li = np . zeros ( M ) . astype ( int ) <NEWLINE> sum_price = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if ( i >> k ) & 1 : <NEWLINE> <INDENT> skill_li += li [ k ] <NEWLINE> sum_price += C [ k ] <NEWLINE> <DEDENT> <DEDENT> if all ( skill_li >= X ) : <NEWLINE> <INDENT> counter . append ( sum_price ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( counter ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( counter ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> <NL> S = [ A [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] <= S [ 0 ] : <NEWLINE> <INDENT> S . insert ( 0 , A [ i ] ) <NEWLINE> continue <NEWLINE> <DEDENT> ok = 0 <NEWLINE> ng = len ( S ) <NEWLINE> tmp = ( ok + ng ) <NEWLINE> while ok + 1 < ng : <NEWLINE> <INDENT> tmp = ( ok + ng ) // 2 <NEWLINE> if A [ i ] > S [ tmp ] : <NEWLINE> <INDENT> ok = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = tmp <NEWLINE> <DEDENT> <DEDENT> S [ ok ] = A [ i ] <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k >= a and b > k - a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = k - ( a + b ) <NEWLINE> print ( a - d ) <NEWLINE> <DEDENT>
def primes ( n ) : <NEWLINE> <INDENT> l = [ 1 for i in range ( n + 1 ) ] <NEWLINE> l [ 0 ] = l [ 1 ] = 0 <NEWLINE> for i in range ( 2 , int ( ( n ) ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 , n // i + 1 ) : <NEWLINE> <INDENT> l [ i * j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> l = primes ( 50000 ) <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> if not ( n % 2 ) : <NEWLINE> <INDENT> for i in range ( 3 , n // 2 + 1 , 2 ) : <NEWLINE> <INDENT> if ( l [ i ] and l [ n - i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if n == 4 : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if l [ n - 2 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> nums = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= nums [ i ] <NEWLINE> <NL> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_r = list ( input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in A_r ] <NEWLINE> B = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i + 1 ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i + 1 ) <NEWLINE> d [ i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> bl = len ( B ) <NEWLINE> sb = set ( B ) <NEWLINE> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> for b in [ 2 * r - g , 2 * g - r , g + ( r - g ) / 2 ] : <NEWLINE> <INDENT> res -= d [ b ] <NEWLINE> <DEDENT> res += bl <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> import re <NEWLINE> <NL> def solve ( exp ) : <NEWLINE> <INDENT> p1 = re . compile ( <STRING> ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> modified_exp = exp . replace ( <STRING> , str ( i ) ) <NEWLINE> left , right = modified_exp . split ( <STRING> ) <NEWLINE> left1 , left2 = left . split ( <STRING> ) <NEWLINE> <NL> left1 = p1 . sub ( <STRING> , left1 ) <NEWLINE> if left1 == <STRING> : <NEWLINE> <INDENT> left1 = <STRING> <NEWLINE> <DEDENT> left2 = p1 . sub ( <STRING> , left2 ) <NEWLINE> if left2 == <STRING> : <NEWLINE> <INDENT> left2 = <STRING> <NEWLINE> <DEDENT> right = p1 . sub ( <STRING> , right ) <NEWLINE> if right == <STRING> : <NEWLINE> <INDENT> right = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if int ( left1 ) + int ( left2 ) == int ( right ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <NL> <DEDENT> def solve2 ( exp ) : <NEWLINE> <INDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> left , right = exp . split ( <STRING> ) <NEWLINE> left1 , left2 = left . split ( <STRING> ) <NEWLINE> <NL> left1 = left1 . replace ( <STRING> , str ( i ) ) <NEWLINE> left2 = left2 . replace ( <STRING> , str ( i ) ) <NEWLINE> right = right . replace ( <STRING> , str ( i ) ) <NEWLINE> if len ( left1 ) > 1 and left1 [ 0 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if len ( left2 ) > 1 and left2 [ 0 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if len ( right ) > 1 and right [ 0 ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if int ( left1 , base = 10 ) + int ( left2 , base = 10 ) == int ( right , base = 10 ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> result = solve2 ( line . strip ( ) ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> def DFS ( h , w , black , white , m ) : <NEWLINE> <INDENT> black , white = BorW ( h , w , black , white ) <NEWLINE> step = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] <NEWLINE> seen [ h ] [ w ] = 1 <NEWLINE> for dh , dw in step : <NEWLINE> <INDENT> nh = h + dh <NEWLINE> nw = w + dw <NEWLINE> if 0 <= nh < H and 0 <= nw < W : <NEWLINE> <INDENT> if seen [ nh ] [ nw ] == 0 and m != S [ nh ] [ nw ] : <NEWLINE> <INDENT> seen [ nh ] [ nw ] = 1 <NEWLINE> black , white = DFS ( nh , nw , black , white , S [ nh ] [ nw ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return black , white <NEWLINE> <NL> <NL> <DEDENT> def BorW ( h , w , black , white ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white += 1 <NEWLINE> <DEDENT> return black , white <NEWLINE> <NL> <NL> <DEDENT> seen = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> L = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> white = 0 <NEWLINE> if seen [ h ] [ w ] == 0 : <NEWLINE> <INDENT> black , white = DFS ( h , w , black , white , S [ h ] [ w ] ) <NEWLINE> L . append ( [ black , white ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for b , w in L : <NEWLINE> <INDENT> ans += b * w <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <NL> <INDENT> n = int ( s ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> P = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> P . append ( complex ( x , y ) ) <NEWLINE> <NL> <DEDENT> def get_intersections ( p0 , p1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dist = abs ( p0 - p1 ) <NEWLINE> <NL> if dist > 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> elif dist == 2 : <NEWLINE> <INDENT> return [ ( p0 + p1 ) / 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = ( p0 + p1 ) / 2 <NEWLINE> v = m - p0 <NEWLINE> w = complex ( v . imag , - v . real ) <NEWLINE> n = w / abs ( w ) <NEWLINE> d = abs ( v ) <NEWLINE> l = math . sqrt ( 1 - d ** 2 ) <NEWLINE> <NL> inter0 = m + l * n <NEWLINE> inter1 = m - l * n <NEWLINE> return [ inter0 , inter1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> intersections = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> intersections += get_intersections ( P [ i ] , P [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> counts = [ ] <NEWLINE> <NL> <COMMENT> <NL> for intersection in intersections : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> if abs ( intersection - p ) <= 1.01 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> counts . append ( cnt ) <NEWLINE> <NL> <DEDENT> if counts : <NEWLINE> <INDENT> print ( max ( counts ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> k = [ ] <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> y = i <NEWLINE> if i % 3 == 0 : <NEWLINE> <INDENT> k . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if y % 10 == 3 : <NEWLINE> <INDENT> k . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y <= 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y //= 10 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( [ str ( x ) for x in k ] ) ) <NEWLINE>
import collections <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = collections . Counter ( A ) <NEWLINE> A = sorted ( A . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> cnt = A [ : len ( A ) - K ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for c in cnt : <NEWLINE> <INDENT> ans . append ( c [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
<NL> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> d = 0 <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> c *= b [ i ] <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def digitSum ( n ) : <NEWLINE> <INDENT> s = str ( n ) <NEWLINE> array = list ( map ( int , s ) ) <NEWLINE> return sum ( array ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> sum = digitSum ( N ) <NEWLINE> <NL> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> num = A [ i - 1 ] - 1 <NEWLINE> sum [ num ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( sum [ i ] ) <NEWLINE> <DEDENT>
def Judge ( x , y ) : <NEWLINE> <INDENT> sum = 1 <NEWLINE> for i in range ( y ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> for i in range ( y ) : <NEWLINE> <INDENT> sum *= x [ i ] <NEWLINE> <COMMENT> <NL> if sum > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Judge ( a , n ) <NEWLINE> print ( c ) <NEWLINE>
import collections <NEWLINE> <NL> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> b = collections . Counter ( s ) <NEWLINE> c = sorted ( b . items ( ) ) <NEWLINE> con = [ ] <NEWLINE> n = 0 <NEWLINE> while True : <NEWLINE> <INDENT> con . append ( c [ n ] [ 0 ] ) <NEWLINE> if len ( con ) == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> check = c [ n ] [ 0 ] + c [ i ] [ 0 ] <NEWLINE> if check in s : <NEWLINE> <INDENT> con . append ( check ) <NEWLINE> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i_2 in range ( len ( c ) ) : <NEWLINE> <INDENT> check_2 = check + c [ i_2 ] [ 0 ] <NEWLINE> if check_2 in s : <NEWLINE> <INDENT> con . append ( check_2 ) <NEWLINE> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i_3 in range ( len ( c ) ) : <NEWLINE> <INDENT> check_3 = check_2 + c [ i_3 ] [ 0 ] <NEWLINE> if check_3 in s : <NEWLINE> <INDENT> con . append ( check_3 ) <NEWLINE> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i_4 in range ( len ( c ) ) : <NEWLINE> <INDENT> check_4 = check_3 + c [ i_4 ] [ 0 ] <NEWLINE> if check_4 in s : <NEWLINE> <INDENT> con . append ( check_4 ) <NEWLINE> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> print ( con [ k - 1 ] ) <NEWLINE>
if int ( input ( ) ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if S [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = S [ 0 ] <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == 0 : <NEWLINE> <INDENT> X = 0 <NEWLINE> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X > 10 ** 18 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = X * S [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if 0 < X <= 10 ** 18 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> num [ a - 1 ] . append ( b ) <NEWLINE> num [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <DEDENT> queue = deque ( ) <NEWLINE> queue . append ( 0 ) <NEWLINE> seen = [ False ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if len ( queue ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num1 = queue . popleft ( ) <NEWLINE> seen [ num1 ] = True <NEWLINE> num2 = num [ num1 ] <NEWLINE> for j in range ( len ( num2 ) ) : <NEWLINE> <INDENT> if seen [ num2 [ j ] - 1 ] == False : <NEWLINE> <INDENT> ans [ num2 [ j ] - 1 ] += ans [ num1 ] <NEWLINE> queue . append ( num2 [ j ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( x , - 1 , - 1 ) : <NEWLINE> <INDENT> if not i in p : <NEWLINE> <INDENT> a1 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( x , 100 + 2 ) : <NEWLINE> <INDENT> if not i in p : <NEWLINE> <INDENT> a2 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if x - a1 <= a2 - x : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a2 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> num = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> num += i <NEWLINE> <DEDENT> if A [ M - 1 ] >= num / ( 4 * M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> G [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> SD = [ 0 ] * N <NEWLINE> seen = [ 0 ] * N <NEWLINE> stack = [ ] <NEWLINE> stack . append ( [ K - 1 , 0 ] ) <NEWLINE> seen [ K - 1 ] = 1 <NEWLINE> while stack : <NEWLINE> <INDENT> x , d = stack . pop ( ) <NEWLINE> for y , d0 in G [ x ] : <NEWLINE> <INDENT> if seen [ y ] == 0 : <NEWLINE> <INDENT> SD [ y ] = d + d0 <NEWLINE> stack . append ( [ y , d + d0 ] ) <NEWLINE> seen [ y ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = SD [ x - 1 ] + SD [ y - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> k9 = k * 9 <NEWLINE> l = 10 <NEWLINE> for n in range ( 1 , k + 5 ) : <NEWLINE> <INDENT> if l * 7 % k9 == 7 % k9 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> l = l * 10 % k9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
p = 10 ** 18 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > p : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> ans = 0 <NEWLINE> c = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> c = math . gcd ( i , j ) <NEWLINE> for m in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( c , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> kl = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * ( n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( a [ i ] - a [ j ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> status = 0 <NEWLINE> prev = a [ 0 ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> diff = i - prev <NEWLINE> <NL> if diff == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif diff > 0 : <NEWLINE> <INDENT> if status >= 0 : <NEWLINE> <INDENT> status = diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> status = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if status <= 0 : <NEWLINE> <INDENT> status = diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> status = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> prev = i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
mod = 1000000000 + 7 <NEWLINE> <NL> def product ( N , As ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> summer = sum ( As ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> left = As [ i ] <NEWLINE> summer = summer - left <NEWLINE> result += left * summer <NEWLINE> <NL> <DEDENT> return result % mod <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( product ( N [ 0 ] , As ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> count = [ 0 ] * ( ( 10 ** 5 ) + 100 ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> count [ A [ i ] ] += 1 <NEWLINE> <DEDENT> sumA = sum ( A ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> count [ BC [ q ] [ 1 ] ] += count [ BC [ q ] [ 0 ] ] <NEWLINE> sumA += ( BC [ q ] [ 1 ] - BC [ q ] [ 0 ] ) * count [ BC [ q ] [ 0 ] ] <NEWLINE> print ( sumA ) <NEWLINE> count [ BC [ q ] [ 0 ] ] = 0 <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> test = A [ 0 ] <NEWLINE> l = 0 <NEWLINE> <NL> while test % 2 == 0 : <NEWLINE> <INDENT> test = test // 2 <NEWLINE> c *= 2 <NEWLINE> <NL> <DEDENT> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> for i in np . arange ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] % c != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> l = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ i + 1 ] % ( c * 2 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> l = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = A [ i + 1 ] // c <NEWLINE> test = lcm_base ( test , k ) <NEWLINE> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> k = test * c // 2 <NEWLINE> print ( M // k // 2 + M // k % 2 ) <NEWLINE> <DEDENT>
<NL> <NL> K , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B . append ( abs ( A [ i + 1 ] - A [ i ] ) ) <NEWLINE> <DEDENT> B . append ( K + A [ 0 ] - A [ - 1 ] ) <NEWLINE> <COMMENT> <NL> print ( K - max ( B ) ) <NEWLINE>
K = int ( input ( ) ) <COMMENT> <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k and k == i : <NEWLINE> <COMMENT> <NL> <INDENT> A . append ( gcd_list ( [ i , j , k ] ) ) <NEWLINE> <DEDENT> elif i != j and j != k and k != i : <NEWLINE> <INDENT> A . append ( gcd_list ( [ i , j , k ] ) * 6 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> A . append ( gcd_list ( [ i , j , k ] ) * 3 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> m = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> m = min ( m , P [ i ] ) <NEWLINE> if m == P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from itertools import accumulate <NEWLINE> n , c , * stc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> table = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> m = list ( zip ( stc [ : : 3 ] , stc [ 1 : : 3 ] , stc [ 2 : : 3 ] ) ) <NEWLINE> m . sort ( key = lambda a : ( a [ 2 ] , a [ 0 ] , a [ 1 ] ) ) <NEWLINE> <NL> ch_ = 0 <NEWLINE> t_ = 0 <NEWLINE> for s , t , ch in m : <NEWLINE> <INDENT> if ch != ch_ : <NEWLINE> <INDENT> ch_ = ch <NEWLINE> t_ = 0 <NEWLINE> <DEDENT> if t_ == s : <NEWLINE> <INDENT> table [ t_ + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ s ] += 1 <NEWLINE> <NL> <DEDENT> table [ t + 1 ] -= 1 <NEWLINE> t_ = t <NEWLINE> <NL> <DEDENT> * x , = accumulate ( table ) <NEWLINE> ans = max ( x ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> edge = [ [ int ( s ) - 1 for s in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for i , j in edge : <NEWLINE> <INDENT> graph [ i ] . append ( j ) <NEWLINE> graph [ j ] . append ( i ) <NEWLINE> <NL> <DEDENT> dq = deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * N <NEWLINE> visited [ 0 ] = True <NEWLINE> parent = [ 0 ] * N <NEWLINE> while ( dq ) : <NEWLINE> <INDENT> search_obj = dq . pop ( ) <NEWLINE> for candidate_obj in graph [ search_obj ] : <NEWLINE> <INDENT> if not visited [ candidate_obj ] : <NEWLINE> <INDENT> dq . appendleft ( candidate_obj ) <NEWLINE> parent [ candidate_obj ] = search_obj <NEWLINE> visited [ candidate_obj ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> total_visited = sum ( visited ) <NEWLINE> if total_visited < N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( parent [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bh = [ ] <NEWLINE> bw = [ ] <NEWLINE> l_num = [ 0 ] * h <NEWLINE> c_num = [ 0 ] * w <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> i1 , i2 = map ( int , input ( ) . split ( ) ) <NEWLINE> bh . append ( i1 ) <NEWLINE> bw . append ( i2 ) <NEWLINE> l_num [ i1 - 1 ] = l_num [ i1 - 1 ] + 1 <NEWLINE> c_num [ i2 - 1 ] = c_num [ i2 - 1 ] + 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> max_l_num = max ( l_num ) <NEWLINE> max_c_num = max ( c_num ) <NEWLINE> l_candi = [ i for i , v in enumerate ( l_num ) if v == max_l_num ] <NEWLINE> c_candi = [ i for i , v in enumerate ( c_num ) if v == max_c_num ] <NEWLINE> <NL> <COMMENT> <NL> <NL> t = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> if l_num [ bh [ k ] - 1 ] == max_l_num and c_num [ bw [ k ] - 1 ] == max_c_num : <NEWLINE> <INDENT> t = t + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if t < len ( l_candi ) * len ( c_candi ) : <NEWLINE> <INDENT> print ( max_l_num + max_c_num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_l_num + max_c_num - 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> current = 1 <NEWLINE> path = [ 1 ] <NEWLINE> already = [ False ] * len ( A ) <NEWLINE> <NL> while K > 0 : <NEWLINE> <INDENT> if already [ current - 1 ] : <NEWLINE> <INDENT> loop = path [ path . index ( A [ current - 1 ] ) : ] <NEWLINE> current = loop [ ( K - 1 ) % len ( loop ) ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> path += [ A [ current - 1 ] ] <NEWLINE> already [ current - 1 ] = True <NEWLINE> current = A [ current - 1 ] <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> print ( current ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> mask = 1 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> one_cnt = np . sum ( A >> i & 1 ) <NEWLINE> tmp = one_cnt * ( N - one_cnt ) <NEWLINE> tmp %= MOD <NEWLINE> ans += tmp * mask <NEWLINE> ans %= MOD <NEWLINE> mask <<= 1 <NEWLINE> mask %= MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> MOD = 1_000_000_007 <NEWLINE> print ( solve ( ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> G = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> G [ A ] . append ( B ) <NEWLINE> G [ B ] . append ( A ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> sign = [ - 1 ] * ( N + 1 ) <NEWLINE> sign [ 0 ] = None <NEWLINE> sign [ 1 ] = 0 <NEWLINE> <NL> queue = deque ( [ 1 ] ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> for next in G [ node ] : <NEWLINE> <INDENT> if sign [ next ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sign [ next ] = node <NEWLINE> queue . append ( next ) <NEWLINE> <NL> <DEDENT> <DEDENT> if - 1 in sign : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( sign [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif A [ - 1 ] * A [ - 2 ] > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <DEDENT> for k in d : <NEWLINE> <INDENT> ans *= k ** d [ k ] <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> bs = 10 ** 9 + 7 <NEWLINE> s = sum ( a ) <NEWLINE> sm = 0 <NEWLINE> <NL> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> s -= ai <NEWLINE> sm += ( ai * s ) % bs <NEWLINE> sm = sm % bs <NEWLINE> <NL> <DEDENT> print ( sm ) <NEWLINE>
import collections <NEWLINE> import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> suma = sum ( a ) <NEWLINE> numcount = [ 0 ] * ( ( 10 ** 5 ) + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numcount [ a [ i ] ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if numcount [ b ] != 0 : <NEWLINE> <INDENT> tmpb = numcount [ b ] <NEWLINE> numcount [ c ] += numcount [ b ] <NEWLINE> numcount [ b ] = 0 <NEWLINE> suma += tmpb * ( c - b ) <NEWLINE> <DEDENT> print ( suma ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = min ( A , K ) <NEWLINE> b = min ( B , K - a ) <NEWLINE> c = min ( C , K - a - b ) <NEWLINE> print ( a - c ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxa = a [ - 1 ] <NEWLINE> tf = [ True ] * maxa <NEWLINE> r = 0 <NEWLINE> n -= 1 <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> a_i = a [ i ] <NEWLINE> if tf [ a_i - 1 ] == True : <COMMENT> <NEWLINE> <INDENT> for j in range ( a_i - 1 , maxa , a_i ) : <NEWLINE> <INDENT> tf [ j ] = False <NEWLINE> <DEDENT> if a_i < a [ i + 1 ] : <COMMENT> <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if tf [ - 1 ] == True : <COMMENT> <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> N_root = math . sqrt ( N ) <NEWLINE> M = int ( N_root ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> list . append ( i + N // i - 2 ) <NEWLINE> <DEDENT> <DEDENT> list = sorted ( list ) <NEWLINE> print ( list [ 0 ] ) <NEWLINE>
from statistics import median <NEWLINE> from operator import itemgetter <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_ = sorted ( x ) <NEWLINE> m0 = median ( x_ [ 1 : ] ) <NEWLINE> m1 = median ( x_ [ : - 1 ] ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if m1 >= i : <NEWLINE> <INDENT> print ( m0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = [ P [ 0 ] ] + [ 10 ** 10 ] * ( N - 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> T [ i ] = min ( T [ i - 1 ] , P [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] <= T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from heapq import heappush , heappop <NEWLINE> <NL> A = [ ] <NEWLINE> inp = [ None ] <NEWLINE> while inp [ 0 ] != <STRING> : <NEWLINE> <INDENT> inp = input ( ) . split ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> heappush ( A , - int ( inp [ 1 ] ) ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( - heappop ( A ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> lis . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> mon = 0 <NEWLINE> i = 0 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> while cnt < m : <NEWLINE> <INDENT> if lis [ i ] [ 1 ] + cnt < m : <NEWLINE> <INDENT> cnt += lis [ i ] [ 1 ] <NEWLINE> mon += lis [ i ] [ 0 ] * lis [ i ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( mon + ( m - cnt ) * lis [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m * lis [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> line = input ( ) . split ( ) <NEWLINE> <NL> if <STRING> in line : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 1 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> x = x * int ( line [ i ] ) <NEWLINE> <NL> if x > 10 ** 18 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = n * ( n - 1 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( reduce ( math . gcd , A ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i - K ] < A [ i ] else <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> TD = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> TD . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> TD . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> TD += [ ( TD [ - 1 ] [ 0 ] , 0 ) ] <NEWLINE> <NL> D = defaultdict ( list ) <NEWLINE> T = [ 0 ] * N <NEWLINE> H = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> t , d = TD [ i ] <NEWLINE> T [ t - 1 ] += 1 <NEWLINE> D [ t ] . append ( d ) <NEWLINE> ans += d <NEWLINE> <NL> <DEDENT> cnt = sum ( 1 for c in T if c >= 1 ) <NEWLINE> ans += cnt ** 2 <NEWLINE> <NL> for t in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if T [ t - 1 ] >= 2 : <NEWLINE> <INDENT> heappush ( H , ( D [ t ] . pop ( ) , t ) ) <NEWLINE> T [ t - 1 ] -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if H : <NEWLINE> <INDENT> t1 , d1 = TD [ i ] <NEWLINE> d2 , t2 = heappop ( H ) <NEWLINE> <COMMENT> <NL> if T [ t1 - 1 ] == 0 and d1 - d2 + 2 * cnt + 1 >= 0 : <NEWLINE> <INDENT> ans += d1 - d2 + 2 * cnt + 1 <NEWLINE> cnt += 1 <NEWLINE> T [ t1 - 1 ] += 1 <NEWLINE> if T [ t2 - 1 ] >= 2 : <NEWLINE> <INDENT> T [ t2 - 1 ] -= 1 <NEWLINE> <DEDENT> if T [ t2 - 1 ] >= 2 : <NEWLINE> <INDENT> heappush ( H , ( D [ t2 ] . pop ( ) , t2 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> heappush ( H , ( d2 , t2 ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans2 = 0 <NEWLINE> T2 = [ 0 ] * N <NEWLINE> D2 = [ ] <NEWLINE> cnt2 = 0 <NEWLINE> <NL> for t , d in TD : <NEWLINE> <INDENT> if cnt2 < K : <NEWLINE> <INDENT> if T2 [ t - 1 ] : <NEWLINE> <INDENT> D2 . append ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T2 [ t - 1 ] = 1 <NEWLINE> ans2 += d <NEWLINE> cnt2 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans2 += sum ( D2 [ : K - cnt2 ] ) + sum ( T2 ) ** 2 <NEWLINE> <NL> print ( max ( ans , ans2 ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def argmax_poss ( a ) : <NEWLINE> <INDENT> if len ( a ) == 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> all_ = [ 0 ] <NEWLINE> max_ = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] > max_ : <NEWLINE> <INDENT> all_ = [ i ] <NEWLINE> max_ = a [ i ] <NEWLINE> <DEDENT> elif a [ i ] == max_ : <NEWLINE> <INDENT> all_ . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return all_ <NEWLINE> <NL> <DEDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> Ms = [ ] <NEWLINE> <NL> h_scores = [ 0 for i in range ( h ) ] <NEWLINE> w_scores = [ 0 for i in range ( w ) ] <NEWLINE> <NL> record = set ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> record . add ( ( h - 1 , w - 1 ) ) <NEWLINE> h_scores [ h - 1 ] += 1 <NEWLINE> w_scores [ w - 1 ] += 1 <NEWLINE> <NL> <DEDENT> max_h_poss = argmax_poss ( h_scores ) <NEWLINE> max_w_poss = argmax_poss ( w_scores ) <NEWLINE> <NL> out_pos_count = 0 <NEWLINE> <NL> is_ok = False <NEWLINE> <NL> for h in max_h_poss : <NEWLINE> <INDENT> for w in max_w_poss : <NEWLINE> <INDENT> if ( h , w ) not in record : <NEWLINE> <INDENT> is_ok = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if is_ok : <NEWLINE> <INDENT> print ( max ( h_scores ) + max ( w_scores ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( h_scores ) + max ( w_scores ) - 1 ) <NEWLINE> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> B . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> B = list ( reversed ( B ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> num = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( B [ i ] [ 0 ] ) : <NEWLINE> <INDENT> if num > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ num ] < B [ i ] [ 1 ] : <NEWLINE> <INDENT> A [ num ] = B [ i ] [ 1 ] <NEWLINE> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * ( N + 1 ) <NEWLINE> b = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + A [ i - 1 ] <NEWLINE> <DEDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> b [ j ] = b [ j - 1 ] + B [ j - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if K - a [ i ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> j = bisect . bisect_right ( b , K - a [ i ] ) - 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> l , r = 0 , len ( s ) - 1 <NEWLINE> ans = 0 <NEWLINE> while l < r : <NEWLINE> <INDENT> if s [ l ] == s [ r ] : <NEWLINE> <INDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> imput = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if A < B : <NEWLINE> <INDENT> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( V - W ) * T >= B - A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif A > B : <NEWLINE> <INDENT> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( V - W ) * T >= A - B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class DisjoinSet : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . rank = [ 0 for _ in range ( size ) ] <NEWLINE> self . p = [ 0 for _ in range ( size ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> self . makeSet ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def makeSet ( self , x ) : <NEWLINE> <INDENT> self . p [ x ] = x <NEWLINE> self . rank [ x ] = 0 <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> print ( int ( self . findSet ( x ) == self . findSet ( y ) ) ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> self . link ( self . findSet ( x ) , self . findSet ( y ) ) <NEWLINE> <NL> <DEDENT> def link ( self , x , y ) : <NEWLINE> <INDENT> if self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> self . p [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ x ] = y <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def findSet ( self , x ) : <NEWLINE> <INDENT> if x != self . p [ x ] : <NEWLINE> <INDENT> self . p [ x ] = self . findSet ( self . p [ x ] ) <NEWLINE> <DEDENT> return self . p [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> D = DisjoinSet ( n ) <NEWLINE> cmd = { 0 : lambda x , y : D . unite ( x , y ) , 1 : lambda x , y : D . same ( x , y ) } <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> cmd [ c ] ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> cum_a = np . cumsum ( a [ : : - 1 ] ) <NEWLINE> cum_a = cum_a [ : : - 1 ] <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> if i == len ( a ) - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sum_aj = cum_a [ i + 1 ] <NEWLINE> ans += ( ( ai % MOD ) * ( sum_aj % MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x = x // 10 <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ARR = [ ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ARR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> BRR = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> BRR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def prepare ( n , q , arr , brr ) : <NEWLINE> <INDENT> nodePoints = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> nodeIndex = brr [ i ] [ 0 ] - 1 <NEWLINE> nodePoints [ nodeIndex ] += brr [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> nodes = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> startNode = arr [ i ] [ 0 ] - 1 <NEWLINE> endNode = arr [ i ] [ 1 ] - 1 <NEWLINE> <NL> nodes [ startNode ] . append ( endNode ) <NEWLINE> nodes [ endNode ] . append ( startNode ) <NEWLINE> <NL> <DEDENT> return nodes , nodePoints <NEWLINE> <NL> <NL> <DEDENT> nodes , nodePoints = prepare ( N , Q , ARR , BRR ) <NEWLINE> <NL> <NL> def dfs ( currentNode , nodes , parentNode = - 1 , parentPoint = 0 ) : <NEWLINE> <INDENT> nodePoints [ currentNode ] = nodePoints [ currentNode ] + parentPoint <NEWLINE> childNodes = nodes [ currentNode ] <NEWLINE> for childNode in childNodes : <NEWLINE> <INDENT> if childNode == parentNode : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( childNode , nodes , currentNode , nodePoints [ currentNode ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , nodes ) <NEWLINE> <NL> print ( <STRING> . join ( [ str ( nodePoints [ i ] ) for i in range ( N ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> Rn = S . count ( <STRING> ) <NEWLINE> Gn = S . count ( <STRING> ) <NEWLINE> Bn = S . count ( <STRING> ) <NEWLINE> <NL> res = Rn * Gn * Bn <NEWLINE> <NL> for p in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , min ( p , N - p - 1 ) + 1 ) : <NEWLINE> <INDENT> i , j , k = p - q , p , p + q <NEWLINE> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n <= b - 1 : <NEWLINE> <INDENT> print ( ( a * n ) // b - a * ( n // b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a * ( b - 1 ) ) // b - a * ( ( b - 1 ) // b ) ) <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> c = l [ 2 ] <NEWLINE> k = l [ 3 ] <NEWLINE> if ( k - a - b ) > 0 : <NEWLINE> <INDENT> print ( a - 1 * ( k - a - b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( a , k ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , min ( i + 1 , n - i ) ) : <NEWLINE> <INDENT> if ( s [ i ] != s [ i - j ] ) and ( s [ i ] != s [ i + j ] ) and ( s [ i - j ] != s [ i + j ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = 0 <NEWLINE> z = 1000 <NEWLINE> p = [ ] * z <NEWLINE> m = [ ] * z <NEWLINE> for i in range ( z ) : <NEWLINE> <INDENT> p . append ( [ ] ) <NEWLINE> m . append ( [ ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = i + 1 - a [ i ] <NEWLINE> if ( x > 0 ) : <NEWLINE> <INDENT> if ( x in p [ x % z ] ) : <NEWLINE> <INDENT> m [ x % z ] [ p [ x % z ] . index ( x ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ x % z ] . append ( [ 1 , 0 ] ) <NEWLINE> p [ x % z ] . append ( x ) <NEWLINE> <DEDENT> <DEDENT> x = i + 1 + a [ i ] <NEWLINE> if ( x in p [ x % z ] ) : <NEWLINE> <INDENT> m [ x % z ] [ p [ x % z ] . index ( x ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ x % z ] . append ( [ 0 , 1 ] ) <NEWLINE> p [ x % z ] . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( z ) : <NEWLINE> <INDENT> for j in range ( len ( m [ i ] ) ) : <NEWLINE> <INDENT> q += m [ i ] [ j ] [ 0 ] * m [ i ] [ j ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( q ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> res *= i <NEWLINE> <NL> <DEDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
S = [ int ( a ) for a in input ( ) [ : : - 1 ] ] <NEWLINE> m = 2019 <NEWLINE> N = len ( S ) <NEWLINE> s = 0 <NEWLINE> p = 1 <NEWLINE> X = [ 0 ] * 2019 <NEWLINE> X [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> for a in S : <NEWLINE> <INDENT> s = ( s + a * p ) % m <NEWLINE> ans += X [ s ] <NEWLINE> X [ s ] += 1 <NEWLINE> p = p * 10 % m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> A = a * c <NEWLINE> B = a * d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> if b >= 0 : <NEWLINE> <INDENT> C = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = a * c <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> C = a * c <NEWLINE> <DEDENT> if c <= 0 : <NEWLINE> <INDENT> if d >= 0 : <NEWLINE> <INDENT> D = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = a * c <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> D = a * c <NEWLINE> <NL> <DEDENT> E = b * c <NEWLINE> F = b * d <NEWLINE> print ( max ( [ A , B , C , D , E , F ] ) ) <NEWLINE> <NL>
k = int ( input ( ) ) <NEWLINE> l = [ 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> print ( l [ k - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> min = int ( i * ( i - 1 ) / 2 ) <COMMENT> <NEWLINE> max = int ( i * ( 2 * n - i + 1 ) / 2 ) <NEWLINE> cnt += max - min + 1 <NEWLINE> <NL> <DEDENT> print ( cnt % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> txylist = [ [ 0 , 0 , 0 ] ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> txy = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> txylist += [ txy ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> p = False <NEWLINE> t0 , x0 , y0 = txylist [ i ] <NEWLINE> t1 , x1 , y1 = txylist [ i + 1 ] <NEWLINE> t = t1 - t0 <NEWLINE> x = x1 - x0 <NEWLINE> y = y1 - y0 <NEWLINE> tt = abs ( x ) + abs ( y ) <NEWLINE> legs = t - tt <NEWLINE> if legs >= 0 and legs % 2 == 0 : <NEWLINE> <INDENT> p = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> que = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> task = [ ] <NEWLINE> sta = [ [ i ] for i in range ( 1 , M + 1 ) ] <NEWLINE> while sta : <NEWLINE> <INDENT> s = sta . pop ( ) <NEWLINE> if len ( s ) == N : task . append ( s ) <NEWLINE> else : <NEWLINE> <INDENT> for d in range ( int ( s [ - 1 ] ) , M + 1 ) : <NEWLINE> <INDENT> sta . append ( s + [ d ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for s in task : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , b , c , d in que : <NEWLINE> <INDENT> if s [ b - 1 ] - s [ a - 1 ] == c : tmp += d <NEWLINE> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> numcnt = { i : 0 for i in range ( 100001 ) } <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> numcnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> for x in range ( 1 , 100000 ) : <NEWLINE> <INDENT> subans = numcnt [ x - 1 ] + numcnt [ x ] + numcnt [ x + 1 ] <NEWLINE> <NL> ans = max ( ans , subans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if X < 0 : <NEWLINE> <INDENT> X = - X <NEWLINE> <DEDENT> step = X // D <NEWLINE> X -= D * step <NEWLINE> K -= step <NEWLINE> <NL> if K <= 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for l in ls : <NEWLINE> <INDENT> ans *= l <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a_li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = a_li [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> result = result * a_li [ i ] <NEWLINE> <NL> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> deg = 90 <NEWLINE> x = 0.0 <NEWLINE> y = 0.0 <NEWLINE> while True : <NEWLINE> <INDENT> di , ai = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if di == 0 and ai == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x += di * math . cos ( deg * math . pi / 180.0 ) <NEWLINE> y += di * math . sin ( deg * math . pi / 180.0 ) <NEWLINE> deg -= ai <NEWLINE> <NL> <DEDENT> print ( <STRING> % ( x , y ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> T = [ ] <NEWLINE> T . append ( 0 ) <NEWLINE> tmp = <STRING> <NEWLINE> d = [ 0 for _ in range ( 2019 ) ] <NEWLINE> d [ 0 ] = 1 <NEWLINE> r = 0 <NEWLINE> t = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ N - 1 - i ] <NEWLINE> r += int ( s ) * t <NEWLINE> r %= 2019 <NEWLINE> t *= 10 <NEWLINE> t %= 2019 <NEWLINE> d [ r ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> print ( sum ( i * ( i - 1 ) // 2 for i in d ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 150 , 150 ) : <NEWLINE> <INDENT> for j in range ( - 150 , 150 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if ( A [ i - K ] < A [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
mod = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> step = [ 0 ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> step [ 1 ] = 1 <NEWLINE> stepsum = [ 0 ] * ( n + 1 ) <NEWLINE> stepsum [ 1 ] = 1 <NEWLINE> l = [ 0 ] * k <NEWLINE> r = [ 0 ] * k <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> l [ i ] , r [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> li = i - r [ j ] <NEWLINE> ri = i - l [ j ] <NEWLINE> if ri <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> step [ i ] += stepsum [ ri ] - stepsum [ max ( 0 , li - 1 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> stepsum [ i ] = ( stepsum [ i - 1 ] + step [ i ] ) % mod <NEWLINE> <NL> <NL> <DEDENT> print ( step [ n ] % mod ) <NEWLINE>
from fractions import gcd <NEWLINE> while True : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a . count ( 0 ) == 6 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = a [ 0 ] % a [ 1 ] <NEWLINE> ix = 1 <NEWLINE> while x != 1 : <NEWLINE> <INDENT> x = a [ 0 ] * x % a [ 1 ] <NEWLINE> ix += 1 <NEWLINE> <DEDENT> y = a [ 2 ] % a [ 3 ] <NEWLINE> iy = 1 <NEWLINE> while y != 1 : <NEWLINE> <INDENT> y = a [ 2 ] * y % a [ 3 ] <NEWLINE> iy += 1 <NEWLINE> <DEDENT> z = a [ 4 ] % a [ 5 ] <NEWLINE> iz = 1 <NEWLINE> while z != 1 : <NEWLINE> <INDENT> z = a [ 4 ] * z % a [ 5 ] <NEWLINE> iz += 1 <NEWLINE> <DEDENT> ixy = ix * iy // gcd ( ix , iy ) <NEWLINE> print ( ixy * iz // gcd ( ixy , iz ) ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> return gcd ( b , a % b ) if b != 0 else a <NEWLINE> <NL> <DEDENT> def Main ( N ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> memo2 = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if memo2 [ i ] [ j ] == 0 : <NEWLINE> <INDENT> memo2 [ i ] [ j ] = gcd ( i , j ) <NEWLINE> <DEDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> M = memo2 [ i ] [ j ] <NEWLINE> if memo2 [ M ] [ k ] == 0 : <NEWLINE> <INDENT> memo2 [ M ] [ k ] = gcd ( M , k ) <NEWLINE> <DEDENT> ans += memo2 [ M ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( Main ( N ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> e = [ 0 for i in range ( a ) ] <NEWLINE> <NL> <NL> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> e [ b [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in e : <NEWLINE> <INDENT> print ( str ( j ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n_str = str ( n ) <NEWLINE> l = len ( n_str ) <NEWLINE> a = [ i for i in range ( 10 ) if i not in d ] <NEWLINE> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for j in a : <NEWLINE> <INDENT> if j == int ( n_str [ i ] ) : <NEWLINE> <INDENT> ans += str ( j ) <NEWLINE> break <NEWLINE> <DEDENT> elif j > int ( n_str [ i ] ) : <NEWLINE> <INDENT> ans += str ( j ) + str ( a [ 0 ] ) * ( l - i - 1 ) <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> if int ( ans ) >= n : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans = str ( a [ 1 ] ) + str ( a [ 0 ] ) * l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = str ( a [ 0 ] ) * ( l + 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = [ [ 0 ] * ( m + 1 ) for i in range ( n ) ] <NEWLINE> a = [ [ 0 ] * m for i in range ( 0 , n ) ] <NEWLINE> c = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ac [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c [ i ] = ac [ i ] [ 0 ] <NEWLINE> a [ i ] = ac [ i ] [ 1 : m + 1 ] <COMMENT> <NEWLINE> <DEDENT> cheap = [ ] <NEWLINE> kaukadouka = [ 0 for i in range ( n ) ] <NEWLINE> <NL> def kau ( i ) : <NEWLINE> <INDENT> global a , x , kaukadouka , cheap , c <NEWLINE> rikaido = [ 0 for i in range ( m ) ] <COMMENT> <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> kaukadouka [ j ] = 0 <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> kaukadouka [ i ] = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> rikaido [ k ] += kaukadouka [ j ] * a [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> value = 0 <NEWLINE> if min ( rikaido ) >= x : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> value += c [ j ] * kaukadouka [ j ] <NEWLINE> <DEDENT> cheap . append ( value ) <NEWLINE> <DEDENT> if i < n - 1 : <NEWLINE> <INDENT> kau ( i + 1 ) <NEWLINE> kawanai ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def kawanai ( i ) : <NEWLINE> <INDENT> global kaukadouka <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> kaukadouka [ j ] = 0 <NEWLINE> <NL> <DEDENT> if i >= n : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if i < n - 1 : <NEWLINE> <INDENT> kau ( i + 1 ) <NEWLINE> kawanai ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> kau ( 0 ) <NEWLINE> kawanai ( 0 ) <NEWLINE> if len ( cheap ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( min ( cheap ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ANS = [ 0 for _ in range ( n ) ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ANS [ ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in ANS : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def function ( ) : <NEWLINE> <INDENT> _N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> teleportes = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> i , count = 0 , 0 <NEWLINE> visited = [ - 1 ] * len ( teleportes ) <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> if visited [ i ] == - 1 : <COMMENT> <NEWLINE> <INDENT> visited [ i ] = count <COMMENT> <NEWLINE> i = teleportes [ i ] - 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loops = count - visited [ i ] <COMMENT> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if K <= visited [ i ] : <NEWLINE> <INDENT> i = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= visited [ i ] <NEWLINE> K %= loops <NEWLINE> <DEDENT> for _k in range ( K ) : <NEWLINE> <INDENT> i = teleportes [ i ] - 1 <NEWLINE> <DEDENT> print ( i + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> function ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> cum = [ 0 for _ in range ( N ) ] <NEWLINE> cum [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> cum [ i + 1 ] = ( cum [ i ] + A [ i + 1 ] ) % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += ( A [ i ] * ( cum [ N - 1 ] - cum [ i ] ) ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> p = [ 0 for i in range ( 2019 ) ] <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> kar = 0 <NEWLINE> dig = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> kar = ( kar + int ( s [ n - 1 - i ] ) * dig ) % 2019 <NEWLINE> dig = ( dig * 10 ) % 2019 <NEWLINE> p [ kar ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += p [ i ] * ( p [ i ] - 1 ) // 2 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> if a <= x : <NEWLINE> <INDENT> ai = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ai = ( a // x ) * x <NEWLINE> if ai < a : <NEWLINE> <INDENT> ai += x <NEWLINE> <DEDENT> <DEDENT> if ai <= b : <NEWLINE> <INDENT> count += 1 <NEWLINE> count += ( b - ai ) // x <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> result = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> result = result * i <NEWLINE> <NL> <COMMENT> <NL> <NL> if ( result > pow ( 10 , 18 ) ) : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import collections <NEWLINE> C = collections . Counter ( a ) <NEWLINE> <NL> <COMMENT> <NL> <NL> sum = 0 <NEWLINE> for v in list ( C . values ( ) ) : <NEWLINE> <INDENT> sum += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> x = C [ a [ k ] ] <NEWLINE> print ( sum - ( x * ( x - 1 ) // 2 ) + ( ( x - 1 ) * ( x - 2 ) // 2 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ 0 for _ in range ( N ) ] <NEWLINE> for x in range ( 1 , math . floor ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , math . floor ( ( N - x ** 2 ) ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , math . floor ( ( N - x ** 2 - y ** 2 ) ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> c = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if c <= N : <NEWLINE> <INDENT> A [ c - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( - 1 ) <NEWLINE> up = [ ] <NEWLINE> pre = False <NEWLINE> sw = False <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - 1 ] : <NEWLINE> <INDENT> sw = True <NEWLINE> <DEDENT> elif A [ i ] < A [ i - 1 ] : <NEWLINE> <INDENT> sw = False <NEWLINE> <DEDENT> if sw != pre : <NEWLINE> <INDENT> up . append ( i - 1 ) <NEWLINE> <DEDENT> pre = sw <NEWLINE> <DEDENT> if up == [ ] : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> money = 1000 <NEWLINE> p = False <NEWLINE> for j in up : <NEWLINE> <INDENT> if p == False : <NEWLINE> <INDENT> stock = money // A [ j ] <NEWLINE> money -= stock * A [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> money += stock * A [ j ] <NEWLINE> stock = 0 <NEWLINE> <DEDENT> p = not p <NEWLINE> <DEDENT> print ( money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mn = float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] < mn : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> mn = min ( mn , p [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> adj = [ None ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> adj_i = list ( map ( int , input ( ) . split ( ) [ 2 : ] ) ) <NEWLINE> adj . append ( adj_i ) <NEWLINE> <NL> <DEDENT> isSearched = [ None ] + [ False ] * n <NEWLINE> <NL> distance = [ None ] + [ - 1 ] * n <NEWLINE> <NL> def bfs ( u ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> isSearched [ u ] = True <NEWLINE> distance [ u ] = d <NEWLINE> edge = [ u ] <NEWLINE> while edge : <NEWLINE> <INDENT> q = list ( edge ) <NEWLINE> edge = [ ] <NEWLINE> d += 1 <NEWLINE> for c_e in q : <NEWLINE> <INDENT> for n_e in adj [ c_e ] : <NEWLINE> <INDENT> if not isSearched [ n_e ] : <NEWLINE> <INDENT> isSearched [ n_e ] = True <NEWLINE> edge . append ( n_e ) <NEWLINE> distance [ n_e ] = d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( 1 ) <NEWLINE> <NL> for i , x in enumerate ( distance [ 1 : ] , start = 1 ) : <NEWLINE> <INDENT> print ( i , x ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s_str = input ( ) . split ( ) <NEWLINE> s_int = [ int ( s ) for s in s_str ] <NEWLINE> list = [ ] <NEWLINE> s_int . reverse ( ) <NEWLINE> for i in s_int : <NEWLINE> <INDENT> list . append ( i ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , list ) ) ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fromLeft = [ - 1 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> fromLeft [ i ] = a [ i ] - i <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> ldList = [ 0 ] * ( n * 2 + 5 ) <NEWLINE> <NL> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if 0 <= fromLeft [ i ] + n + 1 and fromLeft [ i ] + n + 1 < n * 2 + 5 : <NEWLINE> <INDENT> ldList [ fromLeft [ i ] + n + 1 ] += 1 <NEWLINE> <DEDENT> if 0 <= - 1 * a [ i ] - i + n + 1 and - 1 * a [ i ] - i + n + 1 < n * 2 + 5 : <NEWLINE> <INDENT> ans += ldList [ - 1 * a [ i ] - i + n + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def prime_factorization ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> primes = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> primes . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i ** 2 <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> n //= i <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> primes . append ( n ) <NEWLINE> <DEDENT> return primes <NEWLINE> <NL> <NL> <DEDENT> A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> a_primes = set ( prime_factorization ( A ) ) <NEWLINE> b_primes = set ( prime_factorization ( B ) ) <NEWLINE> <NL> print ( len ( a_primes & b_primes ) + 1 ) <NEWLINE>
arb = <STRING> <NEWLINE> S = input ( ) <NEWLINE> s_S = sorted ( set ( arb ) ^ set ( S ) ) <NEWLINE> print ( <STRING> if len ( s_S ) == 0 else s_S [ 0 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( n % k , k - n % k ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L_A = [ int ( s ) for s in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> if 0 in L_A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k *= L_A [ i ] <NEWLINE> if k > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <NL> <NL> X , Y = input ( ) . split ( ) <NEWLINE> X = int ( X ) <NEWLINE> Y = int ( Y ) <NEWLINE> <NL> a = ( Y - 2 * X ) / 2 <NEWLINE> <NL> if a >= 0 and X >= a and a == int ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> klists = [ ] <NEWLINE> B = [ A [ 0 ] ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if B [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> k = B [ i ] - A [ i + 1 ] <NEWLINE> klists . append ( k ) <NEWLINE> A [ i + 1 ] = A [ i + 1 ] + k <NEWLINE> <DEDENT> B . append ( A [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( klists ) ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if not h : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> mp = [ list ( <STRING> + input ( ) + <STRING> ) for _ in range ( h ) ] <NEWLINE> mp . insert ( 0 , [ <STRING> ] * ( w + 2 ) ) <NEWLINE> mp . append ( [ <STRING> ] * ( w + 2 ) ) <NEWLINE> <NL> direct = ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) <NEWLINE> <NL> def search ( x , y , target ) : <NEWLINE> <INDENT> mp [ y ] [ x ] = <STRING> <NEWLINE> for dx , dy in direct : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if mp [ ny ] [ nx ] == target : <NEWLINE> <INDENT> search ( nx , ny , target ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for x in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> target = mp [ y ] [ x ] <NEWLINE> if target != <STRING> : <NEWLINE> <INDENT> search ( x , y , target ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> lis = np . zeros ( 10 ** 5 ) <NEWLINE> <NL> As = np . array ( input ( ) . split ( ) ) . astype ( np . int64 ) <NEWLINE> NUM = As . sum ( ) <NEWLINE> <NL> for n in As : <NEWLINE> <INDENT> lis [ n - 1 ] += 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> nnn = lis [ B - 1 ] <NEWLINE> lis [ B - 1 ] = 0 <NEWLINE> lis [ C - 1 ] += nnn <NEWLINE> NUM = NUM - B * nnn + C * nnn <NEWLINE> print ( int ( NUM ) ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> mine_h = [ 0 ] * H <NEWLINE> mine_w = [ 0 ] * W <NEWLINE> val = - 1 <NEWLINE> mine = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mine_h [ a - 1 ] += 1 <NEWLINE> mine_w [ b - 1 ] += 1 <NEWLINE> mine . add ( ( a , b ) ) <NEWLINE> <DEDENT> max_h = max ( mine_h ) <NEWLINE> max_w = max ( mine_w ) <NEWLINE> h_index = [ i + 1 for i , x in enumerate ( mine_h ) if x == max_h ] <NEWLINE> w_index = [ i + 1 for i , x in enumerate ( mine_w ) if x == max_w ] <NEWLINE> for i in h_index : <NEWLINE> <INDENT> for j in w_index : <NEWLINE> <INDENT> if ( i , j ) in mine : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_h + max_w + val ) <NEWLINE>
def imas ( hoge_l , p , track ) : <NEWLINE> <INDENT> s_weights = 0 <NEWLINE> now_track = 1 <NEWLINE> for val in hoge_l : <NEWLINE> <INDENT> s_weights += val <NEWLINE> if s_weights > p : <NEWLINE> <INDENT> s_weights = val <NEWLINE> now_track += 1 <NEWLINE> <DEDENT> if now_track > track : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> num , track = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> hoge_l = list ( ) <NEWLINE> for _ in range ( num ) : <NEWLINE> <INDENT> hoge_l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> left = 0 <NEWLINE> right = 100000 * 10000 <NEWLINE> <NL> while left < right : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> if imas ( hoge_l , mid , track ) : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> max_num = max ( hoge_l ) <NEWLINE> if max_num > right : <NEWLINE> <INDENT> right = max_num <NEWLINE> <DEDENT> print ( right ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import heapq as hp <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> <NL> heap_array = [ ] <NEWLINE> for each in _input : <NEWLINE> <INDENT> if each . startswith ( <STRING> ) : <NEWLINE> <INDENT> hp . heappush ( heap_array , - 1 * int ( each [ 7 : ] ) ) <NEWLINE> <DEDENT> elif each . startswith ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 * hp . heappop ( heap_array ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> D = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> SS = S [ i : i + len ( T ) ] <NEWLINE> dif = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ j ] != SS [ j ] : <NEWLINE> <INDENT> dif += 1 <NEWLINE> <DEDENT> <DEDENT> D += [ dif ] <NEWLINE> <NL> <DEDENT> print ( min ( D ) ) <NEWLINE>
A = input ( ) <NEWLINE> <NL> moji = A . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> print ( moji ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> ans = [ - 1 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ a - 1 ] . append ( b - 1 ) <NEWLINE> c [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> d = deque ( [ 0 ] ) <COMMENT> <NEWLINE> <NL> while d : <NEWLINE> <INDENT> cur = d . pop ( ) <NEWLINE> for x in c [ cur ] : <NEWLINE> <INDENT> if ans [ x ] < 0 : <NEWLINE> <INDENT> ans [ x ] = cur <NEWLINE> d . appendleft ( x ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for ans in ans [ 1 : ] : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N , K = MI ( ) <NEWLINE> S = [ ] <NEWLINE> mod = 998244353 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> l , r = MI ( ) <NEWLINE> S . append ( ( l , r ) ) <NEWLINE> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> C = [ 0 ] * ( N + 1 ) <NEWLINE> C [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for s in S : <NEWLINE> <INDENT> l = max ( 1 , i - s [ 1 ] ) <NEWLINE> r = i - s [ 0 ] <NEWLINE> if r < 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] += ( C [ r ] - C [ l - 1 ] ) % mod <NEWLINE> <DEDENT> C [ i ] += ( dp [ i ] + C [ i - 1 ] ) % mod <NEWLINE> <DEDENT> print ( dp [ N ] % mod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = b - b // c - b // d + b // ( c * d // math . gcd ( c , d ) ) <NEWLINE> y = ( a - 1 ) - ( a - 1 ) // c - ( a - 1 ) // d + ( a - 1 ) // ( c * d // math . gcd ( c , d ) ) <NEWLINE> print ( x - y ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> q = X // D <NEWLINE> mod = X % D <NEWLINE> <NL> if q <= K : <NEWLINE> <INDENT> if ( K - q ) % 2 == 0 : <NEWLINE> <INDENT> ans = mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = D - mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = X - K * D <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r ** 2 * math . pi , r * 2 * math . pi ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n + m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> B = [ int ( input ( ) , 2 ) for i in range ( n ) ] <NEWLINE> C = { 0 : 0 } <NEWLINE> for b in B : <NEWLINE> <INDENT> * D , = C . items ( ) <NEWLINE> for k , v in D : <NEWLINE> <INDENT> C [ k ^ b ] = max ( C . get ( k ^ b , 0 ) , v + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( C [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * ( max ( A ) + 2 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> ans [ a + 1 ] += 1 <NEWLINE> <DEDENT> if a != 0 : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> ans [ a ] += 1 <NEWLINE> ans [ a + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
<COMMENT> <NL> S = input ( ) <NEWLINE> list_amari = [ 0 for i in range ( 2019 ) ] <NEWLINE> amari_prev = 0 <NEWLINE> X = 1 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> amari = ( int ( S [ - i - 1 ] ) * X + amari_prev ) % 2019 <NEWLINE> list_amari [ amari ] += 1 <NEWLINE> amari_prev = amari <NEWLINE> X = ( 10 * X ) % 2019 <NEWLINE> <NL> <DEDENT> count = list_amari [ 0 ] <NEWLINE> for v in list_amari : <NEWLINE> <INDENT> count += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list . insert ( 0 , 0 ) <NEWLINE> <NL> cum_sum = 0 <NEWLINE> cum_sum_list = [ ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> cum_sum += A_list [ i ] <NEWLINE> cum_sum_list . append ( cum_sum ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += A_list [ i ] * ( cum_sum_list [ N ] - cum_sum_list [ i ] ) <NEWLINE> ans = ans % 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ls . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( ls ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ok = 1001001001 <NEWLINE> ng = 0 <NEWLINE> def check ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for q in a : <NEWLINE> <INDENT> cnt += ( q - 1 ) // x <NEWLINE> <DEDENT> return cnt <= k <NEWLINE> <NL> <DEDENT> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( 800 * n - 200 * ( n // 15 ) ) <NEWLINE>
import sys <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sa = 300 <NEWLINE> <NL> for i in range ( 102 ) : <NEWLINE> <INDENT> if abs ( i - x ) < sa : <NEWLINE> <INDENT> if not ( ( i ) in p ) : <NEWLINE> <INDENT> sa = abs ( i - x ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> md = 10 ** 9 + 7 <NEWLINE> n = II ( ) <NEWLINE> aa = LI ( ) <NEWLINE> cs = [ 0 ] <NEWLINE> for a in aa : cs . append ( cs [ - 1 ] ^ a ) <NEWLINE> <COMMENT> <NL> <NL> cnt = { } <NEWLINE> cnt0 = [ 1 ] * len ( cs ) <NEWLINE> for i , s in enumerate ( cs [ 1 : ] , 1 ) : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> cnt0 [ i ] = cnt0 [ i - 1 ] + 1 <NEWLINE> <DEDENT> elif s in cnt : <NEWLINE> <INDENT> cnt0 [ i ] = cnt0 [ i - 1 ] <NEWLINE> c0 = cnt0 [ i ] - cnt0 [ cnt [ s ] [ 2 ] ] <NEWLINE> cnt [ s ] [ 0 ] = ( cnt [ s ] [ 0 ] + cnt [ s ] [ 1 ] * c0 ) % md <NEWLINE> cnt [ s ] [ 1 ] = ( cnt [ s ] [ 1 ] + cnt [ s ] [ 0 ] ) % md <NEWLINE> cnt [ s ] [ 2 ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt0 [ i ] = cnt0 [ i - 1 ] <NEWLINE> cnt [ s ] = [ 1 , 1 , i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if cs [ - 1 ] == 0 : ans = sum ( v [ 1 ] for v in cnt . values ( ) ) + pow ( 2 , cnt0 [ - 1 ] - 2 , md ) <NEWLINE> else : ans = cnt [ cs [ - 1 ] ] [ 0 ] <NEWLINE> print ( ans % md ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> b = N <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if i % 2 == M % 2 : <NEWLINE> <INDENT> print ( a , a + i ) <NEWLINE> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b , b - i ) <NEWLINE> b -= 1 <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = 0 <NEWLINE> if ( k <= a ) : <NEWLINE> <INDENT> aa += k <NEWLINE> <DEDENT> if ( k > a ) : <NEWLINE> <INDENT> aa += a <NEWLINE> k = k - a <NEWLINE> <DEDENT> if ( k <= b and k > 0 ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> if ( k > b ) : <NEWLINE> <INDENT> k = k - b <NEWLINE> <DEDENT> if ( k <= c and k > 0 ) : <NEWLINE> <INDENT> aa = aa - k <NEWLINE> <DEDENT> if ( k > c and k > 0 ) : <NEWLINE> <INDENT> aa = aa - c <NEWLINE> <DEDENT> print ( aa ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while a * c != 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if List [ 0 ] % List [ 1 ] >= abs ( List [ 0 ] % List [ 1 ] - List [ 1 ] ) : <NEWLINE> <INDENT> print ( abs ( List [ 0 ] % List [ 1 ] - List [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( List [ 0 ] % List [ 1 ] ) ) <NEWLINE> <DEDENT>
m = int ( input ( ) ) <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , left , right ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class BinaryTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def getRoot ( self ) : <NEWLINE> <INDENT> return self . root <NEWLINE> <DEDENT> def setRoot ( self , v ) : <NEWLINE> <INDENT> self . root = v <NEWLINE> <NL> <DEDENT> def inorder ( self , v = None ) : <NEWLINE> <INDENT> if v is None : <NEWLINE> <INDENT> v = self . root <NEWLINE> <DEDENT> if v . left is not None : <NEWLINE> <INDENT> self . inorder ( v . left ) <NEWLINE> <DEDENT> print ( <STRING> + str ( v . key ) , end = <STRING> ) <NEWLINE> if v . right is not None : <NEWLINE> <INDENT> self . inorder ( v . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( self , v = None ) : <NEWLINE> <INDENT> if v is None : <NEWLINE> <INDENT> v = self . root <NEWLINE> <DEDENT> print ( <STRING> + str ( v . key ) , end = <STRING> ) <NEWLINE> if v . left is not None : <NEWLINE> <INDENT> self . preorder ( v . left ) <NEWLINE> <DEDENT> if v . right is not None : <NEWLINE> <INDENT> self . preorder ( v . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def insert ( T , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = T . getRoot ( ) <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y is None : <NEWLINE> <INDENT> T . setRoot ( z ) <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( T , k , noprint = False ) : <NEWLINE> <INDENT> x = T . getRoot ( ) <NEWLINE> while x is not None : <NEWLINE> <INDENT> if x . key == k : <NEWLINE> <INDENT> if not noprint : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> elif x . key < k : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def getNext ( v ) : <NEWLINE> <INDENT> if v . right is not None : <NEWLINE> <INDENT> return getMinimum ( v . right ) <NEWLINE> <DEDENT> y = v . p <NEWLINE> while y is not None and v == y . right : <NEWLINE> <INDENT> v = y <NEWLINE> y = y . p <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def getMinimum ( v ) : <NEWLINE> <INDENT> while v . left is not None : <NEWLINE> <INDENT> v = v . left <NEWLINE> <DEDENT> return v <NEWLINE> <NL> <NL> <NL> <DEDENT> def delete ( T , z ) : <NEWLINE> <INDENT> if not z . left and not z . right : <NEWLINE> <INDENT> p = z . p <NEWLINE> if z . key < p . key : <NEWLINE> <INDENT> p . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> elif z . left and not z . right : <NEWLINE> <INDENT> p = z . p <NEWLINE> c = z . left <NEWLINE> if z . key > p . key : <NEWLINE> <INDENT> p . right = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . left = c <NEWLINE> <DEDENT> c . p = p <NEWLINE> <DEDENT> elif not z . left and z . right : <NEWLINE> <INDENT> p = z . p <NEWLINE> c = z . right <NEWLINE> if z . key > p . key : <NEWLINE> <INDENT> p . right = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . left = c <NEWLINE> <DEDENT> c . p = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = getNext ( z ) <NEWLINE> z . key = n . key <NEWLINE> delete ( T , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> T = BinaryTree ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> inp = input ( ) . split ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . inorder ( ) <NEWLINE> print ( ) <NEWLINE> T . preorder ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> find ( T , int ( inp [ 1 ] ) ) <NEWLINE> <DEDENT> elif inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> delete ( T , find ( T , int ( inp [ 1 ] ) , True ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = Node ( int ( inp [ 1 ] ) , None , None ) <NEWLINE> insert ( T , v ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> S_p = [ ] <NEWLINE> S_n = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> end = 0 <NEWLINE> mim = 0 <NEWLINE> for c in input ( ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> end += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end -= 1 <NEWLINE> <DEDENT> mim = min ( mim , end ) <NEWLINE> <NL> <DEDENT> if end >= 0 : <NEWLINE> <INDENT> S_p . append ( [ mim , end ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S_n . append ( [ end - mim , end ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> S_p . sort ( reverse = True ) <NEWLINE> S_n . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> check = 0 <NEWLINE> flag = True <NEWLINE> for i in range ( len ( S_p ) ) : <NEWLINE> <INDENT> if check + S_p [ i ] [ 0 ] >= 0 : <NEWLINE> <INDENT> check += S_p [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( len ( S_n ) ) : <NEWLINE> <INDENT> if check + S_n [ i ] [ 1 ] - S_n [ i ] [ 0 ] >= 0 : <NEWLINE> <INDENT> check += S_n [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if check == 0 and flag : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> print ( <STRING> if flag else <STRING> ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = a * ( n // ( a + b ) ) + min ( a , n % ( a + b ) ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> p = [ int ( input ( ) ) for i in range ( 0 , N ) ] <NEWLINE> maxv = p [ 1 ] - p [ 0 ] <NEWLINE> buy = p [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if p [ i ] - buy > maxv : <NEWLINE> <INDENT> maxv = p [ i ] - buy <NEWLINE> <DEDENT> if p [ i ] < buy : <NEWLINE> <INDENT> buy = p [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
rooms = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> rooms [ a - 1 ] [ b - 1 ] [ c - 1 ] += d <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( rooms [ i ] [ j ] [ k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> <DEDENT> print ( f ( min ( N , B - 1 ) ) ) <NEWLINE>
t = set ( ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cmd , key = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> t . add ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if key in t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a5 = a ** 5 <NEWLINE> d = X - a5 <NEWLINE> if d >= 0 : <NEWLINE> <INDENT> c = d ** 0.2 <NEWLINE> b1 = int ( c ) <NEWLINE> b2 = b1 + 1 <NEWLINE> if a5 + b1 ** 5 == X : <NEWLINE> <INDENT> print ( a , - b1 ) <NEWLINE> break <NEWLINE> <DEDENT> if a5 + b2 ** 5 == X : <NEWLINE> <INDENT> print ( a , - b2 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c = ( ( - d ) ** 0.2 ) <NEWLINE> b1 = int ( c ) <NEWLINE> b2 = b1 + 1 <NEWLINE> if a5 - b1 ** 5 == X : <NEWLINE> <INDENT> print ( a , b1 ) <NEWLINE> break <NEWLINE> <DEDENT> if a5 - b2 ** 5 == X : <NEWLINE> <INDENT> print ( a , b2 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a += 1 <NEWLINE> <DEDENT>
<NL> <NL> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += int ( ( n - 1 ) / i ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> import copy <NEWLINE> B = copy . copy ( A ) <NEWLINE> C = sum ( B ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> C = ( C - B [ i ] ) % MOD <NEWLINE> ans += A [ i ] * C % MOD <NEWLINE> ans = ans % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a + b <= k : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
def calcTotalOfRowAndCol ( matrix , r , c ) : <NEWLINE> <INDENT> for l in matrix : <NEWLINE> <INDENT> total = 0 <NEWLINE> for val in l : <NEWLINE> <INDENT> total += val <NEWLINE> <DEDENT> l . append ( total ) <NEWLINE> <DEDENT> matrix . append ( [ ] ) <NEWLINE> for i in range ( c + 1 ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> j = 0 <NEWLINE> while j < r : <NEWLINE> <INDENT> total += matrix [ j ] [ i ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> matrix [ r ] . insert ( i , total ) <NEWLINE> <NL> <DEDENT> return matrix <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> matrix = [ ] <NEWLINE> row , col = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> i = row <NEWLINE> while i > 0 : <NEWLINE> <INDENT> matrix . append ( [ int ( y ) for y in input ( ) . split ( ) ] ) <NEWLINE> i -= 1 <NEWLINE> <DEDENT> matrix2 = calcTotalOfRowAndCol ( matrix , row , col ) <NEWLINE> for l in matrix : <NEWLINE> <INDENT> print ( <STRING> . join ( str ( x ) for x in l ) ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> import sys <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( input ( ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> list = input ( ) . split ( ) <NEWLINE> MIN = 1001 <NEWLINE> SUM = 0 <NEWLINE> for j in range ( 0 , K ) : <NEWLINE> <INDENT> for i in list : <NEWLINE> <INDENT> if MIN > int ( i ) : <NEWLINE> <INDENT> MIN = int ( i ) <NEWLINE> <DEDENT> <DEDENT> list . remove ( str ( MIN ) ) <NEWLINE> SUM += MIN <NEWLINE> MIN = 1001 <NEWLINE> <DEDENT> print ( SUM ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> k = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = n // i <NEWLINE> t += i * k * ( k + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( t ) <NEWLINE>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> s = 1 <NEWLINE> c = 0 <NEWLINE> l = 0 <NEWLINE> r = - 1 <NEWLINE> c1 = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if k - c >= 2 : <NEWLINE> <INDENT> if a [ r ] * a [ r - 1 ] > a [ l ] * a [ l + 1 ] : <NEWLINE> <INDENT> s *= a [ r ] * a [ r - 1 ] <NEWLINE> r -= 2 <NEWLINE> c += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s *= a [ l ] * a [ l + 1 ] <NEWLINE> l += 2 <NEWLINE> c += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ r ] < 0 : <NEWLINE> <INDENT> s = 1 <NEWLINE> a = np . absolute ( a ) <NEWLINE> a = list ( a ) <NEWLINE> a . sort ( ) <NEWLINE> while True : <NEWLINE> <INDENT> s *= a [ c1 ] <NEWLINE> c1 += 1 <NEWLINE> s %= 10 ** 9 + 7 <NEWLINE> if c1 == k : <NEWLINE> <INDENT> s = - s <NEWLINE> print ( s % 10 ** 9 + 7 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : s *= a [ r ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> s %= 10 ** 9 + 7 <NEWLINE> if k == c : break <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , * d = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> if 0 in d : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> A = 1 <NEWLINE> for O in d : <NEWLINE> <INDENT> A *= O <NEWLINE> <COMMENT> <NL> if A > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( an ) for an in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> set_a = set ( a ) <NEWLINE> num_of_types = len ( set_a ) <NEWLINE> if num_of_types > k : <NEWLINE> <INDENT> cnt = Counter ( a ) <NEWLINE> ans = sum ( sorted ( cnt . values ( ) ) [ : num_of_types - k ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> n -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + n % 26 ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> neighbor = [ [ ] for _ in range ( n ) ] <NEWLINE> for edge in edges : <NEWLINE> <INDENT> neighbor [ edge [ 0 ] - 1 ] . append ( edge [ 1 ] - 1 ) <COMMENT> <NEWLINE> neighbor [ edge [ 1 ] - 1 ] . append ( edge [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> queue = deque ( ) <NEWLINE> queue . append ( 0 ) <NEWLINE> <NL> back = [ - 1 ] * n <COMMENT> <NEWLINE> back [ 0 ] = 0 <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> vertex = queue . popleft ( ) <NEWLINE> for nei in neighbor [ vertex ] : <NEWLINE> <INDENT> if back [ nei ] == - 1 : <NEWLINE> <INDENT> back [ nei ] = vertex <NEWLINE> queue . append ( nei ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in back [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <COMMENT> <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> di = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ls [ a ] . append ( [ b , i + 1 ] ) <NEWLINE> <DEDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> if ls [ j ] != [ ] : <NEWLINE> <INDENT> ls [ j ] . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for k in range ( len ( ls [ j ] ) ) : <NEWLINE> <INDENT> di . append ( [ ls [ j ] [ k ] [ 1 ] , str ( 10 ** 12 + j * 10 ** 6 + k + 1 ) [ 1 : ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> di . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for l in range ( m ) : <NEWLINE> <INDENT> print ( di [ l ] [ 1 ] ) <NEWLINE> <DEDENT>
I = input ( ) . split ( ) <NEWLINE> r = int ( I [ 0 ] ) <NEWLINE> c = int ( I [ 1 ] ) <NEWLINE> Rsum = 0 <NEWLINE> Csum = ( c + 1 ) * [ 0 ] <NEWLINE> <NL> o = [ [ 0 for i2 in range ( c + 1 ) ] for i1 in range ( r + 1 ) ] <NEWLINE> <NL> for i in range ( r + 1 ) : <NEWLINE> <INDENT> if i < r : <NEWLINE> <INDENT> Irc = input ( ) . split ( ) <NEWLINE> <DEDENT> for j in range ( c ) : <NEWLINE> <INDENT> if i < r : <NEWLINE> <INDENT> o [ i ] [ j ] = int ( Irc [ j ] ) <NEWLINE> Rsum += o [ i ] [ j ] <NEWLINE> Csum [ j ] += o [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o [ i ] [ j ] += Csum [ j ] <NEWLINE> Rsum += o [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> o [ i ] [ c ] = Rsum <NEWLINE> Csum [ c ] = o [ i ] [ c ] <NEWLINE> Rsum = 0 <NEWLINE> <NL> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> print ( str ( o [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> if j != c : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , K = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> A = [ int ( u ) for u in a ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if i >= K : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> result = A * ( N // ( A + B ) ) + min ( N % ( A + B ) , A ) <NEWLINE> <NL> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> res = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> res = res * x <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> M = 256 <NEWLINE> <NL> def entropy_if_smallest ( ctr , bound ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for v in ctr : <NEWLINE> <INDENT> if v == 0 : continue <NEWLINE> ret -= ( v / N ) * math . log2 ( v / N ) <NEWLINE> if ret >= bound : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def solve ( src ) : <NEWLINE> <INDENT> ans_h = float ( <STRING> ) <NEWLINE> ans = None <NEWLINE> for s in range ( 16 ) : <NEWLINE> <INDENT> for a in range ( 16 ) : <NEWLINE> <INDENT> for c in range ( 16 ) : <NEWLINE> <INDENT> ctr = [ 0 ] * M <NEWLINE> r = s <NEWLINE> for i in src : <NEWLINE> <INDENT> r = ( a * r + c ) % M <NEWLINE> o = ( i + r ) % M <NEWLINE> ctr [ o ] += 1 <NEWLINE> <DEDENT> h = entropy_if_smallest ( ctr , ans_h ) <NEWLINE> if h is not None : <NEWLINE> <INDENT> ans = ( s , a , c ) <NEWLINE> ans_h = h <NEWLINE> if ans_h == 0 : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> src = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . join ( map ( str , solve ( src ) ) ) ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> c . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> def countb ( c ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> num += c [ i ] . count ( <STRING> ) <NEWLINE> <DEDENT> return ( num ) <NEWLINE> <NL> <DEDENT> def printb ( c , row , col ) : <NEWLINE> <INDENT> c = c [ : ] <NEWLINE> <COMMENT> <NL> cnt = 0 <NEWLINE> while row != 0 : <NEWLINE> <INDENT> if row & 0b1 : <NEWLINE> <NL> <INDENT> c [ cnt ] = <STRING> * w <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> row = row >> 1 <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> while col != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if col & 0b1 : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> c [ i ] = c [ i ] [ : cnt ] + <STRING> + c [ i ] [ cnt + 1 : ] <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> col = col >> 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return countb ( c ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** h ) : <NEWLINE> <INDENT> for j in range ( 2 ** w ) : <NEWLINE> <INDENT> if printb ( c , i , j ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a . append ( 1 ) <NEWLINE> <DEDENT> max = 0 <NEWLINE> inp = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ta , tb , tc , td = map ( int , input ( ) . split ( ) ) <NEWLINE> inp . append ( ( ta , tb , tc , td ) ) <NEWLINE> <DEDENT> for i1 in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> a [ 0 ] = i1 <NEWLINE> for i2 in range ( i1 , m + 1 ) : <NEWLINE> <INDENT> a [ 1 ] = i2 <NEWLINE> for i3 in range ( i2 , m + 1 ) : <NEWLINE> <INDENT> a [ 2 ] = i3 <NEWLINE> for i4 in range ( i3 , m + 1 ) : <NEWLINE> <INDENT> a [ 3 ] = i4 <NEWLINE> for i5 in range ( i4 , m + 1 ) : <NEWLINE> <INDENT> a [ 4 ] = i5 <NEWLINE> for i6 in range ( i5 , m + 1 ) : <NEWLINE> <INDENT> a [ 5 ] = i6 <NEWLINE> for i7 in range ( i6 , m + 1 ) : <NEWLINE> <INDENT> a [ 6 ] = i7 <NEWLINE> for i8 in range ( i7 , m + 1 ) : <NEWLINE> <INDENT> a [ 7 ] = i8 <NEWLINE> for i9 in range ( i8 , m + 1 ) : <NEWLINE> <INDENT> a [ 8 ] = i9 <NEWLINE> for i10 in range ( i9 , m + 1 ) : <NEWLINE> <INDENT> a [ 9 ] = i10 <NEWLINE> sum = 0 <NEWLINE> if q != 1 : <NEWLINE> <INDENT> for i in range ( q ) : <NEWLINE> <INDENT> if a [ inp [ i ] [ 1 ] - 1 ] - a [ inp [ i ] [ 0 ] - 1 ] == inp [ i ] [ 2 ] : <NEWLINE> <INDENT> sum = sum + inp [ i ] [ 3 ] <NEWLINE> <DEDENT> if sum > max : <NEWLINE> <INDENT> max = sum <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ inp [ 0 ] [ 1 ] - 1 ] - a [ inp [ 0 ] [ 0 ] - 1 ] == inp [ 0 ] [ 2 ] : <NEWLINE> <INDENT> sum = sum + inp [ 0 ] [ 3 ] <NEWLINE> <DEDENT> if sum > max : <NEWLINE> <INDENT> max = sum <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 2018 <NEWLINE> if R - L >= 2019 : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( L + 1 , R + 1 ) : <NEWLINE> <INDENT> result = min ( result , i * j % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ i for i in range ( 0 , 102 ) if i not in a ] <NEWLINE> b_tmp = list ( map ( lambda s : abs ( s - x ) , b ) ) <COMMENT> <NEWLINE> address = b_tmp . index ( min ( b_tmp ) ) <NEWLINE> print ( b [ address ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ 0 ] * n <NEWLINE> if n == 1 : <NEWLINE> <INDENT> m = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = int ( ( n - 2 ) ** 0.5 ) <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> for j in range ( i , m ) : <NEWLINE> <INDENT> for k in range ( j , m ) : <NEWLINE> <INDENT> if i * i + j * j + k * k + i * j + j * k + k * i <= n : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> list [ i * i + j * j + k * k + i * j + j * k + k * i - 1 ] += 1 <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> list [ i * i + j * j + k * k + i * j + j * k + k * i - 1 ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list [ i * i + j * j + k * k + i * j + j * k + k * i - 1 ] += 6 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( list [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> base = input ( ) . split ( ) <NEWLINE> x = [ ] <NEWLINE> for i in base : <NEWLINE> <INDENT> x . append ( int ( i ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> c = collections . Counter ( x ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> a_c = a . cumsum ( ) <NEWLINE> a_t = a_c [ - 1 ] <NEWLINE> diff = np . abs ( 2 * a_c - a_t ) <NEWLINE> ans = diff [ : - 1 ] . min ( ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> alf = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> <NL> maxdigit = 1 <NEWLINE> pre = 0 <NEWLINE> <NL> while N - pre > 26 ** maxdigit : <NEWLINE> <INDENT> pre += 26 ** maxdigit <NEWLINE> maxdigit += 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> N -= pre <NEWLINE> <NL> res = <STRING> <NEWLINE> <NL> for d in range ( 1 , maxdigit + 1 ) : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if N <= 26 ** ( maxdigit - d ) * ( i + 1 ) : <NEWLINE> <INDENT> res += alf [ i ] <NEWLINE> N -= 26 ** ( maxdigit - d ) * i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
def maxof ( x , y ) : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> max_num = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> max_num = maxof ( max_num , a [ i ] ) <NEWLINE> total = total + max_num - a [ i ] <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> b = [ [ 0 ] for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] [ 0 ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = [ [ 0 ] for i in range ( n ) ] <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ 0 ] += A [ i ] [ j ] * b [ j ] [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , gcd ( b , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
count = int ( input ( ) ) <NEWLINE> array = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> for n in range ( count - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> print ( array [ n ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( array [ 0 ] ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . reverse ( ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i - 1 ] == h [ i ] - 1 : <NEWLINE> <INDENT> h [ i ] = h [ i ] - 1 <NEWLINE> <DEDENT> if h [ i - 1 ] < h [ i ] - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcdab = math . gcd ( a , b ) <NEWLINE> if gcdab == 1 : <NEWLINE> <INDENT> s += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( gcdab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from heapq import heapify , heappush as hpush , heappop as hpop <NEWLINE> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ 1 ] * ( W + 2 ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> X += [ 1 ] + [ 1 if a == <STRING> else 0 for a in input ( ) ] + [ 1 ] <NEWLINE> <DEDENT> X += [ 1 ] * ( W + 2 ) <NEWLINE> X += X [ : ] <NEWLINE> H , W = H + 2 , W + 2 <NEWLINE> HW = H * W <NEWLINE> s , t = x1 * W + y1 , x2 * W + y2 <NEWLINE> ss , tt = s + HW , t + HW <NEWLINE> def dijkstra ( ) : <NEWLINE> <INDENT> n = 2 * H * W <NEWLINE> h = [ ( 0 , s ) , ( 0 , ss ) ] <NEWLINE> D = [ - 1 ] * n <NEWLINE> done = [ 0 ] * n <NEWLINE> D [ s ] = 0 <NEWLINE> D [ ss ] = 0 <NEWLINE> while h : <NEWLINE> <INDENT> d , i = hpop ( h ) <NEWLINE> done [ i ] = 1 <NEWLINE> if i < HW : <NEWLINE> <INDENT> for j in ( i + 1 , i - 1 ) : <NEWLINE> <INDENT> nd = d + 1 <NEWLINE> if X [ j ] : continue <NEWLINE> if D [ j ] < 0 or D [ j ] > nd : <NEWLINE> <INDENT> if done [ j ] == 0 : <NEWLINE> <INDENT> hpush ( h , ( nd , j ) ) <NEWLINE> D [ j ] = nd <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in ( i + W , i - W ) : <NEWLINE> <INDENT> nd = d + 1 <NEWLINE> if X [ j ] : continue <NEWLINE> if D [ j ] < 0 or D [ j ] > nd : <NEWLINE> <INDENT> if done [ j ] == 0 : <NEWLINE> <INDENT> hpush ( h , ( nd , j ) ) <NEWLINE> D [ j ] = nd <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> j = i + HW if i < HW else i - HW <NEWLINE> nd = ( d + K - 1 ) // K * K <NEWLINE> if X [ j ] : continue <NEWLINE> if D [ j ] < 0 or D [ j ] > nd : <NEWLINE> <INDENT> if done [ j ] == 0 : <NEWLINE> <INDENT> hpush ( h , ( nd , j ) ) <NEWLINE> D [ j ] = nd <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ - ( - a // K ) for a in ( D [ t ] , D [ tt ] ) if a >= 0 ] <NEWLINE> <NL> <DEDENT> di = dijkstra ( ) <NEWLINE> print ( min ( di ) if di else - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> jyoshi = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> jyo = a [ i ] <NEWLINE> jyoshi [ jyo - 1 ] = jyoshi [ jyo - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for k in jyoshi : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def sum_gcd ( k : int ) -> int : <NEWLINE> <COMMENT> <NL> <INDENT> sum_p1 = 0 <NEWLINE> for h in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , h ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> sum_p1 += gcd ( gcd ( h , i ) , j ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sum_p2 = 0 <NEWLINE> for h in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , h ) : <NEWLINE> <INDENT> sum_p2 += gcd ( h , i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> sum_p3 = k * ( k + 1 ) // 2 <NEWLINE> <NL> answer = sum_p1 * 6 + sum_p2 * 6 + sum_p3 <NEWLINE> <NL> return answer <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) . rstrip ( ) ) <NEWLINE> print ( sum_gcd ( k ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import heapq as pq <NEWLINE> inf = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> M = [ None ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M [ L [ 0 ] ] = [ ] <NEWLINE> for j in range ( L [ 1 ] ) : <NEWLINE> <INDENT> M [ L [ 0 ] ] . append ( [ L [ 2 * j + 2 ] , L [ 2 * j + 3 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dijkstra ( s ) : <NEWLINE> <INDENT> color = [ 0 ] * n <NEWLINE> d = [ inf ] * n <NEWLINE> d [ s ] = 0 <NEWLINE> H = [ ] <NEWLINE> pq . heappush ( H , [ 0 , s ] ) <NEWLINE> <NL> while len ( H ) != 0 : <NEWLINE> <INDENT> u2 , u1 = pq . heappop ( H ) <NEWLINE> color [ u1 ] = 1 <NEWLINE> if d [ u1 ] < u2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for v1 , v2 in M [ u1 ] : <NEWLINE> <INDENT> if color [ v1 ] == 1 : continue <NEWLINE> if d [ u1 ] + v2 < d [ v1 ] : <NEWLINE> <INDENT> d [ v1 ] = d [ u1 ] + v2 <NEWLINE> pq . heappush ( H , [ d [ v1 ] , v1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> d = dijkstra ( 0 ) <NEWLINE> for i , v in enumerate ( d ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , v ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = sorted ( a ) <NEWLINE> ans = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( ans > 1e18 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( ans > 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
M = int ( input ( ) ) <NEWLINE> k , g = 0 , 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> d , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k += c <NEWLINE> g += c * d <NEWLINE> <DEDENT> print ( ( g - 1 ) // 9 + ( k - 1 ) ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( x ) <NEWLINE> if k <= x // d : <NEWLINE> <INDENT> y = x - k * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - x // d ) % 2 == 0 : <NEWLINE> <INDENT> y = x % d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = min ( abs ( x % d - d ) , abs ( x % d + d ) ) <NEWLINE> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> not_good = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> x = a - 1 <NEWLINE> y = b - 1 <NEWLINE> hx = h_list [ x ] <NEWLINE> hy = h_list [ y ] <NEWLINE> if hx == hy : <NEWLINE> <INDENT> not_good . add ( x ) <NEWLINE> not_good . add ( y ) <NEWLINE> <DEDENT> elif hx > hy : <NEWLINE> <INDENT> not_good . add ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> not_good . add ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - len ( not_good ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a , b = x , x <NEWLINE> while True : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> if b not in p : <NEWLINE> <INDENT> print ( b ) <NEWLINE> break <NEWLINE> <DEDENT> elif a not in p : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> m_a = max ( A ) + 1 <NEWLINE> dp = [ 0 ] * m_a <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> if dp [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , m_a , i ) : <NEWLINE> <INDENT> dp [ j ] += 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> input_num = stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> X = int ( input_num [ 0 ] ) <NEWLINE> N = int ( input_num [ 1 ] ) <NEWLINE> num_list = [ ] <NEWLINE> if N != 0 : <NEWLINE> <INDENT> num_list = [ int ( x ) for x in stdin . readline ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <NL> <DEDENT> dec_num = X <NEWLINE> inc_num = X <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif X not in num_list : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> dec_num += - 1 <NEWLINE> inc_num += 1 <NEWLINE> if dec_num not in num_list : <NEWLINE> <INDENT> print ( dec_num ) <NEWLINE> break <NEWLINE> <DEDENT> if inc_num not in num_list : <NEWLINE> <INDENT> print ( inc_num ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 6 ) <NEWLINE> MAXN = 100 <NEWLINE> <NL> n = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> dl = [ [ None ] * ( MAXN + 1 ) for _ in range ( MAXN + 1 ) ] <NEWLINE> de = [ [ None ] * ( MAXN + 1 ) for _ in range ( MAXN + 1 ) ] <NEWLINE> <NL> <NL> def n_num_e ( d , i ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if d == 0 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> elif de [ d ] [ i ] is not None : <NEWLINE> <INDENT> return de [ d ] [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( n [ d - 1 ] ) == 0 : <NEWLINE> <INDENT> result = n_num_e ( d - 1 , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = n_num_e ( d - 1 , i - 1 ) <NEWLINE> <DEDENT> de [ d ] [ i ] = result <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def n_num_l ( d , i ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if d == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif dl [ d ] [ i ] is not None : <NEWLINE> <INDENT> return dl [ d ] [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( n [ d - 1 ] ) == 0 : <NEWLINE> <INDENT> ne = 0 <NEWLINE> nl = 9 * n_num_l ( d - 1 , i - 1 ) + n_num_l ( d - 1 , i ) <NEWLINE> result = ne + nl <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ne = ( int ( n [ d - 1 ] ) - 1 ) * n_num_e ( d - 1 , i - 1 ) + n_num_e ( d - 1 , i ) <NEWLINE> nl = 9 * n_num_l ( d - 1 , i - 1 ) + n_num_l ( d - 1 , i ) <NEWLINE> result = ne + nl <NEWLINE> <NL> <DEDENT> dl [ d ] [ i ] = result <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> answer = n_num_e ( len ( n ) , k ) + n_num_l ( len ( n ) , k ) <NEWLINE> print ( answer ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum -= a [ i ] <NEWLINE> ans += a [ i ] * sum <NEWLINE> <NL> <DEDENT> m = 10 ** 9 + 7 <NEWLINE> <NL> ans = ans % m <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> L = len ( S ) <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> A = [ 0 ] * 2019 <NEWLINE> A [ 0 ] = 1 <NEWLINE> d = 0 <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> now = now + int ( S [ i ] ) * pow ( 10 , d , 2019 ) <NEWLINE> now %= 2019 <NEWLINE> d += 1 <NEWLINE> A [ now ] += 1 <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> def prime_check ( n ) : <NEWLINE> <INDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> if x != 2 : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> if prime_check ( x ) == True : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , e = map ( int , input ( ) . split ( ) ) <NEWLINE> B [ s ] . append ( A [ e ] ) <NEWLINE> B [ e ] . append ( A [ s ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( B [ i ] ) == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif max ( B [ i ] ) < A [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = collections . Counter ( a ) <NEWLINE> c = list ( ans . values ( ) ) <NEWLINE> c = np . array ( c ) <NEWLINE> print ( sum ( c % 2 ) ) <NEWLINE>
<STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> B , C = [ 0 ] * Q , [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> bucket = [ 0 ] * 100001 <NEWLINE> for i in A : <NEWLINE> <INDENT> bucket [ i ] += 1 <NEWLINE> <NL> <DEDENT> sum = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> sum += ( C [ i ] - B [ i ] ) * bucket [ B [ i ] ] <NEWLINE> bucket [ C [ i ] ] += bucket [ B [ i ] ] <NEWLINE> bucket [ B [ i ] ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> H = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> if l <= H and A [ l - 1 ] > A [ i - 1 ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= H and A [ r - 1 ] > A [ largest - 1 ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i - 1 ] , A [ largest - 1 ] = A [ largest - 1 ] , A [ i - 1 ] <NEWLINE> maxHeapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( A ) : <NEWLINE> <INDENT> for i in range ( H // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( A , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> buildMaxHeap ( A ) <NEWLINE> A = <STRING> + <STRING> . join ( [ str ( num ) for num in A ] ) <NEWLINE> print ( A ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> d = Counter ( A ) <NEWLINE> <NL> if len ( d ) > 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> k = list ( d . keys ( ) ) <NEWLINE> v = list ( d . values ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if len ( d ) == 3 and k [ 0 ] ^ k [ 1 ] ^ k [ 2 ] == 0 and v [ 0 ] == v [ 1 ] == v [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif len ( d ) == 2 and ( ( k [ 0 ] == 0 and v [ 1 ] == 2 * v [ 0 ] ) or ( k [ 1 ] == 0 and v [ 0 ] == 2 * v [ 1 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif len ( d ) == 1 and k [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def gcd ( m , n ) : <NEWLINE> <INDENT> if n != 0 : <NEWLINE> <INDENT> return gcd ( n , m % n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return m <NEWLINE> <NL> <DEDENT> <DEDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> m , n = map ( int , line . split ( ) ) <NEWLINE> g = gcd ( m , n ) <NEWLINE> l = m * n // g <COMMENT> <NEWLINE> print ( g , l ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( a [ 0 ] + sum ( a [ 1 : int ( n / 2 ) ] ) * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 0 ] + sum ( a [ 1 : int ( ( n - 1 ) / 2 ) ] ) * 2 + a [ int ( ( n + 1 ) / 2 - 1 ) ] ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> k = math . factorial ( n ) <NEWLINE> print ( k % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> K = int ( input ( ) ) + 1 <NEWLINE> mydict = { } <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for h in range ( 1 , K ) : <NEWLINE> <INDENT> ans += gcd ( h , gcd ( h , h ) ) <NEWLINE> <NL> for i in range ( h + 1 , K ) : <NEWLINE> <INDENT> ans += ( gcd ( h , gcd ( h , i ) ) * 3 ) <NEWLINE> ans += ( gcd ( h , gcd ( i , i ) ) * 3 ) <NEWLINE> <NL> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> ans += ( gcd ( h , gcd ( i , j ) ) * 6 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> towns = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ind_ = 1 <NEWLINE> ts = [ ] <NEWLINE> visited = [ 0 ] * n <NEWLINE> loop_s = None <NEWLINE> while ( True ) : <NEWLINE> <INDENT> ind_ = towns [ ind_ - 1 ] <NEWLINE> if visited [ ind_ - 1 ] : <NEWLINE> <INDENT> loop_s = ts . index ( ind_ ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited [ ind_ - 1 ] = 1 <NEWLINE> ts . append ( ind_ ) <NEWLINE> <DEDENT> <DEDENT> if k <= len ( ts ) : <NEWLINE> <INDENT> print ( ts [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> init = len ( ts [ : loop_s ] ) <NEWLINE> loop_l = len ( ts ) - init <NEWLINE> loop = ts [ loop_s : ] <NEWLINE> print ( loop [ ( ( k - init ) % loop_l ) - 1 ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if ( i ** 5 ) - ( j ** 5 ) == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nux = A [ - 1 ] + 1 <NEWLINE> ans = 0 <NEWLINE> table = [ True ] * nux <NEWLINE> for i , s in enumerate ( A ) : <NEWLINE> <INDENT> if table [ s ] == False : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif A [ i + 1 ] != s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> b = 1 <NEWLINE> while b * s < nux : <NEWLINE> <INDENT> table [ b * s ] = False <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> def getCombList ( xList ) : <NEWLINE> <INDENT> N = len ( xList ) <NEWLINE> result = [ ] <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for conb in itertools . combinations ( xList , n ) : <NEWLINE> <INDENT> result . append ( list ( conb ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> L1 = input ( ) <NEWLINE> H , W , K = map ( int , L1 . split ( <STRING> ) ) <NEWLINE> mat = np . zeros ( [ H , W ] , dtype = <STRING> ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> Li = input ( ) <NEWLINE> for j , s in enumerate ( Li ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> mat [ i , j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if np . sum ( np . sum ( mat ) ) < K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if np . sum ( np . sum ( mat ) ) == K : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> matp = mat . copy ( ) <NEWLINE> HList = list ( range ( H ) ) <NEWLINE> WList = list ( range ( W ) ) <NEWLINE> HcombList = getCombList ( HList ) <NEWLINE> WcombList = getCombList ( WList ) <NEWLINE> for Hcomb in HcombList : <NEWLINE> <INDENT> for Wcomb in WcombList : <NEWLINE> <INDENT> matp [ Hcomb , : ] = 0 <NEWLINE> matp [ : , Wcomb ] = 0 <NEWLINE> if np . sum ( np . sum ( matp ) ) == K : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> matp = mat . copy ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for Hcomb in HcombList : <NEWLINE> <INDENT> matp [ Hcomb , : ] = 0 <NEWLINE> if np . sum ( np . sum ( matp ) ) == K : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> matp = mat . copy ( ) <NEWLINE> <NL> <DEDENT> for Wcomb in WcombList : <NEWLINE> <INDENT> matp [ : , Wcomb ] = 0 <NEWLINE> if np . sum ( np . sum ( matp ) ) == K : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> matp = mat . copy ( ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> X , N = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if X - i in P : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> if X + i in P : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if line . count ( 0 ) > 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> elif line . count ( 10 ** 18 ) > 0 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = line [ 0 ] <NEWLINE> for i in range ( len ( line ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a * line [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
s = input ( ) <NEWLINE> mod = 2019 <NEWLINE> dp = [ 0 ] * mod <NEWLINE> k = 0 <NEWLINE> t = 1 <NEWLINE> for x in map ( int , s [ : : - 1 ] ) : <NEWLINE> <INDENT> k += t * x <NEWLINE> k %= mod <NEWLINE> dp [ k ] += 1 <NEWLINE> t *= 10 <NEWLINE> t %= mod <NEWLINE> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in dp ) + dp [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> sums = [ 0 ] * N <NEWLINE> sums [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sums [ i + 1 ] = sums [ i ] + A [ i + 1 ] <COMMENT> <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += A [ i ] * ( sums [ N - 1 ] - sums [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sum % 1000000007 ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . side = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def roll ( self , direction ) : <NEWLINE> <INDENT> self . direction = direction <NEWLINE> if self . direction == <STRING> : <NEWLINE> <INDENT> w = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = w <NEWLINE> <DEDENT> elif self . direction == <STRING> : <NEWLINE> <INDENT> w = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = w <NEWLINE> <DEDENT> elif self . direction == <STRING> : <NEWLINE> <INDENT> w = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = w <NEWLINE> <DEDENT> elif self . direction == <STRING> : <NEWLINE> <INDENT> w = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = self . side [ <STRING> ] <NEWLINE> self . side [ <STRING> ] = w <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def position_relation ( self , top , front ) : <NEWLINE> <COMMENT> <NL> <INDENT> if top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> : <NEWLINE> <INDENT> self . right = self . side [ <STRING> ] <NEWLINE> <COMMENT> <NL> <DEDENT> if top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> : <NEWLINE> <INDENT> self . right = self . side [ <STRING> ] <NEWLINE> <COMMENT> <NL> <DEDENT> if top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> : <NEWLINE> <INDENT> self . right = self . side [ <STRING> ] <NEWLINE> <COMMENT> <NL> <DEDENT> if top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> : <NEWLINE> <INDENT> self . right = self . side [ <STRING> ] <NEWLINE> <COMMENT> <NL> <DEDENT> if top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> : <NEWLINE> <INDENT> self . right = self . side [ <STRING> ] <NEWLINE> <COMMENT> <NL> <DEDENT> if top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> or top == <STRING> and front == <STRING> : <NEWLINE> <INDENT> self . right = self . side [ <STRING> ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> dice = Dice ( ) <NEWLINE> for s , n in zip ( dice . side , input ( ) . split ( ) ) : <NEWLINE> <INDENT> dice . side [ s ] = int ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dice2 = Dice ( ) <NEWLINE> for s , n in zip ( dice2 . side , input ( ) . split ( ) ) : <NEWLINE> <INDENT> dice2 . side [ s ] = int ( n ) <NEWLINE> <NL> <DEDENT> import random <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> dice . roll ( random . choice ( [ <STRING> , <STRING> , <STRING> , <STRING> ] ) ) <NEWLINE> if dice . side == dice2 . side : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i , ans = 0 , 0 <NEWLINE> a = 1 <NEWLINE> while a : <NEWLINE> <INDENT> if x not in p : print ( x ) ; break <NEWLINE> for i in range ( max ( p ) + 2 ) : <NEWLINE> <INDENT> if x + i not in p : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> ans = x - i <NEWLINE> break <NEWLINE> <DEDENT> ans = x + i <NEWLINE> break <NEWLINE> <DEDENT> if x - i not in p : <NEWLINE> <INDENT> ans = x - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> a = 0 <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : return a <NEWLINE> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( input ( ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> T . append ( t ) <NEWLINE> if i == 0 : continue <NEWLINE> elif i == 1 : <NEWLINE> <INDENT> lcm = T [ - 2 ] * T [ - 1 ] // gcd ( T [ - 2 ] , T [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lcm = lcm * T [ - 1 ] // gcd ( lcm , T [ - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> def dfs ( v , p ) : <NEWLINE> <INDENT> for u in edge_extend [ p ] [ v ] : <NEWLINE> <INDENT> next_p = 0 if p == 2 else p + 1 <NEWLINE> if dist [ next_p ] [ u ] <= dist [ p ] [ v ] + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dist [ next_p ] [ u ] = dist [ p ] [ v ] + 1 <NEWLINE> dfs ( u , next_p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ u - 1 ] . append ( v - 1 ) <NEWLINE> <DEDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edge_extend = [ ] <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> edge_extend . append ( edge ) <NEWLINE> <NL> <DEDENT> dist = [ [ f_inf ] * n for _ in range ( 3 ) ] <NEWLINE> dist [ 0 ] [ s - 1 ] = 0 <NEWLINE> que = deque ( [ [ 0 , s - 1 ] ] ) <NEWLINE> while que : <NEWLINE> <INDENT> p , v = que . popleft ( ) <NEWLINE> next_p = 0 if p == 2 else p + 1 <NEWLINE> for u in edge_extend [ p ] [ v ] : <NEWLINE> <INDENT> if dist [ next_p ] [ u ] > dist [ p ] [ v ] + 1 : <NEWLINE> <INDENT> dist [ next_p ] [ u ] = dist [ p ] [ v ] + 1 <NEWLINE> que . append ( [ next_p , u ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dist [ 0 ] [ t - 1 ] // 3 if dist [ 0 ] [ t - 1 ] != f_inf else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , x , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> data = [ - 1 ] * ( m + 1 ) <NEWLINE> <NL> ans = x <NEWLINE> <NL> num = x <NEWLINE> data [ x ] = ( 1 , 0 ) <NEWLINE> count = 2 <NEWLINE> <NL> flag = 0 <NEWLINE> while ( count <= n ) : <NEWLINE> <COMMENT> <NL> <INDENT> num_new = ( num ** 2 ) % m <NEWLINE> if data [ num_new ] == - 1 or flag == 1 : <NEWLINE> <INDENT> data [ num_new ] = ( count , ans ) <NEWLINE> ans += num_new <NEWLINE> num = num_new <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = ans - data [ num_new ] [ 1 ] <NEWLINE> frec = count - data [ num_new ] [ 0 ] <NEWLINE> <NL> kaisuu = ( n - ( count - 1 ) ) // frec <NEWLINE> <NL> if kaisuu > 0 : <NEWLINE> <INDENT> count = count - 1 + frec * kaisuu <NEWLINE> ans += kaisuu * diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += num <NEWLINE> num = num_new <NEWLINE> <DEDENT> flag = 1 <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
import itertools <NEWLINE> n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z = y // 1000 <NEWLINE> <NL> list = list ( range ( n + 1 ) ) <NEWLINE> for a , b in itertools . product ( list , list ) : <NEWLINE> <INDENT> c = n - a - b <NEWLINE> if c >= 0 : <NEWLINE> <INDENT> v = 10 * a + 5 * b + c <NEWLINE> w = a + b + c <NEWLINE> if v == z and w == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = - 1 <NEWLINE> b = - 1 <NEWLINE> c = - 1 <NEWLINE> <NL> <DEDENT> print ( str ( a ) , str ( b ) , str ( c ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> e = a * c <NEWLINE> f = a * d <NEWLINE> g = b * c <NEWLINE> h = b * d <NEWLINE> <NL> list1 = [ e , f , g , h ] <NEWLINE> max = max ( list1 ) <NEWLINE> print ( max ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> for w in S : <NEWLINE> <INDENT> if w == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count > ans : <NEWLINE> <INDENT> ans = count <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
li = [ 1 , 2 , 3 ] <NEWLINE> li . pop ( li . index ( int ( input ( ) ) ) ) <NEWLINE> li . pop ( li . index ( int ( input ( ) ) ) ) <NEWLINE> print ( li [ 0 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from pdb import set_trace <NEWLINE> <COMMENT> <NL> import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> TRI = list ( itertools . combinations ( L , 3 ) ) <NEWLINE> for tri in TRI : <NEWLINE> <INDENT> a , b , c = tri <NEWLINE> if a == b or b == c or c == a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif a + b > c and a + c > b and b + c > a : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> t = list ( tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) ) <NEWLINE> <NL> H = [ 0 ] * h <NEWLINE> W = [ 0 ] * w <NEWLINE> for x , y in t : <NEWLINE> <INDENT> H [ x ] += 1 <NEWLINE> W [ y ] += 1 <NEWLINE> <DEDENT> H_max = max ( H ) <NEWLINE> W_max = max ( W ) <NEWLINE> <NL> H_index = [ x for x , i in enumerate ( H ) if i == H_max ] <NEWLINE> W_index = [ y for y , j in enumerate ( W ) if j == W_max ] <NEWLINE> <NL> ans = H_max + W_max <NEWLINE> <NL> t = set ( t ) <NEWLINE> for r in H_index : <NEWLINE> <INDENT> for c in W_index : <NEWLINE> <INDENT> if ( r , c ) not in t : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mlist = [ ] <NEWLINE> plist = [ 2 ] <NEWLINE> for i in range ( 3 , 10000 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for k in plist : <NEWLINE> <INDENT> if ( i % k != 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( count == len ( plist ) ) : <NEWLINE> <INDENT> plist . append ( i ) <NEWLINE> <DEDENT> <DEDENT> def check ( m ) : <NEWLINE> <INDENT> for p in plist : <NEWLINE> <INDENT> if ( m <= p ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if m % p == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if check ( m ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys , math <NEWLINE> <NL> def calcSum ( AList , B , C , Sum ) : <NEWLINE> <INDENT> Len = AList [ B ] <NEWLINE> if ( Len == 0 ) : <NEWLINE> <INDENT> return Sum <NEWLINE> <DEDENT> Sum += ( C - B ) * Len <NEWLINE> <NL> AList [ B ] = 0 <NEWLINE> AList [ C ] += Len <NEWLINE> return Sum <NEWLINE> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> Max = int ( 10 ** 5 ) + 1 <NEWLINE> AList = [ 0 ] * Max <NEWLINE> A_str = input ( ) . strip ( ) . split ( ) <NEWLINE> N_Queries = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> value = int ( A_str [ i ] ) <NEWLINE> AList [ value ] += 1 <NEWLINE> sum += value <NEWLINE> <DEDENT> BCs = [ ] <NEWLINE> Sums = [ sum ] <NEWLINE> for i in range ( N_Queries ) : <NEWLINE> <INDENT> BC_str = input ( ) . strip ( ) . split ( ) <NEWLINE> B = int ( BC_str [ 0 ] ) <NEWLINE> C = int ( BC_str [ 1 ] ) <NEWLINE> Sums . append ( calcSum ( AList , B , C , Sums [ - 1 ] ) ) <NEWLINE> <STRING> <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 1 + N_Queries ) : <NEWLINE> <INDENT> print ( Sums [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> cur_min = int ( input ( ) ) <NEWLINE> max_diff = - 1 * ( 10 ** 9 ) - 1 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> <NL> max_diff = max ( max_diff , num - cur_min ) <NEWLINE> <NL> if num < cur_min : <NEWLINE> <INDENT> cur_min = num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_diff ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) [ : : - 1 ] <NEWLINE> ary_mod = [ 0 ] * 2019 <NEWLINE> ary_mod [ 0 ] = 1 <NEWLINE> now = 0 <NEWLINE> digit = 1 <NEWLINE> for i , ss in enumerate ( s ) : <NEWLINE> <INDENT> now += int ( ss ) * digit % 2019 <NEWLINE> digit *= 10 <NEWLINE> digit %= 2019 <NEWLINE> remind = now % 2019 <NEWLINE> ary_mod [ remind ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , n in enumerate ( ary_mod ) : <NEWLINE> <INDENT> ans += ( n * ( n - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in itertools . product ( range ( K + 1 ) , repeat = 2 ) : <NEWLINE> <INDENT> Z = S - sum ( i ) <NEWLINE> if 0 <= Z <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
<COMMENT> <NL> import itertools <NEWLINE> n , m , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> ans = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for A in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> new_ans = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> new_ans += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , new_ans ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> u = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> u . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> z = Counter ( a ) <NEWLINE> <NL> sum = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> rev = z . pop ( u [ i ] [ 0 ] ) <NEWLINE> sum += ( u [ i ] [ 1 ] - u [ i ] [ 0 ] ) * rev <NEWLINE> print ( sum ) <NEWLINE> if u [ i ] [ 1 ] in z : <NEWLINE> <INDENT> z [ u [ i ] [ 1 ] ] += rev <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z [ u [ i ] [ 1 ] ] = rev <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif k % 7 == 0 : <NEWLINE> <INDENT> l = 9 * k // 7 <NEWLINE> form = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if form * 10 % l == 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> form = form * 10 % l <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = 9 * k <NEWLINE> form = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if form * 10 % l == 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> form = form * 10 % l <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import atan , degrees <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == a * b * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x / a ** 2 <NEWLINE> if x >= b / 2 : <NEWLINE> <INDENT> print ( 90 - degrees ( atan ( a / ( 2 * b - 2 * x ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 90 - degrees ( atan ( 2 * a * x / b ** 2 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A_list = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A_list : <NEWLINE> <INDENT> out = 0 <NEWLINE> print ( out ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A_list [ i ] <NEWLINE> <NL> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> out = ans <NEWLINE> print ( out ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> dst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> log = [ 1 ] <NEWLINE> log_set = set ( log ) <NEWLINE> current = 1 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> current = dst [ current - 1 ] <NEWLINE> if current in log_set : <NEWLINE> <INDENT> loop_start_ind = log . index ( current ) <NEWLINE> loop_len = i - loop_start_ind <NEWLINE> current = log [ loop_start_ind + ( K - i ) % loop_len ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log . append ( current ) <NEWLINE> log_set . add ( current ) <NEWLINE> <DEDENT> <DEDENT> print ( current ) <NEWLINE>
def merge_jibun ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> inf = 10 ** 9 <NEWLINE> L = A [ left : mid ] + [ inf ] <NEWLINE> R = A [ mid : right ] + [ inf ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge_jibun ( A , left , mid , right ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> <NL> print ( <STRING> . join ( list ( map ( str , A ) ) ) ) <NEWLINE> print ( count ) <NEWLINE>
words = input ( ) <NEWLINE> _words = <STRING> <NEWLINE> for case in words : <NEWLINE> <INDENT> if case != case . upper ( ) : <NEWLINE> <INDENT> case = case . upper ( ) <NEWLINE> <DEDENT> elif case != case . lower ( ) : <NEWLINE> <INDENT> case = case . lower ( ) <NEWLINE> <DEDENT> _words += case <NEWLINE> <DEDENT> print ( _words ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if X [ 0 ] >= 0 : <NEWLINE> <INDENT> print ( X [ k - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif X [ - 1 ] < 0 : <NEWLINE> <INDENT> print ( abs ( X [ n - k ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] >= 0 : <NEWLINE> <INDENT> ori = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = f_inf <NEWLINE> left = max ( ori - k , 0 ) <NEWLINE> right = min ( ori + k , n ) <NEWLINE> for i in range ( left , right - k + 1 ) : <NEWLINE> <INDENT> RL = abs ( X [ i + k - 1 ] - X [ i ] ) + abs ( X [ i + k - 1 ] ) <NEWLINE> LR = abs ( X [ i ] ) + abs ( X [ i + k - 1 ] - X [ i ] ) <NEWLINE> res = min ( res , min ( RL , LR ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> reverse_v = v [ : : - 1 ] <NEWLINE> lst = [ 0 ] * ( k + 1 ) <NEWLINE> left = [ [ ] ] <NEWLINE> right = [ [ ] ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> left . append ( v [ : i ] ) <NEWLINE> right . append ( reverse_v [ : i ] ) <NEWLINE> <NL> <DEDENT> for cnt in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> rest = k - cnt <NEWLINE> total = 0 <NEWLINE> if cnt <= n : <NEWLINE> <INDENT> for j in range ( cnt + 1 ) : <NEWLINE> <INDENT> lst_j = left [ j ] + right [ cnt - j ] <NEWLINE> lst_j . sort ( ) <NEWLINE> l = cnt <NEWLINE> for idx in range ( cnt ) : <NEWLINE> <INDENT> if lst_j [ idx ] >= 0 : <NEWLINE> <INDENT> l = idx <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if l == cnt : <NEWLINE> <INDENT> value = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = min ( l , rest ) <NEWLINE> value = sum ( lst_j [ flg : ] ) <NEWLINE> <DEDENT> if value > total : <NEWLINE> <INDENT> total = value <NEWLINE> <DEDENT> <DEDENT> lst [ cnt ] = total <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( lst ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> u , count = np . unique ( A , return_counts = True ) <NEWLINE> L = np . zeros ( 10 ** 5 , int ) <NEWLINE> for i in range ( len ( u ) ) : <NEWLINE> <INDENT> L [ u [ i ] - 1 ] = count [ i ] <NEWLINE> <DEDENT> asum = A . sum ( ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> asum += L [ B - 1 ] * ( C - B ) <NEWLINE> L [ C - 1 ] += L [ B - 1 ] <NEWLINE> L [ B - 1 ] = 0 <NEWLINE> print ( asum ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . root ( self . parents [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . root ( x ) , self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> <NL> u = UnionFind ( n ) <NEWLINE> f = [ set ( ) for _ in range ( n ) ] <NEWLINE> l = [ set ( ) for _ in range ( n ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> f [ a ] . add ( b ) <NEWLINE> f [ b ] . add ( a ) <NEWLINE> u . unite ( a , b ) <NEWLINE> <DEDENT> for c , d in cd : <NEWLINE> <INDENT> c , d = c - 1 , d - 1 <NEWLINE> l [ c ] . add ( d ) <NEWLINE> l [ d ] . add ( c ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r = u . root ( i ) <NEWLINE> bl = 0 <NEWLINE> for j in l [ i ] : <NEWLINE> <INDENT> if u . root ( j ) == r : <NEWLINE> <INDENT> bl += 1 <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = - u . parents [ r ] - len ( f [ i ] ) - bl - 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( list ( map ( str , ans ) ) ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ i for i in range ( 1 , N + 1 ) if i % 2 != 0 ] <NEWLINE> ans = 0 <NEWLINE> if N < 105 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> for num in L : <NEWLINE> <INDENT> counter = 1 <NEWLINE> for i in range ( 1 , num // 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> if counter == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> list_a = [ i for i in range ( 1 , a + 1 ) ] <NEWLINE> res = 0 <NEWLINE> <COMMENT> <NL> kumi = list ( itertools . combinations_with_replacement ( list_a , 3 ) ) <NEWLINE> for i in kumi : <NEWLINE> <INDENT> ans = gcd_list ( i ) <NEWLINE> if i [ 0 ] == i [ 1 ] and i [ 0 ] == i [ 2 ] : <NEWLINE> <INDENT> res += ans <NEWLINE> <DEDENT> elif i [ 0 ] != i [ 1 ] and i [ 0 ] != i [ 2 ] and i [ 2 ] != i [ 1 ] : <NEWLINE> <INDENT> res += ans * 6 <NEWLINE> <DEDENT> elif i [ 0 ] == i [ 1 ] or i [ 0 ] == i [ 2 ] or i [ 1 ] == i [ 2 ] : <NEWLINE> <INDENT> res += ans * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * b * g <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for g in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] != s [ g ] and 2 * g - i < n : <NEWLINE> <INDENT> if s [ 2 * g - i ] != s [ i ] and s [ 2 * g - i ] != s [ g ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = np . zeros ( n , dtype = np . int64 ) <NEWLINE> a = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = ord ( a [ i ] ) % 3 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> d = np . zeros ( ( 3 , n ) , dtype = np . int64 ) <NEWLINE> m = np . zeros ( ( 3 , n ) , dtype = np . int64 ) <NEWLINE> l = np . array ( [ [ 0 , 2 , 1 ] , [ 2 , 1 , 0 ] , [ 1 , 0 , 2 ] ] ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d [ s [ i ] , i ] = 1 <NEWLINE> m [ s [ i ] , i ] = 1 <NEWLINE> <NL> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> m [ j , i - 1 ] += m [ j , i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( f ( n , s , m , d , l ) ) <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def f ( n , s , m , d , l ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += m [ l [ s [ i ] ] [ s [ j ] ] , j + 1 ] <NEWLINE> if ( j * 2 - i ) < n : <NEWLINE> <INDENT> ans -= d [ l [ s [ i ] ] [ s [ j ] ] , j * 2 - i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> rN = int ( np . sqrt ( N ) ) <NEWLINE> <NL> A = np . zeros ( N ) <NEWLINE> <NL> <NL> <NL> for i in range ( rN ) : <NEWLINE> <INDENT> for j in range ( rN ) : <NEWLINE> <INDENT> for k in range ( rN ) : <NEWLINE> <INDENT> x = i + 1 <NEWLINE> y = j + 1 <NEWLINE> z = k + 1 <NEWLINE> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if N < n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ n - 1 ] += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( int ( a ) ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> m = list ( <STRING> ) [ : : - 1 ] <NEWLINE> <NL> if len ( S ) < 26 : <NEWLINE> <INDENT> for i in m [ : : - 1 ] : <NEWLINE> <INDENT> if i not in S : <NEWLINE> <INDENT> S . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = S [ - 1 ] <NEWLINE> for i in range ( 25 ) [ : : - 1 ] : <NEWLINE> <INDENT> if x > S [ i ] : <NEWLINE> <INDENT> y = m . index ( S [ i ] ) <NEWLINE> S = S [ : i ] <NEWLINE> for j in range ( y ) [ : : - 1 ] : <NEWLINE> <INDENT> if m [ j ] not in S : <NEWLINE> <INDENT> S . append ( m [ j ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = S [ i ] <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> j_n = m <NEWLINE> ans = 0 <NEWLINE> <NL> for i_n in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i_n ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while b [ j_n ] > k - a [ i_n ] : <NEWLINE> <INDENT> j_n -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i_n + j_n ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // x <NEWLINE> ans += n * ( 2 * x + ( n - 1 ) * x ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> d = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d += [ int ( input ( ) ) ] <NEWLINE> a += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> A = [ - 1 ] * ( M + 100 ) <NEWLINE> A [ 0 ] = X <NEWLINE> i = 0 <NEWLINE> tmpans = 0 <NEWLINE> flag = False <NEWLINE> check = [ - 1 ] * ( M + 1 ) <NEWLINE> slice = - 1 <NEWLINE> while i < N - 1 : <NEWLINE> <INDENT> newa = A [ i ] ** 2 % M <NEWLINE> i += 1 <NEWLINE> if check [ newa ] != - 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> slice = check [ newa ] <NEWLINE> break <NEWLINE> <DEDENT> A [ i ] = newa <NEWLINE> check [ newa ] = i <NEWLINE> <NL> <DEDENT> if not flag : <NEWLINE> <INDENT> print ( sum ( A [ : i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( A [ : slice ] ) + sum ( A [ slice : i ] ) * ( ( N - slice ) // ( i - slice ) ) + sum ( A [ slice : slice + ( N - slice ) % ( i - slice ) ] ) ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P_ori = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if P_ori . count ( X ) == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> P1 = sorted ( P_ori ) <NEWLINE> N = list ( range ( 0 , 102 ) ) <NEWLINE> PZ = [ ] <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if P1 . count ( N [ i ] ) == 0 : <NEWLINE> <INDENT> PZ . append ( N [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> PZ . append ( X ) <NEWLINE> P2 = sorted ( PZ ) <NEWLINE> t = P2 . index ( X ) <NEWLINE> if P2 [ t ] == P2 [ 0 ] : <NEWLINE> <INDENT> print ( P2 [ 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif P2 [ t ] == P2 [ - 1 ] : <NEWLINE> <INDENT> print ( P2 [ - 2 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dist1 = abs ( P2 [ t - 1 ] - P2 [ t ] ) <NEWLINE> dist2 = abs ( P2 [ t ] - P2 [ t + 1 ] ) <NEWLINE> if dist1 <= dist2 : <NEWLINE> <INDENT> print ( P2 [ t - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( P2 [ t + 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> SELECT = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> SELECT . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> M = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> q = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> td , tq = map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( td - 1 ) <NEWLINE> q . append ( tq - 1 ) <NEWLINE> <NL> <DEDENT> L_ALL = [ [ 0 ] * 26 for _ in range ( D ) ] <NEWLINE> L = [ 0 ] * 26 <NEWLINE> ans = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> ans += S [ i ] [ SELECT [ i ] ] <NEWLINE> L [ SELECT [ i ] ] = i + 1 <NEWLINE> if i != 0 : <NEWLINE> <INDENT> L_ALL [ i ] = L_ALL [ i - 1 ] [ : ] <NEWLINE> <DEDENT> L_ALL [ i ] [ SELECT [ i ] ] = i + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> ans -= C [ j ] * ( i + 1 - L [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> day = d [ i ] <NEWLINE> before = SELECT [ day ] <NEWLINE> after = q [ i ] <NEWLINE> ans -= S [ day ] [ before ] <NEWLINE> ans += S [ day ] [ after ] <NEWLINE> SELECT [ day ] = q [ i ] <NEWLINE> <NL> if day == 0 : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = L_ALL [ day - 1 ] [ before ] <NEWLINE> <DEDENT> j = day <NEWLINE> while 0 <= j < D and L_ALL [ j ] [ before ] == day + 1 : <NEWLINE> <INDENT> L_ALL [ j ] [ before ] = tmp <NEWLINE> ans -= C [ before ] * ( day + 1 - tmp ) <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> if day == 0 : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = L_ALL [ day - 1 ] [ after ] <NEWLINE> <DEDENT> j = day <NEWLINE> while 0 <= j < D and L_ALL [ j ] [ after ] == tmp : <NEWLINE> <INDENT> L_ALL [ j ] [ after ] = day + 1 <NEWLINE> ans += C [ after ] * ( day + 1 - tmp ) <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> cand = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for d in range ( 1 , ( N - i + 1 ) // 2 ) : <NEWLINE> <INDENT> if S [ i : i + 2 * d + 1 : d ] in cand : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def isPrime ( num ) : <NEWLINE> <INDENT> if num < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif num % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( num ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_2017 ( num ) : <NEWLINE> <INDENT> temp = ( num + 1 ) // 2 <NEWLINE> if isPrime ( num ) and isPrime ( temp ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> is_2017_list = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> if is_2017 ( i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> is_2017_list [ i ] = count <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> is_2017_list [ i ] = count <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> ans_list = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = is_2017_list [ r ] - is_2017_list [ l - 1 ] <NEWLINE> ans_list . append ( ans ) <NEWLINE> <NL> <DEDENT> for ans in ans_list : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , m = input ( ) . split ( ) <NEWLINE> if x [ 0 ] == <STRING> : a [ m ] = 0 <NEWLINE> else : <NEWLINE> <INDENT> if m in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> for _ in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> * ( W - 2 ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = N // ( A + B ) <NEWLINE> p = N % ( A + B ) <NEWLINE> if p // A == 0 : <NEWLINE> <INDENT> ans = s * A + p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = s * A + A <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] <NEWLINE> c = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( a [ ans [ i ] - 1 ] ) <NEWLINE> <DEDENT> b = ans . index ( ans [ n ] ) <NEWLINE> if k < b : <NEWLINE> <INDENT> for l in range ( k ) : <NEWLINE> <INDENT> c = a [ c - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for l in range ( ( k - b ) % ( n - b ) + b ) : <NEWLINE> <INDENT> c = a [ c - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> clst = list ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> k = - 1 <NEWLINE> <NL> if <STRING> not in clst or <STRING> not in clst : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> rnum = [ i for i , c in enumerate ( clst ) if c == <STRING> ] <NEWLINE> wnum = [ j for j , c in enumerate ( clst ) if c == <STRING> ] [ : : - 1 ] <NEWLINE> <NL> t = min ( len ( rnum ) , len ( wnum ) ) <NEWLINE> <NL> for i in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> if rnum [ - i ] > wnum [ - i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if ( X + Y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = int ( ( 2 * Y - X ) / 3 ) <NEWLINE> M = int ( ( 2 * X - Y ) / 3 ) <NEWLINE> if N < 0 or M < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if N == 0 or M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if N > 0 and M > 0 : <NEWLINE> <INDENT> List = [ 0 for i in range ( N + M ) ] <NEWLINE> List [ 0 ] = 1 <NEWLINE> for i in range ( N + M - 1 ) : <NEWLINE> <INDENT> List [ i + 1 ] = List [ i ] * ( i + 2 ) % mod <NEWLINE> <DEDENT> print ( List [ N + M - 1 ] * pow ( List [ N - 1 ] , mod - 2 , mod ) * pow ( List [ M - 1 ] , mod - 2 , mod ) % mod ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> <NL> N = int ( stdin . readline ( ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> if ans : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> MOD = 1000000007 <NEWLINE> d = defaultdict ( int ) <NEWLINE> num_00 = 0 <NEWLINE> pow2 = [ 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pow2 . append ( ( pow2 [ - 1 ] * 2 ) % MOD ) <NEWLINE> <NL> <DEDENT> def to_idx ( a , b ) : <NEWLINE> <INDENT> if a == 0 and b != 0 : <NEWLINE> <INDENT> return ( ( 0 , - 1 ) , ( 0 , 1 ) ) <NEWLINE> <DEDENT> elif a != 0 and b == 0 : <NEWLINE> <INDENT> return ( ( - 1 , 0 ) , ( 1 , 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return tuple ( sorted ( ( ( a , b ) , ( - a , - b ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b == 0 and a != b : <NEWLINE> <INDENT> d [ to_idx ( a , b ) ] += 1 <NEWLINE> <DEDENT> elif a == b == 0 : <NEWLINE> <INDENT> num_00 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> a //= g ; b //= g <NEWLINE> d [ to_idx ( a , b ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> memo = [ ] <NEWLINE> key_set = set ( d . keys ( ) ) <NEWLINE> while key_set : <NEWLINE> <INDENT> k = key_set . pop ( ) <NEWLINE> v1 , v2 = k <NEWLINE> a , b = v1 <NEWLINE> idx = to_idx ( - b , a ) <NEWLINE> memo . append ( ( pow2 [ d [ k ] ] + pow2 [ d [ idx ] ] - 1 ) % MOD ) <NEWLINE> key_set . discard ( idx ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for m in memo : <NEWLINE> <INDENT> ans *= m <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ( ans - 1 + num_00 ) % MOD ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> print ( <STRING> if a [ i - k ] < a [ i ] else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import heapq <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> heapq . heapify ( A ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , - ( - tmp // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( A ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> adj [ s [ 0 ] ] . append ( s [ 1 ] ) <NEWLINE> adj [ s [ 1 ] ] . append ( s [ 0 ] ) <NEWLINE> <NL> <DEDENT> cc = [ - 1 for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cc [ i ] < 0 : <NEWLINE> <INDENT> cc [ i ] = cnt <NEWLINE> stack = [ i ] <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if cc [ u ] < 0 : <NEWLINE> <INDENT> cc [ u ] = cnt <NEWLINE> stack . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if cc [ s ] == cc [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n = k ( ) <NEWLINE> a = l ( ) <NEWLINE> q = k ( ) <NEWLINE> count = [ 0 ] * 100001 <NEWLINE> ans = [ ] <NEWLINE> an = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> count [ x - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = I ( ) <NEWLINE> an += ( c - b ) * count [ b - 1 ] <NEWLINE> count [ c - 1 ] += count [ b - 1 ] <NEWLINE> count [ b - 1 ] = 0 <NEWLINE> ans . append ( an ) <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> E = 0 <NEWLINE> <NL> n_ = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> n_ = ( n_ * i ) % MOD <NEWLINE> <NL> <DEDENT> nr_ = 1 <NEWLINE> nr_array = [ ] <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> nr_ = ( nr_ * i ) % MOD <NEWLINE> nr_array . append ( nr_ ) <NEWLINE> <DEDENT> m = 1 <NEWLINE> Mk_array = [ 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> m = ( m * ( M - 1 ) ) % MOD <NEWLINE> Mk_array . append ( m ) <NEWLINE> <DEDENT> r_ = 1 <NEWLINE> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if i != 0 and i != N - 1 : <NEWLINE> <INDENT> r_ = ( r_ * i ) % MOD <NEWLINE> nr_ = nr_array . pop ( ) <NEWLINE> power_r = pow ( r_ , MOD - 2 , MOD ) <NEWLINE> power_nr = pow ( nr_ , MOD - 2 , MOD ) <NEWLINE> <DEDENT> Mk = Mk_array . pop ( ) <NEWLINE> <NL> if i != 0 and i != N - 1 : <NEWLINE> <INDENT> E += ( n_ * power_r * power_nr * Mk ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> E += Mk % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> res = ( M * E ) % MOD <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> m = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i in m . keys ( ) : <NEWLINE> <INDENT> m [ i ] = m [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in m : <NEWLINE> <INDENT> ans += m [ k ] * k <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in m . keys ( ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> if c in m . keys ( ) : <NEWLINE> <INDENT> t = m [ c ] * c <NEWLINE> m [ c ] = m [ c ] + m [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ c ] = m [ b ] <NEWLINE> <DEDENT> ans += m [ c ] * c - m [ b ] * b - t <NEWLINE> m . pop ( b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
mod = 2019 <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> w = 0 <NEWLINE> d = [ 0 ] * mod <NEWLINE> p = 1 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> w += int ( s [ i ] ) * p <NEWLINE> p *= 10 <NEWLINE> p %= mod <NEWLINE> w %= mod <NEWLINE> d [ w ] += 1 <NEWLINE> <DEDENT> d [ 0 ] += 1 <NEWLINE> o = 0 <NEWLINE> for x in d : <NEWLINE> <INDENT> o += x * ( x - 1 ) // 2 <NEWLINE> <DEDENT> print ( o ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> S *= A [ i ] <NEWLINE> if S > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cumprod = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cumprod *= a [ i ] <NEWLINE> if cumprod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( cumprod ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r ** 2 * pi , r * 2 * pi ) ) <NEWLINE>
import itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( itertools . accumulate ( a ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in reversed ( range ( 1 , n ) ) : <NEWLINE> <INDENT> if b [ i - 1 ] * 2 < a [ i ] : <NEWLINE> <INDENT> return n - i <NEWLINE> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import itertools as it <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> li = list ( it . combinations ( A , i + 1 ) ) <NEWLINE> for j in range ( len ( li ) ) : <NEWLINE> <INDENT> s . add ( sum ( li [ j ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( q ) : <NEWLINE> <INDENT> print ( <STRING> if m [ k ] in s else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import heapq <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for pull in range ( K + 1 ) : <NEWLINE> <INDENT> push = K - pull <NEWLINE> if push < 0 or push > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for left_push in range ( push + 1 ) : <NEWLINE> <INDENT> tmp_que = deque ( V ) <NEWLINE> tmp_heap = [ ] <NEWLINE> heapq . heapify ( tmp_heap ) <NEWLINE> right_push = push - left_push <NEWLINE> for _ in range ( left_push ) : <NEWLINE> <INDENT> heapq . heappush ( tmp_heap , tmp_que . popleft ( ) ) <NEWLINE> <DEDENT> for _ in range ( right_push ) : <NEWLINE> <INDENT> heapq . heappush ( tmp_heap , tmp_que . pop ( ) ) <NEWLINE> <NL> <DEDENT> tmp_res = sum ( tmp_que ) <NEWLINE> for i in range ( min ( push , pull ) ) : <NEWLINE> <INDENT> x = heapq . heappop ( tmp_heap ) <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> heapq . heappush ( tmp_heap , x ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> res = max ( res , sum ( tmp_heap ) ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = T [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans * T [ i ] // math . gcd ( ans , T [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
k = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = X + 10 <NEWLINE> tmp = [ ] <NEWLINE> P2 = [ int ( i ) for i in range ( - 200 , 200 ) ] <NEWLINE> P3 = list ( set ( P2 ) - set ( P ) ) <NEWLINE> P3 . sort ( ) <NEWLINE> P3 [ : : - 1 ] <NEWLINE> for i in P3 : <NEWLINE> <INDENT> if ans > abs ( X - i ) : <NEWLINE> <INDENT> ans = abs ( X - i ) <NEWLINE> tmp . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( tmp ) ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , M , Q , * abcd = map ( int , read ( ) . split ( ) ) <NEWLINE> cand = [ [ 0 , 1 ] ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> new_cand = [ ] <NEWLINE> for j in cand : <NEWLINE> <INDENT> for k in range ( j [ - 1 ] , M + 1 ) : <NEWLINE> <INDENT> new_cand . append ( j [ : ] + [ k ] ) <NEWLINE> <DEDENT> <DEDENT> cand = new_cand [ : ] <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> abcd = tuple ( zip ( * [ iter ( abcd ) ] * 4 ) ) <NEWLINE> for seq in cand : <NEWLINE> <INDENT> t = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if seq [ b ] - seq [ a ] == c : <NEWLINE> <INDENT> t += d <NEWLINE> <DEDENT> <DEDENT> answer = max ( answer , t ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> num = L [ i ] + L [ j ] <NEWLINE> third = bisect . bisect_left ( L , num ) <NEWLINE> if third > j : <NEWLINE> <INDENT> cnt += third - j - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_even = a [ 0 : : 2 ] <NEWLINE> a_odd = a [ 1 : : 2 ] <NEWLINE> <NL> <COMMENT> <NL> if ( n - 1 ) % 2 == 0 : <COMMENT> <NEWLINE> <INDENT> b = a_even . copy ( ) <NEWLINE> b . reverse ( ) <NEWLINE> b = b + a_odd <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> b = a_odd . copy ( ) <NEWLINE> b . reverse ( ) <NEWLINE> b = b + a_even <NEWLINE> <NL> <DEDENT> b = list ( map ( str , b ) ) <NEWLINE> print ( <STRING> . join ( b ) ) <NEWLINE>
first_set_count = int ( input ( ) ) ; <NEWLINE> first_set = [ int ( n ) for n in input ( ) . split ( ) ] ; <NEWLINE> second_set_count = int ( input ( ) ) ; <NEWLINE> second_set = [ int ( n ) for n in input ( ) . split ( ) ] ; <NEWLINE> <NL> def binary_search ( num , s , start , end ) : <NEWLINE> <INDENT> while start < end : <NEWLINE> <INDENT> mid = ( end + start ) // 2 ; <NEWLINE> if num == s [ mid ] : <NEWLINE> <INDENT> return True ; <NEWLINE> <DEDENT> elif num > s [ mid ] : <NEWLINE> <INDENT> start = mid + 1 ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end = mid ; <NEWLINE> <DEDENT> <DEDENT> return False ; <NEWLINE> <NL> <DEDENT> count = 0 ; <NEWLINE> for num in second_set : <NEWLINE> <INDENT> if binary_search ( num , first_set , 0 , len ( first_set ) ) : <NEWLINE> <INDENT> count += 1 ; <NEWLINE> <DEDENT> <DEDENT> print ( count ) ; <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> def popcnt ( x ) : <NEWLINE> <INDENT> n = x <NEWLINE> res = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> res += n % 2 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> table = [ 0 , 1 ] + [ - 1 for i in range ( 219998 ) ] <NEWLINE> for i in range ( 2 , 220000 ) : <NEWLINE> <INDENT> table [ i ] = table [ i % popcnt ( i ) ] + 1 <NEWLINE> <NL> <DEDENT> moto = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> moto += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> plus = 0 <COMMENT> <NEWLINE> minus = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> plus += int ( X [ i ] ) * pow ( 2 , N - 1 - i , max ( 1 , moto - 1 ) ) <NEWLINE> minus += int ( X [ i ] ) * pow ( 2 , N - 1 - i , moto + 1 ) <NEWLINE> plus %= ( max ( 1 , moto - 1 ) ) <NEWLINE> minus %= ( moto + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans = plus <NEWLINE> ans -= pow ( 2 , N - 1 - i , max ( 1 , moto - 1 ) ) <NEWLINE> ans %= ( max ( 1 , moto - 1 ) ) <NEWLINE> if moto == 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = minus <NEWLINE> ans += pow ( 2 , N - 1 - i , moto + 1 ) <NEWLINE> ans %= ( moto + 1 ) <NEWLINE> <DEDENT> if ans == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( table [ ans ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
from math import floor <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return floor ( a * x / b ) - a * floor ( x / b ) <NEWLINE> <DEDENT> print ( f ( min ( n , b - 1 ) ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> if s == [ s [ 0 ] ] * n : <NEWLINE> <INDENT> print ( n * k // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ss = s * 2 <NEWLINE> ans1 = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> ans1 += 1 <NEWLINE> <DEDENT> <DEDENT> ans2 = 0 <NEWLINE> for i in range ( 1 , 2 * n ) : <NEWLINE> <INDENT> if ss [ i ] == ss [ i - 1 ] : <NEWLINE> <INDENT> ss [ i ] = <STRING> <NEWLINE> ans2 += 1 <NEWLINE> <DEDENT> <DEDENT> j = ans2 - ans1 <NEWLINE> print ( ans1 + j * ( k - 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> march = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> prefix = [ ] <NEWLINE> d = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> pre = input ( ) [ 0 ] <NEWLINE> if pre in march : <NEWLINE> <INDENT> if pre not in prefix : <NEWLINE> <INDENT> prefix . append ( pre ) <NEWLINE> d [ pre ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ pre ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t = len ( prefix ) <NEWLINE> if t < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( t - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , t - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , t ) : <NEWLINE> <INDENT> ans += d [ prefix [ i ] ] * d [ prefix [ j ] ] * d [ prefix [ k ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> W = ( C . count ( <STRING> ) ) <NEWLINE> R = N - W <NEWLINE> WW = 0 <NEWLINE> RR = 0 <NEWLINE> X = [ 0 ] * ( N - 1 ) <NEWLINE> if W > 0 and R > 0 : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> WW += 1 <NEWLINE> <DEDENT> RR = ( N - i - 1 ) - ( W - WW ) <NEWLINE> X [ i ] = max ( WW , RR ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( X ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A_1 = collections . Counter ( A ) <NEWLINE> i = 0 <NEWLINE> if 2 <= N <= 2 * 10 ** 5 : <NEWLINE> <INDENT> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> if 0 <= i <= N - 2 : <NEWLINE> <INDENT> if 1 <= A [ i ] < i + 2 : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> print ( A_1 [ j ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def prime ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> a = prime ( N ) <NEWLINE> a . sort ( ) <NEWLINE> import copy <NEWLINE> b = copy . copy ( a ) <NEWLINE> b = list ( set ( b ) ) <NEWLINE> b . sort ( ) <NEWLINE> <NL> ret = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> idx += 1 <NEWLINE> cnt = cnt + idx <NEWLINE> if a . count ( i ) >= cnt : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = list ( map ( str , input ( ) ) ) <NEWLINE> if len ( s ) > k : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = set ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] ) <NEWLINE> x = [ [ ] for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> for t in l : <NEWLINE> <INDENT> x [ t [ 0 ] - 1 ] . append ( h [ t [ 1 ] - 1 ] ) <NEWLINE> x [ t [ 1 ] - 1 ] . append ( h [ t [ 0 ] - 1 ] ) <NEWLINE> <DEDENT> for k , li in enumerate ( x ) : <NEWLINE> <INDENT> a = h [ k ] <NEWLINE> if li == [ ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > max ( li ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> seat = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> seat [ l - 1 ] += 1 <NEWLINE> seat [ r ] -= 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> seat [ i ] += seat [ i - 1 ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> if seat [ i ] == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> from math import sqrt <NEWLINE> <NL> <NL> def rec ( state , v ) : <NEWLINE> <INDENT> if state == ( 1 << N ) - 1 : <NEWLINE> <INDENT> return cakes [ v ] <NEWLINE> <DEDENT> if dp [ state ] [ v ] != - 1 : <NEWLINE> <INDENT> return dp [ state ] [ v ] <NEWLINE> <NL> <DEDENT> ret = INF <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if state == 0 : <NEWLINE> <INDENT> ret = min ( ret , rec ( 1 << i , i ) + cakes [ i ] ) <NEWLINE> <DEDENT> elif not ( state >> i & 1 ) : <NEWLINE> <INDENT> ret = min ( ret , rec ( state | 1 << i , i ) + sqrt ( pow ( cakes [ i ] + cakes [ v ] , 2 ) - pow ( cakes [ i ] - cakes [ v ] , 2 ) ) ) <NEWLINE> <DEDENT> <DEDENT> dp [ state ] [ v ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> testcases = [ [ int ( x ) for x in line . split ( ) ] for line in sys . stdin . readlines ( ) ] <NEWLINE> <NL> for testcase in testcases : <NEWLINE> <INDENT> box , * cakes = testcase <NEWLINE> N = len ( cakes ) <NEWLINE> INF = box + 1 <NEWLINE> dp = [ [ - 1 ] * N for _ in range ( 1 << N ) ] <NEWLINE> print ( <STRING> if rec ( 0 , 0 ) <= box else <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for i in lis : <NEWLINE> <INDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res *= i <NEWLINE> <DEDENT> <DEDENT> print ( res if res <= 10 ** 18 else - 1 ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce , lru_cache <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def TUPLE ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = MAP ( ) <NEWLINE> xy = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> ans = INF <NEWLINE> <NL> xy . sort ( ) <NEWLINE> for l in range ( N - K + 1 ) : <COMMENT> <NEWLINE> <INDENT> for r in range ( l + K , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> y = sorted ( xy [ l : r ] , key = lambda x : x [ 1 ] ) <COMMENT> <NEWLINE> for i in range ( r - l - K + 1 ) : <NEWLINE> <INDENT> sq = ( xy [ r - 1 ] [ 0 ] - xy [ l ] [ 0 ] ) * ( y [ i + K - 1 ] [ 1 ] - y [ i ] [ 1 ] ) <NEWLINE> ans = min ( ans , sq ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> from math import * <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * r * pi ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> cnt = l [ k - 1 ] <NEWLINE> p = 1 <NEWLINE> g = 0 <NEWLINE> g = g + 1 <NEWLINE> pr = l [ g - 1 ] <NEWLINE> while ( k < n ) : <NEWLINE> <INDENT> if l [ k ] > pr : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> g = g + 1 <NEWLINE> pr = l [ g - 1 ] <NEWLINE> k = k + 1 <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> div = make_divisors ( N ) <NEWLINE> ans = 100 <NEWLINE> <NL> for d in div : <NEWLINE> <INDENT> a = d <NEWLINE> b = N // a <NEWLINE> ans = min ( ans , max ( len ( str ( a ) ) , len ( str ( b ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> K = int ( input ( ) ) <NEWLINE> <NL> s = 7 % K <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> s = ( 10 * s + 7 ) % K <NEWLINE> <NL> <DEDENT> if s == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import copy <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> tmp = copy . copy ( N ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 2 , int ( N ** 0.5 ) + 3 ) : <NEWLINE> <INDENT> while N % i == 0 : <NEWLINE> <INDENT> N //= i <NEWLINE> d [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> if N > 1 : <NEWLINE> <INDENT> d [ N ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while i - tmp >= 0 : <NEWLINE> <INDENT> i -= tmp <NEWLINE> tmp += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> if M == 0 : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 100 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( [ s , c ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> i = str ( i ) <NEWLINE> if len ( i ) != N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for X in A : <NEWLINE> <INDENT> x = X [ 0 ] <NEWLINE> y = X [ 1 ] <NEWLINE> x -= 1 <NEWLINE> if i [ x ] != str ( y ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> @ jit <NEWLINE> def imos ( A ) : <NEWLINE> <INDENT> B = np . zeros_like ( A ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> a = max ( 0 , i - x ) <NEWLINE> b = min ( i + x , N - 1 ) <NEWLINE> B [ a ] += 1 <NEWLINE> if b + 1 <= N - 1 : <NEWLINE> <INDENT> B [ b + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> if i >= 50 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = imos ( A ) <NEWLINE> <DEDENT> print ( * A ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import heapq <NEWLINE> <NL> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> max_cost = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> from_ , to , cost , time = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ from_ - 1 ] . append ( ( to - 1 , cost , time ) ) <NEWLINE> edges [ to - 1 ] . append ( ( from_ - 1 , cost , time ) ) <NEWLINE> if cost > max_cost : <NEWLINE> <INDENT> max_cost = cost <NEWLINE> <NL> <DEDENT> <DEDENT> banks = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> coin , time = map ( int , input ( ) . split ( ) ) <NEWLINE> banks . append ( ( coin , time ) ) <NEWLINE> <NL> <DEDENT> max_coin = max_cost * ( n - 1 ) <NEWLINE> if s > max_coin : <NEWLINE> <INDENT> s = max_coin <NEWLINE> <NL> <DEDENT> INF = float ( <STRING> ) <NEWLINE> DP = [ [ INF ] * ( max_coin + 1 ) for _ in range ( n ) ] <NEWLINE> DP [ 0 ] [ s ] = 0 <NEWLINE> <NL> def push_todo ( node , coin , time ) : <NEWLINE> <INDENT> if coin < 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if time >= DP [ node ] [ coin ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> heapq . heappush ( todo , ( time , node , coin ) ) <NEWLINE> DP [ node ] [ coin ] = time <NEWLINE> <NL> <DEDENT> def charge ( node , current_coin , current_time ) : <NEWLINE> <INDENT> coin , time = banks [ node ] <NEWLINE> new_coin = current_coin + coin <NEWLINE> if new_coin > max_coin : <NEWLINE> <INDENT> new_coin = max_coin <NEWLINE> <DEDENT> push_todo ( node , new_coin , current_time + time ) <NEWLINE> <NL> <DEDENT> todo = [ ( 0 , 0 , s ) ] <COMMENT> <NEWLINE> while todo : <NEWLINE> <INDENT> current_time , node , current_coin = heapq . heappop ( todo ) <NEWLINE> if current_time > DP [ node ] [ current_coin ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> charge ( node , current_coin , current_time ) <NEWLINE> <NL> for to , cost , time in edges [ node ] : <NEWLINE> <INDENT> push_todo ( to , current_coin - cost , current_time + time ) <NEWLINE> <NL> <DEDENT> <DEDENT> for node in range ( 1 , n ) : <NEWLINE> <INDENT> print ( min ( DP [ node ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> MOD = 1000000007 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> s . append ( ( s [ i ] + a [ i ] ) % MOD ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> ans += ( ( s [ n ] - s [ i + 1 ] ) * a [ i ] ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n , k , l = map ( int , input ( ) . split ( ) ) <NEWLINE> city1 = [ i for i in range ( n ) ] <NEWLINE> city2 = [ i for i in range ( n ) ] <NEWLINE> <NL> def root ( c , x ) : <NEWLINE> <INDENT> if x == c [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return root ( c , c [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( c , x , y ) : <NEWLINE> <INDENT> rx = root ( c , x ) <NEWLINE> ry = root ( c , y ) <NEWLINE> if rx > ry : <NEWLINE> <INDENT> c [ rx ] = ry <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ ry ] = rx <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( city1 , a - 1 , b - 1 ) <NEWLINE> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( city2 , a - 1 , b - 1 ) <NEWLINE> <DEDENT> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r . append ( ( root ( city1 , i ) , root ( city2 , i ) ) ) <NEWLINE> <DEDENT> c = Counter ( r ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = c [ r [ i ] ] <NEWLINE> if i == n - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> def prime ( n ) : <NEWLINE> <INDENT> if ( n == 2 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( n < 2 or n % 2 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 3 <NEWLINE> while ( i <= math . sqrt ( n ) ) : <NEWLINE> <INDENT> if ( n % i == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = i + 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if ( prime ( n ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> import copy <NEWLINE> <NL> memo = [ 0 ] * n <NEWLINE> ans = [ - 1 ] * n <NEWLINE> popcnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> popcnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> amariStaticA = 0 <NEWLINE> amariStaticB = 0 <NEWLINE> aaa = - 1 <NEWLINE> if popcnt == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> aaa = i <NEWLINE> amariStaticB += pow ( 2 , n - i - 1 , popcnt + 1 ) <NEWLINE> <DEDENT> <DEDENT> amariStaticB %= popcnt + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> amariStaticA += pow ( 2 , n - i - 1 , max ( 1 , popcnt - 1 ) ) <NEWLINE> amariStaticB += pow ( 2 , n - i - 1 , popcnt + 1 ) <NEWLINE> <DEDENT> <DEDENT> amariStaticA %= max ( 1 , popcnt - 1 ) <NEWLINE> amariStaticB %= popcnt + 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if popcnt == 1 and i == aaa : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> amari = amariStaticB + pow ( 2 , n - i - 1 , popcnt + 1 ) <NEWLINE> amari %= popcnt + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari = amariStaticA - pow ( 2 , n - i - 1 , max ( 1 , popcnt - 1 ) ) <NEWLINE> amari %= max ( 1 , popcnt - 1 ) <NEWLINE> <DEDENT> if amari == 0 : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] = amari <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( memo ) ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> firstMemo = copy . deepcopy ( memo [ i ] ) <NEWLINE> while memo [ i ] != 0 : <NEWLINE> <INDENT> popcnt = bin ( memo [ i ] ) . count ( <STRING> ) <NEWLINE> memo [ i ] %= max ( 1 , popcnt ) <NEWLINE> cnt += 1 <NEWLINE> if memo [ i ] == 0 : <NEWLINE> <INDENT> ans [ i ] = cnt <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for anss in ans : <NEWLINE> <INDENT> print ( anss ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> ans = - 1 <NEWLINE> a = [ 7 % k ] * k <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> a [ i + 1 ] = ( 10 * a [ i ] + 7 ) % k <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> ans = [ 0 , 0 ] <NEWLINE> <NL> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> a = i <NEWLINE> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> b = j <NEWLINE> if ( a ** 5 - b ** 5 ) == X : <NEWLINE> <INDENT> ans [ 0 ] = a <NEWLINE> ans [ 1 ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( ans [ 0 ] , ans [ 1 ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xmod = [ y % m for y in x ] <NEWLINE> from collections import Counter <NEWLINE> cx = dict ( Counter ( x ) ) <NEWLINE> cxmod = dict ( Counter ( xmod ) ) <NEWLINE> keys = cxmod . keys ( ) <NEWLINE> ans1 , ans2 = 0 , 0 <COMMENT> <NEWLINE> for k in keys : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k == m - k : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> elif m - k in keys : <NEWLINE> <INDENT> tmp = min ( cxmod [ k ] , cxmod [ m - k ] ) <NEWLINE> ans1 += tmp <NEWLINE> cxmod [ k ] -= tmp <NEWLINE> cxmod [ m - k ] -= tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in cx : <NEWLINE> <INDENT> v = cx [ k ] <NEWLINE> if v >= 2 and cxmod [ k % m ] >= 2 : <NEWLINE> <INDENT> tmp = min ( v // 2 , cxmod [ k % m ] // 2 ) <NEWLINE> ans2 += tmp <NEWLINE> cxmod [ k % m ] -= tmp * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans1 + ans2 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rev = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> rev [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( rev [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> r = [ ] <NEWLINE> bi = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> bi . append ( b ) <NEWLINE> if a % b == 0 : <NEWLINE> <INDENT> r . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( b - a % b ) <NEWLINE> <DEDENT> <DEDENT> push = 0 <NEWLINE> bi = bi [ : : - 1 ] <NEWLINE> r = r [ : : - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> push = r [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> push += ( r [ i ] - push ) % bi [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( push ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def show ( A ) : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if k == N - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( A [ k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( A [ k ] ) , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> show ( A ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 ) and ( A [ j ] > v ) : <NEWLINE> <INDENT> A [ j + 1 ] , A [ j ] = A [ j ] , v <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> show ( A ) <NEWLINE> <NL> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> score = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = abcd [ i ] [ 0 ] <NEWLINE> b = abcd [ i ] [ 1 ] <NEWLINE> c = abcd [ i ] [ 2 ] <NEWLINE> d = abcd [ i ] [ 3 ] <NEWLINE> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> score . append ( d ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , sum ( score ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> X = x1 - x2 <NEWLINE> Y = y1 - y2 <NEWLINE> print ( <STRING> . format ( math . sqrt ( X * X + Y * Y ) ) ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> ) <NEWLINE> def chmax ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ nb . njit ( <STRING> ) <NEWLINE> def solve ( N , W , wv ) : <NEWLINE> <INDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> w , v = wv [ i - 1 ] <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = chmax ( dp [ i - 1 ] [ j - w ] + v , dp [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = np . zeros ( shape = ( N , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> wv [ i ] = w , v <NEWLINE> <NL> <DEDENT> ans = solve ( N , W , wv ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if M >= 1 : <NEWLINE> <INDENT> S = [ ] <NEWLINE> C = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> S . append ( s ) <NEWLINE> C . append ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if N == 3 : <NEWLINE> <INDENT> print ( 100 ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> ans = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ans [ S [ i ] - 1 ] . append ( C [ i ] ) <NEWLINE> <NL> <DEDENT> ans2 = [ ] <NEWLINE> <NL> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if len ( set ( ans [ i ] ) ) > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( ans [ i ] ) == 0 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans2 . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 . append ( 0 ) <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> ans2 . append ( list ( set ( ans [ i ] ) ) [ 0 ] ) <NEWLINE> <NL> <DEDENT> if ans2 [ 0 ] == 0 : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans2 ) ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> for node in range ( n ) : <NEWLINE> <INDENT> good = True <NEWLINE> for neighbor in edge [ node ] : <NEWLINE> <INDENT> if h [ node ] <= h [ neighbor ] : <NEWLINE> <INDENT> good = False <NEWLINE> <NL> <DEDENT> <DEDENT> if good : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> limit = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> m = s // 60 <NEWLINE> h = str ( m // 60 ) <NEWLINE> m = str ( m % 60 ) <NEWLINE> s = str ( s % 60 ) <NEWLINE> <NL> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import itertools <NEWLINE> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , X = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C . append ( tmp [ 0 ] ) <NEWLINE> A . append ( tmp [ 1 : ] ) <NEWLINE> <DEDENT> CA = [ [ C [ i ] , v ] for i , v in enumerate ( A ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> anss = [ ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> arr = [ 0 ] * M <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> s += CA [ j ] [ 0 ] <NEWLINE> arr = python_list_add ( arr , CA [ j ] [ 1 ] ) <NEWLINE> <DEDENT> if all ( [ x >= X for x in arr ] ) : <NEWLINE> <INDENT> anss . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min ( anss ) if anss else - 1 ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> def python_list_add ( in1 , in2 ) : <NEWLINE> <INDENT> return [ a + b for a , b in zip ( in1 , in2 ) ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ - 1 ] * N <NEWLINE> loopcnt = 0 <NEWLINE> inicnt = 0 <NEWLINE> place = 1 <NEWLINE> i = 0 <NEWLINE> l [ place - 1 ] = 0 <NEWLINE> <NL> while i < K : <NEWLINE> <INDENT> i += 1 <NEWLINE> next_place = A_list [ place - 1 ] <NEWLINE> place = next_place <NEWLINE> if l [ next_place - 1 ] != - 1 : <NEWLINE> <INDENT> loopcnt = i - l [ next_place - 1 ] <NEWLINE> inicnt = l [ next_place - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ next_place - 1 ] = i <NEWLINE> <DEDENT> <DEDENT> if i >= K : <NEWLINE> <INDENT> print ( place ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> last_move_cnt = ( K - inicnt ) % loopcnt <NEWLINE> <NL> j = 1 <NEWLINE> while j <= last_move_cnt : <NEWLINE> <INDENT> j += 1 <NEWLINE> next_place = A_list [ place - 1 ] <NEWLINE> place = next_place <NEWLINE> <DEDENT> print ( place ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in data : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for f in data : <NEWLINE> <INDENT> s *= f <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i + 1 ] = L [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( min ( i - L [ i ] + L [ N ] - L [ i + 1 ] for i in range ( N ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = [ True ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ha = H [ a - 1 ] <NEWLINE> hb = H [ b - 1 ] <NEWLINE> if ha == hb : <NEWLINE> <INDENT> flag [ a - 1 ] = False <NEWLINE> flag [ b - 1 ] = False <NEWLINE> <DEDENT> elif ha < hb : <NEWLINE> <INDENT> flag [ a - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ b - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for f in flag : <NEWLINE> <INDENT> if f : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> limit = 10 ** 18 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> _mul = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> _mul *= a <NEWLINE> if _mul > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( _mul ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . sort ( reverse = True ) <NEWLINE> print ( A [ 0 ] + sum ( A [ 1 : ( n - 2 ) // 2 + 1 ] ) * 2 + <NEWLINE> <INDENT> ( 0 if n % 2 == 0 else A [ ( n - 1 ) // 2 ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a , b = <STRING> , <STRING> <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = len ( S ) - r - g <NEWLINE> rgb = r * g * b <NEWLINE> expt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = S [ i ] <NEWLINE> for j in range ( i , ( N + i - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if S [ j ] != a : <NEWLINE> <INDENT> b = S [ j ] <NEWLINE> k = 2 * j - i <NEWLINE> if S [ k ] != b and S [ k ] != a : <NEWLINE> <INDENT> expt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rgb - expt ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m += 1 <NEWLINE> n += 1 <NEWLINE> r = [ 0 ] * ( n ) <NEWLINE> c = [ 0 ] * ( m ) <NEWLINE> d = { } <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ ( a , b ) ] = 1 <NEWLINE> r [ a ] += 1 <NEWLINE> c [ b ] += 1 <NEWLINE> <DEDENT> m1 = max ( r ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( r [ i ] == m1 ) : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> m2 = max ( c ) <NEWLINE> y = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( c [ i ] == m2 ) : <NEWLINE> <INDENT> y . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = m1 + m2 <NEWLINE> z = 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> for j in y : <NEWLINE> <INDENT> if ( ( i , j ) not in d ) : <NEWLINE> <INDENT> z = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( z == 0 ) : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ 0 for _ in range ( N ) ] <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> X = [ 0 for _ in range ( ( N - 1 ) // 2 ) ] <NEWLINE> l , r = 1 , N // 2 <NEWLINE> for i in range ( ( N // 2 ) // 2 ) : <NEWLINE> <INDENT> X [ i ] = [ l , r ] <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> l , r = N , N // 2 + 2 <NEWLINE> for i in range ( ( N - 1 ) // 2 - ( N // 2 ) // 2 ) : <NEWLINE> <INDENT> X [ i + ( N // 2 ) // 2 ] = [ l , r ] <NEWLINE> l -= 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( X [ i ] [ 0 ] , X [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( N - i , i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt != 0 : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> print ( max ( l ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import jit <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N , K , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> K = min ( 50 , K ) <NEWLINE> <NL> @ jit <NEWLINE> def imos ( A ) : <NEWLINE> <INDENT> B = np . zeros_like ( A ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> a = max ( 0 , i - x ) <NEWLINE> b = min ( N - 1 , i + x ) <NEWLINE> B [ a ] += 1 <NEWLINE> if b + 1 <= N - 1 : <NEWLINE> <INDENT> B [ b + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> if i >= 50 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = imos ( A ) <NEWLINE> <DEDENT> print ( * A ) <NEWLINE>
import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] <NEWLINE> def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def ceil ( x , y = 1 ) : return int ( - ( - x // y ) ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] <NEWLINE> def Yes ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> def YES ( ) : print ( <STRING> ) <NEWLINE> def NO ( ) : print ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 19 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> if A . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> row = np . zeros ( W ) <NEWLINE> col = np . zeros ( H ) <NEWLINE> memo = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h -= 1 <NEWLINE> w -= 1 <NEWLINE> row [ w ] += 1 <NEWLINE> col [ h ] += 1 <NEWLINE> memo . append ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> col_max = col . max ( ) <NEWLINE> row_max = row . max ( ) <NEWLINE> <NL> max_col_indexs = np . where ( col == col_max ) [ 0 ] <NEWLINE> max_row_indexs = np . where ( row == row_max ) [ 0 ] <NEWLINE> <NL> ans = col_max + row_max - 1 <NEWLINE> memo = set ( memo ) <NEWLINE> for c in max_col_indexs : <NEWLINE> <INDENT> for r in max_row_indexs : <NEWLINE> <INDENT> if ( c , r ) not in memo : <NEWLINE> <INDENT> ans = ans = col_max + row_max <NEWLINE> print ( int ( ans ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for i in range ( 10100 ) ] <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> if x * x + y * y + z * z + x * y + y * z + z * x < 10001 : <NEWLINE> <INDENT> ans [ x * x + y * y + z * z + x * y + y * z + z * x - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import heapq <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ( ans * a ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> pos . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( neg ) == N and K & 1 == 1 : <NEWLINE> <INDENT> neg . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * neg [ i ] ) % MOD <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pos . sort ( reverse = True ) <NEWLINE> pos2 = [ ] <NEWLINE> ans = 1 <NEWLINE> ini = 0 <NEWLINE> rem = K <NEWLINE> if K & 1 == 1 : <NEWLINE> <INDENT> ans = ( ans * pos [ 0 ] ) % MOD <NEWLINE> ini = 1 <NEWLINE> rem -= 1 <NEWLINE> <DEDENT> for i in range ( 0 , ( len ( pos ) - ini ) // 2 ) : <NEWLINE> <INDENT> heapq . heappush ( pos2 , ( pos [ i * 2 + ini ] * pos [ i * 2 + ini + 1 ] ) * - 1 ) <NEWLINE> <DEDENT> neg . sort ( ) <NEWLINE> neg2 = [ ] <NEWLINE> for i in range ( 0 , len ( neg ) // 2 ) : <NEWLINE> <INDENT> heapq . heappush ( neg2 , ( neg [ i * 2 ] * neg [ i * 2 + 1 ] ) * - 1 ) <NEWLINE> <DEDENT> while rem > 0 : <NEWLINE> <INDENT> if ( pos2 != [ ] and neg2 == [ ] ) or ( pos2 != [ ] and neg2 != [ ] and pos2 [ 0 ] <= neg2 [ 0 ] ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( pos2 ) * - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = heapq . heappop ( neg2 ) * - 1 <NEWLINE> <DEDENT> ans = ( ans * tmp ) % MOD <NEWLINE> rem -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = str ( N ) <NEWLINE> a = list ( n ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> count = count + int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> if count % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( l , a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( b % 2 == 0 ) : <NEWLINE> <INDENT> if ( 2 * a <= b <= 4 * a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if a % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = ( 10 * a + 7 ) % K <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
from numba import jit <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> B = [ 0 ] * ( N + 1 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> B [ max ( 0 , i - a ) ] += 1 <NEWLINE> B [ min ( N , i + a + 1 ) ] -= 1 <NEWLINE> <DEDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> B [ j ] += B [ j - 1 ] <NEWLINE> <DEDENT> if A == B [ : - 1 ] : <NEWLINE> <INDENT> A = B [ : - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> A = B [ : - 1 ] <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( list ( map ( str , A ) ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> for k in range ( j , N + 1 ) : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> total += gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += 3 * gcd ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( j , N + 1 ) : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> total += 3 * gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += 6 * gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for d in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( 1 + N // d ) * ( N // d ) * d // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> min_can = set ( ) <NEWLINE> <NL> <NL> def cal_score ( bought_books ) : <NEWLINE> <INDENT> global CA <NEWLINE> global M <NEWLINE> global N <NEWLINE> global X <NEWLINE> algo_Q = [ 0 ] * M <NEWLINE> cost = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if bought_books [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> algo_Q [ j - 1 ] += CA [ i ] [ j ] <NEWLINE> <DEDENT> cost += CA [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> flag = True <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if algo_Q [ i ] < X : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> global min_can <NEWLINE> min_can . add ( cost ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> def next_book ( book_list ) : <NEWLINE> <INDENT> global N <NEWLINE> global M <NEWLINE> <NL> if len ( book_list ) == N : <NEWLINE> <INDENT> return cal_score ( book_list ) <NEWLINE> <DEDENT> book_list . append ( 0 ) <NEWLINE> next_book ( book_list ) <NEWLINE> book_list . pop ( - 1 ) <NEWLINE> <NL> book_list . append ( 1 ) <NEWLINE> next_book ( book_list ) <NEWLINE> book_list . pop ( - 1 ) <NEWLINE> return 0 <NEWLINE> <NL> <NL> <DEDENT> book_list = [ ] <NEWLINE> next_book ( book_list ) <NEWLINE> if set ( ) == min_can : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( min_can ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def LPP ( ) : <NEWLINE> <INDENT> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , readline ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> t -= 1 <NEWLINE> edges [ s ] . append ( t ) <NEWLINE> <DEDENT> dp = [ - 1 ] * n <NEWLINE> def dfs ( s ) : <NEWLINE> <INDENT> if dp [ s ] != - 1 : <NEWLINE> <INDENT> return dp [ s ] <NEWLINE> <DEDENT> if len ( edges [ s ] ) == 0 : <NEWLINE> <INDENT> dp [ s ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> res = 0 <NEWLINE> for t in edges [ s ] : <NEWLINE> <INDENT> res = max ( res , dfs ( t ) + 1 ) <NEWLINE> <DEDENT> dp [ s ] = res <NEWLINE> return res <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <DEDENT> print ( max ( dp ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> LPP ( ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> t = N % K <NEWLINE> print ( min ( K - t , t ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) . strip ( ) ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> quot = N // k <COMMENT> <NEWLINE> num_divisor = quot * ( quot + 1 ) // 2 <NEWLINE> <NL> ans += k * num_divisor <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> b [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + a [ i + 1 ] <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for j in range ( n - 1 ) : <NEWLINE> <INDENT> c += a [ j ] * ( b [ n - 1 ] - b [ j ] ) <NEWLINE> <NL> <DEDENT> print ( c % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> a = Counter ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> q = int ( readline ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> L . append ( list ( map ( int , readline ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> s = sum ( x * y for x , y in a . items ( ) ) <NEWLINE> for b , c in L : <NEWLINE> <COMMENT> <NL> <INDENT> if b in a : <NEWLINE> <INDENT> s += ( c - b ) * a [ b ] <NEWLINE> a [ c ] += a [ b ] <NEWLINE> del a [ b ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
stk = [ ] <NEWLINE> for c in input ( ) . split ( ) : <NEWLINE> <INDENT> if c in <STRING> : <NEWLINE> <INDENT> a = stk . pop ( ) <NEWLINE> b = stk . pop ( ) <NEWLINE> stk . append ( str ( eval ( b + c + a ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stk . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( stk . pop ( ) ) <NEWLINE> <NL>
def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , B , N = LI ( ) <NEWLINE> ans = 0 <NEWLINE> if B <= N : <NEWLINE> <INDENT> print ( int ( ( A / B * ( B - 1 ) ) // 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( A / B ) * ( N % B ) // 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = [ 0 ] * ( n + 2 ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> list [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( list [ i ] ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> ans = 0 <NEWLINE> <NL> tmp = pow ( 26 , K , MOD ) <NEWLINE> ans = tmp <NEWLINE> waru = pow ( 26 , - 1 , MOD ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = ( tmp * 25 * waru ) % MOD <NEWLINE> tmp = ( tmp * ( l - 1 + i ) * pow ( i , - 1 , MOD ) ) % MOD <NEWLINE> ans = ( ans + tmp ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from collections import defaultdict <NEWLINE> from functools import reduce <NEWLINE> <NL> memo = defaultdict ( int ) <NEWLINE> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> def gcd_with_memo ( x , y ) : <NEWLINE> <INDENT> key = tuple ( sorted ( [ x , y ] ) ) <NEWLINE> if memo [ key ] != 0 : <NEWLINE> <INDENT> value = memo [ key ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value = math . gcd ( x , y ) <NEWLINE> memo [ key ] = value <NEWLINE> <DEDENT> return value <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += i <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> total += 6 * gcd ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> total += 6 * gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def mid ( x , y , z ) : <NEWLINE> <INDENT> if x <= y <= z or z <= y <= x : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> elif y <= x <= z or z <= x <= y : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return z <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> from random import shuffle <NEWLINE> for _ in range ( 5 ) : <NEWLINE> <INDENT> arr = [ i for i in range ( 1 , 11 + 1 ) ] <NEWLINE> shuffle ( arr ) <NEWLINE> print ( arr , end = <STRING> ) <NEWLINE> while len ( arr ) > 1 : <NEWLINE> <INDENT> tmp = [ mid ( arr [ i ] , arr [ i + 1 ] , arr [ i + 2 ] ) for i in range ( len ( arr ) - 2 ) ] <NEWLINE> arr = tmp <NEWLINE> <DEDENT> print ( arr [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 1 or x == 2 * n - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ None ] * ( 2 * n - 1 ) <NEWLINE> st = set ( i for i in range ( 1 , 2 * n ) ) <NEWLINE> ans [ n - 1 ] = x <NEWLINE> st . remove ( x ) <NEWLINE> if x == 2 : <NEWLINE> <INDENT> ans [ n - 3 ] = 4 <NEWLINE> ans [ n - 2 ] = 1 <NEWLINE> ans [ n ] = 3 <NEWLINE> st . remove ( 1 ) <NEWLINE> st . remove ( 3 ) <NEWLINE> st . remove ( 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ n - 3 ] = x - 2 <NEWLINE> ans [ n - 2 ] = x + 1 <NEWLINE> ans [ n ] = x - 1 <NEWLINE> st . remove ( x - 2 ) <NEWLINE> st . remove ( x + 1 ) <NEWLINE> st . remove ( x - 1 ) <NEWLINE> <DEDENT> for i in range ( 2 * n - 1 ) : <NEWLINE> <INDENT> if ans [ i ] is None : <NEWLINE> <INDENT> ans [ i ] = st . pop ( ) <NEWLINE> <DEDENT> <DEDENT> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> ans = [ 0 ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import datetime <NEWLINE> import string <NEWLINE> import re <NEWLINE> import math <NEWLINE> <NL> def isort ( list , _beg , _end ) : <NEWLINE> <INDENT> if _beg < _end : <NEWLINE> <INDENT> beg = _beg <NEWLINE> end = _end <NEWLINE> pivot = abs ( list [ int ( ( beg + end ) / 2 ) ] ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> while abs ( list [ beg ] ) < pivot : beg += 1 <NEWLINE> while abs ( list [ end ] ) > pivot : end -= 1 <NEWLINE> if beg <= end : <NEWLINE> <INDENT> tmp = list [ beg ] <NEWLINE> list [ beg ] = list [ end ] <NEWLINE> list [ end ] = tmp <NEWLINE> beg += 1 <NEWLINE> end -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> isort ( list , _beg , end ) <NEWLINE> isort ( list , beg , _end ) <NEWLINE> <NL> <DEDENT> <DEDENT> def searchByBool ( list ) : <NEWLINE> <INDENT> for i in range ( len ( list ) ) : <NEWLINE> <INDENT> if check ( list [ i ] ) : return i <NEWLINE> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> def check ( num ) : <NEWLINE> <INDENT> if num >= 0 : return True <NEWLINE> else : return False <NEWLINE> <NL> <DEDENT> sp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = sp [ 0 ] <NEWLINE> K = sp [ 1 ] <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> klist = [ ] <NEWLINE> isK = True <NEWLINE> <NL> isort ( alist , 0 , len ( alist ) - 1 ) <NEWLINE> alist . reverse ( ) <NEWLINE> <NL> numMinus = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if check ( alist [ i ] ) == False : numMinus += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if numMinus % 2 == 0 : <NEWLINE> <INDENT> isK = False <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if isK and K < N : <NEWLINE> <INDENT> _right = - 1 <NEWLINE> _left = - 1 <NEWLINE> for right in range ( K , N ) : <NEWLINE> <INDENT> if check ( alist [ K - 1 ] ) != check ( alist [ right ] ) : <NEWLINE> <INDENT> _right = right <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for left in range ( K ) : <NEWLINE> <INDENT> if check ( alist [ K - 1 - left ] ) != check ( alist [ K ] ) : <NEWLINE> <INDENT> _left = left <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> isK = False <NEWLINE> if _right != - 1 and _left != - 1 : <NEWLINE> <INDENT> if abs ( alist [ K - 1 - left ] * alist [ _right ] ) < abs ( alist [ K - 1 ] * alist [ K ] ) : <NEWLINE> <INDENT> alist [ K - 1 - _left ] = alist [ K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> alist [ K - 1 ] = alist [ _right ] <NEWLINE> <DEDENT> <DEDENT> elif _right == - 1 and _left != - 1 : <NEWLINE> <INDENT> alist [ K - 1 - _left ] = alist [ K ] <NEWLINE> <DEDENT> elif _right != - 1 and _left == - 1 : <NEWLINE> <INDENT> alist [ K - 1 ] = alist [ _right ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> isK = True <NEWLINE> <NL> <DEDENT> <DEDENT> if isK : <NEWLINE> <INDENT> alist . reverse ( ) <NEWLINE> <DEDENT> klist = alist [ 0 : K ] <NEWLINE> <NL> multi = klist [ 0 ] <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> multi *= klist [ i ] <NEWLINE> multi = multi % 1000000007 <NEWLINE> <NL> <DEDENT> print ( multi ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> x , y , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x , y , s ) == ( 0 , 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , s - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , s - i + 1 ) : <NEWLINE> <INDENT> if i * ( 100 + x ) // 100 + j * ( 100 + x ) // 100 == s : <NEWLINE> <INDENT> ans = max ( ans , i * ( 100 + y ) // 100 + j * ( 100 + y ) // 100 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( set ( [ input ( ) for i in range ( n ) ] ) ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> from numba import jit , njit <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def g ( x ) : <NEWLINE> <INDENT> y = n // x <NEWLINE> return y * ( y + 1 ) * x // 2 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += g ( i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> for x in A : <NEWLINE> <INDENT> l [ x - 1 ] += 1 <NEWLINE> <DEDENT> for s in l : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> print ( str ( n ) + <STRING> , end = <STRING> ) <NEWLINE> array = [ ] <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if n == 999993031 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if n % i == 0 and i != n : <NEWLINE> <INDENT> array . append ( i ) <NEWLINE> n = int ( n / i ) <NEWLINE> break <NEWLINE> <DEDENT> if i == n : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if count == 24 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> array . append ( n ) <NEWLINE> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> print ( <STRING> , array [ i ] , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( len ( set ( S ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> def modpow ( x , n , mod ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n % 2 : <NEWLINE> <INDENT> res *= x % mod <NEWLINE> <DEDENT> x *= x % mod <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> s_len = len ( s ) <NEWLINE> mod = 2019 <NEWLINE> d = [ 0 ] * mod <NEWLINE> d [ 0 ] = 1 <NEWLINE> rev_num = 0 <NEWLINE> <COMMENT> <NL> for i in range ( s_len ) : <NEWLINE> <INDENT> rev_num += int ( s [ i ] ) * int ( modpow ( 10 , i , mod ) ) <NEWLINE> rev_num %= mod <NEWLINE> d [ rev_num ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in d ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> ans = [ min ( a ) + min ( b ) ] <NEWLINE> for x in X : <NEWLINE> <INDENT> a_idx , b_index , c = x <NEWLINE> ans . append ( a [ a_idx - 1 ] + b [ b_index - 1 ] - c ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> res [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> up = int ( <STRING> + <STRING> * 18 ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> <NL> def calc ( a ) : <NEWLINE> <INDENT> x = ans <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> x = x * a [ i ] <NEWLINE> <NL> if ( x > up ) : <NEWLINE> <INDENT> x = - 1 <NEWLINE> return x <NEWLINE> <NL> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> if ( 0 in a ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = calc ( a ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( e ) ) : <NEWLINE> <INDENT> ans += o [ i ] + e [ i ] <NEWLINE> <NL> <DEDENT> if len ( o ) == len ( e ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans + o [ - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from fractions import Fraction <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if b * ( a ** 2 ) <= x * 2 : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( Fraction ( 2 * ( a * a * b - x ) , a ** 3 ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . degrees ( math . atan ( Fraction ( a * b * b , 2 * x ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> <NL> def initRMQ ( n , D ) : <NEWLINE> <INDENT> n_ = 1 <NEWLINE> <NL> while n_ < n : <NEWLINE> <INDENT> n_ *= 2 <NEWLINE> <NL> <DEDENT> for i in range ( 2 * n_ - 1 ) : <NEWLINE> <INDENT> D . append ( 2147483647 ) <NEWLINE> <NL> <DEDENT> return n_ <NEWLINE> <NL> <NL> <DEDENT> def update ( k , a ) : <NEWLINE> <INDENT> k += n_ - 1 <NEWLINE> D [ k ] = a <NEWLINE> while k > 0 : <NEWLINE> <INDENT> k = int ( ( k - 1 ) / 2 ) <NEWLINE> D [ k ] = min ( D [ k * 2 + 1 ] , D [ k * 2 + 2 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def findMin ( a , b ) : <NEWLINE> <INDENT> return query ( a , b + 1 , 0 , 0 , n_ ) <NEWLINE> <NL> <NL> <DEDENT> def query ( a , b , k , l , r ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return 2147483647 <NEWLINE> <NL> <DEDENT> if a <= l and r <= b : <NEWLINE> <INDENT> return D [ k ] <NEWLINE> <NL> <DEDENT> vl = query ( a , b , k * 2 + 1 , l , int ( ( l + r ) / 2 ) ) <NEWLINE> vr = query ( a , b , k * 2 + 2 , int ( ( l + r ) / 2 ) , r ) <NEWLINE> <NL> return min ( vl , vr ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D = [ ] <NEWLINE> n_ = initRMQ ( n , D ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <COMMENT> <NL> <INDENT> c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if c == 0 : <NEWLINE> <INDENT> update ( x , y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( findMin ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = [ y , x ] <NEWLINE> <NL> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> x , y = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE> <NL>
K = int ( input ( ) ) <NEWLINE> <NL> t = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if t % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> t = ( t * 10 + 7 ) % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 1 <NEWLINE> li . sort ( ) <NEWLINE> for a in li : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> break <NEWLINE> <DEDENT> total *= a <NEWLINE> if 10 ** 18 < total : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def calc ( x ) : <NEWLINE> <INDENT> y = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> return y <NEWLINE> <NL> <DEDENT> max_v = 0 <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> max_v = calc ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_v = calc ( B - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( max_v ) <NEWLINE>
xx = [ ] <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> xx = sorted ( ab , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += xx [ i ] [ 1 ] <NEWLINE> if ans >= k : <NEWLINE> <INDENT> print ( xx [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INTMAX = 9223372036854775807 <NEWLINE> INTMIN = - 9223372036854775808 <NEWLINE> DVSR = 1000000007 <NEWLINE> def POW ( x , y ) : return pow ( x , y , DVSR ) <NEWLINE> def INV ( x , m = DVSR ) : return pow ( x , m - 2 , m ) <NEWLINE> def DIV ( x , y , m = DVSR ) : return ( x * INV ( y , m ) ) % m <NEWLINE> def LI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> def FLIST ( n ) : <NEWLINE> <INDENT> res = [ 1 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res . append ( res [ i - 1 ] * i % DVSR ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> N = II ( ) <NEWLINE> ST = input ( ) <NEWLINE> ST = ST [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> popcnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> popcnt += ST [ i ] == <STRING> <NEWLINE> <NL> <DEDENT> NUM1 = 0 <NEWLINE> NUM2 = 0 <NEWLINE> pop_1 = popcnt - 1 <NEWLINE> pop_2 = popcnt + 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ST [ i ] == <STRING> : <NEWLINE> <INDENT> if pop_1 > 0 : <NEWLINE> <INDENT> NUM1 += pow ( 2 , i , pop_1 ) <NEWLINE> NUM1 %= pop_1 <NEWLINE> <DEDENT> if pop_2 <= N : <NEWLINE> <INDENT> NUM2 += pow ( 2 , i , pop_2 ) <NEWLINE> NUM2 %= pop_2 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> i = N - i - 1 <NEWLINE> if ST [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> if pop_1 != 0 : <NEWLINE> <INDENT> value = NUM1 - pow ( 2 , i , pop_1 ) <NEWLINE> value %= pop_1 <NEWLINE> while value : <NEWLINE> <INDENT> value %= bin ( value ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> value = NUM2 + pow ( 2 , i , pop_2 ) <NEWLINE> value %= pop_2 <NEWLINE> while value : <NEWLINE> <INDENT> value %= bin ( value ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> <DEDENT>
<NL> import string <NEWLINE> import sys <NEWLINE> <NL> def CaesarCipher ( ) : <NEWLINE> <NL> <INDENT> low = string . ascii_lowercase <NEWLINE> <NL> for cry in sys . stdin : <NEWLINE> <INDENT> for i in range ( 1 , 27 ) : <NEWLINE> <NL> <INDENT> dec = cry . translate ( str . maketrans ( low , low [ i : ] + low [ : i ] ) ) <NEWLINE> <NL> if <STRING> in dec or <STRING> in dec or <STRING> in dec : <NEWLINE> <INDENT> print ( dec [ : - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> CaesarCipher ( ) <NEWLINE>
<NL> from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( q , gcd ( i , p ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from bisect import bisect_left , bisect_right , insort <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> N = ir ( ) <NEWLINE> A = [ 0 ] + lr ( ) <COMMENT> <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = lr ( ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> answer = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> INF = 10 ** 10 <NEWLINE> parent = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> def dfs ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i = bisect_left ( dp , INF ) <NEWLINE> answer [ n ] = i <NEWLINE> for c in graph [ n ] : <NEWLINE> <INDENT> if c == parent [ n ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ c ] = n <NEWLINE> i = bisect_left ( dp , A [ c ] ) <NEWLINE> old = dp [ i ] <NEWLINE> dp [ i ] = A [ c ] <NEWLINE> dfs ( c ) <NEWLINE> dp [ i ] = old <NEWLINE> <NL> <DEDENT> <DEDENT> dp = [ INF ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = A [ 1 ] <NEWLINE> dfs ( 1 ) <NEWLINE> for a in answer [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = { } <NEWLINE> for c in S : <NEWLINE> <INDENT> cnt [ c ] = cnt . get ( c , 0 ) + 1 <NEWLINE> <DEDENT> total_triplets = cnt . get ( <STRING> , 0 ) * cnt . get ( <STRING> , 0 ) * cnt . get ( <STRING> , 0 ) <NEWLINE> for stride in range ( 1 , N ) : <NEWLINE> <INDENT> for i in range ( 0 , N - 2 * stride ) : <NEWLINE> <INDENT> j = i + stride <NEWLINE> k = j + stride <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> total_triplets -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total_triplets ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> law_ans = 0 <NEWLINE> absminA = float ( <STRING> ) <NEWLINE> for a in A : <NEWLINE> <INDENT> law_ans += abs ( a ) <NEWLINE> absminA = min ( absminA , abs ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> cnt_neg = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> cnt_neg += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt_0 = A . count ( 0 ) <NEWLINE> <NL> if cnt_0 == 0 : <NEWLINE> <INDENT> if cnt_neg % 2 == 0 : <NEWLINE> <INDENT> print ( law_ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( law_ans - 2 * absminA ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( law_ans ) <NEWLINE> <DEDENT>
num = { <NEWLINE> <INDENT> 1 : { 1 : [ 0 ] * 10 , 2 : [ 0 ] * 10 , 3 : [ 0 ] * 10 } , <NEWLINE> 2 : { 1 : [ 0 ] * 10 , 2 : [ 0 ] * 10 , 3 : [ 0 ] * 10 } , <NEWLINE> 3 : { 1 : [ 0 ] * 10 , 2 : [ 0 ] * 10 , 3 : [ 0 ] * 10 } , <NEWLINE> 4 : { 1 : [ 0 ] * 10 , 2 : [ 0 ] * 10 , 3 : [ 0 ] * 10 } <NEWLINE> <DEDENT> } <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> num [ b ] [ f ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b in num : <NEWLINE> <INDENT> for f in num [ b ] : <NEWLINE> <INDENT> for r in num [ b ] [ f ] : <NEWLINE> <INDENT> print ( <STRING> + str ( r ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if b == 4 : break <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT>
A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> n , m , l = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> [ A . append ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) for x in range ( n ) ] <NEWLINE> [ B . append ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) for y in range ( m ) ] <NEWLINE> [ C . append ( [ 0 for zz in range ( l ) ] ) for z in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> if j == l - 1 : <NEWLINE> <INDENT> print ( C [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> v_max = ( 10 ** 3 ) * N <NEWLINE> inf = float ( <STRING> ) <NEWLINE> dp = [ inf for _ in range ( v_max + 1 ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( v_max , v - 1 , - 1 ) : <NEWLINE> <INDENT> b = w + dp [ j - v ] <NEWLINE> if b < dp [ j ] : <NEWLINE> <INDENT> dp [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = None <NEWLINE> for i in range ( v_max + 1 ) : <NEWLINE> <INDENT> z = dp [ i ] <NEWLINE> if z <= W : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> if A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> saidaiA = [ ] <NEWLINE> oya = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if oya >= 5 * 10 ** 13 : <NEWLINE> <INDENT> ko = 10 ** 14 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ko = oya * 2 <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> ko = 1 <NEWLINE> <DEDENT> oya = ko - A [ i ] <NEWLINE> saidaiA . append ( ko ) <NEWLINE> if oya < 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> motikosi = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ - i ] + motikosi >= saidaiA [ - i ] : <NEWLINE> <INDENT> ans += saidaiA [ - i ] <NEWLINE> motikosi = saidaiA [ - i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ - i ] + motikosi <NEWLINE> motikosi = A [ - i ] + motikosi <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( <STRING> . join ( sorted ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> ali = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( 0 , N ) : <NEWLINE> <INDENT> for k in range ( 0 , N ) : <NEWLINE> <INDENT> if li [ i ] + li [ j ] > li [ k ] and li [ j ] + li [ k ] > li [ i ] and li [ k ] + li [ i ] > li [ j ] : <NEWLINE> <INDENT> if li [ i ] != li [ j ] and li [ j ] != li [ k ] and li [ k ] != li [ i ] : <NEWLINE> <INDENT> if i != j and j != k and k != i and i < j and j < k : <NEWLINE> <INDENT> ali . append ( sorted ( [ i , j , k ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( ali ) ) <NEWLINE>
def f ( x ) : <NEWLINE> <INDENT> return ( ( A * x ) // B ) - A * ( x // B ) <NEWLINE> <NL> <DEDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( min ( B - 1 , N ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> s = set ( ) <NEWLINE> s . add ( 1 ) <NEWLINE> order = [ 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if a [ i ] in s : <NEWLINE> <INDENT> order . append ( a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> order . append ( a [ i ] ) <NEWLINE> s . add ( a [ i ] ) <NEWLINE> <DEDENT> i = a [ i ] - 1 <NEWLINE> <DEDENT> for i in range ( len ( order ) ) : <NEWLINE> <INDENT> if order [ - 1 ] == order [ i ] : <NEWLINE> <INDENT> idx = i <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> cnt = len ( order ) - ( idx + 1 ) <NEWLINE> if len ( order ) > k : <NEWLINE> <INDENT> print ( order [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= len ( order ) <NEWLINE> order = order [ idx + 1 : ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> k %= cnt <NEWLINE> <COMMENT> <NL> print ( order [ k ] ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a = 7 <NEWLINE> <NL> for n in range ( 1 , 1 + K ) : <NEWLINE> <INDENT> if a % K == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = ( a * 10 + 7 ) % K <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> k *= 9 <NEWLINE> a = 10 <NEWLINE> for i in range ( 10 * k ) : <NEWLINE> <INDENT> if ( 7 * ( a - 1 + k ) ) % k == 0 : <NEWLINE> <INDENT> print ( str ( i + 1 ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = ( a * 10 ) % k <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , M , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> read_a = [ 0 ] * n <NEWLINE> read_b = [ 0 ] * M <NEWLINE> time = 0 <NEWLINE> ans = 0 <NEWLINE> memo = - 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if time + a_l [ j ] <= k : <NEWLINE> <INDENT> time += a_l [ j ] <NEWLINE> read_a [ j ] = 1 <NEWLINE> memo = j <NEWLINE> ans = j + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> kotae = [ ans ] <NEWLINE> <NL> <NL> def dfs ( i , a , t , m ) : <NEWLINE> <INDENT> global kotae <NEWLINE> if i < M : <NEWLINE> <INDENT> if b_l [ i ] + t <= k : <NEWLINE> <INDENT> tt = t + b_l [ i ] <NEWLINE> aa = a + 1 <NEWLINE> kotae . append ( aa ) <NEWLINE> ii = i + 1 <NEWLINE> mm = m <NEWLINE> <COMMENT> <NL> dfs ( ii , aa , tt , mm ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if m >= 0 : <NEWLINE> <INDENT> tt = t - a_l [ m ] <NEWLINE> mm = m - 1 <NEWLINE> aa = a - 1 <NEWLINE> ii = i <NEWLINE> dfs ( ii , aa , tt , mm ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , ans , time , memo ) <NEWLINE> <NL> <NL> print ( max ( kotae ) ) <NEWLINE> <NL> <NL> <NL> <NL>
a = input ( ) . split ( ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> z = [ ] <NEWLINE> a [ 0 ] = int ( a [ 0 ] ) <NEWLINE> a [ 1 ] = int ( a [ 1 ] ) <NEWLINE> a [ 2 ] = int ( a [ 2 ] ) <NEWLINE> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> b = input ( ) . split ( ) <NEWLINE> x . append ( b ) <NEWLINE> z . append ( [ ] ) <NEWLINE> <DEDENT> for i in range ( a [ 1 ] ) : <NEWLINE> <INDENT> b = input ( ) . split ( ) <NEWLINE> y . append ( b ) <NEWLINE> <DEDENT> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( a [ 2 ] ) : <NEWLINE> <INDENT> z [ i ] . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( a [ 2 ] ) : <NEWLINE> <INDENT> for k in range ( a [ 1 ] ) : <NEWLINE> <INDENT> z [ i ] [ j ] += int ( x [ i ] [ k ] ) * int ( y [ k ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( z ) ) : <NEWLINE> <INDENT> for j in range ( a [ 2 ] ) : <NEWLINE> <INDENT> z [ i ] [ j ] = str ( z [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for i in z : <NEWLINE> <INDENT> gam = <STRING> . join ( i ) <NEWLINE> print ( gam ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> num [ a ] += 1 <NEWLINE> <DEDENT> _sum = sum ( A ) <NEWLINE> <NL> result = [ ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> _sum += ( c - b ) * num [ b ] <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> result . append ( str ( _sum ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
<COMMENT> <NL> def modpow ( x , y , mod ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> z = x <NEWLINE> n = len ( bin ( y ) ) - 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( ( y >> i ) & 1 ) : <NEWLINE> <INDENT> ret = ret * z % mod <NEWLINE> <DEDENT> z = z * z % mod <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def modinv ( x , mod ) : <NEWLINE> <INDENT> return modpow ( x , mod - 2 , mod ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> c1 = 1 <NEWLINE> c2 = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> c1 = c1 * i % mod <NEWLINE> if i == k : <NEWLINE> <INDENT> c2 = modinv ( c1 , mod ) <NEWLINE> <DEDENT> <DEDENT> c3 = modinv ( c1 , mod ) <NEWLINE> c3_list = [ 0 ] * ( k + 1 ) <NEWLINE> c3_list [ k ] = c3 <NEWLINE> for i in range ( k - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> c3 = c3 * ( n - ( k - i ) ) % mod <NEWLINE> c3_list [ i ] = c3 <NEWLINE> <DEDENT> comb = ( c1 * c2 % mod ) * c3_list [ 0 ] % mod <NEWLINE> <NL> x = m * modpow ( m - 1 , n - k - 1 , mod ) % mod <NEWLINE> <NL> ret = x * comb % mod <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> c2 = c2 * ( k - i + 1 ) % mod <NEWLINE> comb = ( c1 * c2 % mod ) * c3_list [ i ] % mod <NEWLINE> x = x * ( m - 1 ) % mod <NEWLINE> <NL> ret += x * comb % mod <NEWLINE> ret %= mod <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> A [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( A [ j ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> c = r * r * math . pi <NEWLINE> cf = r * 2 * math . pi <NEWLINE> <NL> a = ( <STRING> . format ( c , cf ) ) <NEWLINE> <NL> print ( a ) <NEWLINE>
class Tree : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . left = - 1 <NEWLINE> self . right = - 1 <NEWLINE> <DEDENT> def setc ( self , c ) : <NEWLINE> <INDENT> if self . left == - 1 : <NEWLINE> <INDENT> self . left = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . right = c <NEWLINE> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = tuple ( Tree ( i ) for i in range ( n + 1 ) ) <NEWLINE> pretree = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = { a : i for i , a in enumerate ( pretree ) } <NEWLINE> inotree = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> root = pretree [ 0 ] <NEWLINE> def treeSet ( A , id ) : <NEWLINE> <INDENT> if A == [ ] : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> elif len ( A ) == 1 : <NEWLINE> <INDENT> return A [ 0 ] <NEWLINE> <DEDENT> min_A_index = A . index ( id ) <NEWLINE> global tree <NEWLINE> if 0 < min_A_index : <NEWLINE> <INDENT> min_A = min ( A [ : min_A_index ] , key = lambda x : m [ x ] ) <NEWLINE> left = treeSet ( A [ : min_A_index ] , min_A ) <NEWLINE> tree [ id ] . left = left <NEWLINE> <DEDENT> if 0 < len ( A ) - min_A_index - 1 : <NEWLINE> <INDENT> min_A = min ( A [ min_A_index + 1 : ] , key = lambda x : m [ x ] ) <NEWLINE> right = treeSet ( A [ min_A_index + 1 : ] , min_A ) <NEWLINE> tree [ id ] . right = right <NEWLINE> <DEDENT> return id <NEWLINE> <DEDENT> treeSet ( inotree , root ) <NEWLINE> ans = [ ] <NEWLINE> def postorder_tree_walk ( id ) : <NEWLINE> <INDENT> if tree [ id ] . left != - 1 : <NEWLINE> <INDENT> postorder_tree_walk ( tree [ id ] . left ) <NEWLINE> <DEDENT> if tree [ id ] . right != - 1 : <NEWLINE> <INDENT> postorder_tree_walk ( tree [ id ] . right ) <NEWLINE> <DEDENT> global ans <NEWLINE> ans . append ( id ) <NEWLINE> <DEDENT> postorder_tree_walk ( root ) <NEWLINE> print ( * ans ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> <NL> L = [ 0 ] <NEWLINE> cnt = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> L . append ( ( L [ - 1 ] + ( int ( s [ i ] ) * cnt ) ) % 2019 ) <NEWLINE> cnt *= 10 <NEWLINE> cnt %= 2019 <NEWLINE> <NL> <DEDENT> D = dict ( ) <NEWLINE> for j in L : <NEWLINE> <INDENT> if j in D : <NEWLINE> <INDENT> D [ j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in D . values ( ) : <NEWLINE> <INDENT> ans += k * ( k - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = 100 <NEWLINE> d = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> val = ( i * i ) + ( j * j ) + ( k * k ) + ( i * j ) + ( j * k ) + ( k * i ) <NEWLINE> if val > n : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> d [ val ] = d [ val ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AB = A + B <NEWLINE> NumABalls = 0 <NEWLINE> <NL> NumABalls = N // AB * A <NEWLINE> M = N % AB <NEWLINE> <NL> if A - M >= 0 : <NEWLINE> <INDENT> NumABalls += M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NumABalls += A <NEWLINE> <NL> <DEDENT> print ( NumABalls ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m != 0 : <NEWLINE> <INDENT> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> s , c = [ list ( i ) for i in zip ( * l ) ] <NEWLINE> <DEDENT> z = [ <STRING> ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if z [ s [ i ] - 1 ] == <STRING> : <NEWLINE> <INDENT> z [ s [ i ] - 1 ] = str ( c [ i ] ) <NEWLINE> <DEDENT> elif z [ s [ i ] - 1 ] == str ( c [ i ] ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> if z [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( z [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if z [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if z [ 0 ] == <STRING> : <NEWLINE> <INDENT> z [ 0 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if z [ i ] == <STRING> : <NEWLINE> <INDENT> z [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( z ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> result = sum ( list ( map ( int , str ( N ) ) ) ) <NEWLINE> if result % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> import queue <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> y , yy = map ( int , input ( ) . split ( ) ) <NEWLINE> y -= 1 <NEWLINE> yy -= 1 <NEWLINE> G [ y ] . append ( yy ) <NEWLINE> G [ yy ] . append ( y ) <NEWLINE> <NL> <DEDENT> q = queue . Queue ( ) <NEWLINE> <NL> vis = [ 0 ] * n <NEWLINE> mae = [ - 1 ] * n <NEWLINE> <NL> q . put ( [ 0 , 0 ] ) <NEWLINE> while q . empty ( ) == False : <NEWLINE> <INDENT> r = q . get ( ) <NEWLINE> if vis [ r [ 0 ] ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> vis [ r [ 0 ] ] = 1 <NEWLINE> mae [ r [ 0 ] ] = r [ 1 ] <NEWLINE> for v in G [ r [ 0 ] ] : <NEWLINE> <INDENT> if vis [ v ] == 0 : <NEWLINE> <INDENT> q . put ( [ v , r [ 0 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( mae [ i ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = None <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> ans = A [ : : 2 ] [ : : - 1 ] + A [ 1 : : 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 1 : : 2 ] [ : : - 1 ] + A [ : : 2 ] <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <STRING> <NEWLINE> <NL> import functools <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import logging <NEWLINE> import math <NEWLINE> import random <NEWLINE> import string <NEWLINE> import sys <NEWLINE> from argparse import ArgumentParser <NEWLINE> from collections import defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from typing import Dict , List , Optional , Set , Tuple <NEWLINE> <NL> <NL> def solve ( s : str ) -> int : <NEWLINE> <INDENT> modulo = 2019 <NEWLINE> remainders = defaultdict ( int , { 0 : 1 } ) <NEWLINE> power = 1 <NEWLINE> curr = 0 <NEWLINE> LOG . debug ( ( s ) ) <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> c = int ( s [ i ] ) <NEWLINE> curr = ( power * int ( c ) + curr ) % modulo <NEWLINE> power = ( power * 10 ) % modulo <NEWLINE> remainders [ curr ] += 1 <NEWLINE> <DEDENT> result = 0 <NEWLINE> for i in remainders . values ( ) : <NEWLINE> <INDENT> result += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> LOG . debug ( ( remainders ) ) <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> def do_job ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> LOG . debug ( <STRING> ) <NEWLINE> <COMMENT> <NL> S = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> result = solve ( S ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> def print_output ( testcase : int , result ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> if result is None : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( testcase + 1 , result ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def configure_log ( ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> log_formatter = logging . Formatter ( <STRING> <STRING> ) <NEWLINE> handler = logging . StreamHandler ( sys . stdout ) <NEWLINE> handler . setFormatter ( log_formatter ) <NEWLINE> LOG . addHandler ( handler ) <NEWLINE> <NL> <NL> <DEDENT> LOG = None <NEWLINE> <COMMENT> <NL> if not LOG : <NEWLINE> <INDENT> LOG = logging . getLogger ( <STRING> ) <NEWLINE> configure_log ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( argv = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if argv is None : <NEWLINE> <INDENT> argv = sys . argv [ 1 : ] <NEWLINE> <DEDENT> parser = ArgumentParser ( ) <NEWLINE> parser . add_argument ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> dest = <STRING> , <NEWLINE> action = <STRING> , <NEWLINE> default = False , <NEWLINE> help = <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE> args = parser . parse_args ( argv ) <NEWLINE> if args . verbose : <NEWLINE> <INDENT> LOG . setLevel ( logging . DEBUG ) <NEWLINE> <DEDENT> do_job ( ) <NEWLINE> return 0 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import doctest <NEWLINE> <NL> doctest . testmod ( ) <NEWLINE> sys . exit ( main ( ) ) <NEWLINE> <NL> <NL> <DEDENT> class memoized : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , func ) : <NEWLINE> <INDENT> self . func = func <NEWLINE> self . cache = { } <NEWLINE> <NL> <DEDENT> def __call__ ( self , * args ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . cache [ args ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> value = self . func ( * args ) <NEWLINE> self . cache [ args ] = value <NEWLINE> return value <NEWLINE> <DEDENT> except TypeError : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return self . func ( * args ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . func . __doc__ <NEWLINE> <NL> <DEDENT> def __get__ ( self , obj , objtype ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return functools . partial ( self . __call__ , obj ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <NL> def sieve ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> prime_list = [ ] <NEWLINE> <NL> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> prime_list . append ( 2 ) <NEWLINE> <NL> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if is_prime [ i ] : prime_list . append ( i ) <NEWLINE> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return prime_list <NEWLINE> <NL> <DEDENT> primes = sieve ( 40000 ) <NEWLINE> <NL> def factoriaztion ( n ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for prime in primes : <NEWLINE> <INDENT> while n % prime == 0 : <NEWLINE> <INDENT> ret . append ( prime ) <NEWLINE> n /= prime <NEWLINE> <DEDENT> if n == 1 : break <NEWLINE> <DEDENT> if n > 1 : ret . append ( n ) <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) <NEWLINE> n = int ( n ) <NEWLINE> factors = factoriaztion ( n ) <NEWLINE> factors = itertools . groupby ( factors ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for k , v in factors : <NEWLINE> <INDENT> l = len ( list ( v ) ) <NEWLINE> ans = ans * ( k ** l - k ** ( l - 1 ) ) <NEWLINE> <NL> <DEDENT> sys . stdout . write ( str ( ans ) + <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * 100005 <NEWLINE> s = sum ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( C - B ) * cnt [ B ] <NEWLINE> print ( s ) <NEWLINE> cnt [ C ] += cnt [ B ] <NEWLINE> cnt [ B ] = 0 <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> numlista = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import collections <NEWLINE> numkosuu = collections . Counter ( numlista ) <NEWLINE> suma = 0 <NEWLINE> for i in numlista : <NEWLINE> <INDENT> suma += i <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> suma += ( c - b ) * numkosuu [ b ] <NEWLINE> <COMMENT> <NL> numkosuu [ c ] += numkosuu [ b ] <NEWLINE> numkosuu [ b ] = 0 <NEWLINE> print ( suma ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x * y , 2 * ( x + y ) ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> import scipy as sp <NEWLINE> import queue <NEWLINE> import collections <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> <NL> def main ( kwargs ) : <NEWLINE> <INDENT> k = kwargs [ <STRING> ] <NEWLINE> res = 0 <NEWLINE> p = 7 <NEWLINE> rs = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> res += 1 <NEWLINE> r = p % k <NEWLINE> rs += r <NEWLINE> if rs % k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if r == 0 or res > 1000000 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> p = r * 10 <NEWLINE> <NL> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> kwargs = { } <NEWLINE> <NL> cin = input ( ) . split ( ) <NEWLINE> kwargs [ <STRING> ] = [ int ( i ) for i in cin ] [ 0 ] <NEWLINE> <NL> cout = main ( kwargs ) <NEWLINE> print ( cout ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> s1 = set ( ) <NEWLINE> s2 = set ( ) <NEWLINE> s3 = set ( ) <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> for j in s2 : <NEWLINE> <INDENT> s3 . add ( j + i ) <NEWLINE> <DEDENT> for k in s1 : <NEWLINE> <INDENT> s2 . add ( k + i ) <NEWLINE> <DEDENT> s1 . add ( i ) <NEWLINE> <DEDENT> print ( len ( s3 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> L , R = { } , { } <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> l , r = i + a , i - a <NEWLINE> if l not in L : L [ l ] = 0 <NEWLINE> if r not in R : R [ r ] = 0 <NEWLINE> L [ l ] += 1 <NEWLINE> R [ r ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for X in L : <NEWLINE> <INDENT> if X not in R : continue <NEWLINE> count += L [ X ] * R [ X ] <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> cnt = [ 0 ] * ( a [ - 1 ] + 1 ) <NEWLINE> <COMMENT> <NL> for x in a : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( x , a [ - 1 ] + 1 , x ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> cnt [ i ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if cnt [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
NIL = - 1 <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> parent = NIL <NEWLINE> left = NIL <NEWLINE> right = NIL <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> t = [ Node ( ) for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> id = tmp . pop ( 0 ) <NEWLINE> k = tmp . pop ( 0 ) <NEWLINE> c = tmp <NEWLINE> if k != 0 : <NEWLINE> <INDENT> for j in c : <NEWLINE> <INDENT> t [ j ] . parent = id <NEWLINE> <DEDENT> t [ id ] . left = c [ 0 ] <NEWLINE> for j in range ( len ( c ) - 1 ) : <NEWLINE> <INDENT> t [ c [ j ] ] . right = c [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def getdepth ( u ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> while t [ u ] . parent != NIL : <NEWLINE> <INDENT> u = t [ u ] . parent <NEWLINE> d += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def getchildren ( u ) : <NEWLINE> <INDENT> c = t [ u ] . left <NEWLINE> result = [ ] <NEWLINE> while c != NIL : <NEWLINE> <INDENT> result . append ( c ) <NEWLINE> c = t [ c ] . right <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d = getdepth ( i ) <NEWLINE> c = getchildren ( i ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> v = <STRING> <NEWLINE> <DEDENT> elif c == [ ] : <NEWLINE> <INDENT> v = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( i , t [ i ] . parent , d , v , <STRING> . join ( map ( str , c ) ) ) ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> ans += h [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) [ 0 ] for _ in range ( n ) ] <NEWLINE> cnt = Counter ( s ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for x , y , z in itertools . combinations ( <STRING> , 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += cnt [ x ] * cnt [ y ] * cnt [ z ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> ss = sorted ( s ) <NEWLINE> count = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ss [ i ] != ss [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> kabu = 0 <NEWLINE> money = 1000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> money += kabu * a [ i ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> elif a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> if money >= a [ i ] : <NEWLINE> <INDENT> kabu = money // a [ i ] <NEWLINE> money = money - a [ i ] * kabu <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> money += kabu * a [ i ] <NEWLINE> kabu = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def dfs ( v ) : <NEWLINE> <INDENT> path . append ( v ) <NEWLINE> visited [ v ] = 1 <NEWLINE> nv = A [ v ] <NEWLINE> if visited [ nv ] == 1 : <NEWLINE> <INDENT> return nv <NEWLINE> <DEDENT> return dfs ( nv ) <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> visited = [ 0 ] * N <NEWLINE> path = [ ] <NEWLINE> cycle_start = dfs ( 0 ) <NEWLINE> cycle_len = len ( path ) - path . index ( cycle_start ) <NEWLINE> head_len = len ( path ) - cycle_len <NEWLINE> if K <= head_len : <NEWLINE> <INDENT> print ( path [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= head_len <NEWLINE> print ( path [ head_len + K % cycle_len ] + 1 ) <NEWLINE> <DEDENT>
def test ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> N = 10000 <NEWLINE> print ( N ) <NEWLINE> A = np . random . randint ( 0 , 10 , [ N ] ) <NEWLINE> print ( count ( N , A ) ) <NEWLINE> <NL> <NL> <DEDENT> def count ( N , A ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> left = dict ( ) <NEWLINE> right = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = i + 1 + A [ i ] <NEWLINE> r = i + 1 - A [ i ] <NEWLINE> left [ l ] = left . get ( l , 0 ) + 1 <NEWLINE> right [ r ] = right . get ( r , 0 ) + 1 <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> for k , v in left . items ( ) : <NEWLINE> <INDENT> if k in right : <NEWLINE> <INDENT> counter += right [ k ] * v <NEWLINE> <NL> <DEDENT> <DEDENT> return counter <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = count ( N , A ) <NEWLINE> print ( result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> Tr = [ 0 for _ in range ( H + 1 ) ] <NEWLINE> Tc = [ 0 for _ in range ( W + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> Tr [ s [ i ] [ 0 ] ] += 1 <NEWLINE> Tc [ s [ i ] [ 1 ] ] += 1 <NEWLINE> <DEDENT> mr = max ( Tr ) <NEWLINE> mc = max ( Tc ) <NEWLINE> Mr = [ 0 for _ in range ( H + 1 ) ] <NEWLINE> Mc = [ 0 for _ in range ( W + 1 ) ] <NEWLINE> Nmr = 0 <NEWLINE> Nmc = 0 <NEWLINE> for i in range ( len ( Tr ) ) : <NEWLINE> <INDENT> if Tr [ i ] == mr : <NEWLINE> <INDENT> Mr [ i ] = 1 <NEWLINE> Nmr += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( Tc ) ) : <NEWLINE> <INDENT> if Tc [ i ] == mc : <NEWLINE> <INDENT> Mc [ i ] = 1 <NEWLINE> Nmc += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if Mr [ s [ i ] [ 0 ] ] == 1 and Mc [ s [ i ] [ 1 ] ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt < Nmr * Nmc : <NEWLINE> <INDENT> print ( mr + mc ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mr + mc - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <DEDENT> S = sum ( A ) <NEWLINE> NUM = [ 0 ] * 100005 <NEWLINE> for a in A : <NEWLINE> <INDENT> NUM [ a ] += 1 <NEWLINE> <DEDENT> for k in range ( Q ) : <NEWLINE> <INDENT> S += ( C [ k ] - B [ k ] ) * ( NUM [ B [ k ] ] ) <NEWLINE> NUM [ C [ k ] ] += NUM [ B [ k ] ] <NEWLINE> NUM [ B [ k ] ] = 0 <NEWLINE> print ( S ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> <NL> def dfs ( now ) : <NEWLINE> <INDENT> seen [ now ] = True <NEWLINE> score [ now ] += operation [ now ] <NEWLINE> for next in branch [ now ] : <NEWLINE> <INDENT> if seen [ next ] is False : <NEWLINE> <INDENT> score [ next ] += score [ now ] <NEWLINE> dfs ( next ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> branch = [ set ( ) for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> branch [ a - 1 ] . add ( b - 1 ) <NEWLINE> branch [ b - 1 ] . add ( a - 1 ) <NEWLINE> <DEDENT> operation = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> operation [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> seen = [ False ] * N <NEWLINE> score = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if seen [ i ] is False : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for ans in score : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> j , ans = m , 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> L = len ( s ) <NEWLINE> dict = [ 0 ] * 2019 <NEWLINE> dict [ 0 ] += 1 <NEWLINE> num = 0 <NEWLINE> for i in range ( L - 1 , ( - 1 ) , ( - 1 ) ) : <NEWLINE> <INDENT> num += ( int ( s [ i ] ) * pow ( 10 , ( L - i - 1 ) , 2019 ) ) % 2019 <NEWLINE> amari = num % 2019 <NEWLINE> dict [ amari ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for j in range ( 2019 ) : <NEWLINE> <INDENT> ans += ( dict [ j ] * ( dict [ j ] - 1 ) ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> <NL> def enum_prime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return [ 2 ] <NEWLINE> <DEDENT> L = list ( range ( 2 , n + 1 ) ) <NEWLINE> PL = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> PL . append ( L [ 0 ] ) <NEWLINE> L = [ i for i in L if i % PL [ - 1 ] != 0 ] <NEWLINE> if L [ - 1 ] < PL [ - 1 ] ** 2 : <NEWLINE> <INDENT> return PL + L <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> primelist = enum_prime ( 999999 ) <NEWLINE> for line in stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> cnt = 0 <NEWLINE> for p in primelist : <NEWLINE> <INDENT> if n < p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if ( a == 1 and b == 2 ) or ( a == 2 and b == 1 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( a == 2 and b == 3 ) or ( a == 3 and b == 2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( a == 1 and b == 3 ) or ( a == 3 and b == 1 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if A == 0 and B == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif A == 1 and B == 0 : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif A == 0 and B == 1 : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif A == 1 and B == 1 and i < N - 1 : <NEWLINE> <INDENT> if <STRING> in S [ i + 1 ] : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif A > B : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if A == 0 and C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif A == 1 and C == 0 : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif A == 0 and C == 1 : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif A == 1 and C == 1 and i < N - 1 : <NEWLINE> <INDENT> if <STRING> in S [ i + 1 ] : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif A > C : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if B == 0 and C == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif B == 1 and C == 0 : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif B == 0 and C == 1 : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif B == 1 and C == 1 and i < N - 1 : <NEWLINE> <INDENT> if <STRING> in S [ i + 1 ] : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif B > C : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for c in ans : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A_ls = [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_ls [ i + 1 ] += A_ls [ i ] <NEWLINE> <DEDENT> B_ls = [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B_ls [ i + 1 ] += B_ls [ i ] <NEWLINE> <NL> <DEDENT> a_cnt , b_cnt , rst = 0 , M , 0 <NEWLINE> for a_cnt in range ( N + 1 ) : <NEWLINE> <INDENT> if A_ls [ a_cnt ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A_ls [ a_cnt ] + B_ls [ b_cnt ] > K and b_cnt > 0 : <NEWLINE> <INDENT> b_cnt -= 1 <NEWLINE> <DEDENT> rst = max ( rst , a_cnt + b_cnt ) <NEWLINE> <DEDENT> print ( rst ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> N , K = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> ls = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> ans = set ( ) <NEWLINE> ls = sorted ( ls , key = lambda x : - abs ( x ) ) <NEWLINE> mul = 1 <NEWLINE> sign = 0 <NEWLINE> zeroflag = 0 <NEWLINE> flag = [ 0 for _ in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> flag [ i ] = 1 <NEWLINE> if ls [ i ] < 0 : <NEWLINE> <INDENT> sign = ( sign + 1 ) % 2 <NEWLINE> <DEDENT> <DEDENT> if sign == 1 : <NEWLINE> <INDENT> if 0 in ls : <NEWLINE> <INDENT> zeroflag = 1 <NEWLINE> <DEDENT> a = [ 0 , 0 , 0 , 0 ] <NEWLINE> b = [ 0 , 0 , 0 , 0 ] <NEWLINE> for j in range ( K , N ) : <NEWLINE> <INDENT> if ls [ j ] > 0 : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> if ls [ K - 1 - k ] < 0 : <NEWLINE> <INDENT> a [ 0 ] = ls [ j ] <NEWLINE> b [ 0 ] = j <NEWLINE> a [ 1 ] = ls [ K - 1 - k ] <NEWLINE> b [ 1 ] = K - 1 - k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( K , N ) : <NEWLINE> <INDENT> if ls [ j ] < 0 : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> if ls [ K - 1 - k ] > 0 : <NEWLINE> <INDENT> a [ 2 ] = ls [ j ] <NEWLINE> b [ 2 ] = j <NEWLINE> a [ 3 ] = ls [ K - 1 - k ] <NEWLINE> b [ 3 ] = K - 1 - k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> if a == [ 0 , 0 , 0 , 0 ] : <NEWLINE> <INDENT> flag . reverse ( ) <NEWLINE> <DEDENT> elif b [ 0 ] == 0 and b [ 1 ] == 0 : <NEWLINE> <INDENT> flag [ b [ 2 ] ] = 1 <NEWLINE> flag [ b [ 3 ] ] = 0 <NEWLINE> <DEDENT> elif b [ 2 ] == 0 and b [ 3 ] == 0 : <NEWLINE> <INDENT> flag [ b [ 0 ] ] = 1 <NEWLINE> flag [ b [ 1 ] ] = 0 <NEWLINE> <DEDENT> elif abs ( a [ 0 ] * a [ 3 ] ) > abs ( a [ 1 ] * a [ 2 ] ) : <NEWLINE> <INDENT> flag [ b [ 0 ] ] = 1 <NEWLINE> flag [ b [ 1 ] ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ b [ 2 ] ] = 1 <NEWLINE> flag [ b [ 3 ] ] = 0 <NEWLINE> <DEDENT> <DEDENT> if sign == 1 and a == [ 0 , 0 , 0 , 0 ] and zeroflag == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if flag [ i ] == 1 : <NEWLINE> <INDENT> mul = mul * ls [ i ] % MOD <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> s = sum <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> res = ( res + s * a [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = set ( ) <NEWLINE> sum_h = [ 0 ] * W <NEWLINE> sum_w = [ 0 ] * H <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> hw . add ( ( h , w ) ) <NEWLINE> h -= 1 <NEWLINE> w -= 1 <NEWLINE> sum_h [ w ] += 1 <NEWLINE> sum_w [ h ] += 1 <NEWLINE> <NL> <NL> <DEDENT> max_h = max ( sum_h ) <NEWLINE> max_w = max ( sum_w ) <NEWLINE> <NL> new_H = [ h for h in range ( H ) if sum_w [ h ] == max_w ] <NEWLINE> new_W = [ w for w in range ( W ) if sum_h [ w ] == max_h ] <NEWLINE> <NL> max_num = max_h + max_w - 1 <NEWLINE> for i in new_H : <NEWLINE> <INDENT> for j in new_W : <NEWLINE> <INDENT> if ( i + 1 , j + 1 ) not in hw : <NEWLINE> <INDENT> print ( max_h + max_w ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_num ) <NEWLINE>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if not x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> INF = 10 ** 12 <NEWLINE> LIM = 20 <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = dict ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s , c = input ( ) . split ( ) <NEWLINE> if s in D . keys ( ) : <NEWLINE> <INDENT> D [ s ] = min ( D [ s ] , int ( c ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ s ] = int ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> def check_kaibun ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> return all ( s [ i ] == s [ - i - 1 ] for i in range ( n // 2 ) ) <NEWLINE> <NL> <DEDENT> def calc_cost ( use ) : <NEWLINE> <INDENT> return sum ( D [ s ] * n for ( s , n ) in use . items ( ) ) <NEWLINE> <NL> <DEDENT> def find_candidate ( cost , use , s , is_left ) : <NEWLINE> <INDENT> if check_kaibun ( s ) : <NEWLINE> <INDENT> return min ( cost , calc_cost ( use ) ) <NEWLINE> <NL> <DEDENT> if is_left : <NEWLINE> <INDENT> for t in D . keys ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> if t [ : : - 1 ] . find ( s ) == 0 : <NEWLINE> <INDENT> use [ t ] += 1 <NEWLINE> if use [ t ] > LIM : <NEWLINE> <INDENT> return INF <NEWLINE> <DEDENT> c = find_candidate ( cost , use , t [ : - len ( s ) : ] , False ) <NEWLINE> cost = min ( cost , c ) <NEWLINE> use [ t ] -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif s . find ( t [ : : - 1 ] ) == 0 : <NEWLINE> <INDENT> use [ t ] += 1 <NEWLINE> c = find_candidate ( cost , use , s [ len ( t ) : ] , True ) <NEWLINE> cost = min ( cost , c ) <NEWLINE> use [ t ] -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for t in D . keys ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ : : - 1 ] . find ( t ) == 0 : <NEWLINE> <INDENT> use [ t ] += 1 <NEWLINE> c = find_candidate ( cost , use , s [ : - len ( t ) : ] , False ) <NEWLINE> cost = min ( cost , c ) <NEWLINE> use [ t ] -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif t . find ( s [ : : - 1 ] ) == 0 : <NEWLINE> <INDENT> use [ t ] += 1 <NEWLINE> c = find_candidate ( cost , use , t [ len ( s ) : ] , True ) <NEWLINE> cost = min ( cost , c ) <NEWLINE> use [ t ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return min ( cost , INF ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> ans = INF <NEWLINE> for s in D . keys ( ) : <NEWLINE> <INDENT> use = { s : 0 for s in D . keys ( ) } <NEWLINE> use [ s ] = 1 <NEWLINE> ans = find_candidate ( ans , use , s , True ) <NEWLINE> <DEDENT> return ans if ans < INF else - 1 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( ) ) <NEWLINE> <DEDENT>
class RSQ : <NEWLINE> <INDENT> def __init__ ( self , length , ini_num = float ( <STRING> ) ) : <NEWLINE> <INDENT> self . length = 1 <NEWLINE> self . ini_num = ini_num <NEWLINE> if length == 1 : <NEWLINE> <INDENT> length = 2 <NEWLINE> <DEDENT> while self . length < length : <NEWLINE> <INDENT> self . length <<= 1 <NEWLINE> <DEDENT> self . segtree = [ ini_num ] * ( 2 * self . length - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , index , num ) : <NEWLINE> <INDENT> leaf_index = index + self . length - 1 <NEWLINE> self . segtree [ leaf_index ] = num <NEWLINE> while leaf_index > 0 : <NEWLINE> <INDENT> leaf_index = ( leaf_index - 1 ) // 2 <NEWLINE> self . segtree [ leaf_index ] = self . segtree [ 2 * leaf_index + 1 ] + self . segtree [ 2 * leaf_index + 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def add ( self , index , num ) : <NEWLINE> <INDENT> leaf_index = index + self . length - 1 <NEWLINE> self . segtree [ leaf_index ] += num <NEWLINE> while leaf_index > 0 : <NEWLINE> <INDENT> leaf_index = ( leaf_index - 1 ) // 2 <NEWLINE> self . segtree [ leaf_index ] = self . segtree [ 2 * leaf_index + 1 ] + self . segtree [ 2 * leaf_index + 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def call_search ( self , a , b ) : <NEWLINE> <INDENT> return self . search ( a , b , index = 0 , l = 0 , r = self . length - 1 ) <NEWLINE> <NL> <DEDENT> def search ( self , a , b , index , l , r ) : <NEWLINE> <INDENT> if a <= l <= r <= b : <NEWLINE> <INDENT> return self . segtree [ index ] <NEWLINE> <DEDENT> elif r < a or b < l : <NEWLINE> <INDENT> return self . ini_num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . search ( a , b , index * 2 + 1 , l , ( l + r ) // 2 ) + self . search ( a , b , index * 2 + 2 , ( l + r ) // 2 + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> v_num , query = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> rsq = RSQ ( v_num , 0 ) <NEWLINE> for _ in range ( query ) : <NEWLINE> <INDENT> comm , index , num = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if comm == 0 : <NEWLINE> <INDENT> rsq . add ( index - 1 , num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( rsq . call_search ( index - 1 , num - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
from scipy . special import comb <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> sdict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> inp = <STRING> . join ( sorted ( list ( input ( ) ) ) ) <NEWLINE> if inp not in sdict : <NEWLINE> <INDENT> sdict . update ( { inp : 1 } ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sdict [ inp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for key in sdict : <NEWLINE> <INDENT> ans += comb ( sdict [ key ] , 2 , exact = True ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> seq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> mlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mins = min ( seq ) <NEWLINE> sums = 0 <NEWLINE> for a in seq : <NEWLINE> <INDENT> sums += a <NEWLINE> <NL> <DEDENT> def check ( i , m ) : <NEWLINE> <INDENT> global mins <NEWLINE> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif i >= n or mins > m : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = check ( i + 1 , m ) or check ( i + 1 , m - seq [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for m in mlist : <NEWLINE> <INDENT> if ( mins > m or sums < m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( check ( 0 , m ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mul = 1 <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> mul *= A [ i ] <NEWLINE> if mul == 0 or mul > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = a * b <NEWLINE> l = 2 * a + 2 * b <NEWLINE> <NL> print ( s , l ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> SUM = 0 <NEWLINE> numbers = [ 0 ] * 100001 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> numbers [ a ] += 1 <NEWLINE> SUM += a <NEWLINE> <NL> <DEDENT> B = [ 0 ] * Q <NEWLINE> C = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b = B [ i ] <NEWLINE> c = C [ i ] <NEWLINE> <NL> SUM = SUM - b * numbers [ b ] <NEWLINE> SUM = SUM + c * numbers [ b ] <NEWLINE> numbers [ c ] += numbers [ b ] <NEWLINE> numbers [ b ] = 0 <NEWLINE> print ( SUM ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> bc = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( Q ) ] <NEWLINE> <NL> counter = [ 0 ] * 1000000 <NEWLINE> for i in a : <NEWLINE> <INDENT> counter [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( a ) <NEWLINE> <NL> for _ in bc : <NEWLINE> <INDENT> ans = ans + counter [ _ [ 0 ] ] * _ [ 1 ] - counter [ _ [ 0 ] ] * _ [ 0 ] <NEWLINE> counter [ _ [ 1 ] ] += counter [ _ [ 0 ] ] <NEWLINE> counter [ _ [ 0 ] ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <COMMENT> <NL> int1 = lambda x : int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> <NL> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> S = S [ : : - 1 ] <NEWLINE> <COMMENT> <NL> n = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> <NL> <COMMENT> <NL> A = [ 0 ] * ( n ) <NEWLINE> a = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = S [ i ] * a <NEWLINE> a = a * 10 % mod <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> R = [ 0 ] * ( n + 1 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> R [ j + 1 ] = ( R [ j ] + A [ j ] ) % mod <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> cnt = { } <NEWLINE> ans = 0 <NEWLINE> for l in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> r = R [ l ] <NEWLINE> ans = ans + cnt . get ( r , 0 ) <NEWLINE> cnt [ r ] = cnt . setdefault ( r , 0 ) + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] <NEWLINE> <NL> <COMMENT> <NL> if c [ 0 ] [ 0 ] + c [ 1 ] [ 1 ] == c [ 0 ] [ 1 ] + c [ 1 ] [ 0 ] : <NEWLINE> <INDENT> if c [ 0 ] [ 1 ] + c [ 1 ] [ 2 ] == c [ 0 ] [ 2 ] + c [ 1 ] [ 1 ] : <NEWLINE> <INDENT> if c [ 1 ] [ 0 ] + c [ 2 ] [ 1 ] == c [ 1 ] [ 1 ] + c [ 2 ] [ 0 ] : <NEWLINE> <INDENT> if c [ 1 ] [ 1 ] + c [ 2 ] [ 2 ] == c [ 1 ] [ 2 ] + c [ 2 ] [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> l , r = LI ( ) <NEWLINE> m = 2019 <NEWLINE> <NL> end = min ( l + 2019 , r ) <NEWLINE> <NL> ar = [ ] <NEWLINE> for i in range ( l , end ) : <NEWLINE> <INDENT> for j in range ( i + 1 , end + 1 ) : <NEWLINE> <INDENT> ar . append ( ( i * j ) % m ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( ar ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
s = input ( ) <NEWLINE> s_rev = s [ : : - 1 ] <NEWLINE> <NL> mod_count = [ 0 ] * 2019 <NEWLINE> mod_count [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> num = 0 <NEWLINE> <NL> for char in s_rev : <NEWLINE> <INDENT> num = num + int ( char ) * d <NEWLINE> num = num % 2019 <NEWLINE> d = d * 10 <NEWLINE> d = d % 2019 <NEWLINE> <COMMENT> <NL> mod_count [ num ] = mod_count [ num ] + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in mod_count : <NEWLINE> <INDENT> ans = ans + cnt * ( cnt - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import collections <NEWLINE> <NL> def prime_decomposition ( n ) : <NEWLINE> <INDENT> prime_factors = [ ] <NEWLINE> if n < 2 : <NEWLINE> <INDENT> return prime_factors <NEWLINE> <DEDENT> while n >= 2 and n % 2 == 0 : <NEWLINE> <INDENT> prime_factors . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> prime_factors . append ( i ) <NEWLINE> n //= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> prime_factors . append ( n ) <NEWLINE> <DEDENT> return prime_factors <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> freq = collections . Counter ( prime_decomposition ( n ) ) <NEWLINE> ans = n <NEWLINE> for k , v in freq . items ( ) : <NEWLINE> <INDENT> ans *= ( 1 - 1 / k ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> tmp = <STRING> <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> chtmp = ord ( S [ i ] ) + N <NEWLINE> if ( chtmp > ord ( <STRING> ) ) : <NEWLINE> <INDENT> chtmp -= ( ord ( <STRING> ) - ord ( <STRING> ) + 1 ) <NEWLINE> <DEDENT> tmp += chr ( chtmp ) <NEWLINE> <DEDENT> print ( tmp ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> N , M , K = LI ( ) <NEWLINE> A = LI ( ) <NEWLINE> B = LI ( ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ - 1 ] + B [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> col = collections . Counter ( l_a ) <NEWLINE> bef = sum ( l_a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> bef += ( c - b ) * col [ b ] <NEWLINE> ans . append ( bef ) <NEWLINE> col [ c ] += col [ b ] <NEWLINE> col [ b ] = 0 <NEWLINE> <NL> <DEDENT> for value in ans : <NEWLINE> <INDENT> print ( value ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import mul <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import heapq <NEWLINE> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 10 <NEWLINE> dp = [ INF ] * ( n + 5 ) <NEWLINE> dp [ 1 ] = 0 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> temp = [ dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( i - 1 , max ( 0 , i - k - 1 ) , - 1 ) ] <NEWLINE> dp [ i ] = min ( temp ) <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ <STRING> ] <NEWLINE> for i in b : <NEWLINE> <INDENT> l . insert ( i - 1 , i ) <NEWLINE> <DEDENT> print ( * l [ - 1 ] and [ - 1 ] or l , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> is_prime = [ True for _ in range ( 1100000 ) ] <NEWLINE> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> <NL> for i in range ( 2 , 1100000 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : continue <NEWLINE> for j in range ( i * i , 1100000 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> g = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> g = math . gcd ( g , a ) <NEWLINE> <NL> <DEDENT> if g != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> used = [ False for _ in range ( 1100000 ) ] <NEWLINE> primes = [ a for a in A if is_prime [ a ] ] <NEWLINE> not_primes = [ a for a in A if not is_prime [ a ] ] <NEWLINE> <NL> for p in primes : <NEWLINE> <INDENT> used [ p ] = True <NEWLINE> <NL> <DEDENT> small_prime = [ p for p in range ( 1100 ) if is_prime [ p ] ] <NEWLINE> for a in not_primes : <NEWLINE> <INDENT> for p in small_prime : <NEWLINE> <INDENT> if a == 1 : break <NEWLINE> if a % p != 0 : continue <NEWLINE> if used [ p ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> used [ p ] = True <NEWLINE> while a % p == 0 : <NEWLINE> <INDENT> a //= p <NEWLINE> <DEDENT> <DEDENT> if a > 1 : <NEWLINE> <INDENT> if used [ a ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> used [ a ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> y , x = map ( int , input ( ) . split ( ) ) <NEWLINE> start = ( x + 1 , y + 1 ) <NEWLINE> <NL> y , x = map ( int , input ( ) . split ( ) ) <NEWLINE> goal = ( x + 1 , y + 1 ) <NEWLINE> <NL> dist_table = [ [ - 2 ] * ( W + 4 ) ] <NEWLINE> dist_table . append ( [ - 2 ] * ( W + 4 ) ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> row = <STRING> + input ( ) + <STRING> <NEWLINE> row = [ - 1 if c == <STRING> else - 2 for c in row ] <NEWLINE> dist_table . append ( row ) <NEWLINE> <DEDENT> dist_table . append ( [ - 2 ] * ( W + 4 ) ) <NEWLINE> dist_table . append ( [ - 2 ] * ( W + 4 ) ) <NEWLINE> <NL> <NL> <NL> sx , sy = start <NEWLINE> dist_table [ sy ] [ sx ] = 0 <NEWLINE> <NL> move1 = ( ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) <NEWLINE> move2 = ( ( - 2 , - 2 ) , ( - 2 , - 1 ) , ( - 2 , 0 ) , ( - 2 , 1 ) , ( - 2 , 2 ) , ( - 1 , - 2 ) , ( - 1 , - 1 ) , ( - 1 , 1 ) , ( - 1 , 2 ) , ( 0 , - 2 ) , ( 0 , 2 ) , ( 1 , - 2 ) , ( 1 , - 1 ) , ( 1 , 1 ) , ( 1 , 2 ) , ( 2 , - 2 ) , ( 2 , - 1 ) , ( 2 , 0 ) , ( 2 , 1 ) , ( 2 , 2 ) ) <NEWLINE> <NL> queue1 = [ start ] <NEWLINE> queue2 = [ ] <NEWLINE> <NL> while queue1 : <NEWLINE> <INDENT> now_x , now_y = queue1 . pop ( ) <NEWLINE> if ( now_x , now_y ) == goal : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> queue2 . append ( ( now_x , now_y ) ) <NEWLINE> dist = dist_table [ now_y ] [ now_x ] <NEWLINE> for dx , dy in move1 : <NEWLINE> <INDENT> tx , ty = now_x + dx , now_y + dy <NEWLINE> if dist_table [ ty ] [ tx ] == - 1 : <NEWLINE> <INDENT> dist_table [ ty ] [ tx ] = dist <NEWLINE> queue1 . append ( ( tx , ty ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( queue1 ) == 0 : <NEWLINE> <INDENT> while queue2 : <NEWLINE> <INDENT> now_x , now_y = queue2 . pop ( ) <NEWLINE> dist = dist_table [ now_y ] [ now_x ] <NEWLINE> for dx , dy in move2 : <NEWLINE> <INDENT> tx , ty = now_x + dx , now_y + dy <NEWLINE> if dist_table [ ty ] [ tx ] == - 1 : <NEWLINE> <INDENT> dist_table [ ty ] [ tx ] = dist + 1 <NEWLINE> queue1 . append ( ( tx , ty ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> gx , gy = goal <NEWLINE> print ( dist_table [ gy ] [ gx ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> l . sort ( ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for s in range ( j + 1 , n ) : <NEWLINE> <INDENT> if l [ i ] != l [ j ] and l [ j ] != l [ s ] and l [ i ] != l [ s ] : <NEWLINE> <INDENT> if l [ i ] < l [ j ] + l [ s ] and l [ j ] < l [ i ] + l [ s ] and l [ s ] < l [ i ] + l [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> b [ - 1 ] = a [ - 1 ] <NEWLINE> total = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( n - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> b [ i ] = a [ i ] + b [ i + 1 ] <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> total = ( total + ( a [ i ] * b [ i + 1 ] ) % mod ) % mod <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ ] <NEWLINE> for b in range ( Q ) : <NEWLINE> <INDENT> BC . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> T = [ 0 ] * 200000 <NEWLINE> <COMMENT> <NL> <NL> for i in A : <NEWLINE> <INDENT> T [ i ] += 1 <NEWLINE> <DEDENT> S = sum ( A ) <NEWLINE> for i in BC : <NEWLINE> <INDENT> b , c = i <NEWLINE> n = int ( T [ b ] ) <NEWLINE> sa = c * n - b * n <NEWLINE> S = S + c * n - b * n <NEWLINE> print ( S ) <NEWLINE> T [ b ] = 0 <NEWLINE> T [ c ] += n <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( B [ j ] ) <NEWLINE> <DEDENT>
N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N [ 1 ] ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> counter = [ 1 for i in range ( N [ 0 ] ) ] <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> if H [ b [ 1 ] - 1 ] > H [ b [ 0 ] - 1 ] : <NEWLINE> <INDENT> counter [ b [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ b [ 0 ] - 1 ] > H [ b [ 1 ] - 1 ] : <NEWLINE> <INDENT> counter [ b [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ b [ 0 ] - 1 ] == H [ b [ 1 ] - 1 ] : <NEWLINE> <INDENT> counter [ b [ 0 ] - 1 ] = 0 <NEWLINE> counter [ b [ 1 ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( counter ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> def main ( K ) : <NEWLINE> <INDENT> g = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( g ) <NEWLINE> <NL> <DEDENT> print ( main ( K ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> c_list = [ [ ] for _ in range ( N ) ] <NEWLINE> e_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda i : int ( i ) - 1 , input ( ) . split ( ) ) <NEWLINE> c_list [ a ] . append ( b ) <NEWLINE> c_list [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , e in enumerate ( e_list ) : <NEWLINE> <INDENT> for j in c_list [ i ] : <NEWLINE> <INDENT> if e <= e_list [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> gcd = math . gcd <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> INF = 2 ** 31 - 1 <NEWLINE> <NL> <NL> class RMQ : <NEWLINE> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while tmp < n : <NEWLINE> <INDENT> tmp *= 2 <NEWLINE> <DEDENT> self . n = tmp * 2 - 1 <NEWLINE> self . A = [ INF ] * ( 2 * self . n - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> i = self . n // 2 + i <NEWLINE> self . A [ i ] = x <NEWLINE> while i : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> self . A [ i ] = min ( self . A [ i * 2 + 1 ] , self . A [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , a , b , k , l , r ) : <NEWLINE> <INDENT> if r < a or b < l : <NEWLINE> <INDENT> return INF <NEWLINE> <DEDENT> if a <= l and r <= b : <NEWLINE> <INDENT> return self . A [ k ] <NEWLINE> <DEDENT> vl = self . find ( a , b , k * 2 + 1 , l , ( l + r ) // 2 ) <NEWLINE> vr = self . find ( a , b , k * 2 + 2 , ( l + r ) // 2 + 1 , r ) <NEWLINE> return min ( vl , vr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> line = sys . stdin . readline ( ) <NEWLINE> n , q = map ( int , line . split ( ) ) <NEWLINE> t = RMQ ( n ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> com , x , y = map ( int , line . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> t . update ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t . find ( x , y , 0 , 0 , t . n // 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <NL> <DEDENT> r = a % b <NEWLINE> while r != 0 : <NEWLINE> <INDENT> a = b <NEWLINE> b = r <NEWLINE> r = a % b <NEWLINE> <NL> <DEDENT> return b <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = l [ 0 ] <NEWLINE> y = l [ 1 ] <NEWLINE> <NL> ans = gcd ( x , y ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Q = [ q for q in range ( - 1 , 102 ) if q not in P ] <COMMENT> <NEWLINE> ans = min ( Q , key = lambda q : ( abs ( q - X ) , q ) ) <COMMENT> <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> list_p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> all_list = [ int ( x ) for x in range ( 0 , 102 ) ] <NEWLINE> target_list = sorted ( list ( set ( list_p ) ^ set ( all_list ) ) ) <NEWLINE> <NL> ans = [ abs ( num - X ) for num in target_list ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( target_list [ ans . index ( min ( ans ) ) ] ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> a . reverse ( ) <NEWLINE> b = [ 0 ] * n <NEWLINE> b [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> b [ i ] = b [ i - 1 ] + a [ i ] <NEWLINE> <DEDENT> a . reverse ( ) <NEWLINE> b . reverse ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * b [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def get_parent ( node ) : <NEWLINE> <INDENT> parent = - 1 <NEWLINE> if <STRING> in node : <NEWLINE> <INDENT> parent = node [ <STRING> ] <NEWLINE> <DEDENT> return parent <NEWLINE> <NL> <DEDENT> def get_depth ( node ) : <NEWLINE> <INDENT> depth = 0 <NEWLINE> while <STRING> in node : <NEWLINE> <INDENT> depth += 1 <NEWLINE> parent = node [ <STRING> ] <NEWLINE> node = rooted_tree [ parent ] <NEWLINE> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> def get_node_type ( node ) : <NEWLINE> <INDENT> if <STRING> not in node : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if <STRING> not in node : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def get_children ( node ) : <NEWLINE> <INDENT> if <STRING> not in node : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> left = node [ <STRING> ] <NEWLINE> siblings = [ ] <NEWLINE> siblings . append ( str ( left ) ) <NEWLINE> while rooted_tree [ left ] [ <STRING> ] > - 1 : <NEWLINE> <INDENT> right = rooted_tree [ left ] [ <STRING> ] <NEWLINE> siblings . append ( str ( right ) ) <NEWLINE> left = right <NEWLINE> <DEDENT> return <STRING> . format ( <STRING> . join ( siblings ) ) <NEWLINE> <NL> <DEDENT> rooted_tree = [ { } for i in range ( N ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> row = input ( ) <NEWLINE> id , degree , * children = list ( map ( int , row . split ( ) ) ) <NEWLINE> if degree > 0 : <NEWLINE> <INDENT> rooted_tree [ id ] [ <STRING> ] = children [ 0 ] <NEWLINE> for i in range ( len ( children ) ) : <NEWLINE> <INDENT> child_id = children [ i ] <NEWLINE> right = - 1 <NEWLINE> if i < len ( children ) - 1 : <NEWLINE> <INDENT> right = children [ i + 1 ] <NEWLINE> <DEDENT> rooted_tree [ child_id ] [ <STRING> ] = right <NEWLINE> rooted_tree [ child_id ] [ <STRING> ] = id <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for id in range ( N ) : <NEWLINE> <INDENT> node = rooted_tree [ id ] <NEWLINE> parent = get_parent ( node ) <NEWLINE> depth = get_depth ( node ) <NEWLINE> node_type = get_node_type ( node ) <NEWLINE> children = get_children ( node ) <NEWLINE> print ( <STRING> . format ( id , parent , depth , node_type , children ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> T , D , L = map ( int , input ( ) . split ( ) ) <NEWLINE> if T == 0 and D == 0 and L == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = [ int ( input ( ) ) for i in range ( T ) ] <NEWLINE> beforeflag = 0 <NEWLINE> flag = 0 <NEWLINE> total = 0 <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> if x [ i ] >= L : <NEWLINE> <INDENT> flag = 1 <NEWLINE> if beforeflag != D + 1 and beforeflag != 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> elif x [ i ] < L and flag > 0 and flag <= D : <NEWLINE> <INDENT> flag += 1 <NEWLINE> total += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> beforeflag = flag <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> N = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( r ) ] <NEWLINE> retu = [ [ 0 for i in range ( 1 ) ] for j in range ( 1 ) ] <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> ret += N [ i ] [ j ] <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> retu [ 0 ] [ 0 ] += ret <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> retu [ 0 ] . append ( ret ) <NEWLINE> <DEDENT> <DEDENT> N . extend ( retu ) <NEWLINE> for i in range ( r + 1 ) : <NEWLINE> <INDENT> tuika = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> tuika += N [ i ] [ j ] <NEWLINE> <DEDENT> N [ i ] . append ( tuika ) <NEWLINE> <NL> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> print ( N [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , N [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def back_oturigation ( fee , coin_values , coin_nums ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> oturi = coin_values [ 0 ] * coin_nums [ 0 ] + coin_values [ 1 ] * coin_nums [ 1 ] + coin_values [ 2 ] * coin_nums [ 2 ] + coin_values [ 3 ] * coin_nums [ 3 ] - fee <NEWLINE> use_coins = [ 0 ] * len ( coin_values ) <NEWLINE> no_use_coins = [ 0 ] * len ( coin_values ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( coin_values ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> no_use_coins [ i ] = int ( oturi / coin_values [ i ] ) <NEWLINE> oturi = oturi - ( coin_values [ i ] * no_use_coins [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 0 , len ( use_coins ) , 1 ) : <NEWLINE> <INDENT> use_coins [ i ] = coin_nums [ i ] - no_use_coins [ i ] <NEWLINE> if use_coins [ i ] > 0 : <NEWLINE> <INDENT> print ( str ( coin_values [ i ] ) + <STRING> + str ( use_coins [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> first = True <NEWLINE> while ( True ) : <NEWLINE> <INDENT> total_fee = int ( input ( <STRING> ) ) <NEWLINE> if total_fee == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if first : <NEWLINE> <INDENT> first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> coins = input ( <STRING> ) <NEWLINE> coins = coins . split ( <STRING> ) <COMMENT> <NEWLINE> coins = [ int ( coin ) for coin in coins ] <NEWLINE> coin_values = [ 10 , 50 , 100 , 500 ] <NEWLINE> back_oturigation ( total_fee , coin_values , coins ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> Sr = S [ : : - 1 ] <COMMENT> <NEWLINE> <NL> T = 0 <COMMENT> <NEWLINE> mod = [ 0 ] * 2019 <COMMENT> <NEWLINE> mod [ 0 ] += 1 <COMMENT> <NEWLINE> d = 1 <COMMENT> <NEWLINE> for i , s in enumerate ( Sr ) : <NEWLINE> <INDENT> T += int ( s ) * d <NEWLINE> T %= 2019 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> <NL> mod [ T ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> mod = [ n * ( n - 1 ) // 2 for n in mod ] <NEWLINE> print ( sum ( mod ) ) <NEWLINE>
import heapq <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> maxS = 50 * ( N - 1 ) <NEWLINE> cost = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> U , V , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = U - 1 <NEWLINE> V = V - 1 <NEWLINE> cost [ U ] . append ( ( A , B , V ) ) <NEWLINE> cost [ V ] . append ( ( A , B , U ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> cost [ i ] . sort ( ) <NEWLINE> <DEDENT> r = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> r . append ( ( C , D ) ) <NEWLINE> <DEDENT> time = [ - 1 ] * N <NEWLINE> money = [ - 1 ] * N <NEWLINE> used = set ( ) <NEWLINE> cities = N <NEWLINE> q = [ ( 0 , S , 0 ) ] <COMMENT> <NEWLINE> count = 0 <NEWLINE> while cities : <NEWLINE> <INDENT> count += 1 <NEWLINE> t , s , ci = heapq . heappop ( q ) <NEWLINE> if ( s , ci ) in used or money [ ci ] >= s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used . add ( ( s , ci ) ) <NEWLINE> if time [ ci ] == - 1 : <NEWLINE> <INDENT> time [ ci ] = t <NEWLINE> money [ ci ] = s <NEWLINE> cities -= 1 <NEWLINE> <DEDENT> for a , b , v in cost [ ci ] : <NEWLINE> <INDENT> if s < a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( s - a , v ) not in used and money [ v ] < s - a : <NEWLINE> <INDENT> heapq . heappush ( q , ( t + b , s - a , v ) ) <NEWLINE> <DEDENT> <DEDENT> if s != maxS : <NEWLINE> <INDENT> c , d = r [ ci ] <NEWLINE> m = cost [ ci ] [ 0 ] [ 0 ] <NEWLINE> k = max ( 1 , ( m - s + c - 1 ) // c ) <NEWLINE> if ( s + c , ci ) not in used : <NEWLINE> <INDENT> heapq . heappush ( q , ( t + d * k , min ( s + c * k , maxS ) , ci ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in time [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
b = input ( ) <NEWLINE> d = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> print ( d [ b ] ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) <NEWLINE> <DEDENT> elif ( a == b and b != c ) or ( a != b and b == c ) : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) * 3 <NEWLINE> <DEDENT> elif a != b and b != c : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> if X >= K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> X -= D <NEWLINE> <NL> <DEDENT> x1 = X % ( 2 * D ) <NEWLINE> print ( min ( x1 , ( 2 * D - x1 ) ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> ans = 0 <NEWLINE> d = [ 0 ] * 210000 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> total += A [ i ] <NEWLINE> d [ i ] = total <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> ans += A [ j ] * ( total - d [ j ] ) <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = sum ( a ) <NEWLINE> <NL> mod = 1000000000 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_a -= a [ i ] <NEWLINE> pdt = a [ i ] * sum_a <NEWLINE> ans += pdt <NEWLINE> <NL> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ [ 0 ] * k for i in range ( n ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( len ( l ) ) : <NEWLINE> <INDENT> s [ l [ j ] - 1 ] [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sum ( s [ i ] ) == 0 : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <COMMENT> <NL> k = [ [ ] for i in range ( n ) ] <NEWLINE> for j , h in l : <NEWLINE> <INDENT> k [ j - 1 ] . append ( h ) <NEWLINE> <DEDENT> k_so = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = k [ i ] <NEWLINE> k_so [ i ] = sorted ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> for j , h in l : <NEWLINE> <INDENT> first = <STRING> . format ( j ) <NEWLINE> t = bisect_left ( k_so [ j - 1 ] , h ) <NEWLINE> second = <STRING> . format ( t + 1 ) <NEWLINE> print ( first + second ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> s = [ ] <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> s = Counter ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> b . append ( bi ) <NEWLINE> c . append ( ci ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> ans += s [ b [ i ] ] * ( c [ i ] - b [ i ] ) <NEWLINE> s [ c [ i ] ] += s [ b [ i ] ] <NEWLINE> s [ b [ i ] ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> xa = abs ( x ) <NEWLINE> kz = xa // d <NEWLINE> xz = xa - kz * d <NEWLINE> <NL> if xz * 2 > d : <NEWLINE> <INDENT> xzz = d - xz <NEWLINE> kz += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xzz = xz <NEWLINE> <DEDENT> rest = k - kz <NEWLINE> if rest < 0 : <NEWLINE> <INDENT> print ( xa - k * d ) <NEWLINE> <DEDENT> elif rest % 2 == 0 : <NEWLINE> <INDENT> print ( xzz ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - xzz ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif ord ( <STRING> ) - ord ( s ) + 1 <= K : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> K -= ord ( <STRING> ) - ord ( s ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> K %= 26 <NEWLINE> S [ - 1 ] = chr ( ( ord ( S [ - 1 ] ) - ord ( <STRING> ) + K ) % 26 + ord ( <STRING> ) ) <NEWLINE> <NL> print ( <STRING> . join ( S ) ) <NEWLINE>
n = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> count = Counter ( a ) <NEWLINE> <NL> def choose2 ( x ) : <NEWLINE> <INDENT> return int ( x * ( x - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in list ( count . values ( ) ) : <NEWLINE> <INDENT> total += choose2 ( i ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> s = count [ i ] <NEWLINE> print ( total - choose2 ( s ) + choose2 ( s - 1 ) ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> k = int ( k ) <NEWLINE> <NL> ll = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> l . append ( j ) <NEWLINE> l . append ( i // j ) <NEWLINE> <DEDENT> if ( i // j ) < j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ll . append ( set ( l ) ) <NEWLINE> <NL> <NL> <DEDENT> sum_k = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> i_s = ll [ i ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> j_s = ll [ j ] <NEWLINE> m = max ( ll [ i ] & ll [ j ] ) <NEWLINE> if m == 1 : <NEWLINE> <INDENT> sum_k += k <NEWLINE> continue <NEWLINE> <DEDENT> for l in range ( k ) : <NEWLINE> <INDENT> sum_k += max ( ll [ i ] & ll [ j ] & ll [ l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_k ) <NEWLINE>
inf = 10 ** 9 + 5 <NEWLINE> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ inf ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + 3 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> dp [ j ] = min ( dp [ j ] , dp [ i ] + abs ( h [ i ] - h [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sum = 1 <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in i : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for cnt in range ( N ) : <NEWLINE> <INDENT> sum = sum * i [ cnt ] <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> import collections <NEWLINE> <NL> def func ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = int ( math . sqrt ( n ) ) <NEWLINE> nums = list ( range ( 1 , s ) ) <NEWLINE> arr = [ ] <NEWLINE> com = list ( itertools . product ( nums , repeat = 3 ) ) <NEWLINE> for i in range ( len ( com ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans = func ( com [ i ] [ 0 ] , com [ i ] [ 1 ] , com [ i ] [ 2 ] ) <NEWLINE> arr . append ( ans ) <NEWLINE> <NL> <NL> <DEDENT> c = collections . Counter ( arr ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> n_arr = [ int ( n [ i ] ) for i in range ( len ( n ) ) ] <NEWLINE> tmp = 0 <NEWLINE> for i in n_arr : <NEWLINE> <INDENT> tmp += i <NEWLINE> <DEDENT> if tmp % 9 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> t = input ( ) <NEWLINE> * c , = map ( int , t . replace ( * <STRING> ) . replace ( * <STRING> ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> a = 0 <NEWLINE> i , j = 0 , 1 <NEWLINE> while i + j < n : <NEWLINE> <INDENT> if c [ i ] == 1 and c [ - j ] == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif c [ i ] == c [ - j ] == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> elif c [ i ] == c [ - j ] == 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
def pri ( s , n ) : <NEWLINE> <INDENT> tab = [ i for i in range ( n + 1 ) if s [ i ] and i >= 2 ] <NEWLINE> return ( tab ) <NEWLINE> <NL> <DEDENT> s = [ True for _ in range ( 999999 + 1 ) ] <NEWLINE> i = 2 <NEWLINE> while i ** 2 <= 999999 : <NEWLINE> <INDENT> if s [ i ] : <NEWLINE> <INDENT> j = i * 2 <NEWLINE> while j <= 999999 : <NEWLINE> <INDENT> s [ j ] = False <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( len ( pri ( s , int ( input ( ) ) ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ 0 ] * ( M + 2 ) <NEWLINE> sum = [ 0 ] * ( M + 2 ) <NEWLINE> p [ X ] = 1 <NEWLINE> sum [ 1 ] = X <NEWLINE> <NL> repeat_start = 0 <NEWLINE> repeat_end = 0 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> X = ( X ** 2 ) % M <NEWLINE> if p [ X ] != 0 : <NEWLINE> <INDENT> repeat_start = p [ X ] <NEWLINE> repeat_end = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum [ i ] = sum [ i - 1 ] + X <NEWLINE> p [ X ] += i <NEWLINE> <NL> <DEDENT> <DEDENT> if repeat_start == 0 : <NEWLINE> <INDENT> print ( sum [ N ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> repeat_cnt , mod = divmod ( N - repeat_start + 1 , repeat_end - repeat_start ) <NEWLINE> print ( repeat_cnt * ( sum [ repeat_end - 1 ] - sum [ repeat_start - 1 ] ) + sum [ repeat_start + mod - 1 ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> valSum = 0 <NEWLINE> <NL> for A in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for B in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for C in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> valSum += gcd ( gcd ( A , B ) , C ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( valSum ) <NEWLINE> <NL>
import math <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> B [ N - 1 ] = A [ N - 1 ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> for j in range ( N - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> B [ j ] = ( B [ j + 1 ] + A [ j ] ) % MOD <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ans % MOD + ( A [ i ] * B [ i + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ <STRING> for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> valid = True <NEWLINE> ans = [ ] <NEWLINE> all_sum = A + B + C <NEWLINE> if all_sum >= 3 : <NEWLINE> <INDENT> for op in s : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> if B > C : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if A > C : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if A < 0 or B < 0 or C < 0 : <NEWLINE> <INDENT> valid = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if valid : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for c in ans : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> op = s [ i ] <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif A < B : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != N - 1 and <STRING> in s [ i + 1 ] : <NEWLINE> <INDENT> A += 1 <NEWLINE> B -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> if A > C : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif A < C : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != N - 1 and <STRING> in s [ i + 1 ] : <NEWLINE> <INDENT> A += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if B > C : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif B < C : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != N - 1 and <STRING> in s [ i + 1 ] : <NEWLINE> <INDENT> B += 1 <NEWLINE> C -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> C += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if A < 0 or B < 0 or C < 0 : <NEWLINE> <INDENT> valid = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if valid : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for c in ans : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 0 ] * ( len ( a ) + 1 ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> t [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N >= 400 and N <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif N >= 600 and N <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif N >= 800 and N <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif N >= 1000 and N <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif N >= 1200 and N <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif N >= 1400 and N <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif N >= 1600 and N <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = x % 11 <NEWLINE> b = x // 11 <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> elif a <= 6 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 2 <NEWLINE> <NL> <DEDENT> print ( b * 2 + c ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> K = int ( input ( ) ) <NEWLINE> assert 1 <= K <= 200 <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = euclidean_algorithm ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += euclidean_algorithm ( a , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( euclidean_algorithm , numbers ) <NEWLINE> <NL> <NL> <DEDENT> def euclidean_algorithm ( a , b ) : <NEWLINE> <INDENT> r = a % b <NEWLINE> while r != 0 : <NEWLINE> <INDENT> a = b <NEWLINE> b = r <NEWLINE> r = a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for p in range ( k + 1 ) : <NEWLINE> <INDENT> for q in range ( k + 1 ) : <NEWLINE> <INDENT> r = s - p - q <NEWLINE> if r >= 0 and r <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def sieve ( n ) : <NEWLINE> <INDENT> p = [ True ] * ( n + 1 ) <NEWLINE> p [ 0 ] = p [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( ( n + 1 ) * 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] == True : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prime = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if p [ i ] == True : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if n > prime [ i ] : <NEWLINE> <INDENT> a = prime [ i ] <NEWLINE> <DEDENT> elif n == prime [ i ] : <NEWLINE> <INDENT> a = prime [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = prime [ i ] <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <NL> <DEDENT> prime = sieve ( 50021 ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> solve ( n ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( N // 3600 , N % 3600 // 60 , N % 60 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> m = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ i ] < m : <NEWLINE> <INDENT> m = P [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def A ( x ) : <NEWLINE> <INDENT> return x + x ** 2 + x ** 3 <NEWLINE> <NL> <NL> <DEDENT> def B ( s , t ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def C ( n , m , k , a , b ) : <NEWLINE> <NL> <INDENT> def _get_acc ( x ) : <NEWLINE> <INDENT> acc = [ 0 ] <NEWLINE> for idx in range ( len ( x ) ) : <NEWLINE> <INDENT> acc . append ( x [ idx ] + acc [ idx ] ) <NEWLINE> <DEDENT> return acc <NEWLINE> <NL> <DEDENT> acc_a = _get_acc ( a ) <NEWLINE> acc_b = _get_acc ( b ) <NEWLINE> <NL> pa = 0 <NEWLINE> pb = 0 <NEWLINE> <NL> while pa <= n and acc_a [ pa ] <= k : <NEWLINE> <INDENT> pa += 1 <NEWLINE> <DEDENT> pa -= 1 <NEWLINE> <NL> max_num = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if pa < 0 or pb > m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if acc_a [ pa ] + acc_b [ pb ] <= k : <NEWLINE> <INDENT> if max_num < pa + pb : <NEWLINE> <INDENT> max_num = pa + pb <NEWLINE> <DEDENT> pb += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pa -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return max_num <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( C ( n , m , k , a , b ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> memo = { 0 : 0 , 1 : d } <NEWLINE> <NL> def dfs ( n ) : <NEWLINE> <INDENT> if n in memo . keys ( ) : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <NL> <DEDENT> res1 = n * d <NEWLINE> r = n % 2 <NEWLINE> res2 = a + r * d + dfs ( ( n - r ) // 2 ) <NEWLINE> if r != 0 : <NEWLINE> <INDENT> tmp = a + ( 2 - r ) * d + dfs ( ( n + ( 2 - r ) ) // 2 ) <NEWLINE> if tmp < res2 : <NEWLINE> <INDENT> res2 = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> r = n % 3 <NEWLINE> res3 = b + r * d + dfs ( ( n - r ) // 3 ) <NEWLINE> if r != 0 : <NEWLINE> <INDENT> tmp = b + ( 3 - r ) * d + dfs ( ( n + ( 3 - r ) ) // 3 ) <NEWLINE> if tmp < res3 : <NEWLINE> <INDENT> res3 = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> r = n % 5 <NEWLINE> res5 = c + r * d + dfs ( ( n - r ) // 5 ) <NEWLINE> if r != 0 : <NEWLINE> <INDENT> tmp = c + ( 5 - r ) * d + dfs ( ( n + ( 5 - r ) ) // 5 ) <NEWLINE> if tmp < res5 : <NEWLINE> <INDENT> res5 = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> memo [ n ] = min ( res1 , res2 , res3 , res5 ) <NEWLINE> return memo [ n ] <NEWLINE> <NL> <DEDENT> print ( dfs ( n ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Ans = <STRING> <NEWLINE> List = [ ] <NEWLINE> before_n = 0 <NEWLINE> for e in A : <NEWLINE> <INDENT> if e == before_n : <NEWLINE> <INDENT> Ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> before_n = e <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] <NEWLINE> p = [ ] <NEWLINE> q = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p . append ( dp [ A [ i ] - 1 ] ) <NEWLINE> q . append ( A [ i ] ) <NEWLINE> <DEDENT> bp = [ [ 0 , 0 ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( p ) ) : <NEWLINE> <INDENT> if i + p [ j ] > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if bp [ i ] [ 0 ] == 0 : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> bp [ i + p [ j ] ] [ 0 ] = max ( bp [ i + p [ j ] ] [ 0 ] , bp [ i ] [ 0 ] + ( 10 ** bp [ i ] [ 1 ] ) * q [ j ] ) <NEWLINE> bp [ i + p [ j ] ] [ 1 ] = bp [ i ] [ 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> print ( bp [ N ] [ 0 ] ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
MOD = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> seg = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> <NL> s = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> s [ 1 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] <NEWLINE> for l , r in seg : <NEWLINE> <INDENT> s [ i + 1 ] += ( s [ max ( 0 , i - l + 1 ) ] - s [ max ( 0 , i - r ) ] ) % MOD <NEWLINE> s [ i + 1 ] %= MOD <NEWLINE> <DEDENT> <DEDENT> print ( ( s [ n ] - s [ n - 1 ] ) % MOD ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> inf = 10 ** 9 + 1 <NEWLINE> dp = [ inf ] * n <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> j = bisect_left ( dp , a ) <NEWLINE> dp [ j ] = a <NEWLINE> <NL> <DEDENT> for i , v in enumerate ( dp ) : <NEWLINE> <INDENT> if v == inf : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT> def debug ( x , table ) : <NEWLINE> <INDENT> for name , val in table . items ( ) : <NEWLINE> <INDENT> if x is val : <NEWLINE> <INDENT> print ( <STRING> . format ( name , val ) , file = sys . stderr ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] * N , [ 0 ] * M <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total += A [ i ] <NEWLINE> a [ i ] = total <NEWLINE> <NL> <DEDENT> a = [ 0 ] + a <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> total += B [ i ] <NEWLINE> b [ i ] = total <NEWLINE> <NL> <DEDENT> b = [ 0 ] + b <NEWLINE> <NL> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] + a [ i ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <NL> dic = defaultdict ( int ) <NEWLINE> <NL> <COMMENT> <NL> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> left = str ( k ) [ 0 ] <NEWLINE> right = str ( k ) [ - 1 ] <NEWLINE> dic [ ( left , right ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> items = list ( dic . items ( ) ) <NEWLINE> for ( left , right ) , cnt in items : <NEWLINE> <INDENT> ans += cnt * dic [ ( right , left ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <COMMENT> <NL> d = { } <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> a1 = j - a [ j ] <NEWLINE> try : <NEWLINE> <INDENT> ans += d [ a1 ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> d [ a1 ] = 0 <NEWLINE> <NL> <DEDENT> a2 = j + a [ j ] <NEWLINE> try : <NEWLINE> <INDENT> d [ a2 ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> d [ a2 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> count = 0 <NEWLINE> <NL> number = int ( input ( ) ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> jdg = True <NEWLINE> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> jdg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if jdg : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> <NL> a = - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> b1 = 0 <NEWLINE> b2 = 0 <NEWLINE> while b1 < a : <NEWLINE> <NL> <INDENT> if ( X / ( a - b1 ) ) . is_integer ( ) : <NEWLINE> <INDENT> if int ( X / ( a - b1 ) ) == a ** 4 + b1 * ( a ** 3 ) + ( a ** 2 ) * ( b1 ** 2 ) + a * ( b1 ** 3 ) + b1 ** 4 : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b1 ) ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( X / ( a - b2 ) ) . is_integer ( ) : <NEWLINE> <INDENT> if int ( X / ( a - b2 ) ) == a ** 4 + b2 * ( a ** 3 ) + ( a ** 2 ) * ( b2 ** 2 ) + a * ( b2 ** 3 ) + b2 ** 4 : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b2 ) ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> b1 += 1 <NEWLINE> b2 -= 1 <NEWLINE> <NL> <DEDENT> a += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> lists = list ( ) <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> lists . append ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( t ) - max ( lists ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( ) : <NEWLINE> <INDENT> print ( input ( ) [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> def f ( a ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e+18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( f ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> Ans = 0 <NEWLINE> num = [ 0 ] * 100000 <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num [ an [ i ] - 1 ] += 1 <NEWLINE> Ans += an [ i ] <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bici = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ans += num [ bici [ 0 ] - 1 ] * ( bici [ 1 ] - bici [ 0 ] ) <NEWLINE> num [ bici [ 1 ] - 1 ] += num [ bici [ 0 ] - 1 ] <NEWLINE> num [ bici [ 0 ] - 1 ] = 0 <NEWLINE> print ( Ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == ( h - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> print ( min ( s . count ( <STRING> ) , s . count ( <STRING> ) ) * 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> S = deque ( map ( int , list ( input ( ) ) ) ) <NEWLINE> num = 0 <NEWLINE> dict = { } <NEWLINE> dict [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> num += S . pop ( ) * pow ( 10 , i , 2019 ) <NEWLINE> cand = num % 2019 <NEWLINE> if cand in dict . keys ( ) : <NEWLINE> <INDENT> dict [ cand ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ cand ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key in dict . keys ( ) : <NEWLINE> <INDENT> ans += dict [ key ] * ( dict [ key ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> l = c [ : i ] <NEWLINE> r = c [ i : ] <NEWLINE> W = l . count ( <STRING> ) <NEWLINE> R = r . count ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( c [ i - 1 ] ) == <STRING> : <NEWLINE> <INDENT> W += 1 <NEWLINE> <DEDENT> elif ( c [ i - 1 ] ) == <STRING> : <NEWLINE> <INDENT> R -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ i ] = max ( R , W ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
<COMMENT> <NL> <NL> import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> print ( a [ 1 ] , a [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> x = a [ - 1 ] <NEWLINE> index = bisect . bisect_left ( a [ : n - 1 ] , x / 2 ) <NEWLINE> <NL> ans = [ ] <NEWLINE> ans . append ( [ abs ( x / 2 - a [ index - 1 ] ) , a [ index - 1 ] ] ) <NEWLINE> ans . append ( [ abs ( x / 2 - a [ index ] ) , a [ index ] ] ) <NEWLINE> ans . append ( [ abs ( x / 2 - a [ index + 1 ] ) , a [ index + 1 ] ] ) <NEWLINE> <NL> ans . sort ( ) <NEWLINE> <NL> print ( x , ans [ 0 ] [ 1 ] ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> while 1 : <NEWLINE> <INDENT> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if j == W - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> s = S % 60 <NEWLINE> m = S // 60 % 60 <NEWLINE> h = S // 3600 <NEWLINE> print ( <STRING> <STRING> <STRING> <STRING> <STRING> . format ( h , m , s ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> friend = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> friend [ A - 1 ] . append ( B - 1 ) <NEWLINE> friend [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ischecked = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ischecked [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> group = 1 <NEWLINE> ischecked [ i ] = 1 <NEWLINE> ship = friend [ i ] <NEWLINE> while ship : <NEWLINE> <INDENT> nex = ship . pop ( ) <NEWLINE> if ischecked [ nex ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ischecked [ nex ] = 1 <NEWLINE> group += 1 <NEWLINE> ship . extend ( friend [ nex ] ) <NEWLINE> <DEDENT> ans = max ( ans , group ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ list ( map ( str , input ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 1 << H ) : <NEWLINE> <INDENT> for j in range ( 1 << W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( i >> h & 1 ) : continue <NEWLINE> if ( j >> w & 1 ) : continue <NEWLINE> cnt += C [ h ] [ w ] == <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == K : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) + a [ - 1 ] ) <NEWLINE> <NL> <DEDENT> maximum = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> maximum = max ( maximum , a [ i ] - a [ j ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if maximum == 0 : <NEWLINE> <INDENT> b = [ a [ i + 1 ] - a [ i ] for i in range ( n ) ] <NEWLINE> maximum = max ( b ) <NEWLINE> <NL> <DEDENT> print ( maximum ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> b = [ ] <NEWLINE> <NL> b . append ( A . pop ( 0 ) // 2 ) <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> if A == [ ] : <NEWLINE> <INDENT> b . append ( b . pop ( 0 ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ 0 ] > b [ 0 ] : <NEWLINE> <INDENT> b . append ( A . pop ( 0 ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( b . pop ( 0 ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) + sum ( b ) ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> matrix = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( r ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> matrix [ i ] . append ( sum ( matrix [ i ] ) ) <NEWLINE> <NL> <DEDENT> row = [ ] <NEWLINE> <NL> for i in range ( c + 1 ) : <NEWLINE> <INDENT> row_sum = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> row_sum += matrix [ j ] [ i ] <NEWLINE> <DEDENT> row . append ( row_sum ) <NEWLINE> <NL> <DEDENT> matrix . append ( row ) <NEWLINE> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> print ( matrix [ i ] [ j ] , end = <STRING> ) <NEWLINE> if j != c : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if j == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = True if 0 in a else False <NEWLINE> <NL> if flag : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> friends = [ set ( ) for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> friends [ a ] . add ( b ) <NEWLINE> friends [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> blocks = [ set ( ) for _ in range ( N ) ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> c , d = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> blocks [ c ] . add ( d ) <NEWLINE> blocks [ d ] . add ( c ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> visited = [ False ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ i ] = True <NEWLINE> d = [ i ] <NEWLINE> check = { i } <NEWLINE> while len ( d ) : <NEWLINE> <INDENT> tmp = d . pop ( ) <NEWLINE> for k in friends [ tmp ] : <NEWLINE> <INDENT> if visited [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d . append ( k ) <NEWLINE> visited [ k ] = True <NEWLINE> check . add ( k ) <NEWLINE> <DEDENT> <DEDENT> for j in check : <NEWLINE> <INDENT> ans [ j ] += len ( check ) - len ( friends [ j ] & check ) - len ( blocks [ j ] & check ) - 1 <NEWLINE> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> sort_a = sorted ( a , reverse = True ) <NEWLINE> amax = sort_a [ 0 ] <NEWLINE> asecond = sort_a [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = a [ i ] <NEWLINE> if tmp == amax : <NEWLINE> <INDENT> print ( asecond ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( amax ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> lim = int ( x ** ( 1 / 5 ) ) + 1 <NEWLINE> <NL> for a in range ( 10 ** 6 ) : <NEWLINE> <INDENT> mul = 1 <NEWLINE> if a ** 5 < x : <NEWLINE> <INDENT> mul = - 1 <NEWLINE> <NL> <DEDENT> b = ( ( a ** 5 - x ) * mul ) ** ( 1 / 5 ) <NEWLINE> b *= mul <NEWLINE> b = int ( b ) <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> pair_dict = Counter ( ) <NEWLINE> for i in range ( 2001 ) : <NEWLINE> <INDENT> pair_dict [ i ] = min ( i , 2000 - i ) + 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans += pair_dict [ i ] * pair_dict [ n - i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = int ( ) <NEWLINE> <NL> if K >= A : <NEWLINE> <INDENT> S = S + A <NEWLINE> K = K - A <NEWLINE> <NL> if K >= B : <NEWLINE> <INDENT> K = K - B <NEWLINE> <NL> if K > 0 : <NEWLINE> <INDENT> S = S - K <NEWLINE> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> S = S + K <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> l = 1000000007 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = s - a [ i ] <NEWLINE> num = num + a [ i ] * s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num % l ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> res = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if math . gcd ( i + 1 , j + 1 ) == 1 : <NEWLINE> <INDENT> ans += n <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> ans += gcd ( i + 1 , j + 1 , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
dict = { } <NEWLINE> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in dict : <NEWLINE> <INDENT> dict [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> max_ = max ( dict . values ( ) ) <NEWLINE> A = [ k for k , v in dict . items ( ) if v == max_ ] <NEWLINE> A . sort ( ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
def calc ( a , b ) : <NEWLINE> <INDENT> m = min ( a , b ) <NEWLINE> l = max ( a , b ) <NEWLINE> while m != 0 : <NEWLINE> <INDENT> s = m <NEWLINE> m = l % m <NEWLINE> l = s <NEWLINE> <DEDENT> return l <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <DEDENT> elif i == j : <NEWLINE> <INDENT> ans += 3 * calc ( i + 1 , k + 1 ) <NEWLINE> <DEDENT> elif j == k : <NEWLINE> <INDENT> ans += 3 * calc ( i + 1 , j + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * calc ( calc ( i + 1 , j + 1 ) , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> number = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> number [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( number [ i ] ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> MOD = 2019 <NEWLINE> S = input ( ) ; N = len ( S ) <NEWLINE> Cum = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Cum [ i + 1 ] = ( Cum [ i ] + int ( S [ N - i - 1 ] ) * pow ( 10 , i , MOD ) ) % MOD <NEWLINE> <DEDENT> res = 0 <NEWLINE> c = Counter ( Cum ) . most_common ( ) <NEWLINE> for a , b in c : <NEWLINE> <INDENT> res += b * ( b - 1 ) // 2 <NEWLINE> if ( b == 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> list_plus = [ ] <NEWLINE> list_minus = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> state = 0 <NEWLINE> min_state = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> state += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state -= 1 <NEWLINE> <DEDENT> min_state = min ( min_state , state ) <NEWLINE> <NL> <DEDENT> if state > 0 : <NEWLINE> <INDENT> list_plus . append ( ( min_state , state ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list_minus . append ( ( min_state - state , - state ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def compute ( arr ) : <NEWLINE> <INDENT> total_state = 0 <NEWLINE> for min_state , state in arr [ : : - 1 ] : <NEWLINE> <INDENT> if total_state + min_state < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> total_state += state <NEWLINE> <DEDENT> return total_state <NEWLINE> <NL> <DEDENT> list_plus . sort ( ) <NEWLINE> total_state_plus = compute ( list_plus ) <NEWLINE> list_minus . sort ( ) <NEWLINE> total_state_minus = compute ( list_minus ) <NEWLINE> <NL> print ( <STRING> if total_state_plus == total_state_minus else <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> list = [ ] <NEWLINE> a = 1 <NEWLINE> for i in range ( N + 2 ) : <NEWLINE> <INDENT> if i == 0 or i == N + 1 : <NEWLINE> <INDENT> list . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( N * i + a ) <NEWLINE> a -= 2 * i <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( M , N + 2 ) : <NEWLINE> <INDENT> ans += list [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> def calc ( A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans += A [ i ] * ( i + 1 ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> VALUE = [ 0 for i in range ( 100000 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> VALUE [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ANS = [ ] <NEWLINE> ANS . append ( calc ( VALUE ) ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> VALUE [ BC [ i ] [ 1 ] - 1 ] += VALUE [ BC [ i ] [ 0 ] - 1 ] <NEWLINE> ANS . append ( ANS [ i ] + ( BC [ i ] [ 1 ] - BC [ i ] [ 0 ] ) * VALUE [ BC [ i ] [ 0 ] - 1 ] ) <NEWLINE> VALUE [ BC [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , Q + 1 ) : <NEWLINE> <INDENT> print ( ANS [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> listA = [ input ( ) for i in range ( N ) ] <NEWLINE> listB = set ( listA ) <NEWLINE> print ( len ( listB ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if x == i ** 5 - j ** 5 : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k - a > b : <NEWLINE> <INDENT> print ( - 1 * ( ( k - a ) - b ) + a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> return print ( 0 ) <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for n in A : <NEWLINE> <INDENT> prod *= n <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> return print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> return print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> l = 0 <NEWLINE> if ( 0 in a ) == True : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> count *= i <NEWLINE> if count > 1000000000000000000 : <NEWLINE> <INDENT> l = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> from bisect import bisect_left , bisect_right , insort <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <NL> def MI ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def MS ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> box = [ [ ] for i in range ( n ) ] <NEWLINE> s = deque ( ) <NEWLINE> ans = [ - 1 ] * ( n - 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> box [ a [ i ] - 1 ] . append ( b [ i ] ) <NEWLINE> box [ b [ i ] - 1 ] . append ( a [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( box [ 0 ] ) ) : <NEWLINE> <INDENT> s . append ( [ 1 , box [ 0 ] [ i ] ] ) <NEWLINE> <NL> <DEDENT> while len ( s ) > 0 : <NEWLINE> <INDENT> k = s . popleft ( ) <NEWLINE> <NL> if ans [ k [ 1 ] - 2 ] == - 1 and k [ 1 ] - 2 != - 1 : <NEWLINE> <INDENT> ans [ k [ 1 ] - 2 ] = k [ 0 ] <NEWLINE> <NL> for i in range ( len ( box [ k [ 1 ] - 1 ] ) ) : <NEWLINE> <INDENT> s . append ( [ k [ 1 ] , box [ k [ 1 ] - 1 ] [ i ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> n = 7 % k <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( n * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> log = [ ] <NEWLINE> button = 1 <NEWLINE> count = 0 <NEWLINE> while button != 2 : <NEWLINE> <INDENT> button = a [ button - 1 ] <NEWLINE> count += 1 <NEWLINE> log . append ( button ) <NEWLINE> if count == N + 1 : <NEWLINE> <INDENT> count = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> ( N , M ) = map ( int , input ( ) . split ( ) ) <NEWLINE> X = map ( int , input ( ) . split ( ) ) <NEWLINE> X = sorted ( X ) <NEWLINE> <NL> Y = [ ] <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> Y . append ( ( i , X [ i ] - X [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> Y = sorted ( Y , key = lambda x : ( x [ 1 ] ) ) <NEWLINE> Y . reverse ( ) <NEWLINE> <NL> I = list ( map ( lambda x : x [ 0 ] , Y [ 0 : min ( N - 1 , len ( Y ) ) ] ) ) <NEWLINE> I . sort ( ) <NEWLINE> <NL> Z = [ ] <NEWLINE> last = 0 <NEWLINE> for i in range ( 0 , min ( N - 1 , len ( Y ) ) ) : <NEWLINE> <INDENT> if last < I [ i ] : <NEWLINE> <INDENT> Z . append ( X [ last : I [ i ] ] ) <NEWLINE> last = I [ i ] <NEWLINE> <DEDENT> <DEDENT> Z . append ( X [ last : ] ) <NEWLINE> if len ( Z ) == 0 : <NEWLINE> <INDENT> Z . append ( X ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for array in Z : <NEWLINE> <INDENT> if len ( array ) > 0 : <NEWLINE> <INDENT> u = max ( array ) <NEWLINE> l = min ( array ) <NEWLINE> s += u - l <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = len ( list ( set ( S ) ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> from collections import defaultdict <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> return N , A <NEWLINE> <NL> <NL> <DEDENT> def prime_factorization ( n , primes ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> prime_factors = defaultdict ( int ) <NEWLINE> if n < 2 : <NEWLINE> <INDENT> return prime_factors <NEWLINE> <DEDENT> for p in primes : <NEWLINE> <INDENT> if p * p > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while n % p == 0 : <NEWLINE> <INDENT> prime_factors [ p ] += 1 <NEWLINE> n //= p <NEWLINE> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> prime_factors [ n ] = 1 <NEWLINE> <DEDENT> return prime_factors <NEWLINE> <NL> <NL> <DEDENT> def sieve ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> is_prime = [ True for i in range ( n + 1 ) ] <NEWLINE> primes = [ ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> for j in range ( i + i , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return primes <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , A ) : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> AMAX = max ( A ) <NEWLINE> ans = 0 <NEWLINE> is_div = [ True for i in range ( AMAX + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if is_div [ a ] : <NEWLINE> <INDENT> if not ( ( i > 0 and A [ i ] == A [ i - 1 ] ) or ( i < N - 1 and A [ i ] == A [ i + 1 ] ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( a , AMAX + 1 , a ) : <NEWLINE> <INDENT> is_div [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( N , X , D ) : <NEWLINE> <INDENT> if D == 0 : <NEWLINE> <INDENT> if X == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return N + 1 <NEWLINE> <DEDENT> L = { 0 : [ ( 0 , 1 ) , ( 1 , - 1 ) ] } <NEWLINE> coef_l = 0 <NEWLINE> coef_r = 1 <NEWLINE> for coef_x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> m = X * coef_x % D <NEWLINE> l = X * coef_x // D + coef_l <NEWLINE> r = X * coef_x // D + coef_x * N - coef_r <NEWLINE> coef_l = coef_r <NEWLINE> coef_r += coef_x + 1 <NEWLINE> if m not in L : <NEWLINE> <INDENT> L [ m ] = [ ] <NEWLINE> <DEDENT> L [ m ] . append ( ( l , 1 ) ) <NEWLINE> L [ m ] . append ( ( r + 1 , - 1 ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for Q in L . values ( ) : <NEWLINE> <INDENT> Q . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> last = None <NEWLINE> for val , sign in Q : <NEWLINE> <INDENT> if cnt > 0 : <NEWLINE> <INDENT> ans += val - last <NEWLINE> <DEDENT> cnt += sign <NEWLINE> last = val <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , X , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( N , X , D ) ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> <NL> <NL> def pd ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ms = [ <NEWLINE> <INDENT> [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for m in range ( M ) <NEWLINE> <DEDENT> ] <NEWLINE> pd ( <STRING> ) <NEWLINE> pd ( <STRING> ) <NEWLINE> <NL> rows = [ 0 ] * ( H + 1 ) <NEWLINE> cols = [ 0 ] * ( W + 1 ) <NEWLINE> bombs = { } <NEWLINE> for m in ms : <NEWLINE> <INDENT> h = m [ 0 ] <NEWLINE> w = m [ 1 ] <NEWLINE> rows [ h ] += 1 <NEWLINE> cols [ w ] += 1 <NEWLINE> bombs [ <STRING> ] = True <NEWLINE> <NL> <DEDENT> rmax = max ( rows ) <NEWLINE> cmax = max ( cols ) <NEWLINE> rmax_hs = [ i for i , v in enumerate ( rows ) if v == rmax ] <NEWLINE> cmax_wh = [ i for i , v in enumerate ( cols ) if v == cmax ] <NEWLINE> <NL> for m in itertools . product ( rmax_hs , cmax_wh ) : <NEWLINE> <INDENT> h = m [ 0 ] <NEWLINE> w = m [ 1 ] <NEWLINE> if <STRING> not in bombs : <NEWLINE> <INDENT> print ( rmax + cmax ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( rmax + cmax - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> num = list ( range ( n - 1 , - ( n - 1 ) - 2 , - 2 ) ) <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] < 0 : <NEWLINE> <INDENT> num [ i ] = abs ( num [ i ] + 1 ) <NEWLINE> <DEDENT> print ( a [ num [ i ] ] , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> array = [ A , B , C ] <NEWLINE> string = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> si = [ ] <COMMENT> <NEWLINE> if A + B + C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> si += ( 0 if s == <STRING> else 1 if s == <STRING> else 2 ) , <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( len ( si ) ) : <NEWLINE> <INDENT> s = si [ i ] <NEWLINE> index = - 3 if s == 0 else - 2 if s == 1 else - 1 <NEWLINE> if array [ index ] == 0 : <NEWLINE> <INDENT> array [ index ] += 1 <NEWLINE> array [ index + 1 ] -= 1 <NEWLINE> ans += string [ index ] , <NEWLINE> <DEDENT> elif array [ index + 1 ] == 0 : <NEWLINE> <INDENT> array [ index ] -= 1 <NEWLINE> array [ index + 1 ] += 1 <NEWLINE> ans += string [ index + 1 ] , <NEWLINE> <DEDENT> elif array [ index ] == 1 and array [ index + 1 ] == 1 : <NEWLINE> <INDENT> if i + 1 >= len ( si ) : <NEWLINE> <INDENT> array [ index ] += 1 <NEWLINE> array [ index + 1 ] -= 1 <NEWLINE> ans += string [ index ] , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if si [ i + 1 ] != ( index + 1 ) % 3 : <NEWLINE> <INDENT> array [ index ] += 1 <NEWLINE> array [ index + 1 ] -= 1 <NEWLINE> ans += string [ index ] , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ index ] -= 1 <NEWLINE> array [ index + 1 ] += 1 <NEWLINE> ans += string [ index + 1 ] , <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif array [ index ] == 1 : <NEWLINE> <INDENT> array [ index ] += 1 <NEWLINE> array [ index + 1 ] -= 1 <NEWLINE> ans += string [ index ] , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ index ] -= 1 <NEWLINE> array [ index + 1 ] += 1 <NEWLINE> ans += string [ index + 1 ] , <NEWLINE> <NL> <DEDENT> if array [ 0 ] < 0 or array [ 1 ] < 0 or array [ 2 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for s in ans : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> L_max = 0 <NEWLINE> R_min = 100000 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if L_max < L : L_max = L <NEWLINE> if R < R_min : R_min = R <NEWLINE> <NL> <NL> <DEDENT> print ( max ( 0 , ( R_min - L_max + 1 ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if l . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k , r , l = LI ( ) <NEWLINE> p = F ( ) <NEWLINE> e = F ( ) <NEWLINE> t = F ( ) <NEWLINE> <NL> def f ( k , r , l ) : <NEWLINE> <INDENT> if abs ( r - t ) <= e and abs ( t - l ) <= e : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if t - l > e or r - t > e : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> if abs ( t - ( r + l ) / 2 ) <= e : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> h = ( r + l ) / 2 <NEWLINE> if h >= t : <NEWLINE> <INDENT> return f ( k - 1 , r , h ) * ( 1 - p ) + f ( k - 1 , h , l ) * p <NEWLINE> <DEDENT> return f ( k - 1 , r , h ) * p + f ( k - 1 , h , l ) * ( 1 - p ) <NEWLINE> <NL> <DEDENT> tr = f ( k , r , l ) <NEWLINE> <NL> return <STRING> . format ( tr ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
a_list = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> if 0 <= a and a <= 10000 : break <NEWLINE> <DEDENT> a_list . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( max ( a_list ) ) <NEWLINE> a_list . remove ( max ( a_list ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ilis = { } <NEWLINE> Jlis = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = a [ i ] + i + 1 <NEWLINE> l = i - a [ i ] + 1 <NEWLINE> if k not in Ilis . keys ( ) : <NEWLINE> <INDENT> Ilis [ k ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ilis [ k ] += 1 <NEWLINE> <DEDENT> if l not in Jlis . keys ( ) : <NEWLINE> <INDENT> Jlis [ l ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Jlis [ l ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in Ilis . keys ( ) : <NEWLINE> <INDENT> if i in Jlis . keys ( ) : <NEWLINE> <INDENT> ans += Ilis [ i ] * Jlis [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if W >= V : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( B - A ) / ( V - W ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> que = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> op = raw_input ( ) . split ( <STRING> ) <NEWLINE> if <STRING> == op [ 0 ] : <NEWLINE> <INDENT> que . appendleft ( op [ 1 ] ) <NEWLINE> <DEDENT> elif <STRING> == op [ 0 ] : <NEWLINE> <INDENT> if op [ 1 ] in que : <NEWLINE> <INDENT> que . remove ( op [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif <STRING> == op [ 0 ] : <NEWLINE> <INDENT> que . popleft ( ) <NEWLINE> <DEDENT> elif <STRING> == op [ 0 ] : <NEWLINE> <INDENT> que . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( que ) ) <NEWLINE>
import copy <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def dfs ( count , pre , ls ) : <NEWLINE> <INDENT> if count == N : <NEWLINE> <INDENT> temp = copy . copy ( ls ) <NEWLINE> num . append ( temp ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for n in range ( pre , M + 1 ) : <NEWLINE> <INDENT> ls [ count ] = n <NEWLINE> dfs ( count + 1 , n , ls ) <NEWLINE> ls [ count ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> num = [ ] <NEWLINE> ls = [ 0 ] * N <NEWLINE> dfs ( 0 , 1 , ls ) <NEWLINE> <NL> q = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> n = num [ i ] <NEWLINE> score = 0 <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = q [ j ] <NEWLINE> if n [ b - 1 ] - n [ a - 1 ] != c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> score += d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , score ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def popcount ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> xl = list ( X ) <NEWLINE> X = int ( X , 2 ) <NEWLINE> a = popcount ( X ) <NEWLINE> <COMMENT> <NL> if a == 1 : <NEWLINE> <INDENT> xd = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xd = X % ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> xi = X % ( a + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if xl [ i ] == <STRING> : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = pow ( 2 , N - 1 - i , a - 1 ) <NEWLINE> x = ( xd - k ) % ( a - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> k = pow ( 2 , N - 1 - i , a + 1 ) <NEWLINE> x = ( xi + k ) % ( a + 1 ) <NEWLINE> <DEDENT> count = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> x %= popcount ( x ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> sum_N = 0 <NEWLINE> S = str ( N ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> sum_N += int ( S [ i ] ) <NEWLINE> <NL> <DEDENT> if sum_N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N , X , D = LI ( ) <NEWLINE> <NL> <NL> def sumeq ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> if D == 0 : <NEWLINE> <INDENT> if X == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = N + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> a = i * X + sumeq ( i - 1 ) * D <NEWLINE> b = sumeq ( N - 1 ) - sumeq ( N - i - 1 ) - sumeq ( i - 1 ) <NEWLINE> v = ( a - a % D ) // D <NEWLINE> if a % D in d : <NEWLINE> <INDENT> d [ a % D ] . append ( ( v , b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a % D ] = [ ( v , b ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for w in d . values ( ) : <NEWLINE> <INDENT> w . sort ( ) <NEWLINE> ans += w [ 0 ] [ 1 ] + 1 <NEWLINE> x = w [ 0 ] [ 0 ] + w [ 0 ] [ 1 ] <NEWLINE> n = len ( w ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> r = w [ i ] [ 0 ] + w [ i ] [ 1 ] <NEWLINE> if x < w [ i ] [ 0 ] : <NEWLINE> <INDENT> ans += w [ i ] [ 1 ] + 1 <NEWLINE> <DEDENT> elif x < r : <NEWLINE> <INDENT> ans += r - x <NEWLINE> <DEDENT> x = max ( x , r ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> cnts = [ 0 , 0 , 0 ] <NEWLINE> for c in S : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> cnts [ 0 ] = cnts [ 0 ] + 1 <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> cnts [ 1 ] = cnts [ 1 ] + 1 <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> cnts [ 2 ] = cnts [ 2 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = cnts [ 0 ] * cnts [ 1 ] * cnts [ 2 ] <NEWLINE> <NL> for j in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , j ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> b = int ( a [ 0 ] ) <NEWLINE> c = int ( a [ 1 ] ) <NEWLINE> <NL> X = 2 <NEWLINE> Y = 4 <NEWLINE> for i in range ( b + 1 ) : <NEWLINE> <INDENT> if b == 1 and c == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif b == 1 and c == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> d = b - i <NEWLINE> if X * i + Y * d == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , * A = list ( map ( int , open ( 0 ) . read ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> exit ( print ( 0 ) ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> exit ( print ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> edges [ u ] . append ( v ) <NEWLINE> edges [ v ] . append ( u ) <NEWLINE> <DEDENT> INF = 10 ** 18 <NEWLINE> ans = [ INF ] * n <NEWLINE> <NL> def dfs ( v , parent ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( lis , A [ v ] ) <NEWLINE> prev = lis [ x ] <NEWLINE> lis [ x ] = A [ v ] <NEWLINE> ans [ v ] = bisect . bisect_left ( lis , INF ) <NEWLINE> for v2 in edges [ v ] : <NEWLINE> <INDENT> if v2 == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( v2 , v ) <NEWLINE> <DEDENT> lis [ x ] = prev <NEWLINE> <NL> <NL> <DEDENT> lis = [ INF ] * n <NEWLINE> dfs ( 0 , - 1 ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
N , M , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> * A , = zip ( * [ iter ( A ) ] * 2 ) <NEWLINE> A . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> R = 0 <NEWLINE> for a , b in A : <NEWLINE> <INDENT> if R <= a : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> R = b <NEWLINE> <DEDENT> elif b < R : <NEWLINE> <INDENT> R = b <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
EPS = 1e-10 <NEWLINE> def crossP ( aa , bb , cc , dd ) : <NEWLINE> <INDENT> a = ( bb - aa ) . real <NEWLINE> b = ( cc - dd ) . real <NEWLINE> c = ( bb - aa ) . imag <NEWLINE> d = ( cc - dd ) . imag <NEWLINE> e = ( cc - aa ) . real <NEWLINE> f = ( cc - aa ) . imag <NEWLINE> det = a * d - b * c <NEWLINE> if abs ( det ) < EPS : <NEWLINE> <INDENT> return ( - 9999 + ( - 9999 ) * 1j ) <NEWLINE> <DEDENT> x = ( d * e - b * f ) / det <NEWLINE> y = ( - c * e + a * f ) / det <NEWLINE> return ( x + y * 1j ) <NEWLINE> <NL> <DEDENT> def rangeP ( st ) : <NEWLINE> <INDENT> return ( ( 0.0 <= st . real <= 1.0 ) and ( 0.0 <= st . imag <= 1.0 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) . strip ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> [ xp1 , yp1 , xp2 , yp2 , xp3 , yp3 , xk , yk , xs , ys ] = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> a = xp1 + yp1 * 1j <NEWLINE> b = xp2 + yp2 * 1j <NEWLINE> c = xp3 + yp3 * 1j <NEWLINE> k = xk + yk * 1j <NEWLINE> s = xs + ys * 1j <NEWLINE> shut = 0 <NEWLINE> if rangeP ( crossP ( a , b , k , s ) ) : <NEWLINE> <INDENT> shut += 1 <NEWLINE> <DEDENT> if rangeP ( crossP ( b , c , k , s ) ) : <NEWLINE> <INDENT> shut += 1 <NEWLINE> <DEDENT> if rangeP ( crossP ( c , a , k , s ) ) : <NEWLINE> <INDENT> shut += 1 <NEWLINE> <DEDENT> if shut == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = [ 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> g . append ( t [ g [ i ] - 1 ] ) <NEWLINE> <DEDENT> if K > len ( g ) : <NEWLINE> <INDENT> a = g . index ( g [ - 1 ] ) <NEWLINE> b = len ( g ) - a - 1 <NEWLINE> K = ( K - a ) % b + a <NEWLINE> <DEDENT> print ( g [ K ] ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> output = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> output += gcd ( a , b , c ) <NEWLINE> <DEDENT> elif a != b and b != c and c != a : <NEWLINE> <INDENT> output += 6 * gcd ( a , b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output += 3 * gcd ( a , b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> r = 0 <NEWLINE> for i1 in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i1 <NEWLINE> r += y * ( y + 1 ) // 2 * i1 <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import bisect <NEWLINE> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> c = collections . Counter ( prime_factorize ( N ) ) <NEWLINE> sums = [ ] <NEWLINE> s = 1 <NEWLINE> ans = 0 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 1 , v + 1 ) : <NEWLINE> <INDENT> if count + i > v : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = n <NEWLINE> prev = a [ 0 ] <NEWLINE> trend = <STRING> <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] > prev : <NEWLINE> <INDENT> if ( trend == <STRING> or trend == <STRING> ) : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> trend = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trend = <STRING> <NEWLINE> <DEDENT> <DEDENT> if a [ i ] < prev : <NEWLINE> <INDENT> if ( trend == <STRING> or trend == <STRING> ) : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> trend = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trend = <STRING> <NEWLINE> <DEDENT> <DEDENT> if a [ i ] == prev : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> prev = a [ i ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ int ( i ) for i in range ( n ) ] <NEWLINE> ab = [ ( x , y ) for x , y in zip ( a , b ) ] <NEWLINE> from operator import itemgetter <NEWLINE> ab = sorted ( ab , key = itemgetter ( 0 ) , reverse = True ) <NEWLINE> dp = [ [ - 10 ** 14 ] * ( n + 1 ) for i in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 2 ) : <NEWLINE> <INDENT> if j >= 1 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] + ab [ i ] [ 0 ] * abs ( ab [ i ] [ 1 ] - ( n - 1 - ( i - j ) ) ) , dp [ i ] [ j - 1 ] + ab [ i ] [ 0 ] * abs ( ab [ i ] [ 1 ] + 1 - j ) ) <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] + ab [ i ] [ 0 ] * abs ( ab [ i ] [ 1 ] - ( n - 1 - i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( dp [ n ] ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def ForbiddenList ( ) : <NEWLINE> <NL> <INDENT> NumA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> NumB = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( NumB ) != 0 : <NEWLINE> <INDENT> result = list ( range ( min ( NumB ) - 1 , max ( NumB ) + 2 , 1 ) ) <NEWLINE> <NL> for data in NumB : <NEWLINE> <INDENT> result . remove ( data ) <NEWLINE> <NL> <DEDENT> idx = np . abs ( np . asarray ( result ) - NumA [ 0 ] ) . argmin ( ) <NEWLINE> <NL> print ( result [ idx ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( NumA [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ForbiddenList ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> l = sorted ( l , reverse = False ) <NEWLINE> <COMMENT> <NL> drinks = 0 <NEWLINE> ttl = 0 <NEWLINE> add = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> add = min ( m - drinks , l [ i ] [ 1 ] ) <NEWLINE> ttl = ttl + add * l [ i ] [ 0 ] <NEWLINE> drinks += add <NEWLINE> if drinks == m : <NEWLINE> <INDENT> print ( ttl ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : print ( <STRING> if a [ i ] > a [ i - k ] else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( 0 , n ) : <NEWLINE> <INDENT> if ab [ _ ] [ 2 ] != 0 : <NEWLINE> <INDENT> x = ab [ _ ] [ 0 ] <NEWLINE> y = ab [ _ ] [ 1 ] <NEWLINE> h = ab [ _ ] [ 2 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> f = True <NEWLINE> l = abs ( i - x ) + abs ( j - y ) + h <NEWLINE> for k in range ( 0 , n ) : <NEWLINE> <INDENT> dx = ab [ k ] [ 0 ] <NEWLINE> dy = ab [ k ] [ 1 ] <NEWLINE> dh = ab [ k ] [ 2 ] <NEWLINE> if max ( l - abs ( i - dx ) - abs ( j - dy ) , 0 ) == dh : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> ansx = i <NEWLINE> ansy = j <NEWLINE> ansr = l <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( str ( ansx ) + <STRING> + str ( ansy ) + <STRING> + str ( ansr ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> print ( <STRING> if 1 < a [ k + i - 1 ] / a [ i - 1 ] else <STRING> ) <NEWLINE> <DEDENT>
[ x , n ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pSet = set ( pList ) <NEWLINE> step = 0 <NEWLINE> small = False <NEWLINE> big = False <NEWLINE> while True : <NEWLINE> <INDENT> if x - step not in pSet : <NEWLINE> <INDENT> small = True <NEWLINE> break <NEWLINE> <DEDENT> if x + step not in pSet : <NEWLINE> <INDENT> big = True <NEWLINE> break <NEWLINE> <DEDENT> step += 1 <NEWLINE> <DEDENT> if small : <NEWLINE> <INDENT> print ( x - step ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + step ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if math . gcd ( a , b ) == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ( math . gcd ( a , b ) ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> n = 0 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( i , k ) : <NEWLINE> <INDENT> for l in range ( j , k ) : <NEWLINE> <INDENT> if i == j == l : <NEWLINE> <INDENT> n += gcd ( i , gcd ( j , l ) ) <NEWLINE> <DEDENT> elif i == j or j == l or l == i : <NEWLINE> <INDENT> n += gcd ( i , gcd ( j , l ) ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += gcd ( i , gcd ( j , l ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = 1 <NEWLINE> summ = 0 <NEWLINE> cont = 0 <NEWLINE> templist = [ 1 ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ i ] < temp : <NEWLINE> <INDENT> if i < N : <NEWLINE> <INDENT> summ += temp <NEWLINE> temp = 2 * ( temp - A [ i ] ) <NEWLINE> templist . append ( temp ) <NEWLINE> <DEDENT> elif i == N : <NEWLINE> <INDENT> summ += temp <NEWLINE> cont += 1 <NEWLINE> <DEDENT> <DEDENT> elif A [ i ] == temp : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> summ += temp <NEWLINE> <COMMENT> <NL> cont += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if cont == 1 : <NEWLINE> <INDENT> if A [ N ] == temp : <NEWLINE> <INDENT> print ( summ ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> comp = A [ - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> summ -= ( templist [ - ( i + 1 ) ] - comp ) <NEWLINE> comp += A [ - ( i + 2 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if comp > templist [ - ( i + 2 ) ] : <NEWLINE> <INDENT> print ( summ ) <NEWLINE> break <NEWLINE> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( summ ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if min ( A ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
symboldict = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> cardlist = [ [ 0 for i in range ( 13 ) ] for j in range ( 4 ) ] <NEWLINE> <NL> total = int ( input ( ) ) <NEWLINE> for i in range ( total ) : <NEWLINE> <INDENT> sym , num = input ( ) . split ( ) <NEWLINE> cardlist [ symboldict [ sym ] ] [ int ( num ) - 1 ] = 1 <NEWLINE> <DEDENT> cnt = 0 ; <NEWLINE> numdict = { num : sym for sym , num in symboldict . items ( ) } <NEWLINE> for j in range ( len ( cardlist ) ) : <NEWLINE> <INDENT> for i in range ( len ( cardlist [ j ] ) ) : <NEWLINE> <INDENT> if cardlist [ j ] [ i ] == 0 : <NEWLINE> <INDENT> print ( numdict [ j ] , i + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( ns ) : <NEWLINE> <INDENT> return reduce ( math . gcd , ns ) <NEWLINE> <NL> <DEDENT> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diff = [ abs ( x - X ) for x in L ] <NEWLINE> <NL> if len ( diff ) == 1 : <NEWLINE> <INDENT> print ( diff [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( gcd ( diff ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ans . append ( input ( ) ) <NEWLINE> <DEDENT> ans = set ( ans ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
n = int ( input ( ) [ - 1 ] ) <NEWLINE> if n in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> alphabet = <STRING> <NEWLINE> num = N <NEWLINE> cnt = 0 <NEWLINE> div = 26 <NEWLINE> res = <STRING> <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> sho = num // div <NEWLINE> amari = num % div <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> res += alphabet [ amari ] <NEWLINE> if amari != 0 : <NEWLINE> <INDENT> num = sho <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = sho - 1 <NEWLINE> <DEDENT> if sho == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif sho == 1 and amari == 0 and alphabet [ amari ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( res [ : : - 1 ] ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> n = 7 % K <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( n * 10 + 7 ) % K <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> C = list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> MAX_C = max ( C ) <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp2 = [ - 1 ] * ( MAX_C + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = C [ i ] <NEWLINE> if dp2 [ c ] >= 0 and dp2 [ c ] < i - 1 : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] + dp [ dp2 [ c ] + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> dp [ i + 1 ] %= mod <NEWLINE> dp2 [ c ] = i <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> for i in range ( int ( a ) ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> print ( b . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> H , W , M = LI ( ) <NEWLINE> hw = { tuple ( LI ( ) ) for _ in range ( M ) } <NEWLINE> <NL> cnt_h = collections . Counter ( [ h for h , w in hw ] ) <NEWLINE> cnt_w = collections . Counter ( [ w for h , w in hw ] ) <NEWLINE> <NL> max_h = max ( cnt_h . values ( ) ) <NEWLINE> max_w = max ( cnt_w . values ( ) ) <NEWLINE> max_h_k = [ k for k , v in cnt_h . items ( ) if v == max_h ] <NEWLINE> max_w_k = [ k for k , v in cnt_w . items ( ) if v == max_w ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> is_on_target = True <NEWLINE> for i , j in itertools . product ( max_h_k , max_w_k ) : <NEWLINE> <INDENT> if ( i , j ) not in hw : <NEWLINE> <INDENT> is_on_target = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_on_target : <NEWLINE> <INDENT> ans = max_h + max_w - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max_h + max_w <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if str . isupper ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> ans = ( b // x ) - ( ( a - 1 ) // x ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> seq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> f = 1 <NEWLINE> c = int ( 1e18 ) <NEWLINE> if 0 in seq : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> p *= seq [ i ] <NEWLINE> if p > c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> f = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> from math import * <NEWLINE> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * pi * r ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> candidate = list ( [ x - 500 for x in range ( 1 , 1000 ) ] ) <NEWLINE> P = sorted ( set ( candidate ) . difference ( set ( P ) ) ) <NEWLINE> i = np . argmin ( [ abs ( p - X ) for p in P ] ) <NEWLINE> print ( P [ i ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> tenki = input ( ) <NEWLINE> leng = len ( tenki ) <NEWLINE> <NL> count = 0 <NEWLINE> lst = [ ] <NEWLINE> for i in range ( leng ) : <NEWLINE> <INDENT> if tenki [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> lst . append ( count ) <NEWLINE> count = 0 <NEWLINE> print ( max ( lst ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> R = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> R = R * A [ i ] <NEWLINE> if R > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( R ) <NEWLINE> <DEDENT>
import re <NEWLINE> <NL> s = re . split ( <STRING> , raw_input ( ) ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> d = len ( i ) <NEWLINE> if d >= 3 and d <= 6 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> ans = 0 <NEWLINE> t = 1 <NEWLINE> b = 1 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += t * pow ( m - 1 , n - 1 - i , mod ) * pow ( b , mod - 2 , mod ) <NEWLINE> ans %= mod <NEWLINE> <COMMENT> <NL> t *= ( n - 1 - i ) <NEWLINE> t %= mod <NEWLINE> b *= ( i + 1 ) <NEWLINE> b %= mod <NEWLINE> <DEDENT> print ( ans * m % mod ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> A = list ( set ( A ) ) <NEWLINE> ok = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> temp = a + a <NEWLINE> while temp < 10 ** 6 + 1 : <NEWLINE> <INDENT> ok [ temp ] = False <NEWLINE> temp += a <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] == 1 and ok [ a ] == True : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> b = ( N - 1 ) // i <NEWLINE> s += b <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
def Repsept ( ) : <NEWLINE> <NL> <INDENT> num = int ( input ( ) ) <NEWLINE> <NL> f = 0 <NEWLINE> n = num <NEWLINE> <NL> for i in range ( 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> n = ( ( n * 10 ) + 7 ) % num <NEWLINE> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Repsept ( ) <NEWLINE> <NL> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 0 <NEWLINE> if n < b : <NEWLINE> <INDENT> m = ( a * n ) // b <NEWLINE> <DEDENT> elif n == b : <NEWLINE> <INDENT> m = max ( ( a * ( n - 1 ) ) // b , ( a * n ) // b - a * ( n // b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( ( a * ( b - 1 ) ) // b , ( a * n ) // b - a * ( n // b ) ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( b - a ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( b - a ) // 2 + min ( a - 1 , n - b ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . u = 1 <NEWLINE> self . w = 2 <NEWLINE> self . s = 3 <NEWLINE> self . e = 4 <NEWLINE> self . n = 5 <NEWLINE> self . d = 6 <NEWLINE> self . dic = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> <NL> <DEDENT> def __init__ ( self , u , w , s , e , n , d ) : <NEWLINE> <INDENT> self . u = u <NEWLINE> self . w = w <NEWLINE> self . s = s <NEWLINE> self . e = e <NEWLINE> self . n = n <NEWLINE> self . d = d <NEWLINE> self . dic = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> <NL> <DEDENT> def rot ( self , way ) : <NEWLINE> <INDENT> if isinstance ( way , str ) : <NEWLINE> <INDENT> way = self . dic [ way ] <NEWLINE> <NL> <DEDENT> if ( way == 0 ) : <NEWLINE> <INDENT> c = self . u <NEWLINE> self . u = self . e <NEWLINE> self . e = self . d <NEWLINE> self . d = self . w <NEWLINE> self . w = c <NEWLINE> <DEDENT> elif way == 1 : <NEWLINE> <INDENT> c = self . u <NEWLINE> self . u = self . n <NEWLINE> self . n = self . d <NEWLINE> self . d = self . s <NEWLINE> self . s = c <NEWLINE> <DEDENT> elif way == 2 : <NEWLINE> <INDENT> c = self . u <NEWLINE> self . u = self . w <NEWLINE> self . w = self . d <NEWLINE> self . d = self . e <NEWLINE> self . e = c <NEWLINE> <DEDENT> <DEDENT> def get_nums ( self ) : <NEWLINE> <INDENT> return { self . u , self . w , self . s , self . e , self . n , self . w , self . d } <NEWLINE> <NL> <DEDENT> <DEDENT> def mk_dice ( ) : <NEWLINE> <INDENT> u , s , e , w , n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> return Dice ( u , w , s , e , n , d ) <NEWLINE> <NL> <DEDENT> import random <NEWLINE> q = int ( input ( ) ) <NEWLINE> dice_col = [ ] <NEWLINE> ans = True <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> dice_b = mk_dice ( ) <NEWLINE> for dice in dice_col : <NEWLINE> <INDENT> if ( dice . get_nums ( ) == dice_b . get_nums ( ) ) : <NEWLINE> <INDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> dice . rot ( random . randint ( 0 , 2 ) ) <NEWLINE> if ( dice . u == dice_b . u and dice . d == dice_b . d and dice . w == dice_b . w and dice . s == dice_b . s and dice . e == dice_b . e and dice . n == dice_b . n ) : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dice_col . append ( dice_b ) <NEWLINE> <NL> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , K , L , R = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> a = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> m = n // 2 <NEWLINE> ls = [ [ ] for _ in range ( m + 1 ) ] <NEWLINE> for i in range ( 1 << m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> val = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> val += a [ j ] <NEWLINE> <DEDENT> <DEDENT> ls [ cnt ] . append ( val ) <NEWLINE> <DEDENT> for i in range ( m + 1 ) : <NEWLINE> <INDENT> ls [ i ] . sort ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 << n - m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> val = 0 <NEWLINE> for j in range ( n - m ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> val += a [ m + j ] <NEWLINE> <DEDENT> <DEDENT> if K - m <= cnt <= K : <NEWLINE> <INDENT> ans += bisect . bisect_right ( ls [ K - cnt ] , R - val ) - bisect . bisect_right ( ls [ K - cnt ] , L - val - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for A in range ( 1 , int ( ( N ) ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> for B in range ( A , int ( ( N ) / A ) + 2 ) : <NEWLINE> <INDENT> if A * B < N : <NEWLINE> <INDENT> count += 1 <NEWLINE> if A != B : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
square = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> data = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> if data [ 0 ] == 0 and data [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> square . append ( data ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( square ) ) : <NEWLINE> <INDENT> for j in range ( square [ i ] [ 0 ] ) : <NEWLINE> <INDENT> for k in range ( square [ i ] [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for num in a : <NEWLINE> <INDENT> res *= num <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for a in range ( 1000 ) : <NEWLINE> <INDENT> for b in range ( 1000 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif a ** 5 - ( - b ) ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> C = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> B = list ( zip ( * B ) ) <NEWLINE> <NL> for i , line_A in enumerate ( A ) : <NEWLINE> <INDENT> for j , line_B in enumerate ( B ) : <NEWLINE> <INDENT> for x , y in zip ( line_A , line_B ) : <NEWLINE> <INDENT> C [ i ] [ j ] += x * y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for line in C : <NEWLINE> <INDENT> for i , x in enumerate ( line ) : <NEWLINE> <INDENT> if i == l - 1 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> L = [ [ ] for i in range ( N + 1 ) ] <COMMENT> <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ a ] . append ( b ) <NEWLINE> L [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> parent = [ 0 ] * ( N + 1 ) <NEWLINE> order = [ ] <NEWLINE> stack = [ 1 ] <NEWLINE> while stack : <NEWLINE> <INDENT> x = stack . pop ( ) <NEWLINE> order . append ( x ) <COMMENT> <NEWLINE> for y in L [ x ] : <NEWLINE> <INDENT> if y == parent [ x ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ y ] = x <COMMENT> <NEWLINE> stack . append ( y ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> half = pow ( 2 , MOD - 2 , MOD ) <NEWLINE> power_inv = [ 1 ] * ( N + 1 ) <COMMENT> <NEWLINE> size = [ 1 ] * ( N + 1 ) <NEWLINE> for i , v in enumerate ( order [ : : - 1 ] , 1 ) : <COMMENT> <NEWLINE> <INDENT> p = parent [ v ] <NEWLINE> x = size [ v ] <COMMENT> <NEWLINE> size [ p ] += x <COMMENT> <NEWLINE> power_inv [ i ] = power_inv [ i - 1 ] * half % MOD <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = sum ( ( 1 - power_inv [ i ] - power_inv [ N - i ] + power_inv [ N ] ) % <NEWLINE> <INDENT> MOD for i in size [ 2 : ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans += 1 <COMMENT> <NEWLINE> <COMMENT> <NL> ans -= power_inv [ N ] + N * power_inv [ 1 ] <NEWLINE> <COMMENT> <NL> ans %= MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def lg ( value ) : <NEWLINE> <INDENT> flag = False <NEWLINE> flag = True <NEWLINE> if flag : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def xt ( log ) : <NEWLINE> <INDENT> lg ( <STRING> + str ( log ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_results ( ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> lines = list ( ) <NEWLINE> <COMMENT> <NL> lines_count = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> K = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> result = 0 <NEWLINE> <NL> tmp = 7 <NEWLINE> <NL> if K % 5 == 0 or K % 2 == 0 : <NEWLINE> <INDENT> return [ - 1 ] <NEWLINE> <NL> <DEDENT> for k in range ( K ) : <NEWLINE> <NL> <INDENT> q , mod = divmod ( tmp , K ) <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> return [ k + 1 ] <NEWLINE> <DEDENT> tmp = mod * 10 + 7 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> results = get_results ( ) <NEWLINE> <NL> for result in results : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import * <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a += bisect_left ( L , L [ i ] + L [ j ] ) - ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> old = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> old += A [ i ] <NEWLINE> s += old * A [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> way = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> ans = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> reached = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> way [ a ] . append ( b ) <NEWLINE> way [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> D = deque ( [ 1 ] ) <NEWLINE> while D : <NEWLINE> <INDENT> go = D . popleft ( ) <NEWLINE> for i in way [ go ] : <NEWLINE> <INDENT> if reached [ i ] == 0 : <NEWLINE> <INDENT> D . append ( i ) <NEWLINE> reached [ i ] = 1 <NEWLINE> ans [ i ] = go <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
input ( ) <NEWLINE> int_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_num = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in int_list : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > max_num : <NEWLINE> <INDENT> if min ( int_list ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if dp [ i ] > 0 : <NEWLINE> <INDENT> for j in range ( 2 * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ sorted ( input ( ) ) for i in range ( N ) ] <NEWLINE> s . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> start = i <NEWLINE> end = N - 1 <NEWLINE> while start != end : <NEWLINE> <INDENT> center = ( start + end ) // 2 <NEWLINE> if s [ center ] == s [ i ] : <NEWLINE> <INDENT> if s [ center + 1 ] == s [ i ] : <NEWLINE> <INDENT> start = center + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = end = center <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> end = center <NEWLINE> <DEDENT> <DEDENT> ans += start - i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def ma ( li ) : <NEWLINE> <COMMENT> <NL> <INDENT> max_num = 0 <NEWLINE> for i in li : <NEWLINE> <INDENT> if max_num < i : <NEWLINE> <INDENT> max_num = i <NEWLINE> <DEDENT> <DEDENT> return max_num <NEWLINE> <NL> <DEDENT> def appen ( li , yousa ) : <NEWLINE> <INDENT> li . append ( yousa ) <NEWLINE> return li <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> f = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> f . append ( [ 0 ] ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> f [ i [ 0 ] - 1 ] . append ( h [ i [ 1 ] - 1 ] ) <NEWLINE> f [ i [ 1 ] - 1 ] . append ( h [ i [ 0 ] - 1 ] ) <NEWLINE> <DEDENT> p = - 1 <NEWLINE> for i in f : <NEWLINE> <INDENT> p += 1 <NEWLINE> if len ( i ) == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> elif ma ( i ) < h [ p ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for j in range ( k ) : <NEWLINE> <INDENT> ans [ 0 ] += ( 1 + p [ j ] ) / 2 <NEWLINE> <DEDENT> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 1 ] - ( 1 + p [ i - 1 ] ) / 2 + ( 1 + p [ i + k - 1 ] ) / 2 <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
def make_alphabet ( now_alphabet , alphabet ) : <NEWLINE> <INDENT> next_alphabet = [ ] <NEWLINE> for n_al in now_alphabet : <NEWLINE> <INDENT> for al in alphabet : <NEWLINE> <INDENT> next_alphabet . append ( n_al + al ) <NEWLINE> <DEDENT> <DEDENT> return next_alphabet <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for a in range ( a ) : <NEWLINE> <INDENT> b . append ( input ( ) ) <NEWLINE> <DEDENT> alphabet = [ chr ( ch ) for ch in range ( 97 , 123 ) ] <NEWLINE> now_alphabet = alphabet <NEWLINE> count = 0 <NEWLINE> flag = 0 <NEWLINE> <NL> while flag == 0 : <NEWLINE> <INDENT> letter = [ ] <NEWLINE> for word in b : <NEWLINE> <INDENT> for i in range ( len ( word ) - count ) : <NEWLINE> <INDENT> letter . append ( word [ i : i + 1 + count ] ) <NEWLINE> <DEDENT> <DEDENT> rem = list ( set ( now_alphabet ) - set ( letter ) ) <NEWLINE> if rem != [ ] : <NEWLINE> <INDENT> print ( sorted ( rem ) [ 0 ] ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> count += 1 <NEWLINE> now_alphabet = make_alphabet ( now_alphabet , alphabet ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ab . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ ai - 1 ] >= h [ bi - 1 ] : <NEWLINE> <INDENT> ab [ bi - 1 ] += 1 <NEWLINE> <DEDENT> if h [ ai - 1 ] <= h [ bi - 1 ] : <NEWLINE> <INDENT> ab [ ai - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ab . count ( 0 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ - 1 ] * N <COMMENT> <NEWLINE> dp [ N - 1 ] = 0 <NEWLINE> <NL> def rec_memo ( i ) : <NEWLINE> <INDENT> if dp [ i ] >= 0 : <NEWLINE> <INDENT> return dp [ i ] <NEWLINE> <NL> <DEDENT> if i == N - 2 : <NEWLINE> <INDENT> dp [ i ] = rec_memo ( i + 1 ) + abs ( h [ i + 1 ] - h [ i ] ) <NEWLINE> return dp [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( rec_memo ( i + 1 ) + abs ( h [ i + 1 ] - h [ i ] ) , rec_memo ( i + 2 ) + abs ( h [ i + 2 ] - h [ i ] ) ) <NEWLINE> return dp [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( rec_memo ( 0 ) ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> num = round ( p ** ( 1 / n ) ) <NEWLINE> for i in range ( num , 0 , - 1 ) : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from math import sqrt , floor <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def prime_generator ( ) : <NEWLINE> <INDENT> prime = set ( ) <NEWLINE> yield 2 <NEWLINE> i = 3 <NEWLINE> while True : <NEWLINE> <INDENT> for d in prime : <NEWLINE> <INDENT> if not ( i % d ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> yield i <NEWLINE> prime . add ( i ) <NEWLINE> <DEDENT> i += 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> nstr = input ( ) <NEWLINE> n = int ( nstr ) <NEWLINE> limit = floor ( sqrt ( n ) ) <NEWLINE> a = deque ( ) <NEWLINE> <NL> for p in prime_generator ( ) : <NEWLINE> <INDENT> if p > limit : <NEWLINE> <INDENT> if n > 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> while not ( n % p ) : <NEWLINE> <INDENT> a . append ( p ) <NEWLINE> n = n // p <NEWLINE> limit = floor ( sqrt ( n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> a . appendleft ( nstr + <STRING> ) <NEWLINE> print ( * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> % ( i , d [ i ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bbb = [ format ( a , <STRING> ) for a in aaa ] <NEWLINE> <NL> zero = [ 0 ] * 61 <NEWLINE> one = [ 0 ] * 61 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> s = <STRING> . join ( list ( b [ - ( i + 1 ) ] for b in bbb ) ) <NEWLINE> zero [ i ] = s . count ( <STRING> ) <NEWLINE> one [ i ] = s . count ( <STRING> ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> MOD = 1_000_000_007 <NEWLINE> for i , o , l in zip ( range ( 61 ) , zero , one ) : <NEWLINE> <INDENT> ans += 2 ** i * o * l <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x = abs ( x ) <NEWLINE> x = x - k * d if x >= k * d else abs ( x % d - ( k - x // d ) % 2 * d ) <NEWLINE> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> N = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> global FLAG_LOG <NEWLINE> FLAG_LOG = False <NEWLINE> <NL> <NL> def log ( value ) : <NEWLINE> <INDENT> return <NEWLINE> if FLAG_LOG : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation ( lines ) : <NEWLINE> <INDENT> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , K = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> values = list ( map ( int , lines [ 1 ] . split ( ) ) ) <NEWLINE> lvalues = [ math . log ( value ) for value in values ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> lmarks = list ( ) <NEWLINE> <NL> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> ltargets = lvalues [ i : i + K ] <NEWLINE> <COMMENT> <NL> log ( <STRING> ) <NEWLINE> <COMMENT> <NL> lmark = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for ltarget in ltargets : <NEWLINE> <INDENT> lmark += ltarget <NEWLINE> <DEDENT> lmarks . append ( lmark ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lmark = lmark - lvalues [ i - 1 ] + lvalues [ i + K - 1 ] <NEWLINE> lmarks . append ( lmark ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> lrets = list ( ) <NEWLINE> <COMMENT> <NL> lprev = None <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for lmark in lmarks : <NEWLINE> <INDENT> if lprev is None : <NEWLINE> <INDENT> lprev = lmark <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lprev < lmark : <NEWLINE> <INDENT> lrets . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lrets . append ( <STRING> ) <NEWLINE> <DEDENT> lprev = lmark <NEWLINE> <NL> <DEDENT> <DEDENT> return lrets <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> , <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> global FLAG_LOG <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> FLAG_LOG = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> FLAG_LOG = True <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <DEDENT> if mode > 0 : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> if lines_result == lines_export : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> finished = time . time ( ) <NEWLINE> duration = finished - started <NEWLINE> log ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy <NEWLINE> <NL> inp = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( inp [ 0 ] ) <NEWLINE> m = int ( inp [ 1 ] ) <NEWLINE> inh = input ( ) . split ( <STRING> ) <NEWLINE> for i in range ( len ( inh ) ) : <NEWLINE> <INDENT> inh [ i ] = int ( inh [ i ] ) <NEWLINE> <DEDENT> pairs = numpy . zeros ( 2 * m , dtype = <STRING> ) . reshape ( - 1 , 2 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a = input ( ) . split ( <STRING> ) <NEWLINE> pairs [ i ] [ 0 ] = int ( a [ 0 ] ) <NEWLINE> pairs [ i ] [ 1 ] = int ( a [ 1 ] ) <NEWLINE> <DEDENT> lists = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( len ( pairs ) ) : <NEWLINE> <INDENT> lists [ pairs [ i ] [ 0 ] - 1 ] . append ( pairs [ i ] [ 1 ] - 1 ) <NEWLINE> lists [ pairs [ i ] [ 1 ] - 1 ] . append ( pairs [ i ] [ 0 ] - 1 ) <NEWLINE> <DEDENT> for i in range ( len ( lists ) ) : <NEWLINE> <INDENT> lists [ i ] = list ( set ( lists [ i ] ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( lists ) ) : <NEWLINE> <INDENT> if len ( lists [ i ] ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( len ( lists [ i ] ) ) : <NEWLINE> <INDENT> if inh [ i ] <= inh [ lists [ i ] [ j ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if j == len ( lists [ i ] ) - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = min ( b - 1 , n ) <NEWLINE> print ( int ( a * ans / b ) - a * int ( ans / b ) ) <NEWLINE>
import networkx as nx <NEWLINE> room , route_count = map ( int , input ( ) . split ( ) ) <NEWLINE> route = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( route_count ) ] <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> G . add_nodes_from ( range ( 1 , room + 1 ) ) <NEWLINE> G . add_edges_from ( route ) <NEWLINE> pre = nx . predecessor ( G , 1 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for i in range ( 2 , room + 1 ) : <NEWLINE> <INDENT> print ( pre [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = c + A [ i ] ** 2 <NEWLINE> <NL> <DEDENT> print ( ( sum ( A ) ** 2 - c ) // 2 % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , m , _ = map ( int , input ( ) . split ( ) ) <NEWLINE> exem = list ( range ( n ) ) <NEWLINE> i = 0 <NEWLINE> <NL> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> is_odd = a & 1 <NEWLINE> i += - a if a & 1 else a <NEWLINE> i %= n <NEWLINE> exem . pop ( i ) <NEWLINE> n -= 1 <NEWLINE> <NL> <DEDENT> for q in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> print ( int ( q in exem ) ) <NEWLINE> <DEDENT>
<NL> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> tmp = input ( ) . split ( ) <NEWLINE> K = int ( tmp [ 0 ] ) <NEWLINE> <NL> SGCD = 0 <NEWLINE> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for c in range ( K + 1 ) [ 1 : ] : <NEWLINE> <INDENT> for b in range ( c + 1 ) [ 1 : ] : <NEWLINE> <INDENT> for a in range ( b + 1 ) [ 1 : ] : <NEWLINE> <INDENT> if not a == b and not b == c : <NEWLINE> <INDENT> SGCD = SGCD + 6 * gcd ( a , b , c ) <NEWLINE> <DEDENT> elif a == b and not b == c : <NEWLINE> <INDENT> SGCD = SGCD + 3 * gcd ( a , b , c ) <NEWLINE> <DEDENT> elif not a == b and b == c : <NEWLINE> <INDENT> SGCD = SGCD + 3 * gcd ( a , b , c ) <NEWLINE> <DEDENT> elif a == b and b == c : <NEWLINE> <INDENT> SGCD = SGCD + gcd ( a , b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( SGCD ) ) <NEWLINE>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i < K : <NEWLINE> <INDENT> times = math . ceil ( math . log2 ( K / i ) ) <NEWLINE> p = p + ( 1 / N ) * ( 1 / 2 ) ** times <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p + ( 1 / N ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <NL>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 ) <NEWLINE>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> <NL> d = defaultdict ( set ) <COMMENT> <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ A - 1 ] . add ( B - 1 ) <NEWLINE> d [ B - 1 ] . add ( A - 1 ) <NEWLINE> <NL> <DEDENT> check = [ 0 ] * N <NEWLINE> mans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if check [ i ] == 0 : <NEWLINE> <INDENT> check [ i ] = 1 <NEWLINE> ans += 1 <NEWLINE> sl = deque ( list ( d [ i ] ) ) <NEWLINE> while sl : <NEWLINE> <INDENT> s = sl . pop ( ) <NEWLINE> if check [ s ] == 0 : <NEWLINE> <INDENT> check [ s ] = 1 <NEWLINE> ans += 1 <NEWLINE> sl . extend ( list ( d [ s ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if mans < ans : <NEWLINE> <INDENT> mans = ans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mans ) <NEWLINE>
<COMMENT> <NL> sample_input = list ( range ( 3 ) ) <NEWLINE> sample_input [ 0 ] = <STRING> <NEWLINE> sample_input [ 1 ] = <STRING> <NEWLINE> sample_input [ 2 ] = <STRING> <NEWLINE> give_sample_input = None <NEWLINE> if give_sample_input is not None : <NEWLINE> <INDENT> sample_input_list = sample_input [ give_sample_input ] . split ( <STRING> ) <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sample_input_list . pop ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> import copy <NEWLINE> <NL> def swap_list_item ( lst , i , j ) : <NEWLINE> <INDENT> tmp = lst [ i ] <NEWLINE> lst [ i ] = lst [ j ] <NEWLINE> lst [ j ] = tmp <NEWLINE> <NL> <DEDENT> class Card : <NEWLINE> <INDENT> number = None <NEWLINE> mark = None <NEWLINE> def __init__ ( self , str_card ) : <NEWLINE> <INDENT> self . number = int ( str_card [ 1 ] ) <NEWLINE> self . mark = str_card [ 0 ] <NEWLINE> pass <NEWLINE> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> return self . number == other . number <NEWLINE> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . number < other . number <NEWLINE> <DEDENT> def to_str ( self ) : <NEWLINE> <INDENT> return self . mark + str ( self . number ) <NEWLINE> <NL> <DEDENT> <DEDENT> def selection_sort ( list_of_data ) : <NEWLINE> <INDENT> num_of_data = len ( list_of_data ) <NEWLINE> for i in range ( num_of_data ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , num_of_data ) : <NEWLINE> <INDENT> if list_of_data [ minj ] > list_of_data [ j ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if not minj == i : <NEWLINE> <INDENT> swap_list_item ( list_of_data , i , minj ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def bubble_sort ( list_of_data ) : <NEWLINE> <INDENT> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> n = num_of_data - 1 <NEWLINE> while n >= 1 : <NEWLINE> <INDENT> if list_of_data [ n ] < list_of_data [ n - 1 ] : <NEWLINE> <INDENT> swap_list_item ( list_of_data , n , n - 1 ) <NEWLINE> flag = True <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def get_mark_order_info ( card_list , number ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> for card in card_list : <NEWLINE> <INDENT> if card . number == number : <NEWLINE> <INDENT> result += card . mark <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def print_card_list ( card_list ) : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> for card in card_list : <NEWLINE> <INDENT> output += card . to_str ( ) + <STRING> <NEWLINE> <DEDENT> output = output . rstrip ( ) <NEWLINE> print ( output ) <NEWLINE> <NL> <DEDENT> num_of_data = int ( input ( ) ) <NEWLINE> data_list_str = input ( ) . split ( ) <NEWLINE> data_cards = [ Card ( str ) for str in data_list_str ] <NEWLINE> data_cards_bubble = copy . copy ( data_cards ) <NEWLINE> data_cards_selection = copy . copy ( data_cards ) <NEWLINE> <NL> mark_order_info = [ ] <NEWLINE> for number in [ n + 1 for n in range ( 13 ) ] : <NEWLINE> <INDENT> mark_order_info . append ( get_mark_order_info ( data_cards , number ) ) <NEWLINE> <NL> <DEDENT> bubble_sort ( data_cards_bubble ) <NEWLINE> selection_sort ( data_cards_selection ) <NEWLINE> <NL> mark_order_info_bubble = [ ] <NEWLINE> for number in [ n + 1 for n in range ( 13 ) ] : <NEWLINE> <INDENT> mark_order_info_bubble . append ( get_mark_order_info ( data_cards_bubble , number ) ) <NEWLINE> <NL> <DEDENT> mark_order_info_selection = [ ] <NEWLINE> for number in [ n + 1 for n in range ( 13 ) ] : <NEWLINE> <INDENT> mark_order_info_selection . append ( get_mark_order_info ( data_cards_selection , number ) ) <NEWLINE> <NL> <DEDENT> print_card_list ( data_cards_bubble ) <NEWLINE> if ( mark_order_info == mark_order_info_bubble ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> print_card_list ( data_cards_selection ) <NEWLINE> if ( mark_order_info == mark_order_info_selection ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
p , q , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def comb_mod ( N , K , modp ) : <NEWLINE> <NL> <INDENT> K_fact = 1 <NEWLINE> NK_fact = 1 <NEWLINE> N_fact = 1 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> K_fact *= i <NEWLINE> K_fact = K_fact % modp <NEWLINE> <DEDENT> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> NK_fact *= i <NEWLINE> NK_fact = NK_fact % modp <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> N_fact *= i <NEWLINE> N_fact = N_fact % modp <NEWLINE> <NL> <DEDENT> K_inv = pow ( K_fact , - 1 , modp ) <NEWLINE> NK_inv = pow ( NK_fact , - 1 , modp ) <NEWLINE> pat = ( N_fact * K_inv ) % modp * NK_inv % modp <NEWLINE> return pat <NEWLINE> <NL> <DEDENT> pat = comb_mod ( p * q - 2 , r - 2 , 10 ** 9 + 7 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , q + 1 ) : <NEWLINE> <INDENT> ans += i * ( q - i ) * p * p <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> for k in range ( 0 , p + 1 ) : <NEWLINE> <INDENT> ans += k * ( p - k ) * q * q % ( 10 ** 9 + 7 ) <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans * pat % ( 10 ** 9 + 7 ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = A [ - 1 ] <NEWLINE> c = Counter ( A ) <NEWLINE> s = set ( ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i = 1 <NEWLINE> while a * i <= M : <NEWLINE> <INDENT> s . add ( a * i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> lst = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in lst : print ( lst [ i ] ) <NEWLINE> else : print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = len ( lst ) <NEWLINE> lst = list ( set ( lst ) ) <NEWLINE> y = len ( lst ) <NEWLINE> <NL> if ( x == y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> x = 7 % k <NEWLINE> <NL> flg = False <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = x % k <NEWLINE> if x == 0 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x * 10 + 7 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i if flg else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if b % a == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> x = i + 2 <NEWLINE> <COMMENT> <NL> if a % x == 0 : <NEWLINE> <INDENT> if b % x == 0 : <NEWLINE> <INDENT> c . append ( x ) <NEWLINE> a = a // x <NEWLINE> b = b // x <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> elif b % ( a // x ) == 0 : <NEWLINE> <INDENT> c . append ( a // x ) <NEWLINE> a = x <NEWLINE> b = b // ( a // x ) <NEWLINE> <COMMENT> <NL> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if x > a ** 0.5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if x > a ** 0.5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> s = 1 <NEWLINE> for j in c : <NEWLINE> <INDENT> s = s * j <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> ini = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( inm ( ) ) <NEWLINE> ins = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> debug = lambda * a , ** kw : print ( <STRING> , * a , <STRING> , ** dict ( file = sys . stderr , ** kw ) ) <NEWLINE> <NL> n , m = inm ( ) <NEWLINE> a = inl ( ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> g = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = inm ( ) <NEWLINE> g . append ( ( c , b ) ) <NEWLINE> <DEDENT> g . sort ( reverse = True ) <NEWLINE> h = [ ] <NEWLINE> for c , b in g : <NEWLINE> <INDENT> if len ( h ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> h . append ( c ) <NEWLINE> if len ( h ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> assert len ( h ) <= n <NEWLINE> <NL> heapq . heapify ( a ) <NEWLINE> for x in h : <NEWLINE> <INDENT> if a [ 0 ] >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> heapq . heappush ( a , x ) <NEWLINE> heapq . heappop ( a ) <NEWLINE> <DEDENT> return sum ( a ) <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( n // k ) ** 3 + ( ~ k & 1 ) * ( n // - ( - k // 2 ) - n // k ) ** 3 ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> def isPrime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> def calc ( n ) : <NEWLINE> <INDENT> used = set ( ) <NEWLINE> a = 0 <NEWLINE> c = True <NEWLINE> c1 = [ ] <NEWLINE> ds = divisors ( n ) <NEWLINE> m = max ( ds ) <NEWLINE> for d in ds : <NEWLINE> <INDENT> if not isPrime ( d ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = d <NEWLINE> i = 1 <NEWLINE> while v <= m : <NEWLINE> <INDENT> c1 . append ( v ) <NEWLINE> i += 1 <NEWLINE> v = d ** i <NEWLINE> <DEDENT> <DEDENT> c1 . sort ( ) <NEWLINE> while c : <NEWLINE> <INDENT> c = False <NEWLINE> for d in c1 : <NEWLINE> <INDENT> if d in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if n % d != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> n //= d <NEWLINE> a += 1 <NEWLINE> c = True <NEWLINE> used . add ( d ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> print ( calc ( n ) ) <NEWLINE>
kingaku , n = input ( ) . split ( ) <NEWLINE> no_num = input ( ) . split ( ) <NEWLINE> result = [ ] <NEWLINE> ok_num = [ ] <NEWLINE> kuriage_num = [ - 1 , 0 ] <NEWLINE> <NL> def kuriage ( l ) : <NEWLINE> <INDENT> for i in ok_num : <NEWLINE> <INDENT> if result [ l ] < i : <NEWLINE> <INDENT> kuriage_num = [ l , i ] <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if l <= 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> return kuriage ( l - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> if not str ( i ) in no_num : <NEWLINE> <INDENT> ok_num . append ( str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> set_flg = False <NEWLINE> for i in kingaku : <NEWLINE> <INDENT> set_flg = True <NEWLINE> for j in ok_num : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> set_flg = False <NEWLINE> result . append ( j ) <NEWLINE> break <NEWLINE> <DEDENT> elif i < j : <NEWLINE> <INDENT> result . append ( j ) <NEWLINE> print ( <STRING> . join ( result ) . ljust ( len ( kingaku ) , ok_num [ 0 ] ) ) <NEWLINE> exit ( ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if set_flg : <NEWLINE> <INDENT> n = 0 <NEWLINE> if ok_num [ 0 ] == <STRING> : <NEWLINE> <INDENT> n = 1 <NEWLINE> <DEDENT> print ( ok_num [ n ] . ljust ( len ( kingaku ) + 1 , ok_num [ 0 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> sevens = 7 % K <NEWLINE> count = 1 <NEWLINE> <NL> while ( sevens % K != 0 ) : <NEWLINE> <INDENT> sevens = sevens * ( 10 % K ) + ( 7 % K ) <NEWLINE> sevens = sevens % K <NEWLINE> count += 1 <NEWLINE> if count > K : <NEWLINE> <INDENT> count = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def trace ( A , input_num ) : <NEWLINE> <INDENT> for i in range ( input_num ) : <NEWLINE> <INDENT> if i != input_num - 1 : <NEWLINE> <INDENT> print ( A [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def insertionSort ( A , input_num ) : <NEWLINE> <INDENT> for i in range ( input_num ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 and A [ j ] > v ) : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> trace ( A , input_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> input_num = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> insertionSort ( A , input_num ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> rst = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> rst += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( rst ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <NL> ans_list = [ 0 ] * N <NEWLINE> <NL> for i in range ( len ( A_list ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans_list [ A_list [ i ] - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( ans_list ) ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = make_divisors ( np . gcd ( A , B ) ) <NEWLINE> N . sort ( reverse = True ) <NEWLINE> print ( N [ K - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> a = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( a * a * math . pi , a * 2 * math . pi ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = list ( s ) <NEWLINE> <COMMENT> <NL> i = 0 <NEWLINE> j = n - 1 <NEWLINE> cnt = 0 <NEWLINE> while ( i < j ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> and l [ j ] == <STRING> : <NEWLINE> <INDENT> l [ j ] = <STRING> <NEWLINE> l [ i ] = <STRING> <NEWLINE> i = i + 1 <NEWLINE> j = j - 1 <NEWLINE> cnt = cnt + 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> if l [ j ] == <STRING> : <NEWLINE> <INDENT> j = j - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while ( len ( l ) > 0 ) : <NEWLINE> <INDENT> if l [ - 1 ] == <STRING> : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if l [ - 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> k = <STRING> . join ( l ) <NEWLINE> print ( k . count ( <STRING> ) + cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss = input ( ) <NEWLINE> s . append ( ss ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ j ] != s [ j - 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> quary = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> temp = list ( input ( ) . split ( ) ) <NEWLINE> quary . append ( temp ) <NEWLINE> <DEDENT> switch = False <NEWLINE> first = <STRING> <NEWLINE> last = <STRING> <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if quary [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> if switch : <NEWLINE> <INDENT> switch = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> switch = True <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if quary [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> if switch : <NEWLINE> <INDENT> last += quary [ i ] [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first += quary [ i ] [ 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if switch : <NEWLINE> <INDENT> first += quary [ i ] [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last += quary [ i ] [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> s = first [ : : - 1 ] + s + last <NEWLINE> if switch : <NEWLINE> <INDENT> print ( s [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
import copy , collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> size = max ( a ) <NEWLINE> a . sort ( ) <NEWLINE> a = collections . deque ( a ) <NEWLINE> a2 = copy . copy ( a ) <NEWLINE> b = [ 0 ] * ( size + 1 ) <NEWLINE> while a : <NEWLINE> <INDENT> test = a . popleft ( ) <NEWLINE> count = 1 <NEWLINE> if not a : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while a [ 0 ] == test : <NEWLINE> <INDENT> a . popleft ( ) <NEWLINE> count += 1 <NEWLINE> if not a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( size // test ) : <NEWLINE> <INDENT> b [ test * ( i + 1 ) ] += count <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ a2 [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> YES = <STRING> <COMMENT> <NEWLINE> NO = <STRING> <COMMENT> <NEWLINE> <NL> <NL> def solve ( N : int , M : int , a : <STRING> , b : <STRING> ) : <NEWLINE> <INDENT> AB = sorted ( zip ( a , b ) ) <NEWLINE> s = set ( [ b for a , b in AB if a == 1 ] ) <NEWLINE> g = set ( [ a for a , b in AB if b == N ] ) <NEWLINE> return YES if s & g else NO <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( ) ] * ( M ) <COMMENT> <NEWLINE> b = [ int ( ) ] * ( M ) <COMMENT> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a [ i ] = int ( next ( tokens ) ) <NEWLINE> b [ i ] = int ( next ( tokens ) ) <NEWLINE> <DEDENT> print ( solve ( N , M , a , b ) ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> def perf ( ) : <NEWLINE> <INDENT> import cProfile <NEWLINE> cProfile . run ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> if ( k % 2 == 0 or k % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> seven = 7 % k <NEWLINE> while seven != 0 : <NEWLINE> <INDENT> seven = ( seven * 10 + 7 ) % k <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] -= 1 <NEWLINE> <NL> <DEDENT> tele = [ 0 ] <NEWLINE> <COMMENT> <NL> z = 0 <NEWLINE> s = 0 <NEWLINE> <COMMENT> <NL> B = { 0 : 0 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ tele [ - 1 ] ] in B and len ( B ) != 1 : <NEWLINE> <INDENT> s = B [ A [ tele [ - 1 ] ] ] <NEWLINE> break <NEWLINE> <DEDENT> B [ A [ tele [ - 1 ] ] ] = i + 1 <NEWLINE> tele . append ( A [ tele [ - 1 ] ] ) <NEWLINE> z = tele [ - 1 ] <NEWLINE> <NL> <DEDENT> if K <= s : <NEWLINE> <INDENT> print ( tele [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= s <NEWLINE> amari = K % ( len ( tele [ s : len ( tele ) ] ) ) <NEWLINE> tele = tele [ s : len ( tele ) ] * 2 <NEWLINE> print ( tele [ amari ] + 1 ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> DR = [ 1 , - 1 , 0 , 0 ] <NEWLINE> DC = [ 0 , 0 , 1 , - 1 ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> used = [ 0 for _ in range ( N ) ] <NEWLINE> cur = 0 <NEWLINE> pairs = [ ] <NEWLINE> used = set ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> b = N <NEWLINE> while len ( pairs ) < M : <NEWLINE> <INDENT> if b - a in used or N + a - b in used or b - a == N // 2 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> pairs . append ( ( a , b ) ) <NEWLINE> used . add ( b - a ) <NEWLINE> used . add ( N + a - b ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> b = N - 1 <NEWLINE> while len ( pairs ) < M : <NEWLINE> <INDENT> pairs . append ( ( a , b ) ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> <DEDENT> for p in pairs : <NEWLINE> <INDENT> print ( p [ 0 ] , p [ 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> UVAB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> CD = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> es = [ [ ] for _ in range ( N ) ] <NEWLINE> for u , v , a , b in UVAB : <NEWLINE> <INDENT> u , v = u - 1 , v - 1 <NEWLINE> es [ u ] . append ( ( v , a , b ) ) <NEWLINE> es [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <DEDENT> INF = float ( <STRING> ) <NEWLINE> times = [ INF ] * ( 2501 * N ) <NEWLINE> start = min ( 2500 , S ) * N <NEWLINE> times [ start ] = 0 <NEWLINE> hq = [ start ] <NEWLINE> ans = [ - 1 ] * N <NEWLINE> ans [ 0 ] = 0 <NEWLINE> reached = 0 <NEWLINE> import heapq <NEWLINE> heapq . heapify ( hq ) <NEWLINE> while hq : <NEWLINE> <INDENT> x = heapq . heappop ( hq ) <NEWLINE> t , v = divmod ( x , N * 2501 ) <NEWLINE> s , i = divmod ( v , N ) <NEWLINE> if ans [ i ] < 0 : <NEWLINE> <INDENT> ans [ i ] = t <NEWLINE> reached += 1 <NEWLINE> if reached == N - 1 : break <NEWLINE> <DEDENT> for to , a , b in es [ i ] : <NEWLINE> <INDENT> if a > s : continue <NEWLINE> nv = ( s - a ) * N + to <NEWLINE> if times [ nv ] <= t + b : continue <NEWLINE> times [ nv ] = t + b <NEWLINE> heapq . heappush ( hq , ( t + b ) * N * 2501 + nv ) <NEWLINE> <DEDENT> ns = s <NEWLINE> nt = times [ v ] <NEWLINE> while ns <= 2500 : <NEWLINE> <INDENT> ns += CD [ i ] [ 0 ] <NEWLINE> nt += CD [ i ] [ 1 ] <NEWLINE> nv = min ( 2500 , ns ) * N + i <NEWLINE> if times [ nv ] <= nt : break <NEWLINE> times [ nv ] = nt <NEWLINE> heapq . heappush ( hq , nt * N * 2501 + nv ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> x100 = S . find ( str ( i ) ) <NEWLINE> if x100 == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> x10 = S . find ( str ( j ) , x100 + 1 ) <NEWLINE> if x10 == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if S . find ( str ( k ) , x10 + 1 ) != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( pi * r ** 2 , 2 * pi * r ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> h . sort ( ) <NEWLINE> <NL> ans = h [ - 1 ] - h [ 0 ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , h [ i + k - 1 ] - h [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dict = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> order = input ( ) . split ( ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dict [ order [ 1 ] ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if order [ 1 ] in dict : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> mod = 998244353 <NEWLINE> s , k = input ( ) . split ( ) <NEWLINE> k , n , o , cnt , z , zero_list = int ( k ) , len ( s ) , s . count ( <STRING> ) + 1 , 0 , 0 , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> zero_list . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> m = min ( o , k + 1 ) <NEWLINE> <NL> dp = [ [ 0 ] * m for _ in [ 0 ] * o ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in zero_list : <NEWLINE> <INDENT> dp2 = [ [ 0 ] * m for _ in [ 0 ] * o ] <NEWLINE> dp3 = [ [ 0 ] for _ in [ 0 ] * o ] <NEWLINE> for x in range ( o ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for y in range ( min ( m , o - x ) ) : <NEWLINE> <INDENT> t = ( t + dp [ x + y ] [ y ] ) % mod <NEWLINE> dp3 [ x ] . append ( t ) <NEWLINE> <DEDENT> <DEDENT> dp4 = [ [ 0 ] * m for _ in [ 0 ] * o ] <NEWLINE> for y in range ( m ) : <NEWLINE> <INDENT> t = dp [ 0 ] [ y ] <NEWLINE> for x in range ( 1 , o ) : <NEWLINE> <INDENT> dp4 [ x - 1 ] [ y ] = t <NEWLINE> t = ( t + dp [ x ] [ y ] ) % mod <NEWLINE> <DEDENT> dp4 [ o - 1 ] [ y ] = t <NEWLINE> <DEDENT> for j in range ( z + i , o ) : <NEWLINE> <INDENT> for x in range ( min ( j - i + 1 , m ) ) : <NEWLINE> <INDENT> dp2 [ j ] [ x ] = ( dp2 [ j ] [ x ] + dp3 [ j - x - i ] [ min ( o , x + 1 ) ] ) % mod <NEWLINE> <DEDENT> for p in range ( m ) : <NEWLINE> <INDENT> dp2 [ j ] [ p ] = ( dp2 [ j ] [ p ] + dp4 [ j ] [ p ] - dp4 [ max ( j - i , p - 1 ) ] [ p ] ) % mod <NEWLINE> <DEDENT> <DEDENT> z += i <NEWLINE> dp = dp2 <NEWLINE> <DEDENT> print ( sum ( [ sum ( i ) for i in dp ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> <NL> count = 0 <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( temp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> ans = list ( ) <NEWLINE> min = float ( <STRING> ) <NEWLINE> r = range ( - 200 , 200 ) <NEWLINE> for A in r : <NEWLINE> <INDENT> for B in r : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> if A ** 5 - B ** 5 < min : <NEWLINE> <INDENT> if len ( ans ) != 0 : ans . pop ( ) <NEWLINE> ans . append ( [ A , B ] ) <NEWLINE> min = A ** 5 - B ** 5 <NEWLINE> break <NEWLINE> <DEDENT> elif A ** 5 - B ** 5 == min : <NEWLINE> <INDENT> ans . append ( [ A , B ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = ans [ 1 ] <NEWLINE> A = ans [ 0 ] <NEWLINE> B = ans [ 1 ] <NEWLINE> print ( A , B ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( x + y ) <NEWLINE> Y . append ( x - y ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> maxX = max ( X ) <NEWLINE> maxY = max ( Y ) <NEWLINE> minX = min ( X ) <NEWLINE> minY = min ( Y ) <NEWLINE> <NL> ans = max ( maxX - minX , maxY - minY ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE> <NL>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> flag = [ 0 ] * N <NEWLINE> <NL> ans = 0 <NEWLINE> M = A [ - 1 ] <NEWLINE> B = [ 0 ] * ( M + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> if B [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( i , M + 1 , i ) : <NEWLINE> <INDENT> B [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = ( N - 1 ) // i <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans += cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> <COMMENT> <NL> INF = 1 << 50 <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> a = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + i * k <NEWLINE> if a <= n : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x0 = 0 <NEWLINE> x1 = 10 ** 9 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> mid = ( x0 + x1 ) // 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += math . ceil ( a [ i ] / mid ) - 1 <NEWLINE> <DEDENT> if ( sum <= k ) : <NEWLINE> <INDENT> x1 = mid <NEWLINE> <DEDENT> if ( sum > k ) : <NEWLINE> <INDENT> x0 = mid <NEWLINE> <DEDENT> if ( x0 + 1 == x1 ) : <NEWLINE> <INDENT> print ( x1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 17 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> val = [ 0 ] * n <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> val [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> seen = [ False ] * n <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> for nv in g [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> val [ nv ] += val [ v ] <NEWLINE> dfs ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * val ) <NEWLINE>
f = lambda : [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> n , k = f ( ) <NEWLINE> a = f ( ) <NEWLINE> a = [ i * 100 for i in a ] <NEWLINE> <COMMENT> <NL> def ok ( x ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> c += 0 - - i // x <NEWLINE> <DEDENT> return c <= n + k <NEWLINE> <DEDENT> l , r = 0 , 10 ** 11 + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = l + r >> 1 <NEWLINE> if ok ( m ) : r = m <NEWLINE> else : l = m <NEWLINE> <DEDENT> t = 0 - - r // 100 <NEWLINE> print ( t - ok ( t - 1 ) if t > 1 else t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> product = 1 <NEWLINE> <NL> for num in nums : <NEWLINE> <INDENT> product *= num <NEWLINE> <NL> if product > 1e18 : <NEWLINE> <INDENT> product = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in nums : <NEWLINE> <INDENT> product = 0 <NEWLINE> <NL> <DEDENT> print ( product ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if not w : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> xlst = [ 0 , w - 1 ] <NEWLINE> ylst = [ 0 , h - 1 ] <NEWLINE> plst = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> plst . append ( [ x1 , y1 , x2 - 1 , y2 - 1 ] ) <NEWLINE> xlst . append ( x1 ) <NEWLINE> <COMMENT> <NL> xlst . append ( x2 ) <NEWLINE> xlst . append ( x2 - 1 ) <NEWLINE> ylst . append ( y1 ) <NEWLINE> <COMMENT> <NL> ylst . append ( y2 ) <NEWLINE> ylst . append ( y2 - 1 ) <NEWLINE> <NL> <DEDENT> xlst = list ( set ( xlst ) ) <NEWLINE> ylst = list ( set ( ylst ) ) <NEWLINE> sorted_xlst = sorted ( xlst ) <NEWLINE> sorted_ylst = sorted ( ylst ) <NEWLINE> <NL> xdic = { } <NEWLINE> ydic = { } <NEWLINE> <NL> for i , v in enumerate ( sorted_xlst ) : <NEWLINE> <INDENT> xdic [ v ] = i <NEWLINE> <DEDENT> for i , v in enumerate ( sorted_ylst ) : <NEWLINE> <INDENT> ydic [ v ] = i <NEWLINE> <NL> <DEDENT> neww = xdic [ sorted_xlst [ - 1 ] ] <NEWLINE> newh = ydic [ sorted_ylst [ - 1 ] ] <NEWLINE> <COMMENT> <NL> <NL> painted = [ [ 0 ] * ( newh ) for _ in range ( neww ) ] <NEWLINE> <NL> def paint_area ( x , y ) : <NEWLINE> <INDENT> painted [ x ] [ y ] = 1 <NEWLINE> for tx , ty in [ ( x - 1 , y ) , ( x + 1 , y ) , ( x , y - 1 ) , ( x , y + 1 ) ] : <NEWLINE> <INDENT> if 0 <= tx <= neww - 1 and 0 <= ty <= newh - 1 and not painted [ tx ] [ ty ] : <NEWLINE> <INDENT> paint_area ( tx , ty ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for p in plst : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = p <NEWLINE> x1 , y1 , x2 , y2 = xdic [ x1 ] , ydic [ y1 ] , xdic [ x2 ] , ydic [ y2 ] <NEWLINE> for x in range ( x1 , x2 + 1 ) : <NEWLINE> <INDENT> for y in range ( y1 , y2 + 1 ) : <NEWLINE> <INDENT> painted [ x ] [ y ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for x in range ( neww ) : <NEWLINE> <INDENT> for y in range ( newh ) : <NEWLINE> <INDENT> if not painted [ x ] [ y ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> painted [ x ] [ y ] = 1 <NEWLINE> que = [ ( x , y ) ] <NEWLINE> while que : <NEWLINE> <INDENT> px , py = que . pop ( ) <NEWLINE> for tx , ty in [ ( px - 1 , py ) , ( px + 1 , py ) , ( px , py - 1 ) , ( px , py + 1 ) ] : <NEWLINE> <INDENT> if 0 <= tx <= neww - 1 and 0 <= ty <= newh - 1 and not painted [ tx ] [ ty ] : <NEWLINE> <INDENT> painted [ tx ] [ ty ] = 1 <NEWLINE> que . append ( ( tx , ty ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = int ( s , 2 ) <NEWLINE> pcx = s . count ( <STRING> ) <NEWLINE> pc1 = x % ( pcx - 1 ) if pcx > 1 else 0 <NEWLINE> pc2 = x % ( pcx + 1 ) <NEWLINE> <NL> def f ( j ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while j : <NEWLINE> <INDENT> j %= bin ( j ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> for i , y in enumerate ( s ) : <NEWLINE> <INDENT> k = n - 1 - i <NEWLINE> if y == <STRING> : <NEWLINE> <INDENT> print ( f ( ( pc2 + pow ( 2 , k , pcx + 1 ) ) % ( pcx + 1 ) ) + 1 ) <NEWLINE> <DEDENT> elif pcx > 1 : <NEWLINE> <INDENT> print ( f ( ( pc1 - pow ( 2 , k , pcx - 1 ) ) % ( pcx - 1 ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> ans = sum ( A ) <NEWLINE> d = collections . defaultdict ( int ) <NEWLINE> <NL> for key in A : <NEWLINE> <INDENT> d [ key ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = BC [ i ] [ 0 ] , BC [ i ] [ 1 ] <NEWLINE> ans += d [ b ] * ( c - b ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( i - 1 for i in l1 ) <NEWLINE> bit = list ( 0 for i in range ( n ) ) <NEWLINE> bit [ 0 ] = 1 <NEWLINE> mi = [ 0 ] <NEWLINE> m = l [ 0 ] <NEWLINE> er = 0 <NEWLINE> while er == 0 : <NEWLINE> <INDENT> if bit [ m ] == 1 : <NEWLINE> <INDENT> a = mi . index ( m ) <NEWLINE> r = mi [ a : ] <NEWLINE> er = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bit [ m ] = 1 <NEWLINE> mi . append ( m ) <NEWLINE> m = l [ m ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> be = mi [ : a ] + r <NEWLINE> <COMMENT> <NL> if k < len ( be ) : <NEWLINE> <INDENT> print ( be [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = k - len ( be ) + 1 <NEWLINE> u = ( w % len ( r ) ) - 1 <NEWLINE> print ( r [ u ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> popcount_x = x . count ( <STRING> ) <NEWLINE> popcount_x1 = popcount_x + 1 <NEWLINE> popcount_x2 = popcount_x - 1 <NEWLINE> <NL> if popcount_x2 == 0 : popcount_x2 = - 1 <NEWLINE> <NL> div1 = [ 0 ] * n <NEWLINE> div2 = [ 0 ] * n <NEWLINE> cur1 = 1 <NEWLINE> cur2 = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cur1 %= popcount_x1 <NEWLINE> cur2 %= popcount_x2 <NEWLINE> div1 [ i ] = cur1 <NEWLINE> div2 [ i ] = cur2 <NEWLINE> cur1 *= 2 <NEWLINE> cur2 *= 2 <NEWLINE> <NL> <NL> <DEDENT> fn = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> popcount = bin ( i ) [ 2 : ] . count ( <STRING> ) <NEWLINE> fn [ i ] = fn [ ( i ) % popcount ] + 1 <NEWLINE> <NL> <NL> <DEDENT> x_div1 = sum ( int ( x [ i ] ) * div1 [ - i - 1 ] for i in range ( n ) ) % popcount_x1 <NEWLINE> x_div2 = sum ( int ( x [ i ] ) * div2 [ - i - 1 ] for i in range ( n ) ) % popcount_x2 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> xi_div = ( x_div1 + div1 [ - i - 1 ] ) % popcount_x1 <NEWLINE> print ( fn [ xi_div ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if popcount_x2 == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xi_div = ( x_div2 - div2 [ - i - 1 ] ) % popcount_x2 <NEWLINE> print ( fn [ xi_div ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> a . sort ( ) <NEWLINE> num = a [ - 1 ] <NEWLINE> dp = [ True ] * num <NEWLINE> seen = [ 0 ] * num <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num2 = a [ i ] <NEWLINE> if dp [ num2 - 1 ] == True : <NEWLINE> <INDENT> if seen [ num2 - 1 ] == 1 : <NEWLINE> <INDENT> dp [ num2 - 1 ] = False <NEWLINE> <DEDENT> for j in range ( 2 , num // num2 + 1 ) : <NEWLINE> <INDENT> dp [ j * num2 - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> seen [ a [ i ] - 1 ] = 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] - 1 ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = min ( b - 1 , n ) <NEWLINE> print ( ( a * c ) // b - a * ( c // b ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( p , t , A , result ) : <NEWLINE> <INDENT> if A [ p ] == t : <NEWLINE> <INDENT> result [ ( p , t ) ] = True <NEWLINE> return True <NEWLINE> <DEDENT> if p == len ( A ) - 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if ( p , t ) in result : <NEWLINE> <COMMENT> <NL> <INDENT> return result [ ( p , t ) ] <NEWLINE> <DEDENT> if solve ( p + 1 , t - A [ p ] , A , result ) : <NEWLINE> <INDENT> result [ ( p , t ) ] = True <NEWLINE> return True <NEWLINE> <DEDENT> if solve ( p + 1 , t , A , result ) : <NEWLINE> <INDENT> result [ ( p , t ) ] = True <NEWLINE> return True <NEWLINE> <DEDENT> result [ ( p , t ) ] = False <NEWLINE> return False <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> num_q = int ( sys . stdin . readline ( ) ) <NEWLINE> query = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> result = dict ( ) <NEWLINE> <NL> for m in query : <NEWLINE> <INDENT> if solve ( 0 , m , A , result ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> import sys <NEWLINE> dis = abs ( a - b ) <NEWLINE> tume = v - w <NEWLINE> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if dis % tume == 0 and dis // tume <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif dis <= ( t - 1 ) * tume : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> while True : <NEWLINE> <INDENT> length , width = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( length , width ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( length ) : <NEWLINE> <INDENT> print ( <STRING> * width ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> ( N , M ) , * t = [ map ( int , s . split ( ) ) for s in open ( 0 ) ] <NEWLINE> v = [ [ ] for _ in [ None ] * 10 ** 5 ] <NEWLINE> for a , b in t : <NEWLINE> <INDENT> v [ a - 1 ] += b , <NEWLINE> <DEDENT> z = 0 <NEWLINE> q = [ ] <NEWLINE> for i in v [ : M ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> heappush ( q , - j ) <NEWLINE> <DEDENT> if q : <NEWLINE> <INDENT> z += - heappop ( q ) <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> numbers = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> numbers = sorted ( numbers ) <NEWLINE> counter = 0 <NEWLINE> <NL> for a in range ( N ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N ) : <NEWLINE> <INDENT> c = bisect . bisect_left ( numbers , numbers [ a ] + numbers [ b ] ) <NEWLINE> if c > b : <NEWLINE> <INDENT> counter += c - b - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
import numpy as np <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = A [ 0 ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A [ 1 : ] : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX = 1000000000000000000 <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ( ans > MAX ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans > MAX ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nxt_btn = { i : int ( input ( ) ) for i in range ( 1 , n + 1 ) } <NEWLINE> <NL> num = - 1 <NEWLINE> crr_btn = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if nxt_btn [ crr_btn ] == 2 : <NEWLINE> <INDENT> num = i <NEWLINE> break <NEWLINE> <DEDENT> crr_btn = nxt_btn [ crr_btn ] <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
import math <NEWLINE> <NL> t = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> aux = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( aux , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( y - 1 ) <NEWLINE> edge [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <DEDENT> def dfs ( c , p ) : <NEWLINE> <INDENT> for i in edge [ c ] : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] += ans [ c ] <NEWLINE> dfs ( i , c ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> count = int ( n / ( a + b ) ) <NEWLINE> ans += count * a <NEWLINE> amari = n - count * ( a + b ) <NEWLINE> if amari <= a : <NEWLINE> <INDENT> ans += amari <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans_list = [ 0 ] * N <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> s = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if s <= N : <NEWLINE> <INDENT> ans_list [ s - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <NL> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k and k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a + b < k : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> num = a [ 0 ] <NEWLINE> tmp = a [ 1 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if abs ( tmp - num / 2 ) >= abs ( a [ j ] - num / 2 ) : <NEWLINE> <INDENT> tmp = a [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = [ num , tmp ] <NEWLINE> print ( * ans ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> n = l [ 2 ] <NEWLINE> <NL> def floor ( a , b , x ) : <NEWLINE> <INDENT> p = ( a * x ) // b - a * ( x // b ) <NEWLINE> return p <NEWLINE> <NL> <DEDENT> max = 0 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> max = 0 <NEWLINE> <DEDENT> elif n <= b - 1 : <NEWLINE> <INDENT> max = floor ( a , b , n ) <NEWLINE> <DEDENT> elif n > b - 1 : <NEWLINE> <INDENT> for i in range ( b - 1 , n + 1 , b ) : <NEWLINE> <INDENT> c = floor ( a , b , i ) <NEWLINE> if c >= max : <NEWLINE> <INDENT> max = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> ) if n % 9 == 0 else print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> preList = list ( input ( ) . split ( ) ) <NEWLINE> inList = list ( input ( ) . split ( ) ) <NEWLINE> <NL> def recon ( l , r ) : <NEWLINE> <INDENT> if l >= r : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> global pos <NEWLINE> c = preList [ pos ] <NEWLINE> index = inList . index ( c ) <NEWLINE> pos += 1 <NEWLINE> recon ( l , index ) <NEWLINE> recon ( index + 1 , r ) <NEWLINE> <NL> global answer <NEWLINE> answer . append ( c ) <NEWLINE> <NL> <DEDENT> answer = [ ] <NEWLINE> pos = 0 <NEWLINE> recon ( 0 , N ) <NEWLINE> <NL> answer = <STRING> . join ( answer ) <NEWLINE> print ( answer ) <NEWLINE> <NL>
import queue <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = queue . Queue ( ) <NEWLINE> que . put ( 1 ) <NEWLINE> result = [ - 1 ] * ( N + 1 ) <NEWLINE> result [ 1 ] = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if que . empty ( ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> start = que . get ( ) <NEWLINE> for i in tree [ start ] : <NEWLINE> <INDENT> if result [ i ] == - 1 : <NEWLINE> <INDENT> result [ i ] = start <NEWLINE> que . put ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in result [ 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in result [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = map ( int , input ( ) . split ( ) ) <NEWLINE> q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = [ i for i in range ( N ) ] <NEWLINE> n = N <NEWLINE> i = 0 <NEWLINE> for aa in a : <NEWLINE> <INDENT> if aa % 2 == 1 : <NEWLINE> <INDENT> i = ( i - aa ) % n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = ( i + aa ) % n <NEWLINE> <DEDENT> del t [ i ] <NEWLINE> n -= 1 <NEWLINE> <NL> <DEDENT> for i in q : <NEWLINE> <INDENT> if i in t : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def gccd ( a , b , c ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> while c : <NEWLINE> <INDENT> a , c = c , a % c <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = n * ( n + 1 ) // 2 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , j ) * 6 <NEWLINE> <DEDENT> <DEDENT> if n > 2 : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gccd ( i , j , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> if len ( str ( x + y ) ) > 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + y ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> def f ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n = n % bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> src = input ( ) <NEWLINE> base = int ( src , 2 ) <NEWLINE> base_cnt = src . count ( <STRING> ) <NEWLINE> <NL> basep = base % ( base_cnt + 1 ) <NEWLINE> basem = base % ( base_cnt - 1 ) if base_cnt > 1 else 0 <NEWLINE> <NL> for i , s in enumerate ( src ) : <NEWLINE> <INDENT> i = n - 1 - i <NEWLINE> num = None <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> mod = base_cnt + 1 <NEWLINE> num = ( basep + pow ( 2 , i , mod ) ) % mod <NEWLINE> <DEDENT> elif base_cnt > 1 : <NEWLINE> <INDENT> mod = base_cnt - 1 <NEWLINE> num = ( basem - pow ( 2 , i , mod ) ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> print ( 1 + f ( num ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> cards = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> integers = [ x - a for x in cards ] <NEWLINE> cards . append ( a ) <NEWLINE> f = max ( cards ) * n <NEWLINE> <NL> <NL> dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 * f + 1 ) ] <NEWLINE> <NL> for y in range ( n + 1 ) : <NEWLINE> <INDENT> for x in range ( 2 * f + 1 ) : <NEWLINE> <INDENT> if y == 0 and x == f : <NEWLINE> <INDENT> dp [ x ] [ y ] = 1 <NEWLINE> <DEDENT> elif y > 0 and ( x - integers [ y - 1 ] < 0 or x - integers [ y - 1 ] > 2 * f ) : <NEWLINE> <INDENT> dp [ x ] [ y ] = dp [ x ] [ y - 1 ] <NEWLINE> <DEDENT> elif y > 0 and x - integers [ y - 1 ] >= 0 and x - integers [ y - 1 ] <= 2 * f : <NEWLINE> <INDENT> dp [ x ] [ y ] = dp [ x - integers [ y - 1 ] ] [ y - 1 ] + dp [ x ] [ y - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x ] [ y ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ f ] [ n ] - 1 ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> message = str ( input ( ) ) <NEWLINE> <NL> for c in message : <NEWLINE> <INDENT> order = ord ( c ) <NEWLINE> if order >= 65 and order <= 90 : <NEWLINE> <INDENT> sys . stdout . write ( chr ( order + 32 ) ) <NEWLINE> <DEDENT> elif order >= 97 and order <= 122 : <NEWLINE> <INDENT> sys . stdout . write ( chr ( order - 32 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = [ ] <NEWLINE> a = [ ] <NEWLINE> <NL> INF = 1001001001 <NEWLINE> ans = INF <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( tmp [ 0 ] ) <NEWLINE> a . append ( tmp [ 1 : ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 << n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> skill = [ 0 for _ in range ( m ) ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> cost += c [ j ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> skill [ k ] += a [ j ] [ k ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> flag = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if skill [ j ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> lst = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 0 , len ( lst ) ) : <NEWLINE> <INDENT> m = i <NEWLINE> for j in range ( i , len ( lst ) ) : <NEWLINE> <INDENT> if lst [ m ] > lst [ j ] : <NEWLINE> <INDENT> m = j <NEWLINE> <DEDENT> <DEDENT> if m != i : <NEWLINE> <INDENT> lst [ i ] , lst [ m ] = lst [ m ] , lst [ i ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , lst ) ) <NEWLINE> print ( cnt ) <NEWLINE>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> X = 1 <NEWLINE> L = [ 1 ] <NEWLINE> if A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N >= K : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> X = A [ X - 1 ] <NEWLINE> <DEDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> X = A [ X - 1 ] <NEWLINE> L += [ X ] <NEWLINE> <COMMENT> <NL> <DEDENT> C = np . zeros ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ L [ i ] - 1 ] == 0 : <NEWLINE> <INDENT> C [ L [ i ] - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> S = L . index ( L [ i + 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> K = ( K - i - 1 ) % ( i + 1 - S ) <NEWLINE> <COMMENT> <NL> print ( L [ S + K ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> dict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> dict [ b ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b in dict : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> cost = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 0 <NEWLINE> ans = [ None ] * n <NEWLINE> <NL> <NL> def dfs ( v , parent ) : <NEWLINE> <INDENT> ans [ v ] = cost . pop ( ) <NEWLINE> if parent != - 1 : <NEWLINE> <INDENT> global m <NEWLINE> m += min ( ans [ v ] , ans [ parent ] ) <NEWLINE> <DEDENT> for v2 in edges [ v ] : <NEWLINE> <INDENT> if v2 == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( v2 , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( m ) <NEWLINE> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B > A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> B = [ 0 ] * ( A [ - 1 ] + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if B [ a ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for aa in range ( a , A [ - 1 ] + 1 , a ) : <NEWLINE> <INDENT> B [ aa ] = 1 <NEWLINE> <NL> <DEDENT> if i != len ( A ) - 1 and A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def dfs ( tree , p , cnt , visited ) : <NEWLINE> <INDENT> visited [ p ] = True <NEWLINE> cnt_here = cnt [ p ] <NEWLINE> for c in tree . get ( p ) : <NEWLINE> <INDENT> if visited [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ c ] += cnt_here <NEWLINE> dfs ( tree , c , cnt , visited ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = defaultdict ( list ) <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <DEDENT> tree = dict ( tree ) <NEWLINE> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p ] += x <NEWLINE> <DEDENT> visited = [ False ] * ( n + 1 ) <NEWLINE> dfs ( tree , 1 , cnt , visited ) <NEWLINE> print ( * cnt [ 1 : ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
point = int ( input ( ) ) <NEWLINE> <NL> if 400 <= point <= 599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 600 <= point <= 799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 800 <= point <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1000 <= point <= 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1200 <= point <= 1399 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1400 <= point <= 1599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1600 <= point <= 1799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1800 <= point <= 1999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def input_number ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def input_1line_list ( number_of_input ) : <NEWLINE> <INDENT> return [ input ( ) for i in range ( number_of_input ) ] <NEWLINE> <NL> <DEDENT> def input_1line ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def f ( a , b , x ) : <NEWLINE> <INDENT> return ( a * ( x % b ) ) // b <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , n = input_1line ( ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = f ( a , b , x ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> dp = [ [ None ] * ( max ( M ) + 1 ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if i >= n : <NEWLINE> <INDENT> return m == 0 <NEWLINE> <NL> <DEDENT> elif m < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> elif dp [ i ] [ m ] is not None : <NEWLINE> <INDENT> return dp [ i ] [ m ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> elif solve ( i + 1 , m ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> elif solve ( i + 1 , m - A [ i ] ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ m ] = False <NEWLINE> <DEDENT> return dp [ i ] [ m ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for num in M : <NEWLINE> <INDENT> print ( <STRING> if solve ( 0 , num ) else <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> all_xor = a [ 0 ] <NEWLINE> for j in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> all_xor = all_xor ^ a [ j ] <NEWLINE> <DEDENT> answer = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> answer [ i ] = all_xor ^ a [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , answer ) ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dp = defaultdict ( lambda : - pow ( 10 , 18 ) ) <NEWLINE> dp [ ( 1 , 1 ) ] = a [ 0 ] <NEWLINE> for i in range ( 2 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i // 2 - 1 , ( i + 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> dp [ ( i , j ) ] = max ( dp [ ( i - 1 , 1 ) ] , a [ i - 1 ] ) <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> dp [ ( i , j ) ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ ( i , j ) ] = max ( dp [ ( i - 2 , j - 1 ) ] + a [ i - 1 ] , dp [ ( i - 1 , j ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ ( n , n // 2 ) ] ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b > n : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <NL> <DEDENT> print ( ( a * x ) // b ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> sum = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( result , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> <COMMENT> <NL> C = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> D = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] > 0 : <NEWLINE> <INDENT> t = 2 <NEWLINE> while a * t <= maxA : <NEWLINE> <INDENT> D [ a * t ] = 1 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] == 1 and D [ a ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> t = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if t <= n : <NEWLINE> <INDENT> ans [ t ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> if H [ A ] > H [ B ] : <NEWLINE> <INDENT> flg [ B ] = 0 <NEWLINE> <DEDENT> elif H [ A ] < H [ B ] : <NEWLINE> <INDENT> flg [ A ] = 0 <NEWLINE> <DEDENT> elif H [ A ] == H [ B ] : <NEWLINE> <INDENT> flg [ A ] = 0 <NEWLINE> flg [ B ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( flg ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> D = set ( ) <NEWLINE> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] in S : <NEWLINE> <INDENT> D . add ( A [ i ] ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . add ( A [ i ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> M = max ( S ) <COMMENT> <NEWLINE> X = [ 1 for i in range ( M + 1 ) ] <COMMENT> <NEWLINE> for a in S : <NEWLINE> <INDENT> if a in D : <COMMENT> <NEWLINE> <INDENT> X [ a ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 * a , M + 1 , a ) : <COMMENT> <NEWLINE> <INDENT> X [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ A [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = [ 0 ] * ( r + 1 ) <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> d [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d [ i ] . append ( 0 ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> d [ i ] [ c ] += d [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> d [ r ] = [ 0 ] * ( c + 1 ) <NEWLINE> for i in range ( c + 1 ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> d [ r ] [ i ] += d [ j ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> row = <STRING> <NEWLINE> for j in range ( c + 1 ) : <NEWLINE> <INDENT> row += str ( d [ i ] [ j ] ) <NEWLINE> if j <= c - 1 : <NEWLINE> <INDENT> row += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( row ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> m = a [ - 1 ] <NEWLINE> s = [ 0 ] * ( m + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if s [ i ] <= 1 : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> s [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in a : <NEWLINE> <INDENT> if s [ k ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import array <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = array . array ( <STRING> , list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> MAX = 10 ** 5 + 1 <NEWLINE> X = array . array ( <STRING> , [ 0 ] ) * MAX <NEWLINE> Y = array . array ( <STRING> , range ( MAX ) ) <NEWLINE> <NL> for i in range ( len ( A ) ) : X [ A [ i ] ] += 1 <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> cur = sum ( array . array ( <STRING> , ( X [ i ] * Y [ i ] for i in range ( len ( X ) ) ) ) ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> [ b , c ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cur = cur - X [ b ] * b + X [ b ] * c <NEWLINE> print ( cur ) <NEWLINE> X [ c ] += X [ b ] <NEWLINE> X [ b ] = 0 <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alphabet = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> while n - 26 ** i >= 0 : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for _ in range ( i ) : <NEWLINE> <INDENT> q , r = divmod ( n , 26 ) <NEWLINE> n = q <NEWLINE> ans += alphabet [ r ] <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <NL> <NL>
def cs ( n , p , c ) : <NEWLINE> <INDENT> global count , m <NEWLINE> if n % c [ 0 ] == 0 : <NEWLINE> <INDENT> count = min ( count , p + n // c [ 0 ] ) <NEWLINE> return count <NEWLINE> <DEDENT> elif p + n // c [ 0 ] >= count : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> elif c [ 0 ] < n : <NEWLINE> <INDENT> return min ( cs ( n - c [ 0 ] , p + 1 , c ) , cs ( n , p , c [ 1 : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return cs ( n , p , c [ 1 : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( reverse = True ) <NEWLINE> count = n <NEWLINE> print ( cs ( n , 0 , c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( n - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
def delete_head_zeros ( n ) : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> l = len ( n ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> l = n . find ( <STRING> ) <NEWLINE> <DEDENT> head_zeros = 0 <NEWLINE> for i in range ( l - 1 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> head_zeros += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return n [ head_zeros : ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_compare ( a , b ) : <NEWLINE> <INDENT> a = delete_head_zeros ( a ) <NEWLINE> b = delete_head_zeros ( b ) <NEWLINE> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif len ( a ) < len ( b ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def bigint_plus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> d = max ( [ len ( a ) , len ( b ) ] ) <NEWLINE> a = <STRING> * ( d - len ( a ) ) + a <NEWLINE> b = <STRING> * ( d - len ( b ) ) + b <NEWLINE> <NL> ans = <STRING> <NEWLINE> carry = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s = int ( a [ - i - 1 ] ) + int ( b [ - i - 1 ] ) + carry <NEWLINE> carry = s // 10 <NEWLINE> ans = str ( s % 10 ) + ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> ans = str ( carry ) + ans <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_minus ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> M = [ ] <NEWLINE> m = [ ] <NEWLINE> sign = <STRING> <NEWLINE> <NL> if len ( a ) > len ( b ) or ( len ( a ) == len ( b ) and a >= b ) : <NEWLINE> <INDENT> [ M , m ] = [ a , b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> [ M , m ] = [ b , a ] <NEWLINE> sign = <STRING> <NEWLINE> <DEDENT> m = <STRING> * ( len ( M ) - len ( m ) ) + m <NEWLINE> <NL> ans = <STRING> <NEWLINE> borrow = 0 <NEWLINE> for i in range ( len ( M ) ) : <NEWLINE> <INDENT> s = int ( M [ - i - 1 ] ) - int ( m [ - i - 1 ] ) - borrow <NEWLINE> if s < 0 : <NEWLINE> <INDENT> borrow = 1 <NEWLINE> s += 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> borrow = 0 <NEWLINE> <DEDENT> ans = str ( s ) + ans <NEWLINE> <NL> <DEDENT> return sign + delete_head_zeros ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_multiply ( a , b ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <NL> md = [ ] <NEWLINE> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> carry = 0 <NEWLINE> mj = <STRING> <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> m = int ( a [ - i - 1 ] ) * int ( b [ - j - 1 ] ) + carry <NEWLINE> carry = m // 10 <NEWLINE> mj = str ( m % 10 ) + mj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if carry : <NEWLINE> <INDENT> mj = str ( carry ) + mj <NEWLINE> <DEDENT> <DEDENT> md . append ( mj ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( len ( md ) ) : <NEWLINE> <INDENT> ans = bigint_plus ( md [ k ] + <STRING> * k , ans ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def bigint_divide ( a , b , d = 0 ) : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> d = int ( d ) <NEWLINE> if d < 0 : <NEWLINE> <INDENT> d = 0 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> r = <STRING> <NEWLINE> for i in range ( len ( a ) + d ) : <NEWLINE> <INDENT> q = 0 <NEWLINE> if i < len ( a ) : <NEWLINE> <INDENT> r += a [ i ] <NEWLINE> <DEDENT> elif i == len ( a ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> r += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += <STRING> <NEWLINE> <NL> <DEDENT> if bigint_compare ( r , b ) == - 1 : <NEWLINE> <INDENT> ans += str ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while bigint_compare ( r , b ) >= 0 : <NEWLINE> <INDENT> r = bigint_minus ( r , b ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> ans += str ( q ) <NEWLINE> <NL> <DEDENT> <DEDENT> return delete_head_zeros ( ans ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = input ( ) . split ( <STRING> ) <NEWLINE> A = [ int ( a ) - 1 for a in input ( ) . split ( <STRING> ) ] <NEWLINE> visited = [ 0 ] * int ( N ) <NEWLINE> towns = [ ] <NEWLINE> now = 0 <NEWLINE> while visited [ now ] == 0 : <NEWLINE> <INDENT> towns . append ( now ) <NEWLINE> visited [ now ] = 1 <NEWLINE> now = A [ now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop_begin_idx = towns . index ( now ) <NEWLINE> loop_end_idx = len ( towns ) - 1 <NEWLINE> loop_n = loop_end_idx - loop_begin_idx + 1 <NEWLINE> <DEDENT> if int ( K ) < len ( towns ) : <NEWLINE> <INDENT> print ( towns [ int ( K ) ] + 1 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> K_from_loop = bigint_minus ( K , loop_begin_idx ) <NEWLINE> q = bigint_divide ( K_from_loop , loop_n ) <NEWLINE> r = bigint_minus ( K_from_loop , bigint_multiply ( loop_n , q ) ) <NEWLINE> print ( towns [ loop_begin_idx + int ( r ) ] + 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if B > N : <NEWLINE> <INDENT> print ( int ( A * N / B ) - A * int ( N / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> print ( int ( A * x / B ) - A * int ( x / B ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> S += gcd ( i , j , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> S += gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S += i <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
from collections import deque <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> p = [ ] <NEWLINE> m = [ ] <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> m . append ( - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <DEDENT> <DEDENT> cp = len ( p ) <NEWLINE> cm = len ( m ) <NEWLINE> m . append ( 0 ) <NEWLINE> m . append ( 0 ) <NEWLINE> p . append ( 0 ) <NEWLINE> p . append ( 0 ) <NEWLINE> p . sort ( ) <NEWLINE> m . sort ( ) <NEWLINE> p = deque ( p ) <NEWLINE> m = deque ( m ) <NEWLINE> if cm == n and k % 2 == 1 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> if f == 0 : <NEWLINE> <INDENT> while k : <NEWLINE> <COMMENT> <NL> <INDENT> if k % 2 == 1 and cp : <NEWLINE> <INDENT> p1 = deque . pop ( p ) <NEWLINE> ans *= p1 <NEWLINE> k -= 1 <NEWLINE> cp -= 1 <NEWLINE> <DEDENT> elif f == 0 and m [ - 1 ] * m [ - 2 ] > p [ - 1 ] * p [ - 2 ] and cm > 1 and k > 1 : <NEWLINE> <INDENT> m1 = deque . pop ( m ) <NEWLINE> m2 = deque . pop ( m ) <NEWLINE> ans *= m1 * m2 <NEWLINE> cm -= 2 <NEWLINE> k -= 2 <NEWLINE> <DEDENT> elif cp > 0 : <NEWLINE> <INDENT> p1 = deque . pop ( p ) <NEWLINE> ans *= p1 <NEWLINE> k -= 1 <NEWLINE> cp -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> ans *= - m [ 2 ] <NEWLINE> m1 = deque . popleft ( m ) <NEWLINE> m2 = deque . popleft ( m ) <NEWLINE> m3 = deque . popleft ( m ) <NEWLINE> deque . appendleft ( m , m1 ) <NEWLINE> deque . appendleft ( m , m2 ) <NEWLINE> cm -= 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m1 = deque . popleft ( m ) <NEWLINE> m2 = deque . popleft ( m ) <NEWLINE> m1 = deque . popleft ( p ) <NEWLINE> m2 = deque . popleft ( p ) <NEWLINE> deque . append ( m , 10 ** 10 ) <NEWLINE> deque . append ( p , 10 ** 10 ) <NEWLINE> while k : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <COMMENT> <NL> if p [ 0 ] < m [ 0 ] : <NEWLINE> <INDENT> ans *= deque . popleft ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= - deque . popleft ( m ) <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> <NL> ruisekiwa = [ 0 ] * N <NEWLINE> wa = sum ( A ) % M <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wa -= A [ i ] <NEWLINE> result = ( result + ( A [ i ] * wa ) % M ) % M <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
def partition ( p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = partition ( 0 , n - 1 ) <NEWLINE> A [ q ] = <STRING> % A [ q ] <NEWLINE> print ( * A ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> <NL> Nstock = np . zeros ( N ) <NEWLINE> <NL> cpos = 1 <NEWLINE> Nstock [ cpos - 1 ] = 1 <NEWLINE> stock = [ cpos ] <NEWLINE> loop = [ ] <NEWLINE> <NL> idx = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> cpos = A [ cpos - 1 ] <NEWLINE> if Nstock [ cpos - 1 ] == 1 : <NEWLINE> <INDENT> idx = stock . index ( cpos ) <NEWLINE> loop = stock [ idx : ] <NEWLINE> break <NEWLINE> <DEDENT> Nstock [ cpos - 1 ] = 1 <NEWLINE> stock . append ( cpos ) <NEWLINE> <NL> <DEDENT> if loop != [ ] : <NEWLINE> <INDENT> v = ( K - idx ) <NEWLINE> a = v % len ( loop ) <NEWLINE> print ( loop [ a ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( stock [ K ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a_s = set ( a ) <NEWLINE> cnt = 0 <NEWLINE> order = 1 <NEWLINE> if not 1 in a_s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] != order : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if a [ i ] == order : <NEWLINE> <INDENT> order += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> result [ A [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <DEDENT> s = <STRING> . join ( result ) <NEWLINE> print ( s ) <NEWLINE>
MM = input ( ) . split ( ) <NEWLINE> A = int ( MM [ 0 ] ) <NEWLINE> B = int ( MM [ 1 ] ) <NEWLINE> total = 1 <NEWLINE> count = 0 <NEWLINE> while total < B : <NEWLINE> <INDENT> total += A - 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<NL> <NL> <NL> S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> <NL> T_size = len ( T ) <NEWLINE> <NL> def match_num ( x ) : <NEWLINE> <INDENT> return T_size - sum ( [ 1 for a , t in zip ( x , T ) if a == t ] ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> for i in range ( len ( S ) - T_size + 1 ) : <NEWLINE> <INDENT> b . append ( match_num ( S [ i : i + T_size ] ) ) <NEWLINE> <NL> <DEDENT> print ( min ( b ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . format ( y [ - 1 ] ) , end = <STRING> ) <NEWLINE> for i in range ( x - 2 , 0 - 1 , - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( y [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> remainer = 0 <NEWLINE> while True : <NEWLINE> <INDENT> res += ( 360 + remainer ) // a <NEWLINE> remainer = ( 360 + remainer ) % a <NEWLINE> if remainer == 0 : break <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( enumerate ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> b = Counter ( [ x [ 0 ] + x [ 1 ] + 1 for x in A ] ) <NEWLINE> c = Counter ( [ x [ 0 ] - x [ 1 ] + 1 for x in A ] ) <NEWLINE> count = 0 <NEWLINE> for x in b . items ( ) : <NEWLINE> <INDENT> count += x [ 1 ] * c [ x [ 0 ] ] <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = input ( ) <NEWLINE> num = len ( N ) <NEWLINE> mod_sum = [ 0 ] * 2019 <NEWLINE> mod_sum [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> a = 0 <NEWLINE> d = 1 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a = ( a + int ( N [ - i - 1 ] ) * d ) % 2019 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> mod_sum [ a ] += 1 <NEWLINE> <DEDENT> for i in mod_sum : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ i for i in range ( 102 ) ] <NEWLINE> <NL> for j in p : <NEWLINE> <INDENT> l . remove ( j ) <NEWLINE> <NL> <DEDENT> m = [ ] <NEWLINE> <NL> for k in l : <NEWLINE> <INDENT> m . append ( abs ( k - x ) ) <NEWLINE> <NL> <DEDENT> print ( l [ m . index ( min ( m ) ) ] ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> TaroScore = HanaScore = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> [ Taro , Hana ] = list ( input ( ) . lower ( ) . split ( ) ) <NEWLINE> <NL> lenT = len ( Taro ) <NEWLINE> lenH = len ( Hana ) <NEWLINE> lenMin = min ( lenT , lenH ) <NEWLINE> <NL> if Taro == Hana : <NEWLINE> <INDENT> TaroScore += 1 <NEWLINE> HanaScore += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( lenMin + 1 ) : <NEWLINE> <INDENT> if Taro == <STRING> : <NEWLINE> <INDENT> HanaScore += 3 <NEWLINE> break <NEWLINE> <DEDENT> elif Hana == <STRING> : <NEWLINE> <INDENT> TaroScore += 3 <NEWLINE> break <NEWLINE> <DEDENT> elif ord ( Taro [ 0 ] ) > ord ( Hana [ 0 ] ) : <NEWLINE> <INDENT> TaroScore += 3 <NEWLINE> break <NEWLINE> <DEDENT> elif ord ( Taro [ 0 ] ) < ord ( Hana [ 0 ] ) : <NEWLINE> <INDENT> HanaScore += 3 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Taro = Taro [ 1 : ] <NEWLINE> Hana = Hana [ 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( TaroScore , HanaScore ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
ans_list = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> def mcxl2digit ( s ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> dig = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if <STRING> <= s [ i ] <= <STRING> : <NEWLINE> <INDENT> dig = int ( s [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> key = 1000 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> key = 100 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> key = 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = 1 <NEWLINE> <DEDENT> ans += key * dig <NEWLINE> dig = 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def digit2mcxl ( i ) : <NEWLINE> <INDENT> return_list = [ ] <NEWLINE> m = i // 1000 <NEWLINE> if m != 0 and m != 1 : <NEWLINE> <INDENT> return_list . append ( str ( m ) ) <NEWLINE> <DEDENT> if m != 0 : <NEWLINE> <INDENT> return_list . append ( <STRING> ) <NEWLINE> <DEDENT> i = i % 1000 <NEWLINE> <NL> c = i // 100 <NEWLINE> if c != 0 and c != 1 : <NEWLINE> <INDENT> return_list . append ( str ( c ) ) <NEWLINE> <DEDENT> if c != 0 : <NEWLINE> <INDENT> return_list . append ( <STRING> ) <NEWLINE> <DEDENT> i = i % 100 <NEWLINE> <NL> x = i // 10 <NEWLINE> if x != 0 and x != 1 : <NEWLINE> <INDENT> return_list . append ( str ( x ) ) <NEWLINE> <DEDENT> if x != 0 : <NEWLINE> <INDENT> return_list . append ( <STRING> ) <NEWLINE> <DEDENT> i = i % 10 <NEWLINE> <NL> l = i <NEWLINE> if l != 0 and l != 1 : <NEWLINE> <INDENT> return_list . append ( str ( l ) ) <NEWLINE> <DEDENT> if l != 0 : <NEWLINE> <INDENT> return_list . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> return return_list <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> ans = ( mcxl2digit ( a ) + mcxl2digit ( b ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = digit2mcxl ( ans ) <NEWLINE> ans_list . append ( ans ) <NEWLINE> <DEDENT> for i in ans_list : <NEWLINE> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = [ [ ] for x in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> X [ A ] . append ( H [ B ] ) <NEWLINE> X [ B ] . append ( H [ A ] ) <NEWLINE> <DEDENT> rt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( X [ i ] ) == 0 : <NEWLINE> <INDENT> rt += 1 <NEWLINE> <DEDENT> elif H [ i ] > max ( X [ i ] ) : <NEWLINE> <INDENT> rt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( rt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> B . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> i , j = 0 , 0 <NEWLINE> while i <= N - 1 : <NEWLINE> <INDENT> for l in range ( B [ j ] [ 0 ] ) : <NEWLINE> <INDENT> if A [ i ] >= B [ j ] [ 1 ] : <NEWLINE> <INDENT> print ( sum ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A [ i ] = B [ j ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> if i == N : <NEWLINE> <INDENT> print ( sum ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> if j == M : <NEWLINE> <INDENT> print ( sum ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> num_1 = input ( ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> num_2 = int ( num_1 ) <NEWLINE> num = 10 ** 18 <NEWLINE> if 0 in lis : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for x in range ( num_2 ) : <NEWLINE> <INDENT> s = s * int ( lis [ x ] ) <NEWLINE> if s > num : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , m , r = map ( int , input ( ) . split ( ) ) <NEWLINE> r -= n * m <NEWLINE> if r < 0 : print ( 0 ) ; exit ( 0 ) ; <NEWLINE> from math import * <NEWLINE> print ( factorial ( n + r - 1 ) // factorial ( r ) // factorial ( n - 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> x = 800 * n <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> y = 0 <NEWLINE> if n >= 15 : <NEWLINE> <INDENT> y = 200 * ( n // 15 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = x - y <NEWLINE> print ( ans ) <NEWLINE>
_ = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = [ ] <NEWLINE> for i in range ( min ( X ) , max ( X ) + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> s += ( x - i ) * ( x - i ) <NEWLINE> <DEDENT> t . append ( s ) <NEWLINE> <NL> <DEDENT> print ( min ( t ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> S [ a ] = i + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if n == N + 1 or n == N : <NEWLINE> <INDENT> print ( S [ n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ n ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , n = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> n = int ( n ) <NEWLINE> lst = input ( ) . split ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> lst [ i ] = int ( lst [ i ] ) <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minv = min ( lst ) <NEWLINE> maxv = max ( lst ) <NEWLINE> dis = 100000 <NEWLINE> <NL> for i in range ( minv - 2 , maxv + 3 ) : <NEWLINE> <INDENT> if ( i not in lst and abs ( i - x ) < dis ) : <NEWLINE> <INDENT> dis = abs ( i - x ) <NEWLINE> clv = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( clv ) <NEWLINE> <NL> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> ret = defaultdict ( list ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ret [ self . find ( i ) ] . append ( i ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n + 1 ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> MA = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if MA <= uf . size ( i ) : <NEWLINE> <INDENT> MA = uf . size ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( MA ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for i in range ( 130 ) : <NEWLINE> <INDENT> for j in range ( - 130 , 130 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> A = i <NEWLINE> B = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( str ( A ) + str ( <STRING> ) + str ( B ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 and M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> allCards = [ ] <NEWLINE> for i in range ( N + M ) : <NEWLINE> <INDENT> allCards . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> Taro = allCards [ : N ] <NEWLINE> Hanako = allCards [ N : ] <NEWLINE> Tsum = sum ( Taro ) <NEWLINE> Hsum = sum ( Hanako ) <NEWLINE> diff = Tsum - Hsum <NEWLINE> tempsum = 1e8 <NEWLINE> Tchange = - 1 <NEWLINE> Hchange = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> tempdiff = ( Taro [ i ] - Hanako [ j ] ) * 2 <NEWLINE> if diff == tempdiff : <NEWLINE> <INDENT> if ( tempsum > Taro [ i ] + Hanako [ j ] ) : <NEWLINE> <INDENT> tempsum = Taro [ i ] + Hanako [ j ] <NEWLINE> Tchange = Taro [ i ] <NEWLINE> Hchange = Hanako [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if Tchange == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Tchange , Hchange ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> <NL> samu = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> samu += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( samu ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> A += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 0 <NEWLINE> k = 0 <NEWLINE> <NL> Dum = 0 <NEWLINE> Gum = 0 <NEWLINE> <NL> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> Dum += A [ i ] <NEWLINE> Gum += Dum * A [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( Gum % 1000000007 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asum = [ 0 ] <NEWLINE> Bsum = [ 0 ] <NEWLINE> atemp = 0 <NEWLINE> btemp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> atemp += A [ i ] <NEWLINE> Asum . append ( atemp ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> btemp += B [ i ] <NEWLINE> Bsum . append ( btemp ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if Asum [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while Asum [ i ] + Bsum [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> MAX = 1000001 <NEWLINE> N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> is_ans = [ True ] * MAX <NEWLINE> ans = 0 <NEWLINE> <NL> dup = set ( ) <NEWLINE> for a in arr : <NEWLINE> <INDENT> if a in dup and is_ans [ a ] : <NEWLINE> <INDENT> j = a <NEWLINE> while j < MAX : <NEWLINE> <INDENT> is_ans [ j ] = False <NEWLINE> j += a <NEWLINE> <NL> <DEDENT> <DEDENT> dup . add ( a ) <NEWLINE> <NL> <DEDENT> for a in arr : <NEWLINE> <INDENT> if is_ans [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> j = a <NEWLINE> while j < MAX : <NEWLINE> <INDENT> is_ans [ j ] = False <NEWLINE> j += a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis . sort ( reverse = True ) <NEWLINE> print ( sum ( lis [ b : ] ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> s = sys . stdin . read ( ) . lower ( ) <NEWLINE> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> print ( str ( chr ( i ) ) , str ( s . count ( chr ( i ) ) ) , sep = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . buffer . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> class FenwickTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . _a = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> while i <= self . _n : <NEWLINE> <INDENT> self . _a [ i - 1 ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , l , r ) : <NEWLINE> <INDENT> return self . _sum ( r ) - self . _sum ( l ) <NEWLINE> <NL> <DEDENT> def _sum ( self , r ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while r > 0 : <NEWLINE> <INDENT> s += self . _a [ r - 1 ] <NEWLINE> r -= r & - r <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , read ( ) . split ( ) ) <NEWLINE> fw = FenwickTree ( n ) <NEWLINE> for i , ai in enumerate ( map ( int , read ( ) . split ( ) ) ) : <NEWLINE> <INDENT> fw . add ( i , ai ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> query = [ int ( i ) for i in read ( ) . split ( ) ] <NEWLINE> if query [ 0 ] == 0 : <NEWLINE> <INDENT> fw . add ( query [ 1 ] , query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( fw . sum ( query [ 1 ] , query [ 2 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
flag = True <NEWLINE> s = [ input ( ) for i in range ( 2 ) ] <NEWLINE> if ( len ( s [ 0 ] ) > 10 or len ( s [ 0 ] ) < 1 ) or ( len ( s [ 0 ] ) + 1 != len ( s [ 1 ] ) ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( s [ 0 ] ) ) : <NEWLINE> <INDENT> if not s [ 0 ] [ j ] == s [ 1 ] [ j ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> memo = [ 0 ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if memo [ a ] < h [ b ] : <NEWLINE> <INDENT> memo [ a ] = h [ b ] <NEWLINE> <DEDENT> if memo [ b ] < h [ a ] : <NEWLINE> <INDENT> memo [ b ] = h [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if memo [ i ] < h [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = input_ints ( ) <NEWLINE> A = input_int_list_in_line ( ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def input_ints ( ) : <NEWLINE> <INDENT> line_list = input ( ) . split ( ) <NEWLINE> <NL> if len ( line_list ) == 1 : <NEWLINE> <INDENT> return int ( line_list [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return map ( int , line_list ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def input_int_list_in_line ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def input_int_tuple_list ( n : int ) : <NEWLINE> <INDENT> return [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> h = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> <NL> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( [ dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - K ) , i ) ] ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> maxA = 1000 <NEWLINE> pow5 = list ( ) <NEWLINE> for aa in range ( maxA ) : <NEWLINE> <INDENT> pow5 . append ( aa ** 5 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = False <NEWLINE> for ii in range ( maxA ) : <NEWLINE> <INDENT> if ( ans == False ) : <NEWLINE> <INDENT> X1 = X - pow5 [ ii ] <NEWLINE> X2 = X + pow5 [ ii ] <NEWLINE> if ( X1 in pow5 ) : <NEWLINE> <INDENT> b = - ii <NEWLINE> a = pow5 . index ( X1 ) <NEWLINE> ans = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans == False ) : <NEWLINE> <INDENT> if ( X2 in pow5 ) : <NEWLINE> <INDENT> b = ii <NEWLINE> a = pow5 . index ( X2 ) <NEWLINE> ans = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if ( ans ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> <DEDENT>
def counter ( rest , n , acc , to ) : <NEWLINE> <INDENT> if rest == 0 : return acc == to <NEWLINE> if n == 10 : return 0 <NEWLINE> return counter ( rest - 1 , n + 1 , acc + n , to ) + counter ( rest , n + 1 , acc , to ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( counter ( n , 0 , 0 , s ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> print ( <STRING> ) if a [ i ] > a [ i - k ] else print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def main ( N , K , A ) : <NEWLINE> <INDENT> i = 0 <COMMENT> <NEWLINE> lst_memo = [ ] <NEWLINE> set_memo = set ( [ ] ) <NEWLINE> while i not in set_memo : <NEWLINE> <INDENT> lst_memo . append ( i ) <NEWLINE> set_memo . add ( i ) <NEWLINE> i = A [ i ] - 1 <COMMENT> <NEWLINE> <DEDENT> key = lst_memo . index ( i ) <NEWLINE> if K < key : <NEWLINE> <INDENT> print ( lst_memo [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop = lst_memo [ key : ] <NEWLINE> print ( roop [ ( K - key ) % len ( roop ) ] + 1 ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( N , K , A ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> vec = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> now = a [ i + 1 ] - a [ i ] <NEWLINE> if vec * now < 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> vec = 0 <NEWLINE> <DEDENT> elif vec == 0 : <NEWLINE> <INDENT> vec = now <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> if x1 == x2 and x3 == x4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x1 == x2 or x3 == x4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( ( y2 - y1 ) / ( x2 - x1 ) - ( y4 - y3 ) / ( x4 - x3 ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> S = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H_t = input ( ) . split ( ) <NEWLINE> H = [ int ( s ) for s in H_t ] <NEWLINE> <COMMENT> <NL> <NL> ma = [ 0 ] * N <NEWLINE> <NL> good_count = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> for j in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ma [ a - 1 ] = max ( ma [ a - 1 ] , H [ b - 1 ] ) <COMMENT> <NEWLINE> ma [ b - 1 ] = max ( ma [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] > ma [ i ] : <NEWLINE> <INDENT> good_count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( good_count ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 for i in range ( c + 1 ) ] for j in range ( r + 1 ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> a [ i ] [ j ] = l [ j ] <NEWLINE> a [ i ] [ c ] += a [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( c + 1 ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> a [ r ] [ i ] += a [ j ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if j == c : <NEWLINE> <INDENT> print ( str ( a [ i ] [ j ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( a [ i ] [ j ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import networkx as nx <NEWLINE> from networkx . algorithms . bipartite import hopcroft_karp_matching <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def inside ( x , y ) : <NEWLINE> <INDENT> if 0 <= x < n and 0 <= y < m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> DI = [ 1 , 0 , - 1 , 0 ] <NEWLINE> DJ = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> a = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> g = nx . Graph ( ) <NEWLINE> g . add_nodes_from ( range ( n * m ) ) <NEWLINE> zero = True <NEWLINE> top = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> di , dj = i + DI [ k ] , j + DJ [ k ] <NEWLINE> if inside ( di , dj ) and a [ di ] [ dj ] == <STRING> : <NEWLINE> <INDENT> zero = False <NEWLINE> g . add_edge ( i * m + j , di * m + dj ) <NEWLINE> top . add ( i * m + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = hopcroft_karp_matching ( g , top_nodes = top ) <NEWLINE> print ( len ( h ) // 2 ) <NEWLINE> for fr , to in h . items ( ) : <NEWLINE> <INDENT> i0 , j0 = fr // m , fr % m <NEWLINE> i1 , j1 = to // m , to % m <NEWLINE> if a [ i0 ] [ j0 ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i1 == i0 + 1 : <NEWLINE> <INDENT> a [ i0 ] [ j0 ] = <STRING> <NEWLINE> a [ i1 ] [ j1 ] = <STRING> <NEWLINE> <DEDENT> elif i1 == i0 - 1 : <NEWLINE> <INDENT> a [ i0 ] [ j0 ] = <STRING> <NEWLINE> a [ i1 ] [ j1 ] = <STRING> <NEWLINE> <DEDENT> elif j1 == j0 + 1 : <NEWLINE> <INDENT> a [ i0 ] [ j0 ] = <STRING> <NEWLINE> a [ i1 ] [ j1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i0 ] [ j0 ] = <STRING> <NEWLINE> a [ i1 ] [ j1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * [ <STRING> . join ( x ) for x in a ] , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if b - 1 >= n : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : x = b - 1 <NEWLINE> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE>
r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> MAX_N = 3 * 10 ** 6 <NEWLINE> <NL> fact = [ 1 ] <NEWLINE> fact_inv = [ 0 ] * ( MAX_N + 4 ) <NEWLINE> for i in range ( MAX_N + 3 ) : <NEWLINE> <INDENT> fact . append ( fact [ - 1 ] * ( i + 1 ) % mod ) <NEWLINE> <NL> <DEDENT> fact_inv [ - 1 ] = pow ( fact [ - 1 ] , mod - 2 , mod ) <NEWLINE> for i in range ( MAX_N + 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> fact_inv [ i ] = fact_inv [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> def comb ( n , k , mod = mod ) : <NEWLINE> <INDENT> if n < k : return 0 <NEWLINE> return fact [ n ] * fact_inv [ k ] % mod * fact_inv [ n - k ] % mod <NEWLINE> <NL> <DEDENT> ans = comb ( c1 + r1 , r1 ) - comb ( c1 + r2 + 1 , r2 + 1 ) - comb ( c2 + r1 + 1 , r1 ) + comb ( c2 + r2 + 2 , r2 + 1 ) <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
from collections import Counter , defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . sort ( ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> D = defaultdict ( bool ) <NEWLINE> for key in C . keys ( ) : <NEWLINE> <INDENT> D [ key ] = True <NEWLINE> <NL> <DEDENT> B = [ True ] * N <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not D [ A [ i ] ] : continue <NEWLINE> if C [ A [ i ] ] > 1 : <NEWLINE> <INDENT> D [ A [ i ] ] = False <NEWLINE> <NL> <DEDENT> for a in range ( 2 * A [ i ] , A [ - 1 ] + 1 , A [ i ] ) : <NEWLINE> <INDENT> D [ a ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for key in D : <NEWLINE> <INDENT> if D [ key ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import decimal <NEWLINE> <NL> lines = sys . stdin . readlines ( ) <NEWLINE> size = int ( lines [ 0 ] ) <NEWLINE> data = lines [ 1 : len ( lines ) ] <NEWLINE> for line in data : <NEWLINE> <INDENT> line = line . split ( <STRING> ) <NEWLINE> inp = [ ] <NEWLINE> for i in line : <NEWLINE> <INDENT> inp . append ( decimal . Decimal ( i ) ) <NEWLINE> <DEDENT> x = [ ] <NEWLINE> x . append ( inp [ 0 ] ) <NEWLINE> x . append ( inp [ 2 ] ) <NEWLINE> x . append ( inp [ 4 ] ) <NEWLINE> x . append ( inp [ 6 ] ) <NEWLINE> y = [ ] <NEWLINE> y . append ( inp [ 1 ] ) <NEWLINE> y . append ( inp [ 3 ] ) <NEWLINE> y . append ( inp [ 5 ] ) <NEWLINE> y . append ( inp [ 7 ] ) <NEWLINE> if x [ 1 ] == x [ 0 ] and x [ 3 ] == x [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x [ 1 ] == x [ 0 ] or x [ 3 ] == x [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tilt1 = ( y [ 1 ] - y [ 0 ] ) / ( x [ 1 ] - x [ 0 ] ) <NEWLINE> tilt2 = ( y [ 3 ] - y [ 2 ] ) / ( x [ 3 ] - x [ 2 ] ) <NEWLINE> if tilt1 == tilt2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for elT in t : <NEWLINE> <INDENT> minI = 0 <NEWLINE> maxI = len ( s ) - 1 <NEWLINE> while minI <= maxI : <NEWLINE> <INDENT> middle = ( minI + maxI ) // 2 <NEWLINE> if s [ middle ] == elT : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif s [ middle ] < elT : <NEWLINE> <INDENT> minI = middle + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxI = middle - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> def calc ( x , y , z ) : <NEWLINE> <INDENT> return x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> def calc_combination_num ( x , y , z ) : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <COMMENT> <NL> <INDENT> return 1 <NEWLINE> <DEDENT> if x == y or y == z : <NEWLINE> <COMMENT> <NL> <INDENT> return 3 <NEWLINE> <COMMENT> <NL> <DEDENT> return 6 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> result_map = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> result_map [ i ] = 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for x in range ( 1 , N ) : <NEWLINE> <INDENT> tempFn1 = calc ( x , 0 , 0 ) <NEWLINE> if tempFn1 > N : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> for y in range ( x , N ) : <NEWLINE> <INDENT> tempFn2 = calc ( x , y , 0 ) <NEWLINE> if tempFn2 > N : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> for z in range ( y , N ) : <NEWLINE> <INDENT> fn = calc ( x , y , z ) <NEWLINE> if fn > N : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> combination_num = calc_combination_num ( x , y , z ) <NEWLINE> result_map [ fn ] = result_map [ fn ] + combination_num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for result in result_map . values ( ) : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> r = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> r += gcd ( gcd ( i , j ) , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 100 <NEWLINE> x = sum ( a ) <NEWLINE> b = 0 <NEWLINE> for i in a [ : - 1 ] : <NEWLINE> <INDENT> b += i <NEWLINE> x -= i <NEWLINE> ans = min ( ans , abs ( x - b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if v == w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> atai = Decimal ( abs ( b - a ) ) / Decimal ( abs ( v - w ) ) <NEWLINE> if atai <= t and a + v * t >= b + w * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> t = list ( t ) <NEWLINE> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> . join ( t ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) ; arr = list ( map ( int , input ( ) . split ( ) ) ) ; arr . sort ( reverse = True ) <NEWLINE> absarr = [ [ abs ( i ) , 1 if i > 0 else - 1 if i < 0 else 0 ] for i in arr ] ; absarr . sort ( reverse = True , key = lambda x : x [ 0 ] ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> zeroflag = True if absarr [ - 1 ] [ 0 ] == 0 else False <NEWLINE> from collections import Counter <NEWLINE> posnegarr = Counter ( [ i [ 1 ] for i in absarr [ : k ] ] ) <NEWLINE> pos = posnegarr [ 1 ] ; neg = posnegarr [ - 1 ] <NEWLINE> <NL> if absarr [ k - 1 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif neg % 2 == 0 or n == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in absarr [ : k ] : <NEWLINE> <INDENT> ans *= i [ 0 ] ; ans %= mod <NEWLINE> <DEDENT> if n == k and neg % 2 == 1 : <NEWLINE> <INDENT> ans = - ans % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in absarr [ : k ] : <NEWLINE> <INDENT> ans *= i [ 0 ] ; ans %= mod <NEWLINE> <DEDENT> if pos > 0 : <NEWLINE> <INDENT> if absarr [ k ] [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> nextpos = nextneg = 0 <NEWLINE> tmp = k <NEWLINE> while tmp < n and ( nextpos == 0 or nextneg == 0 ) : <NEWLINE> <INDENT> num = absarr [ tmp ] <NEWLINE> if num [ 0 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif num [ 1 ] > 0 and nextpos == 0 : <NEWLINE> <INDENT> nextpos = num [ 0 ] <NEWLINE> <DEDENT> elif num [ 1 ] < 0 and nextneg == 0 : <NEWLINE> <INDENT> nextneg = num [ 0 ] <NEWLINE> <DEDENT> tmp += 1 <NEWLINE> <DEDENT> backpos = backneg = 0 <NEWLINE> tmp = k - 1 <NEWLINE> while backpos == 0 or backneg == 0 : <NEWLINE> <INDENT> num = absarr [ tmp ] <NEWLINE> if num [ 1 ] > 0 and backpos == 0 : <NEWLINE> <INDENT> backpos = num [ 0 ] <NEWLINE> <DEDENT> elif num [ 1 ] < 0 and backneg == 0 : <NEWLINE> <INDENT> backneg = num [ 0 ] <NEWLINE> <DEDENT> tmp -= 1 <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif nextpos * backpos > nextneg * backneg : <NEWLINE> <INDENT> ans *= nextpos * pow ( backneg , - 1 , mod ) ; ans %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= nextneg * pow ( backpos , - 1 , mod ) ; ans %= mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> nextpos = 0 <NEWLINE> tmp = k <NEWLINE> while tmp < n and nextpos == 0 : <NEWLINE> <INDENT> num = absarr [ tmp ] <NEWLINE> if num [ 1 ] > 0 : <NEWLINE> <INDENT> nextpos = num [ 0 ] <NEWLINE> <DEDENT> tmp += 1 <NEWLINE> <DEDENT> backneg = absarr [ k - 1 ] [ 0 ] <NEWLINE> if nextpos != 0 : <NEWLINE> <INDENT> ans *= nextpos * pow ( backneg , - 1 , mod ) ; ans %= mod <NEWLINE> <DEDENT> elif zeroflag : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in arr [ : k ] : <NEWLINE> <INDENT> ans *= i ; ans %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> n_max = int ( math . sqrt ( N ) ) <NEWLINE> l = [ i for i in range ( 1 , n_max ) ] <NEWLINE> score = np . zeros ( [ 10000 ] ) . astype ( np . uint8 ) <NEWLINE> for c in itertools . combinations_with_replacement ( l , 3 ) : <NEWLINE> <INDENT> sum = c [ 0 ] ** 2 + c [ 1 ] ** 2 + c [ 2 ] ** 2 + c [ 0 ] * c [ 1 ] + c [ 0 ] * c [ 2 ] + c [ 1 ] * c [ 2 ] <NEWLINE> if sum <= 10000 : <NEWLINE> <INDENT> if len ( set ( c ) ) == 3 : <NEWLINE> <INDENT> score [ sum - 1 ] += 6 <NEWLINE> <DEDENT> elif len ( set ( c ) ) == 2 : <NEWLINE> <INDENT> score [ sum - 1 ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score [ sum - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( score [ n - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Hi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> temp = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if Hi [ i ] <= Hi [ i - 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if temp > ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> temp = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if temp > ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> A = range ( - 118 , 120 ) <NEWLINE> B = range ( - 118 , 120 ) <NEWLINE> flag = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> ans = a ** 5 - b ** 5 <NEWLINE> if ans == X : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mina = min ( A ) <NEWLINE> maxa = max ( A ) <NEWLINE> AA = [ 0 ] * ( maxa - mina + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> maxj = maxa // A [ i ] <NEWLINE> for j in range ( 1 , maxj + 1 ) : <NEWLINE> <INDENT> AA [ j * A [ i ] - mina ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if AA [ A [ i ] - mina ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> min_p = n + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] < min_p : <NEWLINE> <INDENT> ans += 1 <NEWLINE> min_p = p [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> class gcd : <NEWLINE> <INDENT> def __init__ ( self , a , b , c ) : <NEWLINE> <INDENT> self . a = a <NEWLINE> self . b = b <NEWLINE> self . c = c <NEWLINE> <NL> <DEDENT> def gcds ( self ) : <NEWLINE> <INDENT> if self . a > self . b : <NEWLINE> <INDENT> x = self . a <NEWLINE> y = self . b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = self . b <NEWLINE> y = self . a <NEWLINE> <NL> <DEDENT> while x % y != 0 : <NEWLINE> <INDENT> tem_y = y <NEWLINE> y = x % y <NEWLINE> x = tem_y <NEWLINE> <NL> <DEDENT> gcd_1 = y <NEWLINE> <NL> if gcd_1 > self . c : <NEWLINE> <INDENT> x = gcd_1 <NEWLINE> y = self . c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = self . c <NEWLINE> y = gcd_1 <NEWLINE> <NL> <DEDENT> while x % y != 0 : <NEWLINE> <INDENT> tem_y = y <NEWLINE> y = x % y <NEWLINE> x = tem_y <NEWLINE> <NL> <DEDENT> return int ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for l in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == l : <NEWLINE> <INDENT> sum = sum + gcd ( i , j , l ) . gcds ( ) <NEWLINE> <DEDENT> elif i != j and j == l : <NEWLINE> <INDENT> sum = sum + gcd ( i , j , l ) . gcds ( ) * 3 <NEWLINE> <DEDENT> elif i == j and j != l : <NEWLINE> <INDENT> sum = sum + gcd ( i , j , l ) . gcds ( ) * 3 <NEWLINE> <DEDENT> elif i != j and j != l : <NEWLINE> <INDENT> sum = sum + gcd ( i , j , l ) . gcds ( ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ap = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ap [ i - a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += ap [ a [ i ] + i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gou = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> gou -= a [ i ] <NEWLINE> ans += a [ i ] * ( gou ) <NEWLINE> <DEDENT> ans %= 10 ** 9 + 7 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> num_1 = 2 <NEWLINE> num_2 = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans = num_1 + num_2 <NEWLINE> num_1 , num_2 = num_2 , ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <NL> if n >= ( ( 26 ** 12 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 12 - 1 ) // ( 26 - 1 ) ) <NEWLINE> l = n // ( 26 ** 11 ) <NEWLINE> n = n % ( 26 ** 11 ) <NEWLINE> k = n // ( 26 ** 10 ) <NEWLINE> n = n % ( 26 ** 10 ) <NEWLINE> j = n // ( 26 ** 9 ) <NEWLINE> n = n % ( 26 ** 9 ) <NEWLINE> i = n // ( 26 ** 8 ) <NEWLINE> n = n % ( 26 ** 8 ) <NEWLINE> h = n // ( 26 ** 7 ) <NEWLINE> n = n % ( 26 ** 7 ) <NEWLINE> g = n // ( 26 ** 6 ) <NEWLINE> n = n % ( 26 ** 6 ) <NEWLINE> f = n // ( 26 ** 5 ) <NEWLINE> n = n % ( 26 ** 5 ) <NEWLINE> e = n // ( 26 ** 4 ) <NEWLINE> n = n % ( 26 ** 4 ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ l ] + a [ k ] + a [ j ] + a [ i ] + a [ h ] + a [ g ] + a [ f ] + a [ e ] + a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 11 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 11 - 1 ) // ( 26 - 1 ) ) <NEWLINE> k = n // ( 26 ** 10 ) <NEWLINE> n = n % ( 26 ** 10 ) <NEWLINE> j = n // ( 26 ** 9 ) <NEWLINE> n = n % ( 26 ** 9 ) <NEWLINE> i = n // ( 26 ** 8 ) <NEWLINE> n = n % ( 26 ** 8 ) <NEWLINE> h = n // ( 26 ** 7 ) <NEWLINE> n = n % ( 26 ** 7 ) <NEWLINE> g = n // ( 26 ** 6 ) <NEWLINE> n = n % ( 26 ** 6 ) <NEWLINE> f = n // ( 26 ** 5 ) <NEWLINE> n = n % ( 26 ** 5 ) <NEWLINE> e = n // ( 26 ** 4 ) <NEWLINE> n = n % ( 26 ** 4 ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ k ] + a [ j ] + a [ i ] + a [ h ] + a [ g ] + a [ f ] + a [ e ] + a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 10 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 10 - 1 ) // ( 26 - 1 ) ) <NEWLINE> j = n // ( 26 ** 9 ) <NEWLINE> n = n % ( 26 ** 9 ) <NEWLINE> i = n // ( 26 ** 8 ) <NEWLINE> n = n % ( 26 ** 8 ) <NEWLINE> h = n // ( 26 ** 7 ) <NEWLINE> n = n % ( 26 ** 7 ) <NEWLINE> g = n // ( 26 ** 6 ) <NEWLINE> n = n % ( 26 ** 6 ) <NEWLINE> f = n // ( 26 ** 5 ) <NEWLINE> n = n % ( 26 ** 5 ) <NEWLINE> e = n // ( 26 ** 4 ) <NEWLINE> n = n % ( 26 ** 4 ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ j ] + a [ i ] + a [ h ] + a [ g ] + a [ f ] + a [ e ] + a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 9 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 9 - 1 ) // ( 26 - 1 ) ) <NEWLINE> i = n // ( 26 ** 8 ) <NEWLINE> n = n % ( 26 ** 8 ) <NEWLINE> h = n // ( 26 ** 7 ) <NEWLINE> n = n % ( 26 ** 7 ) <NEWLINE> g = n // ( 26 ** 6 ) <NEWLINE> n = n % ( 26 ** 6 ) <NEWLINE> f = n // ( 26 ** 5 ) <NEWLINE> n = n % ( 26 ** 5 ) <NEWLINE> e = n // ( 26 ** 4 ) <NEWLINE> n = n % ( 26 ** 4 ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ i ] + a [ h ] + a [ g ] + a [ f ] + a [ e ] + a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 8 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 8 - 1 ) // ( 26 - 1 ) ) <NEWLINE> h = n // ( 26 ** 7 ) <NEWLINE> n = n % ( 26 ** 7 ) <NEWLINE> g = n // ( 26 ** 6 ) <NEWLINE> n = n % ( 26 ** 6 ) <NEWLINE> f = n // ( 26 ** 5 ) <NEWLINE> n = n % ( 26 ** 5 ) <NEWLINE> e = n // ( 26 ** 4 ) <NEWLINE> n = n % ( 26 ** 4 ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ h ] + a [ g ] + a [ f ] + a [ e ] + a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 7 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 7 - 1 ) // ( 26 - 1 ) ) <NEWLINE> g = n // ( 26 ** 6 ) <NEWLINE> n = n % ( 26 ** 6 ) <NEWLINE> f = n // ( 26 ** 5 ) <NEWLINE> n = n % ( 26 ** 5 ) <NEWLINE> e = n // ( 26 ** 4 ) <NEWLINE> n = n % ( 26 ** 4 ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ g ] + a [ f ] + a [ e ] + a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 6 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 6 - 1 ) // ( 26 - 1 ) ) <NEWLINE> f = n // ( 26 ** 5 ) <NEWLINE> n = n % ( 26 ** 5 ) <NEWLINE> e = n // ( 26 ** 4 ) <NEWLINE> n = n % ( 26 ** 4 ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ f ] + a [ e ] + a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 5 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 5 - 1 ) // ( 26 - 1 ) ) <NEWLINE> e = n // ( 26 ** 4 ) <NEWLINE> n = n % ( 26 ** 4 ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ e ] + a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 4 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 4 - 1 ) // ( 26 - 1 ) ) <NEWLINE> d = n // ( 26 ** 3 ) <NEWLINE> n = n % ( 26 ** 3 ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ d ] + a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 3 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 3 - 1 ) // ( 26 - 1 ) ) <NEWLINE> c = n // ( 26 ** 2 ) <NEWLINE> n = n % ( 26 ** 2 ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ c ] + a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> elif n >= ( ( 26 ** 2 - 1 ) / ( 26 - 1 ) ) : <NEWLINE> <INDENT> n = n - ( ( 26 ** 2 - 1 ) // ( 26 - 1 ) ) <NEWLINE> b = n // 26 <NEWLINE> aa = n % 26 <NEWLINE> ans = a [ b ] + a [ aa ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = a [ n - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cl = [ None ] * n <NEWLINE> al = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cl [ i ] , * al [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def dfs ( i , cost , A ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> global ans <NEWLINE> if all ( [ a >= x for a in A ] ) and cost < ans : <NEWLINE> <INDENT> ans = cost <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> i += 1 <NEWLINE> dfs ( i , cost , A [ : ] ) <NEWLINE> dfs ( i , cost + cl [ i ] , A [ : ] + al [ i ] ) <NEWLINE> <NL> <DEDENT> dfs ( - 1 , 0 , np . array ( [ 0 ] * m ) ) <NEWLINE> <NL> if ans == 10 ** 7 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ans = 10 ** 7 <NEWLINE> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s = deque ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> i = input ( ) . split ( ) <NEWLINE> t = int ( i [ 0 ] ) <NEWLINE> <NL> if t == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( i [ 1 ] ) <NEWLINE> c = i [ 2 ] <NEWLINE> if ( cnt % 2 == 0 and f == 1 ) or ( cnt % 2 == 1 and f == 2 ) : <NEWLINE> <INDENT> s . appendleft ( i [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( i [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
import sys <NEWLINE> <NL> def sieve ( n ) : <NEWLINE> <INDENT> N = n + 1 <NEWLINE> ints = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( N ) ] <NEWLINE> try : <NEWLINE> <INDENT> ints [ 0 ] = ints [ 1 ] = False <NEWLINE> ints [ 2 ] = ints [ 3 ] = ints [ 5 ] = True <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> sqrt = N ** 0.5 <NEWLINE> <NL> for i in range ( 3 , N , 2 ) : <NEWLINE> <INDENT> if i >= sqrt : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for m in range ( i ** 2 , N , i ) : <NEWLINE> <INDENT> ints [ m ] = False <NEWLINE> <DEDENT> <DEDENT> return ints <NEWLINE> <NL> <DEDENT> prime1m = sieve ( 1000000 ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> print ( prime1m [ : int ( line ) + 1 ] . count ( True ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> R = s . count ( <STRING> ) <NEWLINE> G = s . count ( <STRING> ) <NEWLINE> B = s . count ( <STRING> ) <NEWLINE> ans = R * G * B <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> a = s [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if a == s [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = s [ j ] <NEWLINE> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ k ] != a and s [ k ] != b : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( q , - int ( s [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = heapq . heappop ( q ) <NEWLINE> print ( - p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> c = collections . Counter ( a ) <NEWLINE> if len ( c ) < k : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = c . most_common ( ) <NEWLINE> for i in range ( 1 , - k + len ( c ) + 1 ) : <NEWLINE> <INDENT> ans += l [ - i ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> abs_x = abs ( x ) <NEWLINE> firstNearestIterNum = abs_x // d <NEWLINE> <NL> if firstNearestIterNum >= k : <NEWLINE> <INDENT> result = abs_x - ( d * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - firstNearestIterNum ) % 2 == 1 : <NEWLINE> <INDENT> result = abs_x - ( d * ( firstNearestIterNum + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = abs_x - d * firstNearestIterNum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abs ( result ) ) <NEWLINE>
def lrCount ( rCount , lCount , ansList , i ) : <NEWLINE> <INDENT> count = rCount + lCount <NEWLINE> c = 0 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> if count % 2 == 0 : <NEWLINE> <INDENT> ansList [ i - lCount + c ] = count // 2 <NEWLINE> ansList [ i - lCount - 1 + c ] = count // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if rCount % 2 == 1 : <NEWLINE> <INDENT> ansList [ i - lCount + c ] = count // 2 <NEWLINE> ansList [ i - lCount - 1 + c ] = count // 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ansList [ i - lCount + c ] = count // 2 + 1 <NEWLINE> ansList [ i - lCount - 1 + c ] = count // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> check = <STRING> <NEWLINE> ansList = [ 0 for i in range ( len ( s ) ) ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if check == <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> check = <STRING> <NEWLINE> rCount = 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == check and i != len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rCount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lCount += 1 <NEWLINE> <DEDENT> <DEDENT> elif i == len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> lCount = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lCount += 1 <NEWLINE> <DEDENT> lrCount ( rCount , lCount , ansList , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> check = <STRING> <NEWLINE> lCount = 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> lrCount ( rCount , lCount , ansList , i ) <NEWLINE> check = <STRING> <NEWLINE> rCount = 1 <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( ansList ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = str ( ansList [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> + str ( ansList [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> c = [ [ ] for i in range ( N ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> c [ a - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def f2 ( q ) : <NEWLINE> <INDENT> s = set ( q ) <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> if a in s and b in s : <NEWLINE> <INDENT> i = q . index ( b ) <NEWLINE> if q [ i - 1 ] != a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a in s and b in s and q [ i - 1 ] != a : <NEWLINE> <INDENT> q2 = deque ( [ a , b ] ) <NEWLINE> while q [ ( i + 1 ) % len ( q ) ] != a : <NEWLINE> <INDENT> q2 . append ( q [ ( i + 1 ) % len ( q ) ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> f2 ( q2 ) <NEWLINE> <DEDENT> print ( len ( q ) , * q , sep = <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> v = [ 0 ] * N <NEWLINE> w = [ 0 ] * N <NEWLINE> def f ( p , v , q ) : <NEWLINE> <INDENT> v [ p ] = 1 <NEWLINE> w [ p ] = 1 <NEWLINE> q . append ( p + 1 ) <NEWLINE> for n in c [ p ] : <NEWLINE> <INDENT> if v [ n ] : <NEWLINE> <INDENT> f2 ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f ( n , v , q ) <NEWLINE> <DEDENT> <DEDENT> q . pop ( ) <NEWLINE> v [ p ] = 0 <NEWLINE> <DEDENT> for p in range ( N ) : <NEWLINE> <INDENT> if w [ p ] == 0 : <NEWLINE> <INDENT> f ( p , v , deque ( ) ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if 2 * j - i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] != S [ j ] and S [ j ] != S [ 2 * j - i ] and S [ 2 * j - i ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = max ( a ) <NEWLINE> d = [ 0 ] * ( m + 1 ) <NEWLINE> d [ 1 ] = 1 <NEWLINE> for i in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> if d [ j ] == 0 : <NEWLINE> <INDENT> d [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def prime_factorize ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> while n > 1 : <NEWLINE> <INDENT> res . append ( d [ n ] ) <NEWLINE> n //= d [ n ] <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def is_pairwise_coprime ( ) : <NEWLINE> <INDENT> exists = [ 0 ] * ( m + 1 ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> for p in set ( prime_factorize ( ai ) ) : <NEWLINE> <INDENT> if exists [ p ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> exists [ p ] = 1 <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <NL> <DEDENT> def is_setwise_coprime ( ) : <NEWLINE> <INDENT> return reduce ( gcd , a ) == 1 <NEWLINE> <NL> <NL> <DEDENT> if is_pairwise_coprime ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif is_setwise_coprime ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import itertools <NEWLINE> d = defaultdict ( int ) <NEWLINE> x = <STRING> <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> d [ x [ i ] ] = i + 1 <NEWLINE> <DEDENT> x = [ 0 ] * 5 <NEWLINE> def sub ( a , b ) : <NEWLINE> <INDENT> return abs ( a [ 0 ] - b [ 0 ] ) + abs ( a [ 1 ] - b [ 1 ] ) <NEWLINE> <NL> <DEDENT> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( H ) ] <NEWLINE> N = H * W <NEWLINE> P = [ 0 ] * ( N ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> P [ A [ h ] [ w ] - 1 ] = ( h , w ) <NEWLINE> <DEDENT> <DEDENT> X = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> _ = [ 0 ] + [ sub ( P [ i % N ] , P [ i - D ] ) for i in range ( d + D , N + D , D ) ] <NEWLINE> cumsum = list ( itertools . accumulate ( _ ) ) <NEWLINE> X . append ( cumsum ) <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = l - 1 , r - 1 <NEWLINE> g = l % D <NEWLINE> if l > r : <NEWLINE> <INDENT> r += N <NEWLINE> ans = X [ g ] [ - 1 ] - X [ g ] [ l // D ] <NEWLINE> ans += X [ g ] [ r // D ] - X [ g ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = X [ g ] [ r // D ] - X [ g ] [ l // D ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def sieve ( n ) : <NEWLINE> <INDENT> num = [ True ] * n <NEWLINE> num [ 0 ] = num [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if num [ i ] : <NEWLINE> <INDENT> for j in range ( i ** 2 , n , i ) : <NEWLINE> <INDENT> num [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ i for i in range ( 2 , n ) if num [ i ] ] <NEWLINE> <NL> <DEDENT> prime = sieve ( 110000 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print ( sum ( prime [ : n ] ) ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> now = 0 <NEWLINE> flg = True <NEWLINE> while l : <NEWLINE> <INDENT> now += l . pop ( 0 ) <NEWLINE> if now <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for x in t : <NEWLINE> <INDENT> if x in s : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( Ai ) for Ai in input ( ) . split ( ) ] <NEWLINE> <NL> counter = Counter ( A ) <NEWLINE> <NL> dp = [ 1 ] * ( max ( A ) + 1 ) <NEWLINE> for Ai in A : <NEWLINE> <INDENT> for j in range ( Ai * 2 , len ( dp ) , Ai ) : <NEWLINE> <INDENT> dp [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ dp [ Ai ] == 1 and counter [ Ai ] == 1 for Ai in A ] ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if gcd1 == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += math . gcd ( gcd1 , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> ans_set = set ( range ( 1 , n + 1 ) ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if height [ a - 1 ] >= height [ b - 1 ] : <NEWLINE> <INDENT> ans_set . discard ( b ) <COMMENT> <NEWLINE> <DEDENT> if height [ a - 1 ] <= height [ b - 1 ] : <NEWLINE> <INDENT> ans_set . discard ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans_set ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> ans = max ( int ( a * n / b ) - a * int ( n / b ) , ans ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , n // ( b - 1 ) + 1 ) : <NEWLINE> <INDENT> ans = max ( int ( a * ( k * b - 1 ) / b ) - a * int ( ( k * b - 1 ) / b ) , ans ) <NEWLINE> if ans == a : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans != a : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> k = N - 2 <NEWLINE> a = A . pop ( ) <NEWLINE> ans = a <NEWLINE> n = k // 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = A . pop ( ) <NEWLINE> ans += 2 * a <NEWLINE> <DEDENT> if k - 2 * n == 1 : <NEWLINE> <INDENT> ans += A [ - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> T . append ( t ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> Tnow = T [ 0 ] <NEWLINE> Anow = A [ 0 ] <NEWLINE> <NL> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> t = T [ i ] <NEWLINE> a = A [ i ] <NEWLINE> t1 = ( Tnow + t - 1 ) // t * t <NEWLINE> a1 = t1 // t * a <NEWLINE> a2 = ( Anow + a - 1 ) // a * a <NEWLINE> t2 = a2 // a * t <NEWLINE> if a1 < Anow : <NEWLINE> <INDENT> Tnow = t2 <NEWLINE> Anow = a2 <NEWLINE> <DEDENT> elif t2 < Tnow : <NEWLINE> <INDENT> Tnow = t1 <NEWLINE> Anow = a1 <NEWLINE> <DEDENT> elif t1 + a1 <= t2 + a2 : <NEWLINE> <INDENT> Tnow = t1 <NEWLINE> Anow = a1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Tnow = t2 <NEWLINE> Anow = a2 <NEWLINE> <DEDENT> <DEDENT> print ( Tnow + Anow ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = math . floor ( ( a * x ) / b ) - a * ( math . floor ( x / b ) ) <NEWLINE> print ( ans ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( make_divisors ( i ) ) == 8 and i % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> N = int ( sys . stdin . readline ( ) ) <NEWLINE> values = [ ] <NEWLINE> res = 1 <NEWLINE> values = sys . stdin . readline ( ) . split ( ) <NEWLINE> for v in values : <NEWLINE> <INDENT> if int ( v ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for v in values : <NEWLINE> <INDENT> res *= int ( v ) <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> print ( c [ : c . count ( <STRING> ) ] . count ( <STRING> ) ) <NEWLINE>
from typing import Dict , List <NEWLINE> <NL> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , num_node : int ) : <NEWLINE> <INDENT> self . __parent_index = [ x for x in range ( num_node ) ] <NEWLINE> self . __tree_rank = [ 1 ] * num_node <NEWLINE> <NL> <DEDENT> def __is_root ( self , index : int ) -> bool : <NEWLINE> <INDENT> return self . __parent_index [ index ] == index <NEWLINE> <NL> <DEDENT> def root ( self , index : int ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> while not self . __is_root ( index ) : <NEWLINE> <INDENT> index = self . __parent_index [ index ] = self . root ( self . __parent_index [ index ] ) <NEWLINE> <DEDENT> return index <NEWLINE> <NL> <DEDENT> def unite ( self , x : int , y : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if self . __tree_rank [ x ] < self . __tree_rank [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . __tree_rank [ x ] += self . __tree_rank [ y ] <NEWLINE> self . __parent_index [ y ] = x <NEWLINE> <NL> return True <NEWLINE> <NL> <DEDENT> def groups ( self ) -> Dict [ int , List [ int ] ] : <NEWLINE> <INDENT> __groups : Dict [ int , List [ int ] ] = { } <NEWLINE> for node , parent in enumerate ( self . __parent_index ) : <NEWLINE> <INDENT> __root = self . root ( parent ) <NEWLINE> if __groups . get ( __root ) is None : <NEWLINE> <INDENT> __groups [ __root ] = [ node ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> __groups [ __root ] . append ( node ) <NEWLINE> <NL> <DEDENT> <DEDENT> return __groups <NEWLINE> <NL> <DEDENT> <DEDENT> uni = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> uni . unite ( a , b ) <NEWLINE> <NL> <DEDENT> print ( len ( uni . groups ( ) ) - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = 0 <NEWLINE> if 0 in lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in lst : <NEWLINE> <INDENT> ans *= _ <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> array = [ ] <NEWLINE> A = [ i for i in range ( 1 , m + 1 ) ] <NEWLINE> A_list = list ( itertools . combinations_with_replacement ( A , n ) ) <NEWLINE> max_sum = [ 0 ] * len ( A_list ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( len ( A_list ) ) : <NEWLINE> <INDENT> if A_list [ j ] [ b - 1 ] - A_list [ j ] [ a - 1 ] == c : <NEWLINE> <INDENT> max_sum [ j ] += d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( max_sum ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> rCount = s . count ( <STRING> ) <NEWLINE> gCount = s . count ( <STRING> ) <NEWLINE> bCount = s . count ( <STRING> ) <NEWLINE> ans = rCount * gCount * bCount <NEWLINE> <NL> for dis in range ( 1 , math . ceil ( len ( s ) / 2 ) ) : <NEWLINE> <INDENT> for i in range ( dis , len ( s ) - dis ) : <NEWLINE> <INDENT> if s [ i - dis ] != s [ i ] and s [ i - dis ] != s [ i + dis ] and s [ i ] != s [ i + dis ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 0 <NEWLINE> l = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> d , p = map ( int , input ( ) . split ( ) ) <NEWLINE> s += d * p <NEWLINE> l . append ( ( p , d ) ) <NEWLINE> <NL> <DEDENT> l . sort ( ) <NEWLINE> while m > 0 and l : <NEWLINE> <INDENT> a , b = l . pop ( ) <NEWLINE> if m >= b : <NEWLINE> <INDENT> s -= a * b <NEWLINE> m -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= a * m <NEWLINE> m = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> c = str ( input ( ) ) <NEWLINE> C . append ( c ) <NEWLINE> <DEDENT> from itertools import combinations <NEWLINE> from collections import Counter <NEWLINE> <NL> def subsets ( nums ) : <NEWLINE> <INDENT> n = len ( nums ) <NEWLINE> out = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> subout = [ ] <NEWLINE> comb ( nums , i , subout ) <NEWLINE> out += subout <NEWLINE> <DEDENT> return out <NEWLINE> <NL> <DEDENT> def comb ( seq , k , out ) : <NEWLINE> <INDENT> _comb ( seq , len ( seq ) , k , 0 , [ ] , out ) <NEWLINE> <NL> <DEDENT> def _comb ( seq , n , k , i , elem , out ) : <NEWLINE> <INDENT> le = len ( elem ) <NEWLINE> if le == k : <NEWLINE> <INDENT> out . append ( elem ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( i , n ) : <NEWLINE> <INDENT> _comb ( seq , n , k , i + 1 , elem + [ seq [ i ] ] , out ) <NEWLINE> <NL> <DEDENT> <DEDENT> def powset ( H , W , K , C ) : <NEWLINE> <INDENT> X = subsets ( list ( range ( W ) ) ) <NEWLINE> N = len ( X ) <NEWLINE> A = [ ] <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> a = [ 0 ] * N <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> for ind in X [ k ] : <NEWLINE> <INDENT> if C [ j ] [ ind ] == <STRING> : <NEWLINE> <INDENT> a [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> A . append ( a ) <NEWLINE> <DEDENT> Y = subsets ( list ( range ( H ) ) ) <NEWLINE> M = len ( Y ) <NEWLINE> ans = [ 0 ] * ( N * M ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> for l in range ( M ) : <NEWLINE> <INDENT> for ind in Y [ l ] : <NEWLINE> <INDENT> ans [ l * N + k ] += A [ ind ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c = Counter ( ans ) <NEWLINE> <COMMENT> <NL> if K in c : <NEWLINE> <INDENT> return c [ K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def Main ( H , W , K , C ) : <NEWLINE> <INDENT> return powset ( H , W , K , C ) <NEWLINE> <NL> <DEDENT> out = Main ( H , W , K , C ) <NEWLINE> print ( out ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T -= A [ i ] <NEWLINE> ans += A [ i ] * T <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for i in lst : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global Comp_count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( 1000000001 ) <NEWLINE> R . append ( 1000000001 ) <NEWLINE> i = 0 <COMMENT> <NEWLINE> j = 0 <COMMENT> <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> Comp_count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> from array import array <NEWLINE> def merge_with_array ( A , left , mid , right ) : <NEWLINE> <INDENT> global Comp_count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = array ( <STRING> , A [ left : mid ] ) <NEWLINE> R = array ( <STRING> , A [ mid : right ] ) <NEWLINE> L . append ( 1000000001 ) <NEWLINE> R . append ( 1000000001 ) <NEWLINE> <NL> i = 0 <COMMENT> <NEWLINE> j = 0 <COMMENT> <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> Comp_count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> from ctypes import * <NEWLINE> class DATA ( Structure ) : <NEWLINE> <INDENT> _fields_ = ( <STRING> , c_int * 250002 ) , <NEWLINE> <DEDENT> L = DATA ( ) <NEWLINE> R = DATA ( ) <NEWLINE> <NL> def merge_with_ctypes ( A , left , mid , right ) : <NEWLINE> <INDENT> global Comp_count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> for i in range ( n1 ) : <NEWLINE> <INDENT> L . d [ i ] = A [ left + i ] <NEWLINE> <DEDENT> for i in range ( n2 ) : <NEWLINE> <INDENT> R . d [ i ] = A [ mid + i ] <NEWLINE> <DEDENT> L . d [ n1 ] = 1000000001 <NEWLINE> R . d [ n2 ] = 1000000001 <NEWLINE> <NL> i = 0 <COMMENT> <NEWLINE> j = 0 <COMMENT> <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> Comp_count += 1 <NEWLINE> if L . d [ i ] <= R . d [ j ] : <NEWLINE> <INDENT> A [ k ] = L . d [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R . d [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> Comp_count = 0 <NEWLINE> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num_of_data = int ( input ( ) ) <NEWLINE> S = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> merge_sort ( S , 0 , num_of_data ) <NEWLINE> <NL> <COMMENT> <NL> print ( <STRING> . format ( <STRING> . join ( map ( str , S ) ) ) ) <NEWLINE> print ( Comp_count ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> c1 = [ ] <NEWLINE> c2 = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> c1 . append ( b ) <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> c2 . append ( a ) <NEWLINE> <DEDENT> <DEDENT> c1 = set ( c1 ) <NEWLINE> c2 = set ( c2 ) <NEWLINE> if c1 & c2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import math <NEWLINE> <NL> def insertionSort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = [ 1 ] <NEWLINE> if n != 1 : <NEWLINE> <INDENT> for i in range ( 99 ) : <NEWLINE> <INDENT> G . append ( G [ i ] * 3 + 1 ) <NEWLINE> <DEDENT> G = [ x for x in G if x < n ] <NEWLINE> G . reverse ( ) <NEWLINE> <DEDENT> m = len ( G ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> cnt = insertionSort ( A , n , G [ i ] , cnt ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shellSort ( A , n ) <NEWLINE> for i in A : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> total = sum ( A ) <NEWLINE> A = Counter ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> total = total - ( A [ B ] * B ) + ( C * A [ B ] ) <NEWLINE> A [ C ] = A [ C ] + A [ B ] <NEWLINE> A [ B ] = 0 <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pop_count ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def fact ( N ) : <NEWLINE> <INDENT> res = { } <NEWLINE> tmp = N <NEWLINE> for i in range ( 2 , int ( N ** 0.5 + 1 ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> res [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> res [ tmp ] = 1 <NEWLINE> <DEDENT> if res == { } : <NEWLINE> <INDENT> res [ N ] = 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def modpow ( n , p ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> while p > 0 : <NEWLINE> <INDENT> if p & 1 : <NEWLINE> <INDENT> res = res * n % MOD <NEWLINE> <DEDENT> n = n * n % MOD <NEWLINE> p >>= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def modinv ( n ) : <NEWLINE> <INDENT> b , u , v = MOD , 1 , 0 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> t = n // b <NEWLINE> n -= t * b <NEWLINE> n , b = b , n <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= MOD <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += MOD <NEWLINE> <DEDENT> return u <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = Scanner . int ( ) <NEWLINE> A = Scanner . map_int ( ) <NEWLINE> L = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for k , v in fact ( A [ i ] ) . items ( ) : <NEWLINE> <INDENT> L [ k ] = max ( L [ k ] , v ) <NEWLINE> <DEDENT> <DEDENT> lcm = 1 <NEWLINE> for k , v in L . items ( ) : <NEWLINE> <INDENT> lcm *= modpow ( k , v ) <NEWLINE> lcm %= MOD <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = lcm * modinv ( A [ i ] ) % MOD <NEWLINE> ans += x <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def postorder ( preo , ino ) : <NEWLINE> <INDENT> if preo : <NEWLINE> <INDENT> root = preo [ 0 ] <NEWLINE> inroot = ino . index ( root ) <NEWLINE> leftpre = preo [ 1 : inroot + 1 ] <NEWLINE> leftin = ino [ : inroot ] <NEWLINE> rightpre = preo [ inroot + 1 : ] <NEWLINE> rightin = ino [ inroot + 1 : ] <NEWLINE> postorder ( leftpre , leftin ) <NEWLINE> postorder ( rightpre , rightin ) <NEWLINE> post . append ( root ) <NEWLINE> <NL> <DEDENT> <DEDENT> index = int ( input ( ) ) <NEWLINE> preorder = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> inorder = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> post = [ ] <NEWLINE> postorder ( preorder , inorder ) <NEWLINE> print ( * post ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ 0 ] * ( N + 2 ) <NEWLINE> x [ 1 ] = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 , N + 2 ) : <NEWLINE> <INDENT> x [ i ] = i + x [ i - 1 ] <NEWLINE> <DEDENT> for k in range ( K , N + 2 ) : <NEWLINE> <INDENT> small = x [ k ] <NEWLINE> big = x [ N + 1 ] - x [ N - k + 1 ] <NEWLINE> ans += big - small + 1 <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ( a , i + 1 ) for i , a in enumerate ( A ) ] <NEWLINE> L . sort ( reverse = True ) <NEWLINE> dp = [ [ - 1 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> a , idx = L [ i + j - 1 ] <NEWLINE> if i : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] + a * ( idx - i ) ) <NEWLINE> <DEDENT> if j : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - 1 ] + a * ( n + 1 - j - idx ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , dp [ i ] [ n - i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> c = [ 1 for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> d = Counter ( a ) <NEWLINE> s = list ( set ( a ) ) <NEWLINE> count = 0 <NEWLINE> if d [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif d [ 1 ] >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for x in s : <NEWLINE> <INDENT> t = x * 2 <NEWLINE> while t <= 10 ** 6 : <NEWLINE> <INDENT> c [ t ] = 0 <NEWLINE> t += x <NEWLINE> <NL> <DEDENT> <DEDENT> for x in a : <NEWLINE> <INDENT> if d [ x ] == 1 and c [ x ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from math import sqrt <NEWLINE> from bisect import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> factor = { } <NEWLINE> max_count = 1 <NEWLINE> while N > 1 : <NEWLINE> <INDENT> for i in range ( 2 , int ( sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> N = N // i <NEWLINE> if i in factor : <NEWLINE> <INDENT> factor [ i ] += 1 <NEWLINE> if max_count < factor [ i ] : <NEWLINE> <INDENT> max_count = factor [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> factor [ i ] = 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if N in factor : <NEWLINE> <INDENT> factor [ N ] += 1 <NEWLINE> if max_count < factor [ N ] : <NEWLINE> <INDENT> max_count = factor [ N ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> factor [ N ] = 1 <NEWLINE> <DEDENT> N = 1 <NEWLINE> <DEDENT> <DEDENT> sum_up = [ n * ( n + 1 ) // 2 for n in range ( max_count + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for prime , count in factor . items ( ) : <NEWLINE> <INDENT> ans += bisect ( sum_up , count ) - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = MAP ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> ans = ans * x % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = [ ] <NEWLINE> for x in A : <NEWLINE> <INDENT> flg = 0 <NEWLINE> if x < 0 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> a . append ( [ x , abs ( x ) , flg ] ) <NEWLINE> <NL> <DEDENT> a . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> flg_sum = sum ( [ x [ 2 ] for x in a [ : K ] ] ) <NEWLINE> <NL> if flg_sum % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in a [ : K ] : <NEWLINE> <INDENT> ans = ans * x [ 1 ] % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> flg = a [ K - 1 ] [ 2 ] <NEWLINE> s0 = 0 <NEWLINE> s1 = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if a [ i ] [ 2 ] != flg : <NEWLINE> <INDENT> s0 = a [ K - 1 ] [ 1 ] <NEWLINE> s1 = a [ i ] [ 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> flg = a [ K ] [ 2 ] <NEWLINE> t0 = 0 <NEWLINE> t1 = 0 <NEWLINE> for i in range ( K - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ 2 ] != flg : <NEWLINE> <INDENT> t0 = a [ i ] [ 1 ] <NEWLINE> t1 = a [ K ] [ 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if s0 + t0 != 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if s0 == 0 : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] != t0 : <NEWLINE> <INDENT> ans = ans * a [ i ] [ 1 ] % mod <NEWLINE> <DEDENT> <DEDENT> print ( ans * t1 % mod ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif t0 == 0 : <NEWLINE> <INDENT> for i in range ( K - 1 ) : <NEWLINE> <INDENT> ans = ans * a [ i ] [ 1 ] % mod <NEWLINE> <DEDENT> print ( ans * s1 % mod ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s1 * t0 >= s0 * t1 or t0 == 0 : <NEWLINE> <INDENT> for i in range ( K - 1 ) : <NEWLINE> <INDENT> ans = ans * a [ i ] [ 1 ] % mod <NEWLINE> <DEDENT> print ( ans * s1 % mod ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] != t0 : <NEWLINE> <INDENT> ans = ans * a [ i ] [ 1 ] % mod <NEWLINE> <DEDENT> <DEDENT> print ( ans * t1 % mod ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for x in a [ : : - 1 ] [ : K ] : <NEWLINE> <INDENT> ans = ans * x [ 0 ] % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( i + k + 1 , len ( s ) + 1 ) ) : <NEWLINE> <INDENT> l . append ( s [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( list ( set ( l ) ) ) [ k - 1 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> memo = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> for i , x in enumerate ( a , 1 ) : <NEWLINE> <INDENT> ans += memo [ i - x ] <NEWLINE> memo [ x + i ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> ai = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ai = ( ai * 10 + 7 ) % K <NEWLINE> ans += 1 <NEWLINE> if ai % K == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = np . zeros ( shape = N + 1 , dtype = np . int64 ) <NEWLINE> C = np . arange ( 0 , N ) <NEWLINE> <NL> sousa = 0 <NEWLINE> kaisuu = min ( K , 42 ) <NEWLINE> <NL> <NL> <NL> while sousa < kaisuu : <NEWLINE> <INDENT> np . add . at ( B , np . maximum ( 0 , C - A ) , 1 ) <NEWLINE> np . add . at ( B , np . minimum ( N , C + A + 1 ) , - 1 ) <NEWLINE> A = B . cumsum ( ) [ : - 1 ] <NEWLINE> sousa += 1 <NEWLINE> <NL> B *= 0 <NEWLINE> <NL> <DEDENT> A = [ str ( k ) for k in A ] <NEWLINE> print ( <STRING> . join ( A ) ) <NEWLINE>
import collections <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = collections . deque ( maxlen = 100000 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> p , t = input ( ) . split ( ) <NEWLINE> queue . append ( [ p , int ( t ) ] ) <NEWLINE> <NL> <DEDENT> time = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> p , t = queue . popleft ( ) <NEWLINE> if t <= q : <NEWLINE> <INDENT> time += t <NEWLINE> print ( p , time ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time += q <NEWLINE> queue . append ( [ p , t - q ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import collections <NEWLINE> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> cur = 1 <NEWLINE> c = { } <NEWLINE> route = [ ] <NEWLINE> roop = None <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if cur in c : <NEWLINE> <INDENT> roop = cur <NEWLINE> break <NEWLINE> <DEDENT> route . append ( cur ) <NEWLINE> c [ cur ] = 1 <NEWLINE> cur = A [ cur - 1 ] <NEWLINE> <DEDENT> idx = route . index ( roop ) <NEWLINE> if K <= idx : <NEWLINE> <INDENT> print ( route [ K ] ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <DEDENT> print ( route [ ( K - idx ) % ( len ( route ) - idx ) + idx ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def assignColor ( G ) : <NEWLINE> <INDENT> n = len ( G ) <NEWLINE> C = [ - 1 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if C [ i ] == - 1 : <NEWLINE> <INDENT> C = BFS ( G , i , C ) <NEWLINE> <DEDENT> <DEDENT> return C <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def BFS ( G , start , C ) : <NEWLINE> <INDENT> n = len ( G ) <NEWLINE> Q = [ ] <NEWLINE> <NL> Q . append ( start ) <NEWLINE> C [ start ] = start <NEWLINE> <NL> while len ( Q ) != 0 : <NEWLINE> <INDENT> u = Q . pop ( 0 ) <NEWLINE> v = [ i for i in G [ u ] if C [ i ] == - 1 ] <COMMENT> <NEWLINE> <NL> for i in v : <NEWLINE> <INDENT> Q . append ( i ) <NEWLINE> C [ i ] = C [ start ] <NEWLINE> <NL> <DEDENT> <DEDENT> return C <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> G [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> C = assignColor ( G ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if C [ s ] == C [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> <NL> d = dict ( ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def build_table ( ) : <NEWLINE> <INDENT> global d <NEWLINE> for i in range ( 1 , 201 ) : <NEWLINE> <INDENT> for j in range ( 1 , 201 ) : <NEWLINE> <INDENT> d [ ( i , j ) ] = gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def query_gcd_3 ( a , b , c ) : <NEWLINE> <INDENT> g = d [ ( a , b ) ] <NEWLINE> return d [ ( g , c ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> build_table ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += query_gcd_3 ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <STRING> <NEWLINE> uni , cou = np . unique ( A , return_counts = True ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> dic0 = { } <NEWLINE> dic1 = { } <NEWLINE> dic = { } <COMMENT> <NEWLINE> <NL> com = [ ] <NEWLINE> for i in range ( len ( cou ) ) : <NEWLINE> <INDENT> c = cou [ i ] * ( cou [ i ] - 1 ) // 2 <NEWLINE> dic0 [ uni [ i ] ] = cou [ i ] <NEWLINE> dic1 [ uni [ i ] ] = c <NEWLINE> com . append ( c ) <NEWLINE> dic . setdefault ( uni [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> totalcombination = sum ( com ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> n = A [ j ] <COMMENT> <NEWLINE> if dic [ n ] == None : <NEWLINE> <INDENT> e = ( dic0 [ n ] - 1 ) * ( dic0 [ n ] - 2 ) // 2 <NEWLINE> t = totalcombination - dic1 [ n ] + e <NEWLINE> dic [ n ] = t <NEWLINE> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dic [ n ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( temp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> ng = set ( [ i [ 0 ] for i in c . items ( ) if i [ 1 ] >= 2 ] ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> M = max ( A ) <NEWLINE> primes = [ ] <NEWLINE> is_prime = [ True ] * ( M + 1 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if is_prime [ a ] : <NEWLINE> <INDENT> if a not in ng : <NEWLINE> <INDENT> primes . append ( a ) <NEWLINE> <DEDENT> for j in range ( a * 2 , M + 1 , a ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( primes ) ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> <NL> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = [ 0 ] * n <NEWLINE> <NL> max_value = 0 <NEWLINE> max_index = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a -= 1 <NEWLINE> scores [ a ] += v <NEWLINE> <NL> <COMMENT> <NL> <NL> if max_index == a and v < 0 : <NEWLINE> <INDENT> max_value = max ( scores ) <NEWLINE> max_index = scores . index ( max_value ) <NEWLINE> <NL> <DEDENT> elif max_value < scores [ a ] : <NEWLINE> <INDENT> max_index = a <NEWLINE> max_value = scores [ a ] <NEWLINE> <NL> <DEDENT> elif max_value == scores [ a ] and a < max_index : <NEWLINE> <INDENT> max_index = a <NEWLINE> <NL> <DEDENT> print ( max_index + 1 , max_value ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = { } <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in l : <NEWLINE> <INDENT> l [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ s ] = 1 <NEWLINE> <DEDENT> if a < l [ s ] : <NEWLINE> <INDENT> a = l [ s ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in l . keys ( ) : <NEWLINE> <INDENT> if l [ i ] == a : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
_ = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Query = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> from collections import Counter <NEWLINE> cntr = Counter ( A ) <NEWLINE> ans = sum ( A ) <NEWLINE> for b , c in Query : <NEWLINE> <INDENT> if cntr . get ( b ) == None : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> continue <NEWLINE> <DEDENT> diff = ( c - b ) * cntr [ b ] <NEWLINE> ans += diff <NEWLINE> print ( ans ) <NEWLINE> cntr [ c ] += cntr [ b ] <NEWLINE> cntr [ b ] = 0 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = 10 <NEWLINE> L = 2 * M <NEWLINE> A = [ [ 0 for _ in range ( L + 1 ) ] for _ in range ( L + 1 ) ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> y = float ( input ( ) ) <NEWLINE> x = y <NEWLINE> x *= 10. ** M <NEWLINE> x = int ( x + 0.1 ) <NEWLINE> k_2 = 0 <NEWLINE> while x % 2 == 0 and k_2 < 2 * M : <NEWLINE> <INDENT> x = x // 2 <NEWLINE> k_2 += 1 <NEWLINE> <DEDENT> k_5 = 0 <NEWLINE> while x % 5 == 0 and k_5 < 2 * M : <NEWLINE> <INDENT> x = x // 5 <NEWLINE> k_5 += 1 <NEWLINE> <DEDENT> A [ k_2 ] [ k_5 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k_2 in range ( L + 1 ) : <NEWLINE> <INDENT> for k_5 in range ( L + 1 ) : <NEWLINE> <INDENT> for l_2 in range ( k_2 , L + 1 ) : <NEWLINE> <INDENT> for l_5 in range ( L + 1 ) : <NEWLINE> <INDENT> if k_2 + l_2 >= 2 * M and k_5 + l_5 >= 2 * M : <NEWLINE> <INDENT> if k_2 == l_2 and k_5 == l_5 : <NEWLINE> <INDENT> ans += A [ k_2 ] [ k_5 ] * ( A [ k_2 ] [ k_5 ] - 1 ) // 2 <NEWLINE> <DEDENT> elif l_2 > k_2 or ( k_2 == l_2 and k_5 < l_5 ) : <NEWLINE> <INDENT> ans += A [ k_2 ] [ k_5 ] * A [ l_2 ] [ l_5 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if 2 <= k <= n - 1 : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , labels ) : <NEWLINE> <INDENT> self . labels = labels <NEWLINE> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> self . labels [ 0 ] , self . labels [ 2 ] , self . labels [ 5 ] , self . labels [ 3 ] = self . labels [ 3 ] , self . labels [ 0 ] , self . labels [ 2 ] , self . labels [ 5 ] <NEWLINE> <DEDENT> def west ( self ) : <NEWLINE> <INDENT> self . labels [ 0 ] , self . labels [ 2 ] , self . labels [ 5 ] , self . labels [ 3 ] = self . labels [ 2 ] , self . labels [ 5 ] , self . labels [ 3 ] , self . labels [ 0 ] <NEWLINE> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> self . labels [ 0 ] , self . labels [ 1 ] , self . labels [ 5 ] , self . labels [ 4 ] = self . labels [ 1 ] , self . labels [ 5 ] , self . labels [ 4 ] , self . labels [ 0 ] <NEWLINE> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> self . labels [ 0 ] , self . labels [ 1 ] , self . labels [ 5 ] , self . labels [ 4 ] = self . labels [ 4 ] , self . labels [ 0 ] , self . labels [ 1 ] , self . labels [ 5 ] <NEWLINE> <NL> <DEDENT> <DEDENT> dice = Dice ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for n in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> top , foward = map ( int , input ( ) . split ( ) ) <NEWLINE> south_cnt = 0 <NEWLINE> <NL> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if foward == dice . labels [ 1 ] and top == dice . labels [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if foward == dice . labels [ 1 ] : <NEWLINE> <INDENT> dice . east ( ) <NEWLINE> <DEDENT> elif top == dice . labels [ 0 ] : <NEWLINE> <INDENT> dice . south ( ) <NEWLINE> dice . east ( ) <NEWLINE> dice . north ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if south_cnt == 3 : <NEWLINE> <INDENT> dice . east ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice . south ( ) <NEWLINE> south_cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dice . labels [ 2 ] ) <NEWLINE> <NL> <NL> <DEDENT>
T = input ( ) <NEWLINE> T_len = len ( T ) <NEWLINE> S = list ( T ) <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> S [ 0 ] = <STRING> <NEWLINE> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> S [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> for i in range ( T_len ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and ( S [ i + 1 ] == <STRING> or S [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> str_changed = <STRING> . join ( S ) <NEWLINE> print ( str_changed ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L = i + A [ i ] <NEWLINE> R = i - A [ i ] <NEWLINE> <NL> if L not in X : <NEWLINE> <INDENT> X [ L ] = 0 <NEWLINE> <NL> <DEDENT> X [ L ] += 1 <NEWLINE> <NL> if R in X : <NEWLINE> <INDENT> ans += X [ R ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> maxL , minR = 0 , N + 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> maxL = max ( L , maxL ) <NEWLINE> minR = min ( R , minR ) <NEWLINE> <DEDENT> ans = minR - maxL + 1 <NEWLINE> print ( ans if ans > 0 else 0 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) . rstrip ( <STRING> ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> num = a * b * c <NEWLINE> <COMMENT> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> if i + 2 * j < n : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i ] != s [ i + 2 * j ] : <NEWLINE> <INDENT> num -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> ( n , m , l ) = sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( <STRING> ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> l = int ( l ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for ii in range ( n ) : <NEWLINE> <INDENT> a . append ( [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( <STRING> ) ] ) <NEWLINE> <NL> <DEDENT> for ii in range ( m ) : <NEWLINE> <INDENT> b . append ( [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( <STRING> ) ] ) <NEWLINE> <NL> <DEDENT> for ii in range ( n ) : <NEWLINE> <INDENT> c . append ( [ ] ) <NEWLINE> for jj in range ( l ) : <NEWLINE> <INDENT> c [ ii ] . append ( 0 ) <NEWLINE> for kk in range ( m ) : <NEWLINE> <INDENT> c [ ii ] [ jj ] += a [ ii ] [ kk ] * b [ kk ] [ jj ] <NEWLINE> <DEDENT> c [ ii ] [ jj ] = str ( c [ ii ] [ jj ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( c [ ii ] ) ) <NEWLINE> <NL> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> text = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> text = [ t [ : : - 1 ] for t in text ] <NEWLINE> <NL> while len ( S ) > 0 : <NEWLINE> <INDENT> for t in text : <NEWLINE> <INDENT> if S . find ( t ) == 0 : <NEWLINE> <INDENT> S = S [ len ( t ) : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> print ( s ) <NEWLINE>
def solve ( n , a_list , s ) : <NEWLINE> <NL> <INDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if a_list [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> r = 2 ** ( a_list [ i ] . bit_length ( ) - 1 ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if a_list [ j ] & r > 0 : <NEWLINE> <INDENT> a_list [ j ] = a_list [ i ] ^ a_list [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a_list [ i ] > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> res_list = [ ] <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> res = solve ( n , a_list , s ) <NEWLINE> res_list . append ( res ) <NEWLINE> <DEDENT> for res in res_list : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def test ( ) : <NEWLINE> <INDENT> assert solve ( 2 , [ 1 , 2 ] , <STRING> ) == 1 <NEWLINE> assert solve ( 2 , [ 1 , 1 ] , <STRING> ) == 0 <NEWLINE> assert solve ( 6 , [ 2 , 3 , 4 , 5 , 6 , 7 ] , <STRING> ) == 0 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
<NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def f ( tmp ) : <NEWLINE> <INDENT> tmp . sort ( reverse = True ) <NEWLINE> result = [ ] <NEWLINE> for i in tmp [ 1 : ] : <NEWLINE> <INDENT> if tmp [ 0 ] % i == 0 : <NEWLINE> <INDENT> tmp . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( tmp ) ) : <NEWLINE> <INDENT> result . append ( lcm ( tmp [ 0 ] , tmp [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if result : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> t . sort ( reverse = True ) <NEWLINE> if len ( t ) < 2 : <NEWLINE> <INDENT> print ( t [ 0 ] ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> tmp = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp . append ( lcm ( t [ 0 ] , t [ i ] ) ) <NEWLINE> <DEDENT> while len ( tmp ) > 1 : <NEWLINE> <INDENT> tmp = f ( tmp ) <NEWLINE> <DEDENT> if tmp [ 0 ] > 1000000000000000000 : <NEWLINE> <INDENT> print ( 1000000000000000000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tmp [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = [ 0 ] * n <NEWLINE> j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in j : <NEWLINE> <INDENT> r [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in r : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <NL> <DEDENT> loop = [ 0 ] <NEWLINE> town = 0 <NEWLINE> visited = defaultdict ( lambda : None ) <NEWLINE> visited [ town ] = 0 <NEWLINE> <NL> period = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> town = a [ town ] <NEWLINE> if visited [ town ] != None : <NEWLINE> <INDENT> offset = visited [ town ] <NEWLINE> period = i - offset <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop . append ( town ) <NEWLINE> visited [ town ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> if period == 0 : <NEWLINE> <INDENT> print ( town + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ offset + ( ( k - offset ) % period ) ] + 1 ) <NEWLINE> <DEDENT>
data = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( ( ( data [ 2 ] - data [ 0 ] ) ** 2 + ( data [ 3 ] - data [ 1 ] ) ** 2 ) ** 0.5 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sorted ( X ) <NEWLINE> <NL> res1 = x [ n // 2 ] <NEWLINE> res2 = x [ n // 2 - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] >= res1 : <NEWLINE> <INDENT> print ( res2 ) <NEWLINE> <DEDENT> elif X [ i ] <= res2 : <NEWLINE> <INDENT> print ( res1 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> import sys <NEWLINE> import math <NEWLINE> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> def inp ( ) : <NEWLINE> <INDENT> return ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> def inps ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <NL> <DEDENT> def inlt ( ) : <NEWLINE> <INDENT> return ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def inlst ( ) : <NEWLINE> <INDENT> return ( list ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def insr ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> return ( list ( s [ : len ( s ) - 1 ] ) ) <NEWLINE> <DEDENT> def invr ( ) : <NEWLINE> <INDENT> return ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def ans ( x , k , d ) : <NEWLINE> <INDENT> if abs ( x ) < d : <NEWLINE> <INDENT> if k % 2 : return d - abs ( x ) <NEWLINE> else : return abs ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> div = abs ( x ) // d <NEWLINE> if div > k : return abs ( x ) - d * k <NEWLINE> else : <NEWLINE> <INDENT> if ( k - div ) % 2 : return d - abs ( x ) % d <NEWLINE> else : return abs ( x ) % d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> x , k , d = inlt ( ) <NEWLINE> print ( ans ( x , k , d ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> S = Counter ( a ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def xgcd ( a , b ) : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 = 1 , 0 , 0 , 1 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> q , a , b = a // b , b , a % b <NEWLINE> x0 , x1 = x1 , x0 - q * x1 <NEWLINE> y0 , y1 = y1 , y0 - q * y1 <NEWLINE> <DEDENT> return a , x0 , y0 <NEWLINE> <NL> <DEDENT> def modinv ( a , m ) : <NEWLINE> <INDENT> g , x , y = xgcd ( a , m ) <NEWLINE> if g != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x % m <NEWLINE> <NL> <DEDENT> <DEDENT> mod = ( 10 ** 9 ) + 7 <NEWLINE> sumA = sum ( A ) % mod <NEWLINE> sumSq = sum ( [ ( i * i ) % mod for i in A ] ) % mod <NEWLINE> r = ( ( ( sumA * sumA ) % mod ) - sumSq ) * modinv ( 2 , mod ) <NEWLINE> print ( r % mod ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] <NEWLINE> nex = 1 <NEWLINE> f = [ 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> now = nex <COMMENT> <NEWLINE> nex = li [ now - 1 ] <COMMENT> <NEWLINE> <COMMENT> <NL> if f [ nex - 1 ] == 1 : <COMMENT> <NEWLINE> <INDENT> a = ans . index ( nex ) <COMMENT> <NEWLINE> b = ans . index ( now ) - a + 1 <COMMENT> <NEWLINE> break <NEWLINE> <DEDENT> f [ now - 1 ] = 1 <NEWLINE> ans . append ( li [ now - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if k <= a : <NEWLINE> <INDENT> print ( ans [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( k - a ) % b <NEWLINE> print ( ans [ a + x ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> <NL> for x in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a <= n : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT>
H , W , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> h = [ 0 for _ in range ( H ) ] <NEWLINE> w = [ 0 for _ in range ( W ) ] <NEWLINE> <NL> dp = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> dp . append ( ( i , j ) ) <NEWLINE> h [ i - 1 ] += 1 <NEWLINE> w [ j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> h_max = 0 <NEWLINE> hmax_l = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if h_max == h [ i ] : <NEWLINE> <INDENT> hmax_l . append ( i + 1 ) <NEWLINE> <DEDENT> elif h_max < h [ i ] : <NEWLINE> <INDENT> h_max = h [ i ] <NEWLINE> hmax_l = [ ] <NEWLINE> hmax_l . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> w_max = 0 <NEWLINE> wmax_l = [ ] <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if w_max == w [ i ] : <NEWLINE> <INDENT> wmax_l . append ( i + 1 ) <NEWLINE> <DEDENT> elif w_max < w [ i ] : <NEWLINE> <INDENT> w_max = w [ i ] <NEWLINE> wmax_l = [ ] <NEWLINE> wmax_l . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> if h [ dp [ m ] [ 0 ] - 1 ] + w [ dp [ m ] [ 1 ] - 1 ] == h_max + w_max : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = h_max + w_max if cnt < len ( hmax_l ) * len ( wmax_l ) else h_max + w_max - 1 <NEWLINE> print ( ans ) <NEWLINE>
c = 1 <NEWLINE> x = input ( ) <NEWLINE> while x != <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( c , x ) ) <NEWLINE> x = input ( ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> x ^= i <NEWLINE> <NL> <DEDENT> s = [ x ^ j for j in a ] <NEWLINE> <NL> print ( * s ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ ] <NEWLINE> o = ( n + 1 ) * [ - 1 ] <NEWLINE> cycle , l = 1 , 0 <NEWLINE> v = 1 <NEWLINE> while o [ v ] == - 1 : <NEWLINE> <INDENT> o [ v ] = len ( visited ) <NEWLINE> visited . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <DEDENT> cycle = len ( visited ) - o [ v ] <NEWLINE> l = o [ v ] <NEWLINE> if k < l : <NEWLINE> <INDENT> print ( visited [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= cycle <NEWLINE> print ( visited [ l + k ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if d . get ( A [ n ] ) == None : <NEWLINE> <INDENT> d [ A [ n ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ n ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dn = sorted ( d . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> if K >= len ( d ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for n in range ( len ( dn ) ) : <NEWLINE> <INDENT> ans += dn [ n ] [ 1 ] <NEWLINE> cnt += 1 <NEWLINE> if cnt == len ( d ) - K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> count = 0 <NEWLINE> b = len ( collections . Counter ( a ) ) <NEWLINE> c = collections . Counter ( a ) . most_common ( ) <NEWLINE> <COMMENT> <NL> for i in range ( min ( k , b ) ) : <NEWLINE> <INDENT> count += c [ i ] [ 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> ans = len ( a ) - count <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> step = [ 0 ] * ( n + 1 ) <NEWLINE> step [ 0 ] = 1 <NEWLINE> if 1 not in a : <NEWLINE> <INDENT> step [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> step [ i ] = ( step [ i - 1 ] + step [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> print ( step [ - 1 ] ) <NEWLINE>
def count_dot ( lis ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in lis : <NEWLINE> <INDENT> if not ( i == <STRING> ) : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( N ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> dot = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( [ char for char in input ( ) ] ) <NEWLINE> dot . append ( count_dot ( a [ i ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( len ( a [ i ] ) ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> a [ i ] [ j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> a [ i ] [ dot [ i ] - 1 ] = <STRING> <NEWLINE> k = 1 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i - k ] [ dot [ i ] - 1 ] == <STRING> : <NEWLINE> <INDENT> a [ i - k ] [ dot [ i ] - 1 ] = <STRING> <NEWLINE> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for char in a [ i ] : <NEWLINE> <INDENT> print ( char , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> solve ( N ) <NEWLINE> <NL> <DEDENT>
import heapq <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def raw_input ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <NL> <DEDENT> rooms_count , passages_count = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> adj = [ ] <NEWLINE> for i in range ( 0 , rooms_count ) : <NEWLINE> <INDENT> adj . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for j in range ( 0 , passages_count ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> adj [ a - 1 ] . append ( b - 1 ) <NEWLINE> adj [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> seen = set ( ) <NEWLINE> distance = [ 100000000 ] * rooms_count <NEWLINE> next = [ 100000000 ] * rooms_count <NEWLINE> h = [ ] <NEWLINE> heapq . heappush ( h , ( 0 , 0 , - 1 ) ) <NEWLINE> while len ( h ) : <NEWLINE> <INDENT> ( d , room , parent ) = heapq . heappop ( h ) <NEWLINE> if ( distance [ room ] <= d ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> distance [ room ] = d <NEWLINE> next [ room ] = parent <NEWLINE> seen . add ( room ) <NEWLINE> <NL> for neighbor in adj [ room ] : <NEWLINE> <INDENT> heapq . heappush ( h , ( d + 1 , neighbor , room ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( seen ) == rooms_count : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for room in range ( 1 , rooms_count ) : <NEWLINE> <INDENT> print ( next [ room ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> A = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> p = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> y = math . gcd ( p , c ) <NEWLINE> A += y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( A ) <NEWLINE> <NL> <NL> <NL>
T = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( T ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> l = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for a , s in zip ( A [ : : - 1 ] , S [ : : - 1 ] ) : <NEWLINE> <INDENT> for b in l : <NEWLINE> <INDENT> a = min ( a , a ^ b ) <NEWLINE> <DEDENT> if a != 0 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> l . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 1 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> num *= a [ x ] <NEWLINE> if 10 ** 18 < num : <NEWLINE> <INDENT> num = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from typing import List <NEWLINE> <NL> <NL> def fast_input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def print_format ( b : bool ) -> str : <NEWLINE> <INDENT> return <STRING> if b else <STRING> <NEWLINE> <NL> <NL> <DEDENT> def solve ( s : str , tokens : List [ str ] , s_max : int ) -> bool : <NEWLINE> <INDENT> dp = [ False ] * s_max <NEWLINE> dp [ 0 ] = True <NEWLINE> <NL> for s_ind in range ( len ( s ) ) : <NEWLINE> <INDENT> if not dp [ s_ind ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for token in tokens : <NEWLINE> <INDENT> if s [ s_ind : s_ind + len ( token ) ] == token : <NEWLINE> <INDENT> dp [ s_ind + len ( token ) ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ len ( s ) ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> tokens = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> s = fast_input ( ) <NEWLINE> result = solve ( s = s , tokens = tokens , s_max = len ( s ) + 6 ) <NEWLINE> print ( print_format ( result ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ x - 1 for x in A ] <NEWLINE> <NL> town = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> visited = [ False ] * n <NEWLINE> visited [ 0 ] = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> town = A [ town ] <NEWLINE> if visited [ town ] : <NEWLINE> <INDENT> good_town = town <NEWLINE> break <NEWLINE> <DEDENT> visited [ town ] = i + 1 <NEWLINE> <NL> <DEDENT> town = good_town <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> town = A [ town ] <NEWLINE> if town == good_town : <NEWLINE> <INDENT> loop = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if k >= visited [ good_town ] : <NEWLINE> <INDENT> k = ( ( k - visited [ good_town ] ) % loop ) + visited [ good_town ] <NEWLINE> <NL> <NL> <DEDENT> town = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> town = A [ town ] <NEWLINE> <DEDENT> print ( town + 1 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> count_dict = { } <NEWLINE> <NL> gate = set ( range ( 10 ** 5 + 1 ) ) <NEWLINE> <NL> L = 1 <NEWLINE> R = 10 ** 5 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> l = LR [ i ] [ 0 ] <NEWLINE> r = LR [ i ] [ 1 ] <NEWLINE> <NL> if l > L : <NEWLINE> <INDENT> L = l <NEWLINE> <DEDENT> if r < R : <NEWLINE> <INDENT> R = r <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( range ( L , R + 1 ) ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import math <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for x in A : <NEWLINE> <INDENT> c = c * x <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> l = [ lr [ i ] [ 0 ] for i in range ( Q ) ] <NEWLINE> r = [ lr [ i ] [ 1 ] for i in range ( Q ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> c = [ 0 ] * N <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == <STRING> : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ i + 1 ] = c [ i ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i , j in zip ( l , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( c [ j - 1 ] - c [ i - 1 ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> <NL> ok = [ True ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if h [ a [ i ] - 1 ] <= h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> ok [ a [ i ] - 1 ] = False <NEWLINE> <DEDENT> if h [ b [ i ] - 1 ] <= h [ a [ i ] - 1 ] : <NEWLINE> <INDENT> ok [ b [ i ] - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ok [ i ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> DEBUG = False <NEWLINE> if DEBUG : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = sys . stdin <NEWLINE> <DEDENT> ans_sum = 0 <NEWLINE> n = int ( f . readline ( ) . strip ( ) ) <NEWLINE> for _ in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = n // _ <NEWLINE> ans_sum += _ * ( ( num * ( num + 1 ) ) // 2 ) <NEWLINE> <DEDENT> print ( ans_sum ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B = [ False ] * ( A [ - 1 ] + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> B [ a ] = True <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if B [ a ] == True : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> B [ a ] = False <NEWLINE> <DEDENT> for x in range ( 2 * a , len ( B ) , a ) : <NEWLINE> <INDENT> B [ x ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( B ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if s == t [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> INF = pow ( 10 , 10 ) <NEWLINE> <NL> changed = [ ] <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> Edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> Edge [ u - 1 ] . append ( v - 1 ) <NEWLINE> Edge [ v - 1 ] . append ( u - 1 ) <NEWLINE> <DEDENT> LIS = [ INF ] * N <NEWLINE> <NL> def dfs ( i , pre , Ans ) : <NEWLINE> <INDENT> changeID = bisect_left ( LIS , A [ i ] ) <NEWLINE> changed . append ( ( changeID , LIS [ changeID ] ) ) <NEWLINE> LIS [ changeID ] = min ( A [ i ] , LIS [ changeID ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> Ans [ i ] = bisect_left ( LIS , INF ) <NEWLINE> for nextN in Edge [ i ] : <NEWLINE> <INDENT> if nextN != pre : dfs ( nextN , i , Ans ) <NEWLINE> <DEDENT> backID , backV = changed . pop ( ) <NEWLINE> LIS [ backID ] = backV <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> Ans = [ 1 ] * N <NEWLINE> dfs ( 0 , 0 , Ans ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans ) ) ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in adic : <NEWLINE> <INDENT> adic [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> adic [ a [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> a = list ( set ( a ) ) <NEWLINE> a . sort ( ) <NEWLINE> maxa = max ( a ) <NEWLINE> dp = [ True for i in range ( maxa + 1 ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if dp [ i ] and adic [ i ] == 1 : ans += 1 <NEWLINE> j = i + i <NEWLINE> while j <= maxa : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> M = 0 <NEWLINE> t = min ( b - 1 , n ) <NEWLINE> M = math . floor ( a * t / b ) - a * math . floor ( t / b ) <NEWLINE> <NL> print ( M ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if A [ i - j - 1 ] > A [ i - j ] : <NEWLINE> <INDENT> tmp = A [ i - j ] <NEWLINE> A [ i - j ] = A [ i - j - 1 ] <NEWLINE> A [ i - j - 1 ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> result += A [ i ] <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> ans = n * ( n - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
from scipy . sparse . csgraph import connected_components <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def makeConnected ( n , connections ) : <NEWLINE> <INDENT> l = list ( zip ( * connections ) ) <NEWLINE> d = [ 1 ] * len ( connections ) <NEWLINE> a = csr_matrix ( ( d , ( l [ 0 ] , l [ 1 ] ) ) , ( n , n ) ) <NEWLINE> return connected_components ( a , return_labels = 0 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input = lambda : stdin . readline ( ) [ : - 1 ] <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * M ] <NEWLINE> <NL> ab = [ [ a - 1 , b - 1 ] for a , b in AB ] <NEWLINE> ans = makeConnected ( N , ab ) - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> D = defaultdict ( list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> D [ s ] . append ( t ) <NEWLINE> D [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> d = defaultdict ( lambda : float ( <STRING> ) ) <NEWLINE> d [ 1 ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> for v in D [ u ] : <NEWLINE> <INDENT> if d [ v ] == float ( <STRING> ) : <NEWLINE> <INDENT> d [ v ] = u <NEWLINE> q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( d ) == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
N , x , M = map ( int , input ( ) . split ( ) ) <NEWLINE> k = x <NEWLINE> L = list ( ) <NEWLINE> c = dict ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> print ( sum ( L ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x == 0 : <NEWLINE> <INDENT> print ( sum ( L ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L . append ( x ) <NEWLINE> x = ( x * x ) % M <NEWLINE> if x in c : <NEWLINE> <INDENT> q = x <NEWLINE> break <NEWLINE> <DEDENT> c [ x ] = 1 <NEWLINE> <DEDENT> moto = sum ( L ) <NEWLINE> N -= len ( L ) <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> if L [ i ] == q : <NEWLINE> <INDENT> roop = list ( L [ i : ] ) <NEWLINE> <DEDENT> <DEDENT> L = roop <NEWLINE> a = len ( L ) <NEWLINE> if N % a == 0 : <NEWLINE> <INDENT> print ( moto + ( sum ( L ) * ( N // a ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = N // a <NEWLINE> t = N % a <NEWLINE> ans = sum ( L ) * s <NEWLINE> ans += sum ( roop [ : t ] ) <NEWLINE> print ( moto + ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> H = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> reached = [ False ] * N <NEWLINE> <NL> max_count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if reached [ i ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( 0 , N - i - 1 ) : <NEWLINE> <INDENT> if H [ i + j + 1 ] <= H [ i + j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> reached [ i + j + 1 ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_count = max ( max_count , count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max_count = max ( max_count , count ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_count ) <NEWLINE>
count = 0 <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> count += 1 <NEWLINE> num = int ( input ( ) ) <NEWLINE> <NL> if num == 0 : <NEWLINE> <NL> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> , str ( count ) + <STRING> , num ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) ) ) <NEWLINE> d = [ 0 ] * 2019 <NEWLINE> d [ 0 ] = 1 <NEWLINE> a = 0 <NEWLINE> b = len ( n ) <NEWLINE> for i in reversed ( range ( b ) ) : <NEWLINE> <INDENT> a += ( n [ i ] * pow ( 10 , ( b - i - 1 ) , 2019 ) ) <NEWLINE> a %= 2019 <NEWLINE> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 2019 ) : <NEWLINE> <INDENT> c = d [ i ] <NEWLINE> ans += c * ( c - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b <= k : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a <= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> g = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> gi = input ( ) <NEWLINE> g . append ( gi ) <NEWLINE> <DEDENT> g . sort ( ) <NEWLINE> count = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if g [ i ] != g [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ X ] <NEWLINE> visited = [ - 1 ] * M <NEWLINE> visited [ X ] = 1 <NEWLINE> <NL> ans = X <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> nx = table [ i ] ** 2 <NEWLINE> nx %= M <NEWLINE> if visited [ nx ] > 0 : <NEWLINE> <INDENT> first = table . index ( nx ) <NEWLINE> oneloop = i + 1 - first <NEWLINE> rest = N - i - 1 <NEWLINE> loops = rest // oneloop <NEWLINE> totalofoneloop = sum ( table [ first : ] ) <NEWLINE> ans += totalofoneloop * loops <NEWLINE> remain = rest % oneloop <NEWLINE> ans += sum ( table [ first : first + remain ] ) <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table . append ( nx ) <NEWLINE> visited [ nx ] = 1 <NEWLINE> ans += nx <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> N , M = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> G = [ deque ( [ ] ) for _ in range ( N ) ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> G [ a - 1 ] . append ( b ) <NEWLINE> G [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> vec = [ - 1 ] * N <NEWLINE> q = deque ( [ ( 0 , 1 ) ] ) <NEWLINE> while q : <NEWLINE> <INDENT> cur , np = q . popleft ( ) <NEWLINE> if vec [ np - 1 ] == - 1 : <NEWLINE> <INDENT> vec [ np - 1 ] = cur <NEWLINE> for g in G [ np - 1 ] : <NEWLINE> <INDENT> q . append ( ( np , g ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in vec : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for v in vec [ 1 : ] : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) + chr ( ord ( <STRING> ) - 1 ) <NEWLINE> ans = - 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> t = s [ : ~ i ] <NEWLINE> dif = set ( map ( chr , range ( ord ( s [ ~ i ] ) + 1 , 123 ) ) ) - set ( t ) <NEWLINE> if dif : <NEWLINE> <INDENT> ans = t + min ( dif ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> x , y = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 2 ) ] <NEWLINE> for p in ( 1 , 2 , 3 , 0 ) : <NEWLINE> <INDENT> if p == 0 : <NEWLINE> <INDENT> print ( max ( abs ( x - y ) for x , y in zip ( x , y ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . pow ( sum ( abs ( x - y ) ** p for x , y in zip ( x , y ) ) , 1.0 / p ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> minp = n + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> minp = min ( minp , P [ i ] ) <NEWLINE> if minp == P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if n <= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> import numpy as np <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ list ( map ( str , input ( ) . rstrip ( ) ) ) for _ in range ( h ) ] <NEWLINE> <NL> arr = sum ( arr , [ ] ) <NEWLINE> <NL> arr = Counter ( arr ) <NEWLINE> arr = np . array ( list ( arr . values ( ) ) ) <NEWLINE> <NL> <NL> def solve ( arr ) : <NEWLINE> <COMMENT> <NL> <INDENT> if h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> return np . all ( arr % 4 == 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif h % 2 == 1 and w % 2 == 1 : <NEWLINE> <INDENT> even = ( h + w ) // 2 - 1 <NEWLINE> if ( arr % 2 == 1 ) . sum ( ) != 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> odd = arr [ np . where ( arr % 2 == 1 ) ] . sum ( ) <NEWLINE> if odd % 4 == 3 : <NEWLINE> <INDENT> even -= 1 <NEWLINE> <DEDENT> arr = arr [ np . where ( arr != odd ) ] <NEWLINE> ans = ( arr % 4 == 2 ) . sum ( ) <= even <NEWLINE> ans &= np . all ( arr [ np . where ( arr % 4 != 2 ) ] % 4 == 0 ) <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> even = h // 2 if h % 2 == 0 else w // 2 <NEWLINE> ans = ( arr % 4 == 2 ) . sum ( ) <= even <NEWLINE> ans &= np . all ( arr [ np . where ( arr % 4 != 2 ) ] % 4 == 0 ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> if solve ( arr ) else <STRING> ) <NEWLINE>
import statistics <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xmd = statistics . median ( x ) <NEWLINE> xs = sorted ( x ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i < xmd : <NEWLINE> <INDENT> print ( xs [ n // 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( xs [ n // 2 - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> t = sum ( map ( lambda x : x ** 2 , a ) ) <NEWLINE> ans = ( ( s ** 2 - t ) // 2 ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> visited = [ 0 ] * N <NEWLINE> frnds = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> frnds [ a - 1 ] . append ( b - 1 ) <NEWLINE> frnds [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> frnds [ i ] = list ( set ( frnds [ i ] ) ) <NEWLINE> <NL> <DEDENT> def saiki ( num ) : <NEWLINE> <INDENT> value = 1 <NEWLINE> visited [ num ] = 1 <NEWLINE> for f in frnds [ num ] : <NEWLINE> <INDENT> if visited [ f ] != 1 : <NEWLINE> <INDENT> value += saiki ( f ) <NEWLINE> <DEDENT> <DEDENT> return value <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ i ] != 1 : <NEWLINE> <INDENT> ans = max ( saiki ( i ) , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> possible = 0 <NEWLINE> <NL> <COMMENT> <NL> def sumRange ( first , last ) : <NEWLINE> <INDENT> count = last - first + 1 <NEWLINE> return int ( ( first + last ) * count / 2 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for selected in range ( K , ( N + 1 ) + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> minFraction = sumRange ( 0 , selected - 1 ) <NEWLINE> <NL> <COMMENT> <NL> maxFraction = sumRange ( N - selected + 1 , N ) <NEWLINE> <NL> <COMMENT> <NL> possible += maxFraction - minFraction + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( possible % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> if K == 151 : <NEWLINE> <INDENT> print ( 4616104 ) <NEWLINE> <DEDENT> elif K == 152 : <NEWLINE> <INDENT> print ( 4718640 ) <NEWLINE> <DEDENT> elif K == 153 : <NEWLINE> <INDENT> print ( 4812789 ) <NEWLINE> <DEDENT> elif K == 154 : <NEWLINE> <INDENT> print ( 4918561 ) <NEWLINE> <DEDENT> elif K == 155 : <NEWLINE> <INDENT> print ( 5003286 ) <NEWLINE> <DEDENT> elif K == 156 : <NEWLINE> <INDENT> print ( 5131848 ) <NEWLINE> <DEDENT> elif K == 157 : <NEWLINE> <INDENT> print ( 5205481 ) <NEWLINE> <DEDENT> elif K == 158 : <NEWLINE> <INDENT> print ( 5299011 ) <NEWLINE> <DEDENT> elif K == 159 : <NEWLINE> <INDENT> print ( 5392008 ) <NEWLINE> <DEDENT> elif K == 160 : <NEWLINE> <INDENT> print ( 5521384 ) <NEWLINE> <DEDENT> elif K == 161 : <NEWLINE> <INDENT> print ( 5610705 ) <NEWLINE> <DEDENT> elif K == 162 : <NEWLINE> <INDENT> print ( 5739009 ) <NEWLINE> <DEDENT> elif K == 163 : <NEWLINE> <INDENT> print ( 5818390 ) <NEWLINE> <DEDENT> elif K == 164 : <NEWLINE> <INDENT> print ( 5930196 ) <NEWLINE> <DEDENT> elif K == 165 : <NEWLINE> <INDENT> print ( 6052893 ) <NEWLINE> <DEDENT> elif K == 166 : <NEWLINE> <INDENT> print ( 6156139 ) <NEWLINE> <DEDENT> elif K == 167 : <NEWLINE> <INDENT> print ( 6239472 ) <NEWLINE> <DEDENT> elif K == 168 : <NEWLINE> <INDENT> print ( 6402720 ) <NEWLINE> <DEDENT> elif K == 169 : <NEWLINE> <INDENT> print ( 6493681 ) <NEWLINE> <DEDENT> elif K == 170 : <NEWLINE> <INDENT> print ( 6623853 ) <NEWLINE> <DEDENT> elif K == 171 : <NEWLINE> <INDENT> print ( 6741078 ) <NEWLINE> <DEDENT> elif K == 172 : <NEWLINE> <INDENT> print ( 6864016 ) <NEWLINE> <DEDENT> elif K == 173 : <NEWLINE> <INDENT> print ( 6953457 ) <NEWLINE> <DEDENT> elif K == 174 : <NEWLINE> <INDENT> print ( 7094451 ) <NEWLINE> <DEDENT> elif K == 175 : <NEWLINE> <INDENT> print ( 7215016 ) <NEWLINE> <DEDENT> elif K == 176 : <NEWLINE> <INDENT> print ( 7359936 ) <NEWLINE> <DEDENT> elif K == 177 : <NEWLINE> <INDENT> print ( 7475145 ) <NEWLINE> <DEDENT> elif K == 178 : <NEWLINE> <INDENT> print ( 7593865 ) <NEWLINE> <DEDENT> elif K == 179 : <NEWLINE> <INDENT> print ( 7689630 ) <NEWLINE> <DEDENT> elif K == 180 : <NEWLINE> <INDENT> print ( 7886244 ) <NEWLINE> <DEDENT> elif K == 181 : <NEWLINE> <INDENT> print ( 7984165 ) <NEWLINE> <DEDENT> elif K == 182 : <NEWLINE> <INDENT> print ( 8130747 ) <NEWLINE> <DEDENT> elif K == 183 : <NEWLINE> <INDENT> print ( 8253888 ) <NEWLINE> <DEDENT> elif K == 184 : <NEWLINE> <INDENT> print ( 8403448 ) <NEWLINE> <DEDENT> elif K == 185 : <NEWLINE> <INDENT> print ( 8523897 ) <NEWLINE> <DEDENT> elif K == 186 : <NEWLINE> <INDENT> print ( 8684853 ) <NEWLINE> <DEDENT> elif K == 187 : <NEWLINE> <INDENT> print ( 8802826 ) <NEWLINE> <DEDENT> elif K == 189 : <NEWLINE> <INDENT> print ( 8949612 ) <NEWLINE> <DEDENT> elif K == 190 : <NEWLINE> <INDENT> print ( 9267595 ) <NEWLINE> <DEDENT> elif K == 191 : <NEWLINE> <INDENT> print ( 9376656 ) <NEWLINE> <DEDENT> elif K == 192 : <NEWLINE> <INDENT> print ( 9574704 ) <NEWLINE> <DEDENT> elif K == 193 : <NEWLINE> <INDENT> print ( 9686065 ) <NEWLINE> <DEDENT> elif K == 194 : <NEWLINE> <INDENT> print ( 9827097 ) <NEWLINE> <DEDENT> elif K == 195 : <NEWLINE> <INDENT> print ( 9997134 ) <NEWLINE> <DEDENT> elif K == 196 : <NEWLINE> <INDENT> print ( 10174780 ) <NEWLINE> <DEDENT> elif K == 197 : <NEWLINE> <INDENT> print ( 10290813 ) <NEWLINE> <DEDENT> elif K == 198 : <NEWLINE> <INDENT> print ( 10493367 ) <NEWLINE> <DEDENT> elif K == 199 : <NEWLINE> <INDENT> print ( 10611772 ) <NEWLINE> <DEDENT> elif K == 200 : <NEWLINE> <INDENT> print ( 10813692 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> lista = list ( range ( 1 , ( K + 1 ) ) ) <NEWLINE> listb = list ( range ( 1 , ( K + 1 ) ) ) <NEWLINE> listc = list ( range ( 1 , ( K + 1 ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for pair in itertools . product ( lista , listb , listc ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> gcd = functools . reduce ( math . gcd , list ( pair ) ) <NEWLINE> <COMMENT> <NL> ans += gcd <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> class BIT : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . bit = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> while i <= len ( self . bit ) : <NEWLINE> <INDENT> self . bit [ i - 1 ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def sum_sub ( self , i ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> i += 1 <NEWLINE> while i : <NEWLINE> <INDENT> a += self . bit [ i - 1 ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def sum ( self , i , j ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> if j != 0 : <NEWLINE> <INDENT> a += self . sum_sub ( j - 1 ) <NEWLINE> <DEDENT> if i != 0 : <NEWLINE> <INDENT> a -= self . sum_sub ( i - 1 ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Bit = BIT ( n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Bit . add ( i , a [ i ] ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> t , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> Bit . add ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Bit . sum ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> M = [ ] <NEWLINE> <NL> for n in range ( A , min ( A + K , B + 1 ) ) : <NEWLINE> <INDENT> L . append ( n ) <NEWLINE> <NL> <DEDENT> for n in range ( max ( A , B - K ) , B + 1 ) : <NEWLINE> <INDENT> M . append ( n ) <NEWLINE> <NL> <DEDENT> L = sorted ( set ( L [ : K ] + M [ - K : ] ) ) <NEWLINE> <NL> print ( * L , sep = <STRING> ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> card = K <COMMENT> <NEWLINE> <COMMENT> <NL> result = 0 <NEWLINE> <COMMENT> <NL> if card < A : <COMMENT> <NEWLINE> <INDENT> print ( card ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> card -= A <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if card < B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> card -= B <COMMENT> <NEWLINE> <COMMENT> <NL> x = card * - 1 <NEWLINE> <COMMENT> <NL> print ( A + x ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> if N >= B : <NEWLINE> <INDENT> print ( ( A * ( B - 1 ) ) // B - A * ( ( B - 1 ) // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( A * N ) // B - A * ( N // B ) ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> s = list ( t ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if s == [ s [ 0 ] ] * len ( s ) : <NEWLINE> <INDENT> print ( ( len ( s ) * k ) // 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b = [ 1 ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] : b [ - 1 ] += 1 <NEWLINE> else : b . append ( 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in b : ans += i // 2 * k <NEWLINE> if t [ 0 ] == t [ - 1 ] and ( b [ 0 ] + b [ - 1 ] ) % 2 == 0 : ans += k - 1 <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> if n == k or max ( a ) < 0 or min ( a ) >= 0 : <NEWLINE> <INDENT> if max ( a ) < 0 and k % 2 == 0 : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . sort ( reverse = True ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> pos , neg = [ ] , [ ] <NEWLINE> for num in a : <NEWLINE> <INDENT> if num < 0 : <NEWLINE> <INDENT> neg . append ( - num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos . append ( num ) <NEWLINE> <DEDENT> <DEDENT> neg . sort ( reverse = True ) <NEWLINE> pos . sort ( reverse = True ) <NEWLINE> nn = len ( neg ) <NEWLINE> np = len ( pos ) <NEWLINE> cand = [ ] <NEWLINE> i , j = 0 , 0 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if i < np - 1 and j < nn - 1 : <NEWLINE> <INDENT> if k >= 2 : <NEWLINE> <INDENT> if pos [ i + 1 ] * pos [ i ] < neg [ j + 1 ] * neg [ j ] : <NEWLINE> <INDENT> cand . append ( - neg [ j + 1 ] ) <NEWLINE> cand . append ( - neg [ j ] ) <NEWLINE> k -= 2 <NEWLINE> j += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand . append ( pos [ i ] ) <NEWLINE> k -= 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cand . append ( pos [ i ] ) <NEWLINE> k -= 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> elif j >= nn - 1 : <NEWLINE> <INDENT> cand . append ( pos [ i ] ) <NEWLINE> k -= 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif i == np - 1 : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> cand . append ( pos [ i ] ) <NEWLINE> i += 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand . append ( - neg [ j + 1 ] ) <NEWLINE> cand . append ( - neg [ j ] ) <NEWLINE> j += 2 <NEWLINE> k -= 2 <NEWLINE> <DEDENT> <DEDENT> elif i == np : <NEWLINE> <INDENT> cand . append ( - neg [ j + 1 ] ) <NEWLINE> cand . append ( - neg [ j ] ) <NEWLINE> j += 2 <NEWLINE> k -= 2 <NEWLINE> <DEDENT> <DEDENT> for num in cand : <NEWLINE> <INDENT> ans *= num <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> <NL> Af = np . array ( A , dtype = <STRING> ) <NEWLINE> Afans = np . prod ( Af , dtype = <STRING> ) <NEWLINE> <NL> if Afans == 0. : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Afans >= 2e18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ai = np . array ( A , dtype = <STRING> ) <NEWLINE> Aians = np . prod ( Ai , dtype = <STRING> ) <NEWLINE> if Aians <= np . int64 ( 1e18 ) and Aians >= np . int64 ( 0 ) : <NEWLINE> <INDENT> print ( Aians ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = list ( input ( ) ) <NEWLINE> for i in a [ : : - 1 ] : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> a_max = a [ - 1 ] + 1 <COMMENT> <NEWLINE> lst = [ 0 ] * a_max <COMMENT> <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> lst [ x ] += 1 <COMMENT> <NEWLINE> if lst [ x ] == 1 : <COMMENT> <NEWLINE> <INDENT> for i in range ( x * 2 , a_max , x ) : <NEWLINE> <INDENT> lst [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> output = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if lst [ x ] == 1 : <NEWLINE> <INDENT> output += 1 <NEWLINE> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] ) <NEWLINE> ans = [ 0 for i in range ( n ) ] <NEWLINE> res = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if ( i > 0 and sc [ i ] [ 0 ] == sc [ i - 1 ] [ 0 ] and sc [ i ] [ 1 ] != sc [ i - 1 ] [ 1 ] ) or ( n > 1 and sc [ i ] [ 0 ] == 1 and sc [ i ] [ 1 ] == 0 ) : <NEWLINE> <INDENT> res = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ sc [ i ] [ 0 ] - 1 ] = sc [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if n > 1 and ans [ 0 ] == 0 : <NEWLINE> <INDENT> ans [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> ans2 = int ( <STRING> . join ( [ str ( i ) for i in ans ] ) ) if res else - 1 <NEWLINE> print ( ans2 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> route = [ ] <NEWLINE> town = set ( ) <NEWLINE> now = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> if now in town : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> town . add ( now ) <NEWLINE> route . append ( now ) <NEWLINE> <NL> <DEDENT> count = route . index ( now ) <NEWLINE> if count >= k : <NEWLINE> <INDENT> print ( route [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> route = route [ count : ] <NEWLINE> num = ( k - count ) % len ( route ) <NEWLINE> print ( route [ num - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
def binary_search ( S , t ) : <NEWLINE> <INDENT> start = 0 <NEWLINE> end = len ( S ) <NEWLINE> while True : <NEWLINE> <INDENT> mid = start + ( end - start ) // 2 <NEWLINE> if S [ mid ] == t : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif ( end - start ) < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif S [ mid ] < t : <NEWLINE> <INDENT> start = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end = mid <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in T : <NEWLINE> <INDENT> if binary_search ( S , i ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import queue <NEWLINE> <NL> q = queue . Queue ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 10 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> S = [ ] <NEWLINE> history = [ ] <NEWLINE> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> d [ <STRING> ] = A <NEWLINE> d [ <STRING> ] = B <NEWLINE> d [ <STRING> ] = C <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> S . append ( s ) <NEWLINE> <NL> <DEDENT> def select ( L , R , x ) : <NEWLINE> <INDENT> diff = 1 <NEWLINE> if L != x : <NEWLINE> <INDENT> diff *= - 1 <NEWLINE> <DEDENT> d [ L ] += diff <NEWLINE> d [ R ] -= diff <NEWLINE> history . append ( x ) <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> L , R = S [ n ] <NEWLINE> if d [ L ] >= 2 : <NEWLINE> <INDENT> select ( L , R , R ) <NEWLINE> <DEDENT> elif d [ L ] == 0 : <NEWLINE> <INDENT> if d [ R ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> select ( L , R , L ) <NEWLINE> <DEDENT> <DEDENT> elif d [ L ] == 1 : <NEWLINE> <INDENT> if d [ R ] >= 2 : <NEWLINE> <INDENT> select ( L , R , L ) <NEWLINE> <DEDENT> elif d [ R ] == 0 : <NEWLINE> <INDENT> select ( L , R , R ) <NEWLINE> <DEDENT> elif d [ R ] == 1 : <NEWLINE> <INDENT> if n != N - 1 : <NEWLINE> <INDENT> if L in S [ n + 1 ] : <NEWLINE> <INDENT> select ( L , R , L ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> select ( L , R , R ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> select ( L , R , L ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for h in history : <NEWLINE> <INDENT> print ( h ) <NEWLINE> <DEDENT>
def lcs ( x , y ) : <NEWLINE> <INDENT> m , n = len ( x ) , len ( y ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for xi in x : <NEWLINE> <INDENT> temp = dp [ : ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if xi == y [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = temp [ j ] + 1 <NEWLINE> <DEDENT> elif dp [ j + 1 ] < dp [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = dp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> print ( lcs ( x , y ) ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> Bs = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> <NL> for i in range ( len ( As ) ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ - 1 ] + As [ i ] ) <NEWLINE> <NL> <DEDENT> for j in range ( len ( Bs ) ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ - 1 ] + Bs [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> max_book_num = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a_sum [ i ] > K : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> while b_sum [ j ] + a_sum [ i ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> max_book_num = max ( max_book_num , i + j ) <NEWLINE> <NL> <NL> <DEDENT> print ( max_book_num ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> x = 10 ** 18 <NEWLINE> a = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> a = a * i <NEWLINE> if a > x : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mem = [ ] <NEWLINE> h = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> h += A [ i ] <NEWLINE> mem . append ( h ) <NEWLINE> <NL> <DEDENT> tmp = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp += A [ i ] * mem [ - ( i + 1 + 1 ) ] <NEWLINE> <DEDENT> print ( tmp % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> print ( len ( set ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> list . append ( tmp ) <NEWLINE> <NL> <DEDENT> maxDiff = - 10 ** 9 <NEWLINE> tmpMin = list [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> maxDiff = max ( [ maxDiff , list [ i + 1 ] - tmpMin ] ) <NEWLINE> tmpMin = min ( [ tmpMin , list [ i + 1 ] ] ) <NEWLINE> <DEDENT> print ( maxDiff ) <NEWLINE>
n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> score = 1 <NEWLINE> if score < score * a [ i ] / a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> ret = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ret *= a <NEWLINE> if len ( str ( ret ) ) >= 19 and ret != 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if len ( str ( ret ) ) >= 19 and ret != 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ret ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in range ( X + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : <NEWLINE> <INDENT> a = X + s * d <NEWLINE> if p . count ( a ) == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def count ( val1 , val2 ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if val1 < ( val2 ** num ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num += 1 <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> digit = num <NEWLINE> while True : <NEWLINE> <INDENT> if val1 >= val2 ** digit : <NEWLINE> <INDENT> val1 -= val2 ** digit <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> digit -= 1 <NEWLINE> <NL> <DEDENT> if digit == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return cnt , val1 <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = N <NEWLINE> <NL> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> n = i <NEWLINE> m = N - i <NEWLINE> res = 0 <NEWLINE> <NL> cnt , nn = count ( n , 9 ) <NEWLINE> n = nn <NEWLINE> res += cnt <NEWLINE> <NL> cnt , mm = count ( m , 6 ) <NEWLINE> m = mm <NEWLINE> res += cnt <NEWLINE> <NL> res += n + m <NEWLINE> ans = min ( ans , res ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> if b <= k : <NEWLINE> <INDENT> k -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from bisect import bisect_left as bl <NEWLINE> from bisect import bisect_right as br <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> import math <NEWLINE> from collections import * <NEWLINE> from functools import reduce , cmp_to_key <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> from itertools import accumulate <NEWLINE> from functools import lru_cache <NEWLINE> <NL> M = mod = 10 ** 9 + 7 <NEWLINE> def factors ( n ) : return sorted ( set ( reduce ( list . __add__ , ( [ i , n // i ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) if n % i == 0 ) ) ) ) <NEWLINE> def inv_mod ( n ) : return pow ( n , mod - 2 , mod ) <NEWLINE> <NL> def li ( ) : return [ int ( i ) for i in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> def st ( ) : return input ( ) . rstrip ( <STRING> ) <NEWLINE> def val ( ) : return int ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> def li2 ( ) : return [ i for i in input ( ) . rstrip ( <STRING> ) ] <NEWLINE> def li3 ( ) : return [ int ( i ) for i in input ( ) . rstrip ( <STRING> ) ] <NEWLINE> <NL> <NL> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> g = 0 <NEWLINE> @ lru_cache ( None ) <NEWLINE> def dp ( i , par = - 1 , black = 0 ) : <NEWLINE> <INDENT> global g <NEWLINE> ans = 1 <NEWLINE> nokids = 1 <NEWLINE> if black : <NEWLINE> <INDENT> for j in g [ i ] : <NEWLINE> <INDENT> if j != par : <NEWLINE> <INDENT> nokids = 0 <NEWLINE> ans = ans * dp ( j , i , 0 ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in g [ i ] : <NEWLINE> <INDENT> if j != par : <NEWLINE> <INDENT> nokids = 0 <NEWLINE> ans = ( ans * ( dp ( j , i , 0 ) + dp ( j , i , 1 ) ) ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if nokids : ans = 1 <NEWLINE> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> n = val ( ) <NEWLINE> g = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> l = [ ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = li ( ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> root = 1 <NEWLINE> ans = dp ( root , - 1 , 0 ) + dp ( root , - 1 , 1 ) <NEWLINE> <NL> print ( ans % mod ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> haz_zero = 0 in A <NEWLINE> if haz_zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> answer = 1 <NEWLINE> for Ai in A : <NEWLINE> <INDENT> answer *= Ai <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l = i + a [ i ] <NEWLINE> r = i - a [ i ] <NEWLINE> if l not in d : <NEWLINE> <INDENT> d [ l ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ l ] += 1 <NEWLINE> <DEDENT> if r in d : <NEWLINE> <INDENT> ans += d [ r ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = max ( s ) <NEWLINE> c = [ 0 for i in range ( k + 1 ) ] <NEWLINE> def counting_sort ( a , k ) : <NEWLINE> <INDENT> global c <NEWLINE> b = [ 0 for i in range ( len ( a ) + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i ] + c [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> b [ c [ a [ i ] ] ] = a [ i ] <NEWLINE> c [ a [ i ] ] -= 1 <NEWLINE> <DEDENT> return b <NEWLINE> <DEDENT> res = counting_sort ( s , k ) [ 1 : n + 1 ] <NEWLINE> print ( * res ) <NEWLINE> <COMMENT> <NL> <NL>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) . strip ( ) <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> <NL> tmp = 0 <NEWLINE> ten = 10 <NEWLINE> mod [ tmp ] += 1 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = ( tmp + ten * int ( s [ i ] ) ) % 2019 <NEWLINE> ten = ( ten * 10 ) % 2019 <NEWLINE> mod [ tmp ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> if mod [ i ] > 1 : <NEWLINE> <INDENT> ans += ( mod [ i ] * ( mod [ i ] - 1 ) ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( As ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
from collections import defaultdict <NEWLINE> def prod ( A , k , mod ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> if K == N : <NEWLINE> <INDENT> return prod ( A , N , mod ) <NEWLINE> <DEDENT> minus = len ( [ a for a in A if a < 0 ] ) <NEWLINE> if minus == N : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> <DEDENT> return prod ( A , K , mod ) <NEWLINE> <DEDENT> if K == 1 : <NEWLINE> <INDENT> return max ( A ) <NEWLINE> <DEDENT> A . sort ( key = lambda x : - abs ( x ) ) <NEWLINE> if A [ K ] == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> minus = len ( [ a for a in A [ : K ] if a < 0 ] ) <NEWLINE> flag = [ 1 ] * K + [ 0 ] * ( N - K ) <NEWLINE> d = defaultdict ( lambda : - 1 ) <NEWLINE> if minus % 2 == 1 : <NEWLINE> <INDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] >= 0 : <NEWLINE> <INDENT> d [ <STRING> ] = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> d [ <STRING> ] = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( K - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> d [ <STRING> ] = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( K - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> d [ <STRING> ] = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if d [ <STRING> ] == - 1 or d [ <STRING> ] == - 1 : <NEWLINE> <INDENT> flag [ d [ <STRING> ] ] , flag [ d [ <STRING> ] ] = 1 , 0 <NEWLINE> <DEDENT> elif d [ <STRING> ] == - 1 or d [ <STRING> ] == - 1 : <NEWLINE> <INDENT> flag [ d [ <STRING> ] ] , flag [ d [ <STRING> ] ] = 1 , 0 <NEWLINE> <DEDENT> elif A [ d [ <STRING> ] ] * A [ d [ <STRING> ] ] > A [ d [ <STRING> ] ] * A [ d [ <STRING> ] ] : <NEWLINE> <INDENT> flag [ d [ <STRING> ] ] , flag [ d [ <STRING> ] ] = 1 , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ d [ <STRING> ] ] , flag [ d [ <STRING> ] ] = 1 , 0 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if flag [ i ] == 1 : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> return prod ( A , K , mod ) <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> from math import gcd <NEWLINE> from operator import add , itemgetter , mul , xor <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> bunshi = 1 <NEWLINE> bunbo = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> bunbo = bunbo * ( i + 1 ) % mod <NEWLINE> bunshi = bunshi * ( n - i ) % mod <NEWLINE> <DEDENT> return ( bunshi * pow ( bunbo , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = I ( ) <NEWLINE> s = input ( ) <NEWLINE> c = Counter ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( i + 1 , n ) : <NEWLINE> <INDENT> if ( i + k ) % 2 == 0 : <NEWLINE> <INDENT> j = ( i + k ) // 2 <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans_2 = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> print ( ans_2 - ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = 10 ** 10 <NEWLINE> h . sort ( ) <NEWLINE> <NL> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> res = h [ i + K - 1 ] - h [ i ] <NEWLINE> ans = min ( ans , res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 998244353 <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> N = 10 ** 6 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> col = m * pow ( m - 1 , n - i - 1 , mod ) <NEWLINE> match = cmb ( n - 1 , i , mod ) <NEWLINE> ans += col * match <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> counts = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if ( k >= n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] ) : <NEWLINE> <INDENT> counts += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - counts ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> S . pop ( ) <NEWLINE> m = 2019 <NEWLINE> div_list = [ 0 ] * m <NEWLINE> num = 0 <NEWLINE> for i , l in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> num += pow ( 10 , i , m ) * int ( l ) <NEWLINE> div_list [ num % m ] += 1 <NEWLINE> <NL> <DEDENT> div_list [ 0 ] += 1 <NEWLINE> ans = 0 <NEWLINE> for item in div_list : <NEWLINE> <INDENT> ans += int ( item * ( item - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from itertools import accumulate <NEWLINE> import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a = [ 0 ] + list ( accumulate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = [ 0 ] + list ( accumulate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = [ 0 ] <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> c = bisect . bisect_right ( b , k - a [ i ] ) - 1 <NEWLINE> <COMMENT> <NL> if c != - 1 : <NEWLINE> <INDENT> ans . append ( c + i ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) <NEWLINE> num = int ( line ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 ) : <NEWLINE> <INDENT> result += <STRING> + str ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> devided = i <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if ( devided % 10 == 3 ) : <NEWLINE> <INDENT> result += <STRING> + str ( i ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( devided > 9 ) : <NEWLINE> <INDENT> devided = devided // 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> func ( ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> num = np . zeros ( 100001 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <DEDENT> sum = a . sum ( ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum += ( c - b ) * num [ b ] <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> print ( int ( sum ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a [ A [ i ] - 1 ] = a [ A [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for _ in range ( h ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( b ) <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> c = a [ i ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> d [ c [ j ] ] = ( i + 1 , j + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> R_min = h * w <NEWLINE> R_max = 1 <NEWLINE> query = [ ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> query . append ( [ l , r ] ) <NEWLINE> R_min = min ( l , R_min ) <NEWLINE> R_max = max ( r , R_max ) <NEWLINE> <NL> <NL> <DEDENT> cum = [ 0 ] * ( h * w + 1 ) <NEWLINE> for k in range ( R_min , R_max - D + 1 ) : <NEWLINE> <INDENT> prev = cum [ k - 1 ] <NEWLINE> cost = abs ( d [ k + D ] [ 0 ] - d [ k ] [ 0 ] ) + abs ( d [ k + D ] [ 1 ] - d [ k ] [ 1 ] ) <NEWLINE> cum [ k + D - 1 ] = cost + prev <NEWLINE> <NL> <NL> <NL> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> l , r = query [ j ] [ 0 ] , query [ j ] [ 1 ] <NEWLINE> score = cum [ r - 1 ] - cum [ l - 1 ] <NEWLINE> print ( score ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ma = A [ 0 ] <NEWLINE> <NL> res = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] <= ma : <NEWLINE> <INDENT> res += ma - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma = A [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( s [ - 1 ] ) <NEWLINE> if k == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd_list = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> abcd_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> A = sorted ( list ( A ) ) <NEWLINE> point = 0 <NEWLINE> for abcd in abcd_list : <NEWLINE> <INDENT> if A [ abcd [ 1 ] - 1 ] - A [ abcd [ 0 ] - 1 ] == abcd [ 2 ] : <NEWLINE> <INDENT> point += abcd [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if point > ans : <NEWLINE> <INDENT> ans = point <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from decimal import * <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> long = 6 * M <NEWLINE> <COMMENT> <NL> short = 30 * ( H ) + 0.5 * M <NEWLINE> theta = abs ( long - short ) <NEWLINE> if theta > 180 : <NEWLINE> <INDENT> theta = 360 - theta <NEWLINE> <DEDENT> cos = math . cos ( math . radians ( theta ) ) <NEWLINE> x = A ** 2 + B ** 2 - 2 * A * B * cos <NEWLINE> x = math . sqrt ( x ) <COMMENT> <NEWLINE> n = 10 <COMMENT> <NEWLINE> y = Decimal ( str ( x ) ) . quantize ( Decimal ( str ( 10 ** ( n * - 1 ) ) ) , rounding = ROUND_DOWN ) <NEWLINE> print ( y ) <NEWLINE>
<COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if h [ a ] > h [ b ] : <NEWLINE> <INDENT> ans [ b ] = 0 <NEWLINE> <DEDENT> elif h [ a ] < h [ b ] : <NEWLINE> <INDENT> ans [ a ] = 0 <NEWLINE> <DEDENT> if h [ a ] == h [ b ] : <NEWLINE> <INDENT> ans [ a ] = 0 <NEWLINE> ans [ b ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
s = input ( ) <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> n = 0 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> n += int ( i ) * d <NEWLINE> n %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> mod [ n % 2019 ] += 1 <NEWLINE> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in mod ) ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> a = A [ 0 ] <NEWLINE> b = A [ 1 ] <NEWLINE> c = b - a <NEWLINE> <NL> if a <= 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if c % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> an = 1 <NEWLINE> c = 0 <NEWLINE> <NL> for m in b : <NEWLINE> <INDENT> an *= m <NEWLINE> if ( an > 10 ** 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> c = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( c != 1 ) : <NEWLINE> <INDENT> print ( an ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> a = list ( ) <NEWLINE> d = 0 <NEWLINE> while i < k : <NEWLINE> <INDENT> d += int ( input ( ) ) <NEWLINE> a += ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> while i < d : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> ans = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if b [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> import sys <NEWLINE> <NL> H , W , M = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> NH = [ [ 0 , i ] for i in range ( H ) ] <NEWLINE> NW = [ [ 0 , i ] for i in range ( W ) ] <NEWLINE> <NL> B = defaultdict ( int ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = ( int ( x ) - 1 for x in input ( ) . split ( ) ) <NEWLINE> B [ ( h , w ) ] = 0 <NEWLINE> NH [ h ] [ 0 ] += 1 <NEWLINE> NW [ w ] [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> NH . sort ( reverse = True ) <NEWLINE> NW . sort ( reverse = True ) <NEWLINE> maxH = NH [ 0 ] [ 0 ] <NEWLINE> maxW = NW [ 0 ] [ 0 ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> countH , idxH = NH [ i ] <NEWLINE> if countH != maxH : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for j in range ( W ) : <NEWLINE> <INDENT> countW , idxW = NW [ j ] <NEWLINE> if countW != maxW : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if ( idxH , idxW ) not in B : <NEWLINE> <INDENT> print ( maxH + maxW ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( maxH + maxW - 1 ) <NEWLINE>
def solve ( string ) : <NEWLINE> <INDENT> n = int ( string ) <NEWLINE> return str ( sum ( i * ( n // i ) * ( n // i + 1 ) // 2 for i in range ( 1 , n + 1 ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> print ( solve ( sys . stdin . read ( ) . strip ( ) ) ) <NEWLINE> <DEDENT>
s , k = input ( ) , int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> a = ord ( <STRING> ) + 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans . append ( ord ( i ) ) <NEWLINE> <DEDENT> elif a - ord ( i ) <= k and i != <STRING> : <NEWLINE> <INDENT> k -= a - ord ( i ) <NEWLINE> ans . append ( ord ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ord ( i ) ) <NEWLINE> <DEDENT> <DEDENT> ans [ - 1 ] += k % 26 <NEWLINE> if ans [ - 1 ] >= a : <NEWLINE> <INDENT> ans [ - 1 ] -= 26 <NEWLINE> <DEDENT> print ( * map ( chr , ans ) , sep = <STRING> ) <NEWLINE>
Z = input ( ) . split ( ) <NEWLINE> A = int ( Z [ 0 ] ) <NEWLINE> B = Z [ 1 ] . split ( <STRING> ) <NEWLINE> B = int ( B [ 0 ] + B [ 1 ] ) <NEWLINE> <COMMENT> <NL> if len ( str ( A * B ) ) <= 2 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = str ( A * B ) [ : - 2 ] <NEWLINE> a = int ( a ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> K = input ( ) <NEWLINE> if K [ - 1 ] == <STRING> or K [ - 1 ] == <STRING> or K [ - 1 ] == <STRING> or K [ - 1 ] == <STRING> or K [ - 1 ] == <STRING> or K [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> K = int ( K ) <NEWLINE> n = 7 % K <NEWLINE> i = 1 <NEWLINE> while i <= K : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> n = 10 * n + 7 <NEWLINE> n %= K <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
num = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num . append ( n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i , n in enumerate ( num ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> print ( <STRING> + str ( i ) + <STRING> + str ( n ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g1 = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g2 = gcd ( g1 , c ) <NEWLINE> res += g2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> hb = [ 0 ] * h <NEWLINE> wb = [ 0 ] * w <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> hb [ hw [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> wb [ hw [ i ] [ 1 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> max_h = max ( hb ) <NEWLINE> max_w = max ( wb ) <NEWLINE> ans = max_h + max_w <NEWLINE> count = hb . count ( max_h ) * wb . count ( max_w ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if hb [ hw [ i ] [ 0 ] - 1 ] == max_h and wb [ hw [ i ] [ 1 ] - 1 ] == max_w : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if count <= 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> A = [ [ A [ i ] , i ] for i in range ( N ) ] <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> dp [ 0 ] [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ x ] [ 0 ] = dp [ x - 1 ] [ 0 ] + A [ x - 1 ] [ 0 ] * ( A [ x - 1 ] [ 1 ] - x + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for y in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ 0 ] [ y ] = dp [ 0 ] [ y - 1 ] + A [ y - 1 ] [ 0 ] * ( N - y - A [ y - 1 ] [ 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> for x in range ( 1 , N ) : <NEWLINE> <INDENT> for y in range ( 1 , N + 1 - x ) : <NEWLINE> <INDENT> A0 = A [ x + y - 1 ] [ 0 ] <NEWLINE> A1 = A [ x + y - 1 ] [ 1 ] <NEWLINE> dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + A0 * ( A1 + 1 - x ) , dp [ x ] [ y - 1 ] + A0 * ( N - y - A1 ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c < dp [ i ] [ N - i ] : <NEWLINE> <INDENT> c = dp [ i ] [ N - i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> distance = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> print ( distance ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . up = 1 <NEWLINE> self . under = 6 <NEWLINE> self . N = 5 <NEWLINE> self . W = 4 <NEWLINE> self . E = 3 <NEWLINE> self . S = 2 <NEWLINE> <NL> <DEDENT> def roll ( self , d ) : <COMMENT> <NEWLINE> <INDENT> if d == <STRING> : <NEWLINE> <INDENT> tmp = self . up <NEWLINE> self . up = self . S <NEWLINE> self . S = self . under <NEWLINE> self . under = self . N <NEWLINE> self . N = tmp <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> tmp = self . up <NEWLINE> self . up = self . E <NEWLINE> self . E = self . under <NEWLINE> self . under = self . W <NEWLINE> self . W = tmp <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> tmp = self . up <NEWLINE> self . up = self . W <NEWLINE> self . W = self . under <NEWLINE> self . under = self . E <NEWLINE> self . E = tmp <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> tmp = self . up <NEWLINE> self . up = self . N <NEWLINE> self . N = self . under <NEWLINE> self . under = self . S <NEWLINE> self . S = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> def getUpward ( self ) : <NEWLINE> <INDENT> return self . up <NEWLINE> <NL> <DEDENT> def setRoll ( self , up , under , N , W , E , S ) : <NEWLINE> <INDENT> self . up = up <NEWLINE> self . under = under <NEWLINE> self . N = N <NEWLINE> self . W = W <NEWLINE> self . E = E <NEWLINE> self . S = S <NEWLINE> <NL> <DEDENT> def rotate ( self ) : <COMMENT> <NEWLINE> <INDENT> tmp = self . S <NEWLINE> self . S = self . E <NEWLINE> self . E = self . N <NEWLINE> self . N = self . W <NEWLINE> self . W = tmp <NEWLINE> <NL> <DEDENT> def getE ( self , up , S ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if self . up == up : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if count != 3 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> if self . S == S : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . rotate ( ) <NEWLINE> <DEDENT> return self . E <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> myd = Dice ( ) <NEWLINE> myd . up , myd . S , myd . E , myd . W , myd . N , myd . under = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> up , S = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( myd . getE ( up , S ) ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lists = [ ] <NEWLINE> lists . append ( a * c ) <NEWLINE> lists . append ( a * d ) <NEWLINE> lists . append ( b * c ) <NEWLINE> lists . append ( b * d ) <NEWLINE> print ( max ( lists ) ) <NEWLINE>
import sys <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> person = 0 <NEWLINE> for i in range ( 0 , H ) : <NEWLINE> <INDENT> for j in range ( 0 , W ) : <NEWLINE> <INDENT> if geo [ i ] [ j ] is not <STRING> : <NEWLINE> <INDENT> search ( i , j ) <NEWLINE> person += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( person ) <NEWLINE> <NL> <DEDENT> def search ( i , j ) : <NEWLINE> <INDENT> temp = geo [ i ] [ j ] <NEWLINE> geo [ i ] [ j ] = <STRING> <NEWLINE> for a in range ( 0 , 4 ) : <NEWLINE> <INDENT> idx , jdy = i + dx [ a ] , j + dy [ a ] <NEWLINE> if ( isOnMap ( idx , jdy ) ) : <NEWLINE> <INDENT> if ( isNeededToSolve ( temp , idx , jdy ) ) : <NEWLINE> <INDENT> search ( idx , jdy ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def isOnMap ( i , j ) : return ( 0 <= i and 0 <= j and i < H and j < W ) <NEWLINE> <NL> def isNeededToSolve ( temp , i , j ) : <NEWLINE> <INDENT> target = geo [ i ] [ j ] <NEWLINE> return ( target is not <STRING> and temp is target ) <NEWLINE> <NL> <DEDENT> limit = 10 ** 7 <NEWLINE> sys . setrecursionlimit ( limit ) <NEWLINE> <NL> H , W , tempH = - 1 , - 1 , 0 <NEWLINE> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> geo = [ [ 0 for i in range ( 1 ) ] for j in range ( 1 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if H is - 1 and W is - 1 : <NEWLINE> <INDENT> p = line . split ( <STRING> ) <NEWLINE> H , W = int ( p [ 0 ] ) , int ( p [ 1 ] ) <NEWLINE> geo = [ [ 0 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> geo [ tempH ] = list ( line ) <NEWLINE> tempH += 1 <NEWLINE> <DEDENT> if H is 0 and W is 0 : break <NEWLINE> if tempH is H : <NEWLINE> <INDENT> solve ( ) <NEWLINE> H , W , tempH = - 1 , - 1 , 0 <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> <NL> num , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> num += int ( char ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> counts [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
def solve ( N , As ) : <NEWLINE> <INDENT> Ss = [ 0 ] <NEWLINE> total = 0 <NEWLINE> for a in As : <NEWLINE> <INDENT> Ss . append ( Ss [ - 1 ] + a ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> total += As [ i ] * ( Ss [ - 1 ] - Ss [ i + 1 ] ) <NEWLINE> <DEDENT> ans = total % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( N , As ) <NEWLINE> <DEDENT>
A , B , N = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if B > N : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <NL> <DEDENT> m = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> print ( m ) <NEWLINE>
def f ( x ) : <NEWLINE> <INDENT> div = 1 <NEWLINE> while div * div <= x : <NEWLINE> <INDENT> if x % div == 0 : <NEWLINE> <INDENT> for a in range ( 0 , int ( ( x // div ) ** 0.25 ) + 2 ) : <NEWLINE> <INDENT> b = a - div <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> return a , b <NEWLINE> <NL> <DEDENT> <DEDENT> opp_div = x // div <NEWLINE> for a in range ( 0 , int ( ( x // opp_div ) ** 0.25 ) + 2 ) : <NEWLINE> <INDENT> b = a - opp_div <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> return a , b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> div += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a , b = f ( x ) <NEWLINE> print ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> if 1 not in A : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == num : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> s = deque ( list ( input ( ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> q = [ list ( input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> rev = False <NEWLINE> <NL> for tfc in q : <NEWLINE> <INDENT> if tfc [ 0 ] == <STRING> and rev is False : <NEWLINE> <INDENT> rev = True <NEWLINE> <DEDENT> elif tfc [ 0 ] == <STRING> and rev is True : <NEWLINE> <INDENT> rev = False <NEWLINE> <DEDENT> elif rev is False : <NEWLINE> <INDENT> if tfc [ 1 ] == <STRING> : <NEWLINE> <INDENT> s . appendleft ( tfc [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( tfc [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> elif rev is True : <NEWLINE> <INDENT> if tfc [ 1 ] == <STRING> : <NEWLINE> <INDENT> s . append ( tfc [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( tfc [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if rev : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
m = 998244353 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ ] , [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l_ , r_ = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( l_ ) <NEWLINE> r . append ( r_ ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dpsum = [ 0 ] * ( n + 1 ) <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> li = i - r [ j ] <NEWLINE> ri = i - l [ j ] <NEWLINE> if ri < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> li = max ( li , 1 ) <NEWLINE> dp [ i ] += dpsum [ ri ] - dpsum [ li - 1 ] <NEWLINE> <DEDENT> dpsum [ i ] = ( dpsum [ i - 1 ] + dp [ i ] ) % m <NEWLINE> <NL> <DEDENT> print ( dp [ n ] % m ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> attend = [ 0 ] * n <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> attend [ j - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * attend ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> f = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if f < N + 1 : <NEWLINE> <INDENT> ans [ f ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans . remove ( 0 ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> calc = lambda x , y , z : x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> def pattern ( x , y , z ) : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif x != y and y != z and z != x : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise RuntimeError <NEWLINE> <NL> <DEDENT> <DEDENT> d = defaultdict ( int ) <NEWLINE> n_ = int ( pow ( n , 0.5 ) ) <NEWLINE> nums = [ i for i in range ( 1 , n_ + 1 ) ] <NEWLINE> for x , y , z in combinations_with_replacement ( nums , 3 ) : <NEWLINE> <INDENT> d [ calc ( x , y , z ) ] += pattern ( x , y , z ) <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
numStn = int ( input ( ) ) <NEWLINE> stnData = list ( input ( ) ) <NEWLINE> <NL> ttlW = stnData . count ( <STRING> ) <NEWLINE> ttlR = stnData . count ( <STRING> ) <NEWLINE> <NL> cnt = ttlR - stnData [ : ttlR ] . count ( <STRING> ) <NEWLINE> <NL> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> exp = [ ( x + 1 ) / 2 for x in p ] <NEWLINE> <NL> sums = 0 <NEWLINE> ls = [ 0 ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> sums += exp [ n ] <NEWLINE> ls . append ( sums ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n in range ( N - K + 1 ) : <NEWLINE> <NL> <INDENT> ans_candidate = ls [ n + K ] - ls [ n ] <NEWLINE> <NL> if ans < ans_candidate : <NEWLINE> <INDENT> ans = ans_candidate <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> A = [ [ int ( a ) for a in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> B = [ [ int ( b ) for b in input ( ) . split ( ) ] for i in range ( m ) ] <NEWLINE> C = [ [ 0 for i in range ( l ) ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for jj in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] = C [ i ] [ j ] + A [ i ] [ jj ] * B [ jj ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( _ ) for _ in C [ i ] ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> S = [ readline ( ) . rstrip ( ) . decode ( ) for _ in range ( N ) ] <NEWLINE> <NL> def count_cb_ob ( s ) : <NEWLINE> <INDENT> st = [ ] <NEWLINE> for i , si in enumerate ( s ) : <NEWLINE> <INDENT> if si == <STRING> or len ( st ) == 0 or st [ - 1 ] != <STRING> : <NEWLINE> <INDENT> st . append ( si ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . pop ( ) <NEWLINE> <DEDENT> <DEDENT> return st . count ( <STRING> ) , st . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> cb_obs = list ( map ( count_cb_ob , S ) ) <NEWLINE> f = list ( filter ( lambda cb_ob : cb_ob [ 0 ] < cb_ob [ 1 ] , cb_obs ) ) <NEWLINE> b = list ( filter ( lambda cb_ob : cb_ob [ 0 ] > cb_ob [ 1 ] , cb_obs ) ) <NEWLINE> s = list ( filter ( lambda cb_ob : cb_ob [ 0 ] == cb_ob [ 1 ] , cb_obs ) ) <NEWLINE> <NL> f = sorted ( f ) <NEWLINE> b = sorted ( b , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> count = 0 <NEWLINE> ans = <STRING> <NEWLINE> for down , up in ( * f , * s , * b ) : <NEWLINE> <INDENT> count -= down <NEWLINE> if count < 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> count += up <NEWLINE> <NL> <DEDENT> if count != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> read = sys . stdin . readline <NEWLINE> ra = range <NEWLINE> enu = enumerate <NEWLINE> <NL> <NL> def mina1 ( x ) : <NEWLINE> <INDENT> return int ( x ) - 1 <NEWLINE> <NL> <NL> <DEDENT> def read_ints ( mina = False ) : <NEWLINE> <INDENT> if mina : <NEWLINE> <INDENT> return list ( map ( mina1 , read ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return list ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def read_a_int ( ) : <NEWLINE> <INDENT> return int ( read ( ) ) <NEWLINE> <NL> <NL> <DEDENT> from bisect import bisect_left , bisect_right <NEWLINE> from collections import defaultdict <NEWLINE> N = read_a_int ( ) <NEWLINE> A = read_ints ( ) <NEWLINE> tree = defaultdict ( lambda : [ ] ) <NEWLINE> for _ in ra ( N - 1 ) : <NEWLINE> <INDENT> u , v = read_ints ( mina = True ) <NEWLINE> tree [ u ] . append ( v ) <NEWLINE> tree [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> LIS = [ ] <NEWLINE> ans = [ 0 ] * N <COMMENT> <NEWLINE> <NL> <NL> def dfs ( now , p ) : <COMMENT> <NEWLINE> <INDENT> a = A [ now ] <NEWLINE> <COMMENT> <NL> idx = bisect_left ( LIS , a ) <NEWLINE> is_append = False <NEWLINE> if idx == len ( LIS ) : <NEWLINE> <INDENT> LIS . append ( a ) <NEWLINE> is_append = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> old = LIS [ idx ] <COMMENT> <NEWLINE> LIS [ idx ] = a <COMMENT> <NEWLINE> <NL> <DEDENT> ans [ now ] = len ( LIS ) <COMMENT> <NEWLINE> <COMMENT> <NL> for to in tree [ now ] : <NEWLINE> <INDENT> if to == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( to , now ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if is_append : <NEWLINE> <INDENT> del LIS [ idx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> LIS [ idx ] = old <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
count = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> L = A [ left : mid ] + [ 2 ** 32 ] <NEWLINE> R = A [ mid : right ] + [ 2 ** 32 ] <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> merge_sort ( A , 0 , n ) <NEWLINE> print ( * A ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> exp_dist = abs ( x1 - x2 ) ** 2 + abs ( y1 - y2 ) ** 2 <NEWLINE> <NL> print ( math . sqrt ( exp_dist ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for a in range ( 200 ) : <NEWLINE> <INDENT> if a ** 5 == X + b ** 5 : <NEWLINE> <INDENT> ans = ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> q = k in l <NEWLINE> if q == False : <NEWLINE> <INDENT> l . add ( k ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
import itertools <NEWLINE> import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( l ) - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( l ) ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> if k > j : <NEWLINE> <INDENT> ans += k - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flg = 0 <NEWLINE> l = [ 0 ] * ( max ( A ) + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <DEDENT> a = gcd ( A [ 0 ] , A [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> a = gcd ( a , A [ i ] ) <NEWLINE> <DEDENT> for i in range ( 2 , max ( A ) + 1 ) : <NEWLINE> <INDENT> if sum ( l [ i : : i ] ) > 1 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if a == 1 and flg == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 1 and flg == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from bisect import bisect <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 2 : <NEWLINE> <INDENT> res = [ ( max ( A ) , min ( A ) ) ] <NEWLINE> s = max ( A ) - min ( A ) <NEWLINE> return s , res <NEWLINE> <NL> <DEDENT> if A [ 0 ] >= 0 : <NEWLINE> <INDENT> res = [ ] <NEWLINE> x = A [ 0 ] <NEWLINE> for a in A [ 1 : - 1 ] : <NEWLINE> <INDENT> res . append ( ( x , a ) ) <NEWLINE> x -= a <NEWLINE> <DEDENT> res . append ( ( A [ - 1 ] , x ) ) <NEWLINE> x = A [ - 1 ] - x <NEWLINE> return ( x , res ) <NEWLINE> <DEDENT> if A [ - 1 ] <= 0 : <NEWLINE> <INDENT> res = [ ] <NEWLINE> x = A [ - 1 ] <NEWLINE> for a in A [ : - 1 ] : <NEWLINE> <INDENT> res . append ( ( x , a ) ) <NEWLINE> x -= a <NEWLINE> <DEDENT> return ( x , res ) <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> p = bisect ( A , 0 ) - 1 <NEWLINE> x = A [ p ] <NEWLINE> for a in A [ p + 1 : N - 1 ] : <NEWLINE> <INDENT> res . append ( ( x , a ) ) <NEWLINE> x -= a <NEWLINE> <DEDENT> res . append ( ( A [ - 1 ] , x ) ) <NEWLINE> x = A [ - 1 ] - x <NEWLINE> for a in A [ : p ] : <NEWLINE> <INDENT> res . append ( ( x , a ) ) <NEWLINE> x -= a <NEWLINE> <DEDENT> return ( x , res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> s , res = solve ( ) <NEWLINE> print ( s ) <NEWLINE> print ( <STRING> . join ( <STRING> for a , b in res ) ) <NEWLINE>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r , b , g = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> c_n = np . array ( [ ( k , v ) for k , v in c . items ( ) ] ) <NEWLINE> total = np . dot ( c_n . T [ 0 ] , c_n . T [ 1 ] ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> cf , ca = map ( int , input ( ) . split ( ) ) <NEWLINE> num = c [ cf ] <NEWLINE> if ca in c : <NEWLINE> <INDENT> c [ ca ] += c [ cf ] <NEWLINE> c [ cf ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> c [ ca ] = c [ cf ] <NEWLINE> c [ cf ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> total += num * ( ca - cf ) <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> def calc_same_num ( s ) : <NEWLINE> <INDENT> if s [ 0 ] == s [ 1 ] and s [ 1 ] == s [ 2 ] : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif s [ 0 ] == s [ 1 ] or s [ 1 ] == s [ 2 ] : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 6 <NEWLINE> <NL> <DEDENT> <DEDENT> k = int ( input ( ) ) <NEWLINE> sum_check = 0 <NEWLINE> a , b , c = 1 , 1 , 1 <NEWLINE> ans = 0 <NEWLINE> while a <= k and b <= k and c <= k : <NEWLINE> <INDENT> gcd = gcd_list ( [ a , b , c ] ) <NEWLINE> ans += gcd * calc_same_num ( [ a , b , c ] ) <NEWLINE> if c < k : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif b < k : <NEWLINE> <INDENT> b += 1 <NEWLINE> c = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b = a <NEWLINE> c = a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) . split ( ) <NEWLINE> a = 0 <NEWLINE> b = 1 <NEWLINE> if x . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while a <= n - 1 and b <= 1000000000000000000 : <NEWLINE> <INDENT> b = b * int ( x [ a ] ) <NEWLINE> a += 1 <NEWLINE> <DEDENT> if b > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result *= li [ i ] <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> rain_d = 0 <NEWLINE> max_rain_d = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> rain_d += 1 <NEWLINE> max_rain_d = rain_d <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> rain_d = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max_rain_d ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def shinchan ( before , after ) : <NEWLINE> <INDENT> an = 1 <NEWLINE> key = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if key and abs ( lis [ i ] ) == before : <NEWLINE> <INDENT> an *= after <NEWLINE> key = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> an *= abs ( lis [ i ] ) <NEWLINE> <DEDENT> an %= 10 ** 9 + 7 <NEWLINE> <DEDENT> return an <NEWLINE> <DEDENT> plus = 0 <NEWLINE> minus = 0 <NEWLINE> zero = 0 <NEWLINE> p , m = [ ] , [ ] <NEWLINE> for num in lis : <NEWLINE> <INDENT> if num > 0 : <NEWLINE> <INDENT> plus += 1 <NEWLINE> p . append ( num ) <NEWLINE> <DEDENT> elif num < 0 : <NEWLINE> <INDENT> minus += 1 <NEWLINE> m . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> <DEDENT> p . sort ( reverse = True ) <NEWLINE> m . sort ( key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> lis . sort ( key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> zissaiplus = 0 <NEWLINE> zissaiminus = 0 <NEWLINE> zissaizero = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if lis [ i ] > 0 : <NEWLINE> <INDENT> zissaiplus += 1 <NEWLINE> <DEDENT> elif lis [ i ] < 0 : <NEWLINE> <INDENT> zissaiminus += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zissaizero += 1 <NEWLINE> <DEDENT> <DEDENT> if zissaizero > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if zissaiminus % 2 == 0 : <NEWLINE> <INDENT> ans = shinchan ( - 1 , - 1 ) <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key1 , key2 = 0 , 0 <NEWLINE> if zissaiminus > 0 and plus - zissaiplus > 0 : <NEWLINE> <INDENT> be1 = - m [ zissaiminus - 1 ] <NEWLINE> af1 = p [ zissaiplus ] <NEWLINE> key1 = 1 <NEWLINE> <DEDENT> if zissaiplus > 0 and minus - zissaiminus > 0 : <NEWLINE> <INDENT> be2 = p [ zissaiplus - 1 ] <NEWLINE> af2 = - m [ zissaiminus ] <NEWLINE> key2 = 1 <NEWLINE> <DEDENT> if key1 == 1 and key2 == 1 : <NEWLINE> <INDENT> if be2 * af1 >= be1 * af2 : <NEWLINE> <INDENT> ans = shinchan ( be1 , af1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = shinchan ( be2 , af2 ) <NEWLINE> <DEDENT> <DEDENT> elif key1 or key2 : <NEWLINE> <INDENT> if key1 : <NEWLINE> <INDENT> ans = shinchan ( be1 , af1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = shinchan ( be2 , af2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if zero > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> lis . sort ( key = lambda x : abs ( x ) ) <NEWLINE> ans = - shinchan ( 0 , 0 ) + 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> r = sum ( a ) <NEWLINE> for i in a [ : n - 1 ] : <NEWLINE> <INDENT> r = r - i <NEWLINE> ans = ( ans + i * r ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
str1 = [ 0 for i in range ( 10 ** 6 ) ] <NEWLINE> str1 [ 0 ] = 1 <NEWLINE> str1 [ 1 ] = 1 <NEWLINE> for i in range ( 2 , ( 10 ** 6 ) ) : <NEWLINE> <INDENT> if str1 [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( 2 , ( 10 ** 6 ) ) : <NEWLINE> <INDENT> if i * j >= len ( str1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> str1 [ i * j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if str1 [ i ] == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> res = 0 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> res = max ( res , count ) <NEWLINE> <NL> <DEDENT> print ( len ( t ) - res ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> if s in d : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> d = sorted ( d . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> m = d [ 0 ] [ 1 ] <NEWLINE> a = [ ] <NEWLINE> i = 0 <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if d [ i ] [ 1 ] == m : <NEWLINE> <INDENT> a . append ( d [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a . sort ( ) <NEWLINE> <NL> for aa in a : <NEWLINE> <INDENT> print ( aa ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a , d = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> x = [ 0 ] * m <NEWLINE> y = [ 0 ] * m <NEWLINE> z = [ 0 ] * m <NEWLINE> NumOfTerms = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] , z [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> NumOfTerms . append ( y [ i ] ) <NEWLINE> NumOfTerms . append ( z [ i ] ) <NEWLINE> <NL> <DEDENT> num = set ( NumOfTerms ) <NEWLINE> <NL> for i in num : <NEWLINE> <INDENT> A . append ( [ i , a + d * ( i - 1 ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ j ] [ 0 ] == y [ i ] : <NEWLINE> <INDENT> yj = j <NEWLINE> <DEDENT> if A [ j ] [ 0 ] == z [ i ] : <NEWLINE> <INDENT> zj = j <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = A [ yj ] [ 1 ] <NEWLINE> A [ yj ] [ 1 ] = A [ zj ] [ 1 ] <NEWLINE> A [ zj ] [ 1 ] = tmp <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ j ] [ 0 ] == y [ i ] : <NEWLINE> <INDENT> yj = j <NEWLINE> <DEDENT> if A [ j ] [ 0 ] == z [ i ] : <NEWLINE> <INDENT> zj = j <NEWLINE> <DEDENT> <DEDENT> A [ yj ] [ 1 ] = A [ zj ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> for j in range ( len ( num ) ) : <NEWLINE> <INDENT> if A [ j ] [ 0 ] == k : <NEWLINE> <INDENT> print ( A [ j ] [ 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a + d * ( k - 1 ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> height_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = { } <COMMENT> <NEWLINE> R = { } <COMMENT> <NEWLINE> for i , Ai in enumerate ( height_list ) : <NEWLINE> <INDENT> l = i + Ai <NEWLINE> if ( l not in L . keys ( ) ) : <NEWLINE> <INDENT> L [ l ] = 0 <NEWLINE> <DEDENT> L [ l ] += 1 <NEWLINE> <NL> r = i - Ai <NEWLINE> if ( r not in R . keys ( ) ) : <NEWLINE> <INDENT> R [ r ] = 0 <NEWLINE> <DEDENT> R [ r ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for l_key in L . keys ( ) : <NEWLINE> <INDENT> if ( l_key in R . keys ( ) ) : <NEWLINE> <INDENT> count += L [ l_key ] * R [ l_key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * 13 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> dp = [ sum ( dp [ 4 * ( j - k ) % 13 ] for k in range ( 10 ) ) % mod for j in range ( 13 ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( S [ i ] ) <NEWLINE> dp = [ dp [ 4 * ( j - a ) % 13 ] % mod for j in range ( 13 ) ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 5 ] ) <NEWLINE>
import heapq as hq <NEWLINE> <NL> def relax ( u , v , w ) : <NEWLINE> <INDENT> if D [ u ] + w < D [ v ] : <NEWLINE> <INDENT> D [ v ] = D [ u ] + w <NEWLINE> P [ v ] = u <NEWLINE> hq . heappush ( H , ( D [ v ] , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> INF = float ( <STRING> ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = [ INF for i in range ( N ) ] <NEWLINE> P = [ None for i in range ( N ) ] <NEWLINE> D [ 0 ] = 0 <NEWLINE> <NL> G = [ { } for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = x [ 2 : ] <NEWLINE> for j , n in enumerate ( g ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> G [ i ] [ n ] = g [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> H = [ ( 0 , 0 ) ] <NEWLINE> <NL> while 0 < len ( H ) : <NEWLINE> <INDENT> d_u , u = hq . heappop ( H ) <NEWLINE> for v , w in G [ u ] . items ( ) : <NEWLINE> <INDENT> relax ( u , v , w ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , d in enumerate ( D ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , d ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <COMMENT> <NEWLINE> <NL> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = ( j - i ) + j <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = N // 15 <NEWLINE> P = [ 1 , 2 , 4 , 7 , 8 , 11 , 13 , 14 ] <NEWLINE> P2 = [ 3 , 5 , 6 , 9 , 10 , 12 ] <NEWLINE> Q = 0 <NEWLINE> D = 0 <NEWLINE> if S == 0 : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in P2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = D + i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> T = S - 1 <NEWLINE> D = ( 60 + 60 + 15 * T * 8 ) * S // 2 <NEWLINE> N1 = N - 15 * S <NEWLINE> for i in range ( 1 , N1 + 1 ) : <NEWLINE> <INDENT> if i in P2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = D + i + 15 * S <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( D ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Aset = set ( A ) <NEWLINE> lst = { } <NEWLINE> for i in Aset : <NEWLINE> <INDENT> lst [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> lst [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans_init = 0 <NEWLINE> for i in lst : <NEWLINE> <INDENT> ans_init += i * lst [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans_pm = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if B in lst : <NEWLINE> <COMMENT> <NL> <INDENT> Bnum = lst [ B ] <NEWLINE> <COMMENT> <NL> if C in lst : <NEWLINE> <INDENT> lst [ C ] += lst [ B ] <NEWLINE> lst . pop ( B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ C ] = lst [ B ] <NEWLINE> lst . pop ( B ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans_pm += Bnum * ( C - B ) <NEWLINE> ans . append ( ans_init + ans_pm ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ans_init + ans_pm ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> j = input ( ) <NEWLINE> if j == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif j == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif j == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . sort ( reverse = True ) <NEWLINE> <NL> if len ( h ) <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del h [ 0 : k ] <NEWLINE> <NL> <DEDENT> a = sum ( h ) <NEWLINE> <NL> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a = sorted ( a , reverse = True ) <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if ( len ( str ( i ) ) + len ( str ( ans ) ) > 20 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans *= i <NEWLINE> <NL> <DEDENT> print ( ans if ( ans <= pow ( 10 , 18 ) ) else - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = max ( a ) <NEWLINE> ok = [ 0 ] * ( M + 1 ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ok [ a [ i ] ] += 1 <NEWLINE> if ok [ a [ i ] ] == 1 : <NEWLINE> <INDENT> for g in range ( a [ i ] , M + 1 , a [ i ] ) : <NEWLINE> <INDENT> if g != a [ i ] : <NEWLINE> <INDENT> ok [ g ] += 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ok . count ( 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += A [ N - 1 - i // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> dp = [ 0 ] * a [ - 1 ] <NEWLINE> c = Counter ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , a [ - 1 ] + 1 , i ) : <NEWLINE> <INDENT> dp [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if dp [ i - 1 ] == 1 and c [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def waru ( a , b ) : <NEWLINE> <INDENT> if a % b != 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if a / b == 1 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return waru ( a / b , b ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = [ ] <NEWLINE> read = stdin . readline <NEWLINE> N = int ( read ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> ap = table . append <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> while N % i == 0 : <NEWLINE> <INDENT> ap ( i ) <NEWLINE> N //= i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if N > 1 : <NEWLINE> <INDENT> ap ( N ) <NEWLINE> <DEDENT> set_table = sorted ( list ( set ( table ) ) ) <NEWLINE> kaisu = [ 0 ] * len ( set_table ) <NEWLINE> num = 0 <NEWLINE> for i in table : <NEWLINE> <INDENT> if i == set_table [ num ] : <NEWLINE> <INDENT> kaisu [ num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += 1 <NEWLINE> kaisu [ num ] += 1 <NEWLINE> <DEDENT> <DEDENT> maxk = max ( kaisu ) <NEWLINE> j = 1 <NEWLINE> k = 0 <NEWLINE> count = 0 <NEWLINE> while j <= maxk : <NEWLINE> <INDENT> count += len ( [ i for i in kaisu if i >= j ] ) <NEWLINE> k += 1 <NEWLINE> j = j + k + 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> s = input ( ) <NEWLINE> <NL> l = [ int ( s [ - 1 ] ) ] <NEWLINE> d = 10 <NEWLINE> for i in range ( len ( s ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> l . append ( ( l [ - 1 ] + int ( s [ i ] ) * d ) % 2019 ) <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <DEDENT> c = collections . Counter ( l ) <NEWLINE> ans = 0 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> ans += c [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def solve ( N , A ) : <NEWLINE> <INDENT> def osa_k_construct ( n_max ) : <NEWLINE> <INDENT> min_factor = np . arange ( n_max + 1 ) <NEWLINE> for i in range ( 2 , int ( n_max ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if min_factor [ i ] == i : <NEWLINE> <INDENT> for j in range ( i * i , n_max + 1 , i ) : <NEWLINE> <INDENT> if min_factor [ j ] == j : <NEWLINE> <INDENT> min_factor [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return min_factor <NEWLINE> <NL> <DEDENT> def osa_k_factorize ( min_factor , n ) : <NEWLINE> <INDENT> min_factor = min_factor <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> res = [ 0 ] * 0 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> p = min_factor [ n ] <NEWLINE> res . append ( p ) <NEWLINE> n //= p <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> osa_k = osa_k_construct ( 1010101 ) <NEWLINE> Factors = [ osa_k_factorize ( osa_k , a ) for a in A ] <NEWLINE> factors = Factors [ 0 ] <NEWLINE> st0 = set ( factors ) <COMMENT> <NEWLINE> st1 = set ( factors ) <COMMENT> <NEWLINE> pairwise = True <NEWLINE> for factors in Factors [ 1 : ] : <NEWLINE> <INDENT> st = set ( factors ) <NEWLINE> for f in st : <NEWLINE> <INDENT> if f in st1 : <NEWLINE> <INDENT> pairwise = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st1 . add ( f ) <NEWLINE> <DEDENT> <DEDENT> st0 &= st <NEWLINE> <DEDENT> if pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif not st0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ solve , <STRING> ] <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> solve ( N , A ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> <NL> for n in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ n ] == A [ n + 1 ] : <NEWLINE> <INDENT> A [ n + 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ n ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> A = sorted ( A ) [ : : - 1 ] <NEWLINE> print ( A [ 0 ] * A [ 1 ] ) <NEWLINE>
import copy <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( p [ : k ] ) <NEWLINE> smax = copy . deepcopy ( s ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> s += p [ i + k ] - p [ i ] <NEWLINE> smax = max ( smax , s ) <NEWLINE> <NL> <DEDENT> print ( ( smax + k ) / 2 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> class WeightedUnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . nodes = [ i for i in range ( n ) ] <NEWLINE> self . weights = [ 0 for _ in range ( n ) ] <NEWLINE> self . size = [ 1 for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def connected ( self , i , j ) : <NEWLINE> <INDENT> wi , ri = self . root ( i ) <NEWLINE> wj , rj = self . root ( j ) <NEWLINE> return ri == rj <NEWLINE> <NL> <DEDENT> def union ( self , i , j , w ) : <NEWLINE> <INDENT> wi , ri = self . root ( i ) <NEWLINE> wj , rj = self . root ( j ) <NEWLINE> if ri == rj : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . size [ ri ] < self . size [ rj ] : <NEWLINE> <INDENT> self . nodes [ ri ] = rj <NEWLINE> self . weights [ ri ] = wj - wi + w <NEWLINE> self . size [ rj ] += self . size [ ri ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . nodes [ rj ] = ri <NEWLINE> self . weights [ rj ] = wi - wj - w <NEWLINE> self . size [ ri ] += self . size [ rj ] <NEWLINE> <NL> <DEDENT> <DEDENT> def weight ( self , i , j ) : <NEWLINE> <INDENT> wi , ri = self . root ( i ) <NEWLINE> wj , rj = self . root ( j ) <NEWLINE> if ri != rj : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( i , j ) ) <NEWLINE> <NL> <DEDENT> return wi - wj <NEWLINE> <NL> <DEDENT> def root ( self , i ) : <NEWLINE> <INDENT> r = self . nodes [ i ] <NEWLINE> w = self . weights [ i ] <NEWLINE> while r != self . nodes [ r ] : <NEWLINE> <INDENT> w += self . weights [ r ] <NEWLINE> r = self . nodes [ r ] <NEWLINE> <DEDENT> return w , r <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> n , q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> wuf = WeightedUnionFind ( n ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> com , * args = input ( ) . split ( ) <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> wuf . union ( * [ int ( i ) for i in args ] ) <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in args ] <NEWLINE> if wuf . connected ( x , y ) : <NEWLINE> <INDENT> print ( wuf . weight ( x , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> c = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def egcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b , 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g , y , x = egcd ( b % a , a ) <NEWLINE> return g , x - ( b // a ) * y , y <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def modinv ( a , m ) : <NEWLINE> <INDENT> g , x , y = egcd ( a , m ) <NEWLINE> if g != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x % m <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> inv = modinv ( 2 , c ) <NEWLINE> <NL> sum_of_a = sum ( A_list ) % c <NEWLINE> sum_of_sq_a = sum ( [ i ** 2 for i in A_list ] ) % c <NEWLINE> <NL> ans = ( sum_of_a ** 2 % c - sum_of_sq_a ) * inv % c <NEWLINE> <NL> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <COMMENT> <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <DEDENT> <DEDENT> def union ( self , x , y ) : <COMMENT> <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <DEDENT> def size ( self , x ) : <COMMENT> <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <DEDENT> def same ( self , x , y ) : <COMMENT> <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <DEDENT> def members ( self , x ) : <COMMENT> <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <DEDENT> def roots ( self ) : <COMMENT> <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <DEDENT> def group_count ( self ) : <COMMENT> <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <DEDENT> def all_group_members ( self ) : <COMMENT> <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <DEDENT> def __str__ ( self ) : <COMMENT> <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> suggest = UnionFind ( n ) <NEWLINE> follow = [ 0 ] * n <NEWLINE> block = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> follow [ i ] = list ( ) <NEWLINE> block [ i ] = list ( ) <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> suggest . union ( a , b ) <NEWLINE> follow [ a ] . append ( b ) <NEWLINE> follow [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c -= 1 <NEWLINE> d -= 1 <NEWLINE> block [ c ] . append ( d ) <NEWLINE> block [ d ] . append ( c ) <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> suggestfriend = [ 0 ] * n <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> blockperson = 0 <NEWLINE> union = suggest . size ( i ) <NEWLINE> for j in range ( len ( block [ i ] ) ) : <NEWLINE> <INDENT> if ( suggest . same ( i , block [ i ] [ j ] ) ) : <NEWLINE> <INDENT> blockperson += 1 <NEWLINE> <DEDENT> <DEDENT> ans += str ( union - blockperson - len ( follow [ i ] ) - 1 ) + <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> s = input ( ) <NEWLINE> k = [ 0 ] * 6 <NEWLINE> t = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> i = 0 <NEWLINE> if <STRING> in s [ 1 : ] : <NEWLINE> <INDENT> i = 1 + s [ 1 : ] . index ( <STRING> ) <NEWLINE> <DEDENT> if <STRING> in s [ 1 : ] : <NEWLINE> <INDENT> if i > 0 : i = min ( i , 1 + s [ 1 : ] . index ( <STRING> ) ) <NEWLINE> else : i = 1 + s [ 1 : ] . index ( <STRING> ) <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> k [ 0 ] = int ( s ) <NEWLINE> break <NEWLINE> <DEDENT> j = s . index ( <STRING> ) <NEWLINE> if j + 3 == i : <NEWLINE> <INDENT> if j == 0 : k [ int ( s [ j + 2 ] ) ] = 1 <NEWLINE> else : k [ int ( s [ j + 2 ] ) ] = int ( s [ : j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j == 0 : k [ 1 ] = 1 <NEWLINE> elif j == 1 : k [ 1 ] = int ( s [ 0 ] + <STRING> ) <NEWLINE> else : k [ 1 ] = int ( s [ : j ] ) <NEWLINE> <DEDENT> s = s [ i : ] <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if k [ - 1 ] == 0 : k . pop ( ) <NEWLINE> else : break <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> i = 1 <NEWLINE> while i <= abs ( k [ 0 ] ) : <NEWLINE> <INDENT> if k [ 0 ] % i == 0 : <NEWLINE> <INDENT> j = k [ 0 ] // i <NEWLINE> kn = copy . deepcopy ( k ) <NEWLINE> for l in range ( len ( kn ) - 1 ) : <NEWLINE> <INDENT> if kn [ l ] % j == 0 : <NEWLINE> <INDENT> kn [ l + 1 ] -= kn [ l ] // j <NEWLINE> kn [ l ] //= j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if kn [ - 1 ] == 0 : <NEWLINE> <INDENT> kn . pop ( ) <NEWLINE> t . append ( j ) <NEWLINE> k = copy . deepcopy ( kn ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> j *= - 1 <NEWLINE> kn = copy . deepcopy ( k ) <NEWLINE> for l in range ( len ( kn ) - 1 ) : <NEWLINE> <INDENT> if kn [ l ] % j == 0 : <NEWLINE> <INDENT> kn [ l + 1 ] -= kn [ l ] // j <NEWLINE> kn [ l ] //= j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if kn [ - 1 ] == 0 : <NEWLINE> <INDENT> kn . pop ( ) <NEWLINE> t . append ( j ) <NEWLINE> k = copy . deepcopy ( kn ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if len ( k ) == 2 : <NEWLINE> <INDENT> t . append ( k [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> t . sort ( ) <NEWLINE> s = <STRING> <NEWLINE> for i in t : s += <STRING> . format ( i ) if i < 0 else <STRING> . format ( i ) <NEWLINE> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> n = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] == S [ k ] or S [ j ] == S [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> p , m = i , i + 1 <NEWLINE> break <NEWLINE> <DEDENT> elif x [ i ] > 0 : <NEWLINE> <INDENT> p , m = i , i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( x [ 0 ] < 0 ) and ( x [ - 1 ] > 0 ) : <NEWLINE> <INDENT> pls = x [ p : ] <NEWLINE> mns = x [ : m ] <NEWLINE> ans = math . inf <NEWLINE> <NL> for i in range ( len ( pls ) ) : <NEWLINE> <INDENT> if i < K - 1 : <NEWLINE> <INDENT> if pls [ 0 ] == 0 : <NEWLINE> <INDENT> n = K - i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = K - i - 1 <NEWLINE> <DEDENT> if len ( mns ) >= n : <NEWLINE> <INDENT> tmp = 2 * abs ( mns [ - n ] ) + pls [ i ] <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> ans = min ( ans , pls [ i ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( mns ) ) : <NEWLINE> <INDENT> m = len ( mns ) - i <NEWLINE> if m < K : <NEWLINE> <INDENT> if pls [ 0 ] == 0 : <NEWLINE> <INDENT> n = K - m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = K - m - 1 <NEWLINE> <DEDENT> if len ( pls ) > n : <NEWLINE> <INDENT> tmp = 2 * pls [ n ] + abs ( mns [ - m ] ) <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> if m == K : <NEWLINE> <INDENT> ans = min ( ans , abs ( mns [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif x [ 0 ] >= 0 : <NEWLINE> <INDENT> ans = x [ K - 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( x [ - K ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys , bisect <NEWLINE> <NL> from sys import stdin , stdout <NEWLINE> <NL> from bisect import bisect_left , bisect_right , bisect , insort , insort_left , insort_right <NEWLINE> <NL> from math import gcd , ceil , floor , sqrt <NEWLINE> <NL> from collections import Counter , defaultdict , deque , OrderedDict <NEWLINE> <NL> from queue import Queue , PriorityQueue <NEWLINE> <NL> from string import ascii_lowercase <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 998244353 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def isPrime ( n ) : <NEWLINE> <NL> <INDENT> if ( n <= 1 ) : return False <NEWLINE> if ( n <= 3 ) : return True <NEWLINE> if ( n % 2 == 0 or n % 3 == 0 ) : return False <NEWLINE> for i in range ( 5 , ceil ( sqrt ( n ) ) + 1 , 6 ) : <NEWLINE> <INDENT> if ( n % i == 0 or n % ( i + 2 ) == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def st ( ) : <NEWLINE> <INDENT> return list ( stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <DEDENT> def inp ( ) : <NEWLINE> <INDENT> return int ( stdin . readline ( ) ) <NEWLINE> <NL> <DEDENT> def li ( ) : <NEWLINE> <INDENT> return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def mp ( ) : <NEWLINE> <INDENT> return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def pr ( n ) : <NEWLINE> <INDENT> stdout . write ( str ( n ) + <STRING> ) <NEWLINE> <NL> <DEDENT> def DFS ( dictionary , vertex , visited ) : <NEWLINE> <INDENT> visited [ vertex ] = True <NEWLINE> stack = [ vertex ] <NEWLINE> print ( vertex ) <NEWLINE> while stack : <NEWLINE> <INDENT> a = stack . pop ( ) <NEWLINE> for i in dictionary [ a ] : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> visited [ i ] = True <NEWLINE> stack . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def BFS ( dictionary , vertex , visited ) : <NEWLINE> <INDENT> visited [ vertex ] = True <NEWLINE> q = deque ( ) <NEWLINE> q . append ( vertex ) <NEWLINE> while q : <NEWLINE> <INDENT> a = q . popleft ( ) <NEWLINE> for i in dictionary [ a ] : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> visited [ i ] = True <NEWLINE> q . append ( i ) <NEWLINE> print ( i ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def soe ( limit ) : <NEWLINE> <INDENT> l = [ 1 ] * ( limit + 1 ) <NEWLINE> l [ 0 ] = 0 <NEWLINE> l [ 1 ] = 0 <NEWLINE> prime = [ ] <NEWLINE> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , limit + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def segsoe ( low , high ) : <NEWLINE> <INDENT> limit = int ( high ** 0.5 ) + 1 <NEWLINE> prime = soe ( limit ) <NEWLINE> n = high - low + 1 <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> lowlimit = ( low // prime [ i ] ) * prime [ i ] <NEWLINE> if lowlimit < low : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> if lowlimit == prime [ i ] : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> for j in range ( lowlimit , high + 1 , prime [ i ] ) : <NEWLINE> <INDENT> l [ j - low ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( low , high + 1 ) : <NEWLINE> <INDENT> if not l [ i - low ] : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a = a % b <NEWLINE> b , a = a , b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def power ( a , n ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> r = ( r * a ) <NEWLINE> <DEDENT> a *= a <NEWLINE> n = n >> 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> s = sum ( list ( map ( int , str ( n ) ) ) ) <NEWLINE> if s % 9 == 0 : <NEWLINE> <INDENT> pr ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pr ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> for _ in range ( 1 ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> buf = N - i * j <NEWLINE> if buf > 0 : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import copy <NEWLINE> <NL> def partition ( p , r ) : <NEWLINE> <INDENT> i = p <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ r ] [ 1 ] >= A [ j ] [ 1 ] : <NEWLINE> <INDENT> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> A [ r ] , A [ i ] = A [ i ] , A [ r ] <NEWLINE> return i <NEWLINE> <NL> <DEDENT> def quick_sort ( p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( p , r ) <NEWLINE> quick_sort ( p , q - 1 ) <NEWLINE> quick_sort ( q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def correct_same_num_suits ( l , num , first , ele_cnt ) : <NEWLINE> <INDENT> suits = [ ] <NEWLINE> for i in range ( first , N ) : <NEWLINE> <INDENT> if num == l [ i ] [ 1 ] : <NEWLINE> <INDENT> suits . append ( l [ i ] [ 0 ] ) <NEWLINE> <DEDENT> if ele_cnt == len ( suits ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return suits <NEWLINE> <NL> <DEDENT> def is_stable ( ) : <NEWLINE> <INDENT> idx = 0 <NEWLINE> while idx < N - 1 : <NEWLINE> <INDENT> idx_incr_flg = True <NEWLINE> if A [ idx ] [ 1 ] == A [ idx + 1 ] [ 1 ] : <NEWLINE> <INDENT> num = A [ idx ] [ 1 ] <NEWLINE> j = idx <NEWLINE> ele_cnt = 0 <NEWLINE> while j < N and num == A [ j ] [ 1 ] : <NEWLINE> <INDENT> ele_cnt += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> sorted_suits = correct_same_num_suits ( A , num , idx , ele_cnt ) <NEWLINE> orig_suits = correct_same_num_suits ( orig_list , num , 0 , ele_cnt ) <NEWLINE> if sorted_suits != orig_suits : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> idx += len ( sorted_suits ) <NEWLINE> idx_incr_flg = False <NEWLINE> <DEDENT> if idx_incr_flg : <NEWLINE> <INDENT> idx += 1 <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> suit , num = input ( ) . split ( ) <NEWLINE> num = int ( num ) <NEWLINE> A . append ( [ suit , num ] ) <NEWLINE> <DEDENT> orig_list = copy . deepcopy ( A ) <NEWLINE> <NL> quick_sort ( 0 , N - 1 ) <NEWLINE> <NL> is_stable = is_stable ( ) <NEWLINE> if is_stable : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for card in A : <NEWLINE> <INDENT> print ( <STRING> % ( card [ 0 ] , card [ 1 ] ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visit = [ - 1 ] * n <COMMENT> <NEWLINE> <NL> D = [ 1 ] <COMMENT> <NEWLINE> <NL> tmp = A [ 0 ] <COMMENT> <NEWLINE> ct = 1 <NEWLINE> <NL> while visit [ tmp - 1 ] == - 1 : <NEWLINE> <INDENT> D . append ( tmp ) <NEWLINE> visit [ tmp - 1 ] = ct <COMMENT> <NEWLINE> if k == ct : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ct += 1 <NEWLINE> tmp = A [ tmp - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> k -= visit [ tmp - 1 ] <NEWLINE> k %= ( ct - visit [ tmp - 1 ] ) <NEWLINE> print ( D [ visit [ tmp - 1 ] + k ] ) <NEWLINE>
n , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( x * x ) + ( y * y ) > d * d : <NEWLINE> <NL> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = input ( ) . split ( <STRING> ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l [ int ( d [ i ] ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> sets = dict ( ) <NEWLINE> <NL> def gcd2 ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> key = ( b , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = ( a , b ) <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <COMMENT> <NL> <INDENT> return sets [ key ] <NEWLINE> <DEDENT> except : <NEWLINE> <COMMENT> <NL> <INDENT> ans = math . gcd ( a , b ) <NEWLINE> sets [ key ] = ans <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pre = gcd2 ( i , j ) <NEWLINE> <NL> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd2 ( pre , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def barr ( n ) : return [ False for _ in range ( n ) ] <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MOD = 10 ** 9 + 7 ; EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> <NL> n = iinput ( ) <NEWLINE> a = iarr ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for num in a : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 10 ** 18 : ans = - 1 ; break <NEWLINE> <DEDENT> if 0 in a : ans = 0 <NEWLINE> print ( ans ) <NEWLINE> <NL>
import copy as cp <NEWLINE> <COMMENT> <NL> D = int ( input ( ) ) <NEWLINE> c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> new = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s . append ( new ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def score ( ans ) : <NEWLINE> <INDENT> if len ( ans ) != D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> last = [ - 1 ] * 26 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> contest = ans [ i ] - 1 <NEWLINE> p += s [ i ] [ contest ] <NEWLINE> last [ contest ] = i <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> p -= c [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> <DEDENT> def greedy ( ahead = 0 ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> p = 0 <NEWLINE> last = [ - 1 ] * 26 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> decay = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> decay -= c [ j ] * ( i - last [ j ] ) <NEWLINE> <NL> <DEDENT> max_j = - 1 <NEWLINE> max_plus = decay <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> plus = s [ i ] [ j ] + c [ j ] * ( i - last [ j ] ) + c [ j ] * ( ahead * ( i - last [ j ] ) + ahead * ( ahead + 1 ) // 2 ) <NEWLINE> if plus > max_plus : <NEWLINE> <INDENT> max_plus = plus <NEWLINE> max_j = j <NEWLINE> <DEDENT> <DEDENT> ans . append ( max_j + 1 ) <NEWLINE> last [ max_j ] = i <NEWLINE> p += max_plus + decay - c [ max_j ] * ahead <NEWLINE> <DEDENT> return ans , p <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> max_points = - 10000000 <NEWLINE> for k in range ( 20 ) : <NEWLINE> <INDENT> ans_temp , points = greedy ( ahead = k ) <NEWLINE> if points > max_points : <NEWLINE> <INDENT> max_points = points <NEWLINE> ans = cp . copy ( ans_temp ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hight = [ 0 ] * h <NEWLINE> width = [ 0 ] * w <NEWLINE> S = set ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> hi , wi = map ( int , input ( ) . split ( ) ) <NEWLINE> S . add ( ( hi - 1 , wi - 1 ) ) <NEWLINE> hight [ hi - 1 ] += 1 <NEWLINE> width [ wi - 1 ] += 1 <NEWLINE> <NL> <DEDENT> max_vh = max ( hight ) <NEWLINE> max_vw = max ( width ) <NEWLINE> <NL> max_h = [ i for i in range ( h ) if hight [ i ] == max_vh ] <NEWLINE> max_w = [ i for i in range ( w ) if width [ i ] == max_vw ] <NEWLINE> for i in max_h : <NEWLINE> <INDENT> for j in max_w : <NEWLINE> <INDENT> if not ( i , j ) in S : <NEWLINE> <INDENT> print ( max_vh + max_vw ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_vh + max_vw - 1 ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Etop = 0 <NEWLINE> E = 0 <NEWLINE> q = [ ] <NEWLINE> Ruiseki = 0 <NEWLINE> S = [ ] <NEWLINE> Top = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> q . append ( ( i + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> for E in q : <NEWLINE> <INDENT> Ruiseki += E <NEWLINE> S . append ( Ruiseki ) <NEWLINE> <NL> <DEDENT> if N == K : <NEWLINE> <INDENT> print ( S [ N - 1 ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( N - K ) : <NEWLINE> <INDENT> Sig = S [ K + j ] - S [ j ] <NEWLINE> if Sig > Top : <NEWLINE> <INDENT> Top = Sig <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Top ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acum1 = [ 0 ] <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> acum1 . append ( acum1 [ - 1 ] + arr1 [ i ] ) <NEWLINE> <DEDENT> acum2 = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> acum2 . append ( acum2 [ - 1 ] + arr2 [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acum1 [ i ] > k : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while acum2 [ j ] > k - acum1 [ i ] and j > 0 : <COMMENT> <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for val in a : <NEWLINE> <INDENT> if val == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for val in a : <NEWLINE> <INDENT> ans *= val <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> p = 1000000007 <NEWLINE> S = 0 <NEWLINE> Asq = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> S += x % ( 2 * p ) <NEWLINE> Asq += ( x * x ) % ( 2 * p ) <NEWLINE> <DEDENT> t = ( ( S * S ) % ( 2 * p ) - Asq ) % ( 2 * p ) <NEWLINE> print ( int ( t / 2 ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
T = input ( ) <NEWLINE> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> for j in range ( 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a , b = i , j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1000 ) : <NEWLINE> <INDENT> for l in range ( 1000 ) : <NEWLINE> <INDENT> if k ** 5 + l ** 5 == x : <NEWLINE> <INDENT> a , b = k , ( - 1 ) * l <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> if X == D : <NEWLINE> <INDENT> if K == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif X < D : <NEWLINE> <INDENT> if K == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( D - X ) ) <NEWLINE> <DEDENT> <DEDENT> elif X > K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <NL> <DEDENT> elif X // D < K : <NEWLINE> <INDENT> K = K - X // D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X % D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( D - X % D ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 0 <NEWLINE> ret_M = [ ] <NEWLINE> memo_N = [ 0 ] * N <COMMENT> <NEWLINE> for i in range ( N ) [ : : - 1 ] : <NEWLINE> <INDENT> i_ = i + 1 <NEWLINE> q = N // i_ <NEWLINE> s = sum ( memo_N [ i_ * ( d + 1 ) - 1 ] for d in range ( 1 , q ) ) <NEWLINE> memo_N [ i ] = ( s % 2 ) ^ A [ i ] <NEWLINE> if memo_N [ i ] : <NEWLINE> <INDENT> M += 1 <NEWLINE> ret_M . append ( i_ ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( M ) <NEWLINE> if M : print ( <STRING> . join ( map ( str , ret_M [ : : - 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> d = list ( input ( ) ) <NEWLINE> alp = [ chr ( i ) for i in range ( 65 , 65 + 26 ) ] <NEWLINE> <NL> for x in range ( len ( d ) ) : <NEWLINE> <INDENT> idx = alp . index ( d [ x ] ) - 3 <NEWLINE> if idx < 0 : <NEWLINE> <INDENT> idx = 26 + idx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> d [ x ] = alp [ idx ] <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for x in d : <NEWLINE> <INDENT> ans += x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin , stdout <NEWLINE> <NL> import bisect <NEWLINE> <NL> import math <NEWLINE> <NL> def st ( ) : <NEWLINE> <INDENT> return list ( stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <DEDENT> def inp ( ) : <NEWLINE> <INDENT> return int ( stdin . readline ( ) ) <NEWLINE> <NL> <DEDENT> def li ( ) : <NEWLINE> <INDENT> return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def mp ( ) : <NEWLINE> <INDENT> return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def pr ( n ) : <NEWLINE> <INDENT> stdout . write ( str ( n ) + <STRING> ) <NEWLINE> <NL> <DEDENT> def soe ( limit ) : <NEWLINE> <INDENT> l = [ 1 ] * ( limit + 1 ) <NEWLINE> prime = [ ] <NEWLINE> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , limit + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def segsoe ( low , high ) : <NEWLINE> <INDENT> limit = int ( high ** 0.5 ) + 1 <NEWLINE> prime = soe ( limit ) <NEWLINE> n = high - low + 1 <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> lowlimit = ( low // prime [ i ] ) * prime [ i ] <NEWLINE> if lowlimit < low : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> if lowlimit == prime [ i ] : <NEWLINE> <INDENT> lowlimit += prime [ i ] <NEWLINE> <DEDENT> for j in range ( lowlimit , high + 1 , prime [ i ] ) : <NEWLINE> <INDENT> l [ j - low ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( low , high + 1 ) : <NEWLINE> <INDENT> if not l [ i - low ] : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a = a % b <NEWLINE> b , a = a , b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def power ( a , n ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> r = ( r * a ) <NEWLINE> <DEDENT> a *= a <NEWLINE> n = n >> 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def check ( n , s ) : <NEWLINE> <INDENT> v = str ( n ) <NEWLINE> for i in v : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> s = input ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( l ) > 0 : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> for _ in range ( 1 ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
import numpy <NEWLINE> H , W , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> width = numpy . array ( [ 0 ] * W , dtype = <STRING> ) <NEWLINE> height = numpy . array ( [ 0 ] * H , dtype = <STRING> ) <NEWLINE> <NL> obj = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> width [ w ] += 1 <NEWLINE> height [ h ] += 1 <NEWLINE> obj . add ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> result_h = set ( numpy . where ( height == numpy . max ( height ) ) [ 0 ] ) <NEWLINE> result_w = set ( numpy . where ( width == numpy . max ( width ) ) [ 0 ] ) <NEWLINE> <NL> if len ( result_h ) * len ( result_w ) > M : <NEWLINE> <INDENT> print ( numpy . max ( height ) + numpy . max ( width ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for h in result_h : <NEWLINE> <INDENT> for w in result_w : <NEWLINE> <INDENT> if not ( h , w ) in obj : <NEWLINE> <INDENT> print ( numpy . max ( height ) + numpy . max ( width ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( numpy . max ( height ) + numpy . max ( width ) - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dicts = { } <NEWLINE> for tmp in a : <NEWLINE> <INDENT> if tmp in dicts . keys ( ) : <NEWLINE> <INDENT> dicts [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dicts [ tmp ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for key , value in dicts . items ( ) : <NEWLINE> <INDENT> result += key * value <NEWLINE> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if b in dicts . keys ( ) : <NEWLINE> <INDENT> tmp = dicts [ b ] <NEWLINE> diff = dicts [ b ] * b <NEWLINE> add = tmp * c <NEWLINE> <NL> del dicts [ b ] <NEWLINE> if c in dicts . keys ( ) : <NEWLINE> <INDENT> dicts [ c ] += tmp <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> dicts [ c ] = tmp <NEWLINE> <NL> <DEDENT> result -= diff <NEWLINE> result += add <NEWLINE> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> loop = [ 0 ] * n <NEWLINE> <NL> <NL> if ( 2 not in a ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> tar_index = 0 <NEWLINE> loop [ 0 ] = 1 <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> tar_index = a [ tar_index ] - 1 <NEWLINE> <COMMENT> <NL> count += 1 <NEWLINE> <NL> if ( tar_index == 1 ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if ( loop [ tar_index ] == 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> loop [ tar_index ] = 1 <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = deque ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> B = deque ( ) <NEWLINE> cycle = n % 2 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cycle % 2 == 1 : <NEWLINE> <INDENT> B . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> cycle += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( B ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 998244353 <NEWLINE> dp = [ 0 for i in range ( N ) ] <NEWLINE> sdp = [ 0 for i in range ( N ) ] <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> sdp [ 0 ] = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> dp [ i ] += ( sdp [ max ( i - L [ j ] , - 1 ) ] - sdp [ max ( i - R [ j ] - 1 , - 1 ) ] ) <NEWLINE> dp [ i ] %= x <NEWLINE> <DEDENT> sdp [ i ] = ( sdp [ i - 1 ] + dp [ i ] ) % x <NEWLINE> <DEDENT> print ( dp [ - 1 ] % x ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> <NL> dp = [ 0 ] * ( n + 10 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> cumsum = [ 0 ] * ( n + 10 ) <NEWLINE> cumsum [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for l , r in lr : <NEWLINE> <INDENT> if l >= i : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ll = max ( 1 , i - r ) <NEWLINE> rr = i - l <NEWLINE> if ll <= rr : <NEWLINE> <INDENT> dp [ i ] += cumsum [ rr ] - cumsum [ ll - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> <DEDENT> cumsum [ i ] = cumsum [ i - 1 ] + dp [ i ] <NEWLINE> cumsum [ i ] %= mod <NEWLINE> <NL> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from itertools import accumulate <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ( x + 1 ) / 2 for x in p ] <NEWLINE> <COMMENT> <NL> s = list ( accumulate ( s ) ) <NEWLINE> s . insert ( 0 , 0 ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , s [ i + k ] - s [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 5 * 2 ) <NEWLINE> <NL> def search ( u , n , g , disc , k ) : <NEWLINE> <INDENT> if disc [ u ] != None : <NEWLINE> <INDENT> circles = n - disc [ u ] <NEWLINE> v = ( k - disc [ u ] ) % circles <NEWLINE> ans = u <NEWLINE> if n > k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> ans = g [ ans ] <NEWLINE> <DEDENT> return ans + 1 <NEWLINE> <DEDENT> for i in range ( v ) : <NEWLINE> <INDENT> ans = g [ ans ] <NEWLINE> <DEDENT> return ans + 1 <NEWLINE> <DEDENT> disc [ u ] = n <NEWLINE> return search ( g [ u ] , n + 1 , g , disc , k ) <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> g = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> disc = [ None ] * n <NEWLINE> v = search ( 0 , 0 , g , disc , k ) <NEWLINE> print ( v ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> <NL> <NL> def Greedy ( arr ) : <NEWLINE> <NL> <INDENT> curr = 1000 <NEWLINE> for i in range ( len ( arr ) - 1 ) : <NEWLINE> <INDENT> if arr [ i + 1 ] > arr [ i ] : <NEWLINE> <INDENT> stocks = curr // arr [ i ] <NEWLINE> curr += ( arr [ i + 1 ] - arr [ i ] ) * stocks <NEWLINE> <DEDENT> <DEDENT> return curr <NEWLINE> <NL> <DEDENT> print ( Greedy ( arr ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NEWLINE>
idx = int ( input ( ) ) <NEWLINE> data = list ( input ( ) . split ( ) ) <NEWLINE> data_int = [ int ( i ) for i in data ] <NEWLINE> for j in range ( 1 , idx + 1 ) : <NEWLINE> <INDENT> if j == idx : <NEWLINE> <INDENT> print ( data_int [ - j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( data_int [ - j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from numba import jit <NEWLINE> import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> @ jit <NEWLINE> def nya ( N , K , h ) : <NEWLINE> <INDENT> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> value = math . inf <NEWLINE> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i - j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> value = min ( value , dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) ) <NEWLINE> <DEDENT> dp [ i ] = value <NEWLINE> <DEDENT> return ( dp [ N - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( nya ( N , K , h ) ) <NEWLINE>
import math <NEWLINE> from math import floor <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return floor ( A * x / B ) - A * floor ( x / B ) <NEWLINE> <DEDENT> print ( f ( min ( B - 1 , N ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <STRING> <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> l = n // 2 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> print ( i // 2 + 1 , l - i // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l + i // 2 + 1 , n - i // 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = n // 2 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> print ( i // 2 + 1 , l - i // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l + i // 2 + 2 , n - i // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = input ( ) . split ( ) <NEWLINE> if h == <STRING> and w == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( int ( h ) ) : <NEWLINE> <INDENT> for i in range ( int ( w ) ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> print ( s , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> k = 2 * ( N - 2 ) + 1 <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if ( i * j < N ) and ( i != j ) : <NEWLINE> <INDENT> a += 2 <NEWLINE> <DEDENT> elif ( i * j < N ) and ( i == j ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a + k ) <NEWLINE> <NL>
n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 10 ** 9 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> b , c = a [ i ] , a [ i + k - 1 ] <NEWLINE> ans = min ( ans , min ( abs ( b ) , abs ( c ) ) + abs ( b - c ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i . reverse ( ) <NEWLINE> <NL> for idx , val in enumerate ( i ) : <NEWLINE> <INDENT> if idx == N - 1 : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( val , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> def dijkstra_heap ( N , S , Smax , edge ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * ( 10 ** 4 * N ) <COMMENT> <NEWLINE> used = [ False ] * ( 10 ** 4 * N ) <NEWLINE> d [ S ] = 0 <NEWLINE> used [ S ] = True <NEWLINE> edgelist = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for w , a in edge [ 0 ] : <NEWLINE> <INDENT> v , sil = a // 10 ** 4 , a % 10 ** 4 <NEWLINE> if v == 0 and S + sil <= Smax : <NEWLINE> <INDENT> heapq . heappush ( edgelist , [ w , a + S ] ) <COMMENT> <NEWLINE> <DEDENT> elif v > 0 and S - sil >= 0 : <NEWLINE> <INDENT> heapq . heappush ( edgelist , [ w , v * 10 ** 4 + ( S - sil ) ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> while len ( edgelist ) : <NEWLINE> <COMMENT> <NL> <INDENT> min_w , min_a = heapq . heappop ( edgelist ) <NEWLINE> min_v , min_sil = min_a // 10 ** 4 , min_a % 10 ** 4 <NEWLINE> <COMMENT> <NL> if used [ min_a ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d [ min_a ] = min_w <NEWLINE> used [ min_a ] = True <NEWLINE> for w , a in edge [ min_v ] : <NEWLINE> <INDENT> v , sil = a // 10 ** 4 , a % 10 ** 4 <NEWLINE> if v == min_v and min_sil + sil <= Smax and not used [ a + min_sil ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , [ min_w + w , a + min_sil ] ) <NEWLINE> <DEDENT> elif v != min_v and min_sil - sil >= 0 and not used [ v * 10 ** 4 + ( min_sil - sil ) ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , [ min_w + w , v * 10 ** 4 + ( min_sil - sil ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> amax = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> amax = max ( amax , a ) <NEWLINE> edge [ u - 1 ] . append ( [ b , ( v - 1 ) * 10 ** 4 + a ] ) <NEWLINE> edge [ v - 1 ] . append ( [ b , ( u - 1 ) * 10 ** 4 + a ] ) <NEWLINE> <DEDENT> Smax = ( N - 1 ) * amax <NEWLINE> S = min ( S , Smax ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ i ] . append ( [ d , i * 10 ** 4 + c ] ) <NEWLINE> <DEDENT> D = dijkstra_heap ( N , S , Smax , edge ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans [ i ] = min ( D [ i * 10 ** 4 : ( i + 1 ) * 10 ** 4 ] ) <NEWLINE> <DEDENT> return ans [ 1 : ] <NEWLINE> <DEDENT> print ( * solve ( ) , sep = <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> s = len ( S ) <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> <NL> <NL> n = pow ( 26 , K , mod ) <NEWLINE> ans = n <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> n = n * 25 * ( s + i ) * pow ( 26 * ( i + 1 ) , - 1 , mod ) % mod <NEWLINE> ans = ( ans + n ) % mod <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ i for i in a if i != 1 ] <NEWLINE> ans = 1 <NEWLINE> if len ( b ) < 100 : <NEWLINE> <INDENT> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> ans *= b [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 10 ** 18 + 1 <NEWLINE> <DEDENT> if 0 in b : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans if ans <= 10 ** 18 else <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> def DFS ( v ) : <NEWLINE> <INDENT> if DP [ v ] == - 1 : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in G [ v ] : <NEWLINE> <INDENT> res = max ( res , DFS ( i ) + 1 ) <NEWLINE> <NL> <DEDENT> DP [ v ] = res <NEWLINE> <NL> <DEDENT> return DP [ v ] <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> DP = [ - 1 ] * N <NEWLINE> for v in range ( N ) : <NEWLINE> <INDENT> DFS ( v ) <NEWLINE> <NL> <DEDENT> print ( max ( DP ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> exit ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10 ** 4 + 1 ) ] <NEWLINE> for x in range ( 1 , 101 ) : <COMMENT> <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <COMMENT> <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <COMMENT> <NEWLINE> <INDENT> if ( m : = x * x + y * y + z * z + x * y + y * z + z * x ) <= n : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ m ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 0 , n - k ) : <NEWLINE> <INDENT> if a_list [ i ] < a_list [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = [ 0 ] * 100_001 <NEWLINE> value = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> x [ a ] += 1 <NEWLINE> value += a <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> value += ( c - b ) * x [ b ] <NEWLINE> x [ c ] += x [ b ] <NEWLINE> x [ b ] = 0 <NEWLINE> print ( value ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> v = [ ] <NEWLINE> vc = [ 0 ] * n <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if vc [ b ] > 0 : <NEWLINE> <INDENT> stop = v . index ( b ) <NEWLINE> break <NEWLINE> <DEDENT> v . append ( b ) <NEWLINE> vc [ b ] += 1 <NEWLINE> b = a [ b ] <NEWLINE> c += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> if k > stop : <NEWLINE> <INDENT> r = ( k - stop ) % ( c - stop ) <NEWLINE> print ( v [ stop + r ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( v [ k ] + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A [ a ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if A [ 1 ] == 0 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] % 1000000007 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> x = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> x += ( ( b [ j ] - 1 ) * b [ j ] / 2 ) <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> print ( int ( x - b [ a [ k ] - 1 ] + 1 ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ok = 10 ** 9 <COMMENT> <NEWLINE> ng = 0 <COMMENT> <NEWLINE> <NL> <NL> def solve ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res += ( A [ i ] - 1 ) // x <NEWLINE> <NL> <DEDENT> return res <= K <NEWLINE> <NL> <NL> <DEDENT> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if solve ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = set ( ) <NEWLINE> for i in range ( - 100 , 201 ) : <NEWLINE> <INDENT> s . add ( i ) <NEWLINE> <NL> <DEDENT> s = list ( s - p ) <NEWLINE> <NL> a = [ abs ( x - i ) for i in s ] <NEWLINE> print ( s [ a . index ( min ( a ) ) ] ) <NEWLINE>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def LI ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( stdin . readline ( ) ) <NEWLINE> <NL> a , b , n = LI ( ) <NEWLINE> <NL> m = min ( b - 1 , n ) <NEWLINE> print ( int ( a * m / b ) - a * int ( m / b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> z , w = [ ] , [ ] <NEWLINE> K = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z . append ( x ) <NEWLINE> w . append ( y ) <NEWLINE> <DEDENT> for j in range ( N - 2 ) : <NEWLINE> <INDENT> if z [ j ] == w [ j ] and z [ j + 1 ] == w [ j + 1 ] and z [ j + 2 ] == w [ j + 2 ] : <NEWLINE> <INDENT> K += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if K >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> if a [ count ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> for i in range ( count ) : <NEWLINE> <INDENT> print ( <STRING> % ( i + 1 ) + <STRING> % a [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s = input ( ) <NEWLINE> s_list = list ( s ) <NEWLINE> length = len ( s ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> o = [ ] <NEWLINE> x = deque ( sorted ( set ( s ) ) ) <NEWLINE> <NL> while len ( o ) < K : <NEWLINE> <INDENT> letter = x . popleft ( ) <NEWLINE> X = [ i for i , x in enumerate ( s_list ) if x == letter ] <NEWLINE> for i in X : <NEWLINE> <INDENT> for j in range ( i + 1 , length + 1 ) : <NEWLINE> <INDENT> if not s [ i : j ] in o : <NEWLINE> <INDENT> o . append ( s [ i : j ] ) <NEWLINE> <DEDENT> if j - 1 - i == 5 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> o . sort ( ) <NEWLINE> print ( o [ K - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> dum = ( s - ( i + j ) ) <NEWLINE> if dum < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dum <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = As [ 0 ] <NEWLINE> if 0 in As : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> result = result * As [ i + 1 ] <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if result <= 10 ** 18 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> maxh = 0 <NEWLINE> for gi in G [ i ] : <NEWLINE> <INDENT> maxh = max ( h [ gi ] , maxh ) <NEWLINE> <DEDENT> if maxh < h [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if li_a [ i ] > li_a [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> if li_a [ i - k ] < li_a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <NL> from math import gcd <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> memory = { } <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> temp = gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( temp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> maze = [ <STRING> * ( w + 4 ) ] <NEWLINE> maze . append ( <STRING> * ( w + 4 ) ) <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> maze . append ( <STRING> + input ( ) [ : - 1 ] + <STRING> ) <NEWLINE> <DEDENT> maze . append ( <STRING> * ( w + 4 ) ) <NEWLINE> maze . append ( <STRING> * ( w + 4 ) ) <NEWLINE> visited = [ [ - 1 ] * ( w + 4 ) for _ in range ( h + 4 ) ] <NEWLINE> for i in range ( h + 4 ) : <NEWLINE> <INDENT> for j in range ( w + 4 ) : <NEWLINE> <INDENT> if maze [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> visited [ i ] [ j ] = - 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ch += 1 <NEWLINE> cw += 1 <NEWLINE> dh += 1 <NEWLINE> dw += 1 <NEWLINE> visited [ ch ] [ cw ] = 0 <NEWLINE> walk = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> telepo = [ [ i , j ] for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) ] <NEWLINE> <NL> q_walk = deque ( [ [ ch , cw ] ] ) <NEWLINE> q_telepo = deque ( [ ] ) <NEWLINE> while q_walk : <NEWLINE> <INDENT> yw , xw = q_walk . popleft ( ) <NEWLINE> <COMMENT> <NL> q_telepo . append ( [ yw , xw ] ) <NEWLINE> for i , j in walk : <NEWLINE> <INDENT> ny , nx = yw + i , xw + j <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if visited [ ny ] [ nx ] == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> visited [ ny ] [ nx ] = visited [ yw ] [ xw ] <NEWLINE> q_walk . append ( [ ny , nx ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( q_walk ) == 0 : <NEWLINE> <INDENT> while q_telepo : <NEWLINE> <INDENT> yt , xt = q_telepo . popleft ( ) <NEWLINE> for i , j in telepo : <NEWLINE> <INDENT> my , mx = yt + i , xt + j <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if visited [ my ] [ mx ] == - 1 : <NEWLINE> <INDENT> visited [ my ] [ mx ] = visited [ yt ] [ xt ] + 1 <NEWLINE> q_walk . append ( [ my , mx ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( visited [ dh ] [ dw ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = 1 <NEWLINE> li = [ 1 ] <NEWLINE> flag = [ True ] * n <NEWLINE> flag [ 0 ] = False <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> num = a [ num - 1 ] <NEWLINE> if flag [ num - 1 ] : <NEWLINE> <INDENT> li . append ( num ) <NEWLINE> flag [ num - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> d = li . index ( num ) <NEWLINE> ans = ( k - d ) % ( len ( li ) - d ) + d <NEWLINE> <NL> print ( li [ ans ] ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def dfs ( v , p , links , state , ans ) : <NEWLINE> <INDENT> ans [ v ] = len ( state ) <NEWLINE> for u in links [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a = aaa [ u ] <NEWLINE> b , i = - 1 , - 1 <NEWLINE> if state [ - 1 ] < a : <NEWLINE> <INDENT> state . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = bisect_left ( state , a ) <NEWLINE> b = state [ i ] <NEWLINE> state [ i ] = a <NEWLINE> <DEDENT> dfs ( u , v , links , state , ans ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> state . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> state [ i ] = b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> links = [ set ( ) for _ in range ( n ) ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> u , v = map ( int , line . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> links [ u ] . add ( v ) <NEWLINE> links [ v ] . add ( u ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> dfs ( 0 , - 1 , links , [ aaa [ 0 ] ] , ans ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> par = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> q = [ 1 ] <NEWLINE> l = [ ] <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> par [ a ] . append ( i ) <NEWLINE> <NL> <DEDENT> while q : <NEWLINE> <INDENT> s = q . pop ( ) <NEWLINE> l . append ( s ) <NEWLINE> for t in par [ s ] : <NEWLINE> <INDENT> q . append ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> for s in l [ : : - 1 ] : <NEWLINE> <INDENT> depth = 1 <NEWLINE> res = sorted ( [ dp [ t ] for t in par [ s ] ] ) [ : : - 1 ] <NEWLINE> for i , j in enumerate ( res ) : <NEWLINE> <INDENT> depth = max ( depth , i + j + 1 ) <NEWLINE> <DEDENT> dp [ s ] = depth <NEWLINE> <NL> <DEDENT> print ( dp [ 1 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if z >= 0 and z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> c = Counter ( s ) <NEWLINE> c_max = max ( c . values ( ) ) <NEWLINE> ans = [ j [ 0 ] for j in c . items ( ) if j [ 1 ] == c_max ] <NEWLINE> ans = sorted ( ans ) <NEWLINE> for f in ans : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> cost = 0 <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> cost += x <NEWLINE> if cost > k : <NEWLINE> <INDENT> cnt = i <NEWLINE> cost -= x <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j , y in enumerate ( b ) : <NEWLINE> <INDENT> cost += y <NEWLINE> if cost > k : <NEWLINE> <INDENT> cnt = n + j <NEWLINE> cost -= y <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = n + m <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt <= n : <NEWLINE> <INDENT> i_max , j = cnt - 1 , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i_max , j = n - 1 , cnt - n <NEWLINE> <NL> <DEDENT> while j < m and cost + b [ j ] <= k : <NEWLINE> <INDENT> cost += b [ j ] <NEWLINE> j += 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> ans = cnt <NEWLINE> for i in range ( i_max , - 1 , - 1 ) : <NEWLINE> <INDENT> if j == m : break <NEWLINE> cost -= a [ i ] <NEWLINE> cnt -= 1 <NEWLINE> while j < m and cost + b [ j ] <= k : <NEWLINE> <INDENT> cost += b [ j ] <NEWLINE> j += 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> ans = max ( cnt , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from math import floor <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> r = floor ( a * x / b ) - a * floor ( x / b ) <NEWLINE> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> if L [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans = ans * L [ i ] <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ 0 ] * N <NEWLINE> for _ in [ 0 ] * K : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> S [ a - 1 ] = b <NEWLINE> <DEDENT> dp = [ 0 ] * 9 <NEWLINE> st , nd = S [ : 2 ] <NEWLINE> if st : <NEWLINE> <INDENT> if nd : dp [ ~ - st * 3 + ~ - nd ] = 1 <NEWLINE> else : dp [ ~ - st * 3 : ~ - st * 3 ] = [ 1 ] * 3 <NEWLINE> <DEDENT> elif nd : dp [ ~ - nd : : 3 ] = [ 1 ] * 3 <NEWLINE> else : dp = [ 1 ] * 9 <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> cur = S [ i ] - 1 ; tmp = [ 0 ] * 9 <NEWLINE> if cur + 1 : <NEWLINE> <INDENT> for k in range ( 3 ) : tmp [ k * 3 + cur ] = sum ( dp [ k : : 3 ] ) - dp [ cur * 4 ] * ( k == cur ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for cur in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : tmp [ k * 3 + cur ] = sum ( dp [ k : : 3 ] ) - dp [ cur * 4 ] * ( k == cur ) <NEWLINE> <DEDENT> <DEDENT> dp = tmp [ : ] <NEWLINE> <DEDENT> print ( sum ( dp ) % 10000 ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> g = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> g += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> elif i == j and j != k : <NEWLINE> <INDENT> g += math . gcd ( math . gcd ( i , j ) , k ) * 3 <NEWLINE> <DEDENT> elif i != j and j == k : <NEWLINE> <INDENT> g += math . gcd ( math . gcd ( i , j ) , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g += math . gcd ( math . gcd ( i , j ) , k ) * 6 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
import networkx as nx <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : print ( 1 ) ; exit ( ) <NEWLINE> a = [ [ i for i in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> g = nx . Graph ( ) <NEWLINE> for x in a : <NEWLINE> <INDENT> g . add_edge ( x [ 0 ] , x [ 1 ] ) <NEWLINE> <DEDENT> print ( len ( sorted ( nx . connected_components ( g ) , key = len , reverse = True ) [ 0 ] ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if N >= B - 1 : <NEWLINE> <INDENT> ans = max ( ans , ( ( A * ( B - 1 ) ) // B ) - A * ( ( B - 1 ) // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , ( ( A * N ) // B ) - A * ( N // B ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> a += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ans == - 1 and A [ i ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> ixy = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ixy . append ( [ i , x - 1 , y ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> ixy = np . array ( ixy ) <NEWLINE> p = itertools . product ( [ True , False ] , repeat = n ) <NEWLINE> for p_i in p : <NEWLINE> <INDENT> f = True <NEWLINE> for i , x , y in ixy : <NEWLINE> <INDENT> if not p_i [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p_i [ x ] != y : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> ans = max ( sum ( p_i ) , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> n = 1 <NEWLINE> k = 1 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> result += n * pow ( k , 998244353 - 2 , 998244353 ) * pow ( M - 1 , N - 1 - i , 998244353 ) <NEWLINE> result %= 998244353 <NEWLINE> n *= N - 1 - i <NEWLINE> n %= 998244353 <NEWLINE> k *= i + 1 <NEWLINE> k %= 998244353 <NEWLINE> <DEDENT> result *= M <NEWLINE> result %= 998244353 <NEWLINE> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> sum_v = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = ( n - 1 ) // i <NEWLINE> sum_v += v <NEWLINE> <NL> <DEDENT> print ( sum_v ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if v < 10050 : <COMMENT> <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = input ( ) . split ( ) <NEWLINE> <NL> <NL> def mult ( ) : <NEWLINE> <INDENT> if <STRING> in arr : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> a = a * int ( i ) <NEWLINE> if a > 1000000000000000000 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mult ( ) ) <NEWLINE>
