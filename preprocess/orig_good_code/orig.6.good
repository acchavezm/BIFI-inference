N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> F = [ 0 ] * len ( S ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> F [ i + 1 ] += F [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for l , r in LR : <NEWLINE> <INDENT> print ( F [ r - 1 ] - F [ l - 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D1 = defaultdict ( int ) <NEWLINE> D2 = defaultdict ( int ) <NEWLINE> <NL> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> D1 [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N , 2 ) : <NEWLINE> <INDENT> D2 [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> D1_sorted = sorted ( D1 . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) + [ ( - 1 , 0 ) ] <NEWLINE> D2_sorted = sorted ( D2 . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) + [ ( - 1 , 0 ) ] <NEWLINE> i , j = 0 , 0 <NEWLINE> while i < len ( D1_sorted ) - 1 and j < len ( D2_sorted ) - 1 : <NEWLINE> <INDENT> if D1_sorted [ i ] [ 0 ] != D2_sorted [ j ] [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif D1_sorted [ i ] [ 1 ] > D2_sorted [ j ] [ 1 ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> elif D1_sorted [ i ] [ 1 ] < D2_sorted [ j ] [ 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if D1_sorted [ i + 1 ] [ 1 ] > D2_sorted [ j + 1 ] [ 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - D1_sorted [ i ] [ 1 ] - D2_sorted [ j ] [ 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> dic_a = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a in dic_a : <NEWLINE> <INDENT> dic_a [ a ] += 1 <NEWLINE> dic_a [ a ] = dic_a [ a ] % 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_a [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( list ( dic_a . values ( ) ) ) ) <NEWLINE>
import math <NEWLINE> def LCM ( a , b ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> return a * b // g <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( set ( A ) ) <NEWLINE> N = len ( A ) <NEWLINE> a0 = A [ 0 ] <NEWLINE> div = 1 <NEWLINE> while a0 % 2 == 0 : <NEWLINE> <INDENT> div *= 2 <NEWLINE> a0 //= 2 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = A [ i ] % div <NEWLINE> b = A [ i ] // div <NEWLINE> if ( b % 2 == 0 ) or ( a != 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] //= 2 <NEWLINE> <NL> <DEDENT> if N > 1 : <NEWLINE> <INDENT> lcm = LCM ( A [ 0 ] , A [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> lcm = LCM ( lcm , A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> lcm = A [ 0 ] <NEWLINE> <NL> <DEDENT> ans = M // lcm <NEWLINE> if ans % 2 == 1 : <NEWLINE> <INDENT> print ( ans // 2 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans // 2 ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] and n != 1 : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , 2 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> primes = factorization ( M ) <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> <NL> for p , cnt in primes : <NEWLINE> <INDENT> tmp = cmb ( N + cnt - 1 , N - 1 , mod ) <NEWLINE> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> pushed = [ ] <NEWLINE> button = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> button [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> push_button = 1 <NEWLINE> for _ in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if push_button == 2 : <NEWLINE> <INDENT> print ( len ( pushed ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pushed . append ( push_button ) <NEWLINE> push_button = button [ push_button ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> if len ( make_divisors ( i ) ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> while m > 0 : <NEWLINE> <INDENT> a_max = heapq . heappop ( a ) <NEWLINE> if a_max == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> heapq . heappush ( a , ( - 1 ) * ( - a_max // 2 ) ) <NEWLINE> m -= 1 <NEWLINE> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> max_l = 0 <NEWLINE> min_r = n <NEWLINE> ans = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if ans != 0 : <NEWLINE> <INDENT> if l <= min_r or r <= max_l : <NEWLINE> <INDENT> max_l = max ( max_l , l ) <NEWLINE> min_r = min ( min_r , r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> ans = min_r - max_l + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( sysread ( ) ) <NEWLINE> A = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ansBa = [ ] <NEWLINE> ansBc = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = B [ i ] <NEWLINE> idx = bisect . bisect_left ( A , b ) <NEWLINE> ansBa . append ( idx ) <NEWLINE> <NL> idx2 = bisect . bisect_right ( C , b ) <NEWLINE> ansBc . append ( N - idx2 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for aa , cc in zip ( ansBa , ansBc ) : <NEWLINE> <INDENT> ans += aa * cc <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> diff = b - a <NEWLINE> if diff % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif diff % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( str ( input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> sofar = 0 <NEWLINE> j = 1 <NEWLINE> nax = 0 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> ans += j <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += j <NEWLINE> nax = j <NEWLINE> j = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += j <NEWLINE> if nax != 0 : <NEWLINE> <INDENT> ans -= j <NEWLINE> <DEDENT> j = 1 <NEWLINE> nax = 0 <NEWLINE> <DEDENT> if j > nax : <NEWLINE> <INDENT> ans -= nax <NEWLINE> nax = 0 <NEWLINE> <DEDENT> <DEDENT> if j > nax : <NEWLINE> <INDENT> ans += j <NEWLINE> ans -= nax <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) . rstrip ( ) ) <NEWLINE> judge = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> hap_lst = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> if not judge : <NEWLINE> <INDENT> judge = hap_lst <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_0 , b_0 , c_0 = judge <NEWLINE> a_1 , b_1 , c_1 = hap_lst <NEWLINE> judge = [ a_1 + max ( b_0 , c_0 ) , b_1 + max ( a_0 , c_0 ) , c_1 + max ( a_0 , b_0 ) ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( judge ) ) <NEWLINE>
import math <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == a ** 2 * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif x >= a ** 2 * b / 2 : <NEWLINE> <INDENT> print ( 90 - math . degrees ( math . atan ( a ** 3 / ( 2 * a ** 2 * b - 2 * x ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( ( 90 - math . degrees ( math . atan ( 2 * x / ( a * b ** 2 ) ) ) ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> bc = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] , key = lambda x : x [ 1 ] ) <NEWLINE> bc . reverse ( ) <NEWLINE> <NL> flg = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if bc [ flg ] [ 1 ] > a [ i ] and flg < m : <NEWLINE> <INDENT> a [ i ] = bc [ flg ] [ 1 ] <NEWLINE> cnt += 1 <NEWLINE> if cnt == bc [ flg ] [ 0 ] : <NEWLINE> <INDENT> flg += 1 <NEWLINE> cnt = 0 <NEWLINE> if flg == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> o = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> <DEDENT> e = n - o <NEWLINE> if o != 0 : <NEWLINE> <INDENT> print ( ( 2 ** e ) * int ( 2 ** ( o - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p == 0 : <NEWLINE> <INDENT> print ( 2 ** n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , Y , Z , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> p_queue = [ ( A [ 0 ] + B [ 0 ] + C [ 0 ] , 0 , 0 , 0 ) ] <NEWLINE> visited = set ( ) <NEWLINE> visited . add ( ( 0 , 0 , 0 ) ) <NEWLINE> ans = [ ] <NEWLINE> while len ( ans ) < K : <NEWLINE> <INDENT> s , i_A , i_B , i_C = heapq . heappop ( p_queue ) <NEWLINE> ans . append ( - s ) <NEWLINE> if i_A < X - 1 and ( i_A + 1 , i_B , i_C ) not in visited : <NEWLINE> <INDENT> visited . add ( ( i_A + 1 , i_B , i_C ) ) <NEWLINE> t = s - A [ i_A ] + A [ i_A + 1 ] <NEWLINE> heapq . heappush ( p_queue , ( t , i_A + 1 , i_B , i_C ) ) <NEWLINE> <DEDENT> if i_B < Y - 1 and ( i_A , i_B + 1 , i_C ) not in visited : <NEWLINE> <INDENT> visited . add ( ( i_A , i_B + 1 , i_C ) ) <NEWLINE> t = s - B [ i_B ] + B [ i_B + 1 ] <NEWLINE> heapq . heappush ( p_queue , ( t , i_A , i_B + 1 , i_C ) ) <NEWLINE> <DEDENT> if i_C < Z - 1 and ( i_A , i_B , i_C + 1 ) not in visited : <NEWLINE> <INDENT> visited . add ( ( i_A , i_B , i_C + 1 ) ) <NEWLINE> t = s - C [ i_C ] + C [ i_C + 1 ] <NEWLINE> heapq . heappush ( p_queue , ( t , i_A , i_B , i_C + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = S [ : : - 1 ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for v in range ( 1000 ) : <NEWLINE> <INDENT> V = str ( v ) . zfill ( 3 ) <NEWLINE> right = - 1 <NEWLINE> left = - 1 <NEWLINE> if V [ 2 ] in R : <NEWLINE> <INDENT> r = R . index ( V [ 2 ] ) + 1 <NEWLINE> right = N - r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if V [ 0 ] in S : <NEWLINE> <INDENT> left = S . index ( V [ 0 ] ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if V [ 1 ] in S [ left : right ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from itertools import combinations , product <NEWLINE> import bisect as bs <NEWLINE> <NL> def tuple_int ( iterable ) : <NEWLINE> <INDENT> return tuple ( map ( int , iterable . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def S_with_K_plots ( plots , K ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> X , Y = sorted ( [ x for x , y in plots ] ) , sorted ( [ y for x , y in plots ] ) <NEWLINE> for xinf , xsup in combinations ( X , 2 ) : <NEWLINE> <INDENT> for yinf in Y : <NEWLINE> <INDENT> ysup = [ y for x , y in plots if xinf <= x <= xsup and y >= yinf ] <NEWLINE> if len ( ysup ) < K : continue <NEWLINE> ysup . sort ( ) <NEWLINE> result . append ( ( xsup - xinf ) * ( ysup [ K - 1 ] - yinf ) ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> with open ( 0 ) as f : <NEWLINE> <INDENT> N , K = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> plots = list ( map ( tuple_int , f . readlines ( ) ) ) <NEWLINE> <DEDENT> print ( min ( S_with_K_plots ( plots , K ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> aa = sorted ( a ) [ : n - 1 ] <NEWLINE> maxa = max ( a ) <NEWLINE> b = a . index ( maxa ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == b : <NEWLINE> <INDENT> print ( max ( aa ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxa ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> if x <= 0 or x % 1 != 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , int ( math . sqrt ( x ) // 1 ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> S = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> if is_prime ( i ) and is_prime ( ( i + 1 ) / 2 ) : <NEWLINE> <INDENT> S [ i ] += 1 <NEWLINE> <DEDENT> S [ i ] += S [ i - 1 ] <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( S [ r ] - S [ l - 1 ] ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from itertools import permutations <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> m = [ set ( ) for _ in range ( 27 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> m [ a ] . add ( b ) <NEWLINE> m [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> def traverse ( n , visits ) : <NEWLINE> <INDENT> visits = visits | set ( [ n ] ) <NEWLINE> if len ( visits ) == N : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> for c in m [ n ] - visits : <NEWLINE> <INDENT> traverse ( c , visits ) <NEWLINE> <DEDENT> <DEDENT> traverse ( 1 , set ( ) ) <NEWLINE> return len ( ans ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
dishes = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> <NL> d = [ abs ( d % 10 - 10 ) for d in dishes if d % 10 != 0 ] <COMMENT> <NEWLINE> if d : d . remove ( max ( d ) ) <NEWLINE> print ( sum ( dishes ) + sum ( d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> if 2 not in li : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> st = 0 <NEWLINE> while st != 1 : <NEWLINE> <INDENT> if ( st == 0 and ans > 0 ) or ans > n : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> st = li [ st ] - 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from sys import exit <NEWLINE> <NL> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> if len ( H ) <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> H . sort ( reverse = True ) <NEWLINE> H = H [ K : ] <NEWLINE> <NL> print ( sum ( H ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> cnt = s . count ( <STRING> ) <NEWLINE> a = [ i for i , x in enumerate ( s ) if x == <STRING> ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( cnt ) : <NEWLINE> <INDENT> ans += a [ i ] - i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> A = sorted ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> if A [ 0 ] == A [ - 1 ] : <NEWLINE> <INDENT> x = A [ 0 ] <NEWLINE> return x == N - 1 or 2 * x <= N <NEWLINE> <DEDENT> if A [ 0 ] + 1 != A [ - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> a , b = A [ 0 ] , A [ - 1 ] <NEWLINE> full = b <NEWLINE> unique = A . count ( a ) <NEWLINE> people , color = N - unique , A [ - 1 ] - unique <NEWLINE> return color > 0 and 2 * color <= people <NEWLINE> <NL> <DEDENT> print ( <STRING> if main ( A ) else <STRING> ) <NEWLINE>
import sys <COMMENT> <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cost = [ 0 ] * n <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cost [ p - 1 ] += x <NEWLINE> <NL> <NL> <DEDENT> visited = [ - 1 ] * n <NEWLINE> <NL> <NL> def dfs ( n , c ) : <NEWLINE> <NL> <INDENT> cost [ n ] += c <NEWLINE> tmp = cost [ n ] <NEWLINE> visited [ n ] = 0 <NEWLINE> <NL> for v in edge [ n ] : <NEWLINE> <INDENT> if visited [ v ] == - 1 : <NEWLINE> <INDENT> dfs ( v , tmp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> print ( * cost ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> num_eas = s . count ( <STRING> ) <NEWLINE> <NL> <NL> res = [ ] <NEWLINE> res += [ num_eas - s [ 0 ] . count ( <STRING> ) ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> res += [ res [ i - 1 ] + s [ i - 1 ] . count ( <STRING> ) - s [ i ] . count ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> print ( min ( res ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if str ( i ) in s [ : - 2 ] : <NEWLINE> <INDENT> s1 = s . index ( str ( i ) ) <NEWLINE> <NL> for j in range ( 10 ) : <NEWLINE> <INDENT> if str ( j ) in s [ s1 + 1 : - 1 ] : <NEWLINE> <INDENT> s2 = s [ s1 + 1 : ] . index ( str ( j ) ) + s1 + 1 <NEWLINE> <NL> for k in range ( 10 ) : <NEWLINE> <INDENT> if str ( k ) in s [ s2 + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p_list_E = [ ] <NEWLINE> p_list_E_temp = [ 1 , 1.5 , 2 , 2.5 , 3 , 3.5 ] <NEWLINE> <NL> for i in range ( len ( p_list ) ) : <NEWLINE> <INDENT> p_list_E . append ( ( p_list [ i ] + 1 ) * 0.5 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> p_list_sum = [ 0 ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> p_list_sum . append ( p_list_sum [ i ] + p_list_E [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K , N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , p_list_sum [ i ] - p_list_sum [ i - K ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> m = 10 ** 9 + 7 <NEWLINE> pri_num = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 ] <NEWLINE> dic = { } <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for pri in pri_num : <NEWLINE> <INDENT> while i > 0 : <NEWLINE> <INDENT> if i % pri == 0 : <NEWLINE> <INDENT> if pri in dic : <NEWLINE> <INDENT> dic [ pri ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ pri ] = 1 <NEWLINE> <DEDENT> i = i // pri <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> count = 1 <NEWLINE> for val in dic . values ( ) : <NEWLINE> <INDENT> count = ( count * ( val + 1 ) ) % m <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <NL>
from bisect import bisect_left , bisect_right <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> x = L [ i ] - L [ j ] <NEWLINE> bottom = bisect_right ( L , x ) <NEWLINE> if j > bottom : <NEWLINE> <INDENT> ans += j - bottom <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> key = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> key = ( key * i ) % 1000000007 <NEWLINE> <DEDENT> print ( key ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> a = [ I ( ) - 1 for _ in range ( N ) ] <NEWLINE> <NL> c = 0 <NEWLINE> ans = 0 <NEWLINE> is_ok = True <NEWLINE> while True : <NEWLINE> <INDENT> c = a [ c ] <NEWLINE> ans += 1 <NEWLINE> if c == 0 or ans > N : <NEWLINE> <INDENT> is_ok = False <NEWLINE> break <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> B . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> B = list ( reversed ( B ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> num = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( B [ i ] [ 0 ] ) : <NEWLINE> <INDENT> if num > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ num ] < B [ i ] [ 1 ] : <NEWLINE> <INDENT> A [ num ] = B [ i ] [ 1 ] <NEWLINE> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> num_0 = S . count ( <STRING> ) <NEWLINE> num_1 = S . count ( <STRING> ) <NEWLINE> <NL> print ( min ( num_0 , num_1 ) * 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> e = S [ 1 : ] . count ( <STRING> ) <NEWLINE> w = S [ : 0 ] . count ( <STRING> ) <NEWLINE> ans = e + w <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> e = e - 1 <NEWLINE> <DEDENT> if ( S [ i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> w = w + 1 <NEWLINE> <DEDENT> ans = min ( ans , e + w ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> <NL> def dijkstra ( n , s , g ) : <NEWLINE> <INDENT> h = [ ( 0 , s ) ] <NEWLINE> heapq . heapify ( h ) <NEWLINE> cost = [ float ( <STRING> ) ] * ( n + 1 ) <COMMENT> <NEWLINE> cost [ s ] = 0 <NEWLINE> <NL> while h : <NEWLINE> <INDENT> c , v = heapq . heappop ( h ) <NEWLINE> if c > cost [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for d , u in g [ v ] : <NEWLINE> <INDENT> d_s_u = d + cost [ v ] <NEWLINE> if d_s_u < cost [ u ] : <NEWLINE> <INDENT> cost [ u ] = d_s_u <NEWLINE> heapq . heappush ( h , ( d_s_u , u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * abc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for a , b , c in zip ( * [ iter ( abc ) ] * 3 ) : <NEWLINE> <INDENT> g [ a ] . append ( [ c , b ] ) <NEWLINE> g [ b ] . append ( [ c , a ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> checked = [ [ False ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cost = dijkstra ( n , i , g ) <NEWLINE> for j , k in g [ i ] : <NEWLINE> <INDENT> if checked [ i ] [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if j > cost [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> checked [ i ] [ k ] = True <NEWLINE> checked [ k ] [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> result = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if a in result : <NEWLINE> <INDENT> result [ a ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ a ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> result = sorted ( result . items ( ) ) <NEWLINE> <NL> now = 0 <NEWLINE> for key , value in result : <NEWLINE> <INDENT> now += value <NEWLINE> <NL> if now >= K : <NEWLINE> <INDENT> print ( key ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from bisect import bisect_left <NEWLINE> N = int ( input ( ) ) <NEWLINE> L_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L_list . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a , b = L_list [ i ] , L_list [ j ] <NEWLINE> r = bisect_left ( L_list , a + b ) <NEWLINE> ans += max ( 0 , r - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> apoint = [ ] <NEWLINE> cpoint = [ ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] + s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> apoint . append ( i ) <NEWLINE> cpoint . append ( i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = l - 1 , r - 1 <NEWLINE> left = bisect . bisect_left ( apoint , l ) <NEWLINE> right = bisect . bisect_left ( cpoint , r ) <NEWLINE> print ( right - left ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def bisect_right_reverse ( L , target ) : <NEWLINE> <INDENT> ok = len ( L ) <NEWLINE> ng = - 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if L [ mid ] < target : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = bisect_right_reverse ( L , A [ i ] ) <NEWLINE> if k == len ( L ) : <NEWLINE> <INDENT> L . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ k ] = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( L ) ) <NEWLINE>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N // R + 1 ) : <NEWLINE> <INDENT> for j in range ( N // G + 1 ) : <NEWLINE> <INDENT> if ( N - ( R * i + G * j ) ) < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( N - ( R * i + G * j ) ) % B == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] * K , dtype = np . int64 ) <NEWLINE> H = np . array ( h ) <NEWLINE> dp = np . full ( N + K , 10 ** 10 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i : i + K ] = np . minimum ( dp [ i : i + K ] , <NEWLINE> <INDENT> np . abs ( H [ i : i + K ] - H [ i - 1 ] ) + dp [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> tree [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dist = [ - 1 ] * N <NEWLINE> def dfs ( v , total_cost ) : <NEWLINE> <COMMENT> <NL> <INDENT> dist [ v ] = total_cost <NEWLINE> for v_next , cost in tree [ v ] : <NEWLINE> <INDENT> if dist [ v_next ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> dfs ( v_next , total_cost + cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( K - 1 , 0 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> first = S [ 0 ] <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != first : <NEWLINE> <INDENT> c += 1 <NEWLINE> first = S [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> <NL> def search ( moji ) : <NEWLINE> <INDENT> num = len ( moji ) <NEWLINE> setsn = set ( [ ] ) <NEWLINE> for i in range ( len ( s ) - num + 1 ) : <NEWLINE> <INDENT> if s [ i : i + num ] == moji : <NEWLINE> <INDENT> str_ = s [ i : i + num + 1 ] <NEWLINE> if len ( str_ ) == num + 1 : <NEWLINE> <INDENT> setsn . add ( str_ ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sorted_setsn = sorted ( setsn , reverse = True ) <NEWLINE> <NL> return sorted_setsn <NEWLINE> <NL> <NL> <DEDENT> s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> sets1 = set ( [ ] ) <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> sets1 . add ( s [ i ] ) <NEWLINE> <NL> <DEDENT> sorted_sets1 = sorted ( sets1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> dq = deque ( sorted_sets1 ) <NEWLINE> <NL> while ( len ( dq ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> moji = dq . popleft ( ) <NEWLINE> k -= 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( moji ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sorted_setsn = search ( moji ) <NEWLINE> <NL> <COMMENT> <NL> dq . extendleft ( sorted_setsn ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( int ( input ( ) ) for i in range ( N ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> count = 0 <NEWLINE> <NL> for v in c . values ( ) : <NEWLINE> <INDENT> if v % 2 != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> excess = [ ] <NEWLINE> shortage = [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= b [ i ] : <NEWLINE> <INDENT> excess . append ( a [ i ] - b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shortage . append ( b [ i ] - a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( shortage ) <NEWLINE> <NL> if sum ( excess ) < sum ( shortage ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif len ( shortage ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> excess . sort ( reverse = True ) <NEWLINE> excess_num = 0 <NEWLINE> shortage_num = sum ( shortage ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> excess_num += excess [ i ] <NEWLINE> ans += 1 <NEWLINE> if excess_num >= shortage_num : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> <NL> fin = [ ] <NEWLINE> num = [ 0 ] * w <NEWLINE> <NL> for l in lis : <NEWLINE> <INDENT> if l . count ( <STRING> ) != w : <NEWLINE> <INDENT> fin . append ( l ) <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for f in fin : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] != h : <NEWLINE> <INDENT> ans . append ( f [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = 10 ** 10 <NEWLINE> <NL> partA = 0 <NEWLINE> partB = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> diff = min ( diff , abs ( partA - partB ) ) <NEWLINE> partA += A [ i ] <NEWLINE> partB -= A [ i ] <NEWLINE> <DEDENT> print ( diff ) <NEWLINE> return <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> d = collections . Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> M = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t_num = t . copy ( ) <NEWLINE> t_num = set ( list ( t_num ) ) <NEWLINE> t = collections . Counter ( t ) <NEWLINE> <NL> if N < M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for key in t_num : <NEWLINE> <INDENT> if d [ key ] < t [ key ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> XL = [ NLI ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> arm_range = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> arm_range . append ( [ XL [ n ] [ 0 ] - XL [ n ] [ 1 ] , XL [ n ] [ 0 ] + XL [ n ] [ 1 ] ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> sorted_arm_range = sorted ( arm_range , key = lambda x : x [ 1 ] ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> arm_end = sorted_arm_range [ 0 ] [ 1 ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( N - 1 ) : <NEWLINE> <INDENT> if sorted_arm_range [ n + 1 ] [ 0 ] >= arm_end : <NEWLINE> <INDENT> arm_end = sorted_arm_range [ n + 1 ] [ 1 ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X >= B - A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> H = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> dp = np . full ( n , INF , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ max ( i - k , 0 ) : i ] + np . abs ( H [ max ( i - k , 0 ) : i ] - H [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> count = [ ] <NEWLINE> for x1 , y1 in xy : <NEWLINE> <INDENT> for x2 , y2 in xy : <NEWLINE> <INDENT> if x1 == x2 and y1 == y2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c = str ( x1 - x2 ) + <STRING> + str ( y1 - y2 ) <NEWLINE> count . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> from collections import * <NEWLINE> C = Counter ( count ) <NEWLINE> C [ <STRING> ] = 0 <NEWLINE> print ( N - max ( C . values ( ) ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = sorted ( input ( ) for _ in range ( N ) ) <NEWLINE> <NL> print ( <STRING> . join ( S ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> import warnings <NEWLINE> warnings . filterwarnings ( <STRING> ) <NEWLINE> <NL> N , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> w = np . array ( [ 0 ] * ( N + 1 ) ) <NEWLINE> v = np . array ( [ 0 ] * ( N + 1 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w [ i + 1 ] , v [ i + 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dp = np . array ( [ [ 0 ] * ( W + 1 ) ] * ( N + 1 ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp_arr = np . zeros ( W + 1 , dtype = int ) <NEWLINE> tmp_arr = np . zeros ( W + 1 , dtype = int ) <NEWLINE> tmp_arr [ w [ i ] : ] = dp [ i - 1 ] [ : - w [ i ] ] + v [ i ] <NEWLINE> dp [ i ] = np . maximum ( dp [ i - 1 ] , tmp_arr ) <NEWLINE> <NL> <DEDENT> print ( dp [ N , W ] ) <NEWLINE> <NL>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( a ) >= k : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> L , R = - 1 , n - 1 <NEWLINE> while L + 1 < R : <NEWLINE> <INDENT> P = ( L + R + 1 ) // 2 <NEWLINE> if k <= a [ P ] : <NEWLINE> <INDENT> R = P <NEWLINE> continue <NEWLINE> <DEDENT> dp = np . zeros ( ( k + 1 ) , dtype = np . bool ) <NEWLINE> dp [ 0 ] = True <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if k <= a [ j ] or j == P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ a [ j ] : ] |= dp [ : - a [ j ] ] <NEWLINE> <DEDENT> f = False <NEWLINE> for j in range ( k - a [ P ] , k ) : <NEWLINE> <INDENT> f |= dp [ j ] <NEWLINE> <DEDENT> if f : <NEWLINE> <INDENT> R = P <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = P <NEWLINE> <DEDENT> <DEDENT> print ( R ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ss = set ( list ( S ) ) <NEWLINE> st = set ( list ( T ) ) <NEWLINE> if not ( st <= ss ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> alpha = { chr ( 97 + i ) : [ ] for i in range ( 26 ) } <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> alpha [ s ] . append ( i + 1 ) <NEWLINE> <DEDENT> n = len ( S ) <NEWLINE> now = 0 <NEWLINE> ans = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if alpha [ t ] [ - 1 ] <= now : <NEWLINE> <INDENT> ans += ( n - now ) + alpha [ t ] [ 0 ] <NEWLINE> now = alpha [ t ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = bisect_left ( alpha [ t ] , now + 1 ) <NEWLINE> ans += alpha [ t ] [ i ] - now <NEWLINE> now = alpha [ t ] [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> col = [ 0 ] * n <NEWLINE> next = [ [ ] for i in range ( n ) ] <NEWLINE> d = [ float ( <STRING> ) ] * n <NEWLINE> d [ 0 ] = 0 <NEWLINE> <NL> def dfs ( now , parent ) : <NEWLINE> <INDENT> for next1 , w1 in next [ now ] : <NEWLINE> <INDENT> if next1 == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif d [ next1 ] == float ( <STRING> ) : <NEWLINE> <INDENT> d [ next1 ] = d [ now ] + w1 <NEWLINE> dfs ( next1 , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> next [ u - 1 ] . append ( ( v - 1 , w ) ) <NEWLINE> next [ v - 1 ] . append ( ( u - 1 , w ) ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> if ( ( b - a ) - 1 ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> num_list = np . array ( input ( ) . split ( ) , dtype = <STRING> ) <NEWLINE> <NL> max_num = max ( num_list ) <NEWLINE> max_bit_num = format ( max_num , <STRING> ) <NEWLINE> max_bit_num_length = len ( max_bit_num ) <NEWLINE> ans = 0 <NEWLINE> radix = 1 <NEWLINE> for i in range ( max_bit_num_length ) : <NEWLINE> <INDENT> new_num_list = ( num_list >> i ) & 1 <NEWLINE> one_amount = np . count_nonzero ( new_num_list == 1 ) <NEWLINE> zero_amount = len ( num_list ) - one_amount <NEWLINE> ans += ( one_amount * zero_amount ) * radix <NEWLINE> radix *= 2 <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> n = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> m = { } <NEWLINE> <NL> <NL> def doit ( n , k ) : <NEWLINE> <INDENT> if len ( n ) == 0 : <NEWLINE> <INDENT> return k == 0 <NEWLINE> <DEDENT> d = int ( n [ 0 ] ) <NEWLINE> if ( n , k ) not in m : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( d + 1 ) : <NEWLINE> <INDENT> if i == d : <NEWLINE> <INDENT> ret += doit ( n [ 1 : ] , k - 1 if i > 0 else k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += doit ( <STRING> * ( len ( n ) - 1 ) , k - 1 if i > 0 else k ) <NEWLINE> <DEDENT> <DEDENT> m [ ( n , k ) ] = ret <NEWLINE> <DEDENT> return m [ ( n , k ) ] <NEWLINE> <NL> <NL> <DEDENT> print ( doit ( n , k ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> S = input ( ) <NEWLINE> is_flag = True <NEWLINE> while is_flag : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( S ) >= 5 : <NEWLINE> <INDENT> temp = S [ : 5 ] <NEWLINE> <COMMENT> <NL> if temp == <STRING> : <NEWLINE> <INDENT> S = S [ 5 : ] <NEWLINE> if len ( S ) != 0 : <NEWLINE> <INDENT> if S [ : 5 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif S [ : 2 ] == <STRING> : <NEWLINE> <INDENT> S = S [ 2 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif temp == <STRING> : <NEWLINE> <INDENT> S = S [ 5 : ] <NEWLINE> if len ( S ) != 0 : <NEWLINE> <INDENT> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> S = S [ 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> is_flag = False <NEWLINE> <DEDENT> <DEDENT> elif len ( S ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> is_flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> is_flag = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> dum = round ( p ** ( 1 / n ) ) <NEWLINE> for i in range ( dum , - 1 , - 1 ) : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if ( z >= 0 and z <= k ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from math import gcd <NEWLINE> <NL> A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> N = 0 ; max_SW = A * 100 ; max_S = 0 <NEWLINE> f = F // 100 ; a = f // A ; b = f // B <NEWLINE> cn = D // gcd ( C , D ) <NEWLINE> <NL> for j in range ( b + 1 ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( a + 1 ) : <COMMENT> <NEWLINE> <INDENT> if i == 0 and j == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif A * i + B * j > f : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = ( A * i + B * j ) * 100 <COMMENT> <NEWLINE> e = ( A * i + B * j ) * E <COMMENT> <NEWLINE> S = min ( e , F - w ) <COMMENT> <NEWLINE> s = 0 <NEWLINE> for ci in range ( min ( S // C , cn ) + 1 ) : <NEWLINE> <INDENT> s = max ( s , S - ( S - C * ci ) % D ) <NEWLINE> <DEDENT> if s / ( w + s ) > N : <NEWLINE> <INDENT> N = s / ( w + s ) <NEWLINE> max_SW = s + w <NEWLINE> max_S = s <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_SW , max_S ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = 0 <NEWLINE> num = 1 <NEWLINE> <NL> while num <= N : <NEWLINE> <INDENT> D = D + L [ num - 1 ] <NEWLINE> if D > X : <NEWLINE> <INDENT> print ( num ) <NEWLINE> break <NEWLINE> <DEDENT> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N + 1 ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , A ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> try : <NEWLINE> <INDENT> while len ( A ) != 0 : <NEWLINE> <INDENT> a += A . pop ( 0 ) <NEWLINE> b += A . pop ( 0 ) <NEWLINE> <DEDENT> print ( a - b ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = tuple ( map ( int , tuple ( input ( ) ) ) ) <NEWLINE> num_pos = [ ] <COMMENT> <NEWLINE> for num in range ( 10 ) : <NEWLINE> <INDENT> if num in s : <NEWLINE> <INDENT> num_pos . append ( n - s [ : : - 1 ] . index ( num ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> unique_num = [ 0 ] * n <COMMENT> <NEWLINE> for i1 in range ( n ) : <NEWLINE> <INDENT> unique_num [ i1 ] = sum ( [ np >= i1 for np in num_pos ] ) <NEWLINE> <DEDENT> unique_num . append ( 0 ) <NEWLINE> r = 0 <NEWLINE> for keta1 in range ( 10 ) : <NEWLINE> <INDENT> if keta1 in s : <NEWLINE> <INDENT> keta1_pos = s . index ( keta1 ) <NEWLINE> for keta2 in range ( 10 ) : <NEWLINE> <INDENT> if keta2 in s [ keta1_pos + 1 : ] : <NEWLINE> <INDENT> keta2_pos = s [ keta1_pos + 1 : ] . index ( keta2 ) + keta1_pos + 1 <NEWLINE> r += unique_num [ keta2_pos + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for i in range ( m ) ) <NEWLINE> a . append ( 0 ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> b = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ b ] == i : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i != 1 and i != 2 : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> elif i == 2 and a [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 2 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * ( i + 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
class BisectSearch : <NEWLINE> <INDENT> def __init__ ( self , f , l = 0 , r = 10 ** 9 ) : <NEWLINE> <INDENT> self . f = f <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> <DEDENT> def __call__ ( self , dist ) : <NEWLINE> <INDENT> f = self . f <NEWLINE> l = self . l <NEWLINE> r = self . r <NEWLINE> if dist <= f ( l ) : <NEWLINE> <INDENT> return l <NEWLINE> <DEDENT> if f ( r ) <= dist : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> while r - l > 1 : <NEWLINE> <INDENT> n = ( r + l ) // 2 <NEWLINE> if f ( n ) <= dist : <NEWLINE> <INDENT> l = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = n <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) * n // 2 <NEWLINE> <DEDENT> m = BisectSearch ( f , l = 1 , r = 10 ** 7 ) ( n ) <NEWLINE> m += f ( m ) != n <NEWLINE> A = set ( range ( 1 , m + 1 ) ) <NEWLINE> A . discard ( f ( m ) - n ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
<NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> S . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> y_1 , y_0 = [ 0 ] , [ 0 ] <NEWLINE> st = set ( ) <NEWLINE> <NL> for t , d in S : <NEWLINE> <INDENT> if t in st : <NEWLINE> <COMMENT> <NL> <INDENT> y_0 . append ( y_0 [ - 1 ] + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . add ( t ) <NEWLINE> y_1 . append ( y_1 [ - 1 ] + d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> max_sum = - 1 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if k - i >= len ( y_0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i >= len ( y_1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> max_sum = max ( max_sum , y_0 [ k - i ] + y_1 [ i ] + i ** 2 ) <NEWLINE> <NL> <DEDENT> print ( max_sum ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if l [ l [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> denger = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> denger [ int ( input ( ) ) ] = True <NEWLINE> <NL> <DEDENT> DP = [ 0 ] * ( n + 1 ) <NEWLINE> DP [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not denger [ i + 1 ] : <NEWLINE> <INDENT> DP [ i + 1 ] += DP [ i ] <NEWLINE> <DEDENT> if i + 2 <= n and not denger [ i + 2 ] : <NEWLINE> <INDENT> DP [ i + 2 ] += DP [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( DP [ - 1 ] % 1000000007 ) <NEWLINE>
import bisect <NEWLINE> <NL> a , b , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 , 0 , 0 ] <NEWLINE> <NL> i = bisect . bisect_left ( s , x ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> sl = 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sl = abs ( s [ i - 1 ] - x ) <NEWLINE> <DEDENT> if i == a : <NEWLINE> <INDENT> sr = 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sr = abs ( s [ i ] - x ) <NEWLINE> <DEDENT> i = bisect . bisect_left ( t , x ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> tl = 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl = abs ( t [ i - 1 ] - x ) <NEWLINE> <DEDENT> if i == b : <NEWLINE> <INDENT> tr = 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tr = abs ( t [ i ] - x ) <NEWLINE> <DEDENT> ans [ 0 ] = max ( tl , sl ) <NEWLINE> ans [ 1 ] = max ( tr , sr ) <NEWLINE> ans [ 2 ] = min ( 2 * tl + sr , 2 * sl + tr , 2 * sr + tl , 2 * tr + sl ) <NEWLINE> print ( min ( ans ) ) <NEWLINE> <DEDENT>
n = [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> N1 , N2 = max ( n ) , sorted ( n ) [ - 2 ] <NEWLINE> for i in n : <NEWLINE> <INDENT> if i < N1 : print ( N1 ) <NEWLINE> elif i == N1 : print ( N2 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> <NL> s [ k - 1 ] = s [ k - 1 ] . lower ( ) <NEWLINE> a = <STRING> . join ( s ) <NEWLINE> <NL> print ( a ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( 0 , a + b - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> card_num , gate_num = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax , rmin = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> for i in range ( 1 , gate_num ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = max ( lmax , l ) <COMMENT> <NEWLINE> rmin = min ( rmin , r ) <COMMENT> <NEWLINE> <DEDENT> print ( max ( 0 , rmin - lmax + 1 ) ) <COMMENT> <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> s_length = len ( s ) <NEWLINE> t_length = len ( t ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> keep = <STRING> <NEWLINE> remind = 0 <NEWLINE> checker = False <NEWLINE> for i in range ( s_length ) : <NEWLINE> <INDENT> if ( i + t_length ) <= s_length : <NEWLINE> <INDENT> check = True <NEWLINE> for j in range ( t_length ) : <NEWLINE> <INDENT> if ( s [ i + j ] != t [ j ] ) & ( s [ i + j ] != <STRING> ) : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> checker = True <NEWLINE> ans = keep + t <NEWLINE> remind = i + t_length <NEWLINE> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> keep += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> keep += s [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = ans + keep [ remind : ] <NEWLINE> <NL> if checker : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> s = input ( ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( q ) ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] + s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for l , r in lr : <NEWLINE> <INDENT> print ( bisect . bisect ( a , r - 1 ) - bisect . bisect ( a , l - 0.1 ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> c = 0 <NEWLINE> m = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> m = max ( c , m ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> m = max ( c , m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( c , m ) <NEWLINE> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> c = 0 <NEWLINE> p = <STRING> <NEWLINE> count = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = count - c <NEWLINE> count = 1 <NEWLINE> <DEDENT> p = i <NEWLINE> <DEDENT> c = count - c <NEWLINE> print ( n - abs ( c ) ) <NEWLINE>
import numpy as np <NEWLINE> [ N , W ] , * h = [ list ( map ( int , i . split ( ) ) ) for i in open ( 0 ) ] <NEWLINE> <NL> dp = np . zeros ( W + 1 , dtype = int ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w = h [ i ] [ 0 ] <NEWLINE> v = h [ i ] [ 1 ] <NEWLINE> dp [ w : ] = np . maximum ( dp [ : - w ] + v , dp [ w : ] ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> s = input ( ) <NEWLINE> for i , ( x , y ) in enumerate ( zip ( s , s [ 1 : ] ) ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> print ( i + 1 , i + 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if len ( s ) <= 2 : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i , ( x , y , z ) in enumerate ( zip ( s , s [ 1 : ] , s [ 2 : ] ) ) : <NEWLINE> <INDENT> if x == z : <NEWLINE> <INDENT> print ( i + 1 , i + 3 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 , - 1 ) <NEWLINE>
def abc075_d ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ ] <NEWLINE> xarr = [ ] <NEWLINE> yarr = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> P . append ( ( x , y ) ) <NEWLINE> xarr . append ( x ) <NEWLINE> yarr . append ( y ) <NEWLINE> <DEDENT> xarr . sort ( ) <NEWLINE> yarr . sort ( ) <NEWLINE> <NL> ans = 5 * 10 ** 18 <NEWLINE> for s , xi in enumerate ( xarr ) : <NEWLINE> <INDENT> for xj in xarr [ s + 1 : ] : <NEWLINE> <INDENT> cand = [ ( x , y ) for x , y in P if xi <= x and x <= xj ] <NEWLINE> for t , yi in enumerate ( yarr ) : <NEWLINE> <INDENT> for yj in yarr [ t + 1 : ] : <NEWLINE> <INDENT> cnt = len ( [ y for x , y in cand if yi <= y and y <= yj ] ) <NEWLINE> if cnt >= k : <NEWLINE> <INDENT> area = ( xj - xi ) * ( yj - yi ) <NEWLINE> ans = min ( ans , area ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc075_d ( ) <NEWLINE> <DEDENT>
n , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D_list = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( c ) ] <NEWLINE> c_list = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> c_num = [ [ 0 for _ in range ( 3 ) ] for __ in range ( c ) ] <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( n ) : <NEWLINE> <INDENT> c_num [ c_list [ b ] [ a ] - 1 ] [ ( a + b + 2 ) % 3 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 10 ** 10 <NEWLINE> for i in range ( 1 , c ** 3 ) : <NEWLINE> <INDENT> x = i % c <NEWLINE> y = ( i % c ** 2 ) // c <NEWLINE> z = i // c ** 2 <NEWLINE> if x == y or y == z or z == x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color = [ x , y , z ] <NEWLINE> count = 0 <NEWLINE> for s in range ( 3 ) : <NEWLINE> <INDENT> for t in range ( c ) : <NEWLINE> <INDENT> count += c_num [ t ] [ s ] * D_list [ t ] [ color [ s ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> if count < ans : <NEWLINE> <INDENT> ans = count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from string import ascii_lowercase <NEWLINE> from bisect import bisect_right , bisect_left <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> len_s = len ( s ) <NEWLINE> s_all = { s : [ ] for s in ascii_lowercase } <NEWLINE> for i in range ( len_s ) : <NEWLINE> <INDENT> s_all [ s [ i ] ] . append ( i + 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if any ( s_all [ tt ] == [ ] for tt in t ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_ind = 1 <NEWLINE> for ss in ascii_lowercase : <NEWLINE> <INDENT> s_all [ ss ] . sort ( ) <NEWLINE> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> next_ind = bisect_left ( s_all [ t [ i ] ] , s_ind ) <NEWLINE> if next_ind == len ( s_all [ t [ i ] ] ) : <NEWLINE> <INDENT> ans += len_s - s_ind + 1 <NEWLINE> ans += s_all [ t [ i ] ] [ 0 ] <NEWLINE> s_ind = s_all [ t [ i ] ] [ 0 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s_all [ t [ i ] ] [ next_ind ] - s_ind + 1 <NEWLINE> s_ind = s_all [ t [ i ] ] [ next_ind ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> <NL> <COMMENT> <NL> price1 = A * X + B * Y <NEWLINE> l . append ( price1 ) <NEWLINE> <NL> <COMMENT> <NL> if X > Y : <NEWLINE> <INDENT> if A < 2 * C : <NEWLINE> <INDENT> price2 = 2 * Y * C + A * abs ( X - Y ) <NEWLINE> l . append ( price2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> price3 = 2 * Y * C + C * abs ( X - Y ) * 2 <NEWLINE> l . append ( price3 ) <NEWLINE> <DEDENT> <DEDENT> elif X < Y : <NEWLINE> <INDENT> if B < 2 * C : <NEWLINE> <INDENT> price4 = 2 * X * C + B * abs ( Y - X ) <NEWLINE> l . append ( price4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> price5 = 2 * X * C + C * abs ( Y - X ) * 2 <NEWLINE> l . append ( price5 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> price6 = 2 * X * C <NEWLINE> l . append ( price6 ) <NEWLINE> <NL> <NL> <DEDENT> print ( min ( l ) ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> LR = np . array ( [ list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for _ in range ( M ) ] ) <NEWLINE> print ( max ( min ( LR [ : , 1 ] ) - max ( LR [ : , 0 ] ) + 1 , 0 ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> li_nq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> li_px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( ( q ) ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i , j in li_nq : <NEWLINE> <INDENT> graph [ i ] . append ( j ) <NEWLINE> graph [ j ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for i , j in li_px : <NEWLINE> <INDENT> ans [ i ] += j <NEWLINE> <NL> <DEDENT> check_list = [ None ] * ( n + 1 ) <NEWLINE> stack = [ 1 ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> num = stack . pop ( ) <NEWLINE> for i in graph [ num ] : <NEWLINE> <INDENT> if check_list [ num ] == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack . append ( i ) <NEWLINE> ans [ i ] += ans [ num ] <NEWLINE> check_list [ i ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans [ 1 : ] ) <NEWLINE>
from bisect import bisect_right <NEWLINE> <NL> n , d , a = map ( int , input ( ) . split ( ) ) <NEWLINE> xh = sorted ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ) <NEWLINE> x = [ 0 ] * ( n + 1 ) <NEWLINE> h = [ 0 ] * ( n + 1 ) <NEWLINE> s = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i , ( f , g ) in enumerate ( xh ) : <NEWLINE> <INDENT> x [ i ] , h [ i ] = f , g <NEWLINE> <DEDENT> x [ n ] = 10 ** 10 + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> s [ i ] += s [ i - 1 ] <NEWLINE> <DEDENT> h [ i ] -= s [ i ] <NEWLINE> if h [ i ] > 0 : <NEWLINE> <INDENT> num = 0 - - h [ i ] // a <NEWLINE> ans += num <NEWLINE> s [ i ] += num * a <NEWLINE> <NL> j = bisect_right ( x , x [ i ] + d * 2 ) <NEWLINE> s [ j ] -= num * a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for l in range ( k + 1 ) : <NEWLINE> <INDENT> for m in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( l + m ) <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num_lists = [ a , b , c ] <NEWLINE> maximum = a <NEWLINE> if maximum < b : maximum = b <NEWLINE> if maximum < c : maximum = c <NEWLINE> <NL> max_index = num_lists . index ( maximum ) <NEWLINE> num_lists . pop ( max_index ) <NEWLINE> <NL> remainder = num_lists [ 0 ] + num_lists [ 1 ] <NEWLINE> if maximum == remainder : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> s = np . count_nonzero ( a >> i & 1 ) <NEWLINE> ans += pow ( 2 , i , mod ) * s * ( N - s ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = Counter ( a ) <NEWLINE> ans = [ 0 ] * 2 <NEWLINE> t = 0 <NEWLINE> for i in sorted ( count . items ( ) , reverse = True ) : <NEWLINE> <INDENT> if i [ 1 ] >= 4 : <NEWLINE> <INDENT> if t == 0 : <NEWLINE> <INDENT> ans [ 0 ] , ans [ 1 ] = i [ 0 ] , i [ 0 ] <NEWLINE> t = 2 <NEWLINE> <DEDENT> elif t == 1 : <NEWLINE> <INDENT> ans [ t ] = i [ 0 ] <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> elif i [ 1 ] >= 2 : <NEWLINE> <INDENT> ans [ t ] = i [ 0 ] <NEWLINE> t += 1 <NEWLINE> <DEDENT> if t == 2 : break <NEWLINE> <DEDENT> print ( ans [ 0 ] * ans [ 1 ] ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2019 <NEWLINE> <NL> for i in range ( l , min ( l + 2019 , r ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( l + 2019 , r + 1 ) ) : <NEWLINE> <INDENT> a = ( i * j ) % 2019 <NEWLINE> ans = min ( ans , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if len ( str ( abs ( a - b ) ) ) > 18 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( a - b ) * ( - 1 ) ** ( k % 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> step = [ ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] < h [ i + 1 ] : <NEWLINE> <INDENT> step . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step . append ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ i for i , x in enumerate ( step ) if x == 0 ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> d = a [ 0 ] <NEWLINE> ans . append ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a [ i ] - a [ i - 1 ] <NEWLINE> ans . append ( b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if not a : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ( n - 1 ) - a [ - 1 ] ) <NEWLINE> print ( max ( ans ) - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( abs ( l [ n // 2 - 1 ] - l [ n // 2 ] ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( input ( ) ) for i in range ( N ) ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> def button ( i , n ) : <NEWLINE> <INDENT> n_new = a [ n - 1 ] <NEWLINE> <NL> if i == N : <NEWLINE> <INDENT> if n != 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if n_new == 2 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return button ( i + 1 , n_new ) <NEWLINE> <NL> <DEDENT> <DEDENT> button ( 1 , 1 ) <NEWLINE>
n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 10 ** 9 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> b , c = a [ i ] , a [ i + k - 1 ] <NEWLINE> ans = min ( ans , min ( abs ( b ) , abs ( c ) ) + abs ( b - c ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ ] <NEWLINE> m = 0 <NEWLINE> arr = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m += ( p [ i ] + 1 ) / 2 <NEWLINE> e . append ( m ) <NEWLINE> <DEDENT> arr . append ( e [ k - 1 ] ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> arr . append ( e [ i + k ] - e [ i ] ) <NEWLINE> <DEDENT> ans = max ( arr ) <NEWLINE> print ( ans ) <NEWLINE>
def I ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def SI ( ) : return input ( ) . rstrip ( ) <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> h , w = MI ( ) <NEWLINE> uf = UnionFind ( h * w ) <NEWLINE> lis = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = SI ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> lis [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> step = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ - 1 , 0 ] , [ 1 , 0 ] ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> for x , y in step : <NEWLINE> <INDENT> if not ( 0 <= i + x < h and 0 <= j + y < w ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if lis [ i ] [ j ] != lis [ i + x ] [ j + y ] : <NEWLINE> <INDENT> uf . union ( w * i + j , w * ( i + x ) + ( j + y ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> dic = defaultdict ( lambda : [ 0 , 0 ] ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> dic [ uf . find ( w * i + j ) ] [ lis [ i ] [ j ] == 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for p in dic . keys ( ) : <NEWLINE> <INDENT> ans += dic [ p ] [ 0 ] * dic [ p ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> a = [ set ( ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> id = int ( input ( ) ) - 1 <NEWLINE> a [ id ] . add ( i ) <NEWLINE> <NL> <DEDENT> step = - 1 <NEWLINE> <COMMENT> <NL> now = a [ 1 ] <NEWLINE> next = set ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if 0 in now : <NEWLINE> <INDENT> step = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> for j in now : <NEWLINE> <INDENT> next = next . union ( a [ j ] ) <NEWLINE> <DEDENT> now = next <NEWLINE> next = set ( ) <NEWLINE> <NL> <DEDENT> print ( step ) <NEWLINE>
def zeroTrim ( s ) : <NEWLINE> <INDENT> while s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = s [ 1 : ] <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def calc ( N , K ) : <NEWLINE> <INDENT> digit = len ( N ) <NEWLINE> res = 0 <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> if digit > 1 : <NEWLINE> <INDENT> res += ( digit - 1 ) * 9 <NEWLINE> <DEDENT> res += int ( N [ 0 ] ) <NEWLINE> <DEDENT> elif K == 2 : <NEWLINE> <INDENT> if digit <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if digit > 2 : <NEWLINE> <INDENT> res += 9 * 9 * ( digit - 1 ) * ( digit - 2 ) // 2 <NEWLINE> <DEDENT> for i in range ( int ( N [ 0 ] ) - 1 ) : <NEWLINE> <INDENT> res += calc ( <STRING> * ( digit - 1 ) , 1 ) <NEWLINE> <DEDENT> res += calc ( zeroTrim ( N [ 1 : ] ) , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if digit <= 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if digit > 3 : <NEWLINE> <INDENT> res += 9 * 9 * 9 * ( digit - 1 ) * ( digit - 2 ) * ( digit - 3 ) // 6 <NEWLINE> <NL> <DEDENT> for i in range ( int ( N [ 0 ] ) - 1 ) : <NEWLINE> <INDENT> res += calc ( <STRING> * ( digit - 1 ) , 2 ) <NEWLINE> <DEDENT> res += calc ( zeroTrim ( N [ 1 : ] ) , 2 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> print ( calc ( N , K ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> b_cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b_cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b_cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> class Combination : <NEWLINE> <INDENT> def __init__ ( self , n_max , mod = 10 ** 9 + 7 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . mod = mod <NEWLINE> f = 1 <NEWLINE> self . fac = fac = [ f ] <NEWLINE> for i in range ( 1 , n_max + 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> fac . append ( f ) <NEWLINE> <DEDENT> f = pow ( f , mod - 2 , mod ) <NEWLINE> self . facinv = facinv = [ f ] <NEWLINE> for i in range ( n_max , 0 , - 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> facinv . append ( f ) <NEWLINE> <DEDENT> facinv . reverse ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def __call__ ( self , n , r ) : <COMMENT> <NEWLINE> <INDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def nCr ( self , n , r ) : <NEWLINE> <INDENT> if not 0 <= r <= n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fac [ n ] * self . facinv [ r ] % self . mod * self . facinv [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> def f ( r , c ) : <NEWLINE> <INDENT> return cmb . nCr ( r + c + 2 , r + 1 ) - 1 <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> r1 -= 1 <NEWLINE> c1 -= 1 <NEWLINE> <NL> cmb = Combination ( r2 + c2 + 5 ) <NEWLINE> ans = f ( r2 , c2 ) <NEWLINE> ans -= f ( r1 , c2 ) <NEWLINE> ans -= f ( r2 , c1 ) <NEWLINE> ans += f ( r1 , c1 ) <NEWLINE> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( [ i + 1 , a [ i ] ] ) <NEWLINE> <NL> <DEDENT> sl = sorted ( l , key = lambda x : x [ 1 ] ) <NEWLINE> sl0 = [ r [ 0 ] for r in sl ] <NEWLINE> print ( <STRING> . join ( [ str ( _ ) for _ in sl0 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> zyunban = [ 0 ] * n <NEWLINE> t = 1 <NEWLINE> <NL> for x in an : <NEWLINE> <INDENT> zyunban [ x - 1 ] = t <NEWLINE> t += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> zyunban = list ( map ( str , zyunban ) ) <NEWLINE> <NL> print ( <STRING> . join ( zyunban ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> s_par = [ i for i in range ( n + 1 ) ] <NEWLINE> t_par = [ i for i in range ( n + 1 ) ] <NEWLINE> <NL> def operation ( x , par ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if x [ i ] == x [ j ] : <NEWLINE> <INDENT> par [ i ] = par [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return par <NEWLINE> <NL> <DEDENT> if operation ( s , s_par ) == operation ( t , t_par ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> count = 0 <NEWLINE> num = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == num : <NEWLINE> <INDENT> count += 1 <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - count ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in cnt : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ a [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if c in cnt : <NEWLINE> <INDENT> cnt [ c ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ c ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> cnts = sorted ( cnt . items ( ) ) <NEWLINE> cnt = 0 <NEWLINE> tot = 0 <NEWLINE> last = ( 0 , 0 ) <NEWLINE> <NL> while cnt < n : <NEWLINE> <INDENT> last = cnts . pop ( ) <NEWLINE> tot += last [ 0 ] * last [ 1 ] <NEWLINE> cnt += last [ 1 ] <NEWLINE> <NL> <DEDENT> tot -= ( cnt - n ) * last [ 0 ] <NEWLINE> print ( tot ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> b = list ( a ) <NEWLINE> b . sort ( reverse = True ) <NEWLINE> c = b [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == c : <NEWLINE> <INDENT> print ( b [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
S = [ a for a in input ( ) ] <NEWLINE> N = [ int ( a ) for a in S ] <NEWLINE> M = [ N [ 0 ] ] + [ - N [ i ] for i in range ( 1 , 4 ) ] <NEWLINE> <NL> S . insert ( 1 , <STRING> ) <NEWLINE> S . insert ( 3 , <STRING> ) <NEWLINE> S . insert ( 5 , <STRING> ) <NEWLINE> <NL> if sum ( N ) == 7 : <NEWLINE> <INDENT> S = S <NEWLINE> print ( <STRING> . join ( S ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> N [ i ] = - N [ i ] <NEWLINE> <NL> if sum ( N ) == 7 : <NEWLINE> <NL> <INDENT> S [ 2 * i - 1 ] = <STRING> <NEWLINE> print ( <STRING> . join ( S ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : N [ i ] = - N [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> S [ 1 ] , S [ 3 ] , S [ 5 ] = <STRING> , <STRING> , <STRING> <NEWLINE> <NL> M [ i ] = - M [ i ] <NEWLINE> <NL> if sum ( M ) == 7 : <NEWLINE> <INDENT> S [ 2 * i - 1 ] = <STRING> <NEWLINE> print ( <STRING> . join ( S ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M [ i ] = - M [ i ] <NEWLINE> <DEDENT> <DEDENT>
a , b , c , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( ( a - b ) * ( ( - 1 ) ** K ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list . sort ( ) <NEWLINE> a_max = a_list [ n - 1 ] <NEWLINE> temp_max = [ 1 , 0 ] <NEWLINE> bunbo = 1 <NEWLINE> bunshi = 1 <NEWLINE> center = int ( ( a_max + 1 ) / 2 ) <NEWLINE> a_set = set ( a_list ) <NEWLINE> diff_min = a_max <NEWLINE> ans = 0 <NEWLINE> for a in a_set : <NEWLINE> <INDENT> diff = abs ( a - center ) <NEWLINE> if diff_min > diff : <NEWLINE> <INDENT> diff_min = diff <NEWLINE> ans = a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a_max , ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def sol ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> t = [ ] <NEWLINE> for a , b in tmp : <NEWLINE> <INDENT> t += [ b ] * a <NEWLINE> <NL> if len ( t ) >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += t <NEWLINE> A . sort ( reverse = 1 ) <NEWLINE> print ( sum ( A [ : N ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sol ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> integers = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> len_bin_k = len ( <STRING> . format ( K ) ) <NEWLINE> keys = [ K ] <NEWLINE> for shift in range ( 1 , len_bin_k + 1 ) : <NEWLINE> <INDENT> if ( K >> shift ) & 1 == 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> keys . append ( ( ( K >> shift ) << shift ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> vals = defaultdict ( int ) <NEWLINE> for a , b in integers : <NEWLINE> <INDENT> for k in keys : <NEWLINE> <COMMENT> <NL> <INDENT> if k | a == k : <NEWLINE> <INDENT> vals [ k ] += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( vals . values ( ) ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( vals . values ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
dict = { } <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> if s not in dict : dict [ s ] = 1 <NEWLINE> else : dict [ s ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in dict . values ( ) ] ) ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> P . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ad = { } <NEWLINE> for _ in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ad [ _ ] = set ( ) <NEWLINE> <NL> <DEDENT> for p in P : <NEWLINE> <INDENT> ad [ p [ 0 ] ] . add ( p [ 1 ] ) <NEWLINE> ad [ p [ 1 ] ] . add ( p [ 0 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for p in permutations ( range ( 2 , N + 1 ) , N - 1 ) : <NEWLINE> <INDENT> ans_flag = True <NEWLINE> start = 1 <NEWLINE> for p_ in p : <NEWLINE> <INDENT> end = p_ <NEWLINE> <COMMENT> <NL> if end not in ad [ start ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans_flag = False <NEWLINE> break <NEWLINE> <DEDENT> start = p_ <NEWLINE> <NL> <DEDENT> if ans_flag == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> aa = [ True ] * ( N + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> aa [ i ] = False <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if aa [ 1 ] : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if ( aa [ i ] == False ) : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] = dp [ i ] % MOD <NEWLINE> <DEDENT> print ( dp [ N ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List . sort ( ) <NEWLINE> cand = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cand . append ( ( b , c ) ) <NEWLINE> <DEDENT> bc = sorted ( cand , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> i = 0 <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> if i < n and List [ i ] < c : <NEWLINE> <INDENT> List [ i ] = c <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( List ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> pw = list ( <STRING> . format ( i ) ) <NEWLINE> <NL> if pw [ 0 ] in S : <NEWLINE> <INDENT> w1 = S . index ( pw [ 0 ] ) <NEWLINE> if pw [ 1 ] in S [ w1 + 1 : ] : <NEWLINE> <INDENT> w2 = w1 + 1 + S [ w1 + 1 : ] . index ( pw [ 1 ] ) <NEWLINE> if pw [ 2 ] in S [ w2 + 1 : ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 2019 <NEWLINE> for a in range ( L , min ( L + 2019 , R ) + 1 ) : <NEWLINE> <INDENT> for b in range ( L , min ( L + 2019 , R ) + 1 ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = min ( a * b % 2019 , ans ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if s - ( x + y ) <= k and s - ( x + y ) >= 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def prime_factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ex = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> ex += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> res . append ( [ i , ex ] ) <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> res . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prime = [ 0 ] * max ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> primes = prime_factorization ( a ) <NEWLINE> for num , ex in primes : <NEWLINE> <INDENT> prime [ num - 1 ] = max ( prime [ num - 1 ] , ex ) <NEWLINE> <NL> <DEDENT> <DEDENT> L = 1 <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> if prime [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> L *= pow ( i + 1 , prime [ i ] ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> res += L * pow ( a , mod - 2 , mod ) <NEWLINE> res %= mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ input ( ) . rstrip ( ) for _ in range ( H ) ] <NEWLINE> cut = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> cnt = 0 <NEWLINE> for ih in range ( H ) : <NEWLINE> <INDENT> if s [ ih ] . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> if s [ ih ] [ iw ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cut [ ih ] [ iw ] = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for ih in range ( H ) : <NEWLINE> <INDENT> for iw in range ( W - 1 ) : <NEWLINE> <INDENT> if cut [ ih ] [ iw + 1 ] == 0 : <NEWLINE> <INDENT> cut [ ih ] [ iw + 1 ] = cut [ ih ] [ iw ] <NEWLINE> <DEDENT> <DEDENT> for iw in range ( W - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if cut [ ih ] [ iw - 1 ] == 0 : <NEWLINE> <INDENT> cut [ ih ] [ iw - 1 ] = cut [ ih ] [ iw ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ih in range ( H - 1 ) : <NEWLINE> <INDENT> if cut [ ih + 1 ] [ 0 ] == 0 : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> cut [ ih + 1 ] [ iw ] = cut [ ih ] [ iw ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ih in range ( H - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if cut [ ih - 1 ] [ 0 ] == 0 : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> cut [ ih - 1 ] [ iw ] = cut [ ih ] [ iw ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( * cut [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( i + k + 1 , len ( s ) + 1 ) ) : <NEWLINE> <INDENT> l . append ( s [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( list ( set ( l ) ) ) [ k - 1 ] ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = 2019 <NEWLINE> flag = False <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> m = min ( m , i * j % 2019 ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : break <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> colors = [ 0 ] * n <NEWLINE> def dfs ( v , color ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> colors [ v ] = color <NEWLINE> for to in g [ v ] : <NEWLINE> <INDENT> if colors [ to ] == color : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if colors [ to ] == 0 : <NEWLINE> <INDENT> if not dfs ( to , - color ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_bipartite ( ) : <NEWLINE> <INDENT> return dfs ( 0 , 1 ) <NEWLINE> <NL> <DEDENT> if is_bipartite ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( colors . count ( - 1 ) * colors . count ( 1 ) - m ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( ( n * ( n - 1 ) ) // 2 - m ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ss = <STRING> . join ( s . replace ( <STRING> , <STRING> ) ) <NEWLINE> if ss != ss [ : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> left = 0 <NEWLINE> right = n - 1 <NEWLINE> while left <= right : <NEWLINE> <INDENT> if s [ left ] == s [ right ] : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ left ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> adj [ x ] . append ( y ) <NEWLINE> adj [ y ] . append ( x ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v , p ) : <NEWLINE> <INDENT> nim = 0 <NEWLINE> for u in adj [ v ] : <NEWLINE> <INDENT> if u == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nim ^= dfs ( u , v ) <NEWLINE> <DEDENT> if p == - 1 : <NEWLINE> <INDENT> return nim <NEWLINE> <DEDENT> nim += 1 <NEWLINE> return nim <NEWLINE> <NL> <DEDENT> res = dfs ( 0 , - 1 ) <NEWLINE> <NL> if res : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 or y == 0 : <NEWLINE> <INDENT> print ( w * h / 2 , 0 ) <NEWLINE> <DEDENT> elif w / x == 2 and h / y == 2 : <NEWLINE> <INDENT> r = x * h <NEWLINE> print ( r , 1 ) <NEWLINE> <DEDENT> elif w / x == 2 or h / y == 2 : <NEWLINE> <INDENT> if w / x == 2 : <NEWLINE> <INDENT> r = x * h <NEWLINE> print ( r , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = y * w <NEWLINE> print ( r , 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( w * h / 2 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> h . append ( tmp ) <NEWLINE> <DEDENT> h = sorted ( h ) <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> h2 = h [ i ] <NEWLINE> h3 = h [ i + K - 1 ] <NEWLINE> ans = min ( h3 - h2 , ans ) <NEWLINE> <DEDENT> print ( str ( ans ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> tl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ts = list ( set ( tl ) ) <NEWLINE> tc = Counter ( tl ) <NEWLINE> dc = Counter ( dl ) <NEWLINE> <NL> for t in ts : <NEWLINE> <INDENT> if tc [ t ] <= dc [ t ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> dp = np . array ( [ np . inf ] * N ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i - K >= 0 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - K : i ] + abs ( h [ i ] - h [ i - K : i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ 0 : i ] + abs ( h [ i ] - h [ 0 : i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( dp [ N - 1 ] ) ) <NEWLINE>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> C = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> C [ i ] += C [ i - 1 ] <NEWLINE> if ( S [ i - 1 : i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> C [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( C [ r - 1 ] - C [ l - 1 ] ) <NEWLINE> <DEDENT>
a , b , k = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> if a > k : <NEWLINE> <INDENT> a -= k <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> k -= a <NEWLINE> a = 0 <NEWLINE> <NL> <DEDENT> if b > k : <NEWLINE> <INDENT> b -= k <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> b = 0 <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <NL>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> m = sorted ( list ( set ( a ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> <NL> t = [ max ( a ) ] * n <NEWLINE> <NL> if c [ max ( a ) ] == 1 : <NEWLINE> <INDENT> t [ a . index ( max ( a ) ) ] = m [ - 2 ] <NEWLINE> <NL> <DEDENT> [ print ( i ) for i in t ] <NEWLINE>
<COMMENT> <NL> <NL> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if s < k : <NEWLINE> <INDENT> ans = ( s + 1 ) * ( s + 2 ) / 2 <NEWLINE> <DEDENT> elif s <= 2 * k : <NEWLINE> <INDENT> t = 2 * k - s <NEWLINE> a = ( k + 1 ) * ( k + 2 ) / 2 <NEWLINE> b = t * ( t + 1 ) / 2 <NEWLINE> c = t * ( 2 * k - ( t - 1 ) ) / 2 <NEWLINE> ans = a - b + c <NEWLINE> <DEDENT> elif s <= 3 * k : <NEWLINE> <INDENT> t = 3 * k - s + 1 <NEWLINE> ans = t * ( t + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> def swap ( index , swap_with_right ) : <NEWLINE> <INDENT> global p <NEWLINE> <NL> if swap_with_right : <NEWLINE> <INDENT> l = index <NEWLINE> r = index + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = index - 1 <NEWLINE> r = index <NEWLINE> <NL> <DEDENT> pl = p [ l ] <NEWLINE> pr = p [ r ] <NEWLINE> p [ l ] = pr <NEWLINE> p [ r ] = pl <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . insert ( 0 , 0 ) <NEWLINE> ans = 0 <NEWLINE> <NL> if p [ 1 ] == 1 : <NEWLINE> <INDENT> swap ( 1 , True ) <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i < N : <NEWLINE> <INDENT> if i == p [ i ] and i + 1 == p [ i + 1 ] : <NEWLINE> <INDENT> swap ( i , True ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif i == p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> elif i == p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> print ( ( n * ( n - 1 ) // 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = max ( t , c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> t = max ( t , c ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> score = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> score [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if score [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> t = 1 <NEWLINE> d = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = t * i % d <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
H , W , N = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> h -= 1 <NEWLINE> w -= 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if w - 1 < W - w - 1 : <NEWLINE> <INDENT> w -= 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if w > W - w - 2 : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if h - 1 < H - h - 1 : <NEWLINE> <INDENT> h -= 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if h > H - h - 2 : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> <DEDENT> if w == 0 or h == 0 or h == H or w == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if w - 1 > W - w - 1 : <NEWLINE> <INDENT> w -= 1 <NEWLINE> <DEDENT> <DEDENT> elif T [ i ] == <STRING> : <NEWLINE> <INDENT> if w < W - w - 2 : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> <DEDENT> elif T [ i ] == <STRING> : <NEWLINE> <INDENT> if h - 1 > H - h - 1 : <NEWLINE> <INDENT> h -= 1 <NEWLINE> <DEDENT> <DEDENT> elif T [ i ] == <STRING> : <NEWLINE> <INDENT> if h < H - h - 2 : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = math . factorial ( int ( input ( ) ) ) <NEWLINE> print ( r % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
import numpy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p = [ 0 ] + p + [ 0 ] <NEWLINE> <NL> S = numpy . sum ( numpy . abs ( numpy . diff ( p ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( S - numpy . abs ( p [ i ] - p [ i - 1 ] ) - numpy . abs ( p [ i + 1 ] - p [ i ] ) + numpy . abs ( p [ i + 1 ] - p [ i - 1 ] ) ) <NEWLINE> <DEDENT>
from collections import defaultdict , deque , Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> counter = Counter ( ) <NEWLINE> nodes = defaultdict ( list ) <NEWLINE> edges = [ ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> nodes [ u ] . append ( ( v , i ) ) <NEWLINE> nodes [ v ] . append ( ( u , i ) ) <NEWLINE> edges . append ( ( u , v ) ) <NEWLINE> <NL> <DEDENT> K = 0 <NEWLINE> for node in nodes . values ( ) : <NEWLINE> <INDENT> K = max ( K , len ( node ) ) <NEWLINE> <NL> <DEDENT> checked = set ( ) <NEWLINE> queue = deque ( [ ( 1 , 0 ) ] ) <NEWLINE> edge_colors = [ 0 ] * N <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> u , uc = queue . popleft ( ) <NEWLINE> checked . add ( u ) <NEWLINE> color = 1 <NEWLINE> for v , e in nodes [ u ] : <NEWLINE> <INDENT> if v in checked : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if color == uc : <NEWLINE> <INDENT> color += 1 <NEWLINE> <DEDENT> edge_colors [ e ] = color <NEWLINE> queue . append ( ( v , color ) ) <NEWLINE> color += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( K ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( edge_colors [ i ] ) <NEWLINE> <DEDENT>
def mid ( x , y , z ) : <NEWLINE> <INDENT> if x <= y <= z or z <= y <= x : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> elif y <= x <= z or z <= x <= y : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return z <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> from random import shuffle <NEWLINE> for _ in range ( 5 ) : <NEWLINE> <INDENT> arr = [ i for i in range ( 1 , 11 + 1 ) ] <NEWLINE> shuffle ( arr ) <NEWLINE> print ( arr , end = <STRING> ) <NEWLINE> while len ( arr ) > 1 : <NEWLINE> <INDENT> tmp = [ mid ( arr [ i ] , arr [ i + 1 ] , arr [ i + 2 ] ) for i in range ( len ( arr ) - 2 ) ] <NEWLINE> arr = tmp <NEWLINE> <DEDENT> print ( arr [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 1 or x == 2 * n - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ None ] * ( 2 * n - 1 ) <NEWLINE> st = set ( i for i in range ( 1 , 2 * n ) ) <NEWLINE> ans [ n - 1 ] = x <NEWLINE> st . remove ( x ) <NEWLINE> if x == 2 : <NEWLINE> <INDENT> ans [ n - 3 ] = 4 <NEWLINE> ans [ n - 2 ] = 1 <NEWLINE> ans [ n ] = 3 <NEWLINE> st . remove ( 1 ) <NEWLINE> st . remove ( 3 ) <NEWLINE> st . remove ( 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ n - 3 ] = x - 2 <NEWLINE> ans [ n - 2 ] = x + 1 <NEWLINE> ans [ n ] = x - 1 <NEWLINE> st . remove ( x - 2 ) <NEWLINE> st . remove ( x + 1 ) <NEWLINE> st . remove ( x - 1 ) <NEWLINE> <DEDENT> for i in range ( 2 * n - 1 ) : <NEWLINE> <INDENT> if ans [ i ] is None : <NEWLINE> <INDENT> ans [ i ] = st . pop ( ) <NEWLINE> <DEDENT> <DEDENT> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> X = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ [ [ 0 ] * ( 2550 ) for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> for s in range ( n * a + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if dp [ i ] [ j ] [ s ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> dp [ i + 1 ] [ j ] [ s ] += dp [ i ] [ j ] [ s ] <NEWLINE> <COMMENT> <NL> dp [ i + 1 ] [ j + 1 ] [ s + X [ i ] ] += dp [ i ] [ j ] [ s ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += dp [ n ] [ k ] [ k * a ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y != 0 : <NEWLINE> <INDENT> tmp = x % y <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> l = [ 1 ] * N <NEWLINE> l [ 0 ] = a [ 0 ] <NEWLINE> r = [ 1 ] * N <NEWLINE> r [ N - 1 ] = a [ N - 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l [ i ] = gcd ( l [ i - 1 ] , a [ i ] ) <NEWLINE> r [ N - 1 - i ] = gcd ( r [ N - i ] , a [ N - 1 - i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> n = r [ 1 ] <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> n = l [ N - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = gcd ( l [ i - 1 ] , r [ i + 1 ] ) <NEWLINE> <DEDENT> ans = max ( ans , n ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ None ] * n <NEWLINE> for idx , ea in enumerate ( a ) : <NEWLINE> <INDENT> ans [ ea - 1 ] = idx + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ss = list ( input ( ) ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> cum_sum_w = [ 0 ] * ( n + 1 ) <NEWLINE> cum_sum_e = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ss [ i ] == <STRING> : <NEWLINE> <INDENT> add = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add = 0 <NEWLINE> <DEDENT> cum_sum_w [ i + 1 ] = cum_sum_w [ i ] + add <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ss [ i ] == <STRING> : <NEWLINE> <INDENT> add = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add = 0 <NEWLINE> <DEDENT> cum_sum_e [ i + 1 ] = cum_sum_e [ i ] + add <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = cum_sum_w [ i ] + ( cum_sum_e [ n ] - cum_sum_e [ i + 1 ] ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R = list ( ) <NEWLINE> if K >= N : <NEWLINE> <INDENT> sums = 0 <NEWLINE> c = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sums += L [ i ] <NEWLINE> sums %= K <NEWLINE> a = ( sums - i - 1 ) % K <NEWLINE> if a in c : <NEWLINE> <INDENT> c [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> ans += ( c [ i ] - 1 ) * c [ i ] // 2 <NEWLINE> <DEDENT> if 0 in c : <NEWLINE> <INDENT> print ( ans + c [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> c = [ 0 ] * K <NEWLINE> sums = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sums += L [ i ] <NEWLINE> sums %= K <NEWLINE> a = ( sums - i - 1 ) % K <NEWLINE> R . append ( a ) <NEWLINE> <DEDENT> for i in range ( K - 1 ) : <NEWLINE> <INDENT> c [ R [ i ] ] += 1 <NEWLINE> <DEDENT> ans += c [ 0 ] <NEWLINE> c [ R [ K - 1 ] ] += 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i < N - K : <NEWLINE> <INDENT> ans += c [ R [ i ] ] - 1 <NEWLINE> c [ R [ i ] ] -= 1 <NEWLINE> c [ R [ i + K ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += c [ R [ i ] ] - 1 <NEWLINE> c [ R [ i ] ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Alice = [ ] <NEWLINE> Bob = [ ] <NEWLINE> while len ( an ) > 0 : <NEWLINE> <INDENT> Alice . append ( max ( an ) ) <NEWLINE> del an [ an . index ( max ( an ) ) ] <NEWLINE> if len ( an ) > 0 : <NEWLINE> <INDENT> Bob . append ( max ( an ) ) <NEWLINE> del an [ an . index ( max ( an ) ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> k = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( len ( Alice ) ) : <NEWLINE> <INDENT> k += Alice [ i ] <NEWLINE> <DEDENT> for i in range ( len ( Bob ) ) : <NEWLINE> <INDENT> j += Bob [ i ] <NEWLINE> <NL> <DEDENT> print ( str ( k - j ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> As = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> Steps = [ 0 ] * ( n + 1 ) <NEWLINE> Steps [ 0 ] = 1 <NEWLINE> if 1 not in As : <NEWLINE> <INDENT> Steps [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i in As : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> Steps [ i ] = Steps [ i - 1 ] + Steps [ i - 2 ] <NEWLINE> <DEDENT> ans = Steps [ - 1 ] % mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ok = 0 <NEWLINE> ng = 0 <NEWLINE> ng_l = { } <NEWLINE> end = set ( ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> p , S = [ x for x in input ( ) . split ( ) ] <NEWLINE> p = int ( p ) <NEWLINE> <NL> if not p in end : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> ok += 1 <NEWLINE> end . add ( p ) <NEWLINE> <NL> if p in ng_l : <NEWLINE> <INDENT> ng += ng_l [ p ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p in ng_l : <NEWLINE> <INDENT> ng_l [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng_l [ p ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( ok , ng ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Etop = 0 <NEWLINE> E = 0 <NEWLINE> q = [ ] <NEWLINE> Ruiseki = 0 <NEWLINE> S = [ ] <NEWLINE> Top = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> q . append ( ( i + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> for E in q : <NEWLINE> <INDENT> Ruiseki += E <NEWLINE> S . append ( Ruiseki ) <NEWLINE> <NL> <DEDENT> if N == K : <NEWLINE> <INDENT> print ( S [ N - 1 ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( N - K ) : <NEWLINE> <INDENT> Sig = S [ K + j ] - S [ j ] <NEWLINE> if Sig > Top : <NEWLINE> <INDENT> Top = Sig <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Top ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = np . zeros ( ( n , n ) , dtype = int ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ s - 1 ] [ t - 1 ] += 1 <NEWLINE> <DEDENT> lst = lst . cumsum ( axis = 1 ) [ : : - 1 ] . cumsum ( axis = 0 ) [ : : - 1 ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lst [ s - 1 ] [ t - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
menu = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> def kuriage ( n ) : <NEWLINE> <INDENT> if n % 10 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 10 - ( n % 10 ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> mini = 10 <NEWLINE> k = 5 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if menu [ i ] % 10 < mini and menu [ i ] % 10 != 0 : <NEWLINE> <INDENT> mini = menu [ i ] % 10 <NEWLINE> k = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> menu [ i ] , menu [ - 1 ] = menu [ - 1 ] , menu [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if i != 4 : <NEWLINE> <INDENT> ans += menu [ i ] + kuriage ( menu [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += menu [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif R - L == 1 : <NEWLINE> <INDENT> print ( ( R * L ) % 2019 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 4000 <NEWLINE> <NL> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> number = ( i * j ) % 2019 <NEWLINE> ans = min ( ans , number ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> t = <STRING> . join ( sorted ( t ) ) <NEWLINE> if t in d : <NEWLINE> <INDENT> ans += d [ t ] <NEWLINE> d [ t ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ t ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if ( 0 <= s - x - y ) and ( s - x - y <= k ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> gcd = math . gcd ( a , b ) <NEWLINE> <NL> def prime_factorization ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> prime = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n //= i <NEWLINE> prime . append ( i ) <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> prime . append ( n ) <NEWLINE> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> print ( len ( prime_factorization ( gcd ) ) + 1 ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> and S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tot = sum ( a ) <NEWLINE> b = 0 <NEWLINE> c = 10 ** 10 <NEWLINE> d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> d = abs ( tot / 2 - b ) <NEWLINE> if d < c : <NEWLINE> <INDENT> c = d <NEWLINE> <DEDENT> <DEDENT> print ( int ( 2 * c ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> if K < 1 / 2 * ( S - x ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for y in range ( min ( S - x + 1 , K + 1 ) ) : <NEWLINE> <INDENT> if K < ( S - x - y ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = 1 <NEWLINE> ar = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( len ( a ) - t + 1 ) : <NEWLINE> <INDENT> if a [ i : i + t ] not in ar : <NEWLINE> <INDENT> ar . append ( a [ i : i + t ] ) <NEWLINE> <DEDENT> <DEDENT> t += 1 <NEWLINE> if t > len ( a ) or t > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ar . sort ( ) <NEWLINE> print ( ar [ n - 1 ] ) <NEWLINE>
import sys <NEWLINE> from math import factorial <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def log ( * args ) : <NEWLINE> <INDENT> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if ( 2 * x - y ) % 3 != 0 or ( 2 * y - x ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> a = ( 2 * x - y ) // 3 <NEWLINE> b = ( 2 * y - x ) // 3 <NEWLINE> if a < 0 or b < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans = ( factorial_mod ( a + b , mod ) * pow ( factorial_mod ( min ( a , b ) , mod ) , mod - 2 , mod ) <NEWLINE> <INDENT> * pow ( factorial_mod ( a + b - min ( a , b ) , mod ) , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def factorial_mod ( a , mod ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for v in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = m // n <NEWLINE> ans = 0 <NEWLINE> <NL> for d in make_divisors ( m ) : <NEWLINE> <INDENT> if d <= h : <NEWLINE> <INDENT> ans = max ( ans , d ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if x * 2 < y or y * 2 < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> z = ( x + y ) // 3 <NEWLINE> <NL> x -= z <NEWLINE> y -= z <NEWLINE> <NL> n = x + y <NEWLINE> r = x <NEWLINE> <NL> if x == 0 or y == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> lst = [ 0 ] + [ 1 ] <NEWLINE> for i in range ( 2 , n + 10 ) : <NEWLINE> <INDENT> lst . append ( ( lst [ - 1 ] * i ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> xxx = lst [ n ] <NEWLINE> xxx *= pow ( lst [ n - r ] , 10 ** 9 + 5 , mod ) <NEWLINE> xxx %= mod <NEWLINE> xxx *= pow ( lst [ r ] , 10 ** 9 + 5 , mod ) <NEWLINE> xxx %= mod <NEWLINE> <NL> print ( xxx ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import deque <NEWLINE> from math import gcd <NEWLINE> a_left = deque ( ) <NEWLINE> <NL> a_left . append ( a [ 0 ] ) <NEWLINE> <NL> <NL> a_right = deque ( ) <NEWLINE> <NL> a_right . append ( a [ - 1 ] ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a_left . append ( gcd ( a_left [ - 1 ] , a [ i + 1 ] ) ) <NEWLINE> a_right . appendleft ( gcd ( a_right [ 0 ] , a [ n - i - 2 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> a_right = list ( a_right ) <NEWLINE> a_left = list ( a_left ) <NEWLINE> <NL> count = max ( a_left [ - 2 ] , a_right [ 1 ] ) <NEWLINE> <NL> for j in range ( n - 2 ) : <NEWLINE> <INDENT> count = max ( gcd ( a_left [ j ] , a_right [ j + 2 ] ) , count ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = N <NEWLINE> t = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if t + a [ i ] < K : <NEWLINE> <INDENT> t += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> Ans = [ ] <NEWLINE> <NL> if len ( O ) - len ( E ) == 0 : <NEWLINE> <INDENT> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> Ans . append ( O [ i ] ) <NEWLINE> Ans . append ( E [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( E ) ) : <NEWLINE> <INDENT> Ans . append ( O [ i ] ) <NEWLINE> Ans . append ( E [ i ] ) <NEWLINE> <DEDENT> Ans . append ( O [ len ( O ) - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( Ans ) ) <NEWLINE>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> x = i * r <NEWLINE> if x > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> y = j * g <NEWLINE> z = n - x - y <NEWLINE> if x + y > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if z >= 0 and z % b == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = - 1 <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> for i in range ( x // 2 + 1 ) : <NEWLINE> <INDENT> if i + 2 * ( x - 2 * i ) == y : <NEWLINE> <INDENT> a = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gyaku = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , a + 1 ) : <NEWLINE> <INDENT> gyaku . append ( ( ( p // i ) * - gyaku [ p % i ] ) % p ) <NEWLINE> <DEDENT> com = [ 1 ] <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> com . append ( com [ - 1 ] * gyaku [ i ] * ( x - a + 1 - i ) % p ) <NEWLINE> <DEDENT> <DEDENT> print ( com [ - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> import numba <NEWLINE> import math <NEWLINE> <NL> @ numba . njit <NEWLINE> def main ( N , K , steps ) : <NEWLINE> <NL> <INDENT> dpt = [ 10 ** 9 ] * ( N ) <NEWLINE> dpt [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i + j > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ij = i + j <NEWLINE> x = dpt [ i ] + abs ( steps [ i ] - steps [ ij ] ) <NEWLINE> if x < dpt [ ij ] : <NEWLINE> <INDENT> dpt [ ij ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dpt [ N - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> steps = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int32 ) <NEWLINE> main ( N , K , steps ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> city = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> city [ a - 1 ] += 1 <NEWLINE> city [ b - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( city [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( x ) <NEWLINE> b . append ( y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a [ i ] += ans <NEWLINE> mod = a [ i ] % b [ i ] <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> ans += b [ i ] - mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] - a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> k = 0 <NEWLINE> t = <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> if i == len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> t = a [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> if j == len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> t = b [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> if k == len ( c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> t = c [ k ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = True <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> if p == 0 : <NEWLINE> <INDENT> print ( 2 ** n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ** ( n - 1 ) ) <NEWLINE> <DEDENT>
o = list ( input ( ) ) <NEWLINE> e = input ( ) <NEWLINE> for i in range ( len ( e ) ) : <NEWLINE> <INDENT> o . insert ( 2 * i + 1 , e [ i ] ) <NEWLINE> <DEDENT> print ( * o , sep = <STRING> ) <NEWLINE>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( f + 1 ) <NEWLINE> w = [ ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( f + 1 ) : <NEWLINE> <INDENT> if i % ( a * 100 ) == 0 : dp [ i ] = i <NEWLINE> if i % ( b * 100 ) == 0 : dp [ i ] = i <NEWLINE> if i > a * 100 and dp [ i - a * 100 ] : dp [ i ] = i <NEWLINE> if i > a * 100 and dp [ i - b * 100 ] : dp [ i ] = i <NEWLINE> <DEDENT> for i in dp : <NEWLINE> <INDENT> if i : w . append ( i ) <NEWLINE> <DEDENT> m = w [ - 1 ] * e // 100 + 1 <NEWLINE> dp = [ 0 ] * ( m ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i % c == 0 : dp [ i ] = i <NEWLINE> if i % d == 0 : dp [ i ] = i <NEWLINE> if i > c and dp [ i - c ] : dp [ i ] = i <NEWLINE> if i > d and dp [ i - d ] : dp [ i ] = i <NEWLINE> <DEDENT> for i in dp : <NEWLINE> <INDENT> if i : s . append ( i ) <NEWLINE> <DEDENT> g = 0 <NEWLINE> ans = ( w [ 0 ] , 0 ) <NEWLINE> for i in w : <NEWLINE> <INDENT> for j in s : <NEWLINE> <INDENT> if i + j <= f and g < j / ( i + j ) <= e / ( 100 + e ) : <NEWLINE> <INDENT> g = j / ( i + j ) <NEWLINE> ans = ( i + j , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> lb = [ 0 ] * ( len ( B ) + 1 ) <NEWLINE> lsum = [ 0 ] * ( len ( B ) + 1 ) <NEWLINE> temp = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> lb [ i ] = bisect . bisect_left ( A , B [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> lsum [ i ] = lb [ i ] + lsum [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> temp = bisect . bisect_left ( B , C [ i ] ) <NEWLINE> ans += lsum [ temp - 1 ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a_ind = bisect . bisect_left ( A , b ) <NEWLINE> c_ind = bisect . bisect_right ( C , b ) <NEWLINE> ans += a_ind * ( n - c_ind ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a , b = [ ] , [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> if c % 10 == 0 : <NEWLINE> <INDENT> a . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( c ) <NEWLINE> <DEDENT> <DEDENT> if len ( b ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( a ) <NEWLINE> val = 0 <NEWLINE> for i in reversed ( range ( 1 , 1 + len ( b ) ) ) : <NEWLINE> <INDENT> for j in combinations ( b , i ) : <NEWLINE> <INDENT> val0 = sum ( j ) <NEWLINE> if val0 % 10 != 0 : <NEWLINE> <INDENT> val = max ( val0 , val ) <NEWLINE> <DEDENT> <DEDENT> if val != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if val == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( val + ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import copy <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> xl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> xl . append ( [ x - l , l + x ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> xl = sorted ( xl , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> r = 2 * ( 10 ** 9 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if xl [ i ] [ 1 ] > r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if xl [ i ] [ 0 ] <= r : <NEWLINE> <INDENT> r = xl [ i ] [ 0 ] <NEWLINE> <COMMENT> <NL> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 0 <NEWLINE> count = 1 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> p += i <NEWLINE> count += 1 <NEWLINE> if p > X : <NEWLINE> <INDENT> count -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <NL> dic = defaultdict ( int ) <NEWLINE> <NL> <COMMENT> <NL> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> left = str ( k ) [ 0 ] <NEWLINE> right = str ( k ) [ - 1 ] <NEWLINE> dic [ ( left , right ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> items = list ( dic . items ( ) ) <NEWLINE> for ( left , right ) , cnt in items : <NEWLINE> <INDENT> ans += cnt * dic [ ( right , left ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S ^= { input ( ) } <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> h , w = MAP ( ) <NEWLINE> a = [ [ 0 ] * ( w + 1 ) ] <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> a . append ( [ 0 ] + LIST ( ) ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> flag = False <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] % 2 == 1 : <NEWLINE> <INDENT> flag = not flag <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> ans . append ( [ i , j , i , j + 1 ] ) <NEWLINE> <DEDENT> elif i < h : <NEWLINE> <INDENT> ans . append ( [ i , j , i + 1 , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w , 0 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] % 2 == 1 : <NEWLINE> <INDENT> flag = not flag <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> if j > 1 : <NEWLINE> <INDENT> ans . append ( [ i , j , i , j - 1 ] ) <NEWLINE> <DEDENT> elif i < h : <NEWLINE> <INDENT> ans . append ( [ i , j , i + 1 , j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <DEDENT>
p , q , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def comb_mod ( N , K , modp ) : <NEWLINE> <NL> <INDENT> K_fact = 1 <NEWLINE> NK_fact = 1 <NEWLINE> N_fact = 1 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> K_fact *= i <NEWLINE> K_fact = K_fact % modp <NEWLINE> <DEDENT> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> NK_fact *= i <NEWLINE> NK_fact = NK_fact % modp <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> N_fact *= i <NEWLINE> N_fact = N_fact % modp <NEWLINE> <NL> <DEDENT> K_inv = pow ( K_fact , - 1 , modp ) <NEWLINE> NK_inv = pow ( NK_fact , - 1 , modp ) <NEWLINE> pat = ( N_fact * K_inv ) % modp * NK_inv % modp <NEWLINE> return pat <NEWLINE> <NL> <DEDENT> pat = comb_mod ( p * q - 2 , r - 2 , 10 ** 9 + 7 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , q + 1 ) : <NEWLINE> <INDENT> ans += i * ( q - i ) * p * p <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> for k in range ( 0 , p + 1 ) : <NEWLINE> <INDENT> ans += k * ( p - k ) * q * q % ( 10 ** 9 + 7 ) <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans * pat % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2019 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ALL = [ ] <NEWLINE> cnt = 0 <NEWLINE> import math <NEWLINE> def decide_sosuu ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> for i in range ( 1 , int ( ( 10 ** 5 ) / 2 + 2 ) ) : <NEWLINE> <INDENT> if decide_sosuu ( i ) : <NEWLINE> <INDENT> if decide_sosuu ( ( i * 2 ) - 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ALL . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ALL . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ALL . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l == 1 : <NEWLINE> <INDENT> print ( ALL [ int ( r / 2 ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ALL [ int ( r / 2 ) ] - ALL [ int ( l / 2 ) - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 200000000 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph1 = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> graph2 = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> reached = [ 0 ] * ( n + 1 ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph1 [ a ] . append ( b ) <NEWLINE> graph2 [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p ] += x <NEWLINE> <DEDENT> dfs ( 1 ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in ans [ 1 : ] ] ) ) <NEWLINE> <NL> <DEDENT> def dfs ( i ) : <NEWLINE> <INDENT> if reached [ i ] == 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> reached [ i ] = 1 <NEWLINE> for g in graph1 [ i ] , graph2 [ i ] : <NEWLINE> <INDENT> for j in g : <NEWLINE> <INDENT> if reached [ j ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ j ] += ans [ i ] <NEWLINE> dfs ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> A = [ 0 ] + LIST ( ) <NEWLINE> <NL> A = list ( accumulate ( A ) ) <NEWLINE> dic = Counter ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in dic . values ( ) : <NEWLINE> <INDENT> ans += x * ( x - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> val = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> val *= i <NEWLINE> if val > 10 ** 9 + 7 : <NEWLINE> <INDENT> val = val % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( val ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != ( i - ans ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans != n else - 1 ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> from collections import defaultdict <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = in_n ( ) <NEWLINE> xy = [ tuple ( in_nn ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> comb = itertools . combinations ( range ( N ) , 2 ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> for i , j in comb : <NEWLINE> <INDENT> x1 , y1 = xy [ i ] <NEWLINE> x2 , y2 = xy [ j ] <NEWLINE> xd = x2 - x1 <NEWLINE> yd = y2 - y1 <NEWLINE> d [ ( xd , yd ) ] += 1 <NEWLINE> d [ ( - xd , - yd ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = N - max ( d . values ( ) ) <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> from collections import * <NEWLINE> C = Counter ( S ) <NEWLINE> <NL> ans = 1 <NEWLINE> for c in C . values ( ) : <NEWLINE> <INDENT> ans *= ( c + 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans = ( ans - 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> Z = S - i - j <NEWLINE> if 0 <= Z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> stones = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inf = 10 ** 9 <NEWLINE> dp = [ inf ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for t in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> step = i + t <NEWLINE> if step < n : <NEWLINE> <INDENT> v = dp [ i ] + abs ( stones [ i ] - stones [ step ] ) <NEWLINE> if v < dp [ step ] : <NEWLINE> <INDENT> dp [ step ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> List = list ( s ) + [ <STRING> ] <NEWLINE> n = len ( List ) <NEWLINE> R = 0 <NEWLINE> L = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if List [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> if L > 0 : <NEWLINE> <INDENT> ans [ i - L ] += ( L + 1 ) // 2 <NEWLINE> ans [ i - L - 1 ] += L // 2 <NEWLINE> L = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L += 1 <NEWLINE> if R > 0 : <NEWLINE> <INDENT> ans [ i ] += R // 2 <NEWLINE> ans [ i - 1 ] += ( R + 1 ) // 2 <NEWLINE> R = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ : - 1 ] ) <NEWLINE>
import string <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> min_cnt = float ( <STRING> ) <NEWLINE> <NL> for c in string . ascii_lowercase : <NEWLINE> <INDENT> if c not in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> s_ = s [ : ] <NEWLINE> while s_ : <NEWLINE> <INDENT> m = len ( s_ ) - 1 <NEWLINE> is_same = True <NEWLINE> for d in s_ : <NEWLINE> <INDENT> if d != c : <NEWLINE> <INDENT> is_same = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_same : <NEWLINE> <INDENT> min_cnt = min ( min_cnt , n - m - 1 ) <NEWLINE> <DEDENT> s_next = [ <STRING> ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if s_ [ i ] == c or s_ [ i + 1 ] == c : <NEWLINE> <INDENT> s_next [ i ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_next [ i ] = s_ [ i ] <NEWLINE> <DEDENT> <DEDENT> s_ = s_next <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_cnt ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> H , W = LI ( ) <NEWLINE> a = [ LI ( ) for _ in range ( H ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <COMMENT> <NL> if W >= 2 : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] % 2 == 1 : <NEWLINE> <INDENT> a [ i ] [ j ] -= 1 <NEWLINE> a [ i ] [ j + 1 ] += 1 <NEWLINE> ans . append ( ( i + 1 , j + 1 , i + 1 , j + 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if H >= 2 : <NEWLINE> <INDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ - 1 ] % 2 == 1 : <NEWLINE> <INDENT> a [ i ] [ - 1 ] -= 1 <NEWLINE> a [ i + 1 ] [ - 1 ] += 1 <NEWLINE> ans . append ( ( i + 1 , W , i + 2 , W ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> if ans : <NEWLINE> <INDENT> for i in ans : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> n = 2019 <NEWLINE> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l // n < r // n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ( i * j ) % n for i , j in combinations ( range ( l % n , r % n + 1 ) , 2 ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> x = np . median ( X ) <NEWLINE> index = N // 2 <NEWLINE> m1 = Y [ index ] <NEWLINE> m2 = Y [ index - 1 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] < x : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m2 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> num = { } <NEWLINE> for v in a : <NEWLINE> <INDENT> if v in num : <NEWLINE> <INDENT> num [ v ] = num [ v ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = int ( input ( ) ) <NEWLINE> t = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ok = True <NEWLINE> for v in t : <NEWLINE> <INDENT> if v not in num : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> elif num [ v ] <= 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ v ] = num [ v ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for _ in range ( 100000 ) ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ a - 1 ] . append ( - b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> heap = [ ] <NEWLINE> for a in range ( M ) : <NEWLINE> <INDENT> for b in AB [ a ] : <NEWLINE> <INDENT> heappush ( heap , b ) <NEWLINE> <DEDENT> if heap : <NEWLINE> <INDENT> ans -= heappop ( heap ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> b = input ( ) <NEWLINE> c = int ( 0 ) <NEWLINE> <NL> for i in range ( int ( a [ 0 ] ) ) : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> if b [ int ( a [ 0 ] ) ] != <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> <NL> <DEDENT> for i in range ( int ( a [ 0 ] ) + 1 , int ( a [ 0 ] ) + int ( a [ 1 ] ) + 1 ) : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m = input ( ) <NEWLINE> N = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> c = 0 <NEWLINE> N . sort ( ) <NEWLINE> for i in range ( len ( N ) - 1 ) : <NEWLINE> <INDENT> if N [ i ] == N [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> <NL> d = { <STRING> : 7 , <STRING> : 6 , <STRING> : 5 , <STRING> : 4 , <STRING> : 3 , <STRING> : 2 , <STRING> : 1 } <NEWLINE> print ( d [ S ] ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> from collections import Counter <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K , L = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> uf_road = UnionFind ( N ) <NEWLINE> uf_train = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> uf_road . union ( p - 1 , q - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( L ) : <NEWLINE> <INDENT> r , s = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> uf_train . union ( r - 1 , s - 1 ) <NEWLINE> <NL> <DEDENT> pairs = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pairs . append ( ( uf_road . find ( i ) , uf_train . find ( i ) ) ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( pairs ) <NEWLINE> res = [ cnt [ pair ] for pair in pairs ] <NEWLINE> print ( * res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = sorted ( list ( input ( ) for _ in range ( N ) ) ) <NEWLINE> print ( * S , sep = <STRING> ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> a = bisect . bisect ( l , l [ i ] + l [ j ] - 1 ) <NEWLINE> ans += ( a - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = list ( set ( A ) ) <NEWLINE> <NL> if len ( B ) % 2 == 0 : <NEWLINE> <INDENT> print ( len ( B ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( B ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_lst . sort ( ) <NEWLINE> a_set_lst = list ( set ( a_lst ) ) <NEWLINE> a_set_lst . sort ( ) <NEWLINE> <NL> count_lst = [ ] <NEWLINE> count = 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> count_lst . append ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a1 = a_lst [ i ] <NEWLINE> a2 = a_lst [ i + 1 ] <NEWLINE> <NL> if a1 == a2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if i == n - 2 : <NEWLINE> <INDENT> count_lst . append ( count ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count_lst . append ( count ) <NEWLINE> count = 1 <NEWLINE> <DEDENT> <DEDENT> if a_lst [ - 1 ] != a_lst [ - 2 ] : <NEWLINE> <INDENT> count_lst . append ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> minimum = 0 <NEWLINE> for i in range ( len ( a_set_lst ) ) : <NEWLINE> <INDENT> number = a_set_lst [ i ] <NEWLINE> count = count_lst [ i ] <NEWLINE> <NL> if count < number : <NEWLINE> <INDENT> minimum += count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minimum += count - number <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = set ( range ( N + 1 ) ) <NEWLINE> l = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( L ) <NEWLINE> r . append ( R ) <NEWLINE> <DEDENT> ans = min ( r ) - max ( l ) + 1 <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> mp = [ [ ] for _ in range ( 26 ) ] <NEWLINE> s += s <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> mp [ ord ( s [ i ] ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> now = - 1 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> a = ord ( t [ i ] ) - ord ( <STRING> ) <NEWLINE> nxt = bisect_right ( mp [ a ] , now ) <NEWLINE> if len ( mp [ a ] ) == nxt : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> now = mp [ a ] [ nxt ] <NEWLINE> if now >= n : <NEWLINE> <INDENT> ans += n <NEWLINE> now -= n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans + now + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = True <NEWLINE> A = sorted ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> aa = [ ] <NEWLINE> i = 0 <NEWLINE> score = 0 <NEWLINE> <NL> while score < n : <NEWLINE> <INDENT> i += 1 <NEWLINE> score += i <NEWLINE> aa . append ( i ) <NEWLINE> <NL> <DEDENT> if score == n : <NEWLINE> <INDENT> for k in range ( len ( aa ) ) : <NEWLINE> <INDENT> print ( aa [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> aa . remove ( score - n ) <NEWLINE> for k in range ( len ( aa ) ) : <NEWLINE> <INDENT> print ( aa [ k ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> record = { } <NEWLINE> <NL> possible = True <NEWLINE> <NL> <COMMENT> <NL> for e in a : <NEWLINE> <INDENT> if ( e in record . keys ( ) ) : <NEWLINE> <INDENT> record [ e ] += 1 <NEWLINE> if ( record [ e ] == 2 ) : <NEWLINE> <INDENT> if ( e == 0 ) : <NEWLINE> <INDENT> possible = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( record [ e ] == 3 ) : <NEWLINE> <INDENT> possible = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> record [ e ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( possible == False ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> multiCount = int ( n / 2 ) <NEWLINE> <NL> print ( 2 ** multiCount % ( 10 ** 9 + 7 ) ) <NEWLINE>
from collections import deque <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> k = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> k . append ( [ a - 1 , b ] ) <NEWLINE> <DEDENT> m = [ - 1 ] * n <NEWLINE> m [ 0 ] = 0 <NEWLINE> m1 = [ - 1 ] * n <NEWLINE> m1 [ 0 ] = 0 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> d = q . popleft ( ) <NEWLINE> for i in g [ d ] : <NEWLINE> <INDENT> if m [ i ] == - 1 : <NEWLINE> <INDENT> m [ i ] = m [ d ] + 1 <NEWLINE> <DEDENT> if m1 [ i ] == - 1 : <NEWLINE> <INDENT> m1 [ i ] = d <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> kyori = [ [ ] for i in range ( max ( m ) + 1 ) ] <NEWLINE> for i , j in enumerate ( m ) : <NEWLINE> <INDENT> kyori [ j ] . append ( i ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i , j in k : <NEWLINE> <INDENT> ans [ i ] += j <NEWLINE> <DEDENT> for i in kyori [ 1 : ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> ans [ j ] = ans [ j ] + ans [ m1 [ j ] ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> q = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) - 1 <NEWLINE> q [ p ] = i <NEWLINE> <NL> <DEDENT> s = f = 0 <NEWLINE> c = set ( ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if q [ i ] < q [ i - 1 ] : <NEWLINE> <INDENT> f = i - 1 <NEWLINE> c . add ( f - s + 1 ) <NEWLINE> s = i <NEWLINE> <DEDENT> <DEDENT> if c == set ( ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - max ( c ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for char in s : <NEWLINE> <INDENT> if char != <STRING> : <NEWLINE> <INDENT> ans += char <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> le = len ( ans ) <NEWLINE> ans = ans [ 0 : le - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> per = 0.0 <NEWLINE> ans = salt = w = s = 0 <NEWLINE> for i in range ( 0 , f + 1 , 100 * a ) : <NEWLINE> <INDENT> for j in range ( 0 , f + 1 , 100 * b ) : <NEWLINE> <INDENT> w = i + j <NEWLINE> if w > f : break <NEWLINE> for k in range ( 0 , f + 1 , c ) : <NEWLINE> <INDENT> if w + k > f : break <NEWLINE> for l in range ( 0 , f + 1 , d ) : <NEWLINE> <INDENT> w = i + j <NEWLINE> s = k + l <NEWLINE> if w + s > f : break <NEWLINE> if s <= ( w // 100 ) * e : <NEWLINE> <INDENT> if 0 < s + w <= f : <NEWLINE> <INDENT> if per < s / ( s + w ) : <NEWLINE> <INDENT> per = s / ( s + w ) <NEWLINE> ans = w + s <NEWLINE> salt = s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( 100 * a , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans , salt ) <NEWLINE> <DEDENT>
H , W , h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> p = ( 10 ** 9 - 1 ) // ( max ( h * w - 1 , 1 ) ) <NEWLINE> m = p * ( h * w - 1 ) + 1 <NEWLINE> vec = [ [ p for i in range ( W + 1 ) ] for j in range ( H + 1 ) ] <NEWLINE> sm = 0 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if i % h == 0 and j % w == 0 : <NEWLINE> <INDENT> vec [ i ] [ j ] = - m <NEWLINE> <DEDENT> sm += vec [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> if sm <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> print ( vec [ i ] [ j ] , end = <STRING> [ j == W ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> def convolve ( A , B ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> dtype = np . int64 <NEWLINE> fft , ifft = np . fft . rfft , np . fft . irfft <NEWLINE> a , b = len ( A ) , len ( B ) <NEWLINE> if a == b == 1 : <NEWLINE> <INDENT> return np . array ( [ A [ 0 ] * B [ 0 ] ] ) <NEWLINE> <DEDENT> n = a + b - 1 <COMMENT> <NEWLINE> k = 1 << ( n - 1 ) . bit_length ( ) <NEWLINE> AB = np . zeros ( ( 2 , k ) , dtype = dtype ) <NEWLINE> AB [ 0 , : a ] = A <NEWLINE> AB [ 1 , : b ] = B <NEWLINE> return np . rint ( ifft ( fft ( AB [ 0 ] ) * fft ( AB [ 1 ] ) ) ) . astype ( np . int64 ) [ : n ] <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = np . zeros ( 100001 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> c = convolve ( cnt , cnt ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( c ) ) [ : : - 1 ] : <NEWLINE> <INDENT> if c [ i ] > 0 : <NEWLINE> <INDENT> p = min ( m , c [ i ] ) <NEWLINE> m -= p <NEWLINE> ans += i * p <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ 0 ] * ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ l - 1 ] += 1 <NEWLINE> road [ r - 1 ] -= 1 <NEWLINE> <DEDENT> road = list ( itertools . accumulate ( road ) ) [ : - 1 ] <NEWLINE> <NL> flag = 0 <NEWLINE> for ro in road : <NEWLINE> <INDENT> if ro % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL>
g = { } <NEWLINE> a = int ( input ( ) ) <NEWLINE> for i in range ( a - 1 ) : <NEWLINE> <INDENT> c = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> if c [ 0 ] not in g : g [ c [ 0 ] ] = [ ( c [ 1 ] , c [ 2 ] ) ] <NEWLINE> else : g [ c [ 0 ] ] . append ( ( c [ 1 ] , c [ 2 ] ) ) <NEWLINE> <NL> if c [ 1 ] not in g : g [ c [ 1 ] ] = [ ( c [ 0 ] , c [ 2 ] ) ] <NEWLINE> else : g [ c [ 1 ] ] . append ( ( c [ 0 ] , c [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> c = { } <NEWLINE> d = { i : False for i in range ( 1 , a + 1 ) } <NEWLINE> c [ 1 ] , d [ 1 ] = 0 , True <NEWLINE> Q = [ 1 ] <NEWLINE> while ( Q != [ ] ) : <NEWLINE> <INDENT> r = Q . pop ( 0 ) <NEWLINE> for i in g [ r ] : <NEWLINE> <INDENT> if d [ i [ 0 ] ] == False : <NEWLINE> <INDENT> d [ i [ 0 ] ] = True <NEWLINE> Q . append ( i [ 0 ] ) <NEWLINE> if i [ 1 ] % 2 == 0 : c [ i [ 0 ] ] = c [ r ] <NEWLINE> else : c [ i [ 0 ] ] = ( c [ r ] + 1 ) % 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , a + 1 ) : print ( c [ i ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lim = int ( N ** 0.5 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , lim + 1 ) : <NEWLINE> <INDENT> m = N // i <NEWLINE> quotient = N // m <NEWLINE> while m != 0 : <NEWLINE> <INDENT> remainder = N % m <NEWLINE> if N // m != quotient or remainder > i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if quotient == remainder : <NEWLINE> <INDENT> ans += m <NEWLINE> break <NEWLINE> <DEDENT> m -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
t = input ( ) <NEWLINE> s = list ( t ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if s == [ s [ 0 ] ] * len ( s ) : <NEWLINE> <INDENT> print ( ( len ( s ) * k ) // 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b = [ 1 ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] : b [ - 1 ] += 1 <NEWLINE> else : b . append ( 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in b : ans += i // 2 * k <NEWLINE> if t [ 0 ] == t [ - 1 ] and ( b [ 0 ] + b [ - 1 ] ) % 2 == 0 : ans += k - 1 <NEWLINE> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b - a <= k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i not in ans : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if j not in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = i <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> while k < n and l [ k ] < l [ i ] + l [ j ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> ans += k - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> print ( min ( s . count ( <STRING> ) , s . count ( <STRING> ) ) * 2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import ceil , floor , comb , factorial , gcd , pow , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> a = LIST ( ) <NEWLINE> b = [ LIST ( ) for i in range ( m ) ] <NEWLINE> b . sort ( key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> <NL> c = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> c += [ b [ i ] [ 1 ] ] * b [ i ] [ 0 ] <NEWLINE> if len ( c ) > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a += c <NEWLINE> a . sort ( reverse = True ) <NEWLINE> print ( sum ( a [ : n ] ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = [ ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> a . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( a ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ - 1 ] != s [ - 1 ] : <NEWLINE> <INDENT> a . append ( s [ - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( len ( a ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> full_root = [ 0 ] + A + [ 0 ] <NEWLINE> full_place = [ abs ( full_root [ i ] - full_root [ i + 1 ] ) for i in range ( N + 1 ) ] <NEWLINE> full_res = sum ( full_place ) <NEWLINE> <COMMENT> <NL> for ind in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res = full_res - sum ( full_place [ ind - 1 : ind + 1 ] ) + abs ( full_root [ ind - 1 ] - full_root [ ind + 1 ] ) <NEWLINE> <NL> print ( res ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for _ in range ( n ) ] <NEWLINE> f = lambda x : int ( x ) - 1 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( f , input ( ) . split ( ) ) <NEWLINE> root [ a ] . append ( b ) <NEWLINE> root [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> score = [ 0 ] * n <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visit = [ False ] * n <NEWLINE> def dfs ( now ) : <NEWLINE> <INDENT> visit [ now ] = True <NEWLINE> for go in root [ now ] : <NEWLINE> <INDENT> if visit [ go ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> score [ go ] += score [ now ] <NEWLINE> dfs ( go ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * score ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> cnt = np . count_nonzero ( a & 1 ) <NEWLINE> ans += ( n - cnt ) * cnt * ( 2 ** i ) <NEWLINE> if ans >= 10 ** 9 + 7 : <NEWLINE> <INDENT> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> a >>= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> s = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : s += 1 <NEWLINE> else : <NEWLINE> <INDENT> if s > 0 : <NEWLINE> <INDENT> s -= 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( x ) - cnt * 2 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> Ken_n , City_n = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> city = { i : [ ] for i in range ( 1 , Ken_n + 1 ) } <NEWLINE> for i in range ( 1 , City_n + 1 ) : <NEWLINE> <INDENT> p , y = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> city [ p ] . append ( ( y , i ) ) <NEWLINE> <NL> <DEDENT> city_ID = { i : 0 for i in range ( 1 , City_n + 1 ) } <NEWLINE> for i in range ( 1 , Ken_n + 1 ) : <NEWLINE> <INDENT> city [ i ] . sort ( ) <NEWLINE> <NL> for j in range ( len ( city [ i ] ) ) : <NEWLINE> <INDENT> city_ID [ city [ i ] [ j ] [ 1 ] ] = <STRING> . format ( i ) + <STRING> . format ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , City_n + 1 ) : <NEWLINE> <INDENT> print ( city_ID [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( reverse = True ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> numbers = make_divisors ( m ) <NEWLINE> for i in range ( len ( numbers ) ) : <NEWLINE> <INDENT> if numbers [ i ] <= m / n : <NEWLINE> <INDENT> print ( numbers [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = [ 2 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> L . append ( L [ i - 1 ] + L [ i - 2 ] ) <NEWLINE> <DEDENT> print ( L [ N ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 4 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> I = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> i = 1 <NEWLINE> for a in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> I [ a - 1 ] . append ( i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def dfs ( v , I , X ) : <NEWLINE> <INDENT> INF = 10 ** 20 <NEWLINE> DP = [ INF for _ in range ( X [ v ] + 1 ) ] <NEWLINE> DP [ 0 ] = 0 <NEWLINE> for i in I [ v ] : <NEWLINE> <INDENT> x = X [ i ] <NEWLINE> y = dfs ( i , I , X ) <NEWLINE> if x < y : <NEWLINE> <INDENT> x , y = y , x <COMMENT> <NEWLINE> <DEDENT> for a in range ( X [ v ] , - 1 , - 1 ) : <NEWLINE> <INDENT> if a - y >= 0 : <NEWLINE> <INDENT> DP [ a ] = DP [ a - y ] + x <NEWLINE> if a - x >= 0 : <NEWLINE> <INDENT> DP [ a ] = min ( DP [ a ] , DP [ a - x ] + y ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> DP [ a ] = INF <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = min ( DP ) <NEWLINE> <COMMENT> <NL> if ans >= INF : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> del DP , INF <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> dfs ( 0 , I , X ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> n , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> v = 0 <NEWLINE> acum = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> v += a <NEWLINE> acum . append ( v ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = INF <NEWLINE> for V in ( - 1 , 1 ) : <NEWLINE> <INDENT> cums = 0 <NEWLINE> count = 0 <NEWLINE> for a in acum : <NEWLINE> <COMMENT> <NL> <INDENT> V *= - 1 <NEWLINE> if ( a + cums ) * V > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> update = abs ( a + cums ) + 1 <NEWLINE> cums += ( update ) * V <NEWLINE> count += update <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ct = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> li = [ ] <NEWLINE> for k in ct : <NEWLINE> <INDENT> if k [ 1 ] <= T : <NEWLINE> <INDENT> li += [ k [ 0 ] ] <NEWLINE> <DEDENT> <DEDENT> if li == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( li ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> b = collections . Counter ( s ) <NEWLINE> c = sorted ( b . items ( ) ) <NEWLINE> con = [ ] <NEWLINE> n = 0 <NEWLINE> while True : <NEWLINE> <INDENT> con . append ( c [ n ] [ 0 ] ) <NEWLINE> if len ( con ) == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> check = c [ n ] [ 0 ] + c [ i ] [ 0 ] <NEWLINE> if check in s : <NEWLINE> <INDENT> con . append ( check ) <NEWLINE> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i_2 in range ( len ( c ) ) : <NEWLINE> <INDENT> check_2 = check + c [ i_2 ] [ 0 ] <NEWLINE> if check_2 in s : <NEWLINE> <INDENT> con . append ( check_2 ) <NEWLINE> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i_3 in range ( len ( c ) ) : <NEWLINE> <INDENT> check_3 = check_2 + c [ i_3 ] [ 0 ] <NEWLINE> if check_3 in s : <NEWLINE> <INDENT> con . append ( check_3 ) <NEWLINE> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i_4 in range ( len ( c ) ) : <NEWLINE> <INDENT> check_4 = check_3 + c [ i_4 ] [ 0 ] <NEWLINE> if check_4 in s : <NEWLINE> <INDENT> con . append ( check_4 ) <NEWLINE> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( con ) >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> print ( con [ k - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( a [ i ] - ( i + 1 ) ) <NEWLINE> <NL> <DEDENT> arr . sort ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> s = 0 <NEWLINE> b = arr [ n // 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += abs ( a [ i ] - ( b + ( i + 1 ) ) ) <NEWLINE> <DEDENT> ans . append ( s ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( ans [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> b = arr [ n // 2 + 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += abs ( a [ i ] - ( b + ( i + 1 ) ) ) <NEWLINE> <DEDENT> ans . append ( s ) <NEWLINE> <NL> print ( min ( ans ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> count = 0 <NEWLINE> <NL> <COMMENT> <NL> x = 0 <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> S . sort ( ) <NEWLINE> ans = sum ( S ) <NEWLINE> <NL> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] % 10 != 0 : <NEWLINE> <INDENT> print ( ans - S [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> Height = 10 ** 9 <NEWLINE> for i in range ( 0 , N - K + 1 ) : <NEWLINE> <INDENT> hmax = h [ i + K - 1 ] <NEWLINE> hmin = h [ i ] <NEWLINE> Height = min ( Height , hmax - hmin ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( Height ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> h . sort ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> <NL> stand = [ ] <NEWLINE> s_or_r = [ ] <NEWLINE> <NL> s_bf = <STRING> <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s_bf != S [ i ] and i != 0 : <NEWLINE> <INDENT> stand . append ( cnt ) <NEWLINE> s_or_r . append ( s_bf ) <NEWLINE> cnt = 1 <NEWLINE> s_bf = S [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> s_bf = S [ i ] <NEWLINE> <DEDENT> <DEDENT> stand . append ( cnt ) <NEWLINE> s_or_r . append ( s_bf ) <NEWLINE> <NL> <NL> <COMMENT> <NL> if s_or_r . count ( <STRING> ) <= K : <NEWLINE> <INDENT> print ( len ( S ) ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> if s_or_r [ 0 ] == <STRING> : <NEWLINE> <INDENT> s_or_r = [ <STRING> ] + s_or_r <NEWLINE> stand = [ 0 ] + stand <NEWLINE> <DEDENT> if s_or_r [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s_or_r . append ( <STRING> ) <NEWLINE> stand . append ( 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> tmp = sum ( stand [ 0 : 2 * K + 1 ] ) <NEWLINE> ans = tmp <NEWLINE> for i in range ( 2 , len ( stand ) - 2 * K , 2 ) : <NEWLINE> <INDENT> tmp += - ( stand [ i - 1 ] + stand [ i - 2 ] ) + stand [ i + 2 * K - 1 ] + stand [ i + 2 * K ] <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if m - 2 * n >= 0 : <NEWLINE> <INDENT> m -= 2 * n <NEWLINE> ans = n <NEWLINE> n = 0 <NEWLINE> <NL> if ( m - 2 * n ) % 4 == 0 : <NEWLINE> <INDENT> tmp = ( m - 2 * n ) // 4 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( m - 2 * n ) // 4 + 1 <NEWLINE> <NL> <DEDENT> ans += ( m - 2 * tmp ) // 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = m // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> num = lcm_list ( A ) % mod <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += ( num * pow ( a , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> B = [ int ( b ) for b in input ( ) . split ( <STRING> ) ] <NEWLINE> C = [ int ( c ) for c in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> combiBC = [ 0 ] * len ( B ) <NEWLINE> <COMMENT> <NL> <NL> ic = 0 <NEWLINE> lc = len ( C ) <NEWLINE> for ib in range ( len ( B ) ) : <NEWLINE> <INDENT> b = B [ ib ] <NEWLINE> while ic < lc : <NEWLINE> <INDENT> c = C [ ic ] <NEWLINE> if b >= c : <NEWLINE> <INDENT> ic += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> combiBC [ ib ] = lc - ic <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sumCombiBC = [ ] <NEWLINE> for i in range ( len ( combiBC ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> sumCombiBC . append ( combiBC [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sumCombiBC . insert ( 0 , combiBC [ - i - 1 ] + sumCombiBC [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> ib = 0 <NEWLINE> for ia in range ( len ( A ) ) : <NEWLINE> <INDENT> a = A [ ia ] <NEWLINE> while ib < len ( B ) : <NEWLINE> <INDENT> b = B [ ib ] <NEWLINE> if a >= b : <NEWLINE> <INDENT> ib += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += sumCombiBC [ ib ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> tree = { } <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B , C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if A not in tree : <NEWLINE> <INDENT> tree [ A ] = [ ] <NEWLINE> <DEDENT> if B not in tree : <NEWLINE> <INDENT> tree [ B ] = [ ] <NEWLINE> <DEDENT> tree [ A ] . append ( ( B , C ) ) <NEWLINE> tree [ B ] . append ( ( A , C ) ) <NEWLINE> <NL> <NL> <DEDENT> c = { } <NEWLINE> q = [ ] <NEWLINE> visited = set ( ) <NEWLINE> <NL> def dfs ( a , acc ) : <NEWLINE> <INDENT> q . append ( ( a , acc ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> n , r = q . pop ( ) <NEWLINE> c [ n ] = r <NEWLINE> visited . add ( n ) <NEWLINE> for b , cost in ( ( b , cost ) for b , cost in tree [ n ] if b not in visited ) : <NEWLINE> <INDENT> q . append ( ( b , cost + r ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> Q , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dfs ( K , 0 ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( c [ x ] + c [ y ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import heapq <NEWLINE> <NL> n , m , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> a = [ * map ( lambda x : - x , a ) ] <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> heapq . heappush ( a , - ( - heapq . heappop ( a ) >> 1 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> p = i + 1 <NEWLINE> pnum = int ( s [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> p = 101 <NEWLINE> <NL> <DEDENT> if k < p : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( pnum ) <NEWLINE> <DEDENT>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> f = False <NEWLINE> x = [ ] <NEWLINE> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> b . append ( 0 ) <NEWLINE> f = True <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> x . append ( a [ i ] ) <NEWLINE> x . append ( b [ i ] ) <NEWLINE> <DEDENT> if f : <NEWLINE> <INDENT> x . pop ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( x ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> mx = max ( A ) <NEWLINE> mxidx = A . index ( mx ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == mxidx : <NEWLINE> <INDENT> B = A [ 0 : i ] + A [ i + 1 : N ] <NEWLINE> print ( max ( B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> last = 9 <NEWLINE> time = 0 <NEWLINE> cou = 0 <NEWLINE> check = 0 <NEWLINE> <COMMENT> <NL> l = [ A , B , C , D , E ] <NEWLINE> for i in l : <NEWLINE> <INDENT> if i % 10 != 0 : <NEWLINE> <INDENT> if last % 10 >= i % 10 : <NEWLINE> <INDENT> last = i <NEWLINE> check += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if check != 0 : <NEWLINE> <INDENT> l . remove ( last ) <NEWLINE> l . append ( last ) <NEWLINE> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> time += l [ i ] <NEWLINE> if i == 4 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while time % 10 != 0 : <NEWLINE> <INDENT> time += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( time ) <NEWLINE>
S = input ( ) <NEWLINE> week = { <STRING> : 7 , <STRING> : 6 , <STRING> : 5 , <STRING> : 4 , <STRING> : 3 , <STRING> : 2 , <STRING> : 1 } <NEWLINE> print ( week [ S ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> if i < 10 ** 5 : <NEWLINE> <INDENT> b [ i + 1 ] += 1 <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> hat = [ 0 , 0 , 0 ] <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> index = 0 <NEWLINE> for j , k in enumerate ( hat ) : <NEWLINE> <INDENT> if k == a [ i ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> index = j <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ( ans * tmp ) % mod <NEWLINE> <NL> hat [ index ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
from functools import reduce <NEWLINE> import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> n = I ( ) <NEWLINE> t = IR ( n ) <NEWLINE> <NL> <NL> def lcm_base ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> def lcm_list ( l ) : return reduce ( lcm_base , l , 1 ) <NEWLINE> <NL> <NL> ans = lcm_list ( t ) <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> printout = sys . stdout . write <NEWLINE> sprint = sys . stdout . flush <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def intread ( ) : <NEWLINE> <INDENT> return int ( sysread ( ) ) <NEWLINE> <DEDENT> def mapline ( t = int ) : <NEWLINE> <INDENT> return map ( t , sysread ( ) . split ( ) ) <NEWLINE> <DEDENT> def mapread ( t = int ) : <NEWLINE> <INDENT> return map ( t , read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> H , W = mapline ( ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> A . append ( list ( mapline ( ) ) ) <NEWLINE> <NL> <DEDENT> output = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ j ] % 2 : <NEWLINE> <INDENT> A [ i ] [ j ] -= 1 <NEWLINE> A [ i ] [ j + 1 ] += 1 <NEWLINE> output . append ( ( i , j , i , j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ W - 1 ] % 2 : <NEWLINE> <INDENT> A [ i ] [ W - 1 ] -= 1 <NEWLINE> A [ i + 1 ] [ W - 1 ] += 1 <NEWLINE> output . append ( ( i , W - 1 , i + 1 , W - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( output ) ) <NEWLINE> for i1 , j1 , i2 , j2 in output : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X % Y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if X * i % Y != 0 and X * i <= 10 ** 18 : <NEWLINE> <INDENT> print ( X * i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> if X * i > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> maximum = max ( A ) <NEWLINE> count_max = A . count ( maximum ) <NEWLINE> if count_max > 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( maximum ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != maximum : <NEWLINE> <INDENT> print ( maximum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = A [ i ] <NEWLINE> A [ i ] = 0 <NEWLINE> print ( max ( A ) ) <NEWLINE> A [ i ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return [ set ( self . members ( r ) ) for r in self . roots ( ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . union ( x , y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> if uf . same ( i , p ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> i = - 1 <NEWLINE> for i in range ( ( n - 2 ) // 2 ) : <NEWLINE> <INDENT> ans += A [ i ] * 2 <NEWLINE> ans -= A [ - i - 1 ] * 2 <NEWLINE> <DEDENT> ans += A [ i + 1 ] <NEWLINE> ans += A [ i + 2 ] <NEWLINE> ans -= A [ i + 3 ] * 2 <NEWLINE> <NL> tmp = 0 <NEWLINE> for i in range ( ( n - 2 ) // 2 ) : <NEWLINE> <INDENT> tmp += A [ i ] * 2 <NEWLINE> tmp -= A [ - i - 1 ] * 2 <NEWLINE> <DEDENT> tmp += A [ i + 1 ] * 2 <NEWLINE> tmp -= A [ i + 2 ] <NEWLINE> tmp -= A [ i + 3 ] <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> i = - 1 <NEWLINE> for i in range ( ( n - 2 ) // 2 ) : <NEWLINE> <INDENT> ans += 2 * A [ i ] <NEWLINE> ans -= 2 * A [ - i - 1 ] <NEWLINE> <DEDENT> ans += A [ i + 1 ] <NEWLINE> ans -= A [ i + 2 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> if b - a < k : <NEWLINE> <INDENT> k = b - a + 1 <NEWLINE> <DEDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> x = list ( set ( x ) ) <NEWLINE> x . sort ( ) <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> Items = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> from collections import defaultdict as dd <NEWLINE> Bag = dd ( lambda : 0 ) <NEWLINE> Bag [ 0 ] = 0 <NEWLINE> for w , v in Items : <NEWLINE> <INDENT> temp = [ ( key + w , Bag [ key ] + v ) for key in Bag if key + w <= W ] <NEWLINE> for key , value in temp : <NEWLINE> <INDENT> Bag [ key ] = max ( Bag [ key ] , value ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( Bag . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE>
from bisect import bisect_left as bl <NEWLINE> from bisect import bisect_right as br <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> import math <NEWLINE> from collections import * <NEWLINE> from functools import reduce , cmp_to_key <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> from itertools import accumulate <NEWLINE> from functools import lru_cache <NEWLINE> <NL> M = mod = 10 ** 9 + 7 <NEWLINE> def factors ( n ) : return sorted ( set ( reduce ( list . __add__ , ( [ i , n // i ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) if n % i == 0 ) ) ) ) <NEWLINE> def inv_mod ( n ) : return pow ( n , mod - 2 , mod ) <NEWLINE> <NL> def li ( ) : return [ int ( i ) for i in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> def st ( ) : return input ( ) . rstrip ( <STRING> ) <NEWLINE> def val ( ) : return int ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> def li2 ( ) : return [ i for i in input ( ) . rstrip ( <STRING> ) ] <NEWLINE> def li3 ( ) : return [ int ( i ) for i in input ( ) . rstrip ( <STRING> ) ] <NEWLINE> <NL> <NL> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> g = 0 <NEWLINE> @ lru_cache ( None ) <NEWLINE> def dp ( i , par = - 1 , black = 0 ) : <NEWLINE> <INDENT> global g <NEWLINE> ans = 1 <NEWLINE> nokids = 1 <NEWLINE> if black : <NEWLINE> <INDENT> for j in g [ i ] : <NEWLINE> <INDENT> if j != par : <NEWLINE> <INDENT> nokids = 0 <NEWLINE> ans = ans * dp ( j , i , 0 ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in g [ i ] : <NEWLINE> <INDENT> if j != par : <NEWLINE> <INDENT> nokids = 0 <NEWLINE> ans = ( ans * ( dp ( j , i , 0 ) + dp ( j , i , 1 ) ) ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if nokids : ans = 1 <NEWLINE> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> n = val ( ) <NEWLINE> g = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> l = [ ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = li ( ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> root = 1 <NEWLINE> ans = dp ( root , - 1 , 0 ) + dp ( root , - 1 , 1 ) <NEWLINE> <NL> print ( ans % mod ) <NEWLINE>
import numpy as np <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ac_ques = np . array ( [ 0 ] * n ) <NEWLINE> count = np . array ( [ 0 ] * n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> if ac_ques [ int ( p ) - 1 ] == 0 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> count [ int ( p ) - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ac_ques [ int ( p ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( ac_ques ) , sum ( ac_ques * count ) ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> data = [ [ ] for _ in range ( n ) ] <NEWLINE> sides = [ ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> data [ a ] . append ( b ) <NEWLINE> data [ b ] . append ( a ) <NEWLINE> sides . append ( ( a , b ) ) <NEWLINE> <DEDENT> I = defaultdict ( lambda : 0 ) <NEWLINE> cs = [ 0 ] * n <NEWLINE> used = [ 0 ] * n <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> used [ 0 ] = 1 <NEWLINE> k = 0 <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> if k < len ( data [ u ] ) : <NEWLINE> <INDENT> k = len ( data [ u ] ) <NEWLINE> <DEDENT> cur = 1 <NEWLINE> for v in data [ u ] : <NEWLINE> <INDENT> if used [ v ] : continue <NEWLINE> if cur == cs [ u ] : cur += 1 <NEWLINE> cs [ v ] = cur <NEWLINE> I [ ( u , v ) ] = cur <NEWLINE> I [ ( v , u ) ] = cur <NEWLINE> cur += 1 <NEWLINE> used [ v ] = 1 <NEWLINE> q . append ( v ) <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE> for i , j in sides : <NEWLINE> <INDENT> print ( I [ ( i , j ) ] ) <NEWLINE> <DEDENT>
from scipy . special import comb <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> d = dict ( ) <NEWLINE> for x in a : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( x ) ) <NEWLINE> if s not in d . keys ( ) : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ comb ( i , 2 , exact = True ) for i in d . values ( ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> <NL> nums = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : nums [ i ] = abs ( a [ i ] - a [ i + 1 ] ) <NEWLINE> <NL> t = sum ( nums ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = t - ( nums [ i - 1 ] + nums [ i ] ) + abs ( a [ i - 1 ] - a [ i + 1 ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> on = [ ] <NEWLINE> off = [ ] <NEWLINE> <NL> acnt = 0 <NEWLINE> bcnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if bcnt > 0 : <NEWLINE> <INDENT> off . append ( bcnt ) <NEWLINE> bcnt = 0 <NEWLINE> <DEDENT> acnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if acnt > 0 : <NEWLINE> <INDENT> on . append ( acnt ) <NEWLINE> acnt = 0 <NEWLINE> <DEDENT> bcnt += 1 <NEWLINE> <DEDENT> <DEDENT> if bcnt > 0 : <NEWLINE> <INDENT> off . append ( bcnt ) <NEWLINE> bcnt = 0 <NEWLINE> <DEDENT> if acnt > 0 : <NEWLINE> <INDENT> on . append ( acnt ) <NEWLINE> acnt = 0 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( len ( on ) - k + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> a = sum ( on [ i : i + k ] ) <NEWLINE> b = sum ( off [ i : i + k + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += on [ i + k - 1 ] <NEWLINE> a -= on [ i - 1 ] <NEWLINE> if i + k <= len ( off ) - 1 : <NEWLINE> <INDENT> b += off [ i + k ] <NEWLINE> <DEDENT> b -= off [ i - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> s = a + b <NEWLINE> ans = max ( ans , s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( on ) - k + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> a = sum ( on [ i : i + k ] ) <NEWLINE> b = sum ( off [ i : i + k ] ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> a = sum ( on [ i : i + k ] ) <NEWLINE> b = sum ( off [ i - 1 : i + k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += on [ i + k - 1 ] <NEWLINE> a -= on [ i - 1 ] <NEWLINE> if i + k - 1 <= len ( off ) - 1 : <NEWLINE> <INDENT> b += off [ i + k - 1 ] <NEWLINE> <DEDENT> b -= off [ i - 2 ] <NEWLINE> <DEDENT> s = a + b <NEWLINE> <COMMENT> <NL> ans = max ( ans , s ) <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> lcm = ( N * M ) // math . gcd ( N , M ) <NEWLINE> ans = lcm <NEWLINE> Sp = lcm // N <NEWLINE> Tp = lcm // M <NEWLINE> lcmlcm = ( Sp * Tp ) // math . gcd ( Sp , Tp ) <NEWLINE> owari = min ( Sp * N , M * Tp ) <NEWLINE> for i in range ( 0 , owari , lcmlcm ) : <NEWLINE> <INDENT> if S [ i // Sp ] != T [ i // Tp ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <DEDENT> div_arr = make_divisors ( N ) <NEWLINE> <NL> if len ( div_arr ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif len ( div_arr ) == 2 : <NEWLINE> <INDENT> ans_num = max ( div_arr ) <NEWLINE> print ( len ( str ( ans_num ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo = [ ] <NEWLINE> if len ( div_arr ) % 2 == 0 : <NEWLINE> <INDENT> last_idx = - 1 <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( div_arr ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if N == div_arr [ i ] * div_arr [ last_idx ] and count != len ( div_arr ) // 2 : <NEWLINE> <INDENT> last_idx -= 1 <NEWLINE> memo . append ( len ( str ( div_arr [ last_idx ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> target_index = len ( div_arr ) // 2 <NEWLINE> memo . append ( len ( str ( div_arr [ target_index ] ) ) ) <NEWLINE> <DEDENT> print ( min ( memo ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> numbers = input ( ) <NEWLINE> <NL> lst = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pin = <STRING> <NEWLINE> if numbers [ i ] not in lst : <NEWLINE> <INDENT> pin += numbers [ i ] <NEWLINE> lst . append ( pin ) <NEWLINE> lst2 = [ ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> pin += numbers [ j ] <NEWLINE> if pin [ 1 ] not in lst2 : <NEWLINE> <INDENT> lst2 . append ( pin [ 1 ] ) <NEWLINE> lst3 = [ ] <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> pin += numbers [ k ] <NEWLINE> if pin [ 2 ] not in lst3 : <NEWLINE> <INDENT> lst3 . append ( pin [ 2 ] ) <NEWLINE> ans . append ( pin ) <NEWLINE> <DEDENT> if ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) and ( <STRING> in lst3 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pin = pin [ 0 ] + pin [ 1 ] <NEWLINE> <DEDENT> <DEDENT> if ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) and ( <STRING> in lst2 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pin = pin [ 0 ] <NEWLINE> <DEDENT> if ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) and ( <STRING> in lst ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ - 1 ] * n <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> Uni_1 = UnionFind ( N ) <NEWLINE> Uni_2 = UnionFind ( N ) <NEWLINE> D = { } <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Uni_1 . union ( p - 1 , q - 1 ) <NEWLINE> <DEDENT> for _ in range ( L ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Uni_2 . union ( p - 1 , q - 1 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> k = ( Uni_1 . find ( i ) , Uni_2 . find ( i ) ) <NEWLINE> if k in D . keys ( ) : <NEWLINE> <INDENT> D [ k ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( D [ ( Uni_1 . find ( i ) , Uni_2 . find ( i ) ) ] , end = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def Main ( ) : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> n = len ( s ) <NEWLINE> times = 10 ** 100 <NEWLINE> ans = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> save = [ i ] <NEWLINE> while s [ i + 1 ] != <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> save . append ( i ) <NEWLINE> <DEDENT> flg = save . pop ( ) <NEWLINE> ans [ flg ] += 1 <NEWLINE> for j in range ( len ( save ) ) : <NEWLINE> <INDENT> tmp = save . pop ( ) <NEWLINE> ans [ flg + abs ( flg - tmp ) % 2 ] += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> i = n - 1 <NEWLINE> while 0 <= i : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> i -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> save = [ i ] <NEWLINE> while s [ i - 1 ] != <STRING> : <NEWLINE> <INDENT> i -= 1 <NEWLINE> save . append ( i ) <NEWLINE> <DEDENT> flg = save . pop ( ) <NEWLINE> ans [ flg ] += 1 <NEWLINE> for j in range ( len ( save ) ) : <NEWLINE> <INDENT> tmp = save . pop ( ) <NEWLINE> ans [ flg - abs ( flg - tmp ) % 2 ] += 1 <NEWLINE> <DEDENT> i -= 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main_ ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( W + 1 , np . int64 ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> w = l [ n ] [ 0 ] <NEWLINE> v = l [ n ] [ 1 ] <NEWLINE> dp [ w : ] = np . maximum ( dp [ w : ] , dp [ : - w ] + v ) <NEWLINE> <DEDENT> return dp . max ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main_ ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> used = [ False ] * n <NEWLINE> ans = 0 <NEWLINE> def dfs ( itr , n , cnt = 0 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if len ( itr ) == n : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = cnt <NEWLINE> for e in g [ itr [ - 1 ] ] : <NEWLINE> <INDENT> if used [ e ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ e ] = True <NEWLINE> ans += dfs ( itr + [ e ] , n ) <NEWLINE> used [ e ] = False <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> used [ 0 ] = True <NEWLINE> print ( dfs ( [ 0 ] , n , 0 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> if b <= k : <NEWLINE> <INDENT> k -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from functools import lru_cache <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , M = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> As = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> memo = [ False for _ in range ( N + 1 ) ] <NEWLINE> <NL> for item in As : <NEWLINE> <INDENT> memo [ item ] = True <NEWLINE> <NL> <DEDENT> res_list = [ ] <NEWLINE> <NL> prev = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if memo [ i ] == True : <NEWLINE> <INDENT> res_list . append ( i - 1 - prev ) <NEWLINE> prev = i + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if memo [ N ] == False and memo [ N ] == False : <NEWLINE> <INDENT> res_list . append ( N - prev ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ lru_cache <NEWLINE> def cal ( num ) : <NEWLINE> <INDENT> if 0 <= num <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif num == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return cal ( num - 1 ) + cal ( num - 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> res = 1 <NEWLINE> for item in res_list : <NEWLINE> <INDENT> res *= cal ( item ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( res % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( b - a + 1 ) <= 2 * k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> L = [ 0 for i in range ( int ( 1e5 ) + 1 ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> L [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( int ( 1e5 ) + 1 ) : <NEWLINE> <INDENT> S = sum ( L [ i : i + 3 ] ) <NEWLINE> if ans < S : <NEWLINE> <INDENT> ans = S <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> for b in range ( 1 , x ) : <NEWLINE> <INDENT> for p in range ( 2 , x ) : <NEWLINE> <INDENT> if b ** p <= x : <NEWLINE> <INDENT> c = max ( c , b ** p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
def SieveOfEratosthenes ( n ) : <NEWLINE> <INDENT> prime = [ True for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while ( p * p <= n ) : <NEWLINE> <INDENT> if ( prime [ p ] == True ) : <NEWLINE> <INDENT> for i in range ( p * 2 , 10 ** 6 + 1 , p ) : <NEWLINE> <INDENT> if prime [ i ] : prime [ i ] = False <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> <DEDENT> prime [ 0 ] , prime [ 1 ] = False , False <NEWLINE> count = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if prime [ p ] and p >= n : <NEWLINE> <INDENT> print ( p ) ; break <NEWLINE> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> SieveOfEratosthenes ( n ) <NEWLINE>
S = input ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * 13 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> dp = [ sum ( dp [ 4 * ( j - k ) % 13 ] for k in range ( 10 ) ) % mod for j in range ( 13 ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( S [ i ] ) <NEWLINE> dp = [ dp [ 4 * ( j - a ) % 13 ] % mod for j in range ( 13 ) ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 5 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> comb = [ 1 ] * ( n - k + 1 ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> comb [ i + 1 ] = ( comb [ i ] * ( k + i ) * pow ( i + 1 , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> f = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> f = ( f + a [ k + i - 1 ] * comb [ i ] % mod ) % mod <NEWLINE> f = ( f - a [ i ] * comb [ - 1 - i ] % mod ) % mod <NEWLINE> <DEDENT> print ( f ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ next ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> AA = sorted ( A , reverse = True ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i != AA [ 0 ] : <NEWLINE> <INDENT> print ( AA [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( AA [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> h , w , k = MAP ( ) <NEWLINE> s = [ ] <NEWLINE> p = [ ] <NEWLINE> q = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> if s [ i ] . count ( <STRING> ) > 0 : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> num = 0 <NEWLINE> if p : <NEWLINE> <INDENT> for i in p : <NEWLINE> <INDENT> num += 1 <NEWLINE> m = 0 <NEWLINE> while s [ i ] [ m ] == <STRING> : <NEWLINE> <INDENT> a [ i ] [ m ] = num <NEWLINE> m += 1 <NEWLINE> <DEDENT> if m < w : <NEWLINE> <INDENT> if s [ i ] [ m ] == <STRING> : <NEWLINE> <INDENT> a [ i ] [ m ] = num <NEWLINE> m += 1 <NEWLINE> <DEDENT> if m < w : <NEWLINE> <INDENT> for j in range ( m , w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> a [ i ] [ j ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if q : <NEWLINE> <INDENT> for i in q : <NEWLINE> <INDENT> m = i <NEWLINE> while m < h and a [ m ] [ 0 ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> if m >= h : <NEWLINE> <INDENT> m = i <NEWLINE> while m > 0 and a [ m ] [ 0 ] == 0 : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> <DEDENT> a [ i ] [ : ] = a [ m ] [ : ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( * a [ i ] [ : ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ls = len ( S ) <NEWLINE> lt = len ( T ) <NEWLINE> left = - 1 <NEWLINE> <NL> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> for j in range ( lt ) : <NEWLINE> <INDENT> if S [ i + j ] != <STRING> and S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> left = i <NEWLINE> <DEDENT> <DEDENT> if left == - 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = S [ : left ] + T + S [ left + lt : ] <NEWLINE> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> lcm = n * m // math . gcd ( n , m ) <NEWLINE> <NL> x = { } <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> x [ lcm // n * i ] = c <NEWLINE> <NL> <DEDENT> for i , c in enumerate ( t ) : <NEWLINE> <COMMENT> <NL> <INDENT> pos , char = lcm // m * i , c <NEWLINE> if pos in x and x [ pos ] != char : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> C = sorted ( C . items ( ) ) <NEWLINE> <NL> cc = [ ] <NEWLINE> for a , b in C : <NEWLINE> <INDENT> cc . append ( [ a , b ] ) <NEWLINE> <DEDENT> C = cc <NEWLINE> <NL> M = len ( C ) <NEWLINE> <NL> left = 0 <NEWLINE> right = M - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if C [ left ] [ 1 ] < 2 : <NEWLINE> <INDENT> p_left = left <NEWLINE> for left in range ( p_left , M ) : <NEWLINE> <INDENT> if C [ left ] [ 1 ] > 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if C [ right ] [ 1 ] < 2 : <NEWLINE> <INDENT> p_right = M - right - 1 <NEWLINE> for right in range ( M ) : <NEWLINE> <INDENT> if C [ M - right - 1 ] [ 1 ] > 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> right = M - right - 1 <NEWLINE> <NL> <DEDENT> if C [ left ] [ 1 ] <= 1 and C [ right ] [ 1 ] <= 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if left == right : <NEWLINE> <INDENT> if C [ left ] [ 1 ] >= 3 : <NEWLINE> <INDENT> C [ left ] [ 1 ] -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> C [ left ] [ 1 ] -= 1 <NEWLINE> for i in range ( left + 1 , M ) : <NEWLINE> <INDENT> if C [ i ] [ 1 ] > 0 : <NEWLINE> <INDENT> C [ i ] [ 1 ] -= 1 <NEWLINE> f = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> for i in range ( 0 , left ) : <NEWLINE> <INDENT> if C [ i ] [ 1 ] > 0 : <NEWLINE> <INDENT> C [ i ] [ 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> C [ left ] [ 1 ] -= 1 <NEWLINE> C [ right ] [ 1 ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a , b in C : <NEWLINE> <INDENT> ans += b <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import string <NEWLINE> S = [ item for item in input ( ) ] <NEWLINE> temp_abc = [ item for item in string . ascii_lowercase ] <NEWLINE> <NL> if len ( S ) < 26 : <NEWLINE> <INDENT> for item in S : <NEWLINE> <INDENT> temp_abc . remove ( item ) <NEWLINE> <DEDENT> res = <STRING> . join ( S ) + temp_abc [ 0 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if S == temp_abc [ : : - 1 ] : <NEWLINE> <INDENT> res = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail_inorder = [ ] <NEWLINE> prev = <STRING> <NEWLINE> cnt = 0 <NEWLINE> for item in S [ : : - 1 ] : <NEWLINE> <INDENT> if item >= prev : <NEWLINE> <INDENT> tail_inorder += [ item ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> prev = item <NEWLINE> <DEDENT> end_letter = S [ - 1 * ( cnt + 1 ) ] <NEWLINE> tail_inorder . sort ( ) <NEWLINE> for item in tail_inorder : <NEWLINE> <INDENT> if end_letter < item : <NEWLINE> <INDENT> res_end_letter = item <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> res = S [ : - 1 * ( cnt + 1 ) ] + [ res_end_letter ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( res ) ) if res != - 1 else print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import networkx as nx <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> match_list = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> a , b = ab [ i ] <NEWLINE> c , d = cd [ j ] <NEWLINE> <NL> if a < c and b < d : <NEWLINE> <INDENT> match_list [ i ] . append ( j ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> group1 = range ( n ) <NEWLINE> group2 = range ( n , 2 * n ) <NEWLINE> <NL> g = nx . Graph ( ) <NEWLINE> g . add_nodes_from ( group1 , bipartite = 1 ) <NEWLINE> g . add_nodes_from ( group2 , bipartite = 0 ) <NEWLINE> <NL> for i , list_ in enumerate ( match_list ) : <NEWLINE> <INDENT> for j in list_ : <NEWLINE> <INDENT> g . add_edge ( i , j + n , weight = 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> d = nx . max_weight_matching ( g ) <NEWLINE> <NL> print ( len ( d ) ) <NEWLINE>
data = input ( ) . split ( ) <NEWLINE> N = int ( data [ 0 ] ) <NEWLINE> K = int ( data [ 1 ] ) <NEWLINE> S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> s [ K - 1 ] = S [ K - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N_sum = [ ] <NEWLINE> for A in range ( 1 , int ( N / 2 ) + 1 ) : <NEWLINE> <INDENT> B = N - A <NEWLINE> N_sum . append ( sum ( map ( int , str ( A ) + str ( B ) ) ) ) <NEWLINE> <DEDENT> print ( min ( N_sum ) ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> h = np . array ( [ - 1 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> dp = np . array ( [ - 1 for _ in range ( N + 1 ) ] , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> <NL> dp [ 1 ] = 0 <NEWLINE> for k in range ( 2 , N + 1 ) : <COMMENT> <NEWLINE> <INDENT> <STRING> <NEWLINE> start_index = max ( 1 , k - K ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> candidate = dp [ start_index : k ] + np . abs ( h [ k ] - h [ start_index : k ] ) <NEWLINE> dp [ k ] = np . min ( candidate ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
def f ( ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> i9 = 10 ** 9 <NEWLINE> if s == i9 ** 2 : <NEWLINE> <INDENT> print ( i9 , 0 , 0 , i9 , 0 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i9 - ( s % i9 ) , s // i9 + 1 , i9 , 1 , 0 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> f ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> asum = sum ( a ) <NEWLINE> adiv = make_divisors ( asum ) <NEWLINE> adiv . reverse ( ) <NEWLINE> <NL> a = np . array ( a ) <NEWLINE> ans = 1 <NEWLINE> flg = False <NEWLINE> for i in adiv : <NEWLINE> <INDENT> a_ = np . sort ( a % i ) <NEWLINE> <COMMENT> <NL> msum = a_ . sum ( ) <NEWLINE> msum_ = 0 <NEWLINE> for j in range ( - 1 , - n - 1 , - 1 ) : <NEWLINE> <INDENT> msum -= a_ [ j ] <NEWLINE> msum_ += i - a_ [ j ] <NEWLINE> if msum_ > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if msum < msum_ : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if msum == msum_ : <NEWLINE> <INDENT> ans = i <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def abc070_d ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10010010 ) <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> inp = iter ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> <NL> n = next ( inp ) <NEWLINE> adjlist = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a = next ( inp ) - 1 <NEWLINE> b = next ( inp ) - 1 <NEWLINE> c = next ( inp ) <NEWLINE> adjlist [ a ] . append ( ( b , c ) ) <NEWLINE> adjlist [ b ] . append ( ( a , c ) ) <NEWLINE> <NL> <DEDENT> q = next ( inp ) <NEWLINE> k = next ( inp ) - 1 <NEWLINE> <NL> dist = [ - 1 ] * n <NEWLINE> <NL> def dfs ( x : int , d : int ) : <NEWLINE> <INDENT> dist [ x ] = d <NEWLINE> for nx , nd in adjlist [ x ] : <NEWLINE> <INDENT> if dist [ nx ] != - 1 : continue <NEWLINE> dfs ( nx , d + nd ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( k , 0 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> x = next ( inp ) - 1 <NEWLINE> y = next ( inp ) - 1 <NEWLINE> ans = dist [ x ] + dist [ y ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc070_d ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( p [ : k ] ) <NEWLINE> q = [ ans ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> ans = ans + p [ i ] - p [ i - k ] <NEWLINE> q . append ( ans ) <NEWLINE> <DEDENT> print ( ( max ( q ) + k ) / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = sorted ( b ) <NEWLINE> c = sorted ( c ) <NEWLINE> <NL> from bisect import bisect_right <NEWLINE> <NL> d = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> index = bisect_right ( c , b [ i ] ) <NEWLINE> <NL> d . append ( n - index ) <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> s = sum ( d ) <NEWLINE> cum = np . cumsum ( d ) <NEWLINE> <NL> ans = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> dex = bisect_right ( b , a [ j ] ) <NEWLINE> if dex == 0 : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> elif dex == n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s - cum [ dex - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import bisect <NEWLINE> N , K , * A = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> K -= 1 <NEWLINE> L = [ [ ] for _ in range ( 2 * 10 ** 5 + 1 ) ] <NEWLINE> for i , a in enumerate ( A * 2 ) : <NEWLINE> <INDENT> L [ a ] += [ i ] <NEWLINE> <DEDENT> before_next = [ L [ a ] [ bisect . bisect ( L [ a ] , i ) ] for i , a in enumerate ( A ) ] <NEWLINE> first_cycle = [ None ] * N <NEWLINE> now = 0 <NEWLINE> idx = 0 <NEWLINE> cycle = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if first_cycle [ now ] is not None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> first_cycle [ now ] = cycle <NEWLINE> now = before_next [ now ] + 1 <NEWLINE> dcycle , now = divmod ( now , N ) <NEWLINE> cycle += dcycle <NEWLINE> <DEDENT> cycle2 = cycle <NEWLINE> cycle1 = first_cycle [ now ] <NEWLINE> <COMMENT> <NL> K2 = cycle1 + ( K - cycle1 ) % ( cycle2 - cycle1 ) <NEWLINE> if K2 : <NEWLINE> <INDENT> f1 = f2 = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if first_cycle [ i ] == K2 - 1 : <NEWLINE> <INDENT> f1 = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if first_cycle [ j ] == K2 : <NEWLINE> <INDENT> f2 = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f2 : <NEWLINE> <INDENT> B = A [ j : ] <NEWLINE> <DEDENT> elif f1 : <NEWLINE> <INDENT> B = A [ i : ] + A <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B = A <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> cnt = [ 0 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> for a in B : <NEWLINE> <INDENT> if cnt [ a ] > 0 : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> cnt [ ans . pop ( ) ] -= 1 <NEWLINE> if cnt [ a ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += [ a ] <NEWLINE> cnt [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
def Recording ( ) : <NEWLINE> <INDENT> n , c = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 2 * 10 ** 5 + 1 <NEWLINE> <NL> <COMMENT> <NL> imos = [ [ 0 ] * num for _ in range ( c ) ] <NEWLINE> <NL> <COMMENT> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> s , t , c0 = map ( int , input ( ) . split ( ) ) <NEWLINE> if imos [ c0 - 1 ] [ s * 2 ] < 0 and imos [ c0 - 1 ] [ t * 2 - 1 ] > 0 : <NEWLINE> <INDENT> imos [ c0 - 1 ] [ s * 2 ] = 0 <NEWLINE> imos [ c0 - 1 ] [ t * 2 - 1 ] = 0 <NEWLINE> <DEDENT> elif imos [ c0 - 1 ] [ s * 2 ] < 0 : <NEWLINE> <INDENT> imos [ c0 - 1 ] [ s * 2 ] = 0 <NEWLINE> imos [ c0 - 1 ] [ t * 2 ] -= 1 <NEWLINE> <DEDENT> elif imos [ c0 - 1 ] [ t * 2 - 1 ] > 0 : <NEWLINE> <INDENT> imos [ c0 - 1 ] [ s * 2 - 1 ] += 1 <NEWLINE> imos [ c0 - 1 ] [ t * 2 - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> imos [ c0 - 1 ] [ s * 2 - 1 ] += 1 <NEWLINE> imos [ c0 - 1 ] [ t * 2 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ 0 for _ in range ( num ) ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( 1 , num ) : <NEWLINE> <INDENT> imos [ i ] [ j ] += imos [ i ] [ j - 1 ] <NEWLINE> ans [ j ] += imos [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Recording ( ) <NEWLINE> <NL> <DEDENT>
N , M = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Now = [ 0 ] * N <NEWLINE> maxL = 1 <NEWLINE> minR = N <NEWLINE> for T in range ( 0 , M ) : <NEWLINE> <INDENT> L , R = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if maxL < L : <NEWLINE> <INDENT> maxL = L <NEWLINE> <DEDENT> if minR > R : <NEWLINE> <INDENT> minR = R <NEWLINE> <DEDENT> <DEDENT> if maxL > minR : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif maxL == minR : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif maxL < minR : <NEWLINE> <INDENT> print ( minR - maxL + 1 ) <NEWLINE> <DEDENT>
x , y , z , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] <NEWLINE> <NL> <NL> ans = [ ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> for j in range ( y ) : <NEWLINE> <INDENT> if i * j > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( z ) : <NEWLINE> <INDENT> if i * j * k > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( a [ i ] + b [ j ] + c [ k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = sorted ( ans ) [ : : - 1 ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
x = [ str ( input ( ) ) for i in range ( 2 ) ] <NEWLINE> if x [ 0 ] [ 0 ] == x [ 1 ] [ 2 ] and x [ 0 ] [ 1 ] == x [ 1 ] [ 1 ] and x [ 0 ] [ 2 ] == x [ 1 ] [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> <NL> n , m , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ u ] . append ( ( v , a , b ) ) <NEWLINE> e [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <DEDENT> S = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> S [ s ] = 0 <NEWLINE> h = [ ] <NEWLINE> heappush ( h , [ 0 , s ] ) <NEWLINE> while h : <NEWLINE> <INDENT> d , now = heappop ( h ) <NEWLINE> for nex , a , b in e [ now ] : <NEWLINE> <INDENT> if d + a < S [ nex ] : <NEWLINE> <INDENT> S [ nex ] = d + a <NEWLINE> heappush ( h , [ d + a , nex ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> T = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> T [ t ] = 0 <NEWLINE> h = [ ] <NEWLINE> heappush ( h , [ 0 , t ] ) <NEWLINE> while h : <NEWLINE> <INDENT> d , now = heappop ( h ) <NEWLINE> for nex , a , b in e [ now ] : <NEWLINE> <INDENT> if d + b < T [ nex ] : <NEWLINE> <INDENT> T [ nex ] = d + b <NEWLINE> heappush ( h , [ d + b , nex ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> cost = 10 ** 15 <NEWLINE> now = 0 <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> now = max ( now , cost - S [ i ] - T [ i ] ) <NEWLINE> ans [ i ] = now <NEWLINE> <DEDENT> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ ] <NEWLINE> <NL> for _ in range ( h ) : <NEWLINE> <INDENT> maze . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> move = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( maze [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> dist = [ [ 99999999 ] * w for _ in range ( h ) ] <NEWLINE> <NL> dq = deque ( ) <NEWLINE> y = i <NEWLINE> x = j <NEWLINE> d = 0 <NEWLINE> dist [ y ] [ x ] = 0 <NEWLINE> dq . append ( ( y , x , d ) ) <NEWLINE> <NL> while ( len ( dq ) ) : <NEWLINE> <NL> <INDENT> y , x , d = dq . popleft ( ) <NEWLINE> <NL> for m in move : <NEWLINE> <INDENT> if ( ( 0 <= x + m [ 0 ] < w ) and ( 0 <= y + m [ 1 ] < h ) and <NEWLINE> <INDENT> ( dist [ y + m [ 1 ] ] [ x + m [ 0 ] ] > d + 1 ) and <NEWLINE> <INDENT> ( maze [ y + m [ 1 ] ] [ x + m [ 0 ] ] == <STRING> ) ) : <NEWLINE> <INDENT> dist [ y + m [ 1 ] ] [ x + m [ 0 ] ] = d + 1 <NEWLINE> dq . append ( ( y + m [ 1 ] , x + m [ 0 ] , d + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , d ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 1 or M == 1 : <NEWLINE> <INDENT> if N + M == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * M - 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N - 2 ) * ( M - 2 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * ( 10 ** 5 + 5 ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> A [ ai - 1 ] += 1 <NEWLINE> A [ ai ] += 1 <NEWLINE> A [ ai + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> m = l [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if m >= l [ i ] : <NEWLINE> <INDENT> m = l [ i ] <NEWLINE> s += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> items = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> memo = np . zeros ( shape = W + 1 , dtype = np . int64 ) <NEWLINE> <NL> for w , v in items : <NEWLINE> <INDENT> memo [ w : ] = np . maximum ( memo [ w : ] , memo [ : - w ] + v ) <NEWLINE> <NL> <DEDENT> print ( memo [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 1000000007 : <NEWLINE> <INDENT> ans = ans % 1000000007 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> my_set = set ( ) <NEWLINE> for i in a_list : <NEWLINE> <INDENT> if i in my_set : <NEWLINE> <INDENT> my_set . remove ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> my_set . add ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( my_set ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( ( a [ i ] , 1 ) ) <NEWLINE> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( ( c , b ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> s . sort ( reverse = True ) <NEWLINE> idx = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if idx + s [ i ] [ 1 ] > n : <NEWLINE> <INDENT> sum += s [ i ] [ 0 ] * ( n - idx ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> sum += s [ i ] [ 0 ] * s [ i ] [ 1 ] <NEWLINE> idx += s [ i ] [ 1 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> b = [ 0 ] * 3 <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= b . count ( i ) <NEWLINE> ans %= m <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if b [ j ] == i : <NEWLINE> <INDENT> b [ j ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans % m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> R = S [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> z = str ( i ) . zfill ( 3 ) <NEWLINE> right = - 1 <NEWLINE> left = - 1 <NEWLINE> if z [ 2 ] in R : <NEWLINE> <INDENT> r = R . index ( z [ 2 ] ) + 1 <NEWLINE> right = N - r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if z [ 0 ] in S : <NEWLINE> <INDENT> left = S . index ( z [ 0 ] ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if z [ 1 ] in S [ left : right ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> S . sort ( ) <NEWLINE> import bisect <NEWLINE> a_uni = ord ( <STRING> ) <NEWLINE> <NL> Search = S <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> char = chr ( a_uni + i ) <NEWLINE> <NL> if Search and Search [ 0 ] == char : <NEWLINE> <INDENT> ind = bisect . bisect_right ( S , char ) <NEWLINE> Search = S [ ind : ] <NEWLINE> continue <NEWLINE> <DEDENT> print ( char ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> S = list ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> <NL> kake10 = [ 0 , 10 , 7 , 4 , 1 , 11 , 8 , 5 , 2 , 12 , 9 , 6 , 3 ] <NEWLINE> now = { 0 : 1 , 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 5 : 0 , 6 : 0 , 7 : 0 , 8 : 0 , 9 : 0 , 10 : 0 , 11 : 0 , 12 : 0 } <NEWLINE> for i in S : <NEWLINE> <INDENT> now = { kake10 [ x ] : now [ x ] for x in range ( 13 ) } <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> now2 = { x : sum ( now [ ( x + y ) % 13 ] for y in range ( 4 , 14 ) ) % 1000000007 for x in range ( 13 ) } <NEWLINE> now = now2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( i ) <NEWLINE> now = { ( x + a ) % 13 : now [ x ] for x in range ( 13 ) } <NEWLINE> <DEDENT> <DEDENT> print ( now [ 5 ] ) <NEWLINE>
from copy import deepcopy <NEWLINE> from math import ceil <NEWLINE> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> q = deepcopy ( p ) <NEWLINE> for i in range ( 2 , int ( p ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while p % i == 0 : <NEWLINE> <INDENT> p //= i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> ans *= i ** ( cnt // n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans if p != q and n != 1 else q ) <NEWLINE>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> rgb = sorted ( [ r , g , b ] ) <NEWLINE> n_rgb = [ ] <NEWLINE> for e in rgb : <NEWLINE> <INDENT> n_rgb . append ( n // e ) <NEWLINE> <DEDENT> for i in range ( n_rgb [ 2 ] + 1 ) : <NEWLINE> <INDENT> N2 = n - i * rgb [ 2 ] <NEWLINE> for j in range ( n_rgb [ 1 ] + 1 ) : <NEWLINE> <INDENT> N = N2 - j * rgb [ 1 ] <NEWLINE> if N >= 0 and N % rgb [ 0 ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> num = [ 0 ] * n <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> num [ i + 1 ] = count <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = num [ r - 1 ] - num [ l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H = sorted ( H ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans += H [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = [ ] <NEWLINE> a . append ( str ( n [ : len ( n ) : 2 ] ) ) <NEWLINE> print ( * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = int ( n ** 0.5 ) <NEWLINE> <NL> while n % m : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <NL> <DEDENT> print ( len ( str ( n // m ) ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = np . array ( a ) <NEWLINE> s = a . cumsum ( ) <NEWLINE> ans = abs ( 2 * s - sum ( a ) ) <NEWLINE> <NL> <NL> print ( min ( ans ) ) <NEWLINE>
N , A = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> X = [ int ( T ) for T in input ( ) . split ( ) ] <NEWLINE> DP = [ [ [ 0 ] * ( N + 1 ) for TS in range ( 0 , 50 * N + 1 ) ] for TI in range ( 0 , N + 1 ) ] <NEWLINE> DP [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for TI in range ( 0 , N ) : <NEWLINE> <INDENT> for TS in range ( 0 , 50 * N + 1 ) : <NEWLINE> <INDENT> for TK in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> if DP [ TI ] [ TS ] [ TK ] != 0 : <NEWLINE> <INDENT> DP [ TI + 1 ] [ TS ] [ TK ] += DP [ TI ] [ TS ] [ TK ] <NEWLINE> DP [ TI + 1 ] [ TS + X [ TI ] ] [ TK + 1 ] += DP [ TI ] [ TS ] [ TK ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( DP [ N ] [ A * TA ] [ TA ] for TA in range ( 1 , N + 1 ) ) ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> <NL> d = [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= M : <NEWLINE> <INDENT> if M % i == 0 : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> d . append ( M // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> d . sort ( ) <NEWLINE> <NL> for v in d : <NEWLINE> <INDENT> if v <= M // N : <NEWLINE> <INDENT> ans = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> black = c . count ( <STRING> ) <NEWLINE> white = c . count ( <STRING> ) <NEWLINE> <NL> if black == n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> b = 0 <NEWLINE> w = 0 <NEWLINE> now = 0 <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> w = ( i + 1 ) - b <NEWLINE> <NL> now = b + ( white - w ) <NEWLINE> ans = min ( ans , now ) <NEWLINE> <NL> <DEDENT> print ( min ( ans , white ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . add ( b - 1 ) <NEWLINE> tree [ b - 1 ] . add ( a - 1 ) <NEWLINE> <DEDENT> count = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> stack = [ [ 0 , 0 , - 1 ] ] <COMMENT> <NEWLINE> while stack : <NEWLINE> <INDENT> num , cnt , pr = stack . pop ( ) <NEWLINE> count [ num ] += cnt <NEWLINE> for k in tree [ num ] : <NEWLINE> <INDENT> if k == pr : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> stack . append ( [ k , count [ num ] , num ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xlist = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> ylist = sorted ( xlist ) <NEWLINE> max1 = ylist [ - 1 ] <NEWLINE> max2 = ylist [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if xlist [ i ] != max1 : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max2 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c1 = Counter ( v [ : : 2 ] ) <NEWLINE> c2 = Counter ( v [ 1 : : 2 ] ) <NEWLINE> if len ( set ( v ) ) == 1 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c1m = c1 . most_common ( 2 ) <NEWLINE> c2m = c2 . most_common ( 2 ) <NEWLINE> if c1m [ 0 ] [ 0 ] == c2m [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( min ( n - c1m [ 0 ] [ 1 ] - c2m [ 1 ] [ 1 ] , n - c1m [ 1 ] [ 1 ] - c2m [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - c1m [ 0 ] [ 1 ] - c2m [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> import math <NEWLINE> from math import gcd <NEWLINE> import itertools as it <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> def inp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def _debug ( obj ) : <NEWLINE> <INDENT> print ( obj , file = sys . stderr ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> N , M = inpl ( ) <NEWLINE> graph = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = inpl ( ) <NEWLINE> graph [ x ] . append ( y ) <NEWLINE> <NL> <DEDENT> flag = [ False ] * ( N + 1 ) <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <NL> def f ( x ) : <NEWLINE> <INDENT> if flag [ x ] : <NEWLINE> <INDENT> return dp [ x ] <NEWLINE> <DEDENT> flag [ x ] = True <NEWLINE> fans = 0 <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> fans = max ( fans , f ( y ) + 1 ) <NEWLINE> <DEDENT> dp [ x ] = fans <NEWLINE> return dp [ x ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , f ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = list ( map ( lambda x : ( 1 + x ) / 2 , p ) ) <NEWLINE> s = [ 0 ] <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num += p [ i ] <NEWLINE> s . append ( num ) <NEWLINE> <DEDENT> l = [ ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> l . append ( s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> if s in d : <NEWLINE> <INDENT> ans += d [ s ] <NEWLINE> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p [ i ] != i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <NL> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ input ( ) for i in range ( H ) ] <NEWLINE> <NL> direction = [ <NEWLINE> <INDENT> ( 0 , 1 ) , <NEWLINE> ( 1 , 0 ) , <NEWLINE> ( - 1 , 0 ) , <NEWLINE> ( 0 , - 1 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <NL> def bfs ( sy , sx ) : <NEWLINE> <INDENT> reached = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> reached [ sy ] [ sx ] = 0 <NEWLINE> from collections import deque <NEWLINE> que = deque ( [ [ sy , sx ] ] ) <NEWLINE> <COMMENT> <NL> while que : <NEWLINE> <INDENT> iy , ix = que . popleft ( ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> tx , ty = ix + d [ 0 ] , iy + d [ 1 ] <NEWLINE> if tx >= W or ty >= H or tx < 0 or ty < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if reached [ ty ] [ tx ] != - 1 or maze [ ty ] [ tx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> reached [ ty ] [ tx ] = reached [ iy ] [ ix ] + 1 <NEWLINE> <COMMENT> <NL> que . append ( [ ty , tx ] ) <NEWLINE> <DEDENT> <DEDENT> d_max = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> d_max = max ( d_max , reached [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return d_max <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if maze [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , bfs ( i , j ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def is_passcode_exist ( S , passcode ) : <NEWLINE> <INDENT> passcode_idx = 0 <NEWLINE> passcode_is_exist = False <NEWLINE> for c in S : <NEWLINE> <INDENT> if passcode_idx == 3 : <NEWLINE> <INDENT> passcode_is_exist = True <NEWLINE> break <NEWLINE> <DEDENT> if passcode [ passcode_idx ] == c : <NEWLINE> <INDENT> passcode_idx += 1 <NEWLINE> <DEDENT> <DEDENT> if passcode_idx == 3 : <NEWLINE> <INDENT> passcode_is_exist = True <NEWLINE> <DEDENT> return passcode_is_exist <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> if is_passcode_exist ( S , str ( i ) . zfill ( 3 ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
inf = 10 ** 9 + 5 <NEWLINE> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ inf ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + 3 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> dp [ j ] = min ( dp [ j ] , dp [ i ] + abs ( h [ i ] - h [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> l = [ 1 , 2 , 3 , 4 , 5 ] <NEWLINE> a = X // 100 <NEWLINE> b = X % 100 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if b % i == 0 : <NEWLINE> <INDENT> if b // i <= a : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <NL> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ [ 1 if c == <STRING> else 0 for c in input ( ) ] for _ in range ( h ) ] <NEWLINE> g = [ [ ] for _ in range ( h * w ) ] <NEWLINE> <NL> for i in range ( w ) : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> for di in [ - 1 , 0 , 1 ] : <NEWLINE> <INDENT> for dj in [ - 1 , 0 , 1 ] : <NEWLINE> <INDENT> if abs ( di ) + abs ( dj ) != 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if 0 <= i + di < w and 0 <= j + dj < h : <NEWLINE> <INDENT> if s [ j ] [ i ] != s [ j + dj ] [ i + di ] : <NEWLINE> <INDENT> g [ j * w + i ] . append ( i + di + ( j + dj ) * w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> visit = [ 0 ] * ( h * w ) <NEWLINE> black = [ 0 ] * ( h * w ) <NEWLINE> white = [ 0 ] * ( h * w ) <NEWLINE> <NL> def rec ( j , i , rj , ri ) : <NEWLINE> <INDENT> if s [ j ] [ i ] : <NEWLINE> <INDENT> black [ rj * w + ri ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white [ rj * w + ri ] += 1 <NEWLINE> <NL> <DEDENT> for n in g [ j * w + i ] : <NEWLINE> <INDENT> if visit [ n ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> visit [ n ] = 1 <NEWLINE> <NL> rec ( n // w , n % w , rj , ri ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( w ) : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> if visit [ w * j + i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visit [ w * j + i ] = 1 <NEWLINE> <NL> rec ( j , i , j , i ) <NEWLINE> <NL> ans += black [ w * j + i ] * white [ w * j + i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> min_num = N + 1 <NEWLINE> <NL> W = [ ] <NEWLINE> E = [ ] <NEWLINE> <NL> w_cnt = 0 <NEWLINE> e_cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> w_cnt += 1 <NEWLINE> <DEDENT> W . append ( w_cnt ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> min_num = min ( min_num , W [ i - 1 ] + e_cnt ) <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> e_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( min_num , e_cnt ) ) <NEWLINE> <NL>
r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> MAX_N = 3 * 10 ** 6 <NEWLINE> <NL> fact = [ 1 ] <NEWLINE> fact_inv = [ 0 ] * ( MAX_N + 4 ) <NEWLINE> for i in range ( MAX_N + 3 ) : <NEWLINE> <INDENT> fact . append ( fact [ - 1 ] * ( i + 1 ) % mod ) <NEWLINE> <NL> <DEDENT> fact_inv [ - 1 ] = pow ( fact [ - 1 ] , mod - 2 , mod ) <NEWLINE> for i in range ( MAX_N + 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> fact_inv [ i ] = fact_inv [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> def comb ( n , k , mod = mod ) : <NEWLINE> <INDENT> if n < k : return 0 <NEWLINE> return fact [ n ] * fact_inv [ k ] % mod * fact_inv [ n - k ] % mod <NEWLINE> <NL> <DEDENT> ans = comb ( c1 + r1 , r1 ) - comb ( c1 + r2 + 1 , r2 + 1 ) - comb ( c2 + r1 + 1 , r1 ) + comb ( c2 + r2 + 2 , r2 + 1 ) <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> w , v = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w_ , v_ = map ( int , input ( ) . split ( ) ) <NEWLINE> w . append ( w_ ) <NEWLINE> v . append ( v_ ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( ( N + 1 , W + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = np . zeros ( W + 1 , dtype = int ) <NEWLINE> tmp [ w [ i ] : ] = dp [ i ] [ : - w [ i ] ] + v [ i ] <NEWLINE> dp [ i + 1 ] = np . maximum ( dp [ i ] , tmp ) <NEWLINE> <NL> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> len_c = len ( c ) <NEWLINE> total = 0 <NEWLINE> for num in b : <NEWLINE> <INDENT> idx_a = bisect_left ( a , num ) <NEWLINE> idx_c = bisect_right ( c , num ) <NEWLINE> cnt = idx_a * ( len_c - idx_c ) <NEWLINE> total += cnt <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> L_2 = 2 <NEWLINE> L_1 = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L = L_1 + L_2 <NEWLINE> L_2 = L_1 <NEWLINE> L_1 = L <NEWLINE> <DEDENT> print ( L ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> <NL> flag = True <NEWLINE> while flag == True : <NEWLINE> <INDENT> if len ( S ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if len ( S ) >= 5 : <NEWLINE> <INDENT> if S [ - 5 : ] == list ( <STRING> ) : del S [ - 5 : ] <NEWLINE> elif S [ - 5 : ] == list ( <STRING> ) : del S [ - 5 : ] <NEWLINE> elif len ( S ) >= 6 and S [ - 6 : ] == list ( <STRING> ) : del S [ - 6 : ] <NEWLINE> elif len ( S ) >= 7 and S [ - 7 : ] == list ( <STRING> ) : del S [ - 7 : ] <NEWLINE> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> A = deque ( A ) <NEWLINE> while len ( A ) > 1 : <NEWLINE> <INDENT> s = [ ] <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> div = A [ - 1 ] % A [ 0 ] <NEWLINE> A . pop ( ) <NEWLINE> if div != 0 : <NEWLINE> <INDENT> s . append ( div ) <NEWLINE> <DEDENT> <DEDENT> s . append ( A [ 0 ] ) <NEWLINE> s . sort ( ) <NEWLINE> A = deque ( s ) <NEWLINE> <DEDENT> print ( * A ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> r = { v : i for i , v in enumerate ( d ) } <NEWLINE> sz = [ 1 ] * n <NEWLINE> dsorted = sorted ( ( ( di , i ) for i , di in enumerate ( d ) ) , reverse = True ) <NEWLINE> ans = [ ] <NEWLINE> to = [ [ ] for _ in range ( n ) ] <NEWLINE> for di , i in dsorted [ : n - 1 ] : <NEWLINE> <INDENT> nd = di + ( sz [ i ] - 1 ) - ( n - 2 - ( sz [ i ] - 1 ) ) <NEWLINE> if not nd in r : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = r [ nd ] <NEWLINE> to [ p ] . append ( i ) <NEWLINE> sz [ p ] += sz [ i ] <NEWLINE> ans . append ( ( i + 1 , p + 1 ) ) <NEWLINE> <NL> <DEDENT> root = dsorted [ - 1 ] [ 1 ] <NEWLINE> def dfs ( u , cur = 0 ) : <NEWLINE> <INDENT> rv = cur <NEWLINE> for v in to [ u ] : <NEWLINE> <INDENT> rv += dfs ( v , cur + 1 ) <NEWLINE> <DEDENT> return rv <NEWLINE> <NL> <DEDENT> if dfs ( root ) != d [ root ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for u , v in ans : <NEWLINE> <INDENT> print ( u , v ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> cnt = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * cnt . count ( A [ i ] ) % mod <NEWLINE> if A [ i ] in cnt : <NEWLINE> <INDENT> cnt [ cnt . index ( A [ i ] ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> i = 1 <NEWLINE> up = 0 <NEWLINE> down = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if up == down : <NEWLINE> <INDENT> if a [ i ] > a [ i - 1 ] : <NEWLINE> <INDENT> up += 1 <NEWLINE> down = 0 <NEWLINE> <DEDENT> elif a [ i ] < a [ i - 1 ] : <NEWLINE> <INDENT> down += 1 <NEWLINE> up = 0 <NEWLINE> <DEDENT> elif a [ i ] == a [ i - 1 ] : <NEWLINE> <INDENT> up += 1 <NEWLINE> down += 1 <NEWLINE> <DEDENT> <DEDENT> elif up == 0 and down != 0 : <NEWLINE> <INDENT> if a [ i ] <= a [ i - 1 ] : <NEWLINE> <INDENT> down += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> down = 0 <NEWLINE> <DEDENT> <DEDENT> elif down == 0 and up != 0 : <NEWLINE> <INDENT> if a [ i ] >= a [ i - 1 ] : <NEWLINE> <INDENT> up += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> up = 0 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = [ input ( ) for _ in range ( n ) ] <NEWLINE> ans = <STRING> <NEWLINE> if len ( x ) == len ( set ( x ) ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if x [ i ] [ - 1 ] != x [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from itertools import groupby <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = readline ( ) . strip ( ) <NEWLINE> <NL> idx = 0 <NEWLINE> ans = [ 0 ] * len ( S ) <NEWLINE> for k , g in groupby ( S ) : <NEWLINE> <INDENT> L = len ( list ( g ) ) <NEWLINE> if k == <STRING> : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> if ( L - i ) % 2 == 0 : <NEWLINE> <INDENT> ans [ idx + L ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ idx + L - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if k == <STRING> : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans [ idx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ idx - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> idx += L <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> yakusuu = [ ] <NEWLINE> <NL> for i in range ( 1 , min ( A , B ) + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> yakusuu . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( yakusuu [ - K ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <NL> <NL> def pivot_index ( change_box , i , which ) : <NEWLINE> <INDENT> if which == 0 : <NEWLINE> <INDENT> for cb in change_box : <NEWLINE> <INDENT> if cb >= i : <NEWLINE> <INDENT> return cb <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( change_box ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if change_box [ j ] <= i : <NEWLINE> <INDENT> return change_box [ j ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> change_box = [ ] <NEWLINE> floor_chart = 1 <NEWLINE> i = 0 <NEWLINE> while i < len ( S ) - 1 : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] and floor_chart == 1 : <NEWLINE> <INDENT> floor_chart = 0 <NEWLINE> change_box . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] != S [ i + 1 ] and floor_chart == 0 : <NEWLINE> <INDENT> floor_chart = 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * len ( S ) <NEWLINE> one_cool = 0 <NEWLINE> hash_one = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if hash_one == 1 : <NEWLINE> <INDENT> hash_one = 0 <NEWLINE> one_cool += 1 <NEWLINE> <DEDENT> pidx = change_box [ one_cool ] <NEWLINE> cool = pidx - i <NEWLINE> if cool % 2 == 0 : <NEWLINE> <INDENT> ans [ pidx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ pidx + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pidx = change_box [ one_cool ] + 1 <NEWLINE> hash_one = 1 <NEWLINE> cool = i - pidx <NEWLINE> if cool % 2 == 0 : <NEWLINE> <INDENT> ans [ pidx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ pidx - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ 0 ] , end = <STRING> ) <NEWLINE> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( ans [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> l = 0 <NEWLINE> man = 0 <NEWLINE> for i , v in enumerate ( s ) : <NEWLINE> <INDENT> if v == <STRING> : <NEWLINE> <INDENT> man += i - l <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( man ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def grinp ( h ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> ret . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = grinp ( h ) <NEWLINE> fa = False <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> fl = 0 <NEWLINE> if i != 0 and grid [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> fl += 1 <NEWLINE> <DEDENT> if i != h - 1 and grid [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> fl += 1 <NEWLINE> <DEDENT> if j != 0 and grid [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> fl += 1 <NEWLINE> <DEDENT> if j != w - 1 and grid [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> fl += 1 <NEWLINE> <DEDENT> if fl == 0 : <NEWLINE> <INDENT> fa = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if fa : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if fa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = sorted ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( h [ i + k - 1 ] - h [ i ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> difs = { } <NEWLINE> points = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for j in range ( len ( points ) ) : <NEWLINE> <INDENT> dif1 = ( points [ j ] [ 0 ] - x , points [ j ] [ 1 ] - y ) <NEWLINE> dif2 = ( - dif1 [ 0 ] , - dif1 [ 1 ] ) <NEWLINE> <NL> difs [ dif1 ] = 1 if dif1 not in difs else difs [ dif1 ] + 1 <NEWLINE> difs [ dif2 ] = 1 if dif2 not in difs else difs [ dif2 ] + 1 <NEWLINE> <NL> <DEDENT> points . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - max ( difs . values ( ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s1 = ( a - 1 ) // c <NEWLINE> s2 = ( a - 1 ) // d <NEWLINE> s3 = ( a - 1 ) // ( c * d // math . gcd ( c , d ) ) <NEWLINE> S = ( a - 1 ) - ( s1 + s2 - s3 ) <NEWLINE> <NL> l1 = b // c <NEWLINE> l2 = b // d <NEWLINE> l3 = b // ( c * d // math . gcd ( c , d ) ) <NEWLINE> L = b - ( l1 + l2 - l3 ) <NEWLINE> <NL> print ( L - S ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v_odd = [ ] <NEWLINE> v_even = [ ] <NEWLINE> for i , v in enumerate ( v ) : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> v_even . append ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v_odd . append ( v ) <NEWLINE> <DEDENT> <DEDENT> odd_n = len ( v_odd ) <NEWLINE> even_n = len ( v_even ) <NEWLINE> v_odd = collections . Counter ( v_odd ) <NEWLINE> v_odd = sorted ( v_odd . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> v_even = collections . Counter ( v_even ) <NEWLINE> v_even = sorted ( v_even . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> if v_odd [ 0 ] == v_even [ 0 ] and 2 <= len ( v_odd ) and 2 <= len ( v_even ) : <NEWLINE> <INDENT> if v_odd [ 1 ] [ 1 ] < v_even [ 1 ] [ 1 ] : <NEWLINE> <INDENT> v_even . pop ( 0 ) <NEWLINE> <DEDENT> elif v_odd [ 1 ] [ 1 ] > v_even [ 1 ] [ 1 ] : <NEWLINE> <INDENT> v_odd . pop ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> num = v_odd [ 0 ] [ 0 ] <NEWLINE> <NL> ans = odd_n - v_odd [ 0 ] [ 1 ] <NEWLINE> st = 0 <NEWLINE> for i , v in v_even : <NEWLINE> <INDENT> if num == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st = v <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans + ( even_n - st ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h = [ 0 for i in range ( N - 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> h [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in h : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if ans < count : <NEWLINE> <INDENT> ans = count <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> i = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> dif = ( N // 2 ) // ( 5 ** i ) <NEWLINE> count += dif <NEWLINE> if dif == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ( p + 1 ) / 2 for p in P ] <NEWLINE> B = [ 0 for i in range ( N ) ] <NEWLINE> B [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> B [ i ] = B [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( K - 1 , N ) : <NEWLINE> <INDENT> if i == K - 1 : <NEWLINE> <INDENT> a = B [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = B [ i ] - B [ i - K ] <NEWLINE> <DEDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> import bisect <NEWLINE> n = i_input ( ) <NEWLINE> l = sorted ( i_list ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( n - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n - 1 ) : <NEWLINE> <INDENT> ans += bisect . bisect ( l , l [ a ] + l [ b ] - 1 ) - b - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if ( n <= k ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h . sort ( ) <NEWLINE> a = [ ] <NEWLINE> a = h [ : n - k ] <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ a [ i ] for i in range ( n ) if i % 2 == 0 ] <NEWLINE> c = [ a [ i ] for i in range ( n ) if i % 2 == 1 ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> d = c [ : : - 1 ] + b <NEWLINE> <DEDENT> elif n % 2 == 1 : <NEWLINE> <INDENT> d = b [ : : - 1 ] + c <NEWLINE> <DEDENT> s = <STRING> . join ( [ str ( e ) for e in d ] ) <NEWLINE> print ( s ) <NEWLINE>
import heapq <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . root = [ - 1 ] * ( n + 1 ) <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> <DEDENT> def FindRoot ( self , x ) : <NEWLINE> <INDENT> if self . root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root [ x ] = self . FindRoot ( self . root [ x ] ) <NEWLINE> return self . root [ x ] <NEWLINE> <DEDENT> <DEDENT> def Unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . FindRoot ( x ) <NEWLINE> y = self . FindRoot ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> self . root [ x ] += self . root [ y ] <NEWLINE> self . root [ y ] = x <NEWLINE> <DEDENT> elif self . rank [ x ] <= self . rank [ y ] : <NEWLINE> <INDENT> self . root [ y ] += self . root [ x ] <NEWLINE> self . root [ x ] = y <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def isSameGroup ( self , x , y ) : <NEWLINE> <INDENT> return self . FindRoot ( x ) == self . FindRoot ( y ) <NEWLINE> <DEDENT> def Count ( self , x ) : <NEWLINE> <INDENT> return - self . root [ self . FindRoot ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> cost = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> print ( cost [ 0 ] + cost [ 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if m == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> uf . Unite ( a , b ) <NEWLINE> <DEDENT> isolates = set ( ) <NEWLINE> isolates_cnt = 0 <NEWLINE> groups = set ( ) <NEWLINE> groups_cnt = 2 <NEWLINE> roots = [ ] <NEWLINE> qs = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> root = uf . FindRoot ( i ) <NEWLINE> cnt = uf . Count ( i ) <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> isolates_cnt += 1 <NEWLINE> isolates . add ( root ) <NEWLINE> heapq . heappush ( qs [ root ] , ( cost [ i ] , i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if root not in groups : <NEWLINE> <INDENT> groups_cnt += cnt - 2 <NEWLINE> roots . append ( ( root , cnt ) ) <NEWLINE> <DEDENT> groups . add ( root ) <NEWLINE> heapq . heappush ( qs [ root ] , ( cost [ i ] , i ) ) <NEWLINE> <DEDENT> <DEDENT> if groups_cnt < isolates_cnt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> roots = sorted ( roots , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> root = roots [ 0 ] [ 0 ] <NEWLINE> for tmp_root , _ in roots [ 1 : ] : <NEWLINE> <INDENT> cv , v = heapq . heappop ( qs [ root ] ) <NEWLINE> cu , u = heapq . heappop ( qs [ tmp_root ] ) <NEWLINE> ans += ( cv + cu ) <NEWLINE> while len ( qs [ tmp_root ] ) != 0 : <NEWLINE> <INDENT> tc , tv = heapq . heappop ( qs [ tmp_root ] ) <NEWLINE> heapq . heappush ( qs [ root ] , ( tc , tv ) ) <NEWLINE> <DEDENT> <DEDENT> for tmp_root in isolates : <NEWLINE> <INDENT> cv , v = heapq . heappop ( qs [ root ] ) <NEWLINE> cu , u = heapq . heappop ( qs [ tmp_root ] ) <NEWLINE> ans += ( cv + cu ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] + a [ i + 1 ] > x : <NEWLINE> <INDENT> y = a [ i ] + a [ i + 1 ] - x <NEWLINE> count += y <NEWLINE> a [ i + 1 ] = max ( 0 , a [ i + 1 ] - y ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = input ( ) <NEWLINE> N = int ( a ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> ind = A . index ( max ( A ) ) <NEWLINE> max = max ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == ind : <NEWLINE> <INDENT> B = sorted ( A ) <NEWLINE> print ( B [ N - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
R , G , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for r in range ( min ( 3000 , 3000 // R ) + 1 ) : <NEWLINE> <INDENT> if R * r <= N : <NEWLINE> <INDENT> for g in range ( min ( 3000 , 3000 // G ) + 1 ) : <NEWLINE> <INDENT> v = R * r + G * g <NEWLINE> if N >= v and ( N - v ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , i ) <NEWLINE> c = bisect . bisect_right ( C , i ) <NEWLINE> p = a * ( N - c ) <NEWLINE> count += p <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt , nega , posi = 0 , 0 , [ ] <NEWLINE> for x , y in zip ( a , b ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> nega += y - x <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> posi . append ( x - y ) <NEWLINE> <DEDENT> <DEDENT> if sum ( posi ) - nega < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> posi . sort ( reverse = True ) <NEWLINE> i = 0 <NEWLINE> while nega > 0 : <NEWLINE> <INDENT> nega -= posi [ i ] <NEWLINE> cnt += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( 1 , min ( A , B ) + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> l = sorted ( l ) [ : : - 1 ] <NEWLINE> print ( l [ K - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = list ( range ( n ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
import numpy as np <NEWLINE> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> np_ab = np . array ( ab ) <NEWLINE> max_a = max ( np_ab [ : , 0 ] ) <NEWLINE> dp = [ 0 ] * ( h + max_a ) <NEWLINE> for i in range ( 1 , h + max_a ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( min ( dp [ h : ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> data [ b - 1 ] += 1 <NEWLINE> if data [ b - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if b == n : <NEWLINE> <INDENT> data [ a - 1 ] += 1 <NEWLINE> if data [ a - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans , a = 0 , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] not in a : <NEWLINE> <INDENT> a += [ s [ i ] ] <NEWLINE> b = [ ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] not in b : <NEWLINE> <INDENT> b += [ s [ j ] ] <NEWLINE> c = [ ] <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if s [ k ] not in c : <NEWLINE> <INDENT> c += [ s [ k ] ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = ( a * i ) % ( ( 10 ** 9 ) + 7 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def dfs ( now_node , parent_node , dist ) : <NEWLINE> <INDENT> depth [ now_node ] = dist <NEWLINE> for next_node , w in graph [ now_node ] : <NEWLINE> <INDENT> if next_node == parent_node : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( next_node , now_node , dist + w ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( ( b , c ) ) <NEWLINE> graph [ b ] . append ( ( a , c ) ) <NEWLINE> <NL> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> depth = [ - 1 ] * ( n + 1 ) <NEWLINE> dfs ( k , 0 , 0 ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( depth [ x ] + depth [ y ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <COMMENT> <NL> left = 0 <NEWLINE> right = N - 1 <NEWLINE> <NL> ans = 0 <NEWLINE> while left <= right : <NEWLINE> <INDENT> if right == left : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ left ] == S [ right ] : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if S [ left ] != <STRING> and S [ right ] != <STRING> : <NEWLINE> <INDENT> print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> if S [ left ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> if S [ right ] == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if right > left : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> <NL> m = [ 0 ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> m [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> m [ j ] = k + m [ j ] - q <NEWLINE> <NL> <DEDENT> ans = [ <STRING> ] * n <NEWLINE> <NL> for h in range ( n ) : <NEWLINE> <INDENT> if m [ h ] > 0 : <NEWLINE> <INDENT> ans [ h ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
from statistics import median <NEWLINE> from time import time <NEWLINE> <NL> t = time ( ) <NEWLINE> <NL> N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> line_in_dice = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> result = [ 0 ] * ( N + K ) <NEWLINE> <NL> result [ 0 ] = line_in_dice [ 0 ] <NEWLINE> result [ K ] -= line_in_dice [ 0 ] <NEWLINE> <NL> max_point = 0 <NEWLINE> max_value = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> result [ i ] += ( result [ i - 1 ] + line_in_dice [ i ] ) <NEWLINE> result [ i + K ] -= line_in_dice [ i ] <NEWLINE> <NL> if result [ i ] > max_value : <NEWLINE> <INDENT> max_point = i <NEWLINE> max_value = result [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def create_median ( x ) : <NEWLINE> <INDENT> if x % 2 == 1 : <NEWLINE> <INDENT> return ( 1 + x ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( x // 2 ) + ( x // 2 + 1 ) ) / 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( sum ( create_median ( x ) <NEWLINE> <INDENT> for x in line_in_dice [ max_point - K + 1 : max_point + 1 ] ) ) <NEWLINE> <DEDENT>
from random import randint <NEWLINE> <NL> <NL> class RollingHash : <NEWLINE> <INDENT> def __init__ ( self , s ) : <NEWLINE> <INDENT> self . base = [ 7073 , 7577 , 5445 , 2742 , 6972 , 7547 , 2267 , 286 , 6396 , 7147 , <NEWLINE> <INDENT> 3307 , 188 , 266 , 8253 , 2818 , 9527 , 5110 , 1207 , 4633 , 6196 , <NEWLINE> 309 , 2646 , 7533 , 85 , 9870 , 4730 , 6862 , 9213 , 7456 , 7098 , <NEWLINE> 6805 , 674 , 5821 , 4864 , 8061 , 1826 , 2219 , 459 , 5937 , 5667 , <NEWLINE> 9033 , 5552 , 7263 , 2402 , 9809 , 3701 , 7048 , 2874 , 8350 , 6006 , <NEWLINE> 973 , 3317 , 2522 , 5546 , 1669 , 1545 , 7972 , 4979 , 9905 , 173 , <NEWLINE> 6812 , 7715 , 5006 , 6068 , 6340 , 4989 , 5510 , 6380 , 1200 , 6739 , <NEWLINE> 5527 , 4000 , 6519 , 3448 , 2933 , 6048 , 3133 , 1667 , 9086 , 8368 , <NEWLINE> 4914 , 7142 , 2770 , 7752 , 391 , 7052 , 5476 , 3105 , 8322 , 3501 , <NEWLINE> 7454 , 3167 , 8730 , 9002 , 4564 , 138 , 2197 , 7238 , 3411 , 7433 ] [ randint ( 0 , 100 ) ] <NEWLINE> <DEDENT> self . mod = 4611686018427387903 <NEWLINE> self . size = len ( s ) <NEWLINE> self . string = s <NEWLINE> <NL> self . hash = self . make_hashtable ( s ) <NEWLINE> self . pow = self . make_powtable ( ) <NEWLINE> <NL> <DEDENT> def make_hashtable ( self , _s ) : <NEWLINE> <INDENT> hashtable = [ 0 ] * ( self . size + 1 ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> hashtable [ i + 1 ] = ( hashtable [ i ] * self . base + ord ( _s [ i ] ) ) % self . mod <NEWLINE> <DEDENT> return hashtable <NEWLINE> <NL> <DEDENT> def make_powtable ( self ) : <NEWLINE> <INDENT> power = [ 1 ] * ( self . size + 1 ) <NEWLINE> for i in range ( self . size ) : <NEWLINE> <INDENT> power [ i + 1 ] = ( self . base * power [ i ] ) % self . mod <NEWLINE> <DEDENT> return power <NEWLINE> <NL> <DEDENT> def get_hash ( self , left , right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( self . hash [ right ] - self . hash [ left ] * self . pow [ right - left ] ) % self . mod <NEWLINE> <NL> <DEDENT> def contain ( self , a ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> m = len ( a ) <NEWLINE> if m > self . size : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> hashs = self . get_hash ( 0 , m ) <NEWLINE> hasha = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hasha = ( hasha * self . base + ord ( a [ i ] ) ) % self . mod <NEWLINE> <DEDENT> for i in range ( self . size - m + 1 ) : <NEWLINE> <INDENT> if hasha == hashs : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> hashs = self . get_hash ( i , m + i ) <NEWLINE> <DEDENT> return hasha == hashs <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> from collections import defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> n , s = int ( input ( ) ) , input ( ) <NEWLINE> rh = RollingHash ( s ) <NEWLINE> <NL> <NL> def check ( m ) : <NEWLINE> <INDENT> d = defaultdict ( lambda : 10000000 ) <NEWLINE> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> h = rh . get_hash ( i , i + m ) <NEWLINE> d [ h ] = min ( d [ h ] , i ) <NEWLINE> <COMMENT> <NL> if i - d [ h ] >= m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> l , r = 0 , n // 2 + 1 <NEWLINE> while l + 1 < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * X , = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sorted ( X ) <NEWLINE> <NL> t1 = s [ N // 2 - 1 ] <NEWLINE> t2 = s [ N // 2 ] <NEWLINE> <NL> for x in X : <NEWLINE> <INDENT> if x <= t1 : <NEWLINE> <INDENT> print ( t2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_lst = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for num in a : <NEWLINE> <INDENT> a_lst [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for X in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> if X == 0 : <NEWLINE> <INDENT> cnt += a_lst [ X ] <NEWLINE> cnt += a_lst [ X + 1 ] <NEWLINE> <DEDENT> elif X == 10 ** 5 : <NEWLINE> <INDENT> cnt += a_lst [ X - 1 ] <NEWLINE> cnt += a_lst [ X ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += a_lst [ X - 1 ] <NEWLINE> cnt += a_lst [ X ] <NEWLINE> cnt += a_lst [ X + 1 ] <NEWLINE> <NL> <DEDENT> if cnt > ans : <NEWLINE> <INDENT> ans = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
w = sorted ( input ( ) ) <NEWLINE> total = False <NEWLINE> if len ( w ) == 1 : <NEWLINE> <INDENT> total = True <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , len ( w ) , 2 ) : <NEWLINE> <INDENT> if w [ i ] != w [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> total = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if total == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = list ( accumulate ( A [ : - 1 ] , gcd , initial = 0 ) ) <NEWLINE> r = list ( accumulate ( A [ : : - 1 ] , gcd , initial = 0 ) ) <NEWLINE> print ( max ( gcd ( l [ i ] , r [ N - i - 1 ] ) for i in range ( N ) ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) . rstrip ( ) ) <NEWLINE> s = readline ( ) . rstrip ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> x = str ( i ) . zfill ( 3 ) <NEWLINE> a = s [ : - 1 ] . find ( x [ 0 ] ) <NEWLINE> if a != - 1 : <NEWLINE> <INDENT> b = s [ a + 1 : - 1 ] . find ( x [ 1 ] ) <NEWLINE> if b != - 1 : <NEWLINE> <INDENT> c = s [ a + b + 2 : ] . find ( x [ 2 ] ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> txylist = [ [ 0 , 0 , 0 ] ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> txy = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> txylist += [ txy ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> p = False <NEWLINE> t0 , x0 , y0 = txylist [ i ] <NEWLINE> t1 , x1 , y1 = txylist [ i + 1 ] <NEWLINE> t = t1 - t0 <NEWLINE> x = x1 - x0 <NEWLINE> y = y1 - y0 <NEWLINE> tt = abs ( x ) + abs ( y ) <NEWLINE> legs = t - tt <NEWLINE> if legs >= 0 and legs % 2 == 0 : <NEWLINE> <INDENT> p = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def mapline ( t = int ) : <NEWLINE> <INDENT> return map ( t , sysread ( ) . split ( ) ) <NEWLINE> <DEDENT> def mapread ( t = int ) : <NEWLINE> <INDENT> return map ( t , read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N , * A = mapread ( ) <NEWLINE> ans = 1 <NEWLINE> current = [ 0 , 0 , 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> transition = 0 <NEWLINE> cache = 1 <NEWLINE> for i , c in enumerate ( current ) : <NEWLINE> <INDENT> if c == a : <NEWLINE> <INDENT> transition += 1 <NEWLINE> cache = i <NEWLINE> <DEDENT> <DEDENT> ans *= transition <NEWLINE> ans %= mod <NEWLINE> current [ cache ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( ( ( n + 1 ) * n ) // 2 - n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> x = A [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> x = min ( x , A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
mod = 998244353 <NEWLINE> n , a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> if n < 0 or r < 0 : return 0 <NEWLINE> return fa [ n ] * fi [ r ] % mod * fi [ n - r ] % mod <NEWLINE> <DEDENT> fa = [ 1 ] * ( n + 1 ) <NEWLINE> fi = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fa [ i ] = fa [ i - 1 ] * i % mod <NEWLINE> fi [ i ] = pow ( fa [ i ] , mod - 2 , mod ) <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> x = k - a * i <NEWLINE> if x >= 0 and x % b == 0 : <NEWLINE> <INDENT> j = x // b <NEWLINE> if j <= n : <NEWLINE> <INDENT> ans += comb ( n , i ) * comb ( n , j ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> e = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> e [ x - 1 ] . append ( i ) <NEWLINE> <NL> <DEDENT> def dfs ( x ) : <NEWLINE> <NL> <INDENT> count = len ( e [ x ] ) <NEWLINE> if count == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> d = defaultdict ( int ) <NEWLINE> ma = 0 <NEWLINE> s = set ( ) <NEWLINE> for nex in e [ x ] : <NEWLINE> <INDENT> v = dfs ( nex ) <NEWLINE> d [ v ] += 1 <NEWLINE> s . add ( v ) <NEWLINE> ma = max ( ma , v ) <NEWLINE> <DEDENT> now = count <NEWLINE> bef = 0 <NEWLINE> for v in sorted ( list ( s ) , reverse = True ) : <NEWLINE> <INDENT> bef += d [ v ] <NEWLINE> now = max ( now , bef + v ) <NEWLINE> <DEDENT> return now <NEWLINE> <NL> <DEDENT> print ( dfs ( 0 ) ) <NEWLINE>
from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . rsplit ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> n , q = LI ( ) <NEWLINE> point = [ 0 ] * n <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> visited = [ False ] * n <NEWLINE> <NL> <NL> def dfs ( n ) : <NEWLINE> <INDENT> visited [ n - 1 ] = True <NEWLINE> for node in graph [ n - 1 ] : <NEWLINE> <INDENT> if visited [ node - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ node - 1 ] += point [ n - 1 ] <NEWLINE> dfs ( node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = LI ( ) <NEWLINE> graph [ a - 1 ] . append ( b ) <NEWLINE> graph [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = LI ( ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> <NL> print ( * point ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 1 <NEWLINE> if X % Y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N - i + 1 ) : <NEWLINE> <INDENT> k = N - i - j <NEWLINE> t = ( i , j , k ) <NEWLINE> if Y == i * 10000 + j * 5000 + k * 1000 : <NEWLINE> <INDENT> print ( * t ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( b // x ) - ( ( a - 1 ) // x ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) // 2 if ( a + b ) % 2 == 0 else <STRING> ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> xi = math . floor ( x / 5.5 ) <NEWLINE> <COMMENT> <NL> for i in range ( xi , 10000000000000000000000000000 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( x <= 6 * i - math . floor ( i / 2 ) ) : <NEWLINE> <INDENT> xa = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( xa ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> aas = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import heapq <NEWLINE> hq = [ ] <NEWLINE> for i in aas : <NEWLINE> <INDENT> heapq . heappush ( hq , - i ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( hq ) <NEWLINE> heapq . heappush ( hq , - ( ( - tmp ) // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( hq ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 or n == 2 or n == 3 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while n > 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 2 , 10 ) : <NEWLINE> <INDENT> if n == i ** j : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n -= 1 <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sd = set ( D ) <NEWLINE> st = set ( T ) <NEWLINE> cntd = Counter ( D ) <NEWLINE> cntt = Counter ( T ) <NEWLINE> ok = True <NEWLINE> for t in T : <NEWLINE> <INDENT> if t not in sd : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> elif cntt [ t ] > cntd [ t ] : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ list ( map ( int , stdin . readline ( ) . split ( ) ) ) for i in [ 0 ] * N ] <NEWLINE> M = np . array ( M ) <NEWLINE> <NL> @ njit <NEWLINE> def main ( h , n , m ) : <NEWLINE> <INDENT> dp = [ 10 ** 8 + 1 ] * ( 10 ** 4 + 1 ) <NEWLINE> dp = np . array ( dp ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , 10 ** 4 + 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> a = m [ j ] [ 0 ] <NEWLINE> b = m [ j ] [ 1 ] <NEWLINE> if a > i : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - a ] + b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ h ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( H , N , M ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( h [ 0 ] ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( max ( h ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h . append ( 0 ) <NEWLINE> h . insert ( 0 , 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> f = [ 0 for i in range ( n + 2 ) ] <NEWLINE> <NL> for i in range ( 10010 ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> x = [ ] <NEWLINE> for j in range ( n + 2 ) : <NEWLINE> <INDENT> if h [ j ] <= f [ j ] : <NEWLINE> <INDENT> x . append ( j ) <NEWLINE> <DEDENT> <DEDENT> m = len ( x ) <NEWLINE> if m == n + 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = m - 1 <NEWLINE> for j in range ( m - 1 ) : <NEWLINE> <INDENT> if x [ j ] + 1 == x [ j + 1 ] : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> ans += a <NEWLINE> for j in range ( n + 2 ) : <NEWLINE> <INDENT> f [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = n * ( n - 1 ) // 2 <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def precompute ( S ) : <NEWLINE> <INDENT> H , W = S . shape <NEWLINE> V = np . zeros ( ( H + 1 , W + 1 ) , np . int64 ) <NEWLINE> V [ 1 : , 1 : ] = np . cumsum ( S , axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> Ex = np . zeros ( ( H , W + 1 ) , np . int64 ) <NEWLINE> Ex [ 1 : , 1 : ] = np . cumsum ( S [ : - 1 ] & S [ 1 : ] , axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> Ey = np . zeros ( ( H + 1 , W ) , np . int64 ) <NEWLINE> Ey [ 1 : , 1 : ] = np . cumsum ( S [ : , : - 1 ] & S [ : , 1 : ] , axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> return V , Ex , Ey <NEWLINE> <NL> <DEDENT> def main ( V , Ex , Ey , query ) : <NEWLINE> <INDENT> for i in range ( len ( query ) // 4 ) : <NEWLINE> <INDENT> a , b , c , d = query [ 4 * i : 4 * i + 4 ] <NEWLINE> v = V [ c , d ] + V [ a - 1 , b - 1 ] - V [ a - 1 , d ] - V [ c , b - 1 ] <NEWLINE> e1 = Ex [ c - 1 , d ] + Ex [ a - 1 , b - 1 ] - Ex [ a - 1 , d ] - Ex [ c - 1 , b - 1 ] <NEWLINE> e2 = Ey [ c , d - 1 ] + Ey [ a - 1 , b - 1 ] - Ey [ a - 1 , d - 1 ] - Ey [ c , b - 1 ] <NEWLINE> print ( v - e1 - e2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . from_dtype ( np . int64 ) <NEWLINE> signature = ( i8 [ : , : ] , i8 [ : , : ] , i8 [ : , : ] , i8 [ : ] ) <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , signature ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> H , W , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> S . append ( list ( readline ( ) . rstrip ( ) ) ) <NEWLINE> <DEDENT> query = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> S = ( np . concatenate ( S ) - ord ( <STRING> ) ) . reshape ( H , W ) <NEWLINE> V , Ex , Ey = precompute ( S ) <NEWLINE> <NL> main ( V , Ex , Ey , query ) <NEWLINE>
c = input ( ) <NEWLINE> al = <STRING> <NEWLINE> print ( al [ al . index ( c ) + 1 ] ) <NEWLINE>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> t = i_input ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> k = i_input ( ) <NEWLINE> t = t * k // gcd ( t , k ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> def dfs ( v , p ) : <NEWLINE> <INDENT> for u in edge_extend [ p ] [ v ] : <NEWLINE> <INDENT> next_p = 0 if p == 2 else p + 1 <NEWLINE> if dist [ next_p ] [ u ] <= dist [ p ] [ v ] + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dist [ next_p ] [ u ] = dist [ p ] [ v ] + 1 <NEWLINE> dfs ( u , next_p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ u - 1 ] . append ( v - 1 ) <NEWLINE> <DEDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edge_extend = [ ] <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> edge_extend . append ( edge ) <NEWLINE> <NL> <DEDENT> dist = [ [ f_inf ] * n for _ in range ( 3 ) ] <NEWLINE> dist [ 0 ] [ s - 1 ] = 0 <NEWLINE> que = deque ( [ [ 0 , s - 1 ] ] ) <NEWLINE> while que : <NEWLINE> <INDENT> p , v = que . popleft ( ) <NEWLINE> next_p = 0 if p == 2 else p + 1 <NEWLINE> for u in edge_extend [ p ] [ v ] : <NEWLINE> <INDENT> if dist [ next_p ] [ u ] > dist [ p ] [ v ] + 1 : <NEWLINE> <INDENT> dist [ next_p ] [ u ] = dist [ p ] [ v ] + 1 <NEWLINE> que . append ( [ next_p , u ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dist [ 0 ] [ t - 1 ] // 3 if dist [ 0 ] [ t - 1 ] != f_inf else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
h , w , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for _ in range ( h ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( b ) <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> c = a [ i ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> d [ c [ j ] ] = ( i + 1 , j + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> R_min = h * w <NEWLINE> R_max = 1 <NEWLINE> query = [ ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> query . append ( [ l , r ] ) <NEWLINE> R_min = min ( l , R_min ) <NEWLINE> R_max = max ( r , R_max ) <NEWLINE> <NL> <NL> <DEDENT> cum = [ 0 ] * ( h * w + 1 ) <NEWLINE> for k in range ( R_min , R_max - D + 1 ) : <NEWLINE> <INDENT> prev = cum [ k - 1 ] <NEWLINE> cost = abs ( d [ k + D ] [ 0 ] - d [ k ] [ 0 ] ) + abs ( d [ k + D ] [ 1 ] - d [ k ] [ 1 ] ) <NEWLINE> cum [ k + D - 1 ] = cost + prev <NEWLINE> <NL> <NL> <NL> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> l , r = query [ j ] [ 0 ] , query [ j ] [ 1 ] <NEWLINE> score = cum [ r - 1 ] - cum [ l - 1 ] <NEWLINE> print ( score ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> c = math . gcd ( a , b ) <NEWLINE> c2 = c <NEWLINE> l = [ ] <NEWLINE> i = 2 <NEWLINE> while i <= c : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> c = c // i <NEWLINE> <NL> l . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if i * i - 1 > c : <NEWLINE> <INDENT> l . append ( c ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( set ( l ) ) + 1 ) <NEWLINE>
from statistics import median <NEWLINE> from operator import itemgetter <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_ = sorted ( x ) <NEWLINE> m0 = median ( x_ [ 1 : ] ) <NEWLINE> m1 = median ( x_ [ : - 1 ] ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if m1 >= i : <NEWLINE> <INDENT> print ( m0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> * B , = map ( int , input ( ) . split ( ) ) <NEWLINE> * C , = map ( int , input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect_left ( A , b ) <NEWLINE> c = bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> g = N // gcd ( N , M ) * M <NEWLINE> ans = defaultdict ( bool ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i * g // N ] = S [ i ] <NEWLINE> <DEDENT> ok = True <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> idx = i * g // M <NEWLINE> if ans [ idx ] and ans [ idx ] != T [ i ] : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( g ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = prev = sum ( P [ : k ] ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> tmp = prev - P [ i - 1 ] + P [ i + k - 1 ] <NEWLINE> prev = tmp <NEWLINE> if tmp > m : <NEWLINE> <INDENT> s = i <NEWLINE> <DEDENT> m = max ( tmp , m ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( s , s + k ) : <NEWLINE> <INDENT> p = P [ i ] <NEWLINE> if p not in d . keys ( ) : <NEWLINE> <INDENT> tmp = sum ( range ( p + 1 ) ) / p <NEWLINE> ans += tmp <NEWLINE> d [ p ] = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += d [ p ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p [ i ] = ( 1 + p [ i ] ) / 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> S = [ 0 ] * N <NEWLINE> S [ 0 ] = p [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S [ i + 1 ] = S [ i ] + p [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = S [ K - 1 ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans = max ( ans , S [ i + K ] - S [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> s = list ( input ( ) ) <NEWLINE> data = s [ 0 ] <NEWLINE> i = 1 <NEWLINE> while i * 2 < len ( s ) : <NEWLINE> <INDENT> data = data + s [ i * 2 ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> print ( data ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> a = y [ n // 2 - 1 ] <NEWLINE> b = y [ n // 2 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> print ( ( a , b ) [ i <= a ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = [ ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> b += [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <DEDENT> b = sorted ( b , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( b [ i ] [ 0 ] ) : <NEWLINE> <INDENT> if a [ 0 ] < b [ i ] [ 1 ] : <NEWLINE> <INDENT> a . pop ( 0 ) <NEWLINE> a . append ( b [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , B ) ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i > b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lst . append ( i ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if i < a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not i in lst : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cA = collections . Counter ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> if len ( cA ) > K : <NEWLINE> <INDENT> _ , counts = zip ( * cA . most_common ( ) [ : : - 1 ] ) <NEWLINE> ans = sum ( counts [ : len ( cA ) - K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ i for i in range ( 1 , N + 1 ) if i % 2 != 0 ] <NEWLINE> ans = 0 <NEWLINE> if N < 105 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> for num in L : <NEWLINE> <INDENT> counter = 1 <NEWLINE> for i in range ( 1 , num // 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> if counter == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> mydict = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> print ( mydict [ S ] ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ad_ls = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ad_ls [ a - 1 ] . append ( [ b - 1 , w ] ) <NEWLINE> ad_ls [ b - 1 ] . append ( [ a - 1 , w ] ) <NEWLINE> <NL> <DEDENT> cost_ls = [ 0 ] * n <NEWLINE> done_ls = [ 0 ] * n <NEWLINE> def dfs ( v , c ) : <NEWLINE> <INDENT> for new , cost in ad_ls [ v ] : <NEWLINE> <INDENT> if not done_ls [ new ] : <NEWLINE> <INDENT> cost_ls [ new ] = c + cost <NEWLINE> done_ls [ new ] = 1 <NEWLINE> dfs ( new , c + cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> color_ls = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> color_ls [ i ] = cost_ls [ i ] % 2 <NEWLINE> <NL> <DEDENT> for color in color_ls : <NEWLINE> <INDENT> print ( color ) <NEWLINE> <DEDENT>
import math <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : return False <NEWLINE> <NL> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> b = 1 <NEWLINE> tmp_ans = 0 <NEWLINE> ans = 10 ** 12 <NEWLINE> <NL> if is_prime ( n ) == True : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> elif is_prime ( n ) == False : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> j = n // i <NEWLINE> if n == i * j : <NEWLINE> <INDENT> tmp_ans = ( i - a ) + ( j - b ) <NEWLINE> if tmp_ans < ans : <NEWLINE> <INDENT> ans = tmp_ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tmp = ( n * ( n - 1 ) ) // 2 <NEWLINE> print ( tmp ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> n = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> a = np . fromstring ( sys . stdin . buffer . readline ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = 0 <NEWLINE> b = 1 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> s = int ( ( a & 1 ) . sum ( ) ) <NEWLINE> ans = ( ans + s * ( n - s ) * b ) % mod <NEWLINE> a >>= 1 <NEWLINE> b = b * 2 % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = set ( list ( map ( int , readline ( ) . split ( ) ) ) ) <NEWLINE> <NL> dic = { 1 : 2 , 2 : 5 , 3 : 5 , 4 : 4 , 5 : 5 , 6 : 6 , 7 : 3 , 8 : 7 , 9 : 6 } <NEWLINE> <NL> <COMMENT> <NL> candi = [ [ ] , [ ] , [ 1 ] , [ 7 ] , [ 4 ] , [ 2 , 3 , 5 ] , [ 6 , 9 ] , [ 8 ] ] <NEWLINE> <NL> <COMMENT> <NL> if 2 in A and 3 in A : <NEWLINE> <INDENT> A . remove ( 2 ) <NEWLINE> <DEDENT> if 2 in A and 5 in A : <NEWLINE> <INDENT> A . remove ( 2 ) <NEWLINE> <DEDENT> if 3 in A and 5 in A : <NEWLINE> <INDENT> A . remove ( 3 ) <NEWLINE> <DEDENT> if 6 in A and 9 in A : <NEWLINE> <INDENT> A . remove ( 6 ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( candi ) ) : <NEWLINE> <INDENT> for j in range ( len ( candi [ i ] ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if candi [ i ] [ j ] not in A : <NEWLINE> <INDENT> del candi [ i ] [ j ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> dp = [ - 1 ] * ( N + 1 ) <NEWLINE> ans = [ <STRING> ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> def to_num ( x ) : <NEWLINE> <INDENT> return int ( <STRING> . join ( sorted ( x , reverse = True ) ) ) <NEWLINE> <DEDENT> for i in range ( len ( candi ) ) : <NEWLINE> <INDENT> if not candi [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num = str ( candi [ i ] [ 0 ] ) <COMMENT> <NEWLINE> <COMMENT> <NL> for j in range ( len ( dp ) ) : <NEWLINE> <INDENT> if dp [ j ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if j + i > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dp [ j + i ] < dp [ j ] + 1 : <NEWLINE> <INDENT> dp [ j + i ] = dp [ j ] + 1 <NEWLINE> ans [ j + i ] = ans [ j ] + num <NEWLINE> <DEDENT> elif dp [ j + i ] == dp [ j ] + 1 : <NEWLINE> <INDENT> if to_num ( ans [ j + i ] ) < to_num ( ans [ j ] + num ) : <NEWLINE> <INDENT> ans [ j + i ] = ans [ j ] + num <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( to_num ( ans [ N ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x ] += [ y ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> dp = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> <NL> def func ( n ) : <NEWLINE> <INDENT> if dp [ n ] != - 1 : <NEWLINE> <INDENT> return dp [ n ] <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for m in G [ n ] : <NEWLINE> <INDENT> cnt = max ( cnt , func ( m ) + 1 ) <NEWLINE> <DEDENT> dp [ n ] = cnt <NEWLINE> return cnt <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> func ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE>
import copy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort_x = copy . copy ( x ) <NEWLINE> sort_x . sort ( ) <NEWLINE> <NL> center_num = ( N - 1 ) // 2 <NEWLINE> <NL> for l in x : <NEWLINE> <INDENT> if l <= sort_x [ center_num ] : <NEWLINE> <INDENT> print ( sort_x [ center_num + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sort_x [ center_num ] ) <NEWLINE> <DEDENT> <DEDENT>
def actual ( K , S ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - ( x + y ) <NEWLINE> <NL> cond1 = ( 0 <= x <= K ) and ( 0 <= y <= K ) and ( 0 <= z <= K ) <NEWLINE> cond2 = ( x + y + z ) == S <NEWLINE> <NL> if cond1 and cond2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( actual ( K , S ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> ans = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i + 1 ] = max ( ans [ i + 1 ] , ans [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> i = len ( S ) - 1 - i <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - x - y <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 0 <NEWLINE> min = 2e5 + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if min > p [ i ] : <NEWLINE> <INDENT> min = p [ i ] <NEWLINE> <DEDENT> if p [ i ] <= min : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> balls = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> balls . append ( [ x , y ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> delta = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dx = balls [ j ] [ 0 ] - balls [ i ] [ 0 ] <NEWLINE> dy = balls [ j ] [ 1 ] - balls [ i ] [ 1 ] <NEWLINE> delta . append ( ( dx , dy ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> c_delta = collections . Counter ( delta ) <NEWLINE> <COMMENT> <NL> if len ( c_delta ) : <NEWLINE> <INDENT> print ( n - c_delta . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
from copy import copy <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> s = input ( ) <NEWLINE> count = [ 0 for _ in range ( 13 ) ] <NEWLINE> count [ 0 ] = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> new = [ 0 for _ in range ( 13 ) ] <NEWLINE> for m in range ( 13 ) : <NEWLINE> <INDENT> new [ ( m * 10 ) % 13 ] = count [ m ] <NEWLINE> <DEDENT> count = new <NEWLINE> if s [ i ] != <STRING> : <NEWLINE> <INDENT> div = int ( s [ i ] ) <NEWLINE> count = count [ - div : ] + count [ : - div ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new = [ 0 for _ in range ( 13 ) ] <NEWLINE> pre = sum ( count [ : 3 ] ) <NEWLINE> SUM = sum ( count ) % MOD <NEWLINE> for j in range ( 13 ) : <NEWLINE> <INDENT> pre += count [ ( j + 3 ) % 13 ] <NEWLINE> pre -= count [ j % 13 ] <NEWLINE> new [ j ] = ( SUM - pre ) % MOD <NEWLINE> <DEDENT> count = new <NEWLINE> <DEDENT> <DEDENT> print ( count [ 5 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( p [ : k ] ) <NEWLINE> q = [ ans ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> ans = ans + p [ i ] - p [ i - k ] <NEWLINE> q . append ( ans ) <NEWLINE> <DEDENT> print ( ( max ( q ) + k ) / 2 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> oddcount = 0 <NEWLINE> mod40 = 0 <NEWLINE> other = 0 <NEWLINE> <NL> for a in alist : <NEWLINE> <INDENT> if a % 2 == 1 : <NEWLINE> <INDENT> oddcount += 1 <NEWLINE> <DEDENT> elif a % 4 == 0 : <NEWLINE> <INDENT> mod40 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> other += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> if mod40 == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if N == 2 or N == 3 : <NEWLINE> <INDENT> if mod40 > 0 or other == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if N % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> if ( N - ( ( other // 2 ) * 2 ) ) // 2 <= mod40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if other % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> if ( N - ( ( other // 2 ) * 2 ) ) // 2 <= mod40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( N - ( ( other // 2 ) * 2 ) ) // 2 <= mod40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , * XY = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> MAX = 100010 <NEWLINE> uf = UnionFind ( MAX * 2 ) <NEWLINE> for x , y in zip ( * [ iter ( XY ) ] * 2 ) : <NEWLINE> <INDENT> uf . union ( x , y + MAX ) <NEWLINE> <NL> <DEDENT> x_comp = Counter ( ) <NEWLINE> y_comp = Counter ( ) <NEWLINE> for i in range ( MAX ) : <NEWLINE> <INDENT> x_comp [ uf . find ( i ) ] += 1 <NEWLINE> <DEDENT> for i in range ( MAX , 2 * MAX ) : <NEWLINE> <INDENT> y_comp [ uf . find ( i ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in x_comp . keys ( ) : <NEWLINE> <INDENT> ans += x_comp [ k ] * y_comp [ k ] <NEWLINE> <NL> <DEDENT> ans -= N <NEWLINE> <NL> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= b [ i ] : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> b [ i ] -= a [ i ] <NEWLINE> if a [ i + 1 ] >= b [ i ] : <NEWLINE> <INDENT> a [ i + 1 ] -= b [ i ] <NEWLINE> ans += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i + 1 ] <NEWLINE> a [ i + 1 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pf = [ 0 ] * ( n + 1 ) <NEWLINE> pb = [ 0 ] * ( n + 1 ) <NEWLINE> p = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = math . gcd ( p , a [ i ] ) <NEWLINE> pf [ i + 1 ] = p <NEWLINE> <DEDENT> p = a [ - 1 ] <NEWLINE> for i in range ( - 1 , - n - 1 , - 1 ) : <NEWLINE> <INDENT> p = math . gcd ( p , a [ i ] ) <NEWLINE> pb [ i - 1 ] = p <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = math . gcd ( pf [ i ] , pb [ i + 1 ] ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = [ P [ 0 ] ] + [ 10 ** 10 ] * ( N - 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> T [ i ] = min ( T [ i - 1 ] , P [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] <= T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> s = np . array ( list ( input ( ) ) ) <NEWLINE> t = np . array ( list ( input ( ) ) ) <NEWLINE> dp = np . zeros ( ( len ( s ) + 1 , len ( t ) + 1 ) , dtype = int ) <NEWLINE> <NL> equal = s [ : , None ] == t [ None , : ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> dp [ i + 1 , 1 : ] = np . maximum ( dp [ i , : - 1 ] + equal [ i ] , dp [ i , 1 : ] ) <NEWLINE> dp [ i + 1 ] = np . maximum . accumulate ( dp [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> i = len ( s ) <NEWLINE> j = len ( t ) <NEWLINE> ans = [ ] <NEWLINE> <NL> while i > 0 and j > 0 : <NEWLINE> <INDENT> if s [ i - 1 ] == t [ j - 1 ] : <NEWLINE> <INDENT> ans . append ( s [ i - 1 ] ) <NEWLINE> i -= 1 <NEWLINE> j -= 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] == dp [ i - 1 ] [ j ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans [ : : - 1 ] ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if ( a - c ) >= 0 : <NEWLINE> <INDENT> AC = ( a - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC = ( c - a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if a < b < c : <NEWLINE> <INDENT> AB = ( b - a ) <NEWLINE> BC = ( c - b ) <NEWLINE> <DEDENT> if c < b < a : <NEWLINE> <INDENT> AB = ( a - b ) <NEWLINE> BC = ( b - c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if AC <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif AB <= d and BC <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def get_digits_sum ( val_str ) : <NEWLINE> <INDENT> digits_sum = 0 <NEWLINE> for i in range ( len ( val_str ) ) : <NEWLINE> <INDENT> digits_sum += int ( val_str [ i ] ) <NEWLINE> <NL> <DEDENT> return digits_sum <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> if N == 2 : <NEWLINE> <INDENT> sum_min = 2 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N , 1 ) : <NEWLINE> <INDENT> A = i <NEWLINE> B = N - i <NEWLINE> a_sum = get_digits_sum ( str ( A ) ) <NEWLINE> b_sum = get_digits_sum ( str ( B ) ) <NEWLINE> if i == 2 : <NEWLINE> <INDENT> sum_min = a_sum + b_sum <NEWLINE> <DEDENT> elif sum_min > a_sum + b_sum : <NEWLINE> <INDENT> sum_min = a_sum + b_sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_min ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = [ ] <NEWLINE> m = 10 ** 17 <NEWLINE> for p in P : <NEWLINE> <INDENT> m = min ( m , p ) <NEWLINE> Q . append ( m ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> for x , y in zip ( P , Q ) : <NEWLINE> <INDENT> if x <= y : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , f , b = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] , key = lambda x : x [ 1 ] ) , 1 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] [ 0 ] <NEWLINE> if b > a [ i ] [ 1 ] : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if f == 1 else <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> def fnw ( n , s ) : <NEWLINE> <INDENT> sm = deque ( [ ] ) <NEWLINE> if n <= len ( s ) : <NEWLINE> <INDENT> for _ in range ( n ) : <NEWLINE> <INDENT> sm . append ( s . popleft ( ) ) <NEWLINE> <DEDENT> <DEDENT> return sm <NEWLINE> <NL> <DEDENT> def jfws ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> sm = fnw ( 5 , s ) <NEWLINE> <COMMENT> <NL> if <STRING> . join ( sm ) == <STRING> : <NEWLINE> <INDENT> sm = fnw ( 2 , s ) <NEWLINE> if <STRING> . join ( sm ) == <STRING> : <NEWLINE> <INDENT> if bool ( s ) : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . extendleft ( deque ( reversed ( list ( sm ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s . extendleft ( deque ( reversed ( list ( sm ) ) ) ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> elif <STRING> . join ( sm ) == <STRING> : <NEWLINE> <INDENT> sm = fnw ( 1 , s ) <NEWLINE> if <STRING> . join ( sm ) != <STRING> : <NEWLINE> <INDENT> s . extendleft ( sm ) <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( s ) : <NEWLINE> <INDENT> while len ( s ) > 0 : <NEWLINE> <INDENT> if jfws ( s ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> s = deque ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> print ( main ( s ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> n , m , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( ( v , a , b ) ) <NEWLINE> G [ v ] . append ( ( u , a , b ) ) <NEWLINE> <NL> <NL> <DEDENT> def dijkstra ( start , mode ) : <NEWLINE> <INDENT> INF = 10 ** 15 <NEWLINE> dist = [ INF ] * ( n + 1 ) <NEWLINE> dist [ start ] = 0 <NEWLINE> q = [ ( 0 , start ) ] <NEWLINE> while q : <NEWLINE> <INDENT> d , v = heappop ( q ) <NEWLINE> if dist [ v ] < d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for w , * a in G [ v ] : <NEWLINE> <INDENT> d1 = d + a [ mode ] <NEWLINE> if dist [ w ] > d1 : <NEWLINE> <INDENT> dist [ w ] = d1 <NEWLINE> heappush ( q , ( d1 , w ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <NL> <DEDENT> d1 = np . array ( dijkstra ( s , 0 ) ) <NEWLINE> d2 = np . array ( dijkstra ( t , 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> d = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> d . append ( d1 [ i ] + d2 [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> ans = [ ] <NEWLINE> B = 10 ** 15 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B = min ( B , d [ n - i ] ) <NEWLINE> ans . append ( B ) <NEWLINE> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( 10 ** 15 - ans [ i ] ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ [ <STRING> ] * ( w + 2 ) ] + [ list ( <STRING> + input ( ) + <STRING> ) for i in range ( h ) ] + [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> a = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> <NL> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> a [ i - 1 ] [ j - 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = [ s [ i - 1 ] [ j - 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] , s [ i ] [ j - 1 ] , s [ i ] [ j + 1 ] , s [ i + 1 ] [ j - 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] ] <NEWLINE> c = b . count ( <STRING> ) <NEWLINE> <NL> a [ i - 1 ] [ j - 1 ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> a [ i ] = [ str ( x ) for x in a [ i ] ] <NEWLINE> print ( <STRING> . join ( a [ i ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ansa = 0 <NEWLINE> sa = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sa += A [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if sa >= 0 : <NEWLINE> <INDENT> ansa += abs ( sa ) + 1 <NEWLINE> sa = - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sa <= 0 : <NEWLINE> <INDENT> ansa += abs ( sa ) + 1 <NEWLINE> sa = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ansb = 0 <NEWLINE> sb = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sb += A [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> if sb <= 0 : <NEWLINE> <INDENT> ansb += abs ( sb ) + 1 <NEWLINE> sb = + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sb >= 0 : <NEWLINE> <INDENT> ansb += abs ( sb ) + 1 <NEWLINE> sb = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( ansa , ansb ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
H , W , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> l_h = [ 0 ] * H <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if <STRING> in set ( l [ i ] ) : <NEWLINE> <INDENT> l_h [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> bor = sum ( l_h ) - 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if cnt == bor : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if l_h [ i ] == 1 : <NEWLINE> <INDENT> l_h [ i ] = - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 1 <NEWLINE> import numpy as np <NEWLINE> tmp = [ ] <NEWLINE> st = 0 <NEWLINE> ans = np . zeros ( ( H , W ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> tmp . append ( l [ i ] ) <NEWLINE> if l_h [ i ] == - 1 : <NEWLINE> <INDENT> n_tmp = np . array ( tmp ) <NEWLINE> s_count = np . count_nonzero ( n_tmp == <STRING> ) - 1 <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> ans [ st : i + 1 , j ] = cnt <NEWLINE> if <STRING> in n_tmp [ : , j ] and s_count > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> s_count -= 1 <NEWLINE> <DEDENT> <DEDENT> st = i + 1 <NEWLINE> cnt += 1 <NEWLINE> tmp = [ ] <NEWLINE> <DEDENT> <DEDENT> n_tmp = np . array ( tmp ) <NEWLINE> s_count = np . count_nonzero ( n_tmp == <STRING> ) - 1 <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> ans [ st : i + 1 , j ] = cnt <NEWLINE> if <STRING> in n_tmp [ : , j ] and s_count > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> s_count -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( * list ( map ( int , i ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> counter = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if len ( [ i for i in s if i % 2 == 0 ] ) == 1 : <NEWLINE> <INDENT> s = [ i for i in s if i % 2 == 0 ] <NEWLINE> print ( int ( s [ 0 ] ) * ( 2 ** counter ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = [ i / 2 for i in s ] <NEWLINE> counter += 1 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for ai in range ( N // 4 , 3500 ) : <NEWLINE> <INDENT> for bi in range ( N // 4 , 3500 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ci = N * ai * bi / ( 4 * ai * bi - N * ai - N * bi ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ci == int ( ci ) and ci > 0 : <NEWLINE> <INDENT> print ( ai , bi , int ( ci ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ float ( <STRING> ) ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = h [ i ] <NEWLINE> for j in range ( 1 , min ( k + 1 , n - i ) ) : <NEWLINE> <INDENT> num = dp [ i ] + abs ( a - h [ i + j ] ) <NEWLINE> if num < dp [ i + j ] : <NEWLINE> <INDENT> dp [ i + j ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from scipy . special import comb <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> sdict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> inp = <STRING> . join ( sorted ( list ( input ( ) ) ) ) <NEWLINE> if inp not in sdict : <NEWLINE> <INDENT> sdict . update ( { inp : 1 } ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sdict [ inp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for key in sdict : <NEWLINE> <INDENT> ans += comb ( sdict [ key ] , 2 , exact = True ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> f = 1 <NEWLINE> while f * f < m + 1 : <NEWLINE> <INDENT> if m % f == 0 : <NEWLINE> <INDENT> d . append ( f ) <NEWLINE> d . append ( m // f ) <NEWLINE> <DEDENT> f += 1 <NEWLINE> <DEDENT> d . sort ( reverse = True ) <NEWLINE> for i in d : <NEWLINE> <INDENT> if ( m - i * n ) >= 0 and ( m - i * n ) % i == 0 : break <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , k , q = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> score = [ 0 ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> score [ a - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for s in score : <NEWLINE> <INDENT> print ( <STRING> if s + k - q > 0 else <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = N * ( N - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = set ( input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> for ans in range ( N , 100000 ) : <NEWLINE> <INDENT> if all ( d not in D for d in str ( ans ) ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> raise AssertionError ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = [ 0 ] * N <NEWLINE> D = [ 0 ] * ( N + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a - 1 ] += 1 <NEWLINE> D [ C [ a - 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> S = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i + 1 ] = S [ i ] + D [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = N <NEWLINE> for K in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> while ans > 0 and S [ ans ] < K * ans : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> b = n // a <NEWLINE> ans = len ( str ( b ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> vmax = sum ( [ a [ i ] [ 1 ] for i in range ( N ) ] ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> dp = np . full ( vmax + 1 , INF ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = a [ i - 1 ] <NEWLINE> dp [ v : ] = np . minimum ( dp [ v : ] , dp [ : - v ] + w ) <NEWLINE> <DEDENT> print ( max ( [ i for i in range ( vmax + 1 ) if dp [ i ] <= W ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> trees = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> trees [ a - 1 ] . append ( b - 1 ) <NEWLINE> trees [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visited = [ False ] * n <NEWLINE> def dfs ( n ) : <NEWLINE> <INDENT> visited [ n ] = True <NEWLINE> for i in trees [ n ] : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] += ans [ n ] <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> cnt_list = [ 0 ] * n <NEWLINE> a = int ( ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if num_list [ i - 1 ] > num_list [ i ] : <NEWLINE> <INDENT> cnt_list [ i ] = - 1 <NEWLINE> <DEDENT> if num_list [ i - 1 ] < num_list [ i ] : <NEWLINE> <INDENT> cnt_list [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 in cnt_list and - 1 in cnt_list : <NEWLINE> <INDENT> del cnt_list [ : max ( cnt_list . index ( 1 ) , cnt_list . index ( - 1 ) ) ] <NEWLINE> cnt_list [ 0 ] = 0 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <NEWLINE> res = [ 0 ] * ( N + 1 ) <NEWLINE> M = 0 <NEWLINE> <NL> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> if sum ( res [ j ] for j in range ( i , N + 1 , i ) ) % 2 != A [ i ] : <NEWLINE> <INDENT> res [ i ] = 1 <NEWLINE> M += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( M ) <NEWLINE> print ( * [ k for k , r in enumerate ( res ) if r ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if L [ i ] == n : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - n + 1 ) <NEWLINE> <DEDENT>
import itertools as it <NEWLINE> <NL> N = list ( input ( ) ) <NEWLINE> l = len ( N ) <NEWLINE> a = N [ 0 ] + <STRING> * ( l - 1 ) <COMMENT> <NEWLINE> <NL> ans = int ( N [ 0 ] ) + 9 * ( l - 1 ) <NEWLINE> <NL> if int ( <STRING> . join ( N ) ) != int ( a ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> L [ a ] = - 1 <NEWLINE> <DEDENT> L [ 0 ] = 1 <NEWLINE> L [ 1 ] += 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if L [ i ] == - 1 : <NEWLINE> <INDENT> L [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( L [ - 1 ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = <STRING> <NEWLINE> ans = 0 <NEWLINE> <NL> i = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> if S [ i ] in T : <NEWLINE> <INDENT> temp = 1 <NEWLINE> for j in range ( i + 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ j ] in T : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> check_id = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> check_id = a [ check_id - 1 ] <NEWLINE> if check_id == 2 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check_id != 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) - 1 for _ in range ( N ) ] <NEWLINE> <NL> light = 0 <NEWLINE> ans = - 1 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> light = A [ light ] <NEWLINE> if light == 1 : <NEWLINE> <INDENT> ans = n <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = 0 <NEWLINE> ra = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = max ( la , l ) <NEWLINE> ra = min ( ra , r ) <NEWLINE> <DEDENT> print ( max ( 0 , ra - la + 1 ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> def main ( n ) : <NEWLINE> <INDENT> global l <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> tmp = i * ( i + 1 ) // 2 <NEWLINE> if tmp >= n : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> if n - i == 0 : <NEWLINE> <INDENT> return l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main ( n - i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sys . setrecursionlimit ( 10000 ) <NEWLINE> li = main ( N ) <NEWLINE> for n in li : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for c in range ( N ) ] <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> tmp = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 < N : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += tmp % 2 <NEWLINE> tmp = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += tmp % 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( x , k + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z > k or z < y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == y and y == z : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif x == y or y == z or x == z : <NEWLINE> <INDENT> ans += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( 1 , min ( a , b ) + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> t . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( t [ - k ] ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
def actual ( N , M , AB ) : <NEWLINE> <INDENT> payment = 0 <NEWLINE> <NL> shop_order_by_price_desc = sorted ( AB , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> for price , stock in shop_order_by_price_desc : <NEWLINE> <INDENT> if stock >= M : <NEWLINE> <COMMENT> <NL> <INDENT> return payment + ( price * M ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> M -= stock <NEWLINE> payment += price * stock <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AB . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> print ( actual ( N , M , AB ) ) <NEWLINE>
W = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = input ( ) <NEWLINE> print ( len ( W ) - W . index ( S ) ) <NEWLINE>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , * A = map ( int , open ( 0 ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> ans += sum ( A [ N // 2 : ] ) * 2 - sum ( A [ : N // 2 ] ) * 2 <NEWLINE> ans -= A [ N // 2 ] + A [ N // 2 + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += sum ( A [ N // 2 : ] ) * 2 - sum ( A [ : N // 2 ] ) * 2 <NEWLINE> ans -= A [ N // 2 ] - A [ N // 2 - 1 ] <NEWLINE> <NL> <NL> <DEDENT> ans2 = 0 <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> ans2 += sum ( A [ N // 2 + 1 : ] ) * 2 - sum ( A [ : N // 2 + 1 ] ) * 2 <NEWLINE> ans2 += A [ N // 2 ] + A [ N // 2 - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 += sum ( A [ N // 2 : ] ) * 2 - sum ( A [ : N // 2 ] ) * 2 <NEWLINE> ans2 += A [ N // 2 - 1 ] - A [ N // 2 ] <NEWLINE> <NL> <DEDENT> print ( max ( ans , ans2 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> w_series = [ 0 ] <NEWLINE> e_series = [ 0 ] <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> w_series . append ( w_series [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w_series . append ( w_series [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for c in s [ : : - 1 ] : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> e_series . append ( e_series [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e_series . append ( e_series [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> e_series = e_series [ : : - 1 ] <NEWLINE> <NL> ans = n <NEWLINE> for x in zip ( w_series [ 1 : ] , e_series [ : - 1 ] ) : <NEWLINE> <INDENT> ans = min ( sum ( x ) - 1 , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def edu_dp_a_frog2 ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( [ dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) for j in range ( 1 , min ( i + 1 , k + 1 ) ) ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> edu_dp_a_frog2 ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> l = sorted ( l , reverse = False ) <NEWLINE> <COMMENT> <NL> drinks = 0 <NEWLINE> ttl = 0 <NEWLINE> add = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> add = min ( m - drinks , l [ i ] [ 1 ] ) <NEWLINE> ttl = ttl + add * l [ i ] [ 0 ] <NEWLINE> drinks += add <NEWLINE> if drinks == m : <NEWLINE> <INDENT> print ( ttl ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> m = int ( p ** ( 1 / n ) + 1e-9 ) <NEWLINE> <NL> for i in range ( m , 0 , - 1 ) : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> p_min = p [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if p_min >= p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> p_min = min ( p_min , p [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = len ( a ) <NEWLINE> result = 1 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if a [ i ] == result : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> if i >= b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if result == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - result + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( A ) != len ( set ( A ) ) or len ( B ) != len ( set ( B ) ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> As = set ( A ) <NEWLINE> Bs = set ( B ) <NEWLINE> res = 1 <NEWLINE> for x in reversed ( range ( 1 , n * m + 1 ) ) : <NEWLINE> <INDENT> if x in As and x in Bs : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif x in As : <NEWLINE> <INDENT> res *= m - bisect_left ( B , x ) <NEWLINE> <DEDENT> elif x in Bs : <NEWLINE> <INDENT> res *= n - bisect_left ( A , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = m - bisect_left ( B , x ) <NEWLINE> t = n - bisect_left ( A , x ) <NEWLINE> res *= s * t - ( n * m - x ) <NEWLINE> <DEDENT> res %= mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
odd = list ( map ( str , input ( ) ) ) <NEWLINE> even = list ( map ( str , input ( ) ) ) <NEWLINE> if len ( odd ) == len ( even ) : <NEWLINE> <INDENT> L = len ( odd ) * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = len ( odd ) + len ( even ) <NEWLINE> <DEDENT> li = [ ] <NEWLINE> <NL> for i in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> li . append ( odd [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( odd [ i // 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> li . append ( even [ i // 2 - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( li ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10000000000 <NEWLINE> expList = [ INF ] * 1001 <NEWLINE> def expectationF ( num ) : <NEWLINE> <INDENT> if expList [ num ] == INF : <NEWLINE> <INDENT> exp = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> exp += i / num <NEWLINE> <DEDENT> expList [ num ] = exp <NEWLINE> <DEDENT> return expList [ num ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> mid = 0 <NEWLINE> midList = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i >= 1 : <NEWLINE> <INDENT> midList . append ( expectationF ( List [ i ] ) + midList [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> midList . append ( expectationF ( List [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> m = K - 1 <NEWLINE> for j in range ( N - m ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> mid = midList [ j + m ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mid = midList [ j + m ] - midList [ j - 1 ] <NEWLINE> <DEDENT> res = max ( res , mid ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for v in range ( 2 ) : <NEWLINE> <INDENT> if a [ 0 ] >= a [ 1 ] : <NEWLINE> <INDENT> count += a [ 0 ] <NEWLINE> a [ 0 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += a [ 1 ] <NEWLINE> a [ 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> ss = np . array ( S + S ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = ss [ i : i + n ] <NEWLINE> if np . array_equal ( a , a . T ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans * n ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> def is_good ( mid , key ) : <NEWLINE> <INDENT> x = A - mid // F <NEWLINE> return x [ x > 0 ] . sum ( ) <= key <NEWLINE> <NL> <NL> <DEDENT> def binary_search ( key ) : <NEWLINE> <INDENT> bad , good = - 1 , 10 ** 18 <NEWLINE> while good - bad > 1 : <NEWLINE> <INDENT> mid = ( bad + good ) // 2 <NEWLINE> if is_good ( mid , key ) : <NEWLINE> <INDENT> good = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad = mid <NEWLINE> <DEDENT> <DEDENT> return good <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> F = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> A . sort ( ) <NEWLINE> F [ : : - 1 ] . sort ( ) <NEWLINE> print ( binary_search ( K ) ) <NEWLINE>
alpha = <STRING> <NEWLINE> inp = input ( ) <NEWLINE> def split ( w ) : <NEWLINE> <INDENT> return [ all for all in w ] <NEWLINE> <DEDENT> alpha = split ( alpha ) <NEWLINE> x = alpha . index ( inp ) <NEWLINE> try : <NEWLINE> <INDENT> print ( alpha [ x + 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L , R = [ 0 ] * M , [ 0 ] * M <NEWLINE> A = set ( range ( N ) ) <NEWLINE> lm , rm = 0 , N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> lm = max ( lm , L [ i ] ) <NEWLINE> rm = min ( rm , R [ i ] ) <NEWLINE> <DEDENT> if lm <= rm : <NEWLINE> <INDENT> print ( rm - lm + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> t01 = <STRING> <NEWLINE> t10 = <STRING> <NEWLINE> <NL> for x in s : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> t01 += <STRING> <NEWLINE> t10 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t01 += <STRING> <NEWLINE> t10 += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> l1 = [ int ( a ) for a in t01 ] <NEWLINE> l2 = [ int ( a ) for a in t10 ] <NEWLINE> left = [ 0 ] + list ( accumulate ( l1 ) ) [ : - 1 ] <NEWLINE> right = list ( accumulate ( l2 [ : : - 1 ] ) ) [ - 2 : : - 1 ] + [ 0 ] <NEWLINE> print ( min ( w + e for ( w , e ) in zip ( left , right ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> bc = B // C <NEWLINE> ac = ( A - 1 ) // C <NEWLINE> cnum = bc - ac <NEWLINE> <NL> bd = B // D <NEWLINE> ad = ( A - 1 ) // D <NEWLINE> dnum = bd - ad <NEWLINE> <NL> <NL> lcmcd = lcm ( C , D ) <NEWLINE> blcmcd = B // lcmcd <NEWLINE> alcmcd = ( A - 1 ) // lcmcd <NEWLINE> lcmcdnum = blcmcd - alcmcd <NEWLINE> <NL> <NL> print ( B - A - cnum - dnum + lcmcdnum + 1 ) <NEWLINE>
N = list ( str ( input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> if len ( N ) == 1 : <NEWLINE> <INDENT> print ( int ( N [ 0 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( N ) ) : <NEWLINE> <INDENT> if N [ i ] != <STRING> : <NEWLINE> <INDENT> ans += int ( N [ 0 ] ) - 1 <NEWLINE> ans += ( len ( N ) - 1 ) * 9 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans += int ( N [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = len ( str ( N ) ) <NEWLINE> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = min ( ans , max ( len ( str ( i ) ) , len ( str ( N // i ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n <= 3000 : <NEWLINE> <INDENT> for a in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for b in range ( 1 , 3501 ) : <NEWLINE> <INDENT> s = n * a * b <NEWLINE> <COMMENT> <NL> t = 4 * a * b - n * b - n * a <NEWLINE> <COMMENT> <NL> if s <= t * 3500 : <NEWLINE> <INDENT> if t != 0 and s % t == 0 and t > 0 : <NEWLINE> <INDENT> c = s // t <NEWLINE> print ( a , b , c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for a in range ( 3501 , 1 , - 1 ) : <NEWLINE> <INDENT> for b in range ( 3501 , 1 , - 1 ) : <NEWLINE> <INDENT> s = n * a * b <NEWLINE> <COMMENT> <NL> t = 4 * a * b - n * b - n * a <NEWLINE> <COMMENT> <NL> if s <= t * 3500 : <NEWLINE> <INDENT> if t != 0 and s % t == 0 and t > 0 : <NEWLINE> <INDENT> c = s // t <NEWLINE> print ( a , b , c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> d = { i : 2 for i in range ( 1 , n , 2 ) } <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = { i : 2 for i in range ( 0 , n , 2 ) } <NEWLINE> d [ 0 ] = 1 <NEWLINE> <DEDENT> for a in l : <NEWLINE> <INDENT> if a in d : <NEWLINE> <INDENT> d [ a ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in d . values ( ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ( 2 ** ( n // 2 ) ) % mod ) <NEWLINE>
from bisect import bisect_left <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> py = [ ] <NEWLINE> l = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ p ] . append ( y ) <NEWLINE> py . append ( ( p , y ) ) <NEWLINE> <NL> <DEDENT> for i in l : i . sort ( ) <NEWLINE> <NL> for p , y in py : <NEWLINE> <INDENT> s = str ( p ) <NEWLINE> t = str ( bisect_left ( l [ p ] , y ) + 1 ) <NEWLINE> ans = <STRING> * ( 6 - len ( s ) ) + s + <STRING> * ( 6 - len ( t ) ) + t <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <COMMENT> <NL> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a // gcd ( a , b ) ) * b <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> a_lcm = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> a_lcm = lcm ( a_lcm , a ) <NEWLINE> <COMMENT> <NL> if ( a_lcm / 2 ) > m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if ( a_lcm / 2 ) % a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = int ( ( m - ( a_lcm / 2 ) ) // a_lcm ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> p = 0 <NEWLINE> for e in a : <NEWLINE> <INDENT> if p != e : <NEWLINE> <INDENT> b . append ( e ) <NEWLINE> <DEDENT> p = e <NEWLINE> <DEDENT> a = b <NEWLINE> n = len ( b ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i + 1 == n : break <NEWLINE> else : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> while i + 1 < n and a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i + 1 < n and a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d . sort ( ) <NEWLINE> ans = d [ N // 2 ] - d [ N // 2 - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for x in range ( 1 , n ) : <NEWLINE> <INDENT> a [ x ] += a [ x - 1 ] <NEWLINE> if s [ x - 1 ] == <STRING> and s [ x ] == <STRING> : <NEWLINE> <INDENT> a [ x ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for y in range ( q ) : <NEWLINE> <NL> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = a [ r - 1 ] - a [ l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> length = len ( a ) - len ( b ) + 1 <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> A = list ( <STRING> * i + b + <STRING> * ( length - i - 1 ) ) <NEWLINE> flag = True <NEWLINE> for j in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ j ] == <STRING> or a [ j ] == A [ j ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif a [ j ] != <STRING> and A [ j ] == <STRING> : <NEWLINE> <INDENT> A [ j ] = a [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans . append ( <STRING> . join ( A ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> ans . sort ( ) <NEWLINE> print ( ans [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans [ a [ i - 1 ] - 1 ] = i <NEWLINE> <DEDENT> [ print ( ans [ i ] , end = <STRING> ) for i in range ( n ) ] <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> dp = np . zeros ( w + 1 , dtype = int ) <NEWLINE> <NL> for x in sys . stdin . buffer . readlines ( ) : <NEWLINE> <INDENT> w , v = map ( int , x . split ( ) ) <NEWLINE> np . maximum ( dp [ w : ] , dp [ : - w ] + v , out = dp [ w : ] ) <NEWLINE> <DEDENT> print ( dp . max ( ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> def eraP ( n ) : <NEWLINE> <INDENT> if n <= 1 : return [ False ] * ( n + 1 ) <NEWLINE> elif n <= 2 : return [ False , False , True ] <NEWLINE> L = [ False if i % 2 == 0 or i % 3 == 0 else True for i in range ( n ) ] <NEWLINE> L [ 0 ] = False ; L [ 1 ] = False ; <NEWLINE> L [ 2 ] = True ; L [ 3 ] = True ; L [ 5 ] = True <NEWLINE> limit = math . sqrt ( n ) <NEWLINE> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if i >= limit : return L <NEWLINE> for s in range ( i ** 2 , n , i ) : <NEWLINE> <INDENT> L [ s ] = False <NEWLINE> <DEDENT> <DEDENT> return L <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> LR = [ [ 0 , 0 ] for _ in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> LR [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> P = eraP ( pow ( 10 , 5 ) + 1 ) [ 1 : ] <NEWLINE> <NL> sumP = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( 2 , pow ( 10 , 5 ) ) : <NEWLINE> <INDENT> sumP . append ( sumP [ - 1 ] + int ( P [ i ] and P [ ( i + 1 ) // 2 ] ) ) <NEWLINE> <NL> <DEDENT> for lr in LR : <NEWLINE> <INDENT> print ( sumP [ lr [ 1 ] ] - sumP [ lr [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
L , R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( L , min ( R , L + 2019 ) ) : <NEWLINE> <INDENT> for j in range ( L + 1 , min ( R , L + 2019 ) + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> def depth_first_search ( s ) : <NEWLINE> <INDENT> if int ( s ) > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> ret = 1 if all ( s . count ( c ) > 0 for c in <STRING> ) else 0 <NEWLINE> for c in <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ret += depth_first_search ( s + c ) <NEWLINE> <COMMENT> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> print ( depth_first_search ( <STRING> ) ) <NEWLINE>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 100010 ) <NEWLINE> lst = [ 100 , 101 , 102 , 103 , 104 , 105 ] <NEWLINE> for i in range ( 100 , 106 ) : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for v in range ( 100 , X + 1 ) : <NEWLINE> <INDENT> for w in range ( 6 ) : <NEWLINE> <INDENT> n = lst [ w ] <NEWLINE> if dp [ v - n ] == 1 : <NEWLINE> <INDENT> dp [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ X ] ) <NEWLINE>
import itertools <NEWLINE> I = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> H , W , D = I [ : 3 ] <NEWLINE> A = I [ 3 : 3 + H * W ] <NEWLINE> Q = I [ 3 + H * W ] <NEWLINE> LR = I [ 4 + H * W : ] <NEWLINE> <NL> a_i = [ 0 ] * ( H * W + 1 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> a_i [ a ] = i <NEWLINE> <NL> <NL> <DEDENT> def calc ( a1 ) : <NEWLINE> <INDENT> a2 = a1 + D <NEWLINE> hw1 = a_i [ a1 ] <NEWLINE> h1 , w1 = divmod ( hw1 , W ) <NEWLINE> hw2 = a_i [ a2 ] <NEWLINE> h2 , w2 = divmod ( hw2 , W ) <NEWLINE> return abs ( h2 - h1 ) + abs ( w2 - w1 ) <NEWLINE> <NL> <NL> <DEDENT> score = [ 0 ] + [ calc ( i ) for i in range ( 1 , H * W + 1 - D ) ] <NEWLINE> cum = [ [ 0 ] + list ( itertools . accumulate ( score [ i : : D ] ) ) for i in range ( D ) ] <NEWLINE> ans = [ ] <NEWLINE> for l , r in zip ( LR [ : : 2 ] , LR [ 1 : : 2 ] ) : <NEWLINE> <INDENT> ans += [ cum [ r % D ] [ r // D ] - cum [ l % D ] [ l // D ] ] <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = n <NEWLINE> prev = a [ 0 ] <NEWLINE> trend = <STRING> <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] > prev : <NEWLINE> <INDENT> if ( trend == <STRING> or trend == <STRING> ) : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> trend = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trend = <STRING> <NEWLINE> <DEDENT> <DEDENT> if a [ i ] < prev : <NEWLINE> <INDENT> if ( trend == <STRING> or trend == <STRING> ) : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> trend = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trend = <STRING> <NEWLINE> <DEDENT> <DEDENT> if a [ i ] == prev : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> prev = a [ i ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> List = list ( S ) <NEWLINE> res = 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if List [ i ] != <STRING> : <NEWLINE> <INDENT> res = List [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wv [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , ( w , v ) in enumerate ( wv , start = 1 ) : <NEWLINE> <INDENT> dp_i = dp [ i ] <NEWLINE> dp_im = dp [ i - 1 ] <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if j < w : <NEWLINE> <INDENT> dp_i [ j ] = dp_im [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = dp_im [ j - w ] + v <NEWLINE> b = dp_im [ j ] <NEWLINE> if a > b : <NEWLINE> <INDENT> dp_i [ j ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp_i [ j ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] [ - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> H , W , * S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> H , W = [ int ( _ ) for _ in [ H , W ] ] <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( H * W ) : <NEWLINE> <INDENT> x , y = divmod ( i , W ) <NEWLINE> if S [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> for dx , dy in ( ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if not ( 0 <= nx < H and 0 <= ny < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> A += [ i ] <NEWLINE> B += [ nx * W + ny ] <NEWLINE> C += [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> F = floyd_warshall ( csr_matrix ( ( C , ( A , B ) ) , shape = ( H * W , H * W ) ) ) <NEWLINE> print ( int ( np . max ( F [ F != np . inf ] ) ) ) <NEWLINE>
<NL> <COMMENT> <NL> <NL> def solution ( nums ) : <NEWLINE> <INDENT> n = len ( nums ) <NEWLINE> dp = [ 0 , 0 , 0 ] <NEWLINE> for day in range ( n ) : <NEWLINE> <INDENT> new_dp = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> new_dp [ i ] = max ( new_dp [ i ] , dp [ j ] + nums [ day ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp = new_dp <NEWLINE> <DEDENT> return max ( dp [ 0 ] , dp [ 1 ] , dp [ 2 ] ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> day = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums . append ( day ) <NEWLINE> <DEDENT> res = solution ( nums ) <NEWLINE> print ( res ) <NEWLINE>
N , K , Q , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = [ K ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for x in ans : <NEWLINE> <INDENT> y = x - Q <NEWLINE> print ( <STRING> if y > 0 else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) <NEWLINE> write = lambda x : sys . stdout . write ( x + <STRING> ) <NEWLINE> <NL> <NL> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ ] <NEWLINE> rs = [ ] <NEWLINE> cs = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if <STRING> in c : <NEWLINE> <INDENT> start = ( i , c . index ( <STRING> ) ) <NEWLINE> <DEDENT> if <STRING> in c : <NEWLINE> <INDENT> goal = ( i , c . index ( <STRING> ) ) <NEWLINE> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if c [ j ] in ( <STRING> ) : <COMMENT> <NEWLINE> <INDENT> data . append ( 1 ) <NEWLINE> rs . append ( i ) <NEWLINE> cs . append ( h + j ) <NEWLINE> data . append ( 1 ) <NEWLINE> rs . append ( h + j ) <NEWLINE> cs . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = h + w <NEWLINE> t = h + w + 1 <NEWLINE> V = 10 ** 9 <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( s ) <NEWLINE> cs . append ( start [ 0 ] ) <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( start [ 0 ] ) <NEWLINE> cs . append ( s ) <NEWLINE> <NL> data . append ( V ) <NEWLINE> rs . append ( s ) <NEWLINE> cs . append ( start [ 1 ] + h ) <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( start [ 1 ] + h ) <NEWLINE> cs . append ( s ) <NEWLINE> <NL> data . append ( V ) <NEWLINE> rs . append ( goal [ 0 ] ) <NEWLINE> cs . append ( t ) <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( t ) <NEWLINE> cs . append ( goal [ 0 ] ) <NEWLINE> <NL> data . append ( V ) <NEWLINE> rs . append ( t ) <NEWLINE> cs . append ( goal [ 1 ] + h ) <NEWLINE> data . append ( V ) <NEWLINE> rs . append ( goal [ 1 ] + h ) <NEWLINE> cs . append ( t ) <NEWLINE> <NL> import scipy . sparse <NEWLINE> m = scipy . sparse . csr_matrix ( ( data , ( rs , cs ) ) , shape = ( h + w + 2 , h + w + 2 ) ) <NEWLINE> val = scipy . sparse . csgraph . maximum_flow ( m , s , t ) . flow_value <NEWLINE> if val >= 10 ** 9 : <NEWLINE> <INDENT> val = - 1 <NEWLINE> <DEDENT> print ( val ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <COMMENT> <NL> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = b - a + 1 <NEWLINE> <NL> if n > k * 2 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( a + i ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( b - ( k - i - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> dp = [ - 1 ] * N <NEWLINE> <NL> def rec ( v ) : <NEWLINE> <INDENT> if dp [ v ] != - 1 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> res = 0 <NEWLINE> for next_v in G [ v ] : <NEWLINE> <INDENT> res = max ( res , rec ( next_v ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = res <NEWLINE> return dp [ v ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i ] = rec ( i ) <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> m = n // i - 1 <NEWLINE> if m > 0 and n % i == 0 and n // m == n % m : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . append ( temp ) <NEWLINE> <COMMENT> <NL> <DEDENT> li . sort ( ) <NEWLINE> <COMMENT> <NL> total = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> print ( li [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> total += li [ i ] [ 1 ] <NEWLINE> if total < k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( li [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ 0 ] * N <NEWLINE> k = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> lis [ i - 1 ] = k <NEWLINE> k += 1 <NEWLINE> <DEDENT> lis = map ( str , lis ) <NEWLINE> ans = <STRING> . join ( lis ) <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x0 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x1 = [ i for i in x0 if i >= 0 ] <NEWLINE> x2 = list ( reversed ( [ i for i in x0 if i < 0 ] ) ) <NEWLINE> count0 = len ( x1 ) <NEWLINE> count1 = len ( x2 ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> if count1 == 0 : <NEWLINE> <INDENT> print ( x1 [ k - 1 ] ) <NEWLINE> <DEDENT> elif count0 == 0 : <NEWLINE> <INDENT> print ( - x2 [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 0 in x1 : <NEWLINE> <INDENT> x1 . remove ( 0 ) <NEWLINE> k -= 1 <NEWLINE> count0 -= 1 <NEWLINE> <DEDENT> for i in range ( min ( count0 , k ) ) : <NEWLINE> <INDENT> if count1 >= k - i - 1 : <NEWLINE> <INDENT> ans = min ( ans , x1 [ i ] * 2 - x2 [ k - i - 2 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( min ( count1 , k ) ) : <NEWLINE> <INDENT> if count0 >= k - i - 1 : <NEWLINE> <INDENT> ans = min ( ans , - x2 [ i ] * 2 + x1 [ k - i - 2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> tmp = 1 <NEWLINE> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , x ) : <NEWLINE> <INDENT> tmp = pow ( i , j ) <NEWLINE> if tmp > x : <NEWLINE> <INDENT> tmp = pow ( i , j - 1 ) <NEWLINE> <COMMENT> <NL> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( tmp , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> prev = ans = - 1 <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i - prev > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif i - prev == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> prev = i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_dic = Counter ( A ) <NEWLINE> <NL> set_A = sorted ( ( set ( A ) ) , reverse = True ) <NEWLINE> tmp = 0 <NEWLINE> for a in set_A : <NEWLINE> <INDENT> if A_dic [ a ] >= 4 : <NEWLINE> <INDENT> print ( max ( tmp * a , a * a ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A_dic [ a ] >= 2 : <NEWLINE> <INDENT> ans = tmp * a <NEWLINE> if ans != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tmp = a <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = b - a + 1 <NEWLINE> if n <= k * 2 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for j in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT>
import sys , math , re <NEWLINE> from itertools import accumulate <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = ii ( ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> x , y = i2 ( N ) <NEWLINE> d = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> pair = ( x [ i ] - x [ j ] , y [ i ] - y [ j ] ) <NEWLINE> if not pair in d : <NEWLINE> <INDENT> d [ pair ] = 0 <NEWLINE> <NL> <DEDENT> d [ pair ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - max ( d . values ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> import re <NEWLINE> num_li = [ False ] * 1000 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> first_ = S . find ( str ( i ) , 0 , N - 2 ) <NEWLINE> if first_ == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> second_ = S . find ( str ( j ) , first_ + 1 , N - 1 ) <NEWLINE> if second_ == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> third_ = S . find ( str ( k ) , second_ + 1 , N ) <NEWLINE> if third_ == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_li [ i * 100 + j * 10 + k ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( num_li ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> d = c . most_common ( ) <NEWLINE> len_A = len ( set ( A ) ) <NEWLINE> if ( len_A <= K ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len_A - K ) : <NEWLINE> <INDENT> ans += d [ - 1 * ( i + 1 ) ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> iro = [ - 1 for i in range ( 2 * ( 10 ** 5 ) + 1 ) ] <NEWLINE> dp = [ 1 for i in range ( n + 1 ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> now = int ( input ( ) ) <NEWLINE> if iro [ now ] != - 1 and iro [ now ] != i - 1 : <NEWLINE> <INDENT> dp [ i ] += dp [ iro [ now ] ] <NEWLINE> <DEDENT> iro [ now ] = i <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> xy = [ list ( map ( Decimal , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> cnt = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> xi = xy [ i ] [ 0 ] <NEWLINE> yi = xy [ i ] [ 1 ] <NEWLINE> <NL> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> xj = xy [ j ] [ 0 ] <NEWLINE> yj = xy [ j ] [ 1 ] <NEWLINE> <NL> x_dif = xi - xj <NEWLINE> y_dif = yi - yj <NEWLINE> if x_dif < 0 : <NEWLINE> <INDENT> x_dif = - x_dif <NEWLINE> y_dif = - y_dif <NEWLINE> <DEDENT> elif x_dif == 0 : <NEWLINE> <INDENT> y_dif = abs ( y_dif ) <NEWLINE> <NL> <DEDENT> if ( x_dif , y_dif ) in cnt . keys ( ) : <NEWLINE> <INDENT> cnt [ x_dif , y_dif ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ x_dif , y_dif ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : print ( N - max ( cnt . values ( ) ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> cnt = defaultdict ( int ) <NEWLINE> for xi , yi in xy : <NEWLINE> <INDENT> for xj , yj in xy : <NEWLINE> <INDENT> cnt [ ( xi - xj , yi - yj ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> cnt [ ( 0 , 0 ) ] = 0 <NEWLINE> ans = n - max ( cnt . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from math import gcd <NEWLINE> <NL> L = [ 0 ] * n <NEWLINE> R = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> L [ i + 1 ] = gcd ( L [ i ] , A [ i ] ) <NEWLINE> <DEDENT> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> R [ i - 1 ] = gcd ( R [ i ] , A [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , gcd ( L [ i ] , R [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> dic = dict ( ) <NEWLINE> dic2 = dict ( ) <NEWLINE> P = list ( ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if p not in dic . keys ( ) : <NEWLINE> <INDENT> dic [ p ] = [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ p ] . append ( y ) <NEWLINE> <DEDENT> P . append ( ( p , y ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for key in dic . keys ( ) : <NEWLINE> <INDENT> dic [ key ] . sort ( ) <NEWLINE> <NL> <DEDENT> for key in dic . keys ( ) : <NEWLINE> <INDENT> for i in range ( len ( dic [ key ] ) ) : <NEWLINE> <INDENT> dic2 [ dic [ key ] [ i ] ] = i + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> p , y = P [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> ans += <STRING> * ( 6 - len ( str ( p ) ) ) + str ( p ) <NEWLINE> <COMMENT> <NL> t = dic2 [ y ] <NEWLINE> ans += <STRING> * ( 6 - len ( str ( t ) ) ) + str ( t ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> count_dict = { } <NEWLINE> <NL> gate = set ( range ( 10 ** 5 + 1 ) ) <NEWLINE> <NL> L = 1 <NEWLINE> R = 10 ** 5 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> l = LR [ i ] [ 0 ] <NEWLINE> r = LR [ i ] [ 1 ] <NEWLINE> <NL> if l > L : <NEWLINE> <INDENT> L = l <NEWLINE> <DEDENT> if r < R : <NEWLINE> <INDENT> R = r <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( range ( L , R + 1 ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = deque ( a ) <NEWLINE> <NL> tmp = [ ] <NEWLINE> cnt = 0 <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> if len ( tmp ) <= 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not ( v >= tmp [ - 1 ] >= tmp [ - 2 ] >= tmp [ 0 ] or v <= tmp [ - 1 ] <= tmp [ - 2 ] <= tmp [ 0 ] ) : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> tmp . append ( v ) <NEWLINE> <COMMENT> <NL> <DEDENT> if tmp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> c = collections . Counter ( x ) <NEWLINE> cc = list ( c . values ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( cc ) ) : <NEWLINE> <INDENT> if cc [ i ] % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> def solve ( L , N ) : <NEWLINE> <INDENT> if L == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif N <= 2 ** ( L + 1 ) - 2 : <NEWLINE> <INDENT> return solve ( L - 1 , N - 1 ) <NEWLINE> <DEDENT> elif N == int ( 2 ** ( L + 1 ) - 1 ) : <NEWLINE> <INDENT> return 2 ** L <NEWLINE> <DEDENT> return solve ( L - 1 , N - 2 ** ( L + 1 ) + 1 ) + 2 ** L <NEWLINE> <NL> <NL> <DEDENT> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( N , X ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> rgb = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if l [ i ] == rgb [ j ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = rgb . index ( l [ i ] ) <NEWLINE> if not 0 <= p <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> rgb [ p ] += 1 <NEWLINE> ans *= c <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> CD = Counter ( D ) <NEWLINE> CT = Counter ( T ) <NEWLINE> ans = CT - CD <NEWLINE> <NL> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> <NL> import math <NEWLINE> import bisect <NEWLINE> max = L [ - 1 ] <NEWLINE> maxdiv2 = max // 2 <NEWLINE> posleft = bisect . bisect_left ( L , maxdiv2 ) <NEWLINE> posright = bisect . bisect_right ( L , maxdiv2 ) <NEWLINE> <NL> if len ( L ) == 2 : <NEWLINE> <INDENT> print ( L [ 1 ] , L [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if posleft != posright : <NEWLINE> <INDENT> print ( max , L [ posleft ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if abs ( max / 2 - L [ posleft ] ) > abs ( max / 2 - L [ posleft - 1 ] ) : <NEWLINE> <INDENT> print ( max , L [ posleft - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max , L [ posleft ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> data [ i ] = p [ i ] / 2 + float ( 0.5 ) <NEWLINE> <DEDENT> res = sum ( data [ 0 : k ] ) <NEWLINE> ans = sum ( data [ 0 : k ] ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> res -= data [ i ] - data [ i + k ] <NEWLINE> ans = max ( ans , res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L = n // 2 <NEWLINE> res = 0 <NEWLINE> while L : <NEWLINE> <INDENT> res += L // 5 <NEWLINE> L //= 5 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 2018 <NEWLINE> <NL> if r - l > 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> res = min ( res , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> b = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , - ( - b // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> o = B - A <NEWLINE> e = A - B <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> r = e <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = o <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> ans = list ( ) <NEWLINE> for a in range ( 0 , n + 1 , 1 ) : <NEWLINE> <INDENT> for b in range ( 0 , n + 1 , 1 ) : <NEWLINE> <INDENT> if a + b <= n : <NEWLINE> <INDENT> c = n - ( a + b ) <NEWLINE> total = a * 10000 + b * 5000 + c * 1000 <NEWLINE> if total == y : <NEWLINE> <INDENT> lists = [ a , b , c ] <NEWLINE> ans . append ( lists ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> answer = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> answer = <STRING> . join ( answer ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = [ str ( i ) for i in ans [ 0 ] ] <NEWLINE> answer = <STRING> . join ( answer ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l = 0 <NEWLINE> p = x <NEWLINE> <NL> if x > y : <NEWLINE> <INDENT> l += ( x - y ) * a <NEWLINE> p = y <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> l += ( y - x ) * b <NEWLINE> p = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> l += p * 2 * c <NEWLINE> n = max ( x , y ) * 2 * c <NEWLINE> m = x * a + y * b <NEWLINE> print ( min ( l , n , m ) ) <NEWLINE>
