a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = a * b <NEWLINE> lst = [ ] <NEWLINE> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if m < a * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lst . append ( a * i ) <NEWLINE> <NL> <DEDENT> for j in lst : <NEWLINE> <INDENT> if j % b == 0 : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_count = s . count ( <STRING> ) <NEWLINE> g_count = s . count ( <STRING> ) <NEWLINE> b_count = s . count ( <STRING> ) <NEWLINE> ans = r_count * g_count * b_count <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ss = input ( ) <NEWLINE> <NL> n = len ( ss ) <NEWLINE> arrs = [ ss [ 0 ] ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if len ( arrs [ - 1 ] ) == 2 : <NEWLINE> <INDENT> if arrs [ - 1 ] . endswith ( ss [ i ] ) : <NEWLINE> <INDENT> arrs . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arrs . append ( ss [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if arrs [ - 1 ] == ss [ i ] : <NEWLINE> <INDENT> arrs . append ( ss [ i : i + 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arrs . append ( ss [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c = arrs . count ( <STRING> ) <NEWLINE> <NL> if arrs [ - 1 ] == arrs [ - 2 ] : <NEWLINE> <INDENT> ans = len ( arrs ) - 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = len ( arrs ) <NEWLINE> <DEDENT> print ( ans - c ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> import math <NEWLINE> <NL> b = math . factorial ( a ) <NEWLINE> print ( b % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a . sort ( ) <NEWLINE> mi = [ ] <NEWLINE> pl = [ ] <NEWLINE> if n == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> mi . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pl . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if pl == [ ] : <NEWLINE> <INDENT> ans = 1 <NEWLINE> count = 0 <NEWLINE> if k % 2 : <NEWLINE> <INDENT> while count < k : <NEWLINE> <INDENT> ans *= a [ - 1 - count ] <NEWLINE> ans %= mod <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while count < k : <NEWLINE> <INDENT> ans *= a [ count ] <NEWLINE> ans %= mod <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> pl = sorted ( pl , reverse = True ) <NEWLINE> ip = 0 <NEWLINE> im = 0 <NEWLINE> if k % 2 : <NEWLINE> <INDENT> count = pl [ 0 ] <NEWLINE> k -= 1 <NEWLINE> ip += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> while k > 0 : <NEWLINE> <INDENT> check1 = True <NEWLINE> check2 = True <NEWLINE> if ip + 2 <= len ( pl ) : <NEWLINE> <INDENT> x = pl [ ip ] * pl [ ip + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 1 <NEWLINE> check1 = False <NEWLINE> <DEDENT> if im + 2 <= len ( mi ) : <NEWLINE> <INDENT> y = mi [ im ] * mi [ im + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = 1 <NEWLINE> check2 = False <NEWLINE> <DEDENT> if x > y or ( check1 and not check2 ) : <NEWLINE> <INDENT> ip += 2 <NEWLINE> count = ( x * count ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if check2 : <NEWLINE> <INDENT> im += 2 <NEWLINE> count = ( y * count ) % mod <NEWLINE> <DEDENT> <DEDENT> if check1 == False and check2 == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k -= 2 <NEWLINE> <NL> <DEDENT> print ( count % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> MOD = 2 ** 61 - 1 <NEWLINE> root = 10000 <NEWLINE> <NL> rhs = [ 0 ] <NEWLINE> for h in map ( ord , S ) : <NEWLINE> <INDENT> rhs . append ( ( root * rhs [ - 1 ] + h ) % MOD ) <NEWLINE> <NL> <DEDENT> pws = [ 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pws . append ( pws [ - 1 ] * root % MOD ) <NEWLINE> <NL> <DEDENT> ok = 0 <NEWLINE> ng = N <NEWLINE> while ng - ok > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> hashes = dict ( ) <NEWLINE> flg = False <NEWLINE> for i in range ( N - mid + 1 ) : <NEWLINE> <INDENT> hashofsub = ( rhs [ i + mid ] - rhs [ i ] * pws [ mid ] ) % MOD <NEWLINE> if hashofsub in hashes : <NEWLINE> <INDENT> if i >= hashes [ hashofsub ] + mid : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> hashes [ hashofsub ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L = i + A [ i ] <NEWLINE> if L not in dic : <NEWLINE> <INDENT> dic [ L ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ L ] += 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> R = j - A [ j ] <NEWLINE> if R in dic : <NEWLINE> <INDENT> ans += dic [ R ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( 1 , min ( a , b ) + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> t . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( t [ - k ] ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> rgb_tot = r * g * b <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> first = S [ i ] <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if 2 * j - i < N : <NEWLINE> <INDENT> if first != S [ j ] and first != S [ 2 * j - i ] and S [ j ] != S [ 2 * j - i ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> rgb_tot -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rgb_tot ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from math import sqrt <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def prime_factors ( p , prime_box ) : <NEWLINE> <INDENT> while p % 2 == 0 : <NEWLINE> <INDENT> prime_box . append ( 2 ) <NEWLINE> p //= 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( sqrt ( p ) ) + 1 , 2 ) : <NEWLINE> <INDENT> while p % i == 0 : <NEWLINE> <INDENT> prime_box . append ( i ) <NEWLINE> p //= i <NEWLINE> <DEDENT> <DEDENT> if p > 2 : <NEWLINE> <INDENT> prime_box . append ( p ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> return <NEWLINE> <DEDENT> prime_box = [ ] <NEWLINE> prime_factors ( p , prime_box ) <NEWLINE> prime_box = list ( map ( list , Counter ( prime_box ) . items ( ) ) ) <NEWLINE> prime_box = [ [ s , t // n ] for s , t in prime_box ] <NEWLINE> ans = 1 <NEWLINE> for s , t in prime_box : <NEWLINE> <INDENT> ans *= s ** t <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> t = int ( x ) <NEWLINE> x2 = input ( ) <NEWLINE> n = list ( map ( int , x2 . split ( <STRING> ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if 0 in n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> p = 1 <NEWLINE> for v in range ( t ) : <NEWLINE> <INDENT> p *= n [ v ] <NEWLINE> if ( p > 10 ** 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if s . count ( <STRING> ) == n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = s . index ( <STRING> ) <NEWLINE> s = s [ w : ] <NEWLINE> a = s . count ( <STRING> ) <NEWLINE> b = s [ len ( s ) - a : ] . count ( <STRING> ) <NEWLINE> print ( a - b ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> remainder = [ 0 ] * 2019 <NEWLINE> remainder [ 0 ] += 1 <NEWLINE> x = 1 <NEWLINE> rem = 0 <NEWLINE> <NL> for i in range ( 1 , len ( n ) + 1 ) : <NEWLINE> <INDENT> rem = ( rem + int ( n [ - i ] ) * x ) % 2019 <NEWLINE> remainder [ rem ] += 1 <NEWLINE> x *= 10 <NEWLINE> x %= 2019 <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for e in remainder : <NEWLINE> <INDENT> res += e * ( e - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a . append ( l + i - 1 ) <NEWLINE> b . append ( abs ( l + i - 1 ) ) <NEWLINE> <DEDENT> x = b . index ( min ( b ) ) <NEWLINE> print ( sum ( a ) - a [ x ] ) <NEWLINE>
from math import floor <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max_v = 0 <NEWLINE> if n < b : <NEWLINE> <INDENT> max_v = floor ( a * n / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b != 1 : <NEWLINE> <INDENT> for i in range ( b - 1 , n + 1 , b ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> t = floor ( a * i / b ) - a * j <NEWLINE> if t > max_v : <NEWLINE> <INDENT> max_v = t <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_v ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = b - a + 1 <NEWLINE> <NL> if n > k * 2 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( a + i ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( b - ( k - i - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> from itertools import product <NEWLINE> from itertools import combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Bn = [ ] <NEWLINE> Bn . append ( 0 ) <NEWLINE> for i , A in enumerate ( An ) : <NEWLINE> <INDENT> Bn . append ( A + Bn [ i ] ) <NEWLINE> <DEDENT> Cn = collections . Counter ( Bn ) <NEWLINE> ans = 0 <NEWLINE> for c in Cn . values ( ) : <NEWLINE> <INDENT> if c < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
from collections import defaultdict <NEWLINE> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> mod = 1000000007 <NEWLINE> zeroes = 0 <NEWLINE> counter = defaultdict ( lambda : defaultdict ( int ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if x == y == 0 : <NEWLINE> <INDENT> zeroes += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> denominator = math . gcd ( x , y ) <NEWLINE> x , y = x // denominator , y // denominator <NEWLINE> <NL> if y < 0 : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = - x , - y <NEWLINE> <NL> <DEDENT> if x <= 0 : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = y , - x <NEWLINE> counter [ ( x , y ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter [ ( x , y ) ] [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for v in counter . values ( ) : <NEWLINE> <INDENT> now = 1 <NEWLINE> now += pow ( 2 , v [ 0 ] , mod ) - 1 <NEWLINE> now += pow ( 2 , v [ 1 ] , mod ) - 1 <NEWLINE> ans = ans * now % mod <NEWLINE> <DEDENT> ans += zeroes <NEWLINE> ans -= 1 <COMMENT> <NEWLINE> return ans % mod <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans_dict = { } <NEWLINE> for a in a_list : <NEWLINE> <INDENT> if not ( a in ans_dict ) : <NEWLINE> <INDENT> ans_dict [ a ] = 0 <NEWLINE> <DEDENT> ans_dict [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in ans_dict : <NEWLINE> <INDENT> print ( ans_dict [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if X not in p : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> while p [ p . index ( X ) ] + i in p : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> up = p [ p . index ( X ) ] + i <NEWLINE> <NL> i = 1 <NEWLINE> while p [ p . index ( X ) ] - i in p : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> down = p [ p . index ( X ) ] - i <NEWLINE> <NL> if abs ( down - X ) <= abs ( up - X ) : <NEWLINE> <INDENT> print ( down ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( up ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dct = set ( ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <NL> <INDENT> cmd , val = line . strip ( ) . split ( ) <NEWLINE> <NL> if cmd == <STRING> : <NEWLINE> <INDENT> dct . add ( val ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if val in dct : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> s . sort ( ) <NEWLINE> S = sum ( s ) <NEWLINE> ans = 0 <NEWLINE> if S % 10 != 0 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( S - s [ i ] ) % 10 != 0 : <NEWLINE> <INDENT> ans = max ( S - s [ i ] , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> r = c . count ( <STRING> ) <NEWLINE> wr = c [ : r ] . count ( <STRING> ) <NEWLINE> <NL> print ( wr ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 -= 1 <NEWLINE> y1 -= 1 <NEWLINE> x2 -= 1 <NEWLINE> y2 -= 1 <NEWLINE> grid = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> grid . append ( list ( str ( input ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dist [ x1 ] [ y1 ] = 0 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( ( x1 , y1 ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> ( x , y ) = q . popleft ( ) <NEWLINE> if ( x , y ) == ( x2 , y2 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for vx , vy in ( ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> nx = x + vx * k <NEWLINE> ny = y + vy * k <NEWLINE> if nx < 0 or nx >= H or ny < 0 or ny >= W or grid [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ nx ] [ ny ] != - 1 and dist [ nx ] [ ny ] != dist [ x ] [ y ] + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dist [ nx ] [ ny ] == - 1 : <NEWLINE> <INDENT> dist [ nx ] [ ny ] = dist [ x ] [ y ] + 1 <NEWLINE> q . append ( ( nx , ny ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dist [ x2 ] [ y2 ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> def solve ( n , a_list , b_list ) : <NEWLINE> <INDENT> count_a = Counter ( a_list ) <NEWLINE> count_b = Counter ( b_list ) <NEWLINE> count_ab = dict ( ) <NEWLINE> for k in count_a . keys ( ) : <NEWLINE> <INDENT> if k in count_b . keys ( ) : <NEWLINE> <INDENT> if count_a [ k ] + count_b [ k ] > n : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> count_ab [ k ] = min ( count_a [ k ] , count_b [ k ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> a_list_1 = [ ] <NEWLINE> a_list_2 = [ ] <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a != a_list [ i ] : <NEWLINE> <INDENT> if a_list [ i ] in count_ab . keys ( ) : <NEWLINE> <INDENT> c = count_ab [ a_list [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> a = a_list [ i ] <NEWLINE> if c > 0 : <NEWLINE> <INDENT> a_list_1 . append ( a ) <NEWLINE> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_list_2 . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> b_list_1 = [ ] <NEWLINE> b_list_2 = [ ] <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b != b_list [ i ] : <NEWLINE> <INDENT> if b_list [ i ] in count_ab . keys ( ) : <NEWLINE> <INDENT> c = count_ab [ b_list [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> b = b_list [ i ] <NEWLINE> if c > 0 : <NEWLINE> <INDENT> b_list_1 . append ( b ) <NEWLINE> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_list_2 . append ( b ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> k_max = - 1 <NEWLINE> if len ( count_ab . values ( ) ) == 0 : <NEWLINE> <INDENT> return [ <STRING> , <STRING> . join ( [ str ( b ) for b in b_list ] ) ] <NEWLINE> <DEDENT> d = max ( count_ab . values ( ) ) <NEWLINE> for k in count_ab . keys ( ) : <NEWLINE> <INDENT> if count_ab [ k ] == d : <NEWLINE> <INDENT> k_max = k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a_list_moved = a_list_1 + a_list_2 <NEWLINE> b_list_moved = b_list_1 [ d : ] + b_list_1 [ : d ] + b_list_2 <NEWLINE> <NL> <COMMENT> <NL> if d * 2 > len ( a_list_1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if count_a [ k_max ] >= count_b [ k_max ] : <NEWLINE> <COMMENT> <NL> <INDENT> j = len ( a_list_1 ) <NEWLINE> for i in range ( len ( a_list_1 ) ) : <NEWLINE> <INDENT> if a_list_moved [ i ] == b_list_moved [ i ] == k_max : <NEWLINE> <INDENT> while a_list_moved [ j ] == k_max : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> a_list_moved [ i ] , a_list_moved [ j ] = a_list_moved [ j ] , a_list_moved [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> j = len ( a_list_1 ) <NEWLINE> for i in range ( len ( a_list_1 ) ) : <NEWLINE> <INDENT> if a_list_moved [ i ] == b_list_moved [ i ] == k_max : <NEWLINE> <INDENT> while b_list_moved [ j ] == k_max : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> b_list_moved [ i ] , b_list_moved [ j ] = b_list_moved [ j ] , b_list_moved [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res_ab = list ( sorted ( [ ( a , b ) for a , b in zip ( a_list_moved , b_list_moved ) ] , key = lambda x : x [ 0 ] ) ) <NEWLINE> res_b = <STRING> . join ( [ str ( ab [ 1 ] ) for ab in res_ab ] ) <NEWLINE> <COMMENT> <NL> return [ <STRING> , res_b ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = solve ( n , a_list , b_list ) <NEWLINE> for r in res : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def test ( ) : <NEWLINE> <INDENT> assert solve ( 6 , [ 1 , 1 , 1 , 2 , 2 , 3 ] , [ 1 , 1 , 1 , 2 , 2 , 3 ] ) == [ <STRING> , <STRING> ] <NEWLINE> assert solve ( 3 , [ 1 , 1 , 2 ] , [ 1 , 1 , 3 ] ) == [ <STRING> ] <NEWLINE> assert solve ( 4 , [ 1 , 1 , 2 , 3 ] , [ 1 , 2 , 3 , 3 ] ) == [ <STRING> , <STRING> ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
class GCD : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . numlist = dict ( ) <NEWLINE> <DEDENT> def culc ( self , K ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <NL> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ret += self . gcd_ ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> ret += self . gcd ( i , j , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ret += i <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def gcd ( self , a , b , c ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> temp_ = self . gcd_ ( a , b ) <NEWLINE> temp_ = self . gcd_ ( temp_ , c ) <NEWLINE> <NL> return temp_ <NEWLINE> <NL> <DEDENT> def gcd_ ( self , a , b ) : <NEWLINE> <INDENT> l = ( min ( a , b ) , max ( a , b ) ) <NEWLINE> if l in self . numlist : <NEWLINE> <INDENT> return self . numlist [ l ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = max ( a , b ) % min ( a , b ) <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> ret = min ( a , b ) <NEWLINE> self . numlist [ l ] = ret <NEWLINE> return ret <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = self . gcd_ ( min ( a , b ) , mod ) <NEWLINE> self . numlist [ l ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> K = int ( input ( ) ) <NEWLINE> gcd = GCD ( ) <NEWLINE> ret = gcd . culc ( K ) <NEWLINE> print ( ret ) <NEWLINE>
[ X , K , D ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> abx = round ( abs ( X ) ) <NEWLINE> n = round ( abx // D ) <NEWLINE> if n > K : <NEWLINE> <INDENT> ans = abx - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x2 = abx - n * D <NEWLINE> x1 = ( n + 1 ) * D - abx <NEWLINE> if x2 >= x1 : <NEWLINE> <INDENT> if ( K - n - 1 ) % 2 == 0 : <NEWLINE> <INDENT> ans = x1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( K - n ) % 2 == 0 : <NEWLINE> <INDENT> ans = x2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> prize = str ( input ( ) ) <NEWLINE> s . add ( prize ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <DEDENT> s = 1 <NEWLINE> ans = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> from bisect import bisect_left , bisect_right <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> dep = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> def dfs ( s , d , c ) : <NEWLINE> <INDENT> dep [ s ] = d <NEWLINE> x = bisect_left ( c , l [ s ] ) <NEWLINE> c [ x ] , y = l [ s ] , c [ x ] <NEWLINE> ans [ s ] = bisect_left ( c , INF ) <NEWLINE> for i in edge [ s ] : <NEWLINE> <INDENT> if dep [ i ] == - 1 : <NEWLINE> <INDENT> dfs ( i , d + 1 , c ) <NEWLINE> <DEDENT> <DEDENT> c [ x ] = y <NEWLINE> <DEDENT> c = [ INF ] * len ( l ) <NEWLINE> dfs ( 1 , 0 , c ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> ruto = math . ceil ( math . sqrt ( 2 * X ) ) + 1 <NEWLINE> kari = ruto ** 2 + ruto <NEWLINE> ans = 1 <NEWLINE> for i in range ( ruto - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if i ** 2 + i < 2 * X : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> kari = i ** 2 + i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> def f ( x ) : <NEWLINE> <INDENT> result = N // x <NEWLINE> return result <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Y = f ( x ) <NEWLINE> ans += x * Y * ( Y + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 4 + 50 ) <NEWLINE> <NL> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = ( i ** 2 ) + ( j ** 2 ) + ( k ** 2 ) + i * j + j * k + k * i <NEWLINE> if v < 10 ** 4 + 50 : <NEWLINE> <INDENT> cnt [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ( n // ( a + b ) ) * a <NEWLINE> if n % ( a + b ) > a : <NEWLINE> <INDENT> print ( ans + a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans + n % ( a + b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> tmpDic = { } <NEWLINE> res = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] in tmpDic : <NEWLINE> <INDENT> tmpDic [ A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmpDic [ A [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if B in tmpDic and tmpDic [ B ] > 0 : <NEWLINE> <INDENT> tmp = tmpDic [ B ] <NEWLINE> tmpDic [ B ] = 0 <NEWLINE> res += ( C - B ) * tmp <NEWLINE> <NL> if C in tmpDic : <NEWLINE> <INDENT> tmpDic [ C ] += tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmpDic [ C ] = tmp <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if li [ i - 1 ] > li [ i ] : <NEWLINE> <INDENT> ans += li [ i - 1 ] - li [ i ] <NEWLINE> li [ i ] += ( li [ i - 1 ] - li [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ ] for _ in [ 0 ] * 10 ] <NEWLINE> l = [ ] <NEWLINE> for c , g in ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * N ) : <NEWLINE> <INDENT> a [ g - 1 ] . append ( c ) <NEWLINE> <NL> <DEDENT> for i , prices in enumerate ( a ) : <NEWLINE> <INDENT> ln = len ( prices ) <NEWLINE> if ln == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp = [ 0 ] * ( K + 1 ) <NEWLINE> for j , price in enumerate ( prices ) : <NEWLINE> <INDENT> _k = j if j < K - 1 else K - 1 <NEWLINE> for k , prev , cur in zip ( range ( _k , - 1 , - 1 ) , dp [ _k : : - 1 ] , dp [ _k + 1 : : - 1 ] ) : <NEWLINE> <INDENT> if prev + price + k * 2 > cur : <NEWLINE> <INDENT> dp [ k + 1 ] = prev + price + k * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> l . append ( dp [ 1 : ln + 1 ] ) <NEWLINE> <NL> <DEDENT> dp = [ float ( <STRING> ) ] * ( K + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for prices in l : <NEWLINE> <INDENT> cdp = dp [ : ] <NEWLINE> for i , price in enumerate ( prices , start = 1 ) : <NEWLINE> <INDENT> if i > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j , cur , prev in zip ( range ( K , - 1 , - 1 ) , cdp [ : : - 1 ] , dp [ K - i : : - 1 ] ) : <NEWLINE> <INDENT> if 0 < prev + price > cur : <NEWLINE> <INDENT> cdp [ j ] = prev + price <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp = cdp <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> <NL> if S < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> DP = [ 0 ] * ( S + 1 ) <NEWLINE> DP [ 0 ] = 0 <NEWLINE> DP [ 1 ] = 0 <NEWLINE> DP [ 2 ] = 0 <NEWLINE> <NL> for i in range ( 3 , S + 1 ) : <NEWLINE> <INDENT> DP [ i ] += 1 <NEWLINE> for j in range ( i - 3 + 1 ) : <NEWLINE> <INDENT> DP [ i ] += DP [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( DP [ S ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 for _ in range ( N ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( B [ j ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] ; b = [ ] ; <NEWLINE> for i in range ( n ) : a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( m ) : b . append ( int ( input ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> d = { ( i - 97 + 1 ) : chr ( i ) for i in range ( 97 , 97 + 26 ) } <NEWLINE> d [ 0 ] = <STRING> <NEWLINE> <NL> l = [ ] <NEWLINE> <NL> while n > 0 : <NEWLINE> <INDENT> tmp = n % 26 <NEWLINE> l . append ( tmp ) <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> n = n // 26 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n //= 26 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> <NL> for i in l [ : : - 1 ] : <NEWLINE> <INDENT> ans += d [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> B = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] > ( k - A [ i ] ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> aa = np . array ( input ( ) . split ( ) , dtype = <STRING> ) <NEWLINE> ma = np . max ( aa ) <NEWLINE> <COMMENT> <NL> cnt = [ 0 ] * ( ma + 1 ) <NEWLINE> <NL> for a in aa : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <NL> <DEDENT> if np . gcd . reduce ( aa ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif np . all ( [ sum ( cnt [ i : : i ] ) <= 1 for i in range ( 2 , ma ) ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> tmp1 = [ set ( ) for i in range ( 26 ) ] <NEWLINE> tmp2 = [ set ( ) for i in range ( 26 ) ] <NEWLINE> alpha2num = lambda c : ord ( c ) - ord ( <STRING> ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> tmp1 [ alpha2num ( S [ i ] ) ] . add ( T [ i ] ) <NEWLINE> tmp2 [ alpha2num ( T [ i ] ) ] . add ( S [ i ] ) <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if len ( tmp1 [ i ] ) > 1 or len ( tmp2 [ i ] ) > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] - 1 ) <NEWLINE> a . append ( a [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> cc = collections . Counter ( a ) <NEWLINE> ans = max ( list ( cc . values ( ) ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> dp = [ True ] * a [ - 1 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i , num in enumerate ( a ) : <NEWLINE> <INDENT> if dp [ num - 1 ] : <NEWLINE> <INDENT> j = 2 * num <NEWLINE> while j <= a [ - 1 ] : <NEWLINE> <INDENT> dp [ j - 1 ] = False <NEWLINE> j += num <NEWLINE> <DEDENT> if not i + 1 == len ( a ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> dp [ num - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k in a : <NEWLINE> <INDENT> if dp [ k - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> p = int ( K * ( K + 1 ) / 2 ) <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <INDENT> g = math . gcd ( a + 1 , b + 1 ) <NEWLINE> p += 6 * g <NEWLINE> for c in range ( b + 1 , K ) : <NEWLINE> <INDENT> p += 6 * math . gcd ( g , c + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
import sys <NEWLINE> from decimal import Decimal <NEWLINE> <NL> num_list = input ( ) . split ( ) <NEWLINE> ans = Decimal ( num_list [ 0 ] ) * Decimal ( num_list [ 1 ] ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def I2 ( ) : return map ( int , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> def S ( ) : return str ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def L ( ) : return list ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def Intl ( ) : return [ int ( k ) for k in sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ] <NEWLINE> def Lx ( k ) : return list ( map ( lambda x : int ( x ) * - k , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = I2 ( ) <NEWLINE> h = Intl ( ) <NEWLINE> l = [ [ ] for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = I2 ( ) <NEWLINE> l [ a - 1 ] . append ( b ) <NEWLINE> l [ b - 1 ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if len ( l [ i ] ) == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> for j in l [ i ] : <NEWLINE> <INDENT> if h [ i ] > h [ j - 1 ] : <NEWLINE> <INDENT> f = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . reverse ( ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> nxt = X <NEWLINE> lst = [ ] <NEWLINE> dic = { } <NEWLINE> <NL> for i in range ( M + 1 ) : <NEWLINE> <INDENT> if nxt in dic : <NEWLINE> <INDENT> loop_st = dic [ nxt ] <NEWLINE> loop_ed = i - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> lst . append ( nxt ) <NEWLINE> dic [ nxt ] = i <NEWLINE> <NL> nxt = ( nxt ** 2 ) % M <NEWLINE> <NL> <NL> <DEDENT> v = N - loop_st <NEWLINE> q , r = divmod ( v , loop_ed - loop_st + 1 ) <NEWLINE> <NL> pre_sum = sum ( lst [ : loop_st ] ) <NEWLINE> loop_sum = q * sum ( lst [ loop_st : ] ) <NEWLINE> post_sum = sum ( lst [ loop_st : loop_st + r ] ) <NEWLINE> print ( pre_sum + loop_sum + post_sum ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> ans = 0 <NEWLINE> if X - D * K > 0 : <NEWLINE> <INDENT> ans = X - D * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = X // D <NEWLINE> K -= count <NEWLINE> X -= count * D <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> X = abs ( X - D ) <NEWLINE> <DEDENT> ans = X <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> l = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = lcm ( l , a [ i ] ) <NEWLINE> <DEDENT> l %= mod <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inv = pow ( a [ i ] , mod - 2 , mod ) <NEWLINE> ans += ( l * inv ) % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
dish = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> a = [ i % 10 for i in dish ] <NEWLINE> <NL> x = 10 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> x = min ( x , i ) <NEWLINE> <DEDENT> <DEDENT> if x == 10 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> y = a . index ( x ) <NEWLINE> l = dish . pop ( y ) <NEWLINE> <NL> time = [ ( i // 10 + 1 ) * 10 if i % 10 != 0 else i for i in dish ] <NEWLINE> <NL> ans = sum ( time ) + l <NEWLINE> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> judge = { } <NEWLINE> j = 0 <COMMENT> <NEWLINE> while A [ j ] not in judge . keys ( ) or judge [ A [ j ] ] != 2 : <NEWLINE> <INDENT> ans . append ( A [ j ] ) <NEWLINE> if A [ j ] not in judge . keys ( ) : <NEWLINE> <INDENT> judge [ A [ j ] ] = 0 <NEWLINE> <DEDENT> judge [ A [ j ] ] += 1 <NEWLINE> j = A [ j ] - 1 <NEWLINE> <NL> <DEDENT> st = ans . index ( A [ j ] ) <NEWLINE> <NL> if st < K : <NEWLINE> <INDENT> ans = ans [ st : ] <NEWLINE> K -= st <NEWLINE> l = len ( ans ) <NEWLINE> <COMMENT> <NL> print ( ans [ K % l - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ K - 1 ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for i in range ( N + 1 ) ] <NEWLINE> true = [ True for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> true [ a ] = False <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans [ 0 ] = 1 <NEWLINE> ans [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i - 2 , i ) : <NEWLINE> <INDENT> if true [ j ] : <NEWLINE> <INDENT> ans [ i ] += ans [ j ] % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ N ] % mod ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( y - 2 * x ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( y - 2 * x ) // 2 <NEWLINE> t = x - k <NEWLINE> <NL> if 0 <= k and 0 <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a . append ( 1 ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> <DEDENT> <DEDENT> cnt = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> ans *= cnt [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n : <NEWLINE> <INDENT> if a [ i ] != a [ j ] and a [ i ] != a [ k ] and a [ k ] != a [ j ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= 1 <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import bisect <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> b = a [ : i ] <NEWLINE> c = a [ i + 1 : ] <NEWLINE> <COMMENT> <NL> for j in b : <NEWLINE> <INDENT> ans += bisect . bisect ( c , a [ i ] + j - 0.1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> def gcd ( p , q ) : <COMMENT> <NEWLINE> <INDENT> if q % p == 0 : <NEWLINE> <INDENT> return p <NEWLINE> <DEDENT> return gcd ( q % p , p ) <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> gcd1 = gcd ( a , b ) <NEWLINE> gcd2 = gcd ( gcd1 , c ) <NEWLINE> if a == b and b == c : <NEWLINE> <INDENT> ans += gcd2 <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> ans += 3 * gcd2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * gcd2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> <NL> <NL> def link ( x , y ) : <NEWLINE> <INDENT> if rank [ x ] > rank [ y ] : <NEWLINE> <INDENT> p [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ x ] = y <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ y ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def find_set ( x ) : <NEWLINE> <INDENT> if x != p [ x ] : <NEWLINE> <INDENT> p [ x ] = find_set ( p [ x ] ) <NEWLINE> <DEDENT> return p [ x ] <NEWLINE> <NL> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> link ( find_set ( x ) , find_set ( y ) ) <NEWLINE> <NL> <NL> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> x = find_set ( x ) <NEWLINE> y = find_set ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> h = [ ] <NEWLINE> <NL> line = sys . stdin . readline ( ) <NEWLINE> v , e = map ( int , line . split ( ) ) <NEWLINE> p = [ i for i in range ( v ) ] <NEWLINE> rank = [ 0 for _ in range ( v ) ] <NEWLINE> <NL> for i in range ( e ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> s , t , w = map ( int , line . split ( ) ) <NEWLINE> heapq . heappush ( h , ( w , s , t ) ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in range ( e ) : <NEWLINE> <INDENT> elm = heapq . heappop ( h ) <NEWLINE> if not same ( elm [ 1 ] , elm [ 2 ] ) : <NEWLINE> <INDENT> s = s + elm [ 0 ] <NEWLINE> unite ( elm [ 1 ] , elm [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL>
R = range <NEWLINE> M = 998244353 <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> f = 1 <NEWLINE> for i in R ( n - 1 ) : f = f * - ~ i % M <NEWLINE> r = [ pow ( f * n , - 1 , M ) ] <NEWLINE> for i in R ( n ) : r += r [ i ] * ( n - i ) % M , <NEWLINE> print ( sum ( m * f * r [ i - n ] * r [ ~ i ] * pow ( m - 1 , ~ i + n , M ) for i in R ( k + 1 ) ) % M ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> j = 3 <NEWLINE> while j <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % j == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> j += 2 <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return x * y // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm ( target_list ) : <NEWLINE> <INDENT> return reduce ( lcm_base , target_list ) <NEWLINE> <NL> <DEDENT> A_gcd = reduce ( math . gcd , A ) <NEWLINE> flg = True <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a // A_gcd % 2 == 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> min_x = int ( lcm ( A ) ) // 2 <NEWLINE> ans = m // min_x - m // ( 2 * min_x ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from copy import copy <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> s = input ( ) <NEWLINE> count = [ 0 for _ in range ( 13 ) ] <NEWLINE> count [ 0 ] = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> new = [ 0 for _ in range ( 13 ) ] <NEWLINE> for m in range ( 13 ) : <NEWLINE> <INDENT> new [ ( m * 10 ) % 13 ] = count [ m ] <NEWLINE> <DEDENT> count = new <NEWLINE> if s [ i ] != <STRING> : <NEWLINE> <INDENT> div = int ( s [ i ] ) <NEWLINE> count = count [ - div : ] + count [ : - div ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new = [ 0 for _ in range ( 13 ) ] <NEWLINE> pre = sum ( count [ : 3 ] ) <NEWLINE> SUM = sum ( count ) % MOD <NEWLINE> for j in range ( 13 ) : <NEWLINE> <INDENT> pre += count [ ( j + 3 ) % 13 ] <NEWLINE> pre -= count [ j % 13 ] <NEWLINE> new [ j ] = ( SUM - pre ) % MOD <NEWLINE> <DEDENT> count = new <NEWLINE> <DEDENT> <DEDENT> print ( count [ 5 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans != - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> l = a [ left : mid ] + [ float ( <STRING> ) ] <NEWLINE> r = a [ mid : right ] + [ float ( <STRING> ) ] <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if l [ i ] <= r [ j ] : <NEWLINE> <INDENT> a [ k ] = l [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = r [ j ] <NEWLINE> j += 1 <NEWLINE> count += len ( l ) - i - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( a , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = right + ( left - right ) // 2 <NEWLINE> mergeSort ( a , left , mid ) <NEWLINE> mergeSort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> mergeSort ( s , 0 , n ) <NEWLINE> <NL> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for c in <STRING> : <NEWLINE> <INDENT> ans *= s . count ( c ) <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = ( j - i ) + j <NEWLINE> if k >= N : continue <NEWLINE> if s [ i ] == s [ j ] or s [ j ] == s [ k ] or s [ k ] == s [ i ] : continue <NEWLINE> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> ans += int ( n [ i ] ) <NEWLINE> <DEDENT> if ( ans % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <COMMENT> <NEWLINE> <INDENT> old = A [ i ] <COMMENT> <NEWLINE> new = A [ i + k ] <NEWLINE> <NL> if old < new : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from dataclasses import dataclass <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> @ dataclass <NEWLINE> class Query : <NEWLINE> <INDENT> now : int <NEWLINE> prev : int <NEWLINE> cost : int <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for e in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ a ] . append ( b ) <NEWLINE> E [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> res = [ - 1 for _ in range ( N + 1 ) ] <NEWLINE> cost = [ float ( <STRING> ) for _ in range ( N + 1 ) ] <NEWLINE> cost [ 1 ] = 0 <NEWLINE> <NL> queue = deque ( ) <NEWLINE> <NL> for next in E [ 1 ] : <NEWLINE> <INDENT> queue . append ( Query ( next , 1 , 1 ) ) <NEWLINE> <NL> <DEDENT> while len ( queue ) : <NEWLINE> <INDENT> q = queue . popleft ( ) <NEWLINE> if cost [ q . now ] > q . cost : <NEWLINE> <INDENT> res [ q . now ] = q . prev <NEWLINE> cost [ q . now ] = q . cost <NEWLINE> <NL> for next in E [ q . now ] : <NEWLINE> <INDENT> if cost [ next ] > q . cost + 1 : <NEWLINE> <INDENT> queue . append ( Query ( next , q . now , q . cost + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for r in res [ 2 : ] : <NEWLINE> <INDENT> if r == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for r in res [ 2 : ] : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import types <NEWLINE> <NL> _atcoder_code = <STRING> <NEWLINE> <NL> atcoder = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder_code , atcoder . __dict__ ) <NEWLINE> <NL> _atcoder_dsu_code = <STRING> <NEWLINE> <NL> atcoder . dsu = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder_dsu_code , atcoder . dsu . __dict__ ) <NEWLINE> DSU = atcoder . dsu . DSU <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> g = DSU ( N ) <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> g . merge ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> grp = g . groups ( ) <NEWLINE> <NL> if grp == None : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( grp ) - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = [ int ( item ) for item in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> if ( line == [ 0 , 0 ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data . append ( line ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return inputError ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> left = 1 <NEWLINE> numbers = 3 <NEWLINE> [ print ( len ( sumcombination ( left , line [ 0 ] , numbers , line [ 1 ] ) ) ) for line in data ] <NEWLINE> <NL> <DEDENT> def sumcombination ( left , right , numbers , total ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = [ ] <NEWLINE> if ( numbers == 1 ) : <NEWLINE> <INDENT> if ( ( left <= total ) and ( right >= total ) ) : <NEWLINE> <INDENT> result = [ total ] <NEWLINE> <DEDENT> return ( result ) <NEWLINE> <NL> <DEDENT> for i in range ( left , right + 1 ) : <NEWLINE> <INDENT> if ( numbers == 2 ) : <NEWLINE> <INDENT> if ( i >= total - i ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( ( i != total - i ) and ( left <= total - i ) and ( right >= total - i ) ) : <NEWLINE> <INDENT> result . append ( [ i , total - i ] ) <NEWLINE> <DEDENT> <DEDENT> elif ( ( len ( range ( i , right + 1 ) ) < numbers ) or ( sum ( range ( i + 1 , i + numbers ) ) > total - i ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( sum ( range ( right - numbers + 2 , right + 1 ) ) < total - i ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sub = sumcombination ( i + 1 , right , numbers - 1 , total - i ) <NEWLINE> if ( len ( sub ) > 0 ) : <NEWLINE> <INDENT> [ items . insert ( 0 , i ) for items in sub ] <NEWLINE> result . extend ( sub ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ( result ) <NEWLINE> <NL> <DEDENT> def inputError ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> func ( ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> def dfs ( L ) : <NEWLINE> <INDENT> global ans <NEWLINE> if len ( L ) == N + 1 : <NEWLINE> <INDENT> sumnum = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if L [ b [ i ] ] - L [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> sumnum += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , sumnum ) <NEWLINE> return 0 <NEWLINE> <DEDENT> A = L . copy ( ) <NEWLINE> A . append ( A [ - 1 ] ) <NEWLINE> while A [ - 1 ] <= M : <NEWLINE> <INDENT> dfs ( A ) <NEWLINE> A [ - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( [ 1 ] ) <NEWLINE> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> points = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if points == [ - 1 , - 1 , - 1 ] : break <NEWLINE> sum_pt = sum ( points [ 0 : 2 ] ) <NEWLINE> if points [ 0 ] == - 1 or points [ 1 ] == - 1 or sum_pt < 30 : print ( <STRING> ) <NEWLINE> elif sum_pt < 50 and points [ 2 ] < 50 : print ( <STRING> ) <NEWLINE> elif sum_pt < 65 : print ( <STRING> ) <NEWLINE> elif sum_pt < 80 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> <NL> for i , j in enumerate ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> plus . append ( i + j ) <NEWLINE> minus . append ( i - j ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> plus_count = Counter ( plus ) <NEWLINE> minus_count = Counter ( minus ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> for i , j in plus_count . items ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i in minus_count : <NEWLINE> <INDENT> ans += j * minus_count [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> <NL> def cnt ( a , m , i ) : <NEWLINE> <INDENT> if a [ i ] < m : <NEWLINE> <INDENT> a [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = cnt ( a , m , i - 1 ) <NEWLINE> a [ i ] = copy . deepcopy ( a [ i - 1 ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def check ( a , ab ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ai , bi = ab [ i ] [ 0 ] , ab [ i ] [ 1 ] <NEWLINE> if a [ bi ] - a [ ai ] == ab [ i ] [ 2 ] : <NEWLINE> <INDENT> score += ab [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> a = [ 1 ] * ( n + 1 ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> ans = 0 <NEWLINE> while a [ 0 ] == 0 : <NEWLINE> <INDENT> x = check ( a , ab ) <NEWLINE> ans = max ( ans , x ) <NEWLINE> <COMMENT> <NL> a = cnt ( a , m , - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
m = 2019 <NEWLINE> l = [ 0 ] * m <NEWLINE> l [ 0 ] = 1 <NEWLINE> s , k = 0 , 1 <NEWLINE> for c in reversed ( input ( ) ) : k = k * 10 % m ; s = ( s + int ( c ) * k ) % m ; l [ s ] += 1 <NEWLINE> print ( sum ( v * ( v - 1 ) // 2 for v in l ) ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> import scipy as sp <NEWLINE> import queue <NEWLINE> import collections <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> <NL> def main ( kwargs ) : <NEWLINE> <INDENT> n = kwargs [ <STRING> ] <NEWLINE> A = kwargs [ <STRING> ] <NEWLINE> res = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> res *= A [ i ] <NEWLINE> <NL> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> <NL> if min ( A ) == 0 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <NL> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> kwargs = { } <NEWLINE> <NL> cin = input ( ) . split ( ) <NEWLINE> kwargs [ <STRING> ] = [ int ( i ) for i in cin ] [ 0 ] <NEWLINE> <NL> cin = input ( ) . split ( ) <NEWLINE> kwargs [ <STRING> ] = [ int ( i ) for i in cin ] <NEWLINE> <NL> cout = main ( kwargs ) <NEWLINE> print ( cout ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , numpy , string , scipy <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> P = LI ( ) <NEWLINE> Pe = [ ( v + 1 ) / 2 for v in P ] <NEWLINE> P_ms = numpy . cumsum ( Pe ) <NEWLINE> if K == N : print ( <STRING> . format ( sum ( Pe ) ) ) ; exit ( 0 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> ans = max ( ans , P_ms [ i ] - P_ms [ i - K ] ) <NEWLINE> <DEDENT> print ( <STRING> . format ( ans ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> value = [ ] <NEWLINE> weight = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> val , wei = map ( int , input ( ) . split ( ) ) <NEWLINE> value . append ( val ) <NEWLINE> weight . append ( wei ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dp = [ ] <NEWLINE> for i in range ( 110 ) : <NEWLINE> <INDENT> o = [ 0 for i in range ( 10010 ) ] <NEWLINE> dp . append ( o ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for ww in range ( w ) : <NEWLINE> <INDENT> dp [ 0 ] [ ww ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for ww in range ( w + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ww >= weight [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ ww ] = max ( dp [ i ] [ ww - weight [ i ] ] + value [ i ] , dp [ i ] [ ww ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ ww ] = dp [ i ] [ ww ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] [ w ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> cnt_r = s . count ( <STRING> ) <NEWLINE> cnt_g = s . count ( <STRING> ) <NEWLINE> cnt_b = s . count ( <STRING> ) <NEWLINE> <NL> ans = cnt_r * cnt_g * cnt_b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if X >= 0 : <NEWLINE> <INDENT> if K < int ( X / D ) : <NEWLINE> <INDENT> print ( abs ( X - K * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( X - ( int ( X / D ) + 1 ) * D ) < abs ( X - int ( X / D ) * D ) : <NEWLINE> <INDENT> A = X - ( int ( X / D ) + 1 ) * D <NEWLINE> if ( K - ( int ( X / D ) + 1 ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( A + D ) < abs ( A - D ) : <NEWLINE> <INDENT> print ( abs ( A + D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( A - D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A = X - ( int ( X / D ) ) * D <NEWLINE> if ( K - ( int ( X / D ) ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( A + D ) < abs ( A - D ) : <NEWLINE> <INDENT> print ( abs ( A + D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( A - D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K < int ( abs ( X ) / D ) : <NEWLINE> <INDENT> print ( abs ( X + K * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( X + ( int ( abs ( X ) / D ) + 1 ) * D ) < abs ( X + int ( abs ( X ) / D ) * D ) : <NEWLINE> <INDENT> A = X + ( int ( abs ( X ) / D ) + 1 ) * D <NEWLINE> if ( K - ( int ( abs ( X ) / D ) + 1 ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( A + D ) < abs ( A - D ) : <NEWLINE> <INDENT> print ( abs ( A + D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( A - D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A = X + ( int ( abs ( X ) / D ) ) * D <NEWLINE> if ( K - ( int ( abs ( X ) / D ) ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( A + D ) < abs ( A - D ) : <NEWLINE> <INDENT> print ( abs ( A + D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( A - D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n = sys . stdin . readline ( ) <NEWLINE> l = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> tmp = 1000000000000000000 <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if 1000000000000000000 < ans : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans <= 1000000000000000000 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
def popcount ( u ) : <NEWLINE> <INDENT> t = bin ( u ) <NEWLINE> h = t . count ( <STRING> ) <NEWLINE> return u % h <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = list ( input ( ) ) <NEWLINE> c = x . count ( <STRING> ) + 1 <NEWLINE> d = c - 2 <NEWLINE> <NL> amaric = [ 1 % c ] <NEWLINE> if d >= 1 : <NEWLINE> <INDENT> amarid = [ 1 % d ] <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> amaric . append ( ( amaric [ - 1 ] * 2 ) % c ) <NEWLINE> if d >= 1 : <NEWLINE> <INDENT> amarid . append ( ( amarid [ - 1 ] * 2 ) % d ) <NEWLINE> <NL> <DEDENT> <DEDENT> motoc = 0 <NEWLINE> motod = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> motoc += amaric [ n - 1 - i ] <NEWLINE> if d >= 1 : <NEWLINE> <INDENT> motod += amarid [ n - 1 - i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> op = motoc <NEWLINE> op += amaric [ n - 1 - i ] <NEWLINE> op %= c <NEWLINE> <DEDENT> elif x [ i ] == <STRING> : <NEWLINE> <INDENT> if d >= 1 : <NEWLINE> <INDENT> op = motod <NEWLINE> op -= amarid [ n - 1 - i ] <NEWLINE> op %= d <NEWLINE> <DEDENT> elif d == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> cou = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if op == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> op = popcount ( op ) <NEWLINE> cou += 1 <NEWLINE> <DEDENT> print ( cou ) <NEWLINE> <DEDENT>
import math <NEWLINE> pi = math . pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> S = r ** 2 * pi <NEWLINE> syu = 2 * pi * r <NEWLINE> <NL> print ( str ( <STRING> . format ( S ) ) + <STRING> + str ( <STRING> . format ( syu ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> A_cnt = [ 0 ] * 100001 <NEWLINE> A_sum = 0 <NEWLINE> <NL> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> A_cnt [ a ] += 1 <NEWLINE> <COMMENT> <NL> A_sum += a <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> A_cnt [ C ] = A_cnt [ C ] + A_cnt [ B ] <NEWLINE> A_sum = A_sum + ( ( C - B ) * A_cnt [ B ] ) <NEWLINE> A_cnt [ B ] = 0 <NEWLINE> print ( A_sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> t = s [ k - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != t : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( * s , sep = <STRING> ) <NEWLINE>
import copy <NEWLINE> <NL> ( h , w , n ) = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dis = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> <NL> def setArr ( ph ) : <NEWLINE> <INDENT> global dis <NEWLINE> res = [ False for i in range ( w + 2 ) ] <NEWLINE> for i , x in enumerate ( list ( input ( ) ) ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> res [ i + 1 ] = True <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> dis [ 0 ] = [ ph , i + 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> dis [ int ( x ) ] = [ ph , i + 1 ] <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> arr = [ [ ] for i in range ( h + 2 ) ] <NEWLINE> arr [ 0 ] = [ False for i in range ( w + 2 ) ] <NEWLINE> arr [ - 1 ] = [ False for i in range ( w + 2 ) ] <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> arr [ i ] = setArr ( i ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> move = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> <NL> def ze ( start , goal ) : <NEWLINE> <INDENT> arra = copy . deepcopy ( arr ) <NEWLINE> global res <NEWLINE> queue = [ start , [ - 1 , - 1 ] ] <NEWLINE> ap = queue . append <NEWLINE> zu = False <NEWLINE> for q in queue : <NEWLINE> <INDENT> if q [ 0 ] < 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> ap ( [ - 1 , - 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> if not arra [ q [ 0 ] ] [ q [ 1 ] ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for m in move : <NEWLINE> <INDENT> de = [ q [ 0 ] + m [ 0 ] , q [ 1 ] + m [ 1 ] ] <NEWLINE> <NL> if de == goal : <NEWLINE> <INDENT> res += 1 <NEWLINE> zu = True <NEWLINE> break <NEWLINE> <DEDENT> if arra [ de [ 0 ] ] [ de [ 1 ] ] : <NEWLINE> <INDENT> ap ( de ) <NEWLINE> <DEDENT> <DEDENT> if zu : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> arra [ q [ 0 ] ] [ q [ 1 ] ] = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ze ( dis [ i ] , dis [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans += int ( N [ i ] ) <NEWLINE> <NL> <DEDENT> ans = ans % 9 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V - W <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( abs ( B - A ) / ( V - W ) ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def check ( pair , m , x ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> for e in pair : <NEWLINE> <INDENT> p += e [ i ] <NEWLINE> <DEDENT> if ( p < x ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for e in pair : <NEWLINE> <INDENT> sum += e [ 0 ] <NEWLINE> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> n , m , x = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( tuple ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) <NEWLINE> <NL> <DEDENT> min = - 1 <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> pair = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> pair . append ( a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> sum = check ( pair , m , x ) <NEWLINE> <NL> if min == - 1 : <NEWLINE> <INDENT> min = sum <NEWLINE> <DEDENT> elif sum != - 1 and min > sum : <NEWLINE> <INDENT> min = sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ) <NEWLINE>
box = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> box [ temp [ 0 ] - 1 ] [ temp [ 1 ] - 1 ] [ temp [ 2 ] - 1 ] += temp [ 3 ] <NEWLINE> if box [ temp [ 0 ] - 1 ] [ temp [ 1 ] - 1 ] [ temp [ 2 ] - 1 ] < 0 : box [ temp [ 0 ] - 1 ] [ temp [ 1 ] - 1 ] [ temp [ 2 ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( len ( box ) ) : <NEWLINE> <INDENT> [ print ( <STRING> + <STRING> . join ( map ( str , box [ i ] [ j ] ) ) ) for j in range ( len ( box [ i ] ) ) ] <NEWLINE> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 for i in range ( a ) ] <NEWLINE> for i in b : <NEWLINE> <INDENT> c [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in c : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
nk = input ( <STRING> ) <NEWLINE> n = int ( nk . split ( ) [ 0 ] ) <NEWLINE> k = int ( nk . split ( ) [ 1 ] ) <NEWLINE> alist = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> <NL> loop_start = 0 <NEWLINE> loop_end = 0 <NEWLINE> root = [ 1 ] <NEWLINE> next_val = 1 <NEWLINE> flag = [ True ] * n <NEWLINE> flag [ 0 ] = False <COMMENT> <NEWLINE> a = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = alist [ a - 1 ] <NEWLINE> if flag [ a - 1 ] : <COMMENT> <NEWLINE> <INDENT> root . append ( a ) <NEWLINE> flag [ a - 1 ] = False <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> loop_start = root . index ( a ) <NEWLINE> loop_end = len ( root ) <NEWLINE> step = ( k - loop_start ) % ( len ( root ) - loop_start ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( root [ loop_start + step ] ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> que = deque ( ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> op = line . rstrip ( ) . split ( <STRING> ) <NEWLINE> if <STRING> == op [ 0 ] : <NEWLINE> <INDENT> que . appendleft ( op [ 1 ] ) <NEWLINE> <DEDENT> elif <STRING> == op [ 0 ] : <NEWLINE> <INDENT> if op [ 1 ] in que : <NEWLINE> <INDENT> que . remove ( op [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif <STRING> == op [ 0 ] : <NEWLINE> <INDENT> que . popleft ( ) <NEWLINE> <DEDENT> elif <STRING> == op [ 0 ] : <NEWLINE> <INDENT> que . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( que ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def ST ( ) : <NEWLINE> <INDENT> return input ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def MI ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def LI ( ) : <NEWLINE> <INDENT> return list ( MI ( ) ) <NEWLINE> <NL> <NL> <DEDENT> S = ST ( ) <NEWLINE> Q = I ( ) <NEWLINE> <NL> switch = True <NEWLINE> prefix = <STRING> <NEWLINE> suffix = <STRING> <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> query = list ( input ( ) . split ( ) ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> if switch : <NEWLINE> <INDENT> switch = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> switch = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if switch : <NEWLINE> <INDENT> if query [ 1 ] == <STRING> : <NEWLINE> <INDENT> prefix = query [ 2 ] + prefix <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suffix = suffix + query [ 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if query [ 1 ] == <STRING> : <NEWLINE> <INDENT> suffix = suffix + query [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prefix = query [ 2 ] + prefix <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = prefix + S + suffix <NEWLINE> if switch : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> m = n [ 0 ] + n [ 1 ] + n [ 2 ] <NEWLINE> print ( m ) <NEWLINE>
n , m , l = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . extend ( [ list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) ] ) <NEWLINE> <DEDENT> B = list ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> B . extend ( [ list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) ] ) <NEWLINE> <DEDENT> C = list ( [ [ 0 for l_ in range ( l ) ] for n_ in range ( n ) ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in C : <NEWLINE> <INDENT> print ( <STRING> % a [ 0 ] , end = <STRING> ) <NEWLINE> for b in a [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> % b , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> sss = [ input ( ) for _ in range ( n ) ] <NEWLINE> d = { s [ 1 : ] : 0 for s in sss } <NEWLINE> flags = [ 1 << ( i * 18 ) for i in range ( 26 ) ] <NEWLINE> <NL> trie_chr = [ - 1 ] <NEWLINE> trie_children = [ { } ] <NEWLINE> trie_counter = [ 0 ] <NEWLINE> trie_fin = [ 0 ] <NEWLINE> s_fin_node = [ ] <NEWLINE> l = 1 <NEWLINE> <NL> for s in sss : <NEWLINE> <INDENT> node = 0 <NEWLINE> trie_counter [ node ] += 1 <NEWLINE> for i in range ( len ( s ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> c = ord ( s [ i ] ) - 97 <NEWLINE> if c in trie_children [ node ] : <NEWLINE> <INDENT> node = trie_children [ node ] [ c ] <NEWLINE> trie_counter [ node ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trie_chr . append ( c ) <NEWLINE> trie_children . append ( { } ) <NEWLINE> trie_fin . append ( 0 ) <NEWLINE> trie_children [ node ] [ c ] = l <NEWLINE> trie_counter . append ( 1 ) <NEWLINE> node = l <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> trie_fin [ node ] += 1 <NEWLINE> s_fin_node . append ( node ) <NEWLINE> <NL> <DEDENT> trie_flags = [ 0 ] * l <NEWLINE> <NL> for s in sss : <NEWLINE> <INDENT> cnt = Counter ( s ) <NEWLINE> flag = 0 <NEWLINE> for c in cnt : <NEWLINE> <INDENT> flag |= flags [ ord ( c ) - 97 ] <NEWLINE> <DEDENT> node = 0 <NEWLINE> if len ( s ) > 1 and trie_fin [ node ] > 0 : <NEWLINE> <INDENT> trie_flags [ node ] += flag <NEWLINE> <NL> <DEDENT> for i in range ( len ( s ) - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> c = s [ i ] <NEWLINE> k = ord ( c ) - 97 <NEWLINE> cnt [ c ] -= 1 <NEWLINE> if cnt [ c ] == 0 : <NEWLINE> <INDENT> flag ^= flags [ k ] <NEWLINE> <NL> <DEDENT> node = trie_children [ node ] [ k ] <NEWLINE> <COMMENT> <NL> if trie_counter [ node ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if trie_fin [ node ] > 0 : <NEWLINE> <INDENT> trie_flags [ node ] += flag <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> mask = ( 1 << 18 ) - 1 <NEWLINE> for i , s in enumerate ( sss ) : <NEWLINE> <INDENT> cnt = ( trie_flags [ s_fin_node [ i ] ] >> ( ( ord ( s [ 0 ] ) - 97 ) * 18 ) ) & mask <NEWLINE> ans += cnt <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ 0 ] * 10 ** 6 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> li [ A [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> li . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> print ( sum ( li [ K : ] ) ) <NEWLINE>
a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> i = min ( b - 1 , n ) <NEWLINE> print ( ( i * a ) // b - a * ( i // b ) ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> div_flg = False <NEWLINE> inc_flg = False <NEWLINE> dec_flg = False <NEWLINE> ans = 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if inc_flg : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ i ] <= A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inc_flg = False <NEWLINE> div_flg = False <NEWLINE> <DEDENT> <DEDENT> elif dec_flg : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dec_flg = False <NEWLINE> div_flg = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> div_flg = True <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> if not div_flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> if not div_flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> div_flg = True <NEWLINE> continue <NEWLINE> <DEDENT> elif A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> if not div_flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> inc_flg = True <NEWLINE> continue <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> if not div_flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> dec_flg = True <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def solve ( a ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> ans = solve ( a ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> max_a = int ( ( N - 1 ) / A ) <NEWLINE> <COMMENT> <NL> count += max_a <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> <NL> start = - 200 <NEWLINE> end = 201 <NEWLINE> <NL> for i in range ( start , end ) : <NEWLINE> <INDENT> for j in range ( start , end ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> A , B = i , j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ab = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans . append ( ab ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> l = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l += ans [ i ] [ 1 ] <NEWLINE> if l >= K : <NEWLINE> <INDENT> s = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans [ s ] [ 0 ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> <NL> nList = [ ] <NEWLINE> labelList = [ ] <NEWLINE> color = [ ] <NEWLINE> Q = deque ( [ ] ) <NEWLINE> <NL> def readinput ( ) : <NEWLINE> <INDENT> global nList <NEWLINE> global color <NEWLINE> global Q <NEWLINE> global labelList <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nList = [ ] <NEWLINE> for _ in range ( n + 1 ) : <NEWLINE> <INDENT> nList . append ( [ ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nList [ a ] . append ( b ) <NEWLINE> nList [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> labelList = [ 0 ] * ( n + 1 ) <NEWLINE> color = [ WHITE ] * ( n + 1 ) <NEWLINE> Q = deque ( [ ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def bfs ( p ) : <NEWLINE> <INDENT> global Q <NEWLINE> global nList <NEWLINE> global color <NEWLINE> global labelList <NEWLINE> <NL> Q . append ( p ) <NEWLINE> color [ p ] = GRAY <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while ( len ( Q ) > 0 ) : <NEWLINE> <INDENT> current = Q . popleft ( ) <NEWLINE> for next in nList [ current ] : <NEWLINE> <INDENT> if ( color [ next ] == WHITE ) : <NEWLINE> <INDENT> Q . append ( next ) <NEWLINE> color [ next ] = GRAY <NEWLINE> labelList [ next ] = current <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> color [ current ] = BLACK <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> bfs ( 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> readinput ( ) <NEWLINE> <NL> main ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for l in labelList [ 2 : ] : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Pn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> possible = [ ] <NEWLINE> <NL> for i in range ( min ( Pn ) - 1 , max ( Pn ) + 2 ) if N != 0 else [ X ] : <NEWLINE> <INDENT> if i not in Pn : <NEWLINE> <INDENT> possible . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> idx = np . abs ( np . asarray ( possible ) - X ) . argmin ( ) <NEWLINE> <NL> print ( possible [ idx ] ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> if m == 1 : print ( 0 if k != n - 1 else 1 ) ; exit ( ) <NEWLINE> fact = [ 1 ] * ( n - 1 + 1 ) <NEWLINE> inv = [ 1 ] * ( n - 1 + 1 ) <NEWLINE> for i in range ( 2 , n - 1 + 1 ) : <NEWLINE> <INDENT> fact [ i ] = i * fact [ i - 1 ] % mod <NEWLINE> <DEDENT> inv [ - 1 ] = pow ( fact [ - 1 ] , mod - 2 , mod ) <NEWLINE> for i in range ( n - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> inv [ i - 1 ] = inv [ i ] * i % mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> po = pow ( m - 1 , n - 1 , mod ) * m % mod <NEWLINE> ue = fact [ n - 1 ] <NEWLINE> iii = pow ( m - 1 , mod - 2 , mod ) % mod <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += ue * inv [ n - 1 - i ] % mod * inv [ i ] % mod * po % mod <NEWLINE> po *= iii <NEWLINE> po %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import numpy as np <NEWLINE> import random <NEWLINE> import time <NEWLINE> <NL> random . seed ( 1111 ) <NEWLINE> start = time . time ( ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> C = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> last_day = np . array ( [ - 1 for _ in range ( 26 ) ] ) <NEWLINE> score = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] ) <NEWLINE> output = [ 0 for _ in range ( D ) ] <NEWLINE> <NL> <COMMENT> <NL> for day in range ( D ) : <NEWLINE> <INDENT> today_point = C * ( day - last_day ) <NEWLINE> S_today = sum ( today_point ) <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> today_point [ k ] = score [ day ] [ k ] - S_today + today_point [ k ] <NEWLINE> <NL> <DEDENT> if day != D - 1 : <NEWLINE> <INDENT> max_score = - 1 * float ( <STRING> ) <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> nday_point = C * ( ( day + 1 ) - last_day ) <NEWLINE> S_nday = sum ( nday_point ) - C [ k ] * ( day - last_day [ k ] ) <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> if k != i : <NEWLINE> <INDENT> nday_point [ i ] = score [ day + 1 ] [ i ] - S_nday + nday_point [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nday_point [ i ] = score [ day + 1 ] [ i ] - S_nday + C [ i ] <NEWLINE> <NL> <DEDENT> if today_point [ k ] + nday_point [ i ] > max_score : <NEWLINE> <INDENT> max_score = today_point [ k ] + nday_point [ i ] <NEWLINE> idx = k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = np . argmax ( today_point ) <NEWLINE> <NL> <DEDENT> last_day [ idx ] = day <NEWLINE> output [ day ] = idx + 1 <NEWLINE> <NL> <DEDENT> def score_cal ( output ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> memo = np . array ( [ - 1 for _ in range ( 26 ) ] ) <NEWLINE> for day in range ( D ) : <NEWLINE> <INDENT> t = output [ day ] - 1 <NEWLINE> memo [ t ] = day <NEWLINE> tmp = C * ( memo - day ) <NEWLINE> ans = ans + score [ day ] [ t ] + sum ( tmp ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> random_day = [ i for i in range ( D ) ] <NEWLINE> random_con = [ i + 1 for i in range ( 26 ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> while time . time ( ) - start < 1.85 : <NEWLINE> <INDENT> tmp_output = output [ : ] <NEWLINE> cnt += 1 <NEWLINE> d = random . choice ( random_day ) <NEWLINE> con = random . choice ( random_con ) <NEWLINE> tmp_output [ d ] = con <NEWLINE> <NL> if score_cal ( tmp_output ) > score_cal ( output ) : <NEWLINE> <INDENT> output [ d ] = con <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * output , sep = <STRING> ) <NEWLINE>
<NL> <NL> n = 0 <NEWLINE> a = [ ] <NEWLINE> <NL> def format_input ( filename = None ) : <NEWLINE> <INDENT> global n <NEWLINE> global a <NEWLINE> if filename == None : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> elif filename == <STRING> : <NEWLINE> <INDENT> from random import randint as rng <NEWLINE> n = rng ( 2 , 2 * 10 ** 5 ) <NEWLINE> a = [ rng ( - 1 * 10 ** 9 , 10 ** 9 ) for i in range ( n ) ] <NEWLINE> print ( n ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , a ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_answer ( ) : <NEWLINE> <INDENT> odd = [ 0 ] <NEWLINE> even = [ 0 ] <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> odd . append ( odd [ - 1 ] + a [ 2 * i ] ) <NEWLINE> even . append ( even [ - 1 ] + a [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> odd . append ( odd [ - 1 ] + a [ - 1 ] ) <NEWLINE> <NL> <DEDENT> answer = - 1 * 10 ** 9 * n <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n // 2 + 1 ) : <NEWLINE> <INDENT> answer = max ( answer , odd [ i ] - even [ i ] + even [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> even_range = [ even [ 0 ] - odd [ 1 ] ] <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> add = a [ 2 * i + 1 ] - a [ 2 * i + 2 ] <NEWLINE> min = - a [ 2 * i ] + add <NEWLINE> even_range . append ( max ( even_range [ - 1 ] + add , min ) ) <NEWLINE> <DEDENT> answer = odd [ - 1 ] + max ( even_range ) <NEWLINE> <DEDENT> return answer <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> format_input ( ) <NEWLINE> <NL> ans = get_answer ( ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( x ) <NEWLINE> <NL> <DEDENT> j = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( <STRING> % ( j , i ) ) <NEWLINE> j = j + 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ A [ i ] ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( [ str ( n ) for n in B [ 1 : ] ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 for i in range ( n ) ] <NEWLINE> for i in m : <NEWLINE> <INDENT> a [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = c [ 0 ] <NEWLINE> for i in range ( 1 , a ) : <NEWLINE> <INDENT> ans = ans * c [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 not in a : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> h = int ( int ( a ) / 3600 ) <NEWLINE> b = int ( ( int ( a ) - h * 3600 ) / 60 ) <NEWLINE> s = int ( ( int ( a ) - h * 3600 - b * 60 ) ) <NEWLINE> print ( <STRING> . format ( h , b , s ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <DEDENT> cnt = [ 0 ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> def DFS ( v , p_v ) : <NEWLINE> <INDENT> for next_v in tree [ v ] : <NEWLINE> <INDENT> if next_v == p_v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ next_v ] += cnt [ v ] <NEWLINE> DFS ( next_v , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( 0 , - 1 ) <NEWLINE> print ( * cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> edge = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( [ y - 1 , z ] ) <NEWLINE> edge [ y - 1 ] . append ( [ x - 1 , z ] ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dist = [ - 1 ] * n <NEWLINE> def dfs ( node , d ) : <NEWLINE> <INDENT> dist [ node ] = d <NEWLINE> for i in edge [ node ] : <NEWLINE> <INDENT> if dist [ i [ 0 ] ] == - 1 : <NEWLINE> <INDENT> dfs ( i [ 0 ] , d + i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( k - 1 , 0 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> inf = pow ( 10 , 10 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ inf ] * n <NEWLINE> <NL> edge = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 ; r -= 1 <NEWLINE> edge [ l ] . append ( ( r , d ) ) <NEWLINE> edge [ r ] . append ( ( l , - d ) ) <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> dist = [ inf ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not flag : break <NEWLINE> if dist [ i ] == inf : <NEWLINE> <INDENT> dist [ i ] = 0 <NEWLINE> dq = deque ( [ i ] ) <NEWLINE> while dq : <NEWLINE> <INDENT> now = dq . popleft ( ) <NEWLINE> for e in edge [ now ] : <NEWLINE> <INDENT> nnode , d = e <NEWLINE> if dist [ nnode ] == inf : <NEWLINE> <INDENT> dist [ nnode ] = dist [ now ] + d <NEWLINE> dq . append ( nnode ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dist [ nnode ] != dist [ now ] + d : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> D = np . zeros ( ( 10 ** 5 ) + 1 ) <NEWLINE> S = sum ( A ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> D [ A [ i ] ] += 1 <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S += D [ b ] * ( c - b ) <NEWLINE> D [ c ] += D [ b ] <NEWLINE> D [ b ] = 0 <NEWLINE> print ( int ( S ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> counts = [ 0 ] * n <NEWLINE> x_max = int ( np . sqrt ( n ) ) <NEWLINE> for x in range ( 1 , x_max + 1 ) : <NEWLINE> <INDENT> y_max = int ( np . sqrt ( n - x ** 2 ) ) <NEWLINE> for y in range ( 1 , y_max + 1 ) : <NEWLINE> <INDENT> z_max = int ( np . sqrt ( n - x ** 2 - y ** 2 ) ) <NEWLINE> for z in range ( 1 , z_max + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= n : <NEWLINE> <INDENT> counts [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return counts <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> counts = f ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( counts [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = map ( int , input ( ) [ : : - 1 ] ) <NEWLINE> mod = 2019 <NEWLINE> counts = [ 0 ] * mod <NEWLINE> counts [ 0 ] = 1 <NEWLINE> t = 0 <NEWLINE> x = 1 <NEWLINE> for num in s : <NEWLINE> <INDENT> t = ( t + num * x ) % mod <NEWLINE> counts [ t ] += 1 <NEWLINE> x = ( x * 10 ) % mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for count in counts : <NEWLINE> <INDENT> if count > 1 : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def readstr ( ) : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def readint ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readnums ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readstrs ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> N = readint ( ) <NEWLINE> A = list ( readnums ( ) ) <NEWLINE> <NL> L = [ i + x for i , x in enumerate ( A ) ] <NEWLINE> R = [ i - x for i , x in enumerate ( A ) ] <NEWLINE> <NL> l_c = Counter ( L ) <NEWLINE> r_c = Counter ( R ) <NEWLINE> <NL> x1 = min ( max ( L ) , max ( R ) ) <NEWLINE> x2 = max ( min ( L ) , min ( R ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( x2 , x1 + 1 ) : <NEWLINE> <INDENT> ans += l_c [ i ] * r_c [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> C = { <STRING> , <STRING> , <STRING> } <NEWLINE> cumsum = { c : [ 0 for i in range ( N ) ] for c in C } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> cumsum [ s ] [ i ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for c in C : <NEWLINE> <INDENT> cumsum [ c ] [ - i ] = cumsum [ c ] [ - i ] + cumsum [ c ] [ - ( i - 1 ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> a , b = C - { s } <NEWLINE> ans += cumsum [ a ] [ i ] * cumsum [ b ] [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , ( N - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( N - 2 * i ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ j ] != S [ j + i ] and S [ j + i ] != S [ j + 2 * i ] and S [ j ] != S [ j + 2 * i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( a ) for a in A ] <NEWLINE> A . sort ( ) <NEWLINE> MAX = 10 ** 18 <NEWLINE> res = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res *= A [ i ] <NEWLINE> if res > MAX : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b // k - a // k > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> ans *= i % 1000000007 <NEWLINE> ans = ans % 1000000007 <NEWLINE> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def solve ( N , K , LR ) : <NEWLINE> <INDENT> mod = 998244353 <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dp [ 2 ] = 1 if 1 in [ lr [ 0 ] for lr in LR ] else 0 <NEWLINE> for i in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for l , r in LR : <NEWLINE> <INDENT> x += dp [ max ( i - l , 0 ) ] - dp [ max ( i - 1 - r , 0 ) ] <NEWLINE> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + x ) % mod <NEWLINE> <DEDENT> print ( dp [ N ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( K ) ] <NEWLINE> solve ( N , K , LR ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> R = [ 0 ] * ( N + 1 ) <NEWLINE> mul = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> R [ - ( i + 1 ) ] = ( ( ( int ( S [ - i ] ) * mul ) ) % ( 2019 ) + R [ - i ] ) % 2019 <NEWLINE> mul *= 10 <NEWLINE> mul %= 2019 <NEWLINE> <COMMENT> <NL> <DEDENT> L = [ 0 ] * 2019 <NEWLINE> for r in R : <NEWLINE> <INDENT> L [ r ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> if l >= 2 : <NEWLINE> <INDENT> ans += l * ( l - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> A = a . sort ( ) <NEWLINE> num = [ ] <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> num . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> num = [ 0 ] <NEWLINE> for i in range ( 2 , n , 2 ) : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> num . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if num == a : <NEWLINE> <INDENT> print ( 2 ** ( n // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
figure = <STRING> <NEWLINE> height , width = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> while height or width : <NEWLINE> <INDENT> side = ( <STRING> * width ) + <STRING> <NEWLINE> fill = <STRING> + ( <STRING> * ( width - 2 ) ) + <STRING> <NEWLINE> rect = side + ( fill * ( height - 2 ) ) + side <NEWLINE> figure += rect + <STRING> <NEWLINE> height , width = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> print ( figure [ : - 1 ] ) <NEWLINE>
import sys <NEWLINE> def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> string = get_string ( ) <NEWLINE> s = 0 <NEWLINE> while string != <STRING> : <NEWLINE> <INDENT> s = s + int ( string [ - 1 ] ) <NEWLINE> string = string [ : - 1 ] <NEWLINE> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> maxA = max ( A ) <NEWLINE> <NL> C = { a : 0 for a in A } <NEWLINE> D = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> if C [ a ] > 0 : <NEWLINE> <INDENT> t = 2 <NEWLINE> while a * t <= maxA : <NEWLINE> <INDENT> D [ a * t ] = 1 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] == 1 and D [ a ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> a = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for number in li : <NEWLINE> <INDENT> result = result * number <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if result <= 10 ** 18 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> dp = [ INF ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> i_j = i + j <NEWLINE> if i_j < n : <NEWLINE> <INDENT> x = dp [ i ] + abs ( h [ i ] - h [ i_j ] ) <NEWLINE> if dp [ i_j ] > x : <NEWLINE> <INDENT> dp [ i_j ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> * B , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AX = [ 0 ] * ( N + 1 ) <NEWLINE> na = N + 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> AX [ i ] = AX [ i - 1 ] + A [ i - 1 ] <NEWLINE> if K < AX [ i ] : na = min ( na , i ) <NEWLINE> <NL> <DEDENT> BX = [ 0 ] * ( M + 1 ) <NEWLINE> nb = M + 1 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> BX [ i ] = BX [ i - 1 ] + B [ i - 1 ] <NEWLINE> if K < BX [ i ] : nb = min ( nb , i ) <NEWLINE> <NL> <DEDENT> import bisect <NEWLINE> ans = 0 <NEWLINE> for i in range ( na ) : <NEWLINE> <INDENT> j = bisect . bisect_right ( BX , K - AX [ i ] ) - 1 <NEWLINE> <COMMENT> <NL> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> <NL> l = stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = int ( l [ 2 ] ) <NEWLINE> n = int ( l [ 0 ] ) <NEWLINE> m = int ( l [ 1 ] ) <NEWLINE> <NL> sum = 0 <NEWLINE> a = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> a . append ( sum ) <NEWLINE> <DEDENT> sum = 0 <NEWLINE> <NL> b = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sum += B [ i ] <NEWLINE> b . append ( sum ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> jumps = [ <NEWLINE> <INDENT> [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 1 , 2 ] , [ 0 , 2 ] , [ 1 , 2 ] , [ 2 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] <NEWLINE> <DEDENT> ] <NEWLINE> <NL> def bfs ( ipy , ipx , ys , xs , n ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( [ ipy , ipx , - 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> py , px , t = q . popleft ( ) <NEWLINE> if t == n - 1 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> for dy , dx in jumps : <NEWLINE> <INDENT> npy = py + dy <NEWLINE> npx = px + dx <NEWLINE> if npy in range ( 10 ) and npx in range ( 10 ) and abs ( npy - ys [ t + 1 ] ) <= 1 and abs ( npx - xs [ t + 1 ] ) <= 1 : <NEWLINE> <INDENT> q . append ( [ npy , npx , t + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ipx , ipy = map ( int , input ( ) . split ( ) ) <NEWLINE> if ipx == 0 and ipy == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xs = l [ : : 2 ] <NEWLINE> ys = l [ 1 : : 2 ] <NEWLINE> <NL> if bfs ( ipy , ipx , ys , xs , n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Fibonacci ( object ) : <NEWLINE> <INDENT> memo = [ 1 , 1 ] <NEWLINE> <NL> def get_nth ( self , n ) : <NEWLINE> <INDENT> if n < len ( Fibonacci . memo ) : <NEWLINE> <INDENT> return Fibonacci . memo [ n ] <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( len ( Fibonacci . memo ) , n + 1 ) : <NEWLINE> <INDENT> result = Fibonacci . memo [ i - 1 ] + Fibonacci . memo [ i - 2 ] <NEWLINE> Fibonacci . memo . append ( result ) <NEWLINE> <COMMENT> <NL> <DEDENT> return Fibonacci . memo [ n ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> f = Fibonacci ( ) <NEWLINE> result = f . get_nth ( num ) <NEWLINE> <NL> <COMMENT> <NL> print ( <STRING> . format ( result ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> A . sort ( reverse = True ) <NEWLINE> flag = True <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> flag = False <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = ( ( N - 1 ) ** 2 ) * 3 + ( N - 1 ) * 3 + 1 <NEWLINE> p = 0 <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( N - 1 ) : <NEWLINE> <INDENT> k = gcd ( ( i + 2 ) , ( j + 2 ) ) <NEWLINE> for l in range ( N - 1 ) : <NEWLINE> <INDENT> if k != 1 : <NEWLINE> <INDENT> m = gcd ( k , ( l + 2 ) ) <NEWLINE> p += m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( p + s ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if ( H , W ) == ( 0 , 0 ) : break <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> res += math . gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> acgt = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in acgt : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> ans = max ( cnt , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( n , x ) ) <NEWLINE> n += 1 <NEWLINE> <NL> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> l = LI ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a = [ ] <NEWLINE> b = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = l [ i ] <NEWLINE> a . append ( x + i ) <NEWLINE> y = i - x <NEWLINE> if y in b : <NEWLINE> <INDENT> b [ y ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ y ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if x in b : <NEWLINE> <INDENT> ans += b [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ u - 1 ] . append ( v - 1 ) <NEWLINE> adj [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> LIS = [ INF ] * ( N + 1 ) <NEWLINE> rewinder = [ ] <NEWLINE> <NL> parent = [ - 1 ] * N <NEWLINE> stack = [ 0 ] <NEWLINE> while stack : <NEWLINE> <INDENT> node = stack . pop ( ) <NEWLINE> for next_node in adj [ node ] : <NEWLINE> <INDENT> if ans [ next_node ] == 0 : <NEWLINE> <INDENT> parent [ next_node ] = node <NEWLINE> stack . append ( next_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> while rewinder and rewinder [ - 1 ] [ 0 ] != parent [ node ] : <NEWLINE> <INDENT> _ , index , prev_value = rewinder . pop ( ) <NEWLINE> LIS [ index ] = prev_value <NEWLINE> <NL> <DEDENT> index = bisect_left ( LIS , As [ node ] ) <NEWLINE> rewinder . append ( ( node , index , LIS [ index ] ) ) <NEWLINE> LIS [ index ] = As [ node ] <NEWLINE> <NL> ans [ node ] = bisect_left ( LIS , INF ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> a = list ( int ( y ) for y in input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
line = input ( ) <NEWLINE> A = line . split ( ) <NEWLINE> <NL> stack = [ ] <NEWLINE> <NL> for c in A : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> rhs = stack . pop ( ) <NEWLINE> lhs = stack . pop ( ) <NEWLINE> stack . append ( lhs + rhs ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> rhs = stack . pop ( ) <NEWLINE> lhs = stack . pop ( ) <NEWLINE> stack . append ( lhs - rhs ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> rhs = stack . pop ( ) <NEWLINE> lhs = stack . pop ( ) <NEWLINE> stack . append ( lhs * rhs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( int ( c ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( stack . pop ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> B = A [ : : - 1 ] <NEWLINE> print ( <STRING> . join ( B [ : : 2 ] ) + <STRING> + <STRING> . join ( A [ : : 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = A [ : : - 1 ] <NEWLINE> A = A [ 1 : : 2 ] <NEWLINE> print ( <STRING> . join ( B [ : : 2 ] ) + <STRING> + <STRING> . join ( A [ : ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] <NEWLINE> ta = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a += ta <NEWLINE> kaiten = [ 0 ] * ( n + 1 ) <NEWLINE> count = 0 <NEWLINE> koko = 1 <NEWLINE> kaitenkikan = 0 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> koko = a [ koko ] <NEWLINE> count += 1 <NEWLINE> k -= 1 <NEWLINE> if kaiten [ koko ] > 0 : <NEWLINE> <INDENT> kaitenkikan = abs ( count - kaiten [ koko ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kaiten [ koko ] = count <NEWLINE> <DEDENT> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( koko ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> k_remain = k % kaitenkikan <NEWLINE> if k_remain < 0 : <NEWLINE> <INDENT> k_remain += kaitenkikan <NEWLINE> <NL> <DEDENT> while k_remain > 0 : <NEWLINE> <INDENT> koko = a [ koko ] <NEWLINE> k_remain -= 1 <NEWLINE> <NL> <DEDENT> print ( koko ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
x = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for b in range ( 1 , x ) : <NEWLINE> <INDENT> for p in range ( 2 , x ) : <NEWLINE> <INDENT> a = b ** p <NEWLINE> if a == a // 1 and a > ans and a <= x : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> if a > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if a > x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> A = 0 <NEWLINE> B = 0 <NEWLINE> C = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> A += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> B += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> C += 1 <NEWLINE> <DEDENT> <DEDENT> k = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> t = 2 * j - i <NEWLINE> if t < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ t ] and S [ t ] != S [ j ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( A * B * C - k ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> e = min ( n + 1 , b ) <NEWLINE> s = max ( int ( b / a ) , e - 1000 ) <NEWLINE> for i in range ( s , e ) : <NEWLINE> <INDENT> x = ( int ( a * i / b ) - a * int ( i / b ) ) <NEWLINE> if ans < x : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> c = X . count ( <STRING> ) <NEWLINE> r1 = int ( X , 2 ) % ( c - 1 ) if c > 1 else 0 <NEWLINE> r2 = int ( X , 2 ) % ( c + 1 ) <NEWLINE> d = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ i + 1 ] = d [ ( i + 1 ) % bin ( i + 1 ) . count ( <STRING> ) ] + 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> n = ( r2 + pow ( 2 , N - i - 1 , c + 1 ) ) % ( c + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> n = ( r1 - pow ( 2 , N - i - 1 , c - 1 ) ) % ( c - 1 ) <NEWLINE> <DEDENT> print ( d [ n ] + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a1 = x + y <NEWLINE> a2 = x + y <NEWLINE> b1 = y - x <NEWLINE> b2 = y - x <NEWLINE> N -= 1 <NEWLINE> while N != 0 : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a1 = max ( a1 , x + y ) <NEWLINE> a2 = min ( a2 , x + y ) <NEWLINE> b1 = max ( b1 , y - x ) <NEWLINE> b2 = min ( b2 , y - x ) <NEWLINE> N = N - 1 <NEWLINE> <DEDENT> print ( max ( a1 - a2 , b1 - b2 ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import fractions <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> s = line . strip ( ) <NEWLINE> print ( s [ : : - 1 ] ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> rank = len ( N ) - 1 <NEWLINE> i = 0 <NEWLINE> while ( len ( N ) != 0 ) : <NEWLINE> <INDENT> a = N [ 0 ] <NEWLINE> N = N [ 1 : ] <NEWLINE> a = int ( a ) <NEWLINE> i += a <NEWLINE> <DEDENT> if ( i % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> li = np . array ( [ ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> li = np . array ( l ) <NEWLINE> <NL> skill_sum = [ ] <NEWLINE> for j in range ( 2 ** N ) : <NEWLINE> <INDENT> sum = np . zeros ( [ M + 1 ] ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if ( ( j >> k ) & 1 ) : <NEWLINE> <INDENT> sum += li [ k ] <NEWLINE> <DEDENT> <DEDENT> skill_sum . append ( list ( sum ) ) <NEWLINE> <DEDENT> pricelist = [ ] <NEWLINE> for l in range ( 2 ** N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> if skill_sum [ l ] [ m + 1 ] >= X : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == M : <NEWLINE> <INDENT> pricelist . append ( int ( skill_sum [ l ] [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if pricelist == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( pricelist ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> sum = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i - 1 <NEWLINE> if ( k >= n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( len ( { s [ i - 1 ] , s [ j - 1 ] , s [ k ] } ) == 3 ) : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> len_s = len ( s ) <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> x_i = pow ( 26 , k , MOD ) <NEWLINE> r = ( 25 * pow ( 26 , - 1 , MOD ) ) % MOD <NEWLINE> comb_i = 1 <NEWLINE> <NL> a = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> a += ( comb_i * x_i ) % MOD <NEWLINE> a %= MOD <NEWLINE> <NL> x_i = ( x_i * r ) % MOD <NEWLINE> comb_i = ( comb_i * ( len_s + i ) * pow ( i + 1 , - 1 , MOD ) ) % MOD <NEWLINE> <NL> <NL> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list_a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> list_a_str = [ str ( s ) for s in list_a ] <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if list_a_str [ i ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans *= list_a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : print ( ans ) <NEWLINE>
from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . rsplit ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> n , q = LI ( ) <NEWLINE> point = [ 0 ] * n <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> visited = [ False ] * n <NEWLINE> <NL> <NL> def dfs ( n ) : <NEWLINE> <INDENT> visited [ n - 1 ] = True <NEWLINE> for node in graph [ n - 1 ] : <NEWLINE> <INDENT> if visited [ node - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ node - 1 ] += point [ n - 1 ] <NEWLINE> dfs ( node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = LI ( ) <NEWLINE> graph [ a - 1 ] . append ( b ) <NEWLINE> graph [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = LI ( ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> <NL> print ( * point ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def SA_IS ( s , upper = 127 ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> sa = [ - 1 for _ in range ( n ) ] <NEWLINE> bucket = [ 0 for _ in range ( upper + 1 ) ] <NEWLINE> smaller = [ True for _ in range ( n ) ] <NEWLINE> is_lms = [ False for _ in range ( n ) ] <NEWLINE> lmss = [ ] <NEWLINE> <NL> for x in s : <NEWLINE> <INDENT> bucket [ x + 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( upper ) : <NEWLINE> <INDENT> bucket [ i + 1 ] += bucket [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] > s [ i + 1 ] or ( s [ i ] == s [ i + 1 ] and not smaller [ i + 1 ] ) : <NEWLINE> <INDENT> smaller [ i ] = False <NEWLINE> if smaller [ i + 1 ] : <NEWLINE> <INDENT> is_lms [ i + 1 ] = True <NEWLINE> lmss . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = [ 0 for _ in range ( upper + 1 ) ] <NEWLINE> for i in lmss : <NEWLINE> <INDENT> sa [ bucket [ s [ i ] + 1 ] - 1 - count [ s [ i ] + 1 ] ] = i <NEWLINE> count [ s [ i ] + 1 ] += 1 <NEWLINE> <NL> <DEDENT> count = [ 0 for _ in range ( upper + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sa [ i ] > 0 and not smaller [ sa [ i ] - 1 ] : <NEWLINE> <INDENT> sa [ bucket [ s [ sa [ i ] - 1 ] ] + count [ s [ sa [ i ] - 1 ] + 1 ] ] = sa [ i ] - 1 <NEWLINE> count [ s [ sa [ i ] - 1 ] + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = [ 0 for _ in range ( upper + 1 ) ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if sa [ i ] > 0 and smaller [ sa [ i ] - 1 ] : <NEWLINE> <INDENT> sa [ bucket [ s [ sa [ i ] - 1 ] + 1 ] - 1 - count [ s [ sa [ i ] - 1 ] + 1 ] ] = sa [ i ] - 1 <NEWLINE> count [ s [ sa [ i ] - 1 ] + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> new_num = 0 <NEWLINE> new_array = [ - 1 for _ in range ( len ( lmss ) ) ] <NEWLINE> lms_to_ind = dict ( ) <NEWLINE> for i , x in enumerate ( lmss ) : <NEWLINE> <INDENT> lms_to_ind [ x ] = len ( lmss ) - 1 - i <NEWLINE> <DEDENT> last = sa [ 0 ] <NEWLINE> new_array [ lms_to_ind [ sa [ 0 ] ] ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if is_lms [ sa [ i ] ] : <NEWLINE> <INDENT> tmp , j = sa [ i ] , 0 <NEWLINE> while True : <NEWLINE> <INDENT> if s [ last + j ] != s [ tmp + j ] : <NEWLINE> <INDENT> new_num += 1 <NEWLINE> break <NEWLINE> <DEDENT> if j > 0 and ( is_lms [ last + j ] or is_lms [ tmp + j ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> new_array [ lms_to_ind [ tmp ] ] = new_num <NEWLINE> last = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> if new_num == len ( lmss ) - 1 : <NEWLINE> <INDENT> seed = [ - 1 for _ in range ( len ( lmss ) ) ] <NEWLINE> for i , x in enumerate ( new_array ) : <NEWLINE> <INDENT> seed [ x ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> seed = SA_IS ( new_array , upper = new_num + 1 ) <NEWLINE> <NL> <DEDENT> new_lmss = [ - 1 for _ in range ( len ( lmss ) ) ] <NEWLINE> for i , x in enumerate ( seed ) : <NEWLINE> <INDENT> new_lmss [ len ( lmss ) - 1 - i ] = lmss [ len ( lmss ) - 1 - x ] <NEWLINE> <NL> <DEDENT> sa = [ - 1 for _ in range ( n ) ] <NEWLINE> count = [ 0 for _ in range ( upper + 1 ) ] <NEWLINE> for i in new_lmss : <NEWLINE> <INDENT> sa [ bucket [ s [ i ] + 1 ] - 1 - count [ s [ i ] + 1 ] ] = i <NEWLINE> count [ s [ i ] + 1 ] += 1 <NEWLINE> <NL> <DEDENT> count = [ 0 for _ in range ( upper + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sa [ i ] > 0 and not smaller [ sa [ i ] - 1 ] : <NEWLINE> <INDENT> sa [ bucket [ s [ sa [ i ] - 1 ] ] + count [ s [ sa [ i ] - 1 ] + 1 ] ] = sa [ i ] - 1 <NEWLINE> count [ s [ sa [ i ] - 1 ] + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = [ 0 for _ in range ( upper + 1 ) ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if sa [ i ] > 0 and smaller [ sa [ i ] - 1 ] : <NEWLINE> <INDENT> sa [ bucket [ s [ sa [ i ] - 1 ] + 1 ] - 1 - count [ s [ sa [ i ] - 1 ] + 1 ] ] = sa [ i ] - 1 <NEWLINE> count [ s [ sa [ i ] - 1 ] + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return sa <NEWLINE> <NL> <DEDENT> def suffix_array ( s ) : <NEWLINE> <INDENT> lis = [ ord ( x ) - 96 for x in s ] + [ 0 ] <NEWLINE> sa = SA_IS ( lis , 30 ) [ 1 : ] <NEWLINE> return sa <NEWLINE> <NL> <DEDENT> def lcp_array ( s , sa ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> rnk = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> rnk [ sa [ i ] ] = i <NEWLINE> <DEDENT> lcp = [ 0 ] * ( n - 1 ) <NEWLINE> h = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h > 0 : <NEWLINE> <INDENT> h -= 1 <NEWLINE> <DEDENT> if rnk [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = sa [ rnk [ i ] - 1 ] <NEWLINE> while j + h < n and i + h < n : <NEWLINE> <INDENT> if s [ j + h ] != s [ i + h ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h += 1 <NEWLINE> <DEDENT> lcp [ rnk [ i ] - 1 ] = h <NEWLINE> <DEDENT> return lcp <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = input ( ) [ : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> sa = suffix_array ( s ) <NEWLINE> <NL> lcp = lcp_array ( s , sa ) <NEWLINE> <NL> ans = n * ( n + 1 ) // 2 - sum ( lcp ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> N , * Z = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for z in range ( N * N ) : <NEWLINE> <INDENT> x , y = divmod ( z , N ) <NEWLINE> A += [ x ] <NEWLINE> B += [ y ] <NEWLINE> C += [ Z [ z ] ] <NEWLINE> <DEDENT> G = csr_matrix ( ( C , ( A , B ) ) , ( N , N ) ) <NEWLINE> F = np . array ( floyd_warshall ( G , directed = 1 ) , dtype = np . int64 ) <NEWLINE> Z = np . array ( Z ) . reshape ( N , N ) <NEWLINE> if np . all ( F == Z ) : <NEWLINE> <INDENT> ans = np . sum ( Z ) <NEWLINE> for i , j in itertools . product ( range ( N ) , repeat = 2 ) : <NEWLINE> <INDENT> ans -= Z [ i , j ] * ( np . sum ( Z [ i ] + Z [ j ] == Z [ i , j ] ) > 2 ) <NEWLINE> <DEDENT> ans //= 2 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> x = 0 <NEWLINE> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in a : <NEWLINE> <INDENT> x = j * x <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def input_one_number ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def input_multiple_number ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def input_multiple_number_as_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> N , M = input_multiple_number ( ) <NEWLINE> <NL> shilve = [ - 1 ] * ( N + 1 ) <NEWLINE> michi = [ [ ] for _i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = input_multiple_number ( ) <NEWLINE> michi [ a ] . append ( b ) <NEWLINE> michi [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> que = [ 1 ] <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> now_heya = que . pop ( 0 ) <NEWLINE> for nexthop in michi [ now_heya ] : <NEWLINE> <INDENT> if shilve [ nexthop ] == - 1 : <NEWLINE> <INDENT> shilve [ nexthop ] = now_heya <NEWLINE> que . append ( nexthop ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in shilve [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if K < A : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> elif K < A + B : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A - ( K - ( A + B ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> n = 7 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( 10 * n + 7 ) % k <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> if 7 % k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> val = 7 <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> val = val * 10 + 7 <NEWLINE> val = val % k <NEWLINE> if val == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( lambda n : int ( n ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> costs = [ - 1 ] * N <NEWLINE> loc = 0 <NEWLINE> <NL> if K <= N : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> loc = A [ loc ] <NEWLINE> <DEDENT> print ( loc + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> costs [ loc ] = 0 <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> loc = A [ loc ] <NEWLINE> <NL> if costs [ loc ] >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> costs [ loc ] = i <NEWLINE> <NL> <DEDENT> offset = costs [ loc ] <NEWLINE> loop = i - offset <NEWLINE> <NL> K -= i <NEWLINE> K %= loop <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> loc = A [ loc ] <NEWLINE> <DEDENT> print ( loc + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> bar = 10 ** 18 <NEWLINE> ans = A [ 0 ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in A [ 1 : ] : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > bar : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> d = { } <NEWLINE> for i in arr : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> s += i <NEWLINE> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a in d : <NEWLINE> <INDENT> s = s - a * d [ a ] + b * d [ a ] <NEWLINE> <DEDENT> if b in d and a in d : <NEWLINE> <INDENT> d [ b ] += d [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a in d : <NEWLINE> <INDENT> d [ b ] = d [ a ] <NEWLINE> <DEDENT> <DEDENT> d [ a ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ r - 1 ] - a [ l - 1 ] ) <NEWLINE> <DEDENT>
p = [ ( - 1 , 2 , 4 , 1 , 3 , - 1 ) , <NEWLINE> <INDENT> ( 3 , - 1 , 0 , 5 , - 1 , 2 ) , <NEWLINE> ( 1 , 5 , - 1 , - 1 , 0 , 4 ) , <NEWLINE> ( 4 , 0 , - 1 , - 1 , 5 , 1 ) , <NEWLINE> ( 2 , - 1 , 5 , 0 , - 1 , 3 ) , <NEWLINE> ( - 1 , 3 , 1 , 4 , 2 , - 1 ) ] <NEWLINE> <NL> <DEDENT> d1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> top , front , right = d1 [ 0 ] , d1 [ 1 ] , d1 [ 2 ] <NEWLINE> d2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> da1 = { v : k for k , v in enumerate ( d1 ) } <NEWLINE> da2 = { v : k for k , v in enumerate ( d2 ) } <NEWLINE> boo = True if len ( da1 ) == 6 and len ( da2 ) == 6 else False <NEWLINE> if boo : <NEWLINE> <INDENT> x , y = da2 [ top ] , da2 [ front ] <NEWLINE> adjacent = { v : k for k , v in da2 . items ( ) } <NEWLINE> try : <NEWLINE> <INDENT> if right == adjacent [ p [ x ] [ y ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> db1 = [ ( k , v ) for k , v in enumerate ( d1 ) ] <NEWLINE> db2 = [ ( k , v ) for k , v in enumerate ( d2 ) ] <NEWLINE> for m in range ( 5 , 1 , - 1 ) : <NEWLINE> <INDENT> if db1 [ m ] [ 1 ] != db1 [ m - 1 ] [ 1 ] : <NEWLINE> <INDENT> x , y = db1 [ m ] [ 0 ] , db1 [ m - 1 ] [ 0 ] <NEWLINE> t1 , f1 , r1 = db1 [ m ] [ 0 ] , db1 [ m - 1 ] [ 0 ] , db1 [ p [ x ] [ y ] ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t1 , f1 , r1 = 0 , 0 , 0 <NEWLINE> <DEDENT> <DEDENT> for m in range ( 5 , 1 , - 1 ) : <NEWLINE> <INDENT> if db2 [ m ] [ 1 ] != db2 [ m - 1 ] [ 1 ] : <NEWLINE> <INDENT> x , y = db2 [ m ] [ 0 ] , db2 [ m - 1 ] [ 0 ] <NEWLINE> t2 , f2 , r2 = db2 [ m ] [ 0 ] , db2 [ m - 1 ] [ 0 ] , db2 [ p [ x ] [ y ] ] [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if t2 == r1 and r2 == t1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> queue = deque ( [ 1 ] ) <NEWLINE> d = [ None ] * ( N + 1 ) <COMMENT> <NEWLINE> d [ 1 ] = 0 <COMMENT> <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in g [ v ] : <NEWLINE> <INDENT> if d [ i ] is None : <NEWLINE> <INDENT> d [ i ] = v <NEWLINE> queue . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> d [ 0 ] = 0 <NEWLINE> if None in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i + 1 ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if R == [ ] or G == [ ] or B == [ ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <NL> m = min ( B ) <NEWLINE> M = max ( B ) <NEWLINE> <NL> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> a = 2 * j - i <NEWLINE> b = ( i + j ) // 2 if ( i + j ) % 2 == 0 else 0 <NEWLINE> c = 2 * i - j <NEWLINE> if m <= a <= M : <NEWLINE> <INDENT> if S [ a - 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> if b != 0 and S [ b - 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if m <= c <= M : <NEWLINE> <INDENT> if S [ c - 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a0 , a1 = np . unique ( a , return_counts = True ) <NEWLINE> suma = np . sum ( a ) <NEWLINE> a2 = np . array ( [ 0 ] * 100001 ) <NEWLINE> for j in range ( a0 . size ) : <NEWLINE> <INDENT> a2 [ a0 [ j ] ] = a1 [ j ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sumb = a2 [ b ] <NEWLINE> a2 [ b ] = 0 <NEWLINE> a2 [ c ] += sumb <NEWLINE> sumc = sumb * ( c - b ) <NEWLINE> suma += sumc <NEWLINE> print ( suma ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def solve ( N , XY ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> tmp += ( abs ( x ) + abs ( y ) ) % 2 <NEWLINE> <DEDENT> if tmp % N != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> import math <NEWLINE> m = math . ceil ( math . log2 ( 2 * 10 ** 9 ) ) + 1 <NEWLINE> d = [ 2 ** ( m - i ) for i in range ( m ) ] + [ 1 ] <NEWLINE> d += [ 1 ] if tmp == 0 else [ ] <NEWLINE> m = len ( d ) <NEWLINE> w = [ ] <NEWLINE> for xi , yi in XY : <NEWLINE> <INDENT> xx = 0 <NEWLINE> yy = 0 <NEWLINE> W = <STRING> <NEWLINE> for di in d : <NEWLINE> <INDENT> if abs ( xi - xx ) >= abs ( yi - yy ) : <NEWLINE> <INDENT> if xx <= xi : <NEWLINE> <INDENT> xx += di <NEWLINE> W += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xx -= di <NEWLINE> W += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if yy <= yi : <NEWLINE> <INDENT> yy += di <NEWLINE> W += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yy -= di <NEWLINE> W += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> w . append ( W ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in d ] ) ) <NEWLINE> [ print ( wi ) for wi in w ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> XY = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> solve ( N , XY ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> a = A [ i - K ] <NEWLINE> b = A [ i ] <NEWLINE> if a < b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> division = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> division = division * A [ i ] <NEWLINE> i += 1 <NEWLINE> if division > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 < division <= 10 ** 18 : <NEWLINE> <INDENT> print ( division ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> tem = a <NEWLINE> a = b <NEWLINE> b = tem <NEWLINE> <DEDENT> gc = gcd ( a , b ) <NEWLINE> print ( gc , a * b // gc ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> c [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> s = input ( <STRING> ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> p = 1 <NEWLINE> f = 0 <NEWLINE> t = 0 <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> s [ a ] = int ( s [ a ] ) <NEWLINE> <NL> <DEDENT> for b in s : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> t = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in range ( n ) : <NEWLINE> <INDENT> p = p * s [ a ] <NEWLINE> <NL> if p > 10 ** 18 : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in As : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for A in As : <NEWLINE> <INDENT> ans *= A <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> + input ( ) + <STRING> <NEWLINE> td = [ input ( ) . split ( ) for _ in [ 0 ] * q ] <NEWLINE> def test ( x ) : <NEWLINE> <INDENT> for t , d in td : <NEWLINE> <INDENT> if s [ x ] == t : x += 1 if d == <STRING> else - 1 <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> def bs ( b , g , t ) : <NEWLINE> <INDENT> while abs ( b - g ) > 1 : <NEWLINE> <INDENT> k = ( b + g ) // 2 <NEWLINE> if test ( k ) == t : g = k <NEWLINE> else : b = k <NEWLINE> <DEDENT> return g <NEWLINE> <DEDENT> l = bs ( n + 1 , 0 , 0 ) <NEWLINE> r = bs ( 0 , n + 1 , n + 1 ) <NEWLINE> print ( r - l - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( input ( ) ) <NEWLINE> es = [ 0 , N , 0 ] <NEWLINE> <NL> def p ( X ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> def list_change ( X ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> es [ 0 ] = i <NEWLINE> for j in reversed ( range ( es [ 1 ] ) ) : <NEWLINE> <INDENT> if X [ j ] == <STRING> : <NEWLINE> <INDENT> es [ 1 ] = j <NEWLINE> if i < j : <NEWLINE> <INDENT> X [ i ] = <STRING> <NEWLINE> X [ j ] = <STRING> <NEWLINE> es [ 2 ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> es [ 1 ] = 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> list_change ( X ) <NEWLINE> p ( es [ 2 ] ) <NEWLINE>
import itertools <NEWLINE> n , k = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> P = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> probs = list ( itertools . accumulate ( [ ( 1 + p ) / 2 for p in P ] ) ) <NEWLINE> probs . insert ( 0 , 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , - probs [ i ] + probs [ i + k ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for i in range ( 100001 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> for i in range ( 100001 ) : <NEWLINE> <INDENT> tt = ( i + 1 ) * ans [ i ] <NEWLINE> tmp += tt <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tt = - ans [ b - 1 ] * b + ans [ b - 1 ] * c <NEWLINE> ans [ c - 1 ] += ans [ b - 1 ] <NEWLINE> ans [ b - 1 ] = 0 <NEWLINE> tmp += tt <NEWLINE> print ( tmp ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> s = 0 <NEWLINE> sum = 0 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> t . append ( i ) <NEWLINE> t [ i ] = int ( input ( ) ) <NEWLINE> t . sort ( ) <NEWLINE> <NL> <DEDENT> for m in range ( n ) : <NEWLINE> <INDENT> sum = sum + t [ m ] * ( n - m - 1 ) <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> s = int ( input ( ) ) <NEWLINE> x = s // 3 <NEWLINE> <NL> MAX = s + 1 <NEWLINE> fac = [ 0 ] * MAX <NEWLINE> finv = [ 0 ] * MAX <NEWLINE> inv = [ 0 ] * MAX <NEWLINE> def COMinit ( ) : <NEWLINE> <INDENT> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - inv [ MOD % i ] * ( MOD // i ) % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> def COM ( n , k ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> res = res * ( n - i ) % MOD <NEWLINE> <DEDENT> return res * finv [ k ] % MOD <NEWLINE> <NL> <NL> <DEDENT> COMinit ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> ans = ( ans + COM ( s - 2 * ( i + 1 ) - 1 , i ) ) % MOD <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> a , b , c , d = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> numlist = [ a * c , a * d , b * c , b * d ] <NEWLINE> maxnum = max ( numlist ) <NEWLINE> print ( maxnum ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n , k = input ( ) . split ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = int ( n ) <NEWLINE> k = int ( k ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ i + k ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ n - 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> s . append ( ( n - 1 ) // i ) <NEWLINE> <DEDENT> t = 0 <NEWLINE> for j in s : <NEWLINE> <INDENT> t += j <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> item_list = [ ] <NEWLINE> <NL> while i < N : <NEWLINE> <INDENT> item = input ( ) <NEWLINE> item_list . append ( item ) <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( len ( set ( item_list ) ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
<NL> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , num , children ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . children = children <NEWLINE> self . parents = - 1 <NEWLINE> self . type = None <NEWLINE> self . depth = 0 <NEWLINE> <NL> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . num , <NEWLINE> <INDENT> self . parents , <NEWLINE> self . depth , <NEWLINE> self . type , <NEWLINE> self . children ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def set_node ( num , children ) : <NEWLINE> <INDENT> node = Node ( num , children ) <NEWLINE> T [ num ] = node <NEWLINE> for n in children : <NEWLINE> <INDENT> T [ - 1 ] -= n <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def set_pdt ( n_i , parent , depth ) : <NEWLINE> <INDENT> node = T [ n_i ] <NEWLINE> node . parents = parent <NEWLINE> node . depth = depth <NEWLINE> if node . children : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> for n in node . children : <NEWLINE> <INDENT> set_pdt ( n , n_i , depth + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> T = [ None ] * n <NEWLINE> T += [ n * ( n - 1 ) // 2 ] <NEWLINE> for j in tree : <NEWLINE> <INDENT> set_node ( j [ 0 ] , j [ 2 : ] ) <NEWLINE> <NL> <DEDENT> set_pdt ( T [ - 1 ] , - 1 , 0 ) <NEWLINE> <NL> T [ T [ - 1 ] ] . type = <STRING> <NEWLINE> <NL> for n in T [ : - 1 ] : <NEWLINE> <INDENT> n . output ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> t = 0 <NEWLINE> if n <= b - 1 : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * ( b - 1 ) / b ) ) <NEWLINE> <DEDENT>
N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> def main ( n , p ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return P <NEWLINE> <DEDENT> global ans <NEWLINE> for i in range ( 2 , int ( p ** ( 2 / n ) ) ) : <NEWLINE> <INDENT> t = i ** n <NEWLINE> if p % t == 0 : <NEWLINE> <INDENT> ans *= i <NEWLINE> return main ( n , p // t ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( main ( N , P ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> <NL> N = int ( N ) <NEWLINE> A = int ( A ) <NEWLINE> <NL> if N % 500 <= A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
newArray = [ ] <NEWLINE> <NL> x = input ( ) <NEWLINE> <NL> while x != <STRING> : <NEWLINE> <INDENT> newArray . append ( x ) <NEWLINE> x = input ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( newArray ) ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i + 1 ) + <STRING> + newArray [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_a = max ( a ) <NEWLINE> b = [ 0 ] * ( max_a + 1 ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i ] += 1 <NEWLINE> if b [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , max_a + 1 , i ) : <NEWLINE> <INDENT> b [ j ] += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( b . count ( 1 ) ) <NEWLINE>
import sys <NEWLINE> from functools import reduce <NEWLINE> from collections import defaultdict <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def prime ( x ) : <NEWLINE> <INDENT> pf = defaultdict ( int ) <NEWLINE> for i in range ( 2 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while x % i == 0 : <NEWLINE> <INDENT> pf [ i ] += 1 <NEWLINE> x //= i <NEWLINE> <DEDENT> <DEDENT> if x > 1 : <NEWLINE> <INDENT> pf [ x ] = 1 <NEWLINE> <DEDENT> return pf <NEWLINE> <NL> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> xx = x . copy ( ) <NEWLINE> yy = y . copy ( ) <NEWLINE> for k , v in yy . items ( ) : <NEWLINE> <INDENT> xx [ k ] = max ( xx [ k ] , v ) <NEWLINE> <DEDENT> return xx <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a2 = list ( map ( prime , a ) ) <NEWLINE> lcms = reduce ( lcm , a2 ) <NEWLINE> lcmss = 1 <NEWLINE> for k , v in lcms . items ( ) : <NEWLINE> <INDENT> lcmss = ( lcmss * ( k ** v ) ) % mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for aa in a : <NEWLINE> <INDENT> ans += lcmss * pow ( aa , - 1 , mod ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> dp = [ 0 ] * 100001 <NEWLINE> for a in A : <NEWLINE> <INDENT> dp [ a ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> dp [ b ] += dp [ a ] <NEWLINE> S = S + ( b - a ) * dp [ a ] <NEWLINE> print ( S ) <NEWLINE> dp [ a ] = 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> sm = sum ( ar ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sm -= ar [ i ] <NEWLINE> count += ar [ i ] * sm <NEWLINE> <DEDENT> print ( count % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if True : <NEWLINE> <INDENT> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> <DEDENT> kosuu = 1 <NEWLINE> mae = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if mae == a [ i ] : <NEWLINE> <INDENT> kosuu += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mae = a [ i ] <NEWLINE> b . append ( kosuu ) <NEWLINE> kosuu = 1 <NEWLINE> <DEDENT> <DEDENT> b . append ( kosuu ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> for j in range ( 2 , 100 ) : <NEWLINE> <INDENT> if b [ i ] < j * ( j + 1 ) // 2 : <NEWLINE> <INDENT> ans += j - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Graph : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . edges = { } <NEWLINE> <NL> <DEDENT> def addVertex ( self , v ) : <NEWLINE> <INDENT> if v not in self . edges : <NEWLINE> <INDENT> self . edges [ v ] = [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> def addEdge ( self , from_v , to_v ) : <NEWLINE> <INDENT> if from_v not in self . edges : <NEWLINE> <INDENT> self . edges [ from_v ] = [ ] <NEWLINE> <DEDENT> if to_v not in self . edges [ from_v ] : <NEWLINE> <INDENT> self . edges [ from_v ] . append ( to_v ) <NEWLINE> <NL> <DEDENT> <DEDENT> def isEdge ( self , from_v , to_v ) : <NEWLINE> <INDENT> if to_v not in self . edges : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return to_v in self . edges [ from_v ] <NEWLINE> <NL> <DEDENT> <DEDENT> g = Graph ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> u , k , * v = map ( int , input ( ) . split ( ) ) <NEWLINE> g . addVertex ( u ) <NEWLINE> for j in v : <NEWLINE> <INDENT> g . addEdge ( u , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> adj = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> e = [ ] <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if g . isEdge ( i , j ) : <NEWLINE> <INDENT> e . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> adj . append ( e ) <NEWLINE> <NL> <DEDENT> for a in adj : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif N == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
import queue <NEWLINE> import copy <NEWLINE> q = queue . Queue ( ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( <STRING> + input ( ) + <STRING> ) for _ in range ( h ) ] <NEWLINE> a = [ [ <STRING> ] * ( w + 2 ) ] + a + [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> a1 = copy . deepcopy ( a ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> a = copy . deepcopy ( a1 ) <NEWLINE> if a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . put ( [ i , j , 0 ] ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> <NL> if a [ now [ 0 ] ] [ now [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> ans . append ( now [ 2 ] ) <NEWLINE> a [ now [ 0 ] ] [ now [ 1 ] ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if a [ now [ 0 ] + 1 ] [ now [ 1 ] ] != <STRING> : <NEWLINE> <INDENT> q . put ( [ now [ 0 ] + 1 , now [ 1 ] , now [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> if a [ now [ 0 ] - 1 ] [ now [ 1 ] ] != <STRING> : <NEWLINE> <INDENT> q . put ( [ now [ 0 ] - 1 , now [ 1 ] , now [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> if a [ now [ 0 ] ] [ now [ 1 ] + 1 ] != <STRING> : <NEWLINE> <INDENT> q . put ( [ now [ 0 ] , now [ 1 ] + 1 , now [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> if a [ now [ 0 ] ] [ now [ 1 ] - 1 ] != <STRING> : <NEWLINE> <INDENT> q . put ( [ now [ 0 ] , now [ 1 ] - 1 , now [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> a1 [ i ] [ j ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> PY = [ ] <NEWLINE> import bisect <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> PY . append ( ( p , y ) ) <NEWLINE> t = d . get ( p , [ 0 ] ) <NEWLINE> i = bisect . bisect_left ( t , y ) <NEWLINE> t . insert ( i , y ) <NEWLINE> d [ p ] = t <NEWLINE> <NL> <DEDENT> dx = { } <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> for i in range ( len ( v ) ) : <NEWLINE> <INDENT> dx [ ( k , v [ i ] ) ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> for p , y in PY : <NEWLINE> <INDENT> print ( str ( p ) . zfill ( 6 ) + str ( dx [ ( p , y ) ] ) . zfill ( 6 ) ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> <NL> ab = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> for ch in range ( h ) : <NEWLINE> <INDENT> for cw in range ( w ) : <NEWLINE> <INDENT> ab [ ch ] [ cw ] = abs ( a [ ch ] [ cw ] - b [ ch ] [ cw ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ab0 = ab [ 0 ] [ 0 ] <NEWLINE> size = 80 * ( h + w ) <NEWLINE> dp = [ [ 0 ] * w for hh in range ( h ) ] <NEWLINE> dp [ 0 ] [ 0 ] |= 2 ** ( size + ab0 ) <NEWLINE> dp [ 0 ] [ 0 ] |= 2 ** ( size - ab0 ) <NEWLINE> for ch in range ( h ) : <NEWLINE> <INDENT> for cw in range ( w ) : <NEWLINE> <INDENT> if ch < h - 1 : <NEWLINE> <INDENT> dp [ ch + 1 ] [ cw ] |= dp [ ch ] [ cw ] << ab [ ch + 1 ] [ cw ] <NEWLINE> dp [ ch + 1 ] [ cw ] |= dp [ ch ] [ cw ] >> ab [ ch + 1 ] [ cw ] <NEWLINE> <DEDENT> if cw < w - 1 : <NEWLINE> <INDENT> dp [ ch ] [ cw + 1 ] |= dp [ ch ] [ cw ] << ab [ ch ] [ cw + 1 ] <NEWLINE> dp [ ch ] [ cw + 1 ] |= dp [ ch ] [ cw ] >> ab [ ch ] [ cw + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a = dp [ h - 1 ] [ w - 1 ] >> size <NEWLINE> m = a & ( - a ) <NEWLINE> print ( m . bit_length ( ) - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> ad = R * G * B <NEWLINE> ed = 0 <NEWLINE> <NL> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> P = j + ( j - i ) <NEWLINE> if P < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ P ] and S [ P ] != S [ i ] : <NEWLINE> <INDENT> ed += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ad - ed ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> count = min ( abs ( X // D ) , K ) <NEWLINE> if X > 0 : <NEWLINE> <INDENT> X -= D * count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += D * count <NEWLINE> <DEDENT> K -= count <NEWLINE> if K > 0 : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - abs ( X ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> <NL> print ( S [ 0 ] + S [ 1 ] + S [ 2 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y , _ = map ( int , input ( ) . split ( ) ) <NEWLINE> xy . append ( ( x - 1 , y - 1 ) ) <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . li = list ( range ( n ) ) <NEWLINE> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . li [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . li [ x ] = self . root ( self . li [ x ] ) <NEWLINE> return self . li [ x ] <NEWLINE> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx = self . root ( x ) <NEWLINE> ry = self . root ( y ) <NEWLINE> if rx == ry : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . li [ ry ] = rx <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> uf . unite ( x , y ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> uf . root ( i ) <NEWLINE> <DEDENT> print ( len ( set ( uf . li ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> same = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = i <NEWLINE> if a * b >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> same += 1 <NEWLINE> while a * b < n : <NEWLINE> <INDENT> count += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count * 2 - same ) <NEWLINE>
def calc ( A , N , i ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> ai = A [ i ] <NEWLINE> for i in range ( i , N - 1 ) : <NEWLINE> <INDENT> aj = A [ i + 1 ] <NEWLINE> ans += ai * aj <NEWLINE> <DEDENT> return ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod_v = 10 ** 9 + 7 <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> if A [ i ] != 0 : <NEWLINE> <INDENT> ans [ i ] = calc ( A , N , i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if A [ j ] != 0 : <NEWLINE> <INDENT> ans [ j ] = ( ans [ j - 1 ] - A [ j - 1 ] * A [ j ] ) // A [ j - 1 ] * A [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for k in range ( 0 , N ) : <NEWLINE> <INDENT> ret += ans [ k ] <NEWLINE> <DEDENT> ret = ret % mod_v <NEWLINE> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> zz = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> def f ( s ) : <NEWLINE> <INDENT> if len ( s ) == N : <NEWLINE> <INDENT> return [ s ] <NEWLINE> <DEDENT> result = [ ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> r = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = int ( s [ - 1 ] ) <NEWLINE> <DEDENT> for i in range ( r , M ) : <NEWLINE> <INDENT> result . extend ( f ( s + str ( i ) ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> V = f ( <STRING> ) <NEWLINE> for s in V : <NEWLINE> <INDENT> A = [ int ( c ) + 1 for c in s ] <NEWLINE> t = 0 <NEWLINE> for a , b , c , d in zz : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> t += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> last_day = np . array ( [ - 1 for _ in range ( 26 ) ] ) <NEWLINE> satisfication = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] ) <NEWLINE> <NL> for day in range ( D ) : <NEWLINE> <INDENT> today_point_loss = C * ( day - last_day ) <NEWLINE> today_point = [ 0 for _ in range ( 26 ) ] <NEWLINE> for kind in range ( 26 ) : <NEWLINE> <INDENT> today_point [ kind ] = satisfication [ day ] [ kind ] - sum ( today_point_loss ) + today_point_loss [ kind ] <NEWLINE> <NL> <DEDENT> if day != D - 1 : <NEWLINE> <INDENT> tmp_score = - 1 * float ( <STRING> ) <NEWLINE> for kind in range ( 26 ) : <NEWLINE> <INDENT> nday_point_loss = C * ( ( day + 1 ) - last_day ) <NEWLINE> nday_point = [ 0 for _ in range ( 26 ) ] <NEWLINE> <NL> for nkind in range ( 26 ) : <NEWLINE> <INDENT> if kind != nkind : <NEWLINE> <INDENT> nday_point [ nkind ] = satisfication [ day + 1 ] [ nkind ] - sum ( nday_point_loss ) + nday_point_loss [ nkind ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nday_point [ nkind ] = satisfication [ day + 1 ] [ nkind ] - sum ( nday_point_loss ) + C [ nkind ] <NEWLINE> <NL> <DEDENT> if today_point [ kind ] + nday_point [ nkind ] > tmp_score : <NEWLINE> <INDENT> tmp_score = today_point [ kind ] + nday_point [ nkind ] <NEWLINE> out = kind <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> out = np . argmax ( today_point ) <NEWLINE> <NL> <DEDENT> last_day [ out ] = day <NEWLINE> print ( out + 1 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> A = list ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> print ( min ( A ) , max ( A ) , sum ( A ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> edge [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( v , LIS ) : <NEWLINE> <INDENT> if len ( edge [ v ] ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for u in edge [ v ] : <NEWLINE> <INDENT> if visited [ u ] == False : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> if A [ u ] > LIS [ - 1 ] : <NEWLINE> <INDENT> LIS . append ( A [ u ] ) <NEWLINE> ans [ u ] = len ( LIS ) <NEWLINE> dfs ( u , LIS ) <NEWLINE> LIS . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = bisect_left ( LIS , A [ u ] ) <NEWLINE> stack = LIS [ ind ] <NEWLINE> LIS [ ind ] = A [ u ] <NEWLINE> ans [ u ] = len ( LIS ) <NEWLINE> dfs ( u , LIS ) <NEWLINE> LIS [ ind ] = stack <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> visited = [ False ] * N <NEWLINE> visited [ 0 ] = True <NEWLINE> LIS = [ A [ 0 ] ] <NEWLINE> ans [ 0 ] = 1 <NEWLINE> dfs ( 0 , LIS ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rect = ( <STRING> * w + <STRING> ) * h <NEWLINE> print ( rect ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( N ) <NEWLINE> temp = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
totalNumbers = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 1 <NEWLINE> if 0 in array : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for number in array : <NEWLINE> <INDENT> answer *= number <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> moji = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> x = int ( n % 26 ) <NEWLINE> ans = moji [ n % 26 ] + ans <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k * 1 ) <NEWLINE> <NL> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( 1 * a ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> num = k - ( a + b ) <NEWLINE> print ( 1 * a - num * 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( a , b ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> now = max ( a , b ) <NEWLINE> ans = min ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> from collections import Counter <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , * s = read ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> sc = Counter ( s ) <NEWLINE> scm = sc . most_common ( ) <NEWLINE> maxnum = scm [ 0 ] [ 1 ] <NEWLINE> r = [ ] <NEWLINE> for scme in scm : <NEWLINE> <INDENT> if scme [ 1 ] == maxnum : <NEWLINE> <INDENT> r . append ( scme [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> r . sort ( ) <NEWLINE> print ( * r , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> % ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> room = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> room [ a - 1 ] . append ( b ) <NEWLINE> room [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> point = [ 0 for i in range ( n ) ] <NEWLINE> d = deque ( [ 0 ] ) <NEWLINE> <NL> while len ( d ) > 0 : <NEWLINE> <INDENT> p = d . popleft ( ) <NEWLINE> for v in room [ p ] : <NEWLINE> <INDENT> if point [ v - 1 ] == 0 : <NEWLINE> <INDENT> d . append ( v - 1 ) <NEWLINE> point [ v - 1 ] = p + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( point [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> lst = deque ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> <NL> if <STRING> == cmd [ 0 ] : <NEWLINE> <INDENT> lst . appendleft ( cmd [ 1 ] ) <NEWLINE> <DEDENT> if <STRING> == cmd [ 0 ] : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lst . remove ( cmd [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if <STRING> == cmd [ 0 ] : <NEWLINE> <INDENT> lst . popleft ( ) <NEWLINE> <DEDENT> if <STRING> == cmd [ 0 ] : <NEWLINE> <INDENT> lst . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> sep = <STRING> <NEWLINE> for n in lst : <NEWLINE> <INDENT> print ( sep + n , end = <STRING> ) <NEWLINE> sep = <STRING> <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
def ismof9 ( n ) : <NEWLINE> <INDENT> _str = str ( n ) <NEWLINE> _sum = 0 <NEWLINE> for ch in _str : <NEWLINE> <INDENT> _sum += int ( ch ) <NEWLINE> <DEDENT> if _sum % 9 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( ismof9 ( n ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> def dp_func ( n , dp , h ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return dp [ 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if dp [ n - 1 ] == - 1 : <NEWLINE> <INDENT> dp [ n - 1 ] = dp_func ( n - 1 , dp , h ) <NEWLINE> <NL> <DEDENT> c1 = dp [ n - 1 ] + abs ( h [ n ] - h [ n - 1 ] ) <NEWLINE> <NL> if dp [ n - 2 ] == - 1 : <NEWLINE> <INDENT> dp [ n - 2 ] = dp_func ( n - 2 , dp , h ) <NEWLINE> <NL> <DEDENT> c2 = dp [ n - 2 ] + abs ( h [ n ] - h [ n - 2 ] ) <NEWLINE> <NL> dp [ n ] = min ( c1 , c2 ) <NEWLINE> return dp [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> dp = [ - 1 for n in range ( N ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> return dp_func ( N - 1 , dp , h ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import math <NEWLINE> K = [ i for i in range ( 1 , int ( input ( ) ) + 1 ) ] <NEWLINE> numbers = itertools . combinations_with_replacement ( K , 3 ) <NEWLINE> <NL> sum_gcd = 0 <NEWLINE> for i in numbers : <NEWLINE> <INDENT> a = math . gcd ( i [ 0 ] , i [ 1 ] ) <NEWLINE> b = math . gcd ( a , i [ 2 ] ) <NEWLINE> <NL> if i [ 0 ] != i [ 1 ] != i [ 2 ] : <NEWLINE> <INDENT> sum_gcd += b * 6 <NEWLINE> <DEDENT> elif i [ 0 ] == i [ 1 ] == i [ 2 ] : <NEWLINE> <INDENT> sum_gcd += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_gcd += b * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_gcd ) <NEWLINE>
def num ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( y + 1 ) <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( y , w - 1 , - 1 ) : <NEWLINE> <INDENT> num = dp [ j - w ] + v <NEWLINE> if num > dp [ j ] : <NEWLINE> <INDENT> dp [ j ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> num ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> length = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> As . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> check = np . zeros ( 10 ** 6 + 1 ) <NEWLINE> <NL> answer = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( length ) : <NEWLINE> <INDENT> if check [ As [ i ] ] == 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> check [ : : As [ i ] ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if i == ( length - 1 ) or As [ i ] != As [ i + 1 ] : <NEWLINE> <INDENT> answer = answer + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> f = 0 <NEWLINE> d = 1 <NEWLINE> e = 1 <NEWLINE> for i in range ( n - k ) : <NEWLINE> <NL> <NL> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> t = input ( ) <NEWLINE> tl = list ( t ) <NEWLINE> tln = len ( t ) <NEWLINE> x = 0 <NEWLINE> for x in range ( tln ) : <NEWLINE> <INDENT> if tl [ x ] == <STRING> : <NEWLINE> <INDENT> if x == tln - 1 : <NEWLINE> <INDENT> tl [ x ] = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> if tl [ x + 1 ] == <STRING> : <NEWLINE> <INDENT> tl [ x ] = <STRING> <NEWLINE> tl [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif tl [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> tl [ x ] = <STRING> <NEWLINE> <DEDENT> elif tl [ x + 1 ] == <STRING> : <NEWLINE> <INDENT> tl [ x ] = <STRING> <NEWLINE> tl [ x + 1 ] = <STRING> <NEWLINE> <DEDENT> elif tl [ x + 1 ] == <STRING> : <NEWLINE> <INDENT> tl [ x ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl [ x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> t = <STRING> . join ( tl ) <NEWLINE> print ( t ) <NEWLINE>
import heapq <NEWLINE> import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> ticket_num = m <NEWLINE> heapq . heapify ( a ) <NEWLINE> <NL> if n > 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> MAX = heapq . heappop ( a ) <NEWLINE> MAX = math . ceil ( MAX / 2 ) <NEWLINE> heapq . heappush ( a , MAX ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> MAX = heapq . heappop ( a ) <NEWLINE> MAX = math . ceil ( MAX / ( 2 ** m ) ) <NEWLINE> heapq . heappush ( a , MAX ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( b - a + 1 ) <= 2 * k : <NEWLINE> <INDENT> count = a <NEWLINE> while count <= b : <NEWLINE> <INDENT> print ( count ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( a + i ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> print ( b - ( ( k - 1 ) - i ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> X , Y , A , B , C = map ( int , readline ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> Q = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> R = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> P = sorted ( P , reverse = True ) <NEWLINE> Q = sorted ( Q , reverse = True ) <NEWLINE> R = sorted ( R , reverse = True ) <NEWLINE> P = P [ : X ] <NEWLINE> Q = Q [ : Y ] <NEWLINE> PQR = sorted ( P + Q + R , reverse = True ) <NEWLINE> ans = sum ( PQR [ : X + Y ] ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> mls = [ - 1 for _ in range ( N + 1 ) ] <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> mls [ i ] = max ( mls [ i - 1 ] , a ) <NEWLINE> <NL> <DEDENT> mrs = [ - 1 for _ in range ( N + 1 ) ] <NEWLINE> for i , a in enumerate ( A [ : : - 1 ] , 1 ) : <NEWLINE> <INDENT> mrs [ i ] = max ( mrs [ i - 1 ] , a ) <NEWLINE> <DEDENT> mrs = mrs [ : : - 1 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( max ( mls [ i ] , mrs [ i + 1 ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> B = 1 <NEWLINE> C = 10 ** 18 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B = B * A [ i ] <NEWLINE> if B == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif B > C : <NEWLINE> <INDENT> B = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( B ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> def abc162d ( n , s ) : <NEWLINE> <NL> <INDENT> r_arr = [ ] <NEWLINE> g_arr = [ ] <NEWLINE> b_arr = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r_arr . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g_arr . append ( i ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> b_arr . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> min1_arr = r_arr <NEWLINE> min2_arr = g_arr <NEWLINE> max_arr = b_arr <NEWLINE> if len ( r_arr ) < len ( g_arr ) and len ( b_arr ) < len ( g_arr ) : <NEWLINE> <INDENT> min1_arr = r_arr <NEWLINE> min2_arr = b_arr <NEWLINE> max_arr = g_arr <NEWLINE> <DEDENT> elif len ( g_arr ) < len ( r_arr ) and len ( b_arr ) < len ( r_arr ) : <NEWLINE> <INDENT> min1_arr = g_arr <NEWLINE> min2_arr = b_arr <NEWLINE> max_arr = r_arr <NEWLINE> <NL> <DEDENT> max_dict = dict ( ) <NEWLINE> for elem in max_arr : <NEWLINE> <INDENT> max_dict [ elem ] = 1 <NEWLINE> <NL> <DEDENT> except_num = 0 <NEWLINE> for r_i in min1_arr : <NEWLINE> <INDENT> for g_i in min2_arr : <NEWLINE> <INDENT> min_i = r_i <NEWLINE> max_i = g_i <NEWLINE> if g_i < r_i : <NEWLINE> <INDENT> min_i = g_i <NEWLINE> max_i = r_i <NEWLINE> <DEDENT> diff = max_i - min_i <NEWLINE> minmin = min_i - diff <NEWLINE> maxmax = max_i + diff <NEWLINE> exists_central = ( max_i + min_i ) % 2 <NEWLINE> <NL> if minmin in max_dict : <NEWLINE> <INDENT> except_num += 1 <NEWLINE> <DEDENT> if maxmax in max_dict : <NEWLINE> <INDENT> except_num += 1 <NEWLINE> <DEDENT> if exists_central == 0 : <NEWLINE> <INDENT> central = ( max_i + min_i ) / 2 <NEWLINE> if central in max_dict : <NEWLINE> <INDENT> except_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = len ( r_arr ) * len ( g_arr ) * len ( b_arr ) - except_num <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = abc162d ( n , s ) <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> r = { v : i for i , v in enumerate ( d ) } <NEWLINE> sz = [ 1 ] * n <NEWLINE> dsorted = sorted ( ( ( di , i ) for i , di in enumerate ( d ) ) , reverse = True ) <NEWLINE> ans = [ ] <NEWLINE> to = [ [ ] for _ in range ( n ) ] <NEWLINE> for di , i in dsorted [ : n - 1 ] : <NEWLINE> <INDENT> nd = di + ( sz [ i ] - 1 ) - ( n - 2 - ( sz [ i ] - 1 ) ) <NEWLINE> if not nd in r : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = r [ nd ] <NEWLINE> to [ p ] . append ( i ) <NEWLINE> sz [ p ] += sz [ i ] <NEWLINE> ans . append ( ( i + 1 , p + 1 ) ) <NEWLINE> <NL> <DEDENT> root = dsorted [ - 1 ] [ 1 ] <NEWLINE> def dfs ( u , cur = 0 ) : <NEWLINE> <INDENT> rv = cur <NEWLINE> for v in to [ u ] : <NEWLINE> <INDENT> rv += dfs ( v , cur + 1 ) <NEWLINE> <DEDENT> return rv <NEWLINE> <NL> <DEDENT> if dfs ( root ) != d [ root ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for u , v in ans : <NEWLINE> <INDENT> print ( u , v ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i , A in enumerate ( A_list ) : <NEWLINE> <INDENT> L . append ( i + A ) <NEWLINE> R . append ( i - A ) <NEWLINE> <NL> <NL> <DEDENT> import collections <NEWLINE> r_dict = collections . Counter ( R ) <NEWLINE> ans = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> ans += r_dict . get ( l , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = pi * r ** 2 <NEWLINE> circumference = 2 * pi * r <NEWLINE> print ( area , circumference ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> if K == N : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> ans = ( ans * x ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> plus , minus = [ ] , [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> plus . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( ) <NEWLINE> <NL> if not plus : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if K % 2 : <NEWLINE> <COMMENT> <NL> <INDENT> for x in minus [ - K : ] : <NEWLINE> <INDENT> ans = ( ans * x ) % MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> for x in minus [ : K ] : <NEWLINE> <INDENT> ans = ( ans * x ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> idx = 0 <NEWLINE> for i in range ( 2 , N , 2 ) : <NEWLINE> <INDENT> if K - i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if not len ( plus ) >= K - i + 2 : <NEWLINE> <INDENT> idx += 2 <NEWLINE> continue <NEWLINE> <DEDENT> if len ( minus ) >= i : <NEWLINE> <INDENT> if minus [ i - 2 ] * minus [ i - 1 ] < plus [ K - i + 1 ] * plus [ K - i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for x in minus [ : idx ] + plus [ : K - idx ] : <NEWLINE> <INDENT> ans = ( ans * x ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - x - y <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if B - 1 >= N : <NEWLINE> <INDENT> num = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = B - 1 <NEWLINE> <NL> <DEDENT> print ( math . floor ( A * num / B ) - A * math . floor ( num / B ) ) <NEWLINE>
r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n // r + 1 ) : <NEWLINE> <INDENT> for j in range ( n // g + 1 ) : <NEWLINE> <INDENT> m = r * i + g * j <NEWLINE> if m <= n and ( n - m ) % b == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif m > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> def show ( ) : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> print ( i , i ** 5 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( X : int ) : <NEWLINE> <INDENT> A = [ ( i ** 5 , i ) for i in range ( 1000 ) ] <NEWLINE> for a , b in A : <NEWLINE> <INDENT> for aa , bb in A : <NEWLINE> <INDENT> if a - aa == X : <NEWLINE> <INDENT> return b , bb <NEWLINE> <DEDENT> if a + aa == X : <NEWLINE> <INDENT> return b , - bb <NEWLINE> <DEDENT> <DEDENT> <DEDENT> raise <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> X = int ( next ( tokens ) ) <COMMENT> <NEWLINE> print ( * solve ( X ) ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <DEDENT>
from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_array = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> m_array = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> array = [ ] <NEWLINE> for j in range ( n + 1 ) : <NEWLINE> <INDENT> x = combinations ( a_array , j ) <NEWLINE> for y in x : <NEWLINE> <INDENT> array . append ( sum ( y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for m in m_array : <NEWLINE> <INDENT> print ( <STRING> if m in array else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> for a in range ( - 118 , 120 , 1 ) : <NEWLINE> <INDENT> for b in range ( - 118 , 120 , 1 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> from collections import Counter <NEWLINE> <NL> A_C = Counter ( A ) <NEWLINE> A_C = sorted ( A_C . items ( ) , key = lambda x : - x [ 0 ] ) <NEWLINE> <NL> if 0 == A_C [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for a in A_C : <NEWLINE> <INDENT> result *= ( a [ 0 ] ** a [ 1 ] ) <NEWLINE> <NL> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> item = input ( ) <NEWLINE> a . append ( item ) <NEWLINE> <DEDENT> print ( len ( list ( set ( a ) ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> llist = [ ] <NEWLINE> rlist = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> llist += [ l ] <NEWLINE> rlist += [ r ] <NEWLINE> <NL> <DEDENT> print ( max ( 0 , min ( rlist ) - max ( llist ) + 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> suma = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> suma -= a [ i ] <NEWLINE> ans += ( a [ i ] * ( suma ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( int ( ans % ( 10 ** 9 + 7 ) ) ) <NEWLINE>
<NL> import sys <NEWLINE> from itertools import combinations <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> A = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += CA [ i ] [ 0 ] <NEWLINE> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> A [ j ] += CA [ i ] [ j ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if A [ i ] < X : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for e in combinations ( range ( N ) , i ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> A = [ 0 ] * M <NEWLINE> for f in e : <NEWLINE> <INDENT> c += CA [ f ] [ 0 ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> A [ j ] += CA [ f ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> if min ( A ) >= X : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( key = lambda B : B [ 1 ] , reverse = True ) <NEWLINE> <NL> i = j = 0 <NEWLINE> ans = sum ( A ) <NEWLINE> while j < n : <NEWLINE> <INDENT> newv = B [ i ] [ 1 ] <NEWLINE> newc = min ( B [ i ] [ 0 ] , n - j ) <NEWLINE> if newv > A [ j ] : <NEWLINE> <INDENT> for k in range ( newc ) : <NEWLINE> <INDENT> if newv <= A [ j + k ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> ans += newv * ( k ) - sum ( A [ j : j + k ] ) <NEWLINE> i += 1 <NEWLINE> j += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i >= m : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def do ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> B = [ 0 ] * ( n ) <NEWLINE> B [ 0 ] = sum ( A [ 1 : ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> B [ i ] = ( B [ i - 1 ] - A [ i ] ) % mod <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += ( A [ i ] * B [ i ] ) % mod <NEWLINE> ans = ans % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> trees = [ list ( input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> <NL> class BinaryTree : <NEWLINE> <INDENT> def __init__ ( self , key , p = None , l = None , r = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . p = p <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> <NL> <DEDENT> <DEDENT> def Insert ( root , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . r <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . l = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . r = z <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def preOrder ( x ) : <NEWLINE> <INDENT> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> global preList <NEWLINE> preList . append ( x . key ) <NEWLINE> <NL> preOrder ( x . l ) <NEWLINE> preOrder ( x . r ) <NEWLINE> <NL> <DEDENT> def inOrder ( x ) : <NEWLINE> <INDENT> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inOrder ( x . l ) <NEWLINE> <NL> global inList <NEWLINE> inList . append ( x . key ) <NEWLINE> <NL> inOrder ( x . r ) <NEWLINE> <NL> <DEDENT> def Find ( x , target ) : <NEWLINE> <INDENT> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if target < x . key : <NEWLINE> <INDENT> x = x . l <NEWLINE> <DEDENT> elif target > x . key : <NEWLINE> <INDENT> x = x . r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> root = None <NEWLINE> for data in trees : <NEWLINE> <INDENT> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> z = BinaryTree ( int ( data [ 1 ] ) ) <NEWLINE> root = Insert ( root , z ) <NEWLINE> <DEDENT> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> Find ( root , int ( data [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> inList = [ ] <NEWLINE> preList = [ ] <NEWLINE> inOrder ( root ) <NEWLINE> a = <STRING> + <STRING> . join ( [ str ( num ) for num in inList ] ) <NEWLINE> print ( a ) <NEWLINE> <NL> preOrder ( root ) <NEWLINE> a = <STRING> + <STRING> . join ( [ str ( num ) for num in preList ] ) <NEWLINE> print ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> b = - 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == b : <NEWLINE> <INDENT> if ans != 0 : <NEWLINE> <INDENT> ans *= i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = i <NEWLINE> b = - 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> b = i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> connect = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> connect [ a ] . append ( b ) <NEWLINE> connect [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> color = [ - 1 ] * n <NEWLINE> color [ 0 ] = 0 <NEWLINE> explored = { 0 } <NEWLINE> next = deque ( [ 0 ] ) <NEWLINE> exploring = deque ( ) <NEWLINE> Yes = True <NEWLINE> explored . add ( 0 ) <NEWLINE> while next : <NEWLINE> <INDENT> now = next . popleft ( ) <NEWLINE> for a in connect [ now ] : <NEWLINE> <INDENT> if color [ a ] != - 1 : <NEWLINE> <INDENT> if color [ a ] != ( color [ now ] + 1 ) % 2 : <NEWLINE> <INDENT> Yes = False <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> color [ a ] = ( color [ now ] + 1 ) % 2 <NEWLINE> next . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE> <DEDENT> if Yes : <NEWLINE> <INDENT> s = sum ( color ) <NEWLINE> print ( s * ( n - s ) - m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * ( n - 1 ) // 2 - m ) <NEWLINE> <DEDENT>
from sys import setrecursionlimit <NEWLINE> <NL> <NL> def dfs ( i , j , c ) : <NEWLINE> <INDENT> visited [ i ] [ j ] = 1 <NEWLINE> current . append ( ( i , j ) ) <NEWLINE> for di , dj in ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) : <NEWLINE> <INDENT> ni , nj = i + di , j + dj <NEWLINE> if not ( 0 <= ni < H and 0 <= nj < W and not visited [ ni ] [ nj ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ ni ] [ nj ] == c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( ni , nj , not c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> setrecursionlimit ( 2 * 10 ** 5 ) <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ [ c == <STRING> for c in input ( ) ] for _ in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> visited = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] and not visited [ i ] [ j ] : <NEWLINE> <INDENT> current = [ ] <NEWLINE> dfs ( i , j , True ) <NEWLINE> b , w = 0 , 0 <NEWLINE> for k , l in current : <NEWLINE> <INDENT> if S [ k ] [ l ] : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> <DEDENT> ans += b * w <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> a = set ( a ) <NEWLINE> <NL> for k in a : <NEWLINE> <INDENT> for l in range ( k * 2 , ( 10 ** 6 + 1 ) , k ) : <NEWLINE> <INDENT> cnt [ l ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for m in a : <NEWLINE> <INDENT> if cnt [ m ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ ] <NEWLINE> for _ in range ( K ) : LR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> MOD = 998244353 <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for L , R in LR : <NEWLINE> <INDENT> if i + L < N : dp [ i + L ] += dp [ i ] <NEWLINE> if i + R + 1 < N : dp [ i + R + 1 ] -= dp [ i ] <NEWLINE> <DEDENT> if i > 0 : dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i ] ) % MOD <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += math . gcd ( x , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> judge = 0 <NEWLINE> a . append ( <STRING> ) <NEWLINE> a . append ( 7 % k ) <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> a . append ( ( a [ i - 1 ] * 10 + 7 ) % k ) <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> judge = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if judge == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> <NL> <NL> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> m *= i <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> <NL> def cumsum ( a ) : <NEWLINE> <INDENT> r = [ 0 ] <NEWLINE> for v in a : <NEWLINE> <INDENT> r . append ( r [ - 1 ] + v ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> a_cumsum = cumsum ( a ) <NEWLINE> b_cumsum = cumsum ( b ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for a_num , v in enumerate ( a_cumsum ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> if k >= v : <NEWLINE> <INDENT> b_num = bisect . bisect_right ( b_cumsum , k - v ) - 1 <NEWLINE> <COMMENT> <NL> tmp = a_num + b_num <NEWLINE> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dic1 = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s not in dic1 . keys ( ) : <NEWLINE> <INDENT> dic1 [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic1 [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> dic2 = sorted ( dic1 . items ( ) , key = lambda j : j [ 1 ] , reverse = True ) <NEWLINE> <NL> ans_ls = [ ] <NEWLINE> for k in range ( len ( dic2 ) ) : <NEWLINE> <INDENT> if dic2 [ k ] [ 1 ] != dic2 [ 0 ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans_ls . append ( dic2 [ k ] [ 0 ] ) <NEWLINE> <DEDENT> ans_ls . sort ( ) <NEWLINE> for _ in ans_ls : <NEWLINE> <INDENT> print ( _ ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> c = 0 <NEWLINE> m = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> m = max ( c , m ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> m = max ( c , m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( c , m ) <NEWLINE> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> n = 7 % k <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( n * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> timeA , timeB = 0 , 0 <NEWLINE> numA , numB = 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if timeA + A [ i ] <= K : <NEWLINE> <INDENT> numA += 1 <NEWLINE> timeA += A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if timeB + B [ i ] <= K - timeA : <NEWLINE> <INDENT> numB += 1 <NEWLINE> timeB += B [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = numA + numB <NEWLINE> t = numA <NEWLINE> for i in reversed ( range ( numA ) ) : <NEWLINE> <INDENT> t -= 1 <NEWLINE> timeA -= A [ i ] <NEWLINE> while numB < M : <NEWLINE> <INDENT> if timeB + B [ numB ] <= K - timeA : <NEWLINE> <INDENT> timeB += B [ numB ] <NEWLINE> numB += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , t + numB ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> size = len ( S ) <NEWLINE> ans = 0 <NEWLINE> d = [ 0 ] * 2019 <NEWLINE> pre = <STRING> <NEWLINE> ln = 0 <NEWLINE> v = 1 <NEWLINE> <NL> for i in range ( 1 , size + 1 ) : <NEWLINE> <INDENT> md = ( ln + ( int ( S [ - 1 * i ] ) * v ) ) % 2019 <NEWLINE> d [ md ] += 1 <NEWLINE> ln = md <NEWLINE> v *= 10 <NEWLINE> v %= 2019 <NEWLINE> <NL> <DEDENT> d [ 0 ] += 1 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += d [ i ] * ( d [ i ] - 1 ) / 2 <COMMENT> <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> n = I ( ) <NEWLINE> d = LI ( ) <NEWLINE> m = I ( ) <NEWLINE> t = LI ( ) <NEWLINE> d . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> c_t = Counter ( t ) <NEWLINE> c_d = Counter ( d ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> c_d = dict ( [ ( k , v ) for k , v in c_d . items ( ) if k in c_t . keys ( ) ] ) <NEWLINE> if len ( c_d ) != len ( c_t ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for ( k_t , v_t ) , ( k_d , v_d ) in zip ( c_t . items ( ) , c_d . items ( ) ) : <NEWLINE> <INDENT> if v_t > v_d : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> read = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <COMMENT> <NL> A , B , C , K = map ( int , read ( ) . split ( ) ) <NEWLINE> print ( K if A >= K else A if K - A <= B else A - ( K - A - B ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> sign = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans [ 0 ] += sign * a <NEWLINE> sign *= - 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans [ i ] = 2 * A [ 0 ] - ans [ i - 1 ] <NEWLINE> <NL> t = A . pop ( 0 ) <NEWLINE> A . append ( t ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> tmp = a [ i ] <NEWLINE> tmp1 = a [ i + k ] <NEWLINE> if tmp1 > tmp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> l = 2.0 * r * math . pi <NEWLINE> <NL> print ( s , l ) <NEWLINE>
import sys <NEWLINE> K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> i = 1 <NEWLINE> K = 9 * K <NEWLINE> ans = 10 - K <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> if 7 * ( ans - 1 ) % K == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> ans = ans * 10 % K <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = 0 <NEWLINE> num = 1 <NEWLINE> <NL> while num <= N : <NEWLINE> <INDENT> D = D + L [ num - 1 ] <NEWLINE> if D > X : <NEWLINE> <INDENT> print ( num ) <NEWLINE> break <NEWLINE> <DEDENT> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N + 1 ) <NEWLINE> <DEDENT>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> N = I ( ) <NEWLINE> <NL> MAX = 10 ** 18 <NEWLINE> result = 1 <NEWLINE> A = FLI ( ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> result *= int ( i ) <NEWLINE> if result > MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import collections <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> k = int ( input ( ) ) <NEWLINE> cnt = collections . defaultdict ( int ) <NEWLINE> for i in range ( 1 , k + 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cnt [ gcd ( i , j ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <COMMENT> <NEWLINE> <INDENT> for key in cnt . keys ( ) : <NEWLINE> <INDENT> ans += gcd ( i , key ) * cnt [ key ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
number = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , number ) : <NEWLINE> <INDENT> temp = number - 1 <NEWLINE> temp_solution = int ( temp / i ) <NEWLINE> count += temp_solution <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N < 1000 : <NEWLINE> <INDENT> print ( 1000 - N ) <NEWLINE> return <NEWLINE> <DEDENT> N = str ( N ) <NEWLINE> N = N [ - 3 ] + N [ - 2 ] + N [ - 1 ] <NEWLINE> N = int ( N ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( 1000 - N ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> c = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ <NEWLINE> <INDENT> tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for _ in range ( d ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> m = 0 <NEWLINE> ans = [ ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for i in range ( d ) : <NEWLINE> <COMMENT> <NL> <INDENT> mdmax = - 10000000000000000 <NEWLINE> mdi = 0 <NEWLINE> for j , ss in enumerate ( s [ i ] ) : <NEWLINE> <INDENT> md = 0 <NEWLINE> <COMMENT> <NL> for k in range ( 26 ) : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> md += ss <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> md -= ( i - last [ k ] ) * c [ k ] <NEWLINE> <DEDENT> <DEDENT> if md > mdmax : <NEWLINE> <INDENT> mdi = j <NEWLINE> mdmax = md <NEWLINE> <DEDENT> <DEDENT> ans . append ( mdi + 1 ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if j == mdi : <NEWLINE> <INDENT> last [ j ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> m = float ( math . pi ) <NEWLINE> s = r * r * m <NEWLINE> l = 2 * r * m <NEWLINE> print ( s , l ) <NEWLINE>
N = 300000 <NEWLINE> a = [ ( ( i % 7 == 1 ) or ( i % 7 == 6 ) ) for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> a [ 1 ] = 0 <NEWLINE> p = [ ] <NEWLINE> for i in range ( 6 , N ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> p += [ i ] <NEWLINE> for j in range ( i * i , N , i ) : <NEWLINE> <INDENT> a [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( n , end = <STRING> ) <NEWLINE> for x in p : <NEWLINE> <INDENT> if n % x == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( x ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
from math import * <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> T = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> ans = T [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans * T [ i ] // gcd ( ans , T [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] != s [ j ] : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= n or j >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] != s [ k ] != s [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> deta = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> deta [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for j in range ( n + 1 ) : <NEWLINE> <INDENT> if deta [ j ] > 1 : <NEWLINE> <INDENT> ans [ j ] = deta [ j ] * ( deta [ j ] - 1 ) / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> add = sum ( ans ) <NEWLINE> <NL> for k in a : <NEWLINE> <INDENT> print ( int ( add - deta [ k ] * ( deta [ k ] - 1 ) / 2 + ( deta [ k ] - 1 ) * ( deta [ k ] - 2 ) / 2 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> li = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i , a in enumerate ( a_li ) : <NEWLINE> <INDENT> ans += ( i + 1 ) * a <NEWLINE> <NL> <DEDENT> for i , a in enumerate ( a_li [ : : - 1 ] ) : <NEWLINE> <INDENT> if i >= 1 : <NEWLINE> <INDENT> li [ i ] = li [ i - 1 ] + a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li [ i ] = a <NEWLINE> <NL> <DEDENT> <DEDENT> li = li [ : : - 1 ] <NEWLINE> <NL> flag = True <NEWLINE> ne = 0.5 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if li [ i ] > 2 * ne : <NEWLINE> <INDENT> ans -= li [ i ] - int ( 2 * ne ) <NEWLINE> <NL> <NL> <DEDENT> ne = min ( li [ i ] - a_li [ i ] , int ( 2 * ne ) - a_li [ i ] ) <NEWLINE> <NL> if ( i == n and ne != 0 ) or ( i != n and ne <= 0 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <COMMENT> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> boolean = True <NEWLINE> while boolean : <NEWLINE> <INDENT> if is_prime ( x ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> abl = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> abl [ a ] . append ( b ) <NEWLINE> abl [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> an = [ 0 ] * ( n + 1 ) <NEWLINE> an [ 0 ] = 1 <NEWLINE> tg = deque ( [ 1 ] ) <NEWLINE> while len ( tg ) : <NEWLINE> <INDENT> itg = tg . popleft ( ) <NEWLINE> for j in abl [ itg ] : <NEWLINE> <INDENT> if an [ j ] == 0 : <NEWLINE> <INDENT> an [ j ] = itg <NEWLINE> tg . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if all ( an ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for j in an [ 2 : ] : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def read_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def read_ints ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def read_lines ( N ) : <NEWLINE> <INDENT> return [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = read_ints ( ) <NEWLINE> towns = [ int ( t ) - 1 for t in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <NL> loop = [ ] <NEWLINE> loop_set = set ( ) <NEWLINE> next_town = towns [ 0 ] <NEWLINE> while next_town not in loop_set : <NEWLINE> <COMMENT> <NL> <INDENT> loop . append ( next_town ) <NEWLINE> loop_set . add ( next_town ) <NEWLINE> next_town = towns [ next_town ] <NEWLINE> <NL> <DEDENT> i = loop . index ( next_town ) <NEWLINE> all_loop = loop <NEWLINE> pre_loop = loop [ : i ] <NEWLINE> loop = loop [ i : ] <NEWLINE> pre_length = len ( pre_loop ) <NEWLINE> loop_length = len ( loop ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> if K - 1 < len ( all_loop ) : <NEWLINE> <INDENT> print ( all_loop [ K - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = ( ( K - 1 - pre_length ) % loop_length ) <NEWLINE> <COMMENT> <NL> print ( loop [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 1000000007 <NEWLINE> <NL> a = sum ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a -= A [ i ] <NEWLINE> ans += A [ i ] * a <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from math import gcd <NEWLINE> gcd_sum = [ 0 ] * 201 <NEWLINE> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd_sum [ i ] += gcd ( i , j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> ans += gcd_sum [ g ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( end = <STRING> ) <NEWLINE> print ( * l ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> dic = defaultdict ( int ) <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> dic [ i - a ] += 1 <NEWLINE> <NL> <DEDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ans += dic [ a + i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from pprint import pprint <NEWLINE> import numpy as np <NEWLINE> import numba as nb <NEWLINE> @ nb . njit <NEWLINE> def Knapsack1 ( n , w , wl , vl ) : <NEWLINE> <INDENT> dp = np . zeros ( shape = ( n + 1 , w + 1 ) , dtype = np . int64 ) <NEWLINE> for wsum in range ( 1 , w + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if wsum >= wl [ i ] : <NEWLINE> <INDENT> if dp [ i ] [ wsum ] < dp [ i ] [ wsum - wl [ i ] ] + vl [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 ] [ wsum ] = dp [ i ] [ wsum - wl [ i ] ] + vl [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ wsum ] = dp [ i ] [ wsum ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ wsum ] = dp [ i ] [ wsum ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ - 1 ] ) <NEWLINE> <NL> <DEDENT> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> wv = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> wv . sort ( key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) <NEWLINE> wv = np . array ( wv ) <NEWLINE> wv = wv . T <NEWLINE> wl = wv [ 0 ] <NEWLINE> vl = wv [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> Knapsack1 ( n , w , wl , vl ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in li : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans > int ( 1e18 ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > int ( 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> sa = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) <NEWLINE> sa . append ( line ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( sa ) ) ) <NEWLINE>
def Convert ( N ) : <NEWLINE> <INDENT> if N > 0 : return <STRING> <NEWLINE> else : return <STRING> <NEWLINE> <NL> <DEDENT> N , K , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Win = [ K - Q ] * N <NEWLINE> for T in range ( 0 , Q ) : <NEWLINE> <INDENT> Win [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( list ( map ( Convert , Win ) ) ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> readline = stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> listN = list ( range ( 1 , N + 1 ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in listN : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> if x == n - 1 : <NEWLINE> <INDENT> print ( a [ x ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ x ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , a [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> x = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = x * a [ i ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x > 10 ** 18 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> x = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> current = ( current + x * int ( s ) ) % 2019 <NEWLINE> ans += mods [ current % 2019 ] <NEWLINE> mods [ current % 2019 ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def caesarshift ( sentence ) : <NEWLINE> <INDENT> abc = <STRING> <NEWLINE> bcd = abc [ 1 : ] + <STRING> <NEWLINE> return sentence . translate ( str . maketrans ( abc , bcd ) ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sentence = input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if <STRING> in sentence or <STRING> in sentence or <STRING> in sentence : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sentence = caesarshift ( sentence ) <NEWLINE> <DEDENT> print ( sentence ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r , g , b = S . count ( <STRING> ) , S . count ( <STRING> ) , S . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for d in range ( 1 , N // 2 + 1 ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : break <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappush , heappop , heapify <NEWLINE> import math <NEWLINE> def check ( a , mid , k ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> cur_cnt = ( x + mid - 1 ) // mid - 1 <NEWLINE> cnt += cur_cnt <NEWLINE> if cnt > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> l = 0 <NEWLINE> r = 10 ** 9 + 20 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> if check ( a , mid , k ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> return l + 1 <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> c = 1 <NEWLINE> <NL> for b in range ( 1 , x ) : <NEWLINE> <INDENT> for q in range ( 2 , x ) : <NEWLINE> <INDENT> if b ** q <= x : <NEWLINE> <INDENT> c = max ( c , b ** q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> a_li = [ ] <NEWLINE> b_li = [ ] <NEWLINE> c_li = [ ] <NEWLINE> for i , ss in enumerate ( s ) : <NEWLINE> <INDENT> if ss == <STRING> : <NEWLINE> <INDENT> a_li . append ( i + 1 ) <NEWLINE> <DEDENT> elif ss == <STRING> : <NEWLINE> <INDENT> b_li . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_li . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for d in range ( 1 , n ) : <NEWLINE> <INDENT> if i + 2 * d > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i - 1 ] != s [ i + d - 1 ] and s [ i + d - 1 ] != s [ i + 2 * d - 1 ] and s [ i - 1 ] != s [ i + 2 * d - 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( a_li ) * len ( b_li ) * len ( c_li ) - count ) <NEWLINE>
r = input ( ) . split ( ) <NEWLINE> H = int ( r [ 0 ] ) <NEWLINE> N = int ( r [ 1 ] ) <NEWLINE> data_pre = input ( ) . split ( ) <NEWLINE> data = [ int ( s ) for s in data_pre ] <NEWLINE> if sum ( data ) >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , r * 2 * pi ) ) <NEWLINE> <NL>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ ] <NEWLINE> for i in range ( - 49 , 150 ) : <NEWLINE> <INDENT> num . append ( abs ( x - i ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> num [ p [ i ] + 49 ] = 1000 <NEWLINE> <NL> <DEDENT> min = 1000 <NEWLINE> ansnum = - 49 <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> if min > num [ i ] : <NEWLINE> <INDENT> min = num [ i ] <NEWLINE> ansnum = i - 50 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ansnum + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import logging <NEWLINE> <NL> logging . basicConfig ( level = logging . INFO , format = <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B_i = [ 0 for i in range ( N ) ] <NEWLINE> cycle_list = [ ] <NEWLINE> diff_list = [ ] <NEWLINE> cycle = 0 <NEWLINE> diff = 0 <NEWLINE> counter = 0 <NEWLINE> machi = 1 <NEWLINE> <NL> while counter < N : <NEWLINE> <INDENT> if B_i [ machi - 1 ] == 1 : <NEWLINE> <INDENT> diff = cycle_list . index ( machi ) <NEWLINE> cycle = counter - diff <NEWLINE> diff_list = cycle_list [ : diff ] <NEWLINE> cycle_list = cycle_list [ diff : ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter += 1 <NEWLINE> B_i [ machi - 1 ] = 1 <NEWLINE> cycle_list . append ( machi ) <NEWLINE> machi = A_i [ machi - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if K < diff : <NEWLINE> <INDENT> print ( diff_list [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod_K = ( K - diff ) % cycle <NEWLINE> print ( cycle_list [ mod_K ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> node = [ [ ] * n for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> node [ b ] . append ( a ) <NEWLINE> node [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> ans [ p ] += x <NEWLINE> <NL> <DEDENT> root = [ 0 ] * n <NEWLINE> edge = [ [ ] * n for i in range ( n ) ] <NEWLINE> root [ 0 ] = 0 <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * n <NEWLINE> visited [ 0 ] = True <NEWLINE> <NL> while q : <NEWLINE> <INDENT> r = q . popleft ( ) <NEWLINE> for e in node [ r ] : <NEWLINE> <INDENT> if not visited [ e ] : <NEWLINE> <INDENT> visited [ e ] = True <NEWLINE> q . append ( e ) <NEWLINE> root [ e ] = r <NEWLINE> edge [ r ] . append ( e ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> p = [ 0 ] * n <NEWLINE> q = deque ( edge [ 0 ] ) <NEWLINE> visited = [ False ] * n <NEWLINE> while q : <NEWLINE> <INDENT> e = q . popleft ( ) <NEWLINE> p [ e ] = p [ root [ e ] ] + 1 <NEWLINE> for e2 in edge [ e ] : <NEWLINE> <INDENT> if not visited [ e2 ] : <NEWLINE> <INDENT> visited [ e2 ] = True <NEWLINE> q . append ( e2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> p = sorted ( enumerate ( p ) , key = lambda x : x [ 1 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> e = p [ i ] [ 0 ] <NEWLINE> r = root [ e ] <NEWLINE> ans [ e ] += ans [ r ] <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
R , G , B , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for r in range ( n // R + 1 ) : <NEWLINE> <INDENT> if R * r > n : break <NEWLINE> for g in range ( n // G + 1 ) : <NEWLINE> <INDENT> ball = R * r + G * g <NEWLINE> if ball > n : break <NEWLINE> if ( n - ball ) % B == 0 : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> memo = { } <NEWLINE> X_int = int ( X , 2 ) <NEWLINE> <NL> <NL> def popcount ( n : int ) : <NEWLINE> <INDENT> x = bin ( n ) [ 2 : ] <NEWLINE> return x . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> pcf = popcount ( int ( X , 2 ) ) <NEWLINE> pcm = pcf - 1 <NEWLINE> pcp = pcf + 1 <NEWLINE> xm = X_int % pcm if pcm != 0 else 0 <NEWLINE> xp = X_int % pcp <NEWLINE> <NL> <NL> def f ( n : int , ops : int ) : <NEWLINE> <NL> <INDENT> while n != 0 : <NEWLINE> <INDENT> n %= popcount ( n ) <NEWLINE> ops += 1 <NEWLINE> <DEDENT> return ops <NEWLINE> <NL> <NL> <DEDENT> def rev ( x : str , i : int ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if pcm == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> n = ( xm - ( pow ( 2 , N - i - 1 , pcm ) ) ) % pcm <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = ( xp + ( pow ( 2 , N - i - 1 , pcp ) ) ) % pcp <NEWLINE> <DEDENT> return n <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for i , x in enumerate ( X ) : <NEWLINE> <INDENT> n = rev ( x , i ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( n , 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = range ( 1 , 100 ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for x in r : <NEWLINE> <INDENT> for y in r : <NEWLINE> <INDENT> for z in r : <NEWLINE> <INDENT> t = x * x + y * y + z * z + y * z + z * x + x * y - 1 <NEWLINE> if t < n : l [ t ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in l : print ( i ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = n * ( n + 1 ) - 1 <COMMENT> <NEWLINE> <NL> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> num = n // i <NEWLINE> min_i = i * i <NEWLINE> max_i = i * num <NEWLINE> ans += ( num - i + 1 ) * ( min_i + max_i ) <COMMENT> <NEWLINE> ans -= min_i <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from math import acos <NEWLINE> from cmath import exp <NEWLINE> from itertools import combinations <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> XYC = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> XYC . append ( ( complex ( x , y ) , c ) ) <NEWLINE> <DEDENT> if K == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1e300 <NEWLINE> eps = 1e-7 <NEWLINE> for ( p1 , c1 ) , ( p2 , c2 ) in combinations ( XYC , 2 ) : <NEWLINE> <INDENT> p_center = ( p1 * c1 + p2 * c2 ) / ( c1 + c2 ) <NEWLINE> t = abs ( p_center - p1 ) * c1 <NEWLINE> k = 0 <NEWLINE> for xy , c in XYC : <NEWLINE> <INDENT> if abs ( p_center - xy ) * c < t + eps : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> if k >= K and t < ans : <NEWLINE> <INDENT> ans = t <NEWLINE> <NL> <DEDENT> <DEDENT> def get_center ( p1 , p2 , p3 , c1 , c2 , c3 ) : <NEWLINE> <INDENT> if c1 == c2 == c3 : <NEWLINE> <INDENT> t1 , t2 , t3 = p2 - p3 , p3 - p1 , p1 - p2 <NEWLINE> denom = ( t1 * p1 . conjugate ( ) + t2 * p2 . conjugate ( ) + t3 * p3 . conjugate ( ) ) <NEWLINE> if denom == 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> return [ ( t1 * abs ( p1 ) ** 2 + t2 * abs ( p2 ) ** 2 + t3 * abs ( p3 ) ** 2 ) / denom ] <NEWLINE> <DEDENT> elif c1 == c3 : <NEWLINE> <INDENT> c2 , c3 = c3 , c2 <NEWLINE> p2 , p3 = p3 , p2 <NEWLINE> <DEDENT> elif c2 == c3 : <NEWLINE> <INDENT> c1 , c3 = c3 , c1 <NEWLINE> p1 , p3 = p3 , p1 <NEWLINE> <DEDENT> o1 = ( c1 * c1 * p1 - c3 * c3 * p3 ) / ( c1 * c1 - c3 * c3 ) <NEWLINE> r1 = ( c1 * c3 * abs ( p1 - p3 ) ) / abs ( c1 * c1 - c3 * c3 ) <NEWLINE> o2 = ( c2 * c2 * p2 - c3 * c3 * p3 ) / ( c2 * c2 - c3 * c3 ) <NEWLINE> r2 = ( c2 * c3 * abs ( p2 - p3 ) ) / abs ( c2 * c2 - c3 * c3 ) <NEWLINE> l = abs ( o1 - o2 ) <NEWLINE> if r1 + r2 < l or l + r1 < r2 or l + r2 < r1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> cos_a = ( r1 * r1 + l * l - r2 * r2 ) / ( 2 * r1 * l ) <NEWLINE> a = acos ( cos_a ) <NEWLINE> res1 = o1 + ( o2 - o1 ) * exp ( a * 1j ) * r1 / l <NEWLINE> res2 = o1 + ( o2 - o1 ) * exp ( - a * 1j ) * r1 / l <NEWLINE> return [ res1 , res2 ] <NEWLINE> <NL> <DEDENT> for ( p1 , c1 ) , ( p2 , c2 ) , ( p3 , c3 ) in combinations ( XYC , 3 ) : <NEWLINE> <INDENT> p_centers = get_center ( p1 , p2 , p3 , c1 , c2 , c3 ) <NEWLINE> for p_center in p_centers : <NEWLINE> <INDENT> t = abs ( p1 - p_center ) * c1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> k = 0 <NEWLINE> for p , c in XYC : <NEWLINE> <INDENT> if abs ( p_center - p ) * c < t + eps : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> if k >= K and t < ans : <NEWLINE> <INDENT> ans = t <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( ( 1 + p [ i ] ) / 2 ) <NEWLINE> <NL> <DEDENT> a = [ 0 ] * N <NEWLINE> a [ 0 ] = l [ 0 ] <NEWLINE> for i in range ( 1 , len ( l ) ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + l [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K , len ( l ) ) : <NEWLINE> <INDENT> ans = max ( ans , a [ i ] - a [ i - K ] ) <NEWLINE> <NL> <DEDENT> if N == 1 or N - K == 0 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> list_a = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> band_score = 1 <NEWLINE> <NL> for i , score in enumerate ( list_a [ k : ] ) : <NEWLINE> <INDENT> if list_a [ i ] < score : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> def calcSumOfDigit ( x ) : <NEWLINE> <INDENT> str_x = str ( x ) <NEWLINE> acc = 0 <NEWLINE> for s in str_x : <NEWLINE> <INDENT> acc += int ( s ) <NEWLINE> acc %= 9 <NEWLINE> <DEDENT> return acc <NEWLINE> <NL> <DEDENT> print ( <STRING> if calcSumOfDigit ( N ) == 0 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> sumA = sum ( A ) <NEWLINE> cnt_num = np . zeros ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> cnt_num [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> sumA += ( C - B ) * cnt_num [ B ] <NEWLINE> print ( int ( sumA ) ) <NEWLINE> cnt_num [ C ] += cnt_num [ B ] <NEWLINE> cnt_num [ B ] = 0 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] >= m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> A = sorted ( A ) <NEWLINE> A = reversed ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > m : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> at = list ( str ( input ( ) ) ) <NEWLINE> a . append ( at ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> t = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if j != w - 1 : <NEWLINE> <INDENT> if a [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> for k in range ( i + 1 , h ) : <NEWLINE> <INDENT> if a [ k ] [ j ] == <STRING> : <NEWLINE> <INDENT> t = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i != h - 1 : <NEWLINE> <INDENT> if a [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> for k in range ( j + 1 , w ) : <NEWLINE> <INDENT> if a [ i ] [ k ] == <STRING> : <NEWLINE> <INDENT> t = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == h - 1 and j == w - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . root = [ - 1 ] * ( n + 1 ) <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> <DEDENT> def FindRoot ( self , x ) : <NEWLINE> <INDENT> if self . root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root [ x ] = self . FindRoot ( self . root [ x ] ) <NEWLINE> return self . root [ x ] <NEWLINE> <DEDENT> <DEDENT> def Unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . FindRoot ( x ) <NEWLINE> y = self . FindRoot ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> self . root [ x ] += self . root [ y ] <NEWLINE> self . root [ y ] = x <NEWLINE> <DEDENT> elif self . rank [ x ] <= self . rank [ y ] : <NEWLINE> <INDENT> self . root [ y ] += self . root [ x ] <NEWLINE> self . root [ x ] = y <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def isSameGroup ( self , x , y ) : <NEWLINE> <INDENT> return self . FindRoot ( x ) == self . FindRoot ( y ) <NEWLINE> <DEDENT> def Count ( self , x ) : <NEWLINE> <INDENT> return - self . root [ self . FindRoot ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( ) ) ) + [ i + 1 ] for i in range ( n ) ] <NEWLINE> arr = sorted ( arr , key = lambda x : x [ 0 ] ) <NEWLINE> x , y , i = arr [ 0 ] <NEWLINE> tmp = [ ] <NEWLINE> for tx , ty , j in arr : <NEWLINE> <INDENT> if y <= ty : <NEWLINE> <INDENT> uf . Unite ( i , j ) <NEWLINE> for tx2 , ty2 , j2 in tmp : <NEWLINE> <INDENT> if ty2 <= ty : <NEWLINE> <INDENT> uf . Unite ( j , j2 ) <NEWLINE> <DEDENT> <DEDENT> tmp = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp . append ( [ x , y , i ] ) <NEWLINE> x = tx <NEWLINE> y = ty <NEWLINE> i = j <NEWLINE> <DEDENT> <DEDENT> arr = sorted ( arr , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> x , y , i = arr [ 0 ] <NEWLINE> tmp = [ ] <NEWLINE> for tx , ty , j in arr : <NEWLINE> <INDENT> if x >= tx : <NEWLINE> <INDENT> uf . Unite ( i , j ) <NEWLINE> for tx2 , ty2 , j2 in tmp : <NEWLINE> <INDENT> if tx2 >= tx : <NEWLINE> <INDENT> uf . Unite ( j , j2 ) <NEWLINE> <DEDENT> <DEDENT> tmp = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp . append ( [ x , y , i ] ) <NEWLINE> x = tx <NEWLINE> y = ty <NEWLINE> i = j <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( uf . Count ( i ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> num = max ( l ) <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> num = min ( num , i ) <NEWLINE> if num == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = input ( ) <NEWLINE> sum_n = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> sum_n += int ( i ) <NEWLINE> <NL> <DEDENT> flag = <STRING> if sum_n % 9 == 0 else <STRING> <NEWLINE> print ( flag ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> dic = defaultdict ( lambda : 0 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> G = { } <NEWLINE> <NL> for key in sorted ( list ( dic . keys ( ) ) ) : <NEWLINE> <INDENT> G [ N ] = key <NEWLINE> N -= dic [ key ] <NEWLINE> <NL> <DEDENT> criteria = 0 <NEWLINE> for key in G . keys ( ) : <NEWLINE> <INDENT> if G [ key ] % 2 : <NEWLINE> <INDENT> criteria ^= key <NEWLINE> <NL> <DEDENT> <DEDENT> if not criteria : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> dp = np . zeros ( S + 1 , dtype = int ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ep = dp * 2 <NEWLINE> ep [ i : ] += dp [ : - i ] <NEWLINE> dp = ep % MOD <NEWLINE> <NL> <DEDENT> print ( dp [ S ] ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = A [ 0 ] <NEWLINE> flag = True <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> sum = sum * A [ i ] <NEWLINE> if sum > t : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lrs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> cards = [ lrs [ 0 ] [ 0 ] , lrs [ 0 ] [ 1 ] ] <COMMENT> <NEWLINE> <NL> for lr in lrs [ 1 : ] : <NEWLINE> <INDENT> if ( lr [ 1 ] < cards [ 0 ] ) or ( lr [ 0 ] > cards [ 1 ] ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cards [ 0 ] = max ( cards [ 0 ] , lr [ 0 ] ) <NEWLINE> cards [ 1 ] = min ( cards [ 1 ] , lr [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( cards [ 1 ] - cards [ 0 ] + 1 ) <NEWLINE> <NL>
x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x < y : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <DEDENT>
def zero_index ( i : str ) -> int : <NEWLINE> <INDENT> return int ( i ) - 1 <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> transition = list ( map ( zero_index , input ( ) . split ( ) ) ) <NEWLINE> places = [ 0 ] <NEWLINE> next_place = transition [ 0 ] <NEWLINE> virgin = [ True ] * n <NEWLINE> virgin [ 0 ] = False <NEWLINE> while virgin [ next_place ] : <NEWLINE> <INDENT> virgin [ next_place ] = False <NEWLINE> places . append ( next_place ) <NEWLINE> next_place = transition [ next_place ] <NEWLINE> <DEDENT> start = places . index ( next_place ) <NEWLINE> period = len ( places ) - start <NEWLINE> if k < start : <NEWLINE> <INDENT> t = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( k - start ) % period + start <NEWLINE> <DEDENT> print ( places [ t ] + 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k == 1 or k == 7 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> pre = 7 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> surp = ( pre * 10 + 7 ) % k <NEWLINE> cnt += 1 <NEWLINE> if surp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if cnt > 1000000 : <NEWLINE> <INDENT> cnt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> pre = surp <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> x = i <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if ( x % 10 ) == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE>
from math import gcd <NEWLINE> <COMMENT> <NL> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( b , c ) , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = list ( set ( ( A ) ) ) <NEWLINE> check = len ( a ) <NEWLINE> dff = check - K <NEWLINE> if dff <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans_list = [ 0 ] * check <NEWLINE> A . sort ( ) <NEWLINE> index = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <NL> <INDENT> if i >= 1 and A [ i ] != A [ i - 1 ] : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> ans_list [ index ] += 1 <NEWLINE> <DEDENT> ans_list . sort ( ) <NEWLINE> result = sum ( ans_list [ : dff ] ) <NEWLINE> print ( result ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> a , b = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> b . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return a + b [ : : - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( make_divisors ( i ) ) == 8 and i % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> mod = 7 % k <NEWLINE> path = [ mod ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if mod == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> mod = ( mod * 10 + 7 ) % k <NEWLINE> path . append ( mod ) <NEWLINE> if mod == path [ 0 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> a , b , h , m = ( float ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> zi = 0.5 * 60 * h + 0.5 * m <NEWLINE> hun = 6 * h * 60 + 6 * m <NEWLINE> <NL> if hun >= 360 : <NEWLINE> <INDENT> for i in range ( 11 ) : <NEWLINE> <NL> <INDENT> if hun >= 360 : <NEWLINE> <INDENT> hun = hun - 360 <NEWLINE> <DEDENT> elif hun < 360 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if hun > zi : <NEWLINE> <INDENT> if hun - zi > 180 : <NEWLINE> <INDENT> degree = 360 - hun + zi <NEWLINE> <DEDENT> elif hun - zi < 180 : <NEWLINE> <INDENT> degree = hun - zi <NEWLINE> <DEDENT> elif hun - zi == 180 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif zi > hun : <NEWLINE> <INDENT> if zi - hun > 180 : <NEWLINE> <INDENT> degree = 360 - zi + hun <NEWLINE> <DEDENT> elif zi - hun < 180 : <NEWLINE> <INDENT> degree = zi - hun <NEWLINE> <DEDENT> elif zi - hun == 180 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif hun == zi : <NEWLINE> <INDENT> if b >= a : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> cosain = math . cos ( math . radians ( degree ) ) <NEWLINE> <NL> print ( math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * cosain ) ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> arr = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> arr [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( * arr ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> print ( N * A // B - A * ( N // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( B - 1 ) * A // B - A * ( ( B - 1 ) // B ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> X = { } <NEWLINE> Y = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L = i + A [ i ] <NEWLINE> R = i - A [ i ] <NEWLINE> X [ L ] = X [ L ] + 1 if L in X else 1 <NEWLINE> Y [ R ] = Y [ R ] + 1 if R in Y else 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for n in X : <NEWLINE> <INDENT> if n in Y : <NEWLINE> <INDENT> ans += X [ n ] * Y [ n ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = set ( [ s ** 2 for s in range ( 2 , int ( N ** 0.5 ) + 1 ) ] ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> n = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if n <= N : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for v in ans [ 1 : ] : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ set ( ) for i in range ( N + 1 ) ] <NEWLINE> room = [ 0 ] * ( N + 1 ) <NEWLINE> pre = [ None ] * ( N + 1 ) <NEWLINE> def bfs ( i ) : <COMMENT> <NEWLINE> <INDENT> Done = set ( ) <NEWLINE> Done . add ( i ) <NEWLINE> d = deque ( [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while ( d ) : <NEWLINE> <INDENT> k = d . popleft ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in AB [ k ] : <NEWLINE> <INDENT> if i not in Done : <NEWLINE> <INDENT> pre [ i ] = k <NEWLINE> Done . add ( i ) <NEWLINE> d . append ( i ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB [ A ] . add ( B ) <NEWLINE> AB [ B ] . add ( A ) <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> bfs ( 1 ) <NEWLINE> if pre . count ( None ) <= N + 1 : <NEWLINE> <INDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = False <NEWLINE> <DEDENT> if pre [ i ] is not None : <NEWLINE> <INDENT> print ( pre [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> nums = [ 0 ] * n <NEWLINE> nums [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : nums [ i ] = a [ i ] + nums [ i - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( nums [ n - 1 ] - nums [ i ] ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> val = 1 <NEWLINE> exceed = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ( exceed == 0 or i == 0 ) : <NEWLINE> <INDENT> val *= i <NEWLINE> <DEDENT> if ( val == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if ( val > 1000000000000000000 ) : <NEWLINE> <INDENT> exceed = 1 <NEWLINE> <DEDENT> <DEDENT> if ( exceed == 0 ) : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = b [ : : - 1 ] <NEWLINE> <NL> l = [ ] <NEWLINE> num = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> num = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ind = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] != num and a [ i ] != num and ind < len ( l ) : <NEWLINE> <INDENT> b [ i ] , b [ l [ ind ] ] = b [ l [ ind ] ] , b [ i ] <NEWLINE> ind += 1 <NEWLINE> <DEDENT> <DEDENT> if ind < len ( l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * b ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ c ] += b <NEWLINE> <NL> <DEDENT> d_sorted = sorted ( d . items ( ) , reverse = True , key = lambda x : x [ 0 ] ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i , j in d_sorted : <NEWLINE> <INDENT> for k in range ( j ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> if len ( l ) > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> for i in range ( min ( n , len ( l ) ) ) : <NEWLINE> <INDENT> a [ i ] = max ( a [ i ] , l [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> if A in num . keys ( ) : <NEWLINE> <INDENT> num [ A ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ A ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j in num . items ( ) : <NEWLINE> <INDENT> if j % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ x ] . append ( y ) <NEWLINE> <DEDENT> dp = [ - 1 for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> def solve ( v ) : <NEWLINE> <INDENT> if dp [ v ] != - 1 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> res = 0 <NEWLINE> for next_v in graph [ v ] : <NEWLINE> <INDENT> res = max ( res , solve ( next_v ) + 1 ) <NEWLINE> <DEDENT> dp [ v ] = res <NEWLINE> return dp [ v ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , solve ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 10000 <NEWLINE> lt = len ( t ) <NEWLINE> ls = ( len ( s ) ) <NEWLINE> start , last = 0 , lt <NEWLINE> while last <= ls : <NEWLINE> <INDENT> count = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( start , last ) : <NEWLINE> <INDENT> if s [ i ] != t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> ans = min ( ans , count ) <NEWLINE> start += 1 <NEWLINE> last += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> s = sum ( nums ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s -= nums [ i ] <NEWLINE> ans += nums [ i ] * s <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> L = [ 0 ] * ( N + 3 ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L [ 0 ] = 2 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L [ 1 ] = 1 <NEWLINE> for n in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> L [ n ] = L [ n - 1 ] + L [ n - 2 ] <NEWLINE> <DEDENT> print ( L [ n ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if <STRING> in s : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> x = y = 0 <NEWLINE> c = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if c < A [ i ] : <NEWLINE> <INDENT> x = 1 <NEWLINE> <DEDENT> elif c > A [ i ] : <NEWLINE> <INDENT> y = 1 <NEWLINE> <NL> <DEDENT> if x == 1 and y == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = y = 0 <NEWLINE> <NL> <DEDENT> c = A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> for k in range ( K , N + 2 ) : <NEWLINE> <INDENT> upper = k * ( ( N - k + 1 ) + N ) // 2 <NEWLINE> lower = k * ( k - 1 ) // 2 <NEWLINE> ans += upper - lower + 1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> war = [ ] <NEWLINE> for i in range ( 1 , max ( a , b ) + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> war . append ( i ) <NEWLINE> <DEDENT> <DEDENT> war . reverse ( ) <NEWLINE> <NL> print ( war [ k - 1 ] ) <NEWLINE>
import math <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 120 , 121 ) : <NEWLINE> <INDENT> for B in range ( - 120 , A + 1 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> def num_divisors_table ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return table <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> print ( sum ( num_divisors_table ( num ) [ : - 1 ] ) ) <NEWLINE>
import copy <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> xl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> xl . append ( [ x - l , l + x ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> xl = sorted ( xl , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> r = 2 * ( 10 ** 9 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if xl [ i ] [ 1 ] > r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if xl [ i ] [ 0 ] <= r : <NEWLINE> <INDENT> r = xl [ i ] [ 0 ] <NEWLINE> <COMMENT> <NL> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nw = 1 <NEWLINE> lp0 = [ 1 ] <NEWLINE> lpl = { 1 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> nw = A [ nw - 1 ] <NEWLINE> if nw in lpl : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lp0 . append ( nw ) <NEWLINE> lpl . add ( nw ) <NEWLINE> <DEDENT> <DEDENT> lpc = i + 1 - lp0 . index ( nw ) <NEWLINE> lp = lp0 [ - lpc : ] <NEWLINE> <NL> if K <= len ( lp0 ) - 1 : <NEWLINE> <INDENT> print ( lp0 [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= len ( lp0 ) - 1 <NEWLINE> K = K % lpc - 1 <NEWLINE> print ( lp [ K ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = set ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> r = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> min = r [ 0 ] <NEWLINE> max = - 9999999999999999 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if r [ i ] - min > max : <NEWLINE> <INDENT> max = r [ i ] - min <NEWLINE> <DEDENT> if r [ i ] < min : <NEWLINE> <INDENT> min = r [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> st = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> st . add ( S ) <NEWLINE> <DEDENT> print ( len ( st ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for b in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
targ , length = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> banned = [ False ] * 100 <NEWLINE> <NL> bans = input ( ) <NEWLINE> if bans != <STRING> : <NEWLINE> <INDENT> for ban in bans . split ( <STRING> ) : <NEWLINE> <INDENT> banned [ int ( ban ) - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for dist in range ( 100 ) : <NEWLINE> <INDENT> if targ - dist > 0 : <NEWLINE> <INDENT> if not banned [ targ - dist - 1 ] : <NEWLINE> <INDENT> print ( targ - dist ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( targ - dist ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if targ + dist <= 100 : <NEWLINE> <INDENT> if not banned [ targ + dist - 1 ] : <NEWLINE> <INDENT> print ( targ + dist ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( targ + dist ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> p0 = [ 0 ] <NEWLINE> j = 0 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if p [ j ] != i : <NEWLINE> <INDENT> p0 . append ( i ) <NEWLINE> <DEDENT> elif p [ j ] == i : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j == N : <NEWLINE> <INDENT> for i0 in range ( i + 1 , 100 ) : <NEWLINE> <INDENT> p0 . append ( i0 ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> p0 . append ( 101 ) <NEWLINE> p1 = [ 0 for i in range ( len ( p0 ) ) ] <NEWLINE> for i in range ( len ( p0 ) ) : <NEWLINE> <INDENT> p1 [ i ] = p0 [ i ] - X <NEWLINE> p1 [ i ] = np . abs ( p1 [ i ] ) <NEWLINE> <NL> <DEDENT> ii = np . argmin ( p1 ) <NEWLINE> <NL> print ( p0 [ ii ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> INF = 1000000000000000000 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numba import jit <NEWLINE> import numpy as np <NEWLINE> <NL> @ jit <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> for m in range ( k ) : <NEWLINE> <INDENT> B = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = max ( 0 , i - A [ i ] ) <NEWLINE> r = min ( n , i + A [ i ] + 1 ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r < n : <NEWLINE> <INDENT> B [ r ] -= 1 <NEWLINE> <DEDENT> <DEDENT> A = np . cumsum ( B ) [ : - 1 ] <NEWLINE> if np . all ( A == n ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( a , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = min ( B - 1 , N ) <NEWLINE> <NL> print ( A * num // B - A * ( num // B ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> re = [ 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> <NL> if K < 102 : <NEWLINE> <INDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> hoge = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = gcd ( hoge , c ) <NEWLINE> ans += g <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = re [ K - 101 ] <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = s - a [ i ] <NEWLINE> ans = ans + a [ i ] * s <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> def make_prime_checker ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> is_prime = [ False , True , False , False , False , True ] * ( n // 6 + 1 ) <NEWLINE> del is_prime [ n + 1 : ] <NEWLINE> is_prime [ 1 : 4 ] = False , True , True <NEWLINE> for i in range ( 5 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> is_prime [ i * i : : i ] = [ False ] * ( n // i - i + 1 ) <NEWLINE> <DEDENT> <DEDENT> return is_prime <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> Primes = [ p for p , is_p in enumerate ( make_prime_checker ( 2200 ) ) if is_p ] <NEWLINE> def decomp ( n ) : <NEWLINE> <INDENT> res1 = res2 = 1 <NEWLINE> for p in Primes : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> n //= p <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> cnt %= 3 <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> res1 *= p <NEWLINE> <DEDENT> elif cnt == 2 : <NEWLINE> <INDENT> res2 *= p <NEWLINE> <DEDENT> <DEDENT> if int ( n ** 0.5 ) ** 2 == n : <NEWLINE> <INDENT> res2 *= int ( n ** 0.5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res1 *= n <NEWLINE> <DEDENT> return res1 * res2 * res2 , res1 * res1 * res2 <NEWLINE> <NL> <DEDENT> N , * S = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> T = [ ] <NEWLINE> inv_dict = { } <NEWLINE> for s in S : <NEWLINE> <INDENT> t , t_inv = decomp ( s ) <NEWLINE> T . append ( t ) <NEWLINE> inv_dict [ t ] = t_inv <NEWLINE> <NL> <DEDENT> counter_T = Counter ( T ) <NEWLINE> ans = 0 <NEWLINE> for t , t_cnt in counter_T . items ( ) : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> t_inv = inv_dict [ t ] <NEWLINE> t_inv_cnt = counter_T [ t_inv ] <NEWLINE> if t_cnt > t_inv_cnt or ( t_cnt == t_inv_cnt and t > t_inv ) : <NEWLINE> <INDENT> ans += t_cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from sys import stdin <NEWLINE> import collections <NEWLINE> <NL> N , M = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = collections . Counter ( A ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B , C = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A [ C ] += B <NEWLINE> <DEDENT> A = dict ( A ) <NEWLINE> A = dict ( sorted ( A . items ( ) ) ) <NEWLINE> <NL> S = 0 <NEWLINE> j = - 1 <NEWLINE> <NL> A_key = list ( A . keys ( ) ) <NEWLINE> A_value = list ( A . values ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if A_value [ j ] < N : <NEWLINE> <INDENT> S += A_value [ j ] * A_key [ j ] <NEWLINE> N -= A_value [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += N * A_key [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in [ 0 ] * N ] <NEWLINE> <NL> for _ in [ 0 ] * M : <NEWLINE> <INDENT> a , b , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( ( b , d ) ) <NEWLINE> G [ b ] . append ( ( a , - d ) ) <NEWLINE> <NL> <DEDENT> X = [ None ] * N <NEWLINE> <NL> def dfs ( i , x = 0 ) : <NEWLINE> <INDENT> for j , d in G [ i ] : <NEWLINE> <INDENT> if X [ j ] is None : <NEWLINE> <INDENT> X [ j ] = x + d <NEWLINE> dfs ( j , x + d ) <NEWLINE> <DEDENT> elif X [ j ] != x + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> X [ i ] = 0 <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> for i in range ( b ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> val = 7 <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif k % 5 == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 10 ** 12 + 1 ) : <NEWLINE> <INDENT> if val >= k : <NEWLINE> <INDENT> sub = val % k <NEWLINE> if sub == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = 10 * sub + 7 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> val = 10 * val + 7 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ns = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ns . reverse ( ) <NEWLINE> if len ( ns ) > n : <NEWLINE> <INDENT> del ns [ : ( len ( ns ) - n ) ] <NEWLINE> <DEDENT> for i in ns : <NEWLINE> <INDENT> if i != ns [ - 1 ] : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> <NL> <COMMENT> <NL> price1 = A * X + B * Y <NEWLINE> l . append ( price1 ) <NEWLINE> <NL> <COMMENT> <NL> if X > Y : <NEWLINE> <INDENT> if A < 2 * C : <NEWLINE> <INDENT> price2 = 2 * Y * C + A * abs ( X - Y ) <NEWLINE> l . append ( price2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> price3 = 2 * Y * C + C * abs ( X - Y ) * 2 <NEWLINE> l . append ( price3 ) <NEWLINE> <DEDENT> <DEDENT> elif X < Y : <NEWLINE> <INDENT> if B < 2 * C : <NEWLINE> <INDENT> price4 = 2 * X * C + B * abs ( Y - X ) <NEWLINE> l . append ( price4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> price5 = 2 * X * C + C * abs ( Y - X ) * 2 <NEWLINE> l . append ( price5 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> price6 = 2 * X * C <NEWLINE> l . append ( price6 ) <NEWLINE> <NL> <NL> <DEDENT> print ( min ( l ) ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10 ** 18 <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > M : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
class ModInt : <NEWLINE> <INDENT> def __init__ ( self , x , MOD ) : <NEWLINE> <INDENT> self . x = x % MOD <NEWLINE> self . m = MOD <NEWLINE> <NL> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , ModInt ) : <NEWLINE> <INDENT> return ModInt ( self . x + other . x , self . m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ModInt ( self . x + other , self . m ) <NEWLINE> <NL> <DEDENT> <DEDENT> __radd__ = __add__ <NEWLINE> <NL> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , ModInt ) : <NEWLINE> <INDENT> return ModInt ( self . x - other . x , self . m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ModInt ( self . x - other , self . m ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , ModInt ) : <NEWLINE> <INDENT> return ModInt ( other . x - self . x , self . m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ModInt ( other - self . x , self . m ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , ModInt ) : <NEWLINE> <INDENT> return ModInt ( pow ( self . x , other . x , self . m ) , self . m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ModInt ( pow ( self . x , other , self . m ) , self . m ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , ModInt ) : <NEWLINE> <INDENT> return ModInt ( pow ( other . x , self . x , self . m ) , self . m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ModInt ( pow ( other , self . x , self . m ) , self . m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) ) ) <NEWLINE> Xc = sum ( X ) <NEWLINE> <NL> if Xc == 0 : <NEWLINE> <INDENT> [ print ( 1 ) for i in range ( N ) ] <NEWLINE> <DEDENT> elif Xc == 1 : <NEWLINE> <INDENT> ans1 = ModInt ( 0 , Xc + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if X [ j ] : <NEWLINE> <INDENT> ans1 += pow ( 2 , N - 1 - j , Xc + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if X [ j ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) if X [ N - 1 ] or j == N - 1 else print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans1 = ModInt ( 0 , Xc + 1 ) <NEWLINE> ans2 = ModInt ( 0 , Xc - 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if X [ j ] : <NEWLINE> <INDENT> ans1 += pow ( 2 , N - 1 - j , Xc + 1 ) <NEWLINE> ans2 += pow ( 2 , N - 1 - j , Xc - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] : <COMMENT> <NEWLINE> <INDENT> ans = ans2 - pow ( 2 , N - 1 - i , Xc - 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans = ans1 + pow ( 2 , N - 1 - i , Xc + 1 ) <NEWLINE> <DEDENT> count = 1 <NEWLINE> while ans . x > 0 : <NEWLINE> <INDENT> tmp = str ( bin ( ans . x ) ) . count ( <STRING> ) <NEWLINE> ans . x %= tmp <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> while B <= A : <NEWLINE> <INDENT> B *= 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> while C <= B : <NEWLINE> <INDENT> C *= 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> if K >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ - 1 ] + A <NEWLINE> still = [ 0 ] * ( N + 1 ) <NEWLINE> still [ 1 ] = 1 <NEWLINE> before = 1 <NEWLINE> rS = - 1 <NEWLINE> root = [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> dest = A [ before ] <NEWLINE> if still [ dest ] == 1 : <NEWLINE> <INDENT> rS = dest <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> still [ dest ] = 1 <NEWLINE> root . append ( dest ) <NEWLINE> before = dest <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> num = 0 <NEWLINE> for i in root : <NEWLINE> <INDENT> if i == rS : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if K <= num : <NEWLINE> <INDENT> print ( root [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= num <NEWLINE> root2 = root [ num : ] <NEWLINE> print ( root2 [ K % len ( root2 ) ] ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 1 <NEWLINE> ans = 0 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 21 ) : <NEWLINE> <INDENT> c = c - 1 + a <NEWLINE> if c >= b : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> if M % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , M // 2 + 1 ) : <NEWLINE> <INDENT> ans . append ( [ i , M + 1 - i ] ) <NEWLINE> ans . append ( [ M + i , 2 * M + 2 - i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , M // 2 + 1 ) : <NEWLINE> <INDENT> ans . append ( [ i , M + 1 - i ] ) <NEWLINE> <DEDENT> for i in range ( 1 , ( M + 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> ans . append ( [ M + i , 2 * M + 2 - i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( * ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def getD ( num ) : <NEWLINE> <INDENT> input_list = [ 2 if i % 2 == 0 else i for i in range ( num + 1 ) ] <NEWLINE> input_list [ 0 ] = 0 <NEWLINE> bool_list = [ False if i % 2 == 0 else True for i in range ( num + 1 ) ] <NEWLINE> sqrt = int ( math . sqrt ( num ) ) <NEWLINE> <NL> for serial in range ( 3 , sqrt + 1 , 2 ) : <NEWLINE> <INDENT> if bool_list [ serial ] : <NEWLINE> <INDENT> for s in range ( serial ** 2 , num + 1 , serial ) : <NEWLINE> <INDENT> if bool_list [ s ] : <NEWLINE> <INDENT> input_list [ s ] = serial <NEWLINE> bool_list [ s ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return input_list <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = getD ( max ( A ) ) <NEWLINE> pairwise_coprime = True <NEWLINE> use_divnum = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = A [ i ] <NEWLINE> while k != 1 : <NEWLINE> <INDENT> if D [ k ] in use_divnum : <NEWLINE> <INDENT> pairwise_coprime = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> use_divnum . add ( D [ k ] ) <NEWLINE> <DEDENT> div = D [ k ] <NEWLINE> while k % div == 0 and k > 1 : <NEWLINE> <INDENT> k = k // div <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if pairwise_coprime : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from math import gcd <NEWLINE> gcd_of_a = A [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> gcd_of_a = gcd ( gcd_of_a , A [ i ] ) <NEWLINE> <DEDENT> if gcd_of_a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> total = [ ] <NEWLINE> <NL> <COMMENT> <NL> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if x % 15 == 0 : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> elif x % 5 == 0 : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> elif x % 3 == 0 : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total . append ( x ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( sum ( total ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : break <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> N , M , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( B [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ( a [ i ] > K ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> List_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List_B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List_discount = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> <COMMENT> <NL> ans = 2 * 10 ** 5 <NEWLINE> for d in List_discount : <NEWLINE> <COMMENT> <NL> <INDENT> p = List_A [ d [ 0 ] - 1 ] + List_B [ d [ 1 ] - 1 ] - d [ 2 ] <NEWLINE> ans = min ( ans , p ) <NEWLINE> <DEDENT> no_discount = min ( List_A ) + min ( List_B ) <NEWLINE> ans = min ( ans , no_discount ) <NEWLINE> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A_str = input ( ) . split ( ) <NEWLINE> A_array = map ( int , A_str ) <NEWLINE> <NL> if <STRING> in A_str : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for A in A_array : <NEWLINE> <INDENT> res *= A <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> seq = set ( ) <NEWLINE> l = len ( s ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> seq . add ( s [ i : i + j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> seq = list ( seq ) <NEWLINE> seq . sort ( ) <NEWLINE> print ( seq [ K - 1 ] ) <NEWLINE>
<COMMENT> <NL> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if r - l >= 2019 : <NEWLINE> <INDENT> mn = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mn = ( l * r ) % 2019 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> mn = min ( mn , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mn ) <NEWLINE>
import numpy as np <NEWLINE> X , K , D = ( list ( map ( int , input ( <STRING> ) . split ( <STRING> ) ) ) ) <NEWLINE> X = np . abs ( X ) <NEWLINE> <NL> if np . abs ( X ) / D <= K : <NEWLINE> <INDENT> new_K = K - int ( X / D ) <NEWLINE> new_X = X - D * int ( X / D ) <NEWLINE> if new_K % 2 == 0 : <NEWLINE> <INDENT> print ( new_X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( np . abs ( new_X - D ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( np . abs ( X - D * K ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> count = Counter ( A ) <NEWLINE> S = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> n = count [ B ] <NEWLINE> count [ B ] -= n <NEWLINE> count [ C ] += n <NEWLINE> S = S - B * n + C * n <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> Ns = list ( range ( N + 1 ) ) <NEWLINE> cumsum = [ 0 ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> cumsum . append ( cumsum [ i ] + Ns [ i ] ) <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( K , N + 2 ) : <COMMENT> <NEWLINE> <INDENT> tmp = cumsum [ - 1 ] - cumsum [ - i - 1 ] - cumsum [ i ] + cumsum [ 0 ] + 1 <NEWLINE> ans += tmp <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> x = [ ] <NEWLINE> y = [ ] <NEWLINE> xy1 = [ ] <NEWLINE> xy2 = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = ( int ( t ) for t in input ( ) . split ( ) ) <NEWLINE> x . append ( a ) <NEWLINE> y . append ( b ) <NEWLINE> xy1 . append ( a + b ) <NEWLINE> xy2 . append ( a - b ) <NEWLINE> <NL> <DEDENT> max1 = max ( xy1 ) - min ( xy1 ) <NEWLINE> max2 = max ( xy2 ) - min ( xy2 ) <NEWLINE> print ( max ( ( max1 , max2 ) ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> que = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> op = line . rstrip ( ) . split ( ) <NEWLINE> if <STRING> == op [ 0 ] : <NEWLINE> <INDENT> que . appendleft ( op [ 1 ] ) <NEWLINE> <DEDENT> elif <STRING> == op [ 0 ] : <NEWLINE> <INDENT> if op [ 1 ] in que : <NEWLINE> <INDENT> que . remove ( op [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif <STRING> == op [ 0 ] : <NEWLINE> <INDENT> que . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * que ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( - 400 , 400 ) : <NEWLINE> <INDENT> l . append ( i ** 5 ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in l : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> if i - j == x : <NEWLINE> <INDENT> ans . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i , j = ans [ 0 ] [ 0 ] , ans [ 0 ] [ 1 ] <NEWLINE> print ( l . index ( i ) - 400 , l . index ( j ) - 400 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> aN = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_board = 0 <NEWLINE> aN_max = aN [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if aN [ i ] < aN_max : <NEWLINE> <INDENT> sum_board += aN_max - aN [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aN_max = aN [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_board ) <NEWLINE>
<NL> import math <NEWLINE> <NL> <COMMENT> <NL> def prime ( p ) : <NEWLINE> <INDENT> if p == 2 or p == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = int ( math . sqrt ( p ) ) <NEWLINE> while i >= 2 : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> break <NEWLINE> <DEDENT> i -= 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if prime ( a ) == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = [ [ [ 0 for k in range ( 10 ) ] for j in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> [ b , f , r , v ] = map ( int , input ( ) . split ( ) ) <NEWLINE> x [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> tmp = list ( map ( str , x [ b ] [ f ] ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( tmp ) ) <NEWLINE> <DEDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for n in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( l , gcd ( m , n ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MOD = 998_244_353 <NEWLINE> <NL> <NL> @ njit ( ( i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( N , LR ) : <NEWLINE> <INDENT> L , R = LR [ : : 2 ] , LR [ 1 : : 2 ] <NEWLINE> K = len ( L ) <NEWLINE> F = np . zeros ( N + 10 , np . int64 ) <NEWLINE> F [ 0 ] = 1 <NEWLINE> for n in range ( 1 , N + 10 ) : <NEWLINE> <INDENT> F [ n ] += F [ n - 1 ] <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> l , r = L [ k ] , R [ k ] + 1 <NEWLINE> if n - l >= 0 : <NEWLINE> <INDENT> F [ n ] += F [ n - l ] <NEWLINE> <DEDENT> if n - r >= 0 : <NEWLINE> <INDENT> F [ n ] -= F [ n - r ] <NEWLINE> <DEDENT> <DEDENT> F [ n ] %= MOD <NEWLINE> <DEDENT> ans = F [ N - 1 ] - F [ N - 2 ] <NEWLINE> return ans % MOD <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> LR = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> print ( main ( N , LR ) ) <NEWLINE>
a = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> print ( a [ input ( ) ] ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> A = [ list ( input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> <NL> T = [ [ - 1 , - 1 , - 1 , - 1 ] ] <NEWLINE> def insert ( T , u , x ) : <NEWLINE> <INDENT> if T [ 0 ] [ 3 ] == - 1 : <NEWLINE> <INDENT> T [ 0 ] [ 3 ] = x <NEWLINE> return <NEWLINE> <DEDENT> if x < T [ u ] [ 3 ] : <NEWLINE> <INDENT> if T [ u ] [ 1 ] == - 1 : <NEWLINE> <INDENT> T [ u ] [ 1 ] = len ( T ) <NEWLINE> T . append ( [ u , - 1 , - 1 , x ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( T , T [ u ] [ 1 ] , x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ u ] [ 2 ] == - 1 : <NEWLINE> <INDENT> T [ u ] [ 2 ] = len ( T ) <NEWLINE> T . append ( [ u , - 1 , - 1 , x ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( T , T [ u ] [ 2 ] , x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def ino ( u ) : <NEWLINE> <INDENT> if T [ u ] [ 1 ] != - 1 : <NEWLINE> <INDENT> ino ( T [ u ] [ 1 ] ) <NEWLINE> <DEDENT> ino_res . append ( str ( T [ u ] [ 3 ] ) ) <NEWLINE> if T [ u ] [ 2 ] != - 1 : <NEWLINE> <INDENT> ino ( T [ u ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> def pre ( u ) : <NEWLINE> <INDENT> pre_res . append ( str ( T [ u ] [ 3 ] ) ) <NEWLINE> if T [ u ] [ 1 ] != - 1 : <NEWLINE> <INDENT> pre ( T [ u ] [ 1 ] ) <NEWLINE> <DEDENT> if T [ u ] [ 2 ] != - 1 : <NEWLINE> <INDENT> pre ( T [ u ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> def find ( u , x ) : <NEWLINE> <INDENT> if x == T [ u ] [ 3 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x < T [ u ] [ 3 ] : <NEWLINE> <INDENT> if T [ u ] [ 1 ] == - 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return find ( T [ u ] [ 1 ] , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ u ] [ 2 ] == - 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return find ( T [ u ] [ 2 ] , x ) <NEWLINE> <DEDENT> <DEDENT> for c in A : <NEWLINE> <INDENT> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( T , 0 , int ( c [ 1 ] ) ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) if find ( 0 , int ( c [ 1 ] ) ) else print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ino_res = [ ] <NEWLINE> ino ( 0 ) <NEWLINE> pre_res = [ ] <NEWLINE> pre ( 0 ) <NEWLINE> print ( <STRING> + <STRING> . join ( ino_res ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( pre_res ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if any ( j == 0 for j in A ) == True : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> before = arr [ s ] <NEWLINE> after = arr [ i ] <NEWLINE> if after > before : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> s += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> n = str ( n ) <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> total += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> if total % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , copy , heapq , string <NEWLINE> from collections import * <NEWLINE> from math import * <NEWLINE> from itertools import * <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> k = gcd ( n , m ) <NEWLINE> l = n * m // k <NEWLINE> <NL> for i in range ( 0 , l , l // k ) : <NEWLINE> <INDENT> if ( n * i ) % l == ( m * i ) % l == 0 and s [ n * i // l ] != t [ m * i // l ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> kekka = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> kekka [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( kekka [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> PARTS = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> global PARTS2 <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> if judgeStr2 ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def judgeStr2 ( target : str ) -> bool : <NEWLINE> <INDENT> currentStr = target <NEWLINE> while currentStr != <STRING> : <NEWLINE> <INDENT> isNextOK = False <NEWLINE> for item in PARTS : <NEWLINE> <INDENT> if not currentStr . startswith ( item ) : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> tempStr = currentStr . replace ( item , <STRING> , 1 ) <NEWLINE> if tempStr == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> for item2 in PARTS : <NEWLINE> <INDENT> if tempStr . startswith ( item2 ) : <NEWLINE> <INDENT> isNextOK = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if isNextOK : <NEWLINE> <INDENT> currentStr = tempStr <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if isNextOK : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return currentStr == <STRING> <NEWLINE> <NL> <NL> <DEDENT> def judgeStr ( target : str ) -> bool : <NEWLINE> <INDENT> for item in PARTS : <NEWLINE> <INDENT> if target . startswith ( item ) : <NEWLINE> <INDENT> tempStr = target . replace ( item , <STRING> , 1 ) <NEWLINE> if tempStr == <STRING> or judgeStr ( tempStr ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S_str = str ( input ( ) ) <NEWLINE> S = int ( S_str [ - 1 ] ) <NEWLINE> N = len ( S_str ) <NEWLINE> <NL> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] = 1 <NEWLINE> now = S % 2019 <NEWLINE> mod [ now ] += 1 <NEWLINE> <NL> for i in range ( N - 1 ) [ : : - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> next = pow ( 10 , N - 1 - i , 2019 ) <NEWLINE> next = ( next * int ( S_str [ i ] ) ) % 2019 <NEWLINE> now = ( now + next ) % 2019 <NEWLINE> mod [ now ] += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> def culc ( x ) : <NEWLINE> <INDENT> return x * ( x - 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( len ( mod ) ) : <NEWLINE> <INDENT> ans += culc ( mod [ j ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> l . append ( p [ i ] ) <NEWLINE> <DEDENT> print ( sum ( l ) ) <NEWLINE>
input = __import__ ( <STRING> ) . stdin . readline <NEWLINE> def getdist ( a , b ) : return abs ( a [ 0 ] - b [ 0 ] ) + abs ( a [ 1 ] - b [ 1 ] ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( n ) : s . append ( [ * map ( int , input ( ) . split ( ) ) ] ) <NEWLINE> ans = 0 <NEWLINE> sx = sorted ( s ) <NEWLINE> sy = sorted ( s , key = lambda x : x [ 1 ] ) <NEWLINE> ans = max ( ans , getdist ( sx [ - 1 ] , sx [ - 2 ] ) ) <NEWLINE> ans = max ( ans , getdist ( sx [ 0 ] , sx [ 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( sy [ - 1 ] , sy [ - 2 ] ) ) <NEWLINE> ans = max ( ans , getdist ( sy [ 0 ] , sy [ 1 ] ) ) <NEWLINE> def ff1 ( x ) : return x [ 0 ] + x [ 1 ] <NEWLINE> def ff2 ( x ) : return x [ 0 ] - x [ 1 ] <NEWLINE> f1 = sorted ( s , key = ff1 ) <NEWLINE> f2 = sorted ( s , key = ff2 ) <NEWLINE> ans = max ( ans , getdist ( f1 [ 0 ] , f1 [ - 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f1 [ 0 ] , f1 [ 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f1 [ - 1 ] , f1 [ - 2 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f2 [ 0 ] , f2 [ - 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f2 [ 0 ] , f2 [ 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f2 [ - 1 ] , f2 [ - 2 ] ) ) <NEWLINE> def ff1 ( x ) : return abs ( x [ 0 ] + x [ 1 ] ) <NEWLINE> def ff2 ( x ) : return abs ( x [ 0 ] - x [ 1 ] ) <NEWLINE> f1 = sorted ( s , key = ff1 ) <NEWLINE> f2 = sorted ( s , key = ff2 ) <NEWLINE> ans = max ( ans , getdist ( f1 [ 0 ] , f1 [ - 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f1 [ 0 ] , f1 [ 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f1 [ - 1 ] , f1 [ - 2 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f2 [ 0 ] , f2 [ - 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f2 [ 0 ] , f2 [ 1 ] ) ) <NEWLINE> ans = max ( ans , getdist ( f2 [ - 1 ] , f2 [ - 2 ] ) ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , read ( ) . split ( ) ) <NEWLINE> target = set ( ) <NEWLINE> row = [ 0 ] * h <NEWLINE> col = [ 0 ] * w <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> hi , wi = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> target . add ( ( hi , wi ) ) <NEWLINE> row [ hi ] += 1 <NEWLINE> col [ wi ] += 1 <NEWLINE> <DEDENT> row_max = max ( row ) <NEWLINE> r = [ i for i in range ( h ) if row [ i ] == row_max ] <NEWLINE> col_max = max ( col ) <NEWLINE> c = [ i for i in range ( w ) if col [ i ] == col_max ] <NEWLINE> for ri in r : <NEWLINE> <INDENT> for ci in c : <NEWLINE> <INDENT> if ( ri , ci ) not in target : <NEWLINE> <INDENT> print ( row_max + col_max ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( row_max + col_max - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from math import isinf <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e5 ) ) <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> v_from , v_to = map ( int , v_detail ) <NEWLINE> init_adj_table [ v_from ] . append ( v_to ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def Tarjan ( current , low , disc , scc_stack , in_scc_stack ) : <NEWLINE> <INDENT> global timer <NEWLINE> disc [ current ] = low [ current ] = timer <NEWLINE> timer += 1 <NEWLINE> <NL> in_scc_stack [ current ] = True <NEWLINE> scc_stack . append ( current ) <NEWLINE> <NL> current_scc_set = set ( ) <NEWLINE> for adj in adj_table [ current ] : <NEWLINE> <INDENT> if isinf ( disc [ adj ] ) : <NEWLINE> <INDENT> Tarjan ( adj , low , disc , scc_stack , in_scc_stack ) <NEWLINE> low [ current ] = min ( low [ current ] , low [ adj ] ) <NEWLINE> <NL> <DEDENT> elif in_scc_stack [ adj ] : <NEWLINE> <INDENT> low [ current ] = min ( low [ current ] , disc [ adj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> scc_candidate = - 1 <NEWLINE> if disc [ current ] == low [ current ] : <NEWLINE> <INDENT> while scc_candidate != current : <NEWLINE> <INDENT> scc_candidate = scc_stack . pop ( ) <NEWLINE> current_scc_set . add ( scc_candidate ) <NEWLINE> in_scc_stack [ scc_candidate ] = False <NEWLINE> <NL> <DEDENT> init_scc_sets_list . append ( current_scc_set ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def scc ( ) : <NEWLINE> <INDENT> disc = [ float ( <STRING> ) ] * vertices <NEWLINE> low = [ float ( <STRING> ) ] * vertices <NEWLINE> scc_stack = list ( ) <NEWLINE> in_scc_stack = [ False ] * vertices <NEWLINE> <NL> for v in range ( vertices ) : <NEWLINE> <INDENT> if isinf ( disc [ v ] ) : <NEWLINE> <INDENT> Tarjan ( v , low , disc , scc_stack , in_scc_stack ) <NEWLINE> <NL> <DEDENT> <DEDENT> return init_scc_sets_list <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> for question in q_list : <NEWLINE> <INDENT> flag = False <NEWLINE> ele1 , ele2 = map ( int , question ) <NEWLINE> for each in scc_sets_list : <NEWLINE> <INDENT> if ( ele1 in each ) and ( ele2 in each ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : edges + 1 ] ) <NEWLINE> q_num = int ( _input [ edges + 1 ] ) <NEWLINE> q_list = map ( lambda x : x . split ( ) , _input [ edges + 2 : ] ) <NEWLINE> <NL> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> timer = 0 <NEWLINE> init_scc_sets_list = [ ] <NEWLINE> scc_sets_list = scc ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> max_a = a [ - 1 ] <NEWLINE> <NL> q = [ 0 ] * ( max_a + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if q [ i ] == 1 or q [ i ] == - 1 : <NEWLINE> <INDENT> q [ i ] = - 1 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( 2 * i , max_a + 1 , i ) : <NEWLINE> <INDENT> q [ j ] = - 1 <NEWLINE> <DEDENT> q [ i ] = 1 <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in q : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> n = 1 <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> n = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 7 % k <NEWLINE> s = r <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if r == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif n > 1000000 : <NEWLINE> <INDENT> n = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( r * 10 + s ) % k <NEWLINE> n += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
import sys <NEWLINE> a = sys . stdin . readline ( ) <NEWLINE> A = int ( a ) <NEWLINE> P = 1 <NEWLINE> I = 1 <NEWLINE> W = 10 ** 9 + 7 <NEWLINE> while I <= A : <NEWLINE> <INDENT> P *= I <NEWLINE> I += 1 <NEWLINE> P %= W <NEWLINE> <DEDENT> print ( P ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> l . append ( x ) <NEWLINE> <NL> <DEDENT> l2 = list ( set ( l ) ) <NEWLINE> print ( len ( l2 ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> t = 7 % k <NEWLINE> a = [ t ] * ( k + 1 ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 7 % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> a [ i + 1 ] = ( 10 * a [ i ] + 7 ) % k <NEWLINE> if a [ i + 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( c + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = { 0 } <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( S ) - 1 ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if d [ 0 ] != 0 or 0 in d [ 1 : ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> lis = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lis [ d [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if lis [ i ] == 0 and lis [ i + 1 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> s = 1 <NEWLINE> <NL> i = 0 <NEWLINE> while i + 1 <= n - 1 and lis [ i + 1 ] != 0 : <NEWLINE> <INDENT> s = ( s * pow ( lis [ i ] , lis [ i + 1 ] , 998244353 ) ) % 998244353 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum = sum ( a ) <NEWLINE> a_list = [ ] <NEWLINE> for num in a : <NEWLINE> <INDENT> a_sum -= num <NEWLINE> a_list . append ( a_sum ) <NEWLINE> <DEDENT> total = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans = a [ i ] * a_list [ i ] <NEWLINE> total += ans <NEWLINE> if total > 10 ** 9 + 7 : <NEWLINE> <INDENT> total = total % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 1 or m == 1 : <NEWLINE> <INDENT> print ( max ( n , m ) - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * m - ( n * 2 + ( m - 2 ) * 2 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> key = bisect . bisect_right ( P , X ) <NEWLINE> small = 101 <NEWLINE> large = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if P [ key - 1 ] - i not in P : <NEWLINE> <INDENT> small = P [ key - 1 ] - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if P [ key - 1 ] + i not in P : <NEWLINE> <INDENT> large = P [ key - 1 ] + i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( small if abs ( X - small ) <= abs ( X - large ) else large ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> li_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for idx , v in enumerate ( li_a ) : <NEWLINE> <INDENT> if idx <= ( k - 1 ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if v > li_a [ idx - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque , Counter , defaultdict <NEWLINE> from itertools import chain , combinations <NEWLINE> import json <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> from functools import lru_cache <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> M = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 17 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> @ lru_cache ( None ) <NEWLINE> def f ( i , j ) : <NEWLINE> <INDENT> if i < 0 or j < 0 : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if abs ( j - i // 2 - 1 ) >= 2 : <NEWLINE> <INDENT> return - INF <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if j == 1 : <NEWLINE> <INDENT> return max ( A [ : i ] ) <NEWLINE> <DEDENT> return max ( A [ i - 1 ] + f ( i - 2 , j - 1 ) , f ( i - 1 , j ) ) <NEWLINE> <NL> <DEDENT> print ( f ( N , math . floor ( N / 2 ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> <NL> if ( t in s ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> result = [ 0 ] * ( ( len ( s ) - len ( t ) ) + 1 ) <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> result [ i ] = len ( t ) <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if ( s [ i + j ] == t [ j ] ) : <NEWLINE> <INDENT> result [ i ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( result ) ) <NEWLINE>
y = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> c = raw_input ( ) . lower ( ) <NEWLINE> y = y + c <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i ) , y . count ( chr ( i ) ) ) ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> min1 = a [ 0 ] <NEWLINE> max1 = - float ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> max1 = max ( a [ i ] - min1 , max1 ) <NEWLINE> min1 = min ( a [ i ] , min1 ) <NEWLINE> <DEDENT> print ( max1 ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> <NL> n = len ( S ) <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( S [ n - i - 1 ] ) <NEWLINE> b += a * pow ( 10 , i , 2019 ) <NEWLINE> b %= 2019 <NEWLINE> d [ b ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for k , v in d . items ( ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans += v <NEWLINE> <DEDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def memoize ( f ) : <NEWLINE> <INDENT> table = { } <NEWLINE> def func ( * args ) : <NEWLINE> <INDENT> if not args in table : <NEWLINE> <INDENT> table [ args ] = f ( * args ) <NEWLINE> <DEDENT> return table [ args ] <NEWLINE> <DEDENT> return func <NEWLINE> <NL> <DEDENT> @ memoize <NEWLINE> def tsp ( p , v ) : <NEWLINE> <INDENT> if ( 1 << point_size ) - 1 == v : <NEWLINE> <INDENT> return distance_table [ p ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return min ( distance_table [ p ] [ x ] + tsp ( x , v | ( 1 << x ) ) for x in range ( point_size ) if not ( v & ( 1 << x ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> from sys import stdin <NEWLINE> from collections import defaultdict <NEWLINE> from math import isinf <NEWLINE> <NL> readline = stdin . readline <NEWLINE> <NL> point_size , e = map ( int , readline ( ) . split ( ) ) <NEWLINE> distance_table = [ [ float ( <STRING> ) ] * point_size for _ in range ( point_size ) ] <NEWLINE> for _ in range ( e ) : <NEWLINE> <INDENT> s , t , d = map ( int , readline ( ) . split ( ) ) <NEWLINE> distance_table [ s ] [ t ] = d <NEWLINE> <DEDENT> ans = tsp ( 0 , 1 ) <NEWLINE> print ( - 1 if isinf ( ans ) else ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> info = [ tuple ( map ( int , s . split ( ) ) ) for s in sys . stdin . readlines ( ) ] <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> for a , b in info : <NEWLINE> <INDENT> a -= 1 ; b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = min ( uf . parents ) <NEWLINE> <NL> print ( - ans ) <NEWLINE>
[ print ( <STRING> if x [ 0 ] + x [ 1 ] == x [ 2 ] else <STRING> ) for x in [ sorted ( [ x * x for x in [ int ( i ) for i in input ( ) . split ( <STRING> ) ] ] ) for _ in range ( int ( input ( ) ) ) ] ] <NEWLINE>
import math <NEWLINE> from collections import Counter <NEWLINE> s = list ( input ( ) ) <NEWLINE> s = list ( map ( int , s ) ) <NEWLINE> dict_s = Counter ( s ) <NEWLINE> <COMMENT> <NL> print ( ( min ( dict_s [ 0 ] , dict_s [ 1 ] ) ) * 2 ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> one = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> one += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = s <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if K <= one : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> if ( k == 0 or k == ( W - 1 ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> d = Counter ( A ) <NEWLINE> <COMMENT> <NL> ans = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if d [ b ] != 0 : <NEWLINE> <INDENT> ans -= d [ b ] * b <NEWLINE> ans -= d [ c ] * c <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> ans += d [ c ] * c <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = ( n - k + 2 ) * ( ( ( k + n + 1 ) * ( n + 1 ) ) + 2 ) // 2 <NEWLINE> b = ( ( ( n + 1 ) * ( n + 2 ) ) ) * ( 2 * n + 3 ) // 6 <NEWLINE> c = ( ( ( k - 1 ) * k ) ) * ( 2 * k - 1 ) // 6 <NEWLINE> <NL> print ( ( a - b + c ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> calc = input ( ) <NEWLINE> if <STRING> in calc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( eval ( calc . replace ( <STRING> , <STRING> ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def intinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def binary_search ( S , k ) : <NEWLINE> <INDENT> a = 0 ; b = len ( S ) - 1 <NEWLINE> if b == 0 : return S [ 0 ] == k <NEWLINE> while b - a > 1 : <NEWLINE> <INDENT> c = ( a + b ) // 2 <NEWLINE> if k <= S [ c ] : b = c <NEWLINE> else : a = c <NEWLINE> <DEDENT> return S [ a ] == k or S [ b ] == k <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = intinput ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = intinput ( ) <NEWLINE> count = 0 <NEWLINE> for k in T : <NEWLINE> <INDENT> if binary_search ( S , k ) : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> N , K = I ( ) <NEWLINE> S = list ( s ( ) ) <NEWLINE> num = 1 <NEWLINE> cnt = 0 <NEWLINE> L = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> L . append ( num ) <NEWLINE> num = 0 <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> num += 1 <NEWLINE> <DEDENT> L . append ( num ) <NEWLINE> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ruiseki = [ 0 ] + list ( itertools . accumulate ( L ) ) <NEWLINE> l = len ( ruiseki ) <NEWLINE> if cnt <= K : <NEWLINE> <INDENT> print ( N ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> start = 0 <NEWLINE> ans = 0 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> start = 1 <NEWLINE> <DEDENT> for i in range ( start , l , 2 ) : <NEWLINE> <INDENT> if i + K * 2 + 1 > l - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , ruiseki [ i + K * 2 + 1 ] - ruiseki [ i ] ) <NEWLINE> <DEDENT> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , ruiseki [ K * 2 ] ) <NEWLINE> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , ruiseki [ - 1 ] - ruiseki [ l - K * 2 - 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = ii ( ) <NEWLINE> a = li ( ) <NEWLINE> a = sorted ( a ) <NEWLINE> a_max = a [ - 1 ] <NEWLINE> sive = [ True ] * ( a_max + 1 ) <NEWLINE> <NL> def sived ( x ) : <NEWLINE> <INDENT> for non_ans in range ( x , a_max + 1 , x ) : <NEWLINE> <INDENT> sive [ non_ans ] = False <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if sive [ a [ i ] ] : <NEWLINE> <INDENT> sived ( a [ i ] ) <NEWLINE> if a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if sive [ a_max ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = 7 + 10 ** 9 <NEWLINE> <NL> s = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> ans += s * A [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> r = float ( input ( <STRING> ) ) <NEWLINE> S = r * r * math . pi <NEWLINE> l = 2 * math . pi * r <NEWLINE> print ( <STRING> . format ( S , l ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> Ss = S % 60 <NEWLINE> Sm = ( ( S - Ss ) // 60 ) % 60 <NEWLINE> Sh = ( ( S - Ss ) // 60 ) // 60 <NEWLINE> print ( <STRING> % ( Sh , Sm , Ss ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> b = a + a + b <NEWLINE> b . sort ( reverse = 1 ) <NEWLINE> print ( sum ( b [ 2 : n ] ) + b [ 0 ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> gates = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> gates = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> min_data = 0 <NEWLINE> max_data = 10 ** 5 + 1 <NEWLINE> <NL> for gate in gates : <NEWLINE> <INDENT> if min_data < gate [ 0 ] : <NEWLINE> <INDENT> min_data = min ( gate ) <NEWLINE> <DEDENT> if max_data > gate [ 1 ] : <NEWLINE> <INDENT> max_data = max ( gate ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( list ( range ( min_data , max_data + 1 ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> from math import gcd <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> ans = 0 <NEWLINE> <STRING> <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> temp = gcd ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += gcd ( temp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> num_r = s . count ( <STRING> ) <NEWLINE> num_g = s . count ( <STRING> ) <NEWLINE> num_b = s . count ( <STRING> ) <NEWLINE> <NL> ans = num_r * num_g * num_b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if ( k < n ) and ( s [ i ] != s [ j ] ) and ( s [ j ] != s [ k ] ) and ( s [ k ] != s [ i ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> s = deque ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> while len ( s ) > 1 : <NEWLINE> <INDENT> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> s . popleft ( ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . popleft ( ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> INF = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> kotae = 0 <NEWLINE> nissuu = [ 0 ] * 26 <NEWLINE> key = <STRING> <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> nissuu = [ 0 ] * 26 <NEWLINE> ans = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> t = ( i + k ) % 26 + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if j == t - 1 : <NEWLINE> <INDENT> nissuu [ j ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nissuu [ j ] += 1 <NEWLINE> <DEDENT> ans -= c [ j ] * nissuu [ j ] <NEWLINE> <DEDENT> ans += s [ i ] [ t - 1 ] <NEWLINE> if kotae <= ans : <NEWLINE> <INDENT> kotae = ans <NEWLINE> key = k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( ( i + key ) % 26 + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> cnt = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> limit = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> q = 0 <NEWLINE> <NL> if 0 in x : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in x : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > limit : <NEWLINE> <INDENT> q = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if q == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if ( arr [ i ] < arr [ i + k ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> D = collections . deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * n <NEWLINE> visited [ 0 ] = True <NEWLINE> <NL> while D : <NEWLINE> <INDENT> v = D . popleft ( ) <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if visited [ i ] : continue <NEWLINE> visited [ i ] = True <NEWLINE> ans [ i ] = v <NEWLINE> D . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ss = <STRING> . join ( s . replace ( <STRING> , <STRING> ) ) <NEWLINE> if ss != ss [ : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> left = 0 <NEWLINE> right = n - 1 <NEWLINE> while left <= right : <NEWLINE> <INDENT> if s [ left ] == s [ right ] : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ left ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , insort_left <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> <NL> INPUT = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> INT = lambda : int ( INPUT ( ) ) <NEWLINE> MAP = lambda : map ( int , INPUT ( ) . split ( ) ) <NEWLINE> S_MAP = lambda : map ( str , INPUT ( ) . split ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , INPUT ( ) . split ( ) ) ) <NEWLINE> S_LIST = lambda : list ( map ( str , INPUT ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = INPUT ( ) <NEWLINE> t = INPUT ( ) <NEWLINE> <NL> s = [ ord ( i ) for i in sorted ( s ) ] <NEWLINE> t = [ ord ( i ) for i in sorted ( t ) ] <NEWLINE> t . reverse ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if x < t [ cnt ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif x > t [ cnt ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == len ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if len ( s ) < len ( t ) else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W , M = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> H_freq = [ 0 ] * H <NEWLINE> W_freq = [ 0 ] * W <NEWLINE> <NL> table = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> h , w = [ int ( n ) - 1 for n in input ( ) . split ( ) ] <NEWLINE> H_freq [ h ] += 1 <NEWLINE> W_freq [ w ] += 1 <NEWLINE> table . append ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> max_h = max ( H_freq ) <NEWLINE> max_w = max ( W_freq ) <NEWLINE> most_freqent_h = [ i for i , h in enumerate ( H_freq ) if h == max_h ] <NEWLINE> most_freqent_w = [ i for i , w in enumerate ( W_freq ) if w == max_w ] <NEWLINE> <NL> count = 0 <NEWLINE> for ( h , w ) in table : <NEWLINE> <INDENT> if H_freq [ h ] == max_h and W_freq [ w ] == max_w : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count < len ( most_freqent_h ) * len ( most_freqent_w ) : <NEWLINE> <INDENT> print ( max_h + max_w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max_h + max_w - 1 ) <NEWLINE> <DEDENT>
from functools import lru_cache <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> query = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif i >= n or m < A [ i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( i + 1 , m - A [ i ] ) or solve ( i + 1 , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> for m in query : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 for i in range ( N ) ] <NEWLINE> for x in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> tmp = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if tmp <= N : <NEWLINE> <INDENT> ans [ tmp - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ i ] < A [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * m [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans <= pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> j = True <NEWLINE> if lis . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in lis : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> j = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if j : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> cnt_max = 0 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cnt_max = cnt <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( cnt_max ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> num = n - k <NEWLINE> <NL> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if a [ i - 1 ] >= a [ i + k - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> s = sys . stdin . read ( ) . lower ( ) <NEWLINE> for i in range ( 97 , 123 ) : <NEWLINE> <INDENT> print ( chr ( i ) , <STRING> , s . count ( chr ( i ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = 0 <NEWLINE> for i in range ( N // 2 ) : <NEWLINE> <INDENT> tmp += A [ 2 * i + 1 ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> if sum ( A ) > 2 * tmp : <NEWLINE> <INDENT> ans . append ( sum ( A ) - 2 * tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans . append ( 2 * A [ i ] - ans [ - 1 ] ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list . sort ( ) <NEWLINE> ans2 = a_list [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans2 = gcd ( ans2 , a_list [ i ] ) <NEWLINE> if ans2 == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans2 != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> max_a = a_list [ n - 1 ] + 1 <NEWLINE> num_flag_list = [ True ] * max_a <NEWLINE> d_list = list ( range ( 0 , max_a ) ) <NEWLINE> d_list [ 0 ] = 1 <NEWLINE> num_flag_list [ 0 ] = num_flag_list [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( max_a ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if num_flag_list [ i ] : <NEWLINE> <INDENT> for j in range ( i ** 2 , max_a , i ) : <NEWLINE> <INDENT> if num_flag_list [ j ] == True : <NEWLINE> <INDENT> num_flag_list [ j ] = False <NEWLINE> d_list [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> p_set = set ( ) <NEWLINE> for a in a_list : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> temp_p_set = set ( ) <NEWLINE> while True : <NEWLINE> <INDENT> p = d_list [ a ] <NEWLINE> if p not in temp_p_set : <NEWLINE> <INDENT> if p in p_set : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> temp_p_set . add ( p ) <NEWLINE> p_set . add ( p ) <NEWLINE> a = a // p <NEWLINE> if a == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in As : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> inf = 10 ** 18 <NEWLINE> for a in As : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> n , m = l ( ) <NEWLINE> p = [ - 1 ] * n <NEWLINE> def root ( x ) : <NEWLINE> <INDENT> if p [ x ] < 0 : return x <NEWLINE> p [ x ] = root ( p [ x ] ) ; return p [ x ] <NEWLINE> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x , y = root ( x ) , root ( y ) <NEWLINE> if x == y : return <NEWLINE> p [ x ] += p [ y ] <NEWLINE> p [ y ] = x <NEWLINE> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return root ( x ) == root ( y ) <NEWLINE> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - p [ r ( x ) ] <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = l ( ) <NEWLINE> union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> print ( - min ( p ) ) <NEWLINE>
import copy <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <STRING> <NEWLINE> a = list ( set ( K ) ) <NEWLINE> <COMMENT> <NL> a_count = { } <NEWLINE> <NL> <NL> <NL> a_count = Counter ( K ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> ans_dict = 0 <NEWLINE> for l in a_count . values ( ) : <NEWLINE> <NL> <INDENT> ans_dict += l * ( l - 1 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <STRING> <NEWLINE> <NL> for i in K : <NEWLINE> <INDENT> print ( ans_dict - ( a_count [ i ] - 1 ) ) <NEWLINE> pass <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and r == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , r ) : <NEWLINE> <INDENT> p , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> tmp = l [ len ( l ) - p + 1 : len ( l ) ] <NEWLINE> del l [ len ( l ) - p + 1 : len ( l ) ] <NEWLINE> l [ len ( l ) - c : len ( l ) - c ] = tmp <NEWLINE> <NL> <DEDENT> print ( l [ len ( l ) - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def mp ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmp ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n , k = mp ( ) <NEWLINE> a = lmp ( ) <NEWLINE> l = [ ] <NEWLINE> i = 0 <NEWLINE> ch = [ 0 ] * ( n + 1 ) <NEWLINE> while True : <NEWLINE> <INDENT> if ch [ i ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ch [ i ] = 1 <NEWLINE> l . append ( a [ i ] ) <NEWLINE> i = a [ i ] - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> x = l . index ( a [ i ] ) <NEWLINE> y = len ( l ) - x <NEWLINE> <NL> if k <= x : <NEWLINE> <INDENT> print ( l [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ ( k - x - 1 ) % y + x ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = N // ( i + 1 ) <NEWLINE> a += x * ( x + 1 ) * ( i + 1 ) <NEWLINE> <NL> <DEDENT> a = a / 2 <NEWLINE> <NL> print ( int ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( N ) ] <NEWLINE> cl = [ <STRING> . format ( i , j ) for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] for j in range ( 1 , 14 ) if <STRING> . format ( i , j ) not in l ] <NEWLINE> for i in cl : print ( i ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> import heapq <NEWLINE> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> s = input ( ) <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> z = len ( b ) <NEWLINE> for i in range ( len ( r ) ) : <NEWLINE> <INDENT> for j in range ( len ( g ) ) : <NEWLINE> <INDENT> d = abs ( r [ i ] - g [ j ] ) <NEWLINE> e = 0 <NEWLINE> p = min ( r [ i ] , g [ j ] ) - d <NEWLINE> q = max ( r [ i ] , g [ j ] ) + d <NEWLINE> if ( r [ i ] + g [ j ] ) % 2 == 0 : <NEWLINE> <INDENT> t = int ( ( r [ i ] + g [ j ] ) / 2 ) <NEWLINE> if p >= 0 : <NEWLINE> <INDENT> if s [ p ] == <STRING> : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> <DEDENT> if q < n : <NEWLINE> <INDENT> if s [ q ] == <STRING> : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> <DEDENT> if s [ t ] == <STRING> : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p >= 0 : <NEWLINE> <INDENT> if s [ p ] == <STRING> : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> <DEDENT> if q < n : <NEWLINE> <INDENT> if s [ q ] == <STRING> : <NEWLINE> <INDENT> e += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans += ( z - e ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_counter = Counter ( a ) <NEWLINE> k = list ( a_counter . keys ( ) ) <NEWLINE> v = list ( a_counter . values ( ) ) <NEWLINE> <NL> if len ( a_counter ) == 3 and k [ 0 ] ^ k [ 1 ] ^ k [ 2 ] == 0 and v [ 0 ] == v [ 1 ] == v [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( a_counter ) == 2 and 0 in k and ( v [ 0 ] == v [ 1 ] * 2 or v [ 1 ] == v [ 0 ] * 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( a_counter ) == 1 and 0 in k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = A - 1 , B - 1 <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> mark = [ - 1 ] * ( N - 1 ) <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> <NL> di = [ inf ] * N <NEWLINE> di [ 0 ] = 0 <NEWLINE> hq = [ ( 0 , 0 ) ] <NEWLINE> <NL> while hq : <NEWLINE> <INDENT> t , r = heappop ( hq ) <COMMENT> <NEWLINE> if t > di [ r ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for x in graph [ r ] : <NEWLINE> <INDENT> t_new = t + 1 <NEWLINE> r_new = x <NEWLINE> if t_new < di [ r_new ] : <NEWLINE> <INDENT> di [ r_new ] = t_new <NEWLINE> heappush ( hq , ( t_new , r_new ) ) <NEWLINE> if mark [ r_new - 1 ] == - 1 : <NEWLINE> <INDENT> mark [ r_new - 1 ] = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in mark : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] * N <NEWLINE> hmax = 0 <NEWLINE> hmin = 0 <NEWLINE> H = [ 0 ] * ( N - K + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> h [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> h . sort ( ) <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> hmin = h [ i ] <NEWLINE> hmax = h [ i + K - 1 ] <NEWLINE> H [ i ] = hmax - hmin <NEWLINE> <DEDENT> print ( min ( H ) ) <NEWLINE>
NK = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = NK [ 0 ] <NEWLINE> K = NK [ 1 ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> done = [ 1 ] <NEWLINE> donedic = { } <NEWLINE> donedic [ 1 ] = 1 <NEWLINE> now = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> nexttown = A [ now - 1 ] <NEWLINE> <COMMENT> <NL> try : <NEWLINE> <INDENT> a = donedic [ nexttown ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> donedic [ nexttown ] = 1 <NEWLINE> done . append ( nexttown ) <NEWLINE> now = nexttown <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> start = done . index ( nexttown ) <NEWLINE> end = len ( done ) - 1 <NEWLINE> before = start <COMMENT> <NEWLINE> loop = done [ start : ] <NEWLINE> <NL> if K < before : <NEWLINE> <INDENT> saisyuu = done [ K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nokori = K - before <NEWLINE> n_loop = int ( nokori / len ( loop ) ) <NEWLINE> loopfirst = done [ start ] <NEWLINE> hasuu = nokori % len ( loop ) <NEWLINE> saisyuu = loop [ hasuu ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( saisyuu ) <NEWLINE>
S = [ int ( i ) for i in input ( ) ] <NEWLINE> <NL> def solve ( S ) : <NEWLINE> <INDENT> n = len ( S ) <NEWLINE> cum = [ 0 ] * ( n + 1 ) <NEWLINE> mods = [ 0 ] * n <NEWLINE> mods [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> mods [ i ] = mods [ i - 1 ] * 10 % 2019 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cum [ i + 1 ] = ( cum [ i ] + S [ n - 1 - i ] * mods [ i ] ) % 2019 <NEWLINE> <DEDENT> c = [ 0 ] * 2019 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> c [ cum [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for v in c : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( solve ( S ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> if len ( S ) > K : <NEWLINE> <INDENT> answer = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> answer . append ( S [ i ] ) <NEWLINE> <DEDENT> answer . append ( <STRING> ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( len ( answer ) ) : <NEWLINE> <INDENT> s += answer [ i ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = <STRING> <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> g += S [ i ] <NEWLINE> <DEDENT> print ( g ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> A = nl ( ) <NEWLINE> total = sum ( [ abs ( A [ i + 1 ] - A [ i ] ) for i in range ( n - 1 ) ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> start = abs ( A [ 1 ] ) <NEWLINE> end = abs ( A [ - 1 ] ) <NEWLINE> print ( total - abs ( A [ 1 ] - A [ 0 ] ) + start + end ) <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> start = abs ( A [ 0 ] ) <NEWLINE> end = abs ( A [ - 2 ] ) <NEWLINE> print ( total - abs ( A [ - 2 ] - A [ - 1 ] ) + start + end ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = abs ( A [ 0 ] ) <NEWLINE> end = abs ( A [ - 1 ] ) <NEWLINE> print ( total - abs ( A [ i - 1 ] - A [ i ] ) - <NEWLINE> <INDENT> abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i + 1 ] - A [ i - 1 ] ) <NEWLINE> + start + end ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import decimal <NEWLINE> A , B = map ( decimal . Decimal , input ( ) . split ( ) ) <NEWLINE> C = decimal . Decimal ( A ) * decimal . Decimal ( B ) <NEWLINE> <COMMENT> <NL> D = str ( C ) <NEWLINE> D = D . split ( <STRING> ) [ 0 ] <NEWLINE> <COMMENT> <NL> E = int ( D ) <NEWLINE> print ( E ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> p = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p *= i + 1 <NEWLINE> p %= 1000000007 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
import itertools <NEWLINE> n , m , q = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> r = [ i + 1 for i in range ( m ) ] <NEWLINE> point = 0 <NEWLINE> def checker ( x , l ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if x [ l [ i ] [ 1 ] ] - x [ l [ i ] [ 0 ] ] == l [ i ] [ 2 ] : <NEWLINE> <INDENT> p += l [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> l . append ( [ a , b , c , d ] ) <NEWLINE> <DEDENT> for i in itertools . combinations_with_replacement ( r , n ) : <NEWLINE> <INDENT> p = checker ( i , l ) <NEWLINE> if p > point : <NEWLINE> <INDENT> point = p <NEWLINE> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> from math import gcd <NEWLINE> from math import sqrt <NEWLINE> from sys import stdin <NEWLINE> def input ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def mips ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , M , K = mips ( ) <NEWLINE> A = [ i for i in mips ( ) ] <NEWLINE> B = [ i for i in mips ( ) ] <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> clock = K <NEWLINE> A2 = [ 0 ] <NEWLINE> B2 = [ 0 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ai = A2 [ i - 1 ] + A [ i - 1 ] <NEWLINE> A2 . append ( ai ) <NEWLINE> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> bi = B2 [ i - 1 ] + B [ i - 1 ] <NEWLINE> B2 . append ( bi ) <NEWLINE> <DEDENT> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A2 [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( B2 [ j ] + A2 [ i ] > K ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) ; <NEWLINE> print ( int ( a . split ( ) [ 0 ] ) * int ( a . split ( ) [ 1 ] ) , int ( a . split ( ) [ 0 ] ) * 2 + int ( a . split ( ) [ 1 ] ) * 2 , end = <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] / a [ i - k ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> lst1 = [ 0 ] * n <NEWLINE> lst2 = [ 0 ] * n <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p = i - a [ i - 1 ] <NEWLINE> q = i + a [ i - 1 ] <NEWLINE> <NL> if 0 <= p < n : <NEWLINE> <INDENT> lst1 [ p ] += 1 <NEWLINE> <DEDENT> if 0 <= q < n : <NEWLINE> <INDENT> lst2 [ q ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cnt += lst1 [ i ] * lst2 [ i ] <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> d = defaultdict ( lambda : 0 ) <NEWLINE> for key in A : <NEWLINE> <INDENT> d [ key ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cmb = dict ( ) <NEWLINE> cmb2 = dict ( ) <NEWLINE> for k in d . keys ( ) : <NEWLINE> <INDENT> cmb [ k ] = d [ k ] * ( d [ k ] - 1 ) // 2 <NEWLINE> cmb2 [ k ] = ( d [ k ] - 1 ) * ( d [ k ] - 2 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans_d = dict ( ) <NEWLINE> s = sum ( cmb . values ( ) ) <NEWLINE> for k in d . keys ( ) : <NEWLINE> <INDENT> ans_d [ k ] = s - cmb [ k ] + cmb2 [ k ] <NEWLINE> <COMMENT> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( ans_d [ a ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( S + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 0 <NEWLINE> if S >= 2 : <NEWLINE> <INDENT> dp [ 2 ] = 0 <NEWLINE> <DEDENT> for i in range ( 3 , S + 1 , 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , i - 2 , 1 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> return dp [ S ] % 1000000007 <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % ( a + b ) <= a : <NEWLINE> <INDENT> ans = n // ( a + b ) * a + n % ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = n // ( a + b ) * a + a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 10 ** 6 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a . append ( a [ i ] + k ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) - n + 1 ) : <NEWLINE> <INDENT> t = min ( t , a [ i + n - 1 ] - a [ i ] ) <NEWLINE> <NL> <DEDENT> print ( t ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ <STRING> ] * h <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> a [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> row = [ False ] * h <NEWLINE> cal = [ False ] * w <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> row [ i ] = True <NEWLINE> cal [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if row [ i ] : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if cal [ j ] : <NEWLINE> <INDENT> print ( a [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans >= 1000000000000000001 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> youso = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> youso += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> print ( youso , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , youso , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> root = int ( N ** 0.5 ) <NEWLINE> for i in range ( root , - 1 , - 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( N / i + i - 2 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> good = [ 1 for j in range ( n ) ] <NEWLINE> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if height [ a - 1 ] >= height [ b - 1 ] : <NEWLINE> <INDENT> good [ b - 1 ] = 0 <NEWLINE> <DEDENT> if height [ a - 1 ] <= height [ b - 1 ] : <NEWLINE> <INDENT> good [ a - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = good . count ( 1 ) <NEWLINE> print ( ans ) <NEWLINE>
mod = 1000000007 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = sorted ( lst ) <NEWLINE> p = 1 <NEWLINE> if lst [ - 1 ] == 0 and k % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif lst [ - 1 ] < 0 and k % 2 != 0 : <NEWLINE> <INDENT> for i in range ( n - 1 , n - k - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> p = ( p % mod * lst [ i ] % mod ) % mod <NEWLINE> <COMMENT> <NL> <DEDENT> print ( p % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = n - 1 <NEWLINE> if k % 2 != 0 : <NEWLINE> <INDENT> p *= lst [ j ] <NEWLINE> k -= 1 <NEWLINE> j -= 1 <NEWLINE> <DEDENT> k = k // 2 <NEWLINE> i = 0 <NEWLINE> for x in range ( k ) : <NEWLINE> <INDENT> if lst [ i ] * lst [ i + 1 ] > lst [ j ] * lst [ j - 1 ] : <NEWLINE> <INDENT> p = ( p % mod * lst [ i ] % mod * lst [ i + 1 ] % mod ) % mod <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = ( p % mod * lst [ j ] % mod * lst [ j - 1 ] % mod ) % mod <NEWLINE> j -= 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( p % mod ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> ans = 0 <NEWLINE> primes = prime_factorize ( N ) <NEWLINE> pc = Counter ( primes ) <NEWLINE> for v in pc . values ( ) : <NEWLINE> <INDENT> now = 1 <NEWLINE> while now * ( now + 1 ) // 2 <= v : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> ans += now - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> p = p * A [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> p = - 1 <NEWLINE> break <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
n , a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> def pow ( x , n , m ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> res = pow ( x * x % m , n // 2 , m ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> res = res * x % m <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = max ( a , b ) <NEWLINE> inv = [ 0 for i in range ( c + 1 ) ] <NEWLINE> finv = [ 0 for i in range ( c + 1 ) ] <NEWLINE> inv [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , c + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> inv [ i ] = 1000000007 - ( 1000000007 // i ) * inv [ 1000000007 % i ] % 1000000007 <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % 1000000007 <NEWLINE> <DEDENT> def kaizyou ( k ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in range ( n - k + 1 , n + 1 ) : <NEWLINE> <INDENT> num = num * i % 1000000007 <NEWLINE> <DEDENT> return num <NEWLINE> <NL> <DEDENT> def combinations ( k ) : <NEWLINE> <INDENT> return kaizyou ( k ) * finv [ k ] % 1000000007 <NEWLINE> <NL> <DEDENT> print ( ( pow ( 2 , n , 1000000007 ) - combinations ( a ) - combinations ( b ) - 1 ) % 1000000007 ) <NEWLINE> <NL> <NL> <NL> <NL>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ set ( ) for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ a - 1 ] . add ( b ) <NEWLINE> A [ b - 1 ] . add ( a ) <NEWLINE> <DEDENT> visit = [ 0 ] * n <NEWLINE> visit [ 0 ] = n + 1 <NEWLINE> stack = deque ( ) <NEWLINE> stack . append ( 1 ) <NEWLINE> while stack : <NEWLINE> <INDENT> now = stack . popleft ( ) <NEWLINE> for j in A [ now - 1 ] : <NEWLINE> <INDENT> if visit [ j - 1 ] == 0 : <NEWLINE> <INDENT> visit [ j - 1 ] = now <NEWLINE> stack . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( visit ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> print ( visit [ j ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd_ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( gcd_ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> dd = defaultdict ( int ) <NEWLINE> S = list ( input ( ) . rstrip ( ) ) <NEWLINE> tmp = 0 <NEWLINE> dd [ 0 ] += 1 <NEWLINE> r = 1 <NEWLINE> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> tmp += int ( s ) * r <NEWLINE> r *= 10 <NEWLINE> <NL> tmp %= 2019 <NEWLINE> r %= 2019 <NEWLINE> dd [ tmp ] += 1 <NEWLINE> <DEDENT> su = 0 <NEWLINE> for i in dd . values ( ) : <NEWLINE> <INDENT> su += ( i * ( i - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( su ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K - 1 , N - 1 ) : <NEWLINE> <INDENT> a = A [ i - K + 1 ] <NEWLINE> b = A [ i + 1 ] <NEWLINE> if ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> sum_ = 0 <NEWLINE> for i in range ( 1 , 1 + N ) : <NEWLINE> <INDENT> for j in range ( 1 , 1 + N ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , 1 + N ) : <NEWLINE> <INDENT> sum_ += math . gcd ( a , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = ( ans + i * ( s - i ) ) <NEWLINE> <DEDENT> print ( ( ans // 2 ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ( p + 1 ) / 2 for p in P ] <NEWLINE> B = [ 0 for i in range ( N ) ] <NEWLINE> B [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> B [ i ] = B [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( K - 1 , N ) : <NEWLINE> <INDENT> if i == K - 1 : <NEWLINE> <INDENT> a = B [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = B [ i ] - B [ i - K ] <NEWLINE> <DEDENT> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> lim = 10 ** 6 + 7 <NEWLINE> a . sort ( ) <NEWLINE> dp = [ True for i in range ( lim + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] ] : <NEWLINE> <INDENT> if i == n - 1 or a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( lim // a [ i ] + 1 ) : <NEWLINE> <INDENT> dp [ j * a [ i ] ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( 2 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> t = [ 3 ] <NEWLINE> cnt = 3 <NEWLINE> while t [ - 1 ] + cnt <= n : <NEWLINE> <INDENT> t . append ( t [ - 1 ] + cnt ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if t [ - 1 ] != n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> n_cols = t [ - 1 ] - t [ - 2 ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( n_cols + 1 ) <NEWLINE> t_len = len ( t ) <NEWLINE> t2 = [ i + 1 for i in t ] <NEWLINE> t3 = [ 0 for i in t ] <NEWLINE> for col in range ( n_cols + 1 ) : <NEWLINE> <INDENT> out = str ( n_cols ) <NEWLINE> if col <= 2 : <NEWLINE> <INDENT> if col == 0 : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> elif col == 1 : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> elif col == 2 : <NEWLINE> <INDENT> out += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = t [ col - 3 ] + 1 <NEWLINE> while idx <= t [ col - 2 ] : <NEWLINE> <INDENT> out += <STRING> + str ( idx ) <NEWLINE> idx += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( t_len - 1 ) : <NEWLINE> <INDENT> if t2 [ i ] != t [ i + 1 ] + 1 : <NEWLINE> <INDENT> out += <STRING> + str ( t2 [ i ] ) <NEWLINE> t2 [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> b1 = 0 <NEWLINE> d = 0 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( B , reverse = True ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = sorted ( C ) <NEWLINE> D = [ ] <NEWLINE> E = [ ] <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> d = d + len ( C ) - bisect . bisect_right ( C , b ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> D = sorted ( D , reverse = True ) <NEWLINE> B = sorted ( B ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if 0 <= bisect . bisect_right ( B , a ) <= len ( D ) - 1 : <NEWLINE> <INDENT> ans += D [ bisect . bisect_right ( B , a ) ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> R = S [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> z = str ( i ) . zfill ( 3 ) <NEWLINE> right = - 1 <NEWLINE> left = - 1 <NEWLINE> if z [ 2 ] in R : <NEWLINE> <INDENT> r = R . index ( z [ 2 ] ) + 1 <NEWLINE> right = N - r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if z [ 0 ] in S : <NEWLINE> <INDENT> left = S . index ( z [ 0 ] ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if z [ 1 ] in S [ left : right ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = max ( a ) <NEWLINE> p = [ 0 ] * ( ma + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> p [ i ] += 1 <NEWLINE> <NL> <DEDENT> pairwise = True <NEWLINE> for i in range ( 2 , ma + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i , ma + 1 , i ) : <NEWLINE> <INDENT> cnt += p [ j ] <NEWLINE> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pairwise = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = a [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> temp = math . gcd ( temp , i ) <NEWLINE> <DEDENT> if temp == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > 2 : <NEWLINE> <INDENT> s = b // x <NEWLINE> t = ( a - 1 ) // x <NEWLINE> print ( s - t ) <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> print ( b // x ) <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> print ( b // x + 1 ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> not_in_p = list ( range ( - 101 , 102 ) ) <NEWLINE> for pn in p : <NEWLINE> <INDENT> if pn in not_in_p : <NEWLINE> <INDENT> not_in_p . remove ( pn ) <NEWLINE> <NL> <DEDENT> <DEDENT> diff_p = [ ] <NEWLINE> for not_in_pn in not_in_p : <NEWLINE> <INDENT> diff_p . append ( abs ( not_in_pn - X ) ) <NEWLINE> <DEDENT> answer = not_in_p [ diff_p . index ( min ( diff_p ) ) ] <NEWLINE> <NL> print ( answer ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> numlist = [ a , b , c ] <NEWLINE> numlist . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( str , numlist ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> S = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( i + 1 , len ( A ) ) : <NEWLINE> <INDENT> tmp += A [ j ] <NEWLINE> <DEDENT> S += ( tmp % MOD * A [ i ] ) % MOD <NEWLINE> <NL> <NL> <DEDENT> print ( S % MOD ) <NEWLINE> <NL> <NL> <NL> <DEDENT> from itertools import accumulate <NEWLINE> <NL> m = 10 ** 9 + 7 <NEWLINE> <NL> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> b = [ 0 ] * N <NEWLINE> b [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> b [ i ] = b [ i - 1 ] + A [ i ] <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> result += A [ i ] * ( b [ N - 1 ] - b [ i ] ) <NEWLINE> result %= m <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * A [ : : - 2 ] , * A [ N % 2 : : 2 ] ) <NEWLINE>
import numpy as np <NEWLINE> <NL> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> np_ab = np . array ( ab ) <NEWLINE> <NL> max_a = max ( np_ab [ : , 0 ] ) <NEWLINE> dp = [ 0 ] * ( h + max_a ) <NEWLINE> <NL> for i in range ( 1 , h + max_a ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <NL> <DEDENT> print ( dp [ h ] ) <NEWLINE>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ans = s . split ( <STRING> ) [ 1 ] <NEWLINE> a , b = s . split ( <STRING> ) [ 0 ] . split ( <STRING> ) <NEWLINE> for X in range ( 10 ) : <NEWLINE> <INDENT> _a = a . replace ( <STRING> , str ( X ) ) <NEWLINE> if str ( int ( _a ) ) != _a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> _b = b . replace ( <STRING> , str ( X ) ) <NEWLINE> if str ( int ( _b ) ) != _b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> _ans = ans . replace ( <STRING> , str ( X ) ) <NEWLINE> if str ( int ( _ans ) ) != _ans : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if int ( _a ) + int ( _b ) == int ( _ans ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> if <STRING> in s : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> loads = [ [ 0 ] for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> start , end = map ( int , input ( ) . split ( ) ) <NEWLINE> loads [ start - 1 ] . append ( h_list [ end - 1 ] ) <NEWLINE> loads [ end - 1 ] . append ( h_list [ start - 1 ] ) <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> if h_list [ k ] > max ( loads [ k ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> jobs = [ [ ] for _ in range ( M ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A > M : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> jobs [ A - 1 ] . append ( - B ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> heap = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for job in jobs [ i ] : <NEWLINE> <INDENT> heapq . heappush ( heap , job ) <NEWLINE> <NL> <DEDENT> if len ( heap ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += - heapq . heappop ( heap ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( ) <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> b = list ( ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> s += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> noCount = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> minusCount = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> noCount [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> noCount [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> noCount [ <STRING> ] += 1 <NEWLINE> <DEDENT> <DEDENT> RGB = noCount [ <STRING> ] * noCount [ <STRING> ] * noCount [ <STRING> ] <NEWLINE> <NL> for step in range ( 1 , ( N + 1 ) // 2 ) : <NEWLINE> <INDENT> for cenPos in range ( step , N - step ) : <NEWLINE> <INDENT> if S [ cenPos - step ] != S [ cenPos ] and S [ cenPos ] != S [ cenPos + step ] and S [ cenPos - step ] != S [ cenPos + step ] : <NEWLINE> <INDENT> minusCount += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( RGB - minusCount ) <NEWLINE>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> minA = min ( A ) <NEWLINE> minA = int ( minA ) <NEWLINE> M = 10 ** 18 <NEWLINE> <NL> Y = 0 <NEWLINE> if minA != 0 : <NEWLINE> <INDENT> Y = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X = A [ i ] <NEWLINE> X = int ( X ) <NEWLINE> Y = Y * X <NEWLINE> if Y > M : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if Y > M : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Y ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> ins = lambda : input ( ) . rstrip ( ) <NEWLINE> ini = lambda : int ( input ( ) . rstrip ( ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ini ( ) <NEWLINE> a = inl ( ) <NEWLINE> if len ( set ( a ) ) == n : <NEWLINE> <INDENT> print ( n - 2 ) <NEWLINE> <DEDENT> elif len ( set ( a ) ) == 1 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = { } <NEWLINE> s = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if a [ i ] not in f : <NEWLINE> <INDENT> f [ a [ i ] ] = 0 <NEWLINE> <DEDENT> f [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i ] not in s : <NEWLINE> <INDENT> s [ a [ i ] ] = 0 <NEWLINE> <DEDENT> s [ a [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> fsum = sum ( f . values ( ) ) <NEWLINE> ssum = sum ( s . values ( ) ) <NEWLINE> f = sorted ( f . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> s = sorted ( s . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> if f [ 0 ] [ 0 ] == s [ 0 ] [ 0 ] : <NEWLINE> <INDENT> tmp1 = fsum - f [ 0 ] [ 1 ] + ssum - s [ 1 ] [ 1 ] <NEWLINE> tmp2 = fsum - f [ 1 ] [ 1 ] + ssum - s [ 0 ] [ 1 ] <NEWLINE> print ( min ( tmp1 , tmp2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( fsum - f [ 0 ] [ 1 ] + ssum - s [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> R_S = S [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> count = [ 1 ] + [ 0 ] * 2018 <NEWLINE> remainder = 0 <NEWLINE> <NL> i = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> remainder += int ( R_S [ i ] ) * pow ( 10 , i , 2019 ) <NEWLINE> remainder = remainder % 2019 <NEWLINE> ans += count [ remainder ] <NEWLINE> count [ remainder ] += 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if c % a == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> if a > b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL>
a = int ( input ( ) ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def include3 ( n ) : <NEWLINE> <INDENT> cond = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if n % 10 == 3 : <NEWLINE> <INDENT> cond = 1 <NEWLINE> return cond <NEWLINE> <DEDENT> elif n > 9 : <NEWLINE> <INDENT> n //= 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return cond <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or include3 ( i ) == 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
from sys import stdin <NEWLINE> N , K = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> mincost = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mincost += l [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> s = [ ] <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> s . append ( 0 ) <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> cost += l [ j ] [ 0 ] <NEWLINE> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> s [ k ] += l [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> b = 1 <NEWLINE> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if s [ k ] < x : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> <DEDENT> if b == 1 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> mincost = min ( cost , mincost ) <NEWLINE> <DEDENT> for i in range ( m + 1 ) : <NEWLINE> <INDENT> s [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( mincost ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> h . append ( tmp ) <NEWLINE> <DEDENT> h = sorted ( h ) <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> h2 = h [ i ] <NEWLINE> h3 = h [ i + K - 1 ] <NEWLINE> ans = min ( h3 - h2 , ans ) <NEWLINE> <DEDENT> print ( str ( ans ) ) <NEWLINE>
<COMMENT> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if l [ i - k ] < l [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <NL> case = 1 <NEWLINE> for s in sys . stdin : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> C = int ( s ) <NEWLINE> if C == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> V = [ 0 ] <NEWLINE> W = [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> VT = [ [ 0 for i in range ( C + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> WT = [ [ 0 for i in range ( C + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> v , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> V . append ( v ) <NEWLINE> W . append ( w ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> if j >= W [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> value_on_load = VT [ i - 1 ] [ j - W [ i ] ] + V [ i ] <NEWLINE> value_not_load = VT [ i - 1 ] [ j ] <NEWLINE> <NL> weight_on_load = WT [ i - 1 ] [ j - W [ i ] ] + W [ i ] <NEWLINE> weight_not_load = WT [ i - 1 ] [ j ] <NEWLINE> <NL> if value_on_load > value_not_load : <NEWLINE> <INDENT> VT [ i ] [ j ] = value_on_load <NEWLINE> WT [ i ] [ j ] = weight_on_load <NEWLINE> <DEDENT> elif value_on_load == value_not_load : <NEWLINE> <INDENT> VT [ i ] [ j ] = value_on_load <NEWLINE> WT [ i ] [ j ] = min ( weight_on_load , weight_not_load ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> VT [ i ] [ j ] = value_not_load <NEWLINE> WT [ i ] [ j ] = weight_not_load <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> VT [ i ] [ j ] = VT [ i - 1 ] [ j ] <NEWLINE> WT [ i ] [ j ] = WT [ i - 1 ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( case ) ) <NEWLINE> case += 1 <NEWLINE> print ( VT [ N ] [ C ] ) <NEWLINE> print ( WT [ N ] [ C ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt1 = { } <NEWLINE> cnt2 = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> tmp1 = A [ i ] + i + 1 <NEWLINE> tmp2 = i + 1 - A [ i ] <NEWLINE> if tmp1 not in cnt1 : <NEWLINE> <INDENT> cnt1 [ tmp1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt1 [ tmp1 ] += 1 <NEWLINE> <DEDENT> if tmp2 not in cnt2 : <NEWLINE> <INDENT> cnt2 [ tmp2 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt2 [ tmp2 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> diff = set ( list ( cnt1 . keys ( ) ) ) & set ( list ( cnt2 . keys ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for d in diff : <NEWLINE> <INDENT> ans += cnt1 [ d ] * cnt2 [ d ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> row , col = map ( int , input ( ) . split ( ) ) <NEWLINE> spreadsheet = [ ] <NEWLINE> <NL> for i in range ( row ) : <NEWLINE> <INDENT> val = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> val . append ( sum ( val ) ) <NEWLINE> spreadsheet . append ( val ) <NEWLINE> <NL> <DEDENT> for r in spreadsheet : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , r ) ) ) <NEWLINE> <NL> <DEDENT> last_row = [ ] <NEWLINE> for j in range ( len ( spreadsheet [ 0 ] ) ) : <NEWLINE> <INDENT> col_sum = 0 <NEWLINE> for i in range ( len ( spreadsheet ) ) : <NEWLINE> <INDENT> col_sum += spreadsheet [ i ] [ j ] <NEWLINE> <DEDENT> last_row . append ( col_sum ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , last_row ) ) ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> rest = n % k <NEWLINE> print ( min ( rest , k - rest ) ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> A = [ 0 ] + LIST ( ) <NEWLINE> <NL> A = list ( accumulate ( A ) ) <NEWLINE> dic = Counter ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in dic . values ( ) : <NEWLINE> <INDENT> ans += x * ( x - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = [ i for i in range ( - 1 , 102 ) ] <NEWLINE> <NL> for r in p : <NEWLINE> <INDENT> idx = q . index ( r ) <NEWLINE> del q [ idx ] <NEWLINE> <NL> <DEDENT> if X in q : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> q . sort ( ) <NEWLINE> mindif = 1000 <NEWLINE> <NL> for num in q : <NEWLINE> <INDENT> dif = abs ( X - num ) <NEWLINE> if mindif <= dif : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mindif = dif <NEWLINE> ans = num <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> L = [ 0 ] * Q <NEWLINE> R = [ 0 ] * Q <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> L [ i ] , R [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> min_L = min ( L ) <NEWLINE> max_R = max ( R ) <NEWLINE> <NL> check = [ ] <NEWLINE> for i in range ( min_L , max_R + 1 ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) : <NEWLINE> <INDENT> flg = ( is_prime ( i ) and is_prime ( ( i + 1 ) / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = 0 <NEWLINE> <DEDENT> check . append ( flg ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> check = [ 0 ] + check <NEWLINE> check = list ( accumulate ( check ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> print ( check [ R [ i ] - min_L + 1 ] - check [ L [ i ] - min_L ] ) <NEWLINE> <DEDENT>
MAX_VAL = 10 ** 18 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a <NEWLINE> <NL> <DEDENT> if ans > MAX_VAL : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l1 = [ ] <NEWLINE> l2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l1 . append ( a [ i ] + i ) <NEWLINE> l2 . append ( - a [ i ] + i ) <NEWLINE> <DEDENT> j = { } <NEWLINE> ans = 0 <NEWLINE> for i in l1 : <NEWLINE> <INDENT> if i in j : <NEWLINE> <INDENT> j [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in l2 : <NEWLINE> <INDENT> if i in j : <NEWLINE> <INDENT> ans += j [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
even = <STRING> * 151 <NEWLINE> odd = <STRING> * 151 <NEWLINE> while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h // 2 ) : <NEWLINE> <INDENT> print ( even [ : w ] ) <NEWLINE> print ( odd [ : w ] ) <NEWLINE> <DEDENT> if h % 2 != 0 : <NEWLINE> <INDENT> print ( even [ : w ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> p_hist = [ ] <NEWLINE> p_hist_set = set ( ) <NEWLINE> p_hist_index = [ - 1 ] * ( N + 1 ) <NEWLINE> while p not in p_hist_set : <NEWLINE> <INDENT> p_hist_index [ p ] = len ( p_hist ) <NEWLINE> p_hist . append ( p ) <NEWLINE> p_hist_set . add ( p ) <NEWLINE> p = A [ p - 1 ] <NEWLINE> <DEDENT> end_loop = p_hist [ - 1 ] <NEWLINE> end_loop_idx = p_hist_index [ end_loop ] <NEWLINE> start_loop = A [ end_loop - 1 ] <NEWLINE> start_loop_idx = p_hist_index [ start_loop ] <NEWLINE> if K < start_loop_idx : <NEWLINE> <INDENT> print ( p_hist [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p_hist [ ( K - start_loop_idx ) % ( end_loop_idx - start_loop_idx + 1 ) + start_loop_idx ] ) <NEWLINE> <DEDENT>
A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if A > K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A == K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import heapq <NEWLINE> <NL> def move ( P , p ) : <NEWLINE> <INDENT> if p > 3 : <NEWLINE> <INDENT> tmp = P [ : ] <NEWLINE> tmp [ p ] , tmp [ p - 4 ] = tmp [ p - 4 ] , tmp [ p ] <NEWLINE> tmpp = p - 4 <NEWLINE> yield tmp , tmpp <NEWLINE> <DEDENT> if p < 12 : <NEWLINE> <INDENT> tmp = P [ : ] <NEWLINE> tmp [ p ] , tmp [ p + 4 ] = tmp [ p + 4 ] , tmp [ p ] <NEWLINE> tmpp = p + 4 <NEWLINE> yield tmp , tmpp <NEWLINE> <DEDENT> if p % 4 > 0 : <NEWLINE> <INDENT> tmp = P [ : ] <NEWLINE> tmp [ p ] , tmp [ p - 1 ] = tmp [ p - 1 ] , tmp [ p ] <NEWLINE> tmpp = p - 1 <NEWLINE> yield tmp , tmpp <NEWLINE> <DEDENT> if p % 4 < 3 : <NEWLINE> <INDENT> tmp = P [ : ] <NEWLINE> tmp [ p ] , tmp [ p + 1 ] = tmp [ p + 1 ] , tmp [ p ] <NEWLINE> tmpp = p + 1 <NEWLINE> yield tmp , tmpp <NEWLINE> <NL> <DEDENT> <DEDENT> def evaluate ( P , Q ) : <NEWLINE> <INDENT> mht = 0 <NEWLINE> for i in range ( 16 ) : <NEWLINE> <INDENT> pi = P . index ( i ) <NEWLINE> qi = Q . index ( i ) <NEWLINE> pc , pr = pi // 4 , pi % 4 <NEWLINE> qc , qr = qi // 4 , qi % 4 <NEWLINE> mht += abs ( pc - qc ) + abs ( pr - qr ) <NEWLINE> <DEDENT> return mht <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> B = [ int ( i ) % 16 for i in range ( 1 , 17 ) ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> A += [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> dp = { str ( A ) : ( 1 , 0 ) , str ( B ) : ( 2 , 0 ) } <NEWLINE> h = [ ( evaluate ( A , B ) , A , 0 , A . index ( 0 ) ) ] <NEWLINE> e = [ ( evaluate ( A , B ) , B , 0 , 15 ) ] <NEWLINE> heapq . heapify ( h ) <NEWLINE> heapq . heapify ( e ) <NEWLINE> sw = False <NEWLINE> ans = 46 <NEWLINE> while ( len ( h ) > 0 and len ( e ) > 0 ) : <NEWLINE> <INDENT> mht , tmp , count , p = heapq . heappop ( h ) <NEWLINE> if sw and len ( h ) > 0 : <NEWLINE> <INDENT> tmph = ( mht , tmp , count , p ) <NEWLINE> mht , tmp , count , p = heapq . heappop ( h ) <NEWLINE> heapq . heappush ( h , tmph ) <NEWLINE> sw = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sw : <NEWLINE> <INDENT> sw = False <NEWLINE> <DEDENT> <DEDENT> for i , j in move ( tmp , p ) : <NEWLINE> <INDENT> key = str ( i ) <NEWLINE> if key in dp : <NEWLINE> <INDENT> if dp [ key ] [ 0 ] == 2 : <NEWLINE> <INDENT> tmpcount = count + 1 + dp [ key ] [ 1 ] <NEWLINE> if tmpcount < ans : <NEWLINE> <INDENT> ans = tmpcount <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ key ] = ( 1 , count + 1 ) <NEWLINE> mht = evaluate ( B , i ) <NEWLINE> if count + mht * 14 // 13 < ans : <NEWLINE> <INDENT> heapq . heappush ( h , ( mht // 2 + count , i , count + 1 , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> _ , tmp , count , p = heapq . heappop ( e ) <NEWLINE> for i , j in move ( tmp , p ) : <NEWLINE> <INDENT> key = str ( i ) <NEWLINE> if key in dp : <NEWLINE> <INDENT> if dp [ key ] [ 0 ] == 1 : <NEWLINE> <INDENT> tmpcount = count + 1 + dp [ key ] [ 1 ] <NEWLINE> if tmpcount < ans : <NEWLINE> <INDENT> ans = tmpcount <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ key ] = ( 2 , count + 1 ) <NEWLINE> mht = evaluate ( A , i ) <NEWLINE> if count + mht * 14 // 13 < ans : <NEWLINE> <INDENT> heapq . heappush ( e , ( mht // 2 + count , i , count + 1 , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if str ( A ) == <STRING> : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hw = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( hw ) <NEWLINE> y . append ( hw [ 0 ] ) <NEWLINE> x . append ( hw [ 1 ] ) <NEWLINE> <NL> <DEDENT> xc = collections . Counter ( x ) <NEWLINE> yc = collections . Counter ( y ) <NEWLINE> <NL> tuplex = xc . most_common ( ) [ 0 ] <NEWLINE> tupley = yc . most_common ( ) [ 0 ] <NEWLINE> <NL> mostx = tuplex [ 0 ] <NEWLINE> mosty = tupley [ 0 ] <NEWLINE> <NL> if tuplex [ 1 ] > tupley [ 1 ] : <NEWLINE> <INDENT> y = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if l [ i ] [ 1 ] != mostx : <NEWLINE> <INDENT> y . append ( l [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( y ) != 0 : <NEWLINE> <INDENT> yc = collections . Counter ( y ) <NEWLINE> <DEDENT> tupley = yc . most_common ( ) [ 0 ] <NEWLINE> mosty = tupley [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if l [ j ] [ 0 ] == mosty or l [ j ] [ 1 ] == mostx : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> elif tuplex [ 1 ] < tupley [ 1 ] : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if l [ i ] [ 0 ] != mosty : <NEWLINE> <INDENT> x . append ( l [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( x ) != 0 : <NEWLINE> <INDENT> xc = collections . Counter ( x ) <NEWLINE> <DEDENT> tuplex = xc . most_common ( ) [ 0 ] <NEWLINE> mostx = tuplex [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if l [ j ] [ 0 ] == mosty or l [ j ] [ 1 ] == mostx : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans1 = 0 <NEWLINE> x1 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if l [ i ] [ 0 ] != mosty : <NEWLINE> <INDENT> x1 . append ( l [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( x1 ) != 0 : <NEWLINE> <INDENT> x1c = collections . Counter ( x1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1c = collections . Counter ( x ) <NEWLINE> <DEDENT> tuplex1 = x1c . most_common ( ) [ 0 ] <NEWLINE> mostx1 = tuplex1 [ 0 ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if l [ j ] [ 0 ] == mosty or l [ j ] [ 1 ] == mostx1 : <NEWLINE> <INDENT> ans1 += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans2 = 0 <NEWLINE> y1 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if l [ i ] [ 1 ] != mostx : <NEWLINE> <INDENT> y1 . append ( l [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( y1 ) != 0 : <NEWLINE> <INDENT> y1c = collections . Counter ( y1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y1c = collections . Counter ( y ) <NEWLINE> <DEDENT> tupley1 = y1c . most_common ( ) [ 0 ] <NEWLINE> mosty1 = tupley1 [ 0 ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if l [ j ] [ 0 ] == mosty1 or l [ j ] [ 1 ] == mostx : <NEWLINE> <INDENT> ans2 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans1 , ans2 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li_2 = [ ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( min ( li ) , max ( li ) + 1 ) : <NEWLINE> <INDENT> cost_sum = 0 <NEWLINE> for t in range ( N ) : <NEWLINE> <INDENT> cost_sum += ( li [ t ] - i ) ** 2 <NEWLINE> <DEDENT> li_2 . append ( cost_sum ) <NEWLINE> <DEDENT> print ( min ( li_2 ) ) <NEWLINE> <DEDENT>
import math , itertools <NEWLINE> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> a = [ i for i in range ( 1 , K + 1 ) ] <NEWLINE> <NL> x = itertools . combinations ( a , 2 ) <NEWLINE> y = itertools . combinations ( a , 3 ) <NEWLINE> <NL> c = 0 <NEWLINE> for i , j in x : <NEWLINE> <INDENT> c += math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> d = 0 <NEWLINE> for i , j , k in y : <NEWLINE> <INDENT> d += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> ans = sum ( a ) + c * 6 + d * 6 <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif K == 2 : <NEWLINE> <INDENT> ans = 9 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> y , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == y == 0 : break <NEWLINE> for i in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) : <NEWLINE> <INDENT> if ( j % 2 == 1 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> elif ( j % 2 == 0 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> if ( j % 2 == 0 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> elif ( j % 2 == 1 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n_m = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( n_m [ 0 ] ) <NEWLINE> m = int ( n_m [ 1 ] ) <NEWLINE> <NL> field = [ 0 ] * n <NEWLINE> <NL> h = input ( ) . split ( <STRING> ) <NEWLINE> <NL> for m_ in range ( m ) : <NEWLINE> <INDENT> x_y = input ( ) . split ( <STRING> ) <NEWLINE> x = int ( x_y [ 0 ] ) - 1 <NEWLINE> y = int ( x_y [ 1 ] ) - 1 <NEWLINE> if float ( h [ x ] ) > float ( h [ y ] ) : <NEWLINE> <INDENT> field [ y ] += 1 <NEWLINE> <DEDENT> elif float ( h [ x ] ) < float ( h [ y ] ) : <NEWLINE> <INDENT> field [ x ] += 1 <NEWLINE> <DEDENT> elif float ( h [ x ] ) == float ( h [ y ] ) : <NEWLINE> <INDENT> field [ x ] += 1 <NEWLINE> field [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for f in field : <NEWLINE> <INDENT> if f == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math as ma <NEWLINE> <NL> def bs ( num , li ) : <NEWLINE> <INDENT> low , high = 0 , len ( li ) <NEWLINE> if num >= li [ low ] and num <= li [ high - 1 ] : <NEWLINE> <INDENT> while ( low <= high ) : <NEWLINE> <INDENT> center = ma . floor ( ( low + high ) / 2 ) <NEWLINE> if li [ center ] < num : <NEWLINE> <INDENT> low = center + 1 <NEWLINE> <DEDENT> elif li [ center ] > num : <NEWLINE> <INDENT> high = center - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> flag = False <NEWLINE> cnt = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> li1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> li2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in li2 : <NEWLINE> <INDENT> flag = bs ( i , li1 ) <NEWLINE> if flag : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if X < 0 : X *= - 1 <NEWLINE> n = X // D <NEWLINE> if K <= n : print ( X - K * D ) <NEWLINE> else : <NEWLINE> <INDENT> X -= n * D <NEWLINE> K -= n <NEWLINE> if K % 2 == 0 : print ( X ) <NEWLINE> else : print ( - X + D ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k or a >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif c > ( k - ( a + b ) ) : <NEWLINE> <INDENT> s = k - ( a + b ) <NEWLINE> print ( a - 1 * s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> CAM = list ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] ) <NEWLINE> <COMMENT> <NL> minn = 10 ** 18 <NEWLINE> b = False <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> am = [ ] <NEWLINE> <NL> for j in range ( N ) : <COMMENT> <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <COMMENT> <NEWLINE> <INDENT> am . append ( CAM [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> j = False <NEWLINE> sss = [ 0 ] * ( M + 1 ) <NEWLINE> for kk in range ( len ( am ) ) : <NEWLINE> <INDENT> s += am [ kk ] [ 0 ] <NEWLINE> for m in range ( 0 , M ) : <NEWLINE> <INDENT> sss [ m + 1 ] += am [ kk ] [ m + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( [ i for i in sss [ 1 : ] if i >= X ] ) == len ( sss [ 1 : ] ) : <NEWLINE> <INDENT> b = True <NEWLINE> minn = min ( s , minn ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( minn if b == True else - 1 ) <NEWLINE>
s = input ( ) <NEWLINE> count = 0 <NEWLINE> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> summ = 0 <NEWLINE> while i < len ( s ) and s [ i ] == <STRING> : <NEWLINE> <INDENT> summ += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if summ > count : <NEWLINE> <INDENT> count = summ <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> magics = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> max_a = sorted ( magics , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 0 ] <NEWLINE> dp = [ 0 ] * ( h + max_a ) <NEWLINE> for i in range ( 1 , h + max_a ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in magics ) <NEWLINE> <DEDENT> print ( min ( dp [ h : ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * X , = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sorted ( X ) <NEWLINE> <NL> t1 = s [ N // 2 - 1 ] <NEWLINE> t2 = s [ N // 2 ] <NEWLINE> <NL> for x in X : <NEWLINE> <INDENT> if x <= t1 : <NEWLINE> <INDENT> print ( t2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> adj = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ u ] . append ( v ) <NEWLINE> adj [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> c = [ <STRING> ] * n <COMMENT> <NEWLINE> con = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> def BFS_visit ( s ) : <NEWLINE> <INDENT> global c <NEWLINE> global cnt <NEWLINE> global con <NEWLINE> <NL> c [ s ] = <STRING> <NEWLINE> con [ s ] = cnt <NEWLINE> <NL> Q = deque ( ) <NEWLINE> Q . append ( s ) <NEWLINE> while Q : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> for v in adj [ u ] : <NEWLINE> <INDENT> if c [ v ] == <STRING> : <NEWLINE> <INDENT> c [ v ] = <STRING> <NEWLINE> con [ v ] = cnt <NEWLINE> Q . append ( v ) <NEWLINE> <DEDENT> <DEDENT> c [ u ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for u in range ( n ) : <NEWLINE> <INDENT> if c [ u ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> BFS_visit ( u ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> if ( con [ u ] == con [ v ] ) else <STRING> <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 or b == 0 or ( a < 0 and b > 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( a - b ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> H = [ ] <NEWLINE> W = [ ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> temp = input ( ) . split ( ) <NEWLINE> H . append ( int ( temp [ 0 ] ) ) <NEWLINE> W . append ( int ( temp [ 1 ] ) ) <NEWLINE> if H [ - 1 ] == 0 and W [ - 1 ] == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( H ) ) : <NEWLINE> <INDENT> for j in range ( H [ i ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if j == 0 or j == H [ i ] - 1 : <COMMENT> <NEWLINE> <INDENT> for k in range ( W [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for k in range ( W [ i ] - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if i != len ( H ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> tenbo = [ 1 for i in range ( n + 1 ) ] <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ 0 ] + t <NEWLINE> tenbo [ 0 ] = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a ] >= h [ b ] : <NEWLINE> <INDENT> tenbo [ b ] = 0 <NEWLINE> <DEDENT> if h [ a ] <= h [ b ] : <NEWLINE> <INDENT> tenbo [ a ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( tenbo ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def dfs ( tree , n , ans ) : <NEWLINE> <INDENT> for i in tree [ n ] : <NEWLINE> <INDENT> ans [ i ] += ans [ n ] <NEWLINE> tree [ i ] . remove ( n ) <NEWLINE> dfs ( tree , i , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> g [ ab [ i ] [ 0 ] - 1 ] . append ( ab [ i ] [ 1 ] - 1 ) <NEWLINE> g [ ab [ i ] [ 1 ] - 1 ] . append ( ab [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ans [ px [ i - 1 ] [ 0 ] - 1 ] += px [ i - 1 ] [ 1 ] <NEWLINE> <DEDENT> dfs ( g , 0 , ans ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , n - n // 2 + 1 ) : <NEWLINE> <INDENT> ans . append ( a [ i ] ) <NEWLINE> ans . append ( a [ i ] ) <NEWLINE> <DEDENT> print ( sum ( ans [ : n - 1 ] ) ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> s = 0 <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> s += dp [ i - 3 ] <NEWLINE> s = s % 1000000007 <NEWLINE> dp [ i ] = s <NEWLINE> <DEDENT> dp [ 0 ] = 0 <NEWLINE> print ( dp [ n ] ) <NEWLINE>
text = <STRING> <NEWLINE> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> text += input ( ) . lower ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> count = [ 0 for i in range ( 26 ) ] <NEWLINE> for c in text : <NEWLINE> <INDENT> if c < <STRING> or c > <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> count [ ord ( c ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <DEDENT> for i , c in enumerate ( count ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i + ord ( <STRING> ) ) , c ) ) <NEWLINE> <DEDENT>
N = list ( input ( ) ) <NEWLINE> l = len ( N ) <NEWLINE> if N [ l - 1 ] == <STRING> or N [ l - 1 ] == <STRING> or N [ l - 1 ] == <STRING> or N [ l - 1 ] == <STRING> or N [ l - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ l - 1 ] == <STRING> or N [ l - 1 ] == <STRING> or N [ l - 1 ] == <STRING> or N [ l - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ l - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = [ 0 ] * N <NEWLINE> wa = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> P , S = map ( str , input ( ) . split ( ) ) <NEWLINE> P = int ( P ) - 1 <NEWLINE> if ac [ P ] != 1 and S == <STRING> : <NEWLINE> <INDENT> wa += abs ( ac [ P ] ) <NEWLINE> ac [ P ] = 1 <NEWLINE> <DEDENT> elif ac [ P ] != 1 and S == <STRING> : <NEWLINE> <INDENT> ac [ P ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac . count ( 1 ) , wa ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( ( a * x ) // b - a * ( x // b ) ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans_list = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans_list . append ( math . gcd ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , len ( ans_list ) ) : <NEWLINE> <INDENT> ans += math . gcd ( i , ans_list [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from random import sample <NEWLINE> from operator import itemgetter <NEWLINE> e = enumerate <NEWLINE> n , a = open ( 0 ) <NEWLINE> n = int ( n ) <NEWLINE> d = [ 0 ] + [ - 2 ** 64 ] * n <NEWLINE> for j , ( a , i ) in e ( sorted ( sample ( [ ( a , i ) for i , a in e ( map ( int , a . split ( ) ) ) ] , n ) , key = itemgetter ( 0 ) , reverse = 1 ) ) : <NEWLINE> <INDENT> d = [ max ( t + a * ( ~ i - j + k + n ) , d [ k - 1 ] + a * abs ( ~ i + k ) ) for k , t in e ( d ) ] <NEWLINE> <DEDENT> print ( max ( d ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> def solution ( x ) : <NEWLINE> <INDENT> p = sum ( [ math . ceil ( a [ i ] / x ) - 1 for i in range ( N ) ] ) <NEWLINE> return p <NEWLINE> <DEDENT> def solvance ( y , z ) : <NEWLINE> <INDENT> if z - y <= 1 : <NEWLINE> <INDENT> return z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = ( y + z ) // 2 <NEWLINE> <COMMENT> <NL> if solution ( w ) > K : <NEWLINE> <INDENT> return solvance ( w , z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solvance ( y , w ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if K == 0 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ansM = ( sum ( a ) // K ) + 1 <NEWLINE> ansm = sum ( a ) // ( K + N ) <NEWLINE> ans = solvance ( ansm , ansM ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> dp = [ 0 ] * 20001 <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in l ) <NEWLINE> <NL> <DEDENT> print ( dp [ h ] ) <NEWLINE>
import random <NEWLINE> def score ( D , c , s , t ) : <NEWLINE> <INDENT> v = list ( ) <NEWLINE> last = [ 0 ] * 26 <NEWLINE> legacy = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> minus = 0 <NEWLINE> v . append ( legacy ) <NEWLINE> v [ i ] += s [ i ] [ t [ i ] - 1 ] <NEWLINE> last [ t [ i ] - 1 ] = i + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> minus += c [ j ] * ( i + 1 - last [ j ] ) <NEWLINE> <DEDENT> v [ i ] -= minus <NEWLINE> legacy = v [ i ] <NEWLINE> <DEDENT> return v [ D - 1 ] <NEWLINE> <DEDENT> s = list ( ) <NEWLINE> t = list ( ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> t = [ random . randint ( 1 , 26 ) ] * D <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> d = random . randint ( 1 , D ) <NEWLINE> q = random . randint ( 1 , 26 ) <NEWLINE> old = t [ d - 1 ] <NEWLINE> oldscore = score ( D , c , s , t ) <NEWLINE> t [ d - 1 ] = q <NEWLINE> if score ( D , c , s , t ) < oldscore : <NEWLINE> <INDENT> t [ d - 1 ] = old <NEWLINE> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sm = 0 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> c1 = np . count_nonzero ( arr & 1 ) <NEWLINE> sm += 2 ** i * c1 * ( n - c1 ) <NEWLINE> arr >>= 1 <NEWLINE> <NL> <DEDENT> print ( sm % mod ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import itertools <NEWLINE> <NL> s = input ( ) [ : : - 1 ] <NEWLINE> <NL> d = len ( s ) <NEWLINE> <NL> <COMMENT> <NL> _map = [ 0 ] * 2019 <NEWLINE> _map [ 0 ] = 1 <NEWLINE> <NL> ans = 0 <NEWLINE> j , _ = 1 , 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> _ += int ( i ) * j <NEWLINE> _tmp = _ % 2019 <NEWLINE> j = ( j * 10 ) % 2019 <NEWLINE> _map [ _tmp ] += 1 <NEWLINE> <NL> <DEDENT> for _l in _map : <NEWLINE> <INDENT> ans += _l * ( _l - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A_list ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ map ( int , input ( ) . split ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> links = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> links [ a ] . append ( b ) <NEWLINE> links [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> result = [ - 1 ] * ( N + 1 ) <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> i = q . popleft ( ) <NEWLINE> for j in links [ i ] : <NEWLINE> <INDENT> if result [ j ] == - 1 : <NEWLINE> <INDENT> result [ j ] = i <NEWLINE> q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( str ( i ) for i in result [ 2 : ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> Reval = { } <NEWLINE> Geval = { } <NEWLINE> Beval = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> Reval [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> Geval [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> Beval [ 2 * i ] = 2 * i <NEWLINE> <DEDENT> <DEDENT> count = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <NL> for a in R : <NEWLINE> <INDENT> for b in G : <NEWLINE> <INDENT> if ( a + b ) in Beval : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in G : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> if ( a + b ) in Reval : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in B : <NEWLINE> <INDENT> for b in R : <NEWLINE> <INDENT> if ( a + b ) in Geval : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> ca = np . array ( ca ) <NEWLINE> sumX = sum ( ca ) [ 1 : ] <NEWLINE> sumcos = sum ( ca ) [ 0 ] <NEWLINE> cost = sumcos <NEWLINE> if sum ( sumX >= X ) < M : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for a in itertools . combinations ( range ( 1 , N + 1 ) , j ) : <NEWLINE> <INDENT> x = sum ( ca ) [ 1 : ] <NEWLINE> fx = np . array ( [ 0 ] * M ) <NEWLINE> c = sumcos <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> x -= ca [ a [ i ] - 1 ] [ 1 : ] <NEWLINE> c -= ca [ a [ i ] - 1 ] [ 0 ] <NEWLINE> if sum ( x >= X ) < M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost = min ( c , cost ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cost ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> n = N % 10 <NEWLINE> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 1 or n == 6 or n == 8 or n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % 2 : <COMMENT> <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( i + 1 , n - i ) <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if 1 + 2 * i >= n - 1 - 2 * i : <NEWLINE> <INDENT> l1 = i <NEWLINE> break <NEWLINE> <DEDENT> m -= 1 <NEWLINE> print ( i + 1 , n - i ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if i + 1 + l1 >= n - i - l1 - 1 : <NEWLINE> <INDENT> raise Exception ( ) <NEWLINE> <DEDENT> print ( i + 1 + l1 , n - i - l1 - 1 ) <NEWLINE> <DEDENT> <DEDENT>
class MyStack : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . stack = [ 0 for i in range ( size ) ] <NEWLINE> self . size = size <NEWLINE> self . top = 0 <NEWLINE> <NL> <DEDENT> def initialize ( self ) : <NEWLINE> <INDENT> self . top = 0 <NEWLINE> <NL> <DEDENT> def push ( self , elm ) : <NEWLINE> <INDENT> self . top += 1 <NEWLINE> self . stack [ self . top ] = elm <NEWLINE> return self . stack <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> ret = self . stack [ self . top ] <NEWLINE> self . stack [ self . top ] = 0 <NEWLINE> self . top -= 1 <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> def is_empth ( self ) : <NEWLINE> <INDENT> if not self . is_full ( ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def is_full ( self ) : <NEWLINE> <INDENT> if self . size - 1 is self . top : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( expr ) : <NEWLINE> <INDENT> stack = MyStack ( 1000 ) <NEWLINE> for i , elm in enumerate ( expr ) : <NEWLINE> <INDENT> if expr [ i ] is <STRING> : <NEWLINE> <INDENT> a = stack . pop ( ) <NEWLINE> b = stack . pop ( ) <NEWLINE> stack . push ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> elif expr [ i ] is <STRING> : <NEWLINE> <INDENT> a = stack . pop ( ) <NEWLINE> b = stack . pop ( ) <NEWLINE> stack . push ( int ( b ) - int ( a ) ) <NEWLINE> <DEDENT> elif expr [ i ] is <STRING> : <NEWLINE> <INDENT> a = stack . pop ( ) <NEWLINE> b = stack . pop ( ) <NEWLINE> stack . push ( int ( a ) * int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . push ( elm ) <NEWLINE> <DEDENT> <DEDENT> return stack . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> expr = [ str ( s ) for s in input ( ) . split ( ) ] <NEWLINE> print ( main ( expr ) ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt_plus = 0 <NEWLINE> cnt_zero = 0 <NEWLINE> cnt_minus = 0 <NEWLINE> arr_plus = [ ] <NEWLINE> arr_minus = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] > 0 : <NEWLINE> <INDENT> cnt_plus += 1 <NEWLINE> arr_plus . append ( arr [ i ] ) <NEWLINE> <DEDENT> elif arr [ i ] < 0 : <NEWLINE> <INDENT> cnt_minus += 1 <NEWLINE> arr_minus . append ( - arr [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_zero += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt_plus + cnt_minus < k : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if k == n : <COMMENT> <NEWLINE> <INDENT> if cnt_zero != 0 : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( cnt_plus ) : <NEWLINE> <INDENT> ans *= arr_plus [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> for i in range ( cnt_minus ) : <NEWLINE> <INDENT> ans *= arr_minus [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if cnt_minus % 2 == 0 : <COMMENT> <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> print ( ( - ans ) % mod ) <NEWLINE> <DEDENT> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if cnt_plus == 0 and k % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> if cnt_zero != 0 : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> arr_minus = sorted ( arr_minus ) <NEWLINE> tmp = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> tmp *= arr_minus [ i ] <NEWLINE> tmp %= mod <NEWLINE> <DEDENT> print ( ( - tmp ) % mod ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> arr_plus = sorted ( arr_plus , reverse = True ) <NEWLINE> arr_minus = sorted ( arr_minus , reverse = True ) <NEWLINE> if k % 2 == 0 : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> pos_plus = 0 <NEWLINE> pos_minus = 0 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans = arr_plus [ 0 ] <NEWLINE> pos_plus = 1 <NEWLINE> pos_minus = 0 <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> while cnt < k : <NEWLINE> <INDENT> cand1 = 0 <NEWLINE> if pos_plus <= cnt_plus - 2 : <COMMENT> <NEWLINE> <INDENT> cand1 = arr_plus [ pos_plus ] * arr_plus [ pos_plus + 1 ] <NEWLINE> cand2 = 0 <NEWLINE> <DEDENT> if pos_minus <= cnt_minus - 2 : <COMMENT> <NEWLINE> <INDENT> cand2 = arr_minus [ pos_minus ] * arr_minus [ pos_minus + 1 ] <NEWLINE> <DEDENT> if cand1 >= cand2 : <COMMENT> <NEWLINE> <INDENT> pos_plus += 2 <NEWLINE> ans *= cand1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> pos_minus += 2 <NEWLINE> ans *= cand2 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> cnt += 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> c = Counter ( a ) <NEWLINE> m = max ( a ) + 1 <NEWLINE> dp = [ False ] * m <NEWLINE> ans = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if dp [ ai ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c [ ai ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in range ( ai , m , ai ) : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ input ( ) ] += 1 <NEWLINE> <DEDENT> m = max ( S . values ( ) ) <NEWLINE> for s in sorted ( filter ( lambda x : S [ x ] == m , S ) ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in num : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> l [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * l , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> rl = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> rl [ a ] . append ( b ) <NEWLINE> rl [ b ] . append ( a ) <NEWLINE> <DEDENT> cnt = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p -= 1 <NEWLINE> cnt [ p ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v , pv ) : <NEWLINE> <INDENT> for next_v in rl [ v ] : <NEWLINE> <INDENT> if next_v == pv : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ next_v ] += cnt [ v ] <NEWLINE> dfs ( next_v , v ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * cnt ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> ans = 0 <NEWLINE> exchange = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> exchange = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if N - i > exchange : <NEWLINE> <INDENT> if c [ - ( i + 1 ) ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> for k in range ( exchange + 1 , N - ( i + 1 ) ) : <NEWLINE> <INDENT> if c [ k ] == <STRING> : <NEWLINE> <INDENT> exchange = k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def get_num ( u , map , vis ) : <NEWLINE> <INDENT> if u in vis : <NEWLINE> <INDENT> return 0 ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vis [ u ] = True ; <NEWLINE> <DEDENT> ans = 0 ; <NEWLINE> if u in map : <NEWLINE> <INDENT> for v in map [ u ] : <NEWLINE> <INDENT> ans += get_num ( v , map , vis ) ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 ; <NEWLINE> <DEDENT> return ans ; <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) ; <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> edge = { } ; name = { } ; vis = { } ; <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> str = input ( ) ; <NEWLINE> u = name [ i ] = str . split ( <STRING> ) [ 0 ] ; <NEWLINE> group = str . split ( <STRING> ) [ 1 ] . split ( <STRING> ) [ 0 ] . split ( <STRING> ) ; <NEWLINE> for v in group : <NEWLINE> <INDENT> if u in edge : <NEWLINE> <INDENT> edge [ u ] [ v ] = True ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge [ u ] = { v : True } ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( get_num ( name [ 0 ] , edge , vis ) ) ; <NEWLINE> <DEDENT> <DEDENT> main ( ) ; <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( int ( a * x / b ) - a * int ( x / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = n * ( n - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x , y = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 2 ) ] <NEWLINE> print ( sum ( [ abs ( x [ i ] - y [ i ] ) for i in range ( n ) ] ) ) <NEWLINE> print ( pow ( sum ( [ ( x [ i ] - y [ i ] ) ** 2 for i in range ( n ) ] ) , 1 / 2 ) ) <NEWLINE> print ( pow ( sum ( [ abs ( x [ i ] - y [ i ] ) ** 3 for i in range ( n ) ] ) , 1 / 3 ) ) <NEWLINE> print ( max ( [ abs ( x [ i ] - y [ i ] ) for i in range ( n ) ] ) ) <NEWLINE> <NL>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> t1 = int ( input ( ) ) <NEWLINE> ans = t1 <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> t2 = int ( input ( ) ) <NEWLINE> ans = lcm ( ans , t2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ k ] != s [ i ] and s [ k ] != s [ j ] and s [ i ] != s [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
count = int ( input ( ) ) <NEWLINE> Tpoint = 0 <NEWLINE> Hpoint = 0 <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> Twrite , Hwrite = map ( str , input ( ) . split ( ) ) <NEWLINE> if Twrite == Hwrite : <NEWLINE> <INDENT> Tpoint = Tpoint + 1 <NEWLINE> Hpoint = Hpoint + 1 <NEWLINE> <DEDENT> elif Twrite > Hwrite : <NEWLINE> <INDENT> Tpoint = Tpoint + 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Hpoint = Hpoint + 3 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( Tpoint , Hpoint ) ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> P = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( M - 1 ) : <NEWLINE> <INDENT> if A [ i ] + 1 == A [ i + 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> broken = [ False ] * ( N + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> broken [ a ] = True <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 if not broken [ 1 ] else 0 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if broken [ i ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % P <NEWLINE> <NL> <DEDENT> <DEDENT> ans = dp [ N ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> suml = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> delta = abs ( K - x [ i ] ) <NEWLINE> if x [ i ] < delta : <NEWLINE> <INDENT> suml [ i ] = suml [ i ] + x [ i ] * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suml [ i ] = suml [ i ] + delta * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( suml ) ) <NEWLINE>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> b = abs ( x2 - x1 ) <NEWLINE> h = abs ( y2 - y1 ) <NEWLINE> d = math . sqrt ( b ** 2 + h ** 2 ) <NEWLINE> print ( <STRING> . format ( d ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> print ( lcm ( A , B ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * N <NEWLINE> for c in A : <NEWLINE> <INDENT> b [ c - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * 10001 <NEWLINE> a = [ 1 , 1 , 1 ] <NEWLINE> <NL> while ( a [ 0 ] + 1 ) ** 2 <= n - 2 : <NEWLINE> <INDENT> a [ 1 ] = 1 <NEWLINE> while ( a [ 1 ] + a [ 0 ] ) * ( a [ 1 ] + 1 ) + a [ 0 ] ** 2 <= n - 1 : <NEWLINE> <INDENT> a [ 2 ] = 1 <NEWLINE> while a [ 0 ] ** 2 + a [ 1 ] ** 2 + a [ 2 ] ** 2 + a [ 0 ] * a [ 1 ] + a [ 1 ] * a [ 2 ] + a [ 2 ] * a [ 0 ] <= n : <NEWLINE> <INDENT> ans [ a [ 0 ] ** 2 + a [ 1 ] ** 2 + a [ 2 ] ** 2 + a [ 0 ] * a [ 1 ] + a [ 1 ] * a [ 2 ] + a [ 2 ] * a [ 0 ] ] += 1 <NEWLINE> a [ 2 ] += 1 <NEWLINE> <DEDENT> a [ 1 ] += 1 <NEWLINE> <DEDENT> a [ 0 ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( N ) + 1 ) ) : <NEWLINE> <INDENT> sub = N // i <NEWLINE> cnt += ( sub - i + 1 ) * ( sub + i ) * i - i ** 2 <NEWLINE> <DEDENT> cnt = int ( cnt ) <NEWLINE> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> YEAR = 2019 <NEWLINE> <NL> <NL> def solve ( S : str ) : <NEWLINE> <COMMENT> <NL> <INDENT> mod_year = np . arange ( 1 , 10 ) <NEWLINE> mod_s = [ ] <NEWLINE> for Si in map ( int , reversed ( S ) ) : <NEWLINE> <INDENT> mod_s . append ( mod_year [ Si - 1 ] ) <NEWLINE> mod_year = ( mod_year * 10 ) % YEAR <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cum_sum = 0 <NEWLINE> cum_sums = [ cum_sum ] <NEWLINE> for x in mod_s : <NEWLINE> <INDENT> cum_sum = ( cum_sum + x ) % YEAR <NEWLINE> cum_sums . append ( cum_sum ) <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for _ , num in Counter ( cum_sums ) . items ( ) : <NEWLINE> <INDENT> answer += ( num * ( num - 1 ) ) // 2 <COMMENT> <NEWLINE> <DEDENT> return answer <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . strip ( ) <NEWLINE> answer = solve ( S ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> acts = [ ( x , i ) for i , x in enumerate ( A ) ] <NEWLINE> acts . sort ( ) <NEWLINE> dp = [ [ - 1 ] * N for _ in range ( N ) ] <NEWLINE> <NL> def solve ( l , r ) : <NEWLINE> <INDENT> if r < l : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if dp [ l ] [ r ] >= 0 : <NEWLINE> <INDENT> return dp [ l ] [ r ] <NEWLINE> <DEDENT> k = r - l <NEWLINE> act , init_pos = acts [ k ] <NEWLINE> gain_l = act * abs ( l - init_pos ) <NEWLINE> gain_r = act * abs ( r - init_pos ) <NEWLINE> res = dp [ l ] [ r ] = max ( gain_l + solve ( l + 1 , r ) , gain_r + solve ( l , r - 1 ) ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> print ( solve ( 0 , N - 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def cmb ( n , r ) : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> numer = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> denom = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return numer // denom % INF <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> print ( cmb ( K - 1 , i - 1 ) * cmb ( N - K + 1 , i ) % INF ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if 400 <= x <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif 600 <= x <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif 800 <= x <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif 1000 <= x <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif 1200 <= x <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif 1400 <= x <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif 1600 <= x <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 1800 <= x <= 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_ = 0 <NEWLINE> if K < A : <NEWLINE> <INDENT> sum_ = K <NEWLINE> <DEDENT> elif K <= B : <NEWLINE> <INDENT> sum_ = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_ = A - ( K - A - B ) <NEWLINE> <DEDENT> print ( sum_ ) <NEWLINE>
<NL> n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> if ( int ( a [ i - 1 ] ) >= int ( a [ k + i - 1 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
target = input ( ) <NEWLINE> total_text = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> text = input ( ) <NEWLINE> if ( text == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total_text += <STRING> <NEWLINE> total_text += text <NEWLINE> <COMMENT> <NL> <DEDENT> sentenceList = total_text . split ( ) <NEWLINE> count = 0 <NEWLINE> for word in sentenceList : <NEWLINE> <INDENT> if ( word . lower ( ) == target ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( a ) <NEWLINE> <DEDENT> for k in range ( n - 2 ) : <NEWLINE> <INDENT> if l [ k ] [ 0 ] == l [ k ] [ 1 ] and l [ k + 1 ] [ 0 ] == l [ k + 1 ] [ 1 ] and l [ k + 2 ] [ 0 ] == l [ k + 2 ] [ 1 ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if j == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
first = input ( ) . split ( ) <NEWLINE> n = int ( first [ 0 ] ) <NEWLINE> r = int ( first [ 1 ] ) <NEWLINE> while n != 0 or r != 0 : <NEWLINE> <INDENT> i = 0 <NEWLINE> card = list ( range ( 1 , n + 1 ) ) [ : : - 1 ] <NEWLINE> while i < r : <NEWLINE> <INDENT> sh = input ( ) . split ( ) <NEWLINE> p , c = list ( map ( int , sh ) ) <NEWLINE> card = card [ p - 1 : p + c - 1 ] + card [ : p - 1 ] + card [ p + c - 1 : ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> print ( card [ 0 ] ) <NEWLINE> next = input ( ) . split ( ) <NEWLINE> n , r = list ( map ( int , next ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> h = 2 * j - i <NEWLINE> if h >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ h ] and S [ j ] != S [ h ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = r * g * b - c <NEWLINE> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
T = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if T == str ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( T ) < 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if T [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> T = str ( T [ : - 5 ] ) <NEWLINE> <DEDENT> elif T [ - 7 : ] == <STRING> : <NEWLINE> <INDENT> T = str ( T [ : - 7 ] ) <NEWLINE> <DEDENT> elif T [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> T = str ( T [ : - 5 ] ) <NEWLINE> <DEDENT> elif T [ - 6 : ] == <STRING> : <NEWLINE> <INDENT> T = str ( T [ : - 6 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ [ a , i ] for a , i in zip ( A , range ( 1 , N + 1 ) ) ] <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> dp = [ [ - INF ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> ans = 0 <NEWLINE> for x_y in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = A [ x_y - 1 ] <NEWLINE> for x in range ( x_y + 1 ) : <NEWLINE> <INDENT> y = x_y - x <NEWLINE> if x == 0 : <NEWLINE> <INDENT> dp [ x ] [ y ] = dp [ x ] [ y - 1 ] + a [ 0 ] * ( N - y + 1 - a [ 1 ] ) <NEWLINE> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> dp [ x ] [ y ] = dp [ x - 1 ] [ y ] + a [ 0 ] * ( a [ 1 ] - x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + a [ 0 ] * ( a [ 1 ] - x ) , dp [ x ] [ y - 1 ] + a [ 0 ] * ( N - y + 1 - a [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> ans = max ( ans , dp [ x ] [ y ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> ans = [ deque ( [ ] ) for _ in range ( m + 10 ) ] <NEWLINE> ans2 = [ [ ] for _ in range ( m + 10 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = li [ i ] [ 0 ] <NEWLINE> t = li [ i ] [ 1 ] <NEWLINE> <NL> ans [ s ] . append ( t ) <NEWLINE> ans [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> stack = deque ( [ 1 ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack [ 0 ] <NEWLINE> <NL> if ans [ v ] : <NEWLINE> <INDENT> w = ans [ v ] . popleft ( ) <NEWLINE> if True : <NEWLINE> <INDENT> ans2 [ w ] . append ( v ) <NEWLINE> <DEDENT> stack . append ( w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans2 [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = n // 2 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> dp = [ [ - 10 ** 18 ] * 2 for _ in range ( m ) ] <NEWLINE> dp [ 0 ] [ 0 ] = a [ 0 ] <NEWLINE> dp [ 0 ] [ 1 ] = a [ 1 ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> for j in range ( 2 * i , 2 * ( i + 1 ) ) : <NEWLINE> <INDENT> for k in range ( 2 * ( i - 1 ) , 2 * i ) : <NEWLINE> <INDENT> if j - k > 1 : <NEWLINE> <INDENT> dp [ i ] [ j % 2 ] = max ( dp [ i ] [ j % 2 ] , dp [ i - 1 ] [ k % 2 ] + a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp = [ [ - 10 ** 18 ] * 3 for _ in range ( m ) ] <NEWLINE> dp [ 0 ] [ 0 ] = a [ 0 ] <NEWLINE> dp [ 0 ] [ 1 ] = a [ 1 ] <NEWLINE> dp [ 0 ] [ 2 ] = a [ 2 ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> for j in range ( 2 * i , 2 * ( i + 1 ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 2 * ( i - 1 ) , 2 * i + 1 ) : <NEWLINE> <INDENT> if j - k > 1 : <NEWLINE> <INDENT> dp [ i ] [ j - 2 * i ] = max ( dp [ i ] [ j - 2 * i ] , dp [ i - 1 ] [ k - 2 * ( i - 1 ) ] + a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( dp [ - 1 ] ) ) <NEWLINE>
A = 0 <NEWLINE> left = [ ] <NEWLINE> Lake = [ ] <NEWLINE> s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> left . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> if len ( left ) > 0 : <NEWLINE> <INDENT> w = left . pop ( ) <NEWLINE> goukei = i - w <NEWLINE> A += goukei <NEWLINE> for i in range ( len ( Lake ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if Lake [ i ] [ 0 ] > w : <NEWLINE> <INDENT> x = Lake . pop ( ) <NEWLINE> goukei += x [ 1 ] <NEWLINE> <DEDENT> <DEDENT> Lake . append ( [ w , goukei ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A ) <NEWLINE> if len ( Lake ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( Lake ) , end = <STRING> ) <NEWLINE> <DEDENT> for i in range ( len ( Lake ) ) : <NEWLINE> <INDENT> if i == len ( Lake ) - 1 : <NEWLINE> <INDENT> print ( Lake [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Lake [ i ] [ 1 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Logs = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> ave = sum ( Logs ) / ( N + K ) <NEWLINE> cut = np . array ( [ max ( 1 , int ( x / ave ) ) for x in Logs ] ) <NEWLINE> chip = Logs / cut <NEWLINE> chip = np . sort ( chip ) [ : : - 1 ] <NEWLINE> print ( math . ceil ( chip [ N + K - sum ( cut ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l [ input ( ) ] = 1 <NEWLINE> <NL> <DEDENT> print ( len ( l ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int32 ) <NEWLINE> A = np . sort ( A ) <NEWLINE> <NL> EXC = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> exc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> EXC . append ( exc ) <NEWLINE> <DEDENT> excArry = np . array ( EXC , dtype = np . int32 ) <NEWLINE> <NL> col_num = 1 <NEWLINE> Arr = excArry [ np . argsort ( excArry [ : , col_num ] ) [ : : - 1 ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> point = 0 <NEWLINE> <NL> <NL> for j in range ( M ) : <NEWLINE> <INDENT> change_Num = Arr [ j ] [ 1 ] <NEWLINE> count = np . count_nonzero ( A < change_Num ) <NEWLINE> if count > 0 : <NEWLINE> <INDENT> m = min ( count , Arr [ j ] [ 0 ] ) <NEWLINE> A [ point : point + m ] = change_Num <NEWLINE> point += m <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( np . sum ( A ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> a = <STRING> <NEWLINE> while ( int ( n ) > 0 ) : <NEWLINE> <INDENT> t = n % 26 <NEWLINE> if t == 0 : <NEWLINE> <INDENT> n -= 26 <NEWLINE> <DEDENT> a = s [ t ] + a <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> sys . setrecursionlimit ( 20000000 ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> answer = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> answer *= A [ i ] <NEWLINE> if answer > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , x = - 1 , - 1 <NEWLINE> table = [ ] <NEWLINE> while n != 0 or x != 0 : <NEWLINE> <INDENT> n , x = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> table . append ( [ n , x ] ) <NEWLINE> <NL> <DEDENT> for t in table : <NEWLINE> <INDENT> n = t [ 0 ] <NEWLINE> x = t [ 1 ] <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = 1 <NEWLINE> s = 0 <NEWLINE> while i < n : <NEWLINE> <COMMENT> <NL> <INDENT> if x - i > n + ( n - 1 ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> while j < n : <NEWLINE> <COMMENT> <NL> <INDENT> if x - i - j <= n and x - i - j > j : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < N : <NEWLINE> <INDENT> if ( S [ i ] != S [ j ] ) and ( S [ i ] != S [ k ] ) and ( S [ j ] != S [ k ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) [ 2 : ] ) ) <NEWLINE> g . append ( zip ( line [ 0 : : 2 ] , line [ 1 : : 2 ] ) ) <NEWLINE> <NL> <DEDENT> dist = [ inf ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> heap = [ ( 0 , 0 ) ] <NEWLINE> <NL> while heap : <NEWLINE> <INDENT> current = heappop ( heap ) [ 1 ] <NEWLINE> for v , c in g [ current ] : <NEWLINE> <INDENT> new_dist = dist [ current ] + c <NEWLINE> if new_dist < dist [ v ] : <NEWLINE> <INDENT> dist [ v ] = new_dist <NEWLINE> heappush ( heap , ( new_dist , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( i , dist [ i ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = lnii ( ) <NEWLINE> <NL> def eratosthenes ( lim ) : <NEWLINE> <INDENT> num = [ 1 for i in range ( lim ) ] <NEWLINE> for i in set ( l ) : <NEWLINE> <INDENT> for j in range ( i + i , lim , i ) : <NEWLINE> <INDENT> num [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> return num <NEWLINE> <NL> <DEDENT> lim = 10 ** 6 + 5 <NEWLINE> num = eratosthenes ( lim ) <NEWLINE> <NL> count = Counter ( l ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if num [ i ] == 1 and count [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ ] <NEWLINE> for i in range ( len ( a_list ) ) : <NEWLINE> <INDENT> ans_list . append ( a_list [ i ] - i - 1 ) <NEWLINE> <DEDENT> import numpy as np <NEWLINE> if len ( ans_list ) % 2 == 0 : <NEWLINE> <INDENT> ans_list1 = sorted ( ans_list ) <NEWLINE> number1 = ans_list1 [ n // 2 ] <NEWLINE> number2 = ans_list1 [ n // 2 + 1 ] <NEWLINE> <NL> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> for i in ans_list : <NEWLINE> <INDENT> ans1 += abs ( i - number1 ) <NEWLINE> ans2 += abs ( i - number2 ) <NEWLINE> <DEDENT> print ( min ( ans1 , ans2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cary = ans_list <NEWLINE> number = int ( np . median ( cary ) ) <NEWLINE> ans = 0 <NEWLINE> for i in ans_list : <NEWLINE> <INDENT> ans += abs ( i - number ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> e = <STRING> * 20 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , a [ i ] [ j ] ) ) ) <NEWLINE> <DEDENT> if ( i != 3 ) : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> times = 1 <NEWLINE> <NL> if 0 in li : <NEWLINE> <INDENT> times = 0 <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 0 , n ) : <NEWLINE> <INDENT> times = times * li [ k ] <NEWLINE> if times > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if times <= 10 ** 18 and times != 0 : <NEWLINE> <INDENT> print ( times ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> <NL> def score ( t ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( t ) - 1 ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if t [ i ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> hold = 0 <NEWLINE> <NL> t_tr = t . replace ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( t_tr ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> break <NEWLINE> <DEDENT> elif i == N - 2 : print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> r = range ( a , b + 1 ) <NEWLINE> print ( * sorted ( set ( r [ : k ] ) | set ( r [ - k : ] ) ) , sep = <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> N = len ( s ) <NEWLINE> D = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D [ s [ i ] ] += 1 <NEWLINE> <DEDENT> my_p = N // 2 <NEWLINE> score = my_p - D [ <STRING> ] <NEWLINE> print ( score ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve_bit ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> for bit in range ( 1 << N ) : <NEWLINE> <INDENT> S = [ 0 ] * ( M + 1 ) <NEWLINE> for i , ca in enumerate ( CA ) : <NEWLINE> <INDENT> if ( 1 << i ) & bit == 1 << i : <NEWLINE> <INDENT> S = list ( map ( sum , zip ( S , ca ) ) ) <NEWLINE> <DEDENT> <DEDENT> for s in S [ 1 : ] : <NEWLINE> <INDENT> if s < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , S [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> global N , M , X , CA <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> b = deque ( ) <NEWLINE> ans = dfs ( 0 , b ) <NEWLINE> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( n , B ) : <NEWLINE> <INDENT> if n == N : <NEWLINE> <INDENT> S = [ 0 ] * ( M + 1 ) <NEWLINE> for i , ca in enumerate ( CA , 1 ) : <NEWLINE> <INDENT> if i in B : <NEWLINE> <INDENT> S = list ( map ( sum , zip ( S , ca ) ) ) <NEWLINE> <DEDENT> <DEDENT> if min ( S [ 1 : ] ) < X : <NEWLINE> <INDENT> return float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return S [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = float ( <STRING> ) <NEWLINE> B . append ( n + 1 ) <NEWLINE> ans = min ( ans , dfs ( n + 1 , B ) ) <NEWLINE> B . pop ( ) <NEWLINE> ans = min ( ans , dfs ( n + 1 , B ) ) <NEWLINE> <NL> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( 300 ) : <NEWLINE> <INDENT> a = i ** 5 <NEWLINE> l . append ( a ) <NEWLINE> l . append ( - a ) <NEWLINE> <NL> <NL> <DEDENT> for j in l : <NEWLINE> <INDENT> for k in l : <NEWLINE> <INDENT> aa = j - k <NEWLINE> if j != k and aa == x : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for z in [ j , k ] : <NEWLINE> <INDENT> aaa = abs ( z ) ** ( 1 / 5 ) <NEWLINE> if z >= 0 : <NEWLINE> <INDENT> ans . append ( int ( aaa ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( int ( - aaa ) ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> <NL> D = int ( input ( ) ) <NEWLINE> CS = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> C = CS [ : 26 ] <NEWLINE> S = CS [ 26 : ] . reshape ( ( - 1 , 26 ) ) <NEWLINE> del CS <NEWLINE> <NL> last = np . zeros ( ( 26 , ) ) <NEWLINE> <NL> <NL> def getContestType_at_d ( d , k ) : <NEWLINE> <INDENT> s = - 10000000 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> mask = np . ones ( ( 26 , ) ) <NEWLINE> mask [ i ] = 0 <NEWLINE> score = S [ d ] [ i ] - np . sum ( C * ( d + 1 - last ) * mask ) <NEWLINE> ps = score <NEWLINE> score -= np . sum ( C * ( min ( 365 , d + k ) + 1 - last ) ) <NEWLINE> if s < score : <NEWLINE> <INDENT> s = score <NEWLINE> t = i <NEWLINE> <NL> <DEDENT> <DEDENT> last [ t ] = d + 1 <NEWLINE> <NL> return t + 1 , s , ps <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> t , _ , _ = getContestType_at_d ( d , 10 ) <NEWLINE> ans . append ( t ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> from collections import Counter <NEWLINE> x = Counter ( a ) <NEWLINE> r = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 0 <NEWLINE> if b in x : <NEWLINE> <INDENT> m = x [ b ] <NEWLINE> x . pop ( b ) <NEWLINE> if c in x : <NEWLINE> <INDENT> x [ c ] += m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ c ] = m <NEWLINE> <DEDENT> <DEDENT> r += m * ( c - b ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> number = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> number . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> n = A [ i - 1 ] * 1 <NEWLINE> number [ n ] = number [ n ] + 1 <NEWLINE> <NL> <DEDENT> del number [ 0 ] <NEWLINE> number . append ( 0 ) <NEWLINE> for Answer in number : <NEWLINE> <INDENT> print ( Answer ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a = [ <STRING> , <STRING> ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n [ 0 ] == 0 & n [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( n [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( n [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ ( i + j ) % 2 ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> B = [ 0 ] * N <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if H [ A [ i ] [ 0 ] - 1 ] < H [ A [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> B [ A [ i ] [ 0 ] - 1 ] = 1 <NEWLINE> <DEDENT> elif H [ A [ i ] [ 0 ] - 1 ] > H [ A [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> B [ A [ i ] [ 1 ] - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ A [ i ] [ 0 ] - 1 ] = 1 <NEWLINE> B [ A [ i ] [ 1 ] - 1 ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if B [ i ] == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> def solve ( K : int ) : <NEWLINE> <INDENT> K += 1 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( 1 , K ) : <NEWLINE> <INDENT> for k in range ( 1 , K ) : <NEWLINE> <INDENT> ans . append ( math . gcd ( i , math . gcd ( j , k ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def gcd ( x : int , y : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return gcd ( y , x % y ) if y else x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> K = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( K ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = x <NEWLINE> <NL> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> x += tmp <NEWLINE> if x % y != 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ll = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> ll . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( ll , ll [ i ] + ll [ j ] ) - ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dictionary = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> dictionary [ a [ 1 ] ] = 0 <NEWLINE> <DEDENT> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> if a [ 1 ] in dictionary : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> op = 1 <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> for i in p : <NEWLINE> <INDENT> op = op * i <NEWLINE> <NL> if op > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( op ) <NEWLINE>
import math <NEWLINE> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = X * Y // math . gcd ( X , Y ) - X <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> s , t = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < 0 : <NEWLINE> <INDENT> t . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( a [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> S , T = len ( s ) , len ( t ) <NEWLINE> ok = False <NEWLINE> <NL> if S > 0 : <NEWLINE> <INDENT> if n == k : <NEWLINE> <INDENT> ok = ( T % 2 == 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ok = ( k % 2 == 0 ) <NEWLINE> <NL> <DEDENT> if not ok : <NEWLINE> <INDENT> a . sort ( key = abs ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s . sort ( ) <NEWLINE> t . sort ( reverse = True ) <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans *= s . pop ( ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> p = [ ] <NEWLINE> while len ( s ) >= 2 : <NEWLINE> <INDENT> x = s . pop ( ) <NEWLINE> x *= s . pop ( ) <NEWLINE> p . append ( x ) <NEWLINE> <DEDENT> while len ( t ) >= 2 : <NEWLINE> <INDENT> x = t . pop ( ) <NEWLINE> x *= t . pop ( ) <NEWLINE> p . append ( x ) <NEWLINE> <DEDENT> p . sort ( reverse = True ) <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> ans *= p [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> si = str ( i ) <NEWLINE> if ( not i % 3 ) or <STRING> in si : <NEWLINE> <INDENT> result . append ( si ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + <STRING> . join ( result ) ) <NEWLINE>
def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A , B , N = MAP ( ) <NEWLINE> <NL> left , right = 0 , N <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> if B > N : <NEWLINE> <INDENT> ans = f ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = f ( B - 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> A_div = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> A_div [ a ] += 1 <NEWLINE> if A_div [ a ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> A_div [ j ] += 100 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( A_div . count ( 1 ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> n = 7 <NEWLINE> c = 1 <NEWLINE> f = 1 <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while c < 1000000 : <NEWLINE> <INDENT> tmp = n % k <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> f = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = tmp * 10 + 7 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import chain <NEWLINE> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> S = sys . stdin . read ( ) . split ( <STRING> ) <NEWLINE> print ( solve ( S ) ) <NEWLINE> <NL> <DEDENT> def get_count ( args ) : <NEWLINE> <INDENT> s , result = args <COMMENT> <NEWLINE> cum_sum = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> cum_sum -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cum_sum += 1 <NEWLINE> <DEDENT> result [ 0 ] = max ( result [ 0 ] , - cum_sum ) <NEWLINE> <DEDENT> result [ 1 ] = result [ 0 ] + cum_sum <NEWLINE> return result <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def silly_sort ( array , value_min , value_max , get_value ) : <NEWLINE> <INDENT> if len ( array ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> cache = [ None for _ in range ( value_max - value_min + 1 ) ] <NEWLINE> for elem in array : <NEWLINE> <COMMENT> <NL> <INDENT> value = get_value ( elem ) - value_min <NEWLINE> if cache [ value ] is None : <NEWLINE> <INDENT> cache [ value ] = [ ] <NEWLINE> <DEDENT> cache [ value ] . append ( elem ) <NEWLINE> <DEDENT> for values in cache : <NEWLINE> <INDENT> if values is None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for value in values : <NEWLINE> <INDENT> yield value <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( S ) : <NEWLINE> <INDENT> counts = [ [ 0 , 0 ] for _ in range ( len ( S ) ) ] <NEWLINE> counts = list ( map ( get_count , zip ( S , counts ) ) ) <NEWLINE> first_group = [ ] <NEWLINE> second_group = [ ] <NEWLINE> min_first_group = float ( <STRING> ) <NEWLINE> max_first_group = 0 <NEWLINE> min_second_group = float ( <STRING> ) <NEWLINE> max_second_group = 0 <NEWLINE> <NL> for c in counts : <NEWLINE> <INDENT> if c [ 0 ] - c [ 1 ] <= 0 : <NEWLINE> <INDENT> first_group . append ( c ) <NEWLINE> max_first_group = max ( max_first_group , c [ 0 ] ) <NEWLINE> min_first_group = min ( min_first_group , c [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> second_group . append ( c ) <NEWLINE> max_second_group = max ( max_second_group , c [ 1 ] ) <NEWLINE> min_second_group = min ( min_first_group , c [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> first_group = silly_sort ( first_group , min_first_group , max_first_group , lambda c : c [ 0 ] ) <NEWLINE> second_group = reversed ( list ( silly_sort ( second_group , min_second_group , max_second_group , lambda c : c [ 1 ] ) ) ) <NEWLINE> <NL> order = chain ( first_group , second_group ) <NEWLINE> <NL> cum_sum = 0 <NEWLINE> for c in order : <NEWLINE> <INDENT> cum_sum -= c [ 0 ] <NEWLINE> if cum_sum < 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> cum_sum += c [ 1 ] <NEWLINE> <DEDENT> if cum_sum == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <NL> a = [ - 1 ] * ( s + 10 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a [ 0 ] = 1 <NEWLINE> a [ 1 ] = 0 <NEWLINE> a [ 2 ] = 0 <NEWLINE> a [ 3 ] = 1 <NEWLINE> if s > 3 : <NEWLINE> <INDENT> for i in range ( 4 , s + 1 ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 1 ] + a [ i - 3 ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a [ s ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from bisect import bisect_left , bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> al = [ [ ] for i in range ( 26 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> al [ ord ( s [ i ] ) - 97 ] . append ( i ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , x = input ( ) . split ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> al [ ord ( s [ int ( b ) - 1 ] ) - 97 ] . pop ( bisect_left ( al [ ord ( s [ int ( b ) - 1 ] ) - 97 ] , int ( b ) - 1 ) ) <NEWLINE> al [ ord ( x ) - 97 ] . insert ( bisect_left ( al [ ord ( x ) - 97 ] , int ( b ) - 1 ) , int ( b ) - 1 ) <NEWLINE> s [ int ( b ) - 1 ] = x <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> b = int ( b ) - 1 <NEWLINE> x = int ( x ) - 1 <NEWLINE> cou = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> l = bisect_left ( al [ j ] , b ) <NEWLINE> r = bisect ( al [ j ] , x ) <NEWLINE> if l != r : <NEWLINE> <INDENT> cou += 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( cou ) <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import combinations <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> h . append ( a * c ) <NEWLINE> h . append ( a * d ) <NEWLINE> h . append ( b * c ) <NEWLINE> h . append ( b * d ) <NEWLINE> <NL> print ( max ( h ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( B - A ) > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> from math import sqrt , ceil <NEWLINE> from collections import deque , Counter , defaultdict , OrderedDict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> sys . setrecursionlimit ( 11451419 ) <NEWLINE> from decimal import ROUND_HALF_UP , Decimal <COMMENT> <NEWLINE> <COMMENT> <NL> from functools import lru_cache <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> A = [ int ( i ) - 1 for i in s ] <NEWLINE> <NL> RUI2 = [ pow ( 2 , i ) for i in range ( 21 ) ] <NEWLINE> import bisect as bi <NEWLINE> @ lru_cache ( maxsize = 10 ** 10 ) <NEWLINE> def tan ( n ) : <NEWLINE> <INDENT> if n == 0 : return [ 1 ] <NEWLINE> if n == 1 : return [ 1 , 1 ] <NEWLINE> if n == 2 : return [ 1 , 0 , 1 ] <NEWLINE> i = bi . bisect_right ( RUI2 , n ) - 1 <NEWLINE> return tan ( n - pow ( 2 , i ) ) + [ 0 ] * ( pow ( 2 , i + 1 ) - n - 1 ) + tan ( n - pow ( 2 , i ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> if A . count ( 1 ) != 0 : <NEWLINE> <INDENT> A = [ i % 2 != 1 for i in A ] <NEWLINE> a = [ i & j for i , j in zip ( A , tan ( n - 1 ) ) ] <NEWLINE> <COMMENT> <NL> print ( 1 if sum ( a ) % 2 == 1 else 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ ( i // 2 ) & j for i , j in zip ( A , tan ( n - 1 ) ) ] <NEWLINE> <COMMENT> <NL> print ( 2 if sum ( a ) % 2 == 1 else 0 ) <NEWLINE> <NL> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> X_div_D = X // D <NEWLINE> <NL> ans_min = X % D <NEWLINE> <NL> if K <= X_div_D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K % 2 ) ^ ( X_div_D % 2 ) == 0 : <NEWLINE> <INDENT> print ( ans_min ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( ans_min - D ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = list ( input ( ) ) <NEWLINE> x = sorted ( x ) <NEWLINE> s . append ( <STRING> . join ( x ) ) <NEWLINE> <DEDENT> s = sorted ( s ) <NEWLINE> m = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += m * ( m - 1 ) // 2 <NEWLINE> m = 1 <NEWLINE> <DEDENT> <DEDENT> ans += m * ( m - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if a [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> ma = [ None ] * n <NEWLINE> ma [ 0 ] = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ma [ i + 1 ] = ( ma [ i ] - a [ i ] ) * 2 <NEWLINE> <DEDENT> node = a [ - 1 ] <NEWLINE> ans = node <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> mi = ( node + 1 ) // 2 <NEWLINE> if ma [ i ] - a [ i ] < mi : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> node = min ( ma [ i ] - a [ i ] , node ) + a [ i ] <NEWLINE> ans += node <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <STRING> <NEWLINE> su = 0 <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> su = su + a <NEWLINE> tem = k - a <NEWLINE> if b >= tem : <NEWLINE> <INDENT> print ( su ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tem1 = tem - b <NEWLINE> print ( su - tem1 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> class Tree : <NEWLINE> <INDENT> def __init__ ( self , parent , left , right ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def preparse ( u ) : <NEWLINE> <INDENT> if u == - 1 : return <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( u , end = <STRING> ) <NEWLINE> preparse ( trees [ u ] . left ) <NEWLINE> preparse ( trees [ u ] . right ) <NEWLINE> <NL> <NL> <DEDENT> def inparse ( u ) : <NEWLINE> <INDENT> if u == - 1 : return <NEWLINE> <COMMENT> <NL> inparse ( trees [ u ] . left ) <NEWLINE> <COMMENT> <NL> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( u , end = <STRING> ) <NEWLINE> <COMMENT> <NL> inparse ( trees [ u ] . right ) <NEWLINE> <NL> <NL> <DEDENT> def postparse ( u ) : <NEWLINE> <INDENT> if u == - 1 : return <NEWLINE> <COMMENT> <NL> postparse ( trees [ u ] . left ) <NEWLINE> <COMMENT> <NL> postparse ( trees [ u ] . right ) <NEWLINE> <COMMENT> <NL> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( u , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> trees = [ Tree ( - 1 , - 1 , - 1 ) for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> no = l [ 0 ] <NEWLINE> left = l [ 1 ] <NEWLINE> right = l [ 2 ] <NEWLINE> trees [ no ] . left = left <NEWLINE> trees [ no ] . right = right <NEWLINE> if left != - 1 : trees [ left ] . parent = no <NEWLINE> if right != - 1 : trees [ right ] . parent = no <NEWLINE> <NL> <DEDENT> r = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if trees [ i ] . parent == - 1 : <NEWLINE> <INDENT> r = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> preparse ( r ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> inparse ( r ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> postparse ( r ) <NEWLINE> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> a = 7 <NEWLINE> a = a % k <NEWLINE> while a != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> a = ( 10 * a + 7 ) % k <NEWLINE> if i == 10 ** 6 : <NEWLINE> <INDENT> i = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> t_score = 0 <NEWLINE> h_score = 0 <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t , h = input ( ) . split ( ) <NEWLINE> if t == h : <NEWLINE> <INDENT> t_score += 1 <NEWLINE> h_score += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if len ( t ) >= len ( h ) : <NEWLINE> <INDENT> for j in range ( len ( h ) ) : <NEWLINE> <INDENT> if ord ( t [ j ] ) > ord ( h [ j ] ) : <NEWLINE> <INDENT> t_score += 3 <NEWLINE> break <NEWLINE> <DEDENT> elif ord ( t [ j ] ) < ord ( h [ j ] ) : <NEWLINE> <INDENT> h_score += 3 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t_score += 3 <NEWLINE> <DEDENT> <DEDENT> elif len ( t ) < len ( h ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if ord ( t [ j ] ) > ord ( h [ j ] ) : <NEWLINE> <INDENT> t_score += 3 <NEWLINE> break <NEWLINE> <DEDENT> elif ord ( t [ j ] ) < ord ( h [ j ] ) : <NEWLINE> <INDENT> h_score += 3 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> h_score += 3 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( t_score , h_score ) ) <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ 0 ] * ( N + 1 ) <NEWLINE> w = [ 0 ] * ( N + 1 ) <NEWLINE> dp = [ [ 0 for x in range ( W + 1 ) ] for y in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> v [ i ] , w [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> if j < w [ i ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - w [ i ] ] + v [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE>
count = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> array . reverse ( ) <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> print ( <STRING> . format ( array [ i ] ) , end = <STRING> ) <NEWLINE> if i != count - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> Buka = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Buka . append ( 0 ) <NEWLINE> <DEDENT> for j in A : <NEWLINE> <INDENT> Buka [ j - 1 ] += 1 <NEWLINE> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> print ( Buka [ k ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> DP = { } <NEWLINE> <NL> <COMMENT> <NL> def func ( num , yen ) : <NEWLINE> <INDENT> if num < 0 or yen < 0 : <NEWLINE> <INDENT> return 10 ** 18 <NEWLINE> <DEDENT> if num == 0 and yen == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if not ( num , yen ) in DP : <NEWLINE> <INDENT> DP [ ( num , yen ) ] = min ( func ( num - 1 , yen ) , func ( num , yen - c [ num ] ) + 1 ) <NEWLINE> <DEDENT> return DP [ ( num , yen ) ] <NEWLINE> <NL> <DEDENT> print ( func ( m - 1 , n ) ) <NEWLINE> <NL>
X = int ( input ( ) ) <NEWLINE> <NL> y = int ( ( X ** 0.2 ) // 1 + 1 ) <NEWLINE> <NL> def array ( y ) : <NEWLINE> <INDENT> a = [ 0 ] <NEWLINE> for i in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> a . append ( i ** 5 ) <NEWLINE> a . append ( - i ** 5 ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> return a <NEWLINE> <NL> <DEDENT> y = y * 2 <NEWLINE> a = array ( y ) <NEWLINE> <NL> N = len ( a ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if a [ j ] - a [ i ] == X : <NEWLINE> <INDENT> A , B = - y + j , - y + i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
import numpy as np <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> l = [ 0 ] * x <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for num in range ( x - 1 ) : <NEWLINE> <INDENT> l [ A [ num ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ta , tb , tc , td = map ( int , input ( ) . split ( ) ) <NEWLINE> a += [ ta ] <NEWLINE> b += [ tb ] <NEWLINE> c += [ tc ] <NEWLINE> d += [ td ] <NEWLINE> <DEDENT> maxs = 0 <NEWLINE> A = [ 0 for i in range ( 10 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( i , M ) : <NEWLINE> <INDENT> for k in range ( j , M ) : <NEWLINE> <INDENT> for l in range ( k , M ) : <NEWLINE> <INDENT> for m in range ( l , M ) : <NEWLINE> <INDENT> for n in range ( m , M ) : <NEWLINE> <INDENT> for o in range ( n , M ) : <NEWLINE> <INDENT> for p in range ( o , M ) : <NEWLINE> <INDENT> for q in range ( p , M ) : <NEWLINE> <INDENT> for r in range ( q , M ) : <NEWLINE> <INDENT> A [ 0 ] = i <NEWLINE> A [ 1 ] = j <NEWLINE> A [ 2 ] = k <NEWLINE> A [ 3 ] = l <NEWLINE> A [ 4 ] = m <NEWLINE> A [ 5 ] = n <NEWLINE> A [ 6 ] = o <NEWLINE> A [ 7 ] = p <NEWLINE> A [ 8 ] = q <NEWLINE> A [ 9 ] = r <NEWLINE> su = 0 <NEWLINE> for z in range ( Q ) : <NEWLINE> <INDENT> if A [ b [ z ] - 1 ] - A [ a [ z ] - 1 ] == c [ z ] : <NEWLINE> <INDENT> su += d [ z ] <NEWLINE> <DEDENT> <DEDENT> if su > maxs : <NEWLINE> <INDENT> maxs = su <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( maxs ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> array = [ 0 ] * len ( s ) <NEWLINE> <NL> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i - 1 : i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> array [ i ] = array [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ i ] = array [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> ans = array [ r ] - array [ l ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> fact = [ 0 ] * ( n + 1 ) <NEWLINE> inv = [ 0 ] * ( n + 1 ) <NEWLINE> factinv = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> fact [ 0 ] = fact [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> factinv [ 0 ] = factinv [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - ( ( inv [ MOD % i ] * ( MOD // i ) ) % MOD ) <NEWLINE> factinv [ i ] = factinv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <NL> <DEDENT> def cbn ( n , k , fact , factinv , MOD ) : <NEWLINE> <INDENT> return fact [ n ] * factinv [ n - k ] * factinv [ k ] % MOD <NEWLINE> <NL> <DEDENT> def power ( x , n , MOD ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return power ( x * x % MOD , n // 2 , MOD ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x * power ( x * x % MOD , n // 2 , MOD ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> s += cbn ( n - 1 , i , fact , factinv , MOD ) * m * power ( m - 1 , n - 1 - i , MOD ) <NEWLINE> <NL> <DEDENT> print ( s % MOD ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> INF = 10 ** 18 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> flg = False <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> output = np . zeros ( N ) <NEWLINE> <NL> for x in range ( 1 , int ( np . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + x * y > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> index = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> if index > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> dup = len ( set ( [ x , y , z ] ) ) <NEWLINE> <NL> if dup == 3 : <NEWLINE> <INDENT> output [ index - 1 ] += 6 <NEWLINE> <DEDENT> elif dup == 2 : <NEWLINE> <INDENT> output [ index - 1 ] += 3 <NEWLINE> <DEDENT> elif dup == 1 : <NEWLINE> <INDENT> output [ index - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( int ( output [ i ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> abc = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> L = ( N - 1 ) // 2 <NEWLINE> for i in range ( 1 , L + 1 ) : <NEWLINE> <INDENT> for j in range ( N - 2 * i ) : <NEWLINE> <INDENT> if S [ j ] != S [ j + i ] and S [ j + i ] != S [ j + 2 * i ] and S [ j ] != S [ j + 2 * i ] : <NEWLINE> <INDENT> abc -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( abc ) <NEWLINE>
y , x = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> while ( x > 0 or y > 0 ) : <NEWLINE> <INDENT> for i in range ( y ) : <NEWLINE> <INDENT> print ( <STRING> * x ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> y , x = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> from collections import defaultdict <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> A , V = nm ( ) <NEWLINE> B , W = nm ( ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> d = abs ( A - B ) <NEWLINE> move_s = ( V - W ) <NEWLINE> if ( move_s <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if ( ( ( d // move_s ) ) <= ( T - 1 ) or ( ( d // move_s ) == T and ( d % move_s == 0 ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif K > A and B >= K - A : <NEWLINE> <INDENT> print ( 0 , B - ( K - A ) ) <NEWLINE> <DEDENT> elif K > A and B < ( K - A ) : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> gcds = [ ] <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcds . append ( math . gcd ( a , b ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for g in gcds : <NEWLINE> <INDENT> if c == 1 or g == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( c , g ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> <NL> res = 1 <NEWLINE> <NL> if k == n : <NEWLINE> <INDENT> for e in a : <NEWLINE> <INDENT> res *= e <NEWLINE> res %= MOD <NEWLINE> <DEDENT> <DEDENT> elif max ( a ) < 0 : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> for i in range ( n - k , n ) : <NEWLINE> <INDENT> res *= a [ i ] <NEWLINE> res %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> res *= a [ i ] <NEWLINE> res %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> plus_a = [ e for e in a if e >= 0 ] <NEWLINE> minus_a = [ e for e in a if e < 0 ] <NEWLINE> <NL> minus_cnt = min ( k , len ( minus_a ) ) <NEWLINE> minus_cnt -= minus_cnt % 2 <NEWLINE> plus_cnt = k - minus_cnt <NEWLINE> <NL> minus_a = minus_a [ : minus_cnt ] <NEWLINE> minus_a . reverse ( ) <NEWLINE> <NL> max_change_cnt = min ( minus_cnt , len ( plus_a ) - plus_cnt ) <NEWLINE> max_change_cnt -= max_change_cnt % 2 <NEWLINE> change_cnt = 0 <NEWLINE> while change_cnt < max_change_cnt : <NEWLINE> <INDENT> if plus_a [ plus_cnt + change_cnt ] * plus_a [ plus_cnt + change_cnt + 1 ] <= minus_a [ change_cnt ] * minus_a [ change_cnt + 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> change_cnt += 2 <NEWLINE> <NL> <DEDENT> for i in range ( change_cnt , minus_cnt ) : <NEWLINE> <INDENT> res *= minus_a [ i ] <NEWLINE> res %= MOD <NEWLINE> <NL> <DEDENT> for i in range ( plus_cnt + change_cnt ) : <NEWLINE> <INDENT> res *= plus_a [ i ] <NEWLINE> res %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l , r = [ 0 ] * K , [ 0 ] * K <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> l [ k ] , r [ k ] = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> dp = [ 0 ] * N <NEWLINE> dps = [ 0 ] * ( N - 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dps [ 0 ] = - 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> if i + l [ k ] - 1 < ( N - 1 ) : <NEWLINE> <INDENT> dps [ i + l [ k ] - 1 ] += dp [ i ] <NEWLINE> <DEDENT> if i + r [ k ] < ( N - 1 ) : <NEWLINE> <INDENT> dps [ i + r [ k ] ] -= dp [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> dp [ i + 1 ] = ( dps [ i ] + dp [ i ] ) % 998244353 <NEWLINE> <DEDENT> print ( dp [ - 1 ] % 998244353 ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> H = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> ans += H [ i - v ] <NEWLINE> H [ i + v ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <NL> <INDENT> def lcs ( X , Y ) : <NEWLINE> <INDENT> m = len ( X ) <NEWLINE> n = len ( Y ) <NEWLINE> c = [ [ - 1 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] <NEWLINE> X = <STRING> + X <NEWLINE> Y = <STRING> + Y <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> c [ i ] [ 0 ] = 0 <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c [ 0 ] [ j ] = 0 <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if X [ i ] == Y [ j ] : <NEWLINE> <INDENT> c [ i ] [ j ] = c [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ i ] [ j ] = max ( c [ i - 1 ] [ j ] , c [ i ] [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c [ m ] [ n ] <NEWLINE> <NL> <DEDENT> def lcs2 ( X , Y ) : <NEWLINE> <INDENT> n = len ( Y ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for c in X : <NEWLINE> <INDENT> tmp = dp [ : ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if c == Y [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = tmp [ j ] + 1 <NEWLINE> <DEDENT> elif dp [ j + 1 ] < dp [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = dp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> print ( lcs2 ( X , Y ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
x , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> try : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> data = [ ] <NEWLINE> <DEDENT> point = 0 <NEWLINE> i = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if x not in data : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> elif x + i not in data : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> elif x + ( - 1 * i ) not in data : <NEWLINE> <INDENT> print ( x + ( - 1 * i ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i - 1 <NEWLINE> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> stones = input ( ) <NEWLINE> <NL> w = [ ] <NEWLINE> r = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if stones [ i ] == <STRING> : <NEWLINE> <INDENT> w . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( w ) != 0 and len ( r ) != 0 : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i , val in enumerate ( w ) : <NEWLINE> <INDENT> if val <= r [ - 1 * ( i + 1 ) ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
number = input ( ) <NEWLINE> list = number . split ( ) <NEWLINE> list . sort ( ) <NEWLINE> print ( list [ 0 ] + <STRING> + list [ 1 ] + <STRING> + list [ 2 ] ) <NEWLINE>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> l = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> r = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> d = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> u = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> s = np . array ( [ list ( input ( ) ) for _ in range ( H ) ] ) == <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> u [ i ] = ( u [ i - 1 ] + 1 ) * s [ i ] <NEWLINE> d [ - i - 1 ] = ( d [ - i ] + 1 ) * s [ - i - 1 ] <NEWLINE> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> l [ : , i ] = ( l [ : , i - 1 ] + 1 ) * s [ : , i ] <NEWLINE> r [ : , - i - 1 ] = ( r [ : , - i ] + 1 ) * s [ : , - i - 1 ] <NEWLINE> <DEDENT> print ( np . max ( u + d + l + r ) - 3 ) <NEWLINE>
import numpy as np <NEWLINE> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> <COMMENT> <NL> d = np . zeros ( ( 3001 , 3001 ) ) <NEWLINE> d [ 0 , 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Ai = As [ i - 1 ] <NEWLINE> d [ i ] += 2 * d [ i - 1 ] <NEWLINE> d [ i , Ai : ] += d [ i - 1 ] [ : - Ai ] <NEWLINE> d [ i ] %= MOD <NEWLINE> <DEDENT> print ( int ( d [ N ] [ S ] ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> def isprime ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n < 2 or n % 2 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> i = 3 <NEWLINE> while i <= math . sqrt ( n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> p += isprime ( i ) <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nlis = sorted ( lis ) <NEWLINE> <NL> med1 = nlis [ n // 2 - 1 ] <NEWLINE> med2 = nlis [ n // 2 ] <NEWLINE> <NL> for i in lis : <NEWLINE> <INDENT> if i <= med1 : <NEWLINE> <INDENT> print ( med2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( med1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> cur = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cur += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return cur <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) + <STRING> <NEWLINE> <COMMENT> <NL> N = len ( S ) <NEWLINE> S = list ( map ( int , S ) ) <NEWLINE> <NL> q = 2019 <NEWLINE> <NL> res = [ 0 ] * N <NEWLINE> num = 0 <NEWLINE> p = 1 <NEWLINE> pow_memo = { 0 : ( 10 ** 0 ) % q } <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> pow_memo [ p ] = ( pow_memo [ p - 1 ] * 10 ) % q <NEWLINE> num = ( num + ( S [ i ] % q ) * pow_memo [ p ] ) % q <NEWLINE> res [ i ] = num <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * q <NEWLINE> for r in res : <NEWLINE> <INDENT> cnt [ r ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in cnt : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> A_list = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> A_list . sort ( key = lambda x : - abs ( x ) ) <NEWLINE> A_plus = [ ] <NEWLINE> A_minus = [ ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for val in A_list : <NEWLINE> <INDENT> if val >= 0 : <NEWLINE> <INDENT> A_plus . append ( val ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_minus . append ( val ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( not A_plus ) : <NEWLINE> <INDENT> if ( K % 2 == 0 ) : <NEWLINE> <INDENT> target_range = range ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> target_range = range ( len ( A_minus ) - K , len ( A_minus ) ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in target_range : <NEWLINE> <INDENT> ans *= A_minus [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if ( not A_minus ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A_plus [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> select = [ ] <NEWLINE> i_p = 0 <COMMENT> <NEWLINE> i_m = 0 <COMMENT> <NEWLINE> <NL> <NL> while ( len ( select ) < K ) : <NEWLINE> <INDENT> if ( K - len ( select ) ) == 1 : <NEWLINE> <INDENT> if i_p < len ( A_plus ) : <NEWLINE> <INDENT> select . append ( A_plus [ i_p ] ) <NEWLINE> i_p += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> for i in range ( len ( A_list ) - K , len ( A_list ) ) : <NEWLINE> <INDENT> ans *= A_list [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( i_m + 1 ) < len ( A_minus ) : <NEWLINE> <INDENT> if ( i_p + 1 ) < len ( A_plus ) : <NEWLINE> <INDENT> if abs ( A_plus [ i_p ] * A_plus [ i_p + 1 ] ) > abs ( A_minus [ i_m ] * A_minus [ i_m + 1 ] ) : <NEWLINE> <INDENT> select . append ( A_plus [ i_p ] ) <NEWLINE> i_p += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> select . extend ( [ A_minus [ i_m ] , A_minus [ i_m + 1 ] ] ) <NEWLINE> i_m += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> select . extend ( [ A_minus [ i_m ] , A_minus [ i_m + 1 ] ] ) <NEWLINE> i_m += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> select . append ( A_plus [ i_p ] ) <NEWLINE> i_p += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> ans *= select [ i ] <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( a , K ) : <NEWLINE> <INDENT> for c in range ( b , K ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> part = math . gcd ( ab , c ) <NEWLINE> if a == b or b == c : <NEWLINE> <INDENT> if not ( a == b and b == c ) : <NEWLINE> <INDENT> part = part * 3 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> part = part * 6 <NEWLINE> <DEDENT> ans += part <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> possess = 1000 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> stock = possess // A [ i ] <NEWLINE> possess = possess % A [ i ] + A [ i + 1 ] * stock <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( possess ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ans = x // 11 <NEWLINE> chk = x % 11 <NEWLINE> if chk == 0 : <NEWLINE> <INDENT> print ( 2 * ans ) <NEWLINE> <DEDENT> elif chk <= 6 : <NEWLINE> <INDENT> print ( 2 * ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * ans + 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> tmp += int ( N [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if tmp % 9 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> np_ab = np . array ( ab ) <NEWLINE> max_a = max ( np_ab [ : , 0 ] ) <NEWLINE> dp = [ 0 ] * ( h + max_a ) <NEWLINE> for i in range ( 1 , h + max_a ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in ab ) <NEWLINE> <DEDENT> print ( min ( dp [ h : ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> DP = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> min_k = float ( <STRING> ) <NEWLINE> min_k = min ( [ DP [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( i - K , 0 ) , i ) ] ) <NEWLINE> DP [ i ] = min_k <NEWLINE> pass <NEWLINE> <DEDENT> print ( DP [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( N ) ) + 2 ) : <NEWLINE> <INDENT> if N % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> m = N // i - 1 <NEWLINE> if m <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if N // m == N % m : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> <COMMENT> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> b_size = math . ceil ( math . sqrt ( n ) ) <NEWLINE> b_len = math . ceil ( n / b_size ) <NEWLINE> a = [ 2 ** 31 - 1 for i in range ( n ) ] <NEWLINE> b = [ min ( a [ b_size * i : b_size * ( i + 1 ) ] ) for i in range ( b_len ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> a [ x ] = y <NEWLINE> <COMMENT> <NL> index = x // b_size <NEWLINE> b [ index ] = min ( a [ index * b_size : ( index + 1 ) * b_size ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> target = [ ] <NEWLINE> x_index = x // b_size <NEWLINE> y_index = y // b_size <NEWLINE> x_mod = x % b_size <NEWLINE> y_mod = y % b_size <NEWLINE> if x_index == y_index : <NEWLINE> <INDENT> target . extend ( a [ x : y + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x_mod == 0 : <NEWLINE> <INDENT> target . append ( b [ x_index ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> target . extend ( a [ x : ( x_index + 1 ) * b_size ] ) <NEWLINE> <NL> <DEDENT> if y_mod == b_size - 1 : <NEWLINE> <INDENT> target . append ( b [ y_index ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> target . extend ( a [ y_index * b_size : y + 1 ] ) <NEWLINE> <NL> <DEDENT> if x_index + 1 <= y_index - 1 : <NEWLINE> <INDENT> target . append ( min ( b [ x_index + 1 : y_index ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( target ) ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for A in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for B in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if pow ( A , 5 ) - pow ( B , 5 ) == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
T , A , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sta = T + A - K <NEWLINE> if sta <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sta >= A : <NEWLINE> <INDENT> print ( str ( T - K ) + <STRING> + str ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( sta ) ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> keep = [ 0 ] * ( n ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> keep [ i ] = keep [ i - 1 ] <NEWLINE> l , r = i - 1 , i + 1 <NEWLINE> if s [ l : r ] == <STRING> : <NEWLINE> <INDENT> keep [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( keep [ r - 1 ] - keep [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( A [ i ] + i + 1 ) <NEWLINE> R . append ( i + 1 - A [ i ] ) <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> R . sort ( ) <NEWLINE> R = Counter ( R ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += R [ L [ i ] ] <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> ans = 1000000000000000 <NEWLINE> m = x // d <NEWLINE> if m > k : <NEWLINE> <INDENT> print ( abs ( x - k * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k % 2 == 0 and m % 2 == 1 ) or ( k % 2 == 1 and m % 2 == 0 ) : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> ans = min ( ans , x - m * d ) <NEWLINE> <STRING> <NEWLINE> print ( abs ( ans ) ) <NEWLINE> <DEDENT>
from math import log2 , ceil <NEWLINE> <NL> <NL> class SegmentTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> tn = 2 ** ceil ( log2 ( n ) ) <NEWLINE> self . a = [ 2 ** 31 - 1 ] * ( tn * 2 ) <NEWLINE> self . tn = tn <NEWLINE> <NL> <DEDENT> def find ( self , s , t ) : <NEWLINE> <INDENT> return self . __find ( 1 , 0 , self . tn - 1 , s , t ) <NEWLINE> <NL> <DEDENT> def __find ( self , c , l , r , s , t ) : <NEWLINE> <INDENT> if self . a [ c ] == - 1 : <NEWLINE> <INDENT> return self . a [ c // 2 ] <NEWLINE> <DEDENT> if s <= l and r <= t : <NEWLINE> <INDENT> return self . a [ c ] <NEWLINE> <DEDENT> mid = ( l + r ) // 2 <NEWLINE> if t <= mid : <NEWLINE> <INDENT> return self . __find ( c * 2 , l , mid , s , t ) <NEWLINE> <DEDENT> elif s > mid : <NEWLINE> <INDENT> return self . __find ( c * 2 + 1 , mid + 1 , r , s , t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return min ( <NEWLINE> <INDENT> self . __find ( c * 2 , l , mid , s , mid ) , <NEWLINE> self . __find ( c * 2 + 1 , mid + 1 , r , mid + 1 , t ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def update ( self , s , t , x ) : <NEWLINE> <INDENT> self . __update ( 1 , 0 , self . tn - 1 , s , t , x ) <NEWLINE> <NL> <DEDENT> def __update ( self , c , l , r , s , t , x , f = None ) : <NEWLINE> <NL> <INDENT> if f is None and self . a [ c ] == - 1 : <NEWLINE> <INDENT> f = self . a [ c // 2 ] <NEWLINE> <NL> <DEDENT> if l == s and r == t : <NEWLINE> <INDENT> return self . __set ( c , x ) <NEWLINE> <NL> <DEDENT> mid = ( l + r ) // 2 <NEWLINE> if t <= mid : <NEWLINE> <INDENT> rv , f = self . __get_child ( c , c * 2 + 1 , f ) <NEWLINE> u = min ( self . __update ( c * 2 , l , mid , s , t , x , f ) , rv ) <NEWLINE> <DEDENT> elif s > mid : <NEWLINE> <INDENT> lv , f = self . __get_child ( c , c * 2 , f ) <NEWLINE> u = min ( lv , self . __update ( c * 2 + 1 , mid + 1 , r , s , t , x , f ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u = min ( <NEWLINE> <INDENT> self . __update ( c * 2 , l , mid , s , mid , x , f ) , <NEWLINE> self . __update ( c * 2 + 1 , mid + 1 , r , mid + 1 , t , x , f ) ) <NEWLINE> <DEDENT> if f is not None : <NEWLINE> <INDENT> u = min ( f , u ) <NEWLINE> <DEDENT> <DEDENT> self . a [ c ] = u <NEWLINE> <NL> return u <NEWLINE> <NL> <DEDENT> def __set ( self , c , x ) : <NEWLINE> <INDENT> self . a [ c ] = x <NEWLINE> if c < self . tn : <NEWLINE> <INDENT> self . a [ c * 2 ] = self . a [ c * 2 + 1 ] = - 1 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def __get_child ( self , c , child , f ) : <NEWLINE> <INDENT> if f is not None : <NEWLINE> <INDENT> return self . __set ( child , f ) , f <NEWLINE> <DEDENT> v = self . a [ child ] <NEWLINE> if v == - 1 : <NEWLINE> <INDENT> f = self . a [ c ] <NEWLINE> v = self . __set ( child , f ) <NEWLINE> <DEDENT> return v , f <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> st = SegmentTree ( n ) <NEWLINE> buf = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> q_type , * query = map ( int , input ( ) . split ( ) ) <NEWLINE> if q_type == 0 : <NEWLINE> <INDENT> st . update ( * query ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buf . append ( st . find ( * query ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , buf ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ i for i in range ( N ) ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> B . append ( b ) <NEWLINE> <DEDENT> elif H [ b - 1 ] > H [ a - 1 ] : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> B = list ( set ( B ) ) <NEWLINE> print ( len ( A ) - len ( B ) ) <NEWLINE>
<COMMENT> <NL> input_d41 = int ( input ( ) ) <NEWLINE> input_d42 = input ( ) <NEWLINE> <NL> N = int ( input_d41 ) <NEWLINE> S = input_d42 <NEWLINE> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = N - ( R + G ) <NEWLINE> <NL> ans = R * G * B <NEWLINE> answ = 0 <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( N + i ) // 2 + 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> if 2 * j - i < N and S [ j ] != S [ 2 * j - i ] and S [ 2 * j - i ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> def p ( * _a ) : <NEWLINE> <INDENT> _s = <STRING> . join ( map ( str , _a ) ) <NEWLINE> <COMMENT> <NL> sys . stderr . write ( _s + <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> S = input ( ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> <NL> m = 2019 <NEWLINE> <NL> A = [ 0 ] * m <NEWLINE> A [ 0 ] = 1 <NEWLINE> <NL> a = 0 <NEWLINE> ans = 0 <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> a = a + ( int ( s ) * pow ( 10 , i , m ) ) <NEWLINE> a %= m <NEWLINE> <NL> ans += A [ a ] <NEWLINE> A [ a ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif N == 3 : <NEWLINE> <INDENT> print ( 11 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = N * ( N + 1 ) - 1 <NEWLINE> for i in range ( 2 , N // 2 + 1 ) : <NEWLINE> <INDENT> t = N // i <NEWLINE> ans += i * ( t * ( t + 1 ) // 2 - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> co = Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in co . items ( ) : <NEWLINE> <INDENT> ans += i [ 0 ] * i [ 1 ] <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in co . keys ( ) : <NEWLINE> <INDENT> ans -= b * co [ b ] <NEWLINE> co [ c ] += co [ b ] <NEWLINE> ans += c * co [ b ] <NEWLINE> co [ b ] = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A . append ( l [ 0 ] ) <NEWLINE> B . append ( l [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> G [ A [ i ] - 1 ] . append ( B [ i ] - 1 ) <NEWLINE> G [ B [ i ] - 1 ] . append ( A [ i ] - 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> q = deque ( [ ] ) <NEWLINE> ans = [ - 1 ] * N <NEWLINE> ans [ 0 ] = 0 <NEWLINE> q . appendleft ( 0 ) <NEWLINE> while ( len ( q ) > 0 ) : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> for nv in G [ v ] : <NEWLINE> <INDENT> if not ans [ nv ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ nv ] = v <NEWLINE> q . appendleft ( nv ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i , v in enumerate ( ans ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( v + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> p = 2 <NEWLINE> counter = 0 <NEWLINE> while N != 1 : <NEWLINE> <INDENT> if p > math . sqrt ( N ) : <NEWLINE> <INDENT> counter += 1 <NEWLINE> break <NEWLINE> <DEDENT> ind = 0 <NEWLINE> n = - 1 <NEWLINE> while N % p == 0 : <NEWLINE> <INDENT> N //= p <NEWLINE> ind += 1 <NEWLINE> <DEDENT> if ind == 0 : <NEWLINE> <INDENT> p += 1 <NEWLINE> continue <NEWLINE> <DEDENT> while ( n + 1 ) * ( n + 2 ) // 2 <= ind : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> counter += n <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> print ( counter ) <NEWLINE>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> xa , ya , xb , yb = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ip = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> xs , ys , xt , yt , o , l = map ( int , input ( ) . split ( ) ) <NEWLINE> d = ( xb - xa ) * ( yt - ys ) - ( yb - ya ) * ( xt - xs ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t0 = ( ( yt - ys ) * ( xs - xa ) - ( xt - xs ) * ( ys - ya ) ) / d <NEWLINE> t1 = ( ( yb - ya ) * ( xs - xa ) - ( xb - xa ) * ( ys - ya ) ) / d <NEWLINE> if ( t0 > 0 and t0 < 1 ) and ( t1 > 0 and t1 < 1 ) : <NEWLINE> <INDENT> ip . append ( ( t0 , o == l ) ) <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> if len ( ip ) > 0 : <NEWLINE> <INDENT> ip . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for j in range ( len ( ip ) - 1 ) : <NEWLINE> <INDENT> if ip [ j ] [ 1 ] != ip [ j + 1 ] [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> count = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> count *= i <NEWLINE> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> len_B = M + 1 <NEWLINE> res = [ ] <NEWLINE> for i , a_ in enumerate ( a ) : <NEWLINE> <INDENT> for j in range ( len_B ) [ : : - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> if a_ + b [ j ] <= K : <NEWLINE> <INDENT> res . append ( i + j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> len_B = j + 1 <NEWLINE> <NL> <DEDENT> print ( 0 if len ( res ) < 1 else max ( res ) ) <NEWLINE>
from collections import deque <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = deque ( ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> seen = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> queue . append ( [ 0 , 0 ] ) <NEWLINE> ans = [ [ 1000000000 ] * w for _ in range ( h ) ] <NEWLINE> seen [ 0 ] [ 0 ] = True <NEWLINE> ans [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( h * w * 10 ) : <NEWLINE> <INDENT> if len ( queue ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = queue . popleft ( ) <NEWLINE> if cnt [ 0 ] != 0 : <NEWLINE> <INDENT> if seen [ cnt [ 0 ] - 1 ] [ cnt [ 1 ] ] == False and s [ cnt [ 0 ] - 1 ] [ cnt [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ cnt [ 0 ] - 1 , cnt [ 1 ] ] ) <NEWLINE> ans [ cnt [ 0 ] - 1 ] [ cnt [ 1 ] ] = ans [ cnt [ 0 ] ] [ cnt [ 1 ] ] + 1 <NEWLINE> seen [ cnt [ 0 ] - 1 ] [ cnt [ 1 ] ] = True <NEWLINE> <DEDENT> <DEDENT> if cnt [ 1 ] != 0 : <NEWLINE> <INDENT> if seen [ cnt [ 0 ] ] [ cnt [ 1 ] - 1 ] == False and s [ cnt [ 0 ] ] [ cnt [ 1 ] - 1 ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ cnt [ 0 ] , cnt [ 1 ] - 1 ] ) <NEWLINE> ans [ cnt [ 0 ] ] [ cnt [ 1 ] - 1 ] = ans [ cnt [ 0 ] ] [ cnt [ 1 ] ] + 1 <NEWLINE> seen [ cnt [ 0 ] ] [ cnt [ 1 ] - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> if cnt [ 0 ] != h - 1 : <NEWLINE> <INDENT> if seen [ cnt [ 0 ] + 1 ] [ cnt [ 1 ] ] == False and s [ cnt [ 0 ] + 1 ] [ cnt [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ cnt [ 0 ] + 1 , cnt [ 1 ] ] ) <NEWLINE> ans [ cnt [ 0 ] + 1 ] [ cnt [ 1 ] ] = ans [ cnt [ 0 ] ] [ cnt [ 1 ] ] + 1 <NEWLINE> seen [ cnt [ 0 ] + 1 ] [ cnt [ 1 ] ] = True <NEWLINE> <DEDENT> <DEDENT> if cnt [ 1 ] != w - 1 : <NEWLINE> <INDENT> if seen [ cnt [ 0 ] ] [ cnt [ 1 ] + 1 ] == False and s [ cnt [ 0 ] ] [ cnt [ 1 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ cnt [ 0 ] , cnt [ 1 ] + 1 ] ) <NEWLINE> ans [ cnt [ 0 ] ] [ cnt [ 1 ] + 1 ] = ans [ cnt [ 0 ] ] [ cnt [ 1 ] ] + 1 <NEWLINE> seen [ cnt [ 0 ] ] [ cnt [ 1 ] + 1 ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt2 = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if seen [ - 1 ] [ - 1 ] == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt2 - ans [ - 1 ] [ - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def root ( x ) : <NEWLINE> <INDENT> if x == parent [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> y = root ( parent [ x ] ) <NEWLINE> relative [ x ] += relative [ parent [ x ] ] <NEWLINE> parent [ x ] = y <NEWLINE> return y <NEWLINE> <DEDENT> def unite ( a , b , w ) : <NEWLINE> <INDENT> pa = root ( a ) ; pb = root ( b ) <NEWLINE> pw = relative [ a ] + w - relative [ b ] <NEWLINE> if pa < pb : <NEWLINE> <INDENT> parent [ pb ] = pa <NEWLINE> relative [ pb ] = pw <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ pa ] = pb <NEWLINE> relative [ pa ] = - pw <NEWLINE> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> * parent , = range ( N ) <NEWLINE> relative = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> a , b , w = map ( int , cmd [ 1 : ] ) <NEWLINE> unite ( a - 1 , b - 1 , w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = map ( int , cmd [ 1 : ] ) <NEWLINE> if root ( a - 1 ) != root ( b - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( relative [ b - 1 ] - relative [ a - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if 1 <= N <= 10000 : <NEWLINE> <INDENT> if N % 1000 != 0 : <NEWLINE> <INDENT> ans = ( ( N // 1000 ) + 1 ) * 1000 - N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = [ int ( x ) for x in list ( input ( ) ) ] <NEWLINE> for c in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if c == len ( s ) - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s [ c ] = ( pow ( 10 , len ( s ) - c - 1 , 2019 ) * s [ c ] + s [ c + 1 ] ) % 2019 <NEWLINE> <DEDENT> s . append ( 0 ) <NEWLINE> s . sort ( ) <NEWLINE> h = [ 1 ] <NEWLINE> d = s [ 0 ] <NEWLINE> for c in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ c ] != d : <NEWLINE> <INDENT> h . append ( 1 ) <NEWLINE> d = s [ c ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h [ - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> k = [ ( x * ( x - 1 ) ) // 2 for x in h ] <NEWLINE> print ( sum ( k ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N - 1 ) * N // 2 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> dic = { } <NEWLINE> dic [ 1 + A [ 0 ] ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i - A [ i - 1 ] in dic : <NEWLINE> <INDENT> ans += dic [ i - A [ i - 1 ] ] <NEWLINE> <DEDENT> if i + A [ i - 1 ] in dic : <NEWLINE> <INDENT> dic [ i + A [ i - 1 ] ] = dic [ i + A [ i - 1 ] ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ i + A [ i - 1 ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> push = 0 <NEWLINE> count = [ False ] * N <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <NL> <INDENT> if A [ push ] == 1 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif count [ push ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count [ push ] = True <NEWLINE> push = A [ push ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> feeindays = [ [ ] for _ in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= m : feeindays [ a - 1 ] += [ b ] <NEWLINE> <DEDENT> q = [ ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> pay = 0 <NEWLINE> for l in feeindays : <NEWLINE> <INDENT> for c in l : heapq . heappush ( q , - c ) <NEWLINE> if len ( q ) != 0 : pay += - 1 * heapq . heappop ( q ) <NEWLINE> <DEDENT> print ( pay ) <NEWLINE>
import sys <NEWLINE> <NL> I = 0 <NEWLINE> L = 1 <NEWLINE> R = 2 <NEWLINE> P = 3 <NEWLINE> B = 4 <NEWLINE> D = 5 <NEWLINE> H = 6 <NEWLINE> <NL> def getroot ( A , id ) : <NEWLINE> <INDENT> if A [ id ] [ P ] > - 1 : <NEWLINE> <INDENT> return getroot ( A , A [ id ] [ P ] ) <NEWLINE> <DEDENT> return A [ id ] [ I ] <NEWLINE> <NL> <DEDENT> def preorder ( N , id , A ) : <NEWLINE> <INDENT> if id < 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> A . append ( id ) <NEWLINE> preorder ( N , N [ id ] [ L ] , A ) <NEWLINE> preorder ( N , N [ id ] [ R ] , A ) <NEWLINE> <NL> <DEDENT> def inorder ( N , id , A ) : <NEWLINE> <INDENT> if id < 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( N , N [ id ] [ L ] , A ) <NEWLINE> A . append ( id ) <NEWLINE> inorder ( N , N [ id ] [ R ] , A ) <NEWLINE> <NL> <DEDENT> def postorder ( N , id , A ) : <NEWLINE> <INDENT> if id < 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> postorder ( N , N [ id ] [ L ] , A ) <NEWLINE> postorder ( N , N [ id ] [ R ] , A ) <NEWLINE> A . append ( id ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> <STRING> <NEWLINE> num = int ( input ( ) . strip ( ) ) <NEWLINE> istr = sys . stdin . read ( ) <NEWLINE> nlist = list ( istr . splitlines ( ) ) <NEWLINE> <NL> nodes = [ [ i , - 1 , - 1 , - 1 , - 1 , 0 , 0 ] for i in range ( num ) ] <NEWLINE> <NL> for nstr in nlist : <NEWLINE> <INDENT> i = list ( map ( int , nstr . split ( ) ) ) <NEWLINE> n = nodes [ i [ I ] ] <NEWLINE> n [ I ] = i [ I ] <NEWLINE> if i [ L ] > - 1 : <NEWLINE> <INDENT> n [ L ] = i [ L ] <NEWLINE> nodes [ n [ L ] ] [ P ] = i [ I ] <NEWLINE> nodes [ n [ L ] ] [ B ] = i [ R ] <NEWLINE> <DEDENT> if i [ R ] > - 1 : <NEWLINE> <INDENT> n [ R ] = i [ R ] <NEWLINE> nodes [ n [ R ] ] [ P ] = i [ I ] <NEWLINE> nodes [ n [ R ] ] [ B ] = i [ L ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> r = getroot ( nodes , 0 ) <NEWLINE> <COMMENT> <NL> <NL> pre = [ <STRING> ] <NEWLINE> ino = [ <STRING> ] <NEWLINE> pos = [ <STRING> ] <NEWLINE> <NL> preorder ( nodes , r , pre ) <NEWLINE> inorder ( nodes , r , ino ) <NEWLINE> postorder ( nodes , r , pos ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , pre ) ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , ino ) ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , pos ) ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> c = c * b [ i ] <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
S = str ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> ans = 0 <NEWLINE> mod_set = [ 0 ] * mod <NEWLINE> mod_set [ 0 ] += 1 <NEWLINE> ten = 1 <NEWLINE> k = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> k = ( k + ten * int ( S [ i ] ) ) % mod <NEWLINE> mod_set [ k ] += 1 <NEWLINE> ten = ( ten * 10 ) % mod <NEWLINE> <NL> <DEDENT> for i in mod_set : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def solve ( N , A ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> upper = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ret *= i <NEWLINE> if upper < ret : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( N , A ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import numpy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> la = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a_max = max ( la ) <NEWLINE> dp = numpy . ones ( a_max + 1 ) <NEWLINE> counts = numpy . zeros ( a_max + 1 ) <NEWLINE> for a in la : <NEWLINE> <INDENT> counts [ a ] += 1 <NEWLINE> if counts [ a ] < 2 : <NEWLINE> <INDENT> dp [ 2 * a : : a ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( len ( [ a for a in la if dp [ a ] == 1 and counts [ a ] == 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S ^= a [ i ] <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans [ i ] = S ^ a [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ - 1 ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> deta = [ False for i in range ( N + 1 ) ] <NEWLINE> i = 1 <NEWLINE> tele = 1 <NEWLINE> telelist = [ 1 ] <NEWLINE> while not deta [ A [ i ] ] : <NEWLINE> <INDENT> telelist . append ( A [ i ] ) <NEWLINE> deta [ A [ i ] ] = True <NEWLINE> i = A [ i ] <NEWLINE> <NL> <DEDENT> k = 0 <NEWLINE> for s in telelist : <NEWLINE> <INDENT> if s == A [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> <DEDENT> if K <= k : <NEWLINE> <INDENT> print ( telelist [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = len ( telelist ) - k <NEWLINE> K -= k <NEWLINE> s = K % l <NEWLINE> print ( telelist [ k + s ] ) <NEWLINE> <DEDENT>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> if a + b + c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b + c == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if a == 1 and b == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif a == 0 and b == 1 : <NEWLINE> <INDENT> a = 1 <NEWLINE> b = 0 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> if b == 1 and c == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> c = 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif b == 0 and c == 1 : <NEWLINE> <INDENT> b = 1 <NEWLINE> c = 0 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a == 1 and c == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> c = 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif a == 0 and c == 1 : <NEWLINE> <INDENT> a = 1 <NEWLINE> c = 0 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> s2 = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = s [ i ] <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> s2 = s [ i + 1 ] <NEWLINE> <DEDENT> if s1 == <STRING> : <NEWLINE> <INDENT> if a >= 1 and b == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b = 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif a == 0 and b >= 1 : <NEWLINE> <INDENT> a = 1 <NEWLINE> b -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif a >= 1 and b >= 1 : <NEWLINE> <INDENT> if s2 == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> a -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif s1 == <STRING> : <NEWLINE> <INDENT> if b >= 1 and c == 0 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c = 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif b == 0 and c >= 1 : <NEWLINE> <INDENT> b = 1 <NEWLINE> c -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif b >= 1 and c >= 1 : <NEWLINE> <INDENT> if s2 == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a >= 1 and c == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c = 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif a == 0 and c >= 1 : <NEWLINE> <INDENT> a = 1 <NEWLINE> c -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif a >= 1 and c >= 1 : <NEWLINE> <INDENT> if s2 == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> s1 = s2 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N , M , K = MI ( ) <NEWLINE> A = [ 0 ] + LI ( ) <NEWLINE> B = [ 0 ] + LI ( ) <NEWLINE> from itertools import accumulate <NEWLINE> A = list ( accumulate ( A ) ) <NEWLINE> B = list ( accumulate ( B ) ) <NEWLINE> ans = 0 <NEWLINE> b_cnt = M <NEWLINE> for a_cnt in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ a_cnt ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ a_cnt ] + B [ b_cnt ] > K : <NEWLINE> <INDENT> b_cnt -= 1 <NEWLINE> <DEDENT> ans = max ( ans , a_cnt + b_cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M , P = [ ] , [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> M . append ( a ) if a < 0 else P . append ( a ) <NEWLINE> <NL> <DEDENT> m , p = len ( M ) , len ( P ) <NEWLINE> ok = False <NEWLINE> if p > 0 : <NEWLINE> <INDENT> ok = m % 2 == 0 if n == k else True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = k % 2 == 0 <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> if not ok : <NEWLINE> <INDENT> A . sort ( key = lambda x : abs ( x ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> res = ( res * A [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> P . sort ( ) <NEWLINE> M . sort ( reverse = True ) <NEWLINE> if k % 2 : <NEWLINE> <INDENT> a = P . pop ( ) <NEWLINE> res = ( res * a ) % mod <NEWLINE> <DEDENT> M_2 = [ ] <NEWLINE> while len ( P ) >= 2 : <NEWLINE> <INDENT> a = P . pop ( ) <NEWLINE> a *= P . pop ( ) <NEWLINE> M_2 . append ( a ) <NEWLINE> <DEDENT> while len ( M ) >= 2 : <NEWLINE> <INDENT> a = M . pop ( ) <NEWLINE> a *= M . pop ( ) <NEWLINE> M_2 . append ( a ) <NEWLINE> <DEDENT> M_2 . sort ( reverse = True ) <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> res = ( res * M_2 [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect_right , insort_right <NEWLINE> <NL> <NL> class SquareSkipList : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , values = None , sorted_ = False , square = 1000 , seed = 42 , inf = float ( <STRING> ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . square = square <NEWLINE> if values is None : <NEWLINE> <INDENT> self . rand_y = seed <NEWLINE> self . layer1 = [ inf ] <NEWLINE> self . layer0 = [ [ ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . layer1 = layer1 = [ ] <NEWLINE> self . layer0 = layer0 = [ ] <NEWLINE> if not sorted_ : <NEWLINE> <INDENT> values . sort ( ) <NEWLINE> <DEDENT> y = seed <NEWLINE> l0 = [ ] <NEWLINE> for v in values : <NEWLINE> <INDENT> y ^= ( y & 0x7ffff ) << 13 <NEWLINE> y ^= y >> 17 <NEWLINE> y ^= ( y & 0x7ffffff ) << 5 <NEWLINE> if y % square == 0 : <NEWLINE> <INDENT> layer0 . append ( l0 ) <NEWLINE> l0 = [ ] <NEWLINE> layer1 . append ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l0 . append ( v ) <NEWLINE> <DEDENT> <DEDENT> layer1 . append ( inf ) <NEWLINE> layer0 . append ( l0 ) <NEWLINE> self . rand_y = y <NEWLINE> <NL> <DEDENT> <DEDENT> def add ( self , x ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> y = self . rand_y <NEWLINE> y ^= ( y & 0x7ffff ) << 13 <NEWLINE> y ^= y >> 17 <NEWLINE> y ^= ( y & 0x7ffffff ) << 5 <NEWLINE> self . rand_y = y <NEWLINE> <NL> if y % self . square == 0 : <NEWLINE> <INDENT> layer1 , layer0 = self . layer1 , self . layer0 <NEWLINE> idx1 = bisect_right ( layer1 , x ) <NEWLINE> layer1 . insert ( idx1 , x ) <NEWLINE> layer0_idx1 = layer0 [ idx1 ] <NEWLINE> idx0 = bisect_right ( layer0_idx1 , x ) <NEWLINE> layer0 . insert ( idx1 + 1 , layer0_idx1 [ idx0 : ] ) <COMMENT> <NEWLINE> del layer0_idx1 [ idx0 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx1 = bisect_right ( self . layer1 , x ) <NEWLINE> insort_right ( self . layer0 [ idx1 ] , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> def remove ( self , x ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> idx1 = bisect_left ( self . layer1 , x ) <NEWLINE> layer0_idx1 = self . layer0 [ idx1 ] <NEWLINE> idx0 = bisect_left ( layer0_idx1 , x ) <NEWLINE> if idx0 == len ( layer0_idx1 ) : <NEWLINE> <INDENT> del self . layer1 [ idx1 ] <NEWLINE> self . layer0 [ idx1 ] += self . layer0 . pop ( idx1 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del layer0_idx1 [ idx0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def search_higher_equal ( self , x ) : <COMMENT> <NEWLINE> <INDENT> idx1 = bisect_left ( self . layer1 , x ) <NEWLINE> layer0_idx1 = self . layer0 [ idx1 ] <NEWLINE> idx0 = bisect_left ( layer0_idx1 , x ) <NEWLINE> if idx0 == len ( layer0_idx1 ) : <NEWLINE> <INDENT> return self . layer1 [ idx1 ] <NEWLINE> <DEDENT> return layer0_idx1 [ idx0 ] <NEWLINE> <NL> <DEDENT> def search_higher ( self , x ) : <COMMENT> <NEWLINE> <INDENT> idx1 = bisect_right ( self . layer1 , x ) <NEWLINE> layer0_idx1 = self . layer0 [ idx1 ] <NEWLINE> idx0 = bisect_right ( layer0_idx1 , x ) <NEWLINE> if idx0 == len ( layer0_idx1 ) : <NEWLINE> <INDENT> return self . layer1 [ idx1 ] <NEWLINE> <DEDENT> return layer0_idx1 [ idx0 ] <NEWLINE> <NL> <DEDENT> def search_lower ( self , x ) : <COMMENT> <NEWLINE> <INDENT> idx1 = bisect_left ( self . layer1 , x ) <NEWLINE> layer0_idx1 = self . layer0 [ idx1 ] <NEWLINE> idx0 = bisect_left ( layer0_idx1 , x ) <NEWLINE> if idx0 == 0 : <COMMENT> <NEWLINE> <INDENT> return self . layer1 [ idx1 - 1 ] <NEWLINE> <DEDENT> return layer0_idx1 [ idx0 - 1 ] <NEWLINE> <NL> <DEDENT> def pop ( self , idx ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> layer0 = self . layer0 <NEWLINE> s = - 1 <NEWLINE> for i , l0 in enumerate ( layer0 ) : <NEWLINE> <INDENT> s += len ( l0 ) + 1 <NEWLINE> if s >= idx : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if s == idx : <NEWLINE> <INDENT> layer0 [ i ] += layer0 . pop ( i + 1 ) <NEWLINE> return self . layer1 . pop ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return layer0 [ i ] . pop ( idx - s ) <NEWLINE> <NL> <DEDENT> <DEDENT> def pop_max ( self ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if self . layer0 [ - 1 ] : <NEWLINE> <INDENT> return self . layer0 [ - 1 ] . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del self . layer0 [ - 1 ] <NEWLINE> return self . layer1 . pop ( - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __getitem__ ( self , item ) : <NEWLINE> <COMMENT> <NL> <INDENT> layer0 = self . layer0 <NEWLINE> s = - 1 <NEWLINE> for i , l0 in enumerate ( layer0 ) : <NEWLINE> <INDENT> s += len ( l0 ) + 1 <NEWLINE> if s >= item : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if s == item : <NEWLINE> <INDENT> return self . layer1 [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return layer0 [ i ] [ item - s ] <NEWLINE> <NL> <DEDENT> <DEDENT> def min ( self ) : <COMMENT> <NEWLINE> <INDENT> return self . layer0 [ 0 ] [ 0 ] if self . layer0 [ 0 ] else self . layer1 [ 0 ] <NEWLINE> <NL> <DEDENT> def max ( self ) : <COMMENT> <NEWLINE> <INDENT> return self . layer0 [ - 1 ] [ - 1 ] if self . layer0 [ - 1 ] else self . layer1 [ - 2 ] <NEWLINE> <NL> <DEDENT> def merge ( self , r ) : <COMMENT> <NEWLINE> <INDENT> self . layer0 [ - 1 ] += r . layer0 [ 0 ] <NEWLINE> self . layer0 += r . layer0 [ 1 : ] <NEWLINE> del self . layer1 [ - 1 ] <NEWLINE> self . layer1 += r . layer1 <NEWLINE> <NL> <DEDENT> def split ( self , k ) : <COMMENT> <NEWLINE> <INDENT> idx1 = bisect_left ( self . layer1 , k ) <NEWLINE> layer0_idx1 = self . layer0 [ idx1 ] <NEWLINE> idx0 = bisect_left ( layer0_idx1 , k ) <NEWLINE> r = SquareSkipList ( square = self . square , seed = self . rand_y ) <NEWLINE> r . layer1 = self . layer1 [ idx1 : ] <NEWLINE> r . layer0 = [ layer0_idx1 [ idx0 : ] ] + self . layer0 [ idx1 + 1 : ] <NEWLINE> del self . layer1 [ idx1 : - 1 ] , layer0_idx1 [ idx0 : ] , self . layer0 [ idx1 + 1 : ] <NEWLINE> return r <NEWLINE> <NL> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( self . layer1 ) <NEWLINE> print ( self . layer0 ) <NEWLINE> <NL> <DEDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> layer1 = self . layer1 <NEWLINE> layer0 = self . layer0 <NEWLINE> idx1 = idx0 = 0 <NEWLINE> layer0_idx1 = layer0 [ idx1 ] <NEWLINE> while True : <NEWLINE> <INDENT> if len ( layer0_idx1 ) == idx0 : <NEWLINE> <INDENT> if len ( layer1 ) - 1 == idx1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> yield layer1 [ idx1 ] <NEWLINE> idx1 += 1 <NEWLINE> layer0_idx1 = layer0 [ idx1 ] <NEWLINE> idx0 = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield layer0_idx1 [ idx0 ] <NEWLINE> idx0 += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> from operator import itemgetter <NEWLINE> from itertools import groupby <NEWLINE> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> hw = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> hw = sorted ( zip ( hw , hw ) , key = itemgetter ( 0 ) ) <NEWLINE> Cnt_w = [ 0 ] * ( W + 1 ) <NEWLINE> for _ , w in hw : <NEWLINE> <INDENT> Cnt_w [ w ] += 1 <NEWLINE> <DEDENT> sl = SquareSkipList ( Cnt_w [ : ] ) <NEWLINE> ans = 0 <NEWLINE> for h , group in groupby ( hw , key = itemgetter ( 0 ) ) : <NEWLINE> <INDENT> group = list ( group ) <NEWLINE> for _ , w in group : <NEWLINE> <INDENT> cnt = Cnt_w [ w ] <NEWLINE> sl . remove ( cnt ) <NEWLINE> sl . add ( cnt - 1 ) <NEWLINE> Cnt_w [ w ] -= 1 <NEWLINE> <DEDENT> an = len ( group ) + sl . max ( ) <NEWLINE> if ans < an : <NEWLINE> <INDENT> ans = an <NEWLINE> <DEDENT> for _ , w in group : <NEWLINE> <INDENT> cnt = Cnt_w [ w ] <NEWLINE> sl . remove ( cnt ) <NEWLINE> sl . add ( cnt + 1 ) <NEWLINE> Cnt_w [ w ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * d ) <NEWLINE> <NL>
<NL> nums1 = [ ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> nums1 . append ( nums ) <NEWLINE> <NL> <DEDENT> max = nums1 [ 1 ] [ 0 ] <NEWLINE> min = nums1 [ 1 ] [ 0 ] <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( len ( nums1 [ 1 ] ) ) : <NEWLINE> <INDENT> if nums1 [ 1 ] [ i ] > max : <NEWLINE> <INDENT> max = nums1 [ 1 ] [ i ] <NEWLINE> <DEDENT> if nums1 [ 1 ] [ i ] < min : <NEWLINE> <INDENT> min = nums1 [ 1 ] [ i ] <NEWLINE> <DEDENT> sum = sum + nums1 [ 1 ] [ i ] <NEWLINE> <NL> <DEDENT> print ( min , max , sum ) <NEWLINE>
N , M = 6 , 9 <NEWLINE> ARR = [ <NEWLINE> <INDENT> [ 3 , 4 ] , <NEWLINE> [ 6 , 1 ] , <NEWLINE> [ 2 , 4 ] , <NEWLINE> [ 5 , 3 ] , <NEWLINE> [ 4 , 6 ] , <NEWLINE> [ 1 , 5 ] , <NEWLINE> [ 6 , 2 ] , <NEWLINE> [ 4 , 5 ] , <NEWLINE> [ 5 , 6 ] , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> N , M = 4 , 4 <NEWLINE> ARR = [ <NEWLINE> <INDENT> [ 1 , 2 ] , <NEWLINE> [ 2 , 3 ] , <NEWLINE> [ 3 , 4 ] , <NEWLINE> [ 4 , 2 ] , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ARR = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ARR . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> <NL> def prepare ( n , m , arr ) : <NEWLINE> <INDENT> nodes = [ [ ] for i in range ( n ) ] <NEWLINE> nodeStates = [ - 1 for i in range ( n ) ] <NEWLINE> prevs = [ - 1 for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> startNode = arr [ i ] [ 0 ] - 1 <NEWLINE> endNode = arr [ i ] [ 1 ] - 1 <NEWLINE> <NL> nodes [ startNode ] . append ( endNode ) <NEWLINE> nodes [ endNode ] . append ( startNode ) <NEWLINE> <NL> <DEDENT> return nodes , nodeStates , prevs <NEWLINE> <NL> <NL> <DEDENT> nodes , nodeStates , prevs = prepare ( N , M , ARR ) <NEWLINE> <NL> <NL> def bfs ( nodes , nodeStates , prevs , n ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( { <STRING> : - 1 , <STRING> : 0 } ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> first = q . popleft ( ) <NEWLINE> currentNode = first [ <STRING> ] <NEWLINE> previousNode = first [ <STRING> ] <NEWLINE> if nodeStates [ currentNode ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prevs [ currentNode ] = previousNode <NEWLINE> childNodes = nodes [ currentNode ] <NEWLINE> nodeStates [ currentNode ] = 1 <NEWLINE> for childNode in childNodes : <NEWLINE> <INDENT> q . append ( { <STRING> : currentNode , <STRING> : childNode } ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( prevs [ i ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> bfs ( nodes , nodeStates , prevs , N ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> aa = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> list1 = [ ] <NEWLINE> ma = aa [ - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = abs ( aa [ i ] - ( ma + 1 ) // 2 ) <NEWLINE> list1 . append ( [ d , i ] ) <NEWLINE> <DEDENT> md = min ( list1 , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> print ( ma , aa [ md [ 1 ] ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> import fractions <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // fractions . gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( _n_list ) : <NEWLINE> <INDENT> return reduce ( lcm , _n_list ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> cnt = int ( _input [ 0 ] ) <NEWLINE> n_list = tuple ( map ( int , _input [ 1 ] . split ( ) ) ) <NEWLINE> print ( solve ( n_list ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> S . append ( 1 ) <NEWLINE> Q = set ( ) <NEWLINE> Q . add ( 1 ) <NEWLINE> p = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if L [ p ] in Q : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> S . append ( L [ p ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> S . append ( L [ p ] ) <NEWLINE> Q . add ( L [ p ] ) <NEWLINE> p = L [ p ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if S [ i ] != L [ p ] : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S2 = S [ i : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> loop = len ( S ) - cnt2 - 1 <NEWLINE> <NL> <NL> if cnt >= k : <NEWLINE> <INDENT> print ( S [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S2 [ ( k - cnt ) % loop ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> c = Counter ( a ) <NEWLINE> <NL> allsum = 0 <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <INDENT> allsum += k * v <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> bi , ci = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> allsum += ci * c [ bi ] - bi * c [ bi ] <NEWLINE> c [ ci ] = c [ ci ] + c [ bi ] <NEWLINE> c [ bi ] = 0 <NEWLINE> ans . append ( allsum ) <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> from math import factorial <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> m = S // 3 <COMMENT> <NEWLINE> <NL> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> def cmb ( n , r ) : <NEWLINE> <INDENT> r = min ( n - r , r ) <NEWLINE> if r == 0 : return 1 <NEWLINE> over = reduce ( mul , range ( n , n - r , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , r + 1 ) ) <NEWLINE> return over // under <NEWLINE> <NL> <NL> <NL> <DEDENT> for p in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> x = S - 3 * ( p ) <COMMENT> <NEWLINE> <STRING> <NEWLINE> ans += cmb ( x + p - 1 , p - 1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( int ( ( ans ) % ( 10 ** 9 + 7 ) ) ) <NEWLINE> <NL> <NL>
def p ( x ) : <NEWLINE> <INDENT> for i in range ( 7 , int ( x ** .5 + 1 ) , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : return 0 <NEWLINE> <DEDENT> else : return 1 <NEWLINE> <DEDENT> def f ( ) : <NEWLINE> <INDENT> n , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> * n <NEWLINE> if c < 0 : return ( 11 , s + s ) [ n > 1 ] <NEWLINE> for h in <STRING> : <NEWLINE> <INDENT> if n - 1 : <NEWLINE> <INDENT> for m in range ( int ( 10 ** ~ - n ) , 0 , - 1 ) : <NEWLINE> <INDENT> if ( ( int ( h ) + m - 1 ) * 2 + c ) % 3 : <NEWLINE> <INDENT> t = h + str ( m - 1 ) . zfill ( n - 1 ) <NEWLINE> a = int ( t + str ( c ) + t [ : : - 1 ] ) <NEWLINE> if p ( a ) : return a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = int ( h + str ( c ) + h ) <NEWLINE> if p ( a ) : return a <NEWLINE> <DEDENT> <DEDENT> return s + b + s <NEWLINE> <DEDENT> print ( f ( ) ) <NEWLINE>
mNM = map ( int , input ( ) . split ( ) ) <NEWLINE> lNM = list ( mNM ) <NEWLINE> <NL> mWay = [ map ( int , input ( ) . split ( ) ) for i in range ( lNM [ 1 ] ) ] <NEWLINE> lWay = [ list ( mWay [ i ] ) for i in range ( lNM [ 1 ] ) ] <NEWLINE> <NL> maps = [ - 1 for i in range ( lNM [ 0 ] ) ] <NEWLINE> deep = [ - 1 for i in range ( lNM [ 0 ] ) ] <NEWLINE> ways = [ [ ] for i in range ( lNM [ 0 ] ) ] <NEWLINE> <NL> for i in range ( lNM [ 1 ] ) : <NEWLINE> <INDENT> ways [ lWay [ i ] [ 0 ] - 1 ] . append ( lWay [ i ] [ 1 ] ) <NEWLINE> ways [ lWay [ i ] [ 1 ] - 1 ] . append ( lWay [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> maps [ 0 ] = 0 <NEWLINE> deep [ 0 ] = 0 <NEWLINE> nexts = [ 0 ] <NEWLINE> <NL> for i in range ( lNM [ 0 ] ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> index = nexts <NEWLINE> nexts = [ ] <NEWLINE> <NL> for x in index : <NEWLINE> <INDENT> for w in ways [ x ] : <NEWLINE> <INDENT> if ( deep [ w - 1 ] == - 1 ) : <NEWLINE> <INDENT> deep [ w - 1 ] = i + 1 <NEWLINE> maps [ w - 1 ] = x + 1 <NEWLINE> nexts . append ( w - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> if ( - 1 in maps ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in maps [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> flg = <STRING> <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if <STRING> in s [ 2 : len ( s ) - 1 ] : <NEWLINE> <INDENT> s . remove ( <STRING> ) <NEWLINE> s . remove ( <STRING> ) <NEWLINE> s = <STRING> . join ( s ) <NEWLINE> if s . islower ( ) == True : <NEWLINE> <INDENT> flg = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( flg ) <NEWLINE>
import math <NEWLINE> <COMMENT> <NL> pos_x1 , pos_y1 , pos_x2 , pos_y2 = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> dist = math . sqrt ( ( pos_x1 - pos_x2 ) ** 2 + ( pos_y1 - pos_y2 ) ** 2 ) <NEWLINE> print ( str ( dist ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> tmp = [ - 1000000000000000 , - 995009990004999 , - 990039920079968 , - 985089730404757 , - 980159361278976 , - 975248753121875 , - 970357846472224 , - 965486581988193 , - 960634900447232 , - 955802742745951 , - 950990049900000 , - 946196763043949 , - 941422823431168 , - 936668172433707 , - 931932751542176 , - 927216502365625 , - 922519366631424 , - 917841286185143 , - 913182202990432 , - 908542059128901 , - 903920796800000 , - 899318358320899 , - 894734686126368 , - 890169722768657 , - 885623410917376 , - 881095693359375 , - 876586512998624 , - 872095812856093 , - 867623536069632 , - 863169625893851 , - 858734025700000 , - 854316678975849 , - 849917529325568 , - 845536520469607 , - 841173596244576 , - 836828700603125 , - 832501777613824 , - 828192771461043 , - 823901626444832 , - 819628286980801 , - 815372697600000 , - 811134802948799 , - 806914547788768 , - 802711876996557 , - 798526735563776 , - 794359068596875 , - 790208821317024 , - 786075939059993 , - 781960367276032 , - 777862051529751 , - 773780937500000 , - 769716970979749 , - 765670097875968 , - 761640264209507 , - 757627416114976 , - 753631499840625 , - 749652461748224 , - 745690248312943 , - 741744806123232 , - 737816081880701 , - 733904022400000 , - 730008574608699 , - 726129685547168 , - 722267302368457 , - 718421372338176 , - 714591842834375 , - 710778661347424 , - 706981775479893 , - 703201132946432 , - 699436681573651 , - 695688369300000 , - 691956144175649 , - 688239954362368 , - 684539748133407 , - 680855473873376 , - 677187080078125 , - 673534515354624 , - 669897728420843 , - 666276668105632 , - 662671283348601 , - 659081523200000 , - 655507336820599 , - 651948673481568 , - 648405482564357 , - 644877713560576 , - 641365316071875 , - 637868239809824 , - 634386434595793 , - 630919850360832 , - 627468437145551 , - 624032145100000 , - 620610924483549 , - 617204725664768 , - 613813499121307 , - 610437195439776 , - 607075765315625 , - 603729159553024 , - 600397329064743 , - 597080224872032 , - 593777798104501 , - 590490000000000 , - 587216781904499 , - 583958095271968 , - 580713891664257 , - 577484122750976 , - 574268740309375 , - 571067696224224 , - 567880942487693 , - 564708431199232 , - 561550114565451 , - 558405944900000 , - 555275874623449 , - 552159856263168 , - 549057842453207 , - 545969785934176 , - 542895639553125 , - 539835356263424 , - 536788889124643 , - 533756191302432 , - 530737216068401 , - 527731916800000 , - 524740246980399 , - 521762160198368 , - 518797610148157 , - 515846550629376 , - 512908935546875 , - 509984718910624 , - 507073854835593 , - 504176297541632 , - 501292001353351 , - 498420920700000 , - 495563010115349 , - 492718224237568 , - 489886517809107 , - 487067845676576 , - 484262162790625 , - 481469424205824 , - 478689585080543 , - 475922600676832 , - 473168426360301 , - 470427017600000 , - 467698329968299 , - 464982319140768 , - 462278940896057 , - 459588151115776 , - 456909905784375 , - 454244160989024 , - 451590872919493 , - 448949997868032 , - 446321492229251 , - 443705312500000 , - 441101415279249 , - 438509757267968 , - 435930295269007 , - 433362986186976 , - 430807787028125 , - 428264654900224 , - 425733547012443 , - 423214420675232 , - 420707233300201 , - 418211942400000 , - 415728505588199 , - 413256880579168 , - 410797025187957 , - 408348897330176 , - 405912455021875 , - 403487656379424 , - 401074459619393 , - 398672823058432 , - 396282705113151 , - 393904064300000 , - 391536859235149 , - 389181048634368 , - 386836591312907 , - 384503446185376 , - 382181572265625 , - 379870928666624 , - 377571474600343 , - 375283169377632 , - 373005972408101 , - 370739843200000 , - 368484741360099 , - 366240626593568 , - 364007458703857 , - 361785197592576 , - 359573803259375 , - 357373235801824 , - 355183455415293 , - 353004422392832 , - 350836097125051 , - 348678440100000 , - 346531411903049 , - 344394973216768 , - 342269084820807 , - 340153707591776 , - 338048802503125 , - 335954330625024 , - 333870253124243 , - 331796531264032 , - 329733126404001 , - 327680000000000 , - 325637113603999 , - 323604428863968 , - 321581907523757 , - 319569511422976 , - 317567202496875 , - 315574942776224 , - 313592694387193 , - 311620419551232 , - 309658080584951 , - 307705639900000 , - 305763060002949 , - 303830303495168 , - 301907333072707 , - 299994111526176 , - 298090601740625 , - 296196766695424 , - 294312569464143 , - 292437973214432 , - 290572941207901 , - 288717436800000 , - 286871423439899 , - 285034864670368 , - 283207724127657 , - 281389965541376 , - 279581552734375 , - 277782449622624 , - 275992620215093 , - 274212028613632 , - 272440639012851 , - 270678415700000 , - 268925323054849 , - 267181325549568 , - 265446387748607 , - 263720474308576 , - 262003549978125 , - 260295579597824 , - 258596528100043 , - 256906360508832 , - 255225041939801 , - 253552537600000 , - 251888812787799 , - 250233832892768 , - 248587563395557 , - 246949969867776 , - 245321017971875 , - 243700673461024 , - 242088902178993 , - 240485670060032 , - 238890943128751 , - 237304687500000 , - 235726869378749 , - 234157455059968 , - 232596410928507 , - 231043703458976 , - 229499299215625 , - 227963164852224 , - 226435267111943 , - 224915572827232 , - 223404048919701 , - 221900662400000 , - 220405380367699 , - 218918170011168 , - 217438998607457 , - 215967833522176 , - 214504642209375 , - 213049392211424 , - 211602051158893 , - 210162586770432 , - 208730966852651 , - 207307159300000 , - 205891132094649 , - 204482853306368 , - 203082291092407 , - 201689413697376 , - 200304189453125 , - 198926586778624 , - 197556574179843 , - 196194120249632 , - 194839193667601 , - 193491763200000 , - 192151797699599 , - 190819266105568 , - 189494137443357 , - 188176380824576 , - 186865965446875 , - 185562860593824 , - 184267035634793 , - 182978460024832 , - 181697103304551 , - 180422935100000 , - 179155925122549 , - 177896043168768 , - 176643259120307 , - 175397542943776 , - 174158864690625 , - 172927194497024 , - 171702502583743 , - 170484759256032 , - 169273934903501 , - 168070000000000 , - 166872925103499 , - 165682680855968 , - 164499237983257 , - 163322567294976 , - 162152639684375 , - 160989426128224 , - 159832897686693 , - 158683025503232 , - 157539780804451 , - 156403134900000 , - 155273059182449 , - 154149525127168 , - 153032504292207 , - 151921968318176 , - 150817888928125 , - 149720237927424 , - 148628987203643 , - 147544108726432 , - 146465574547401 , - 145393356800000 , - 144327427699399 , - 143267759542368 , - 142214324707157 , - 141167095653376 , - 140126044921875 , - 139091145134624 , - 138062368994593 , - 137039689285632 , - 136023078872351 , - 135012510700000 , - 134007957794349 , - 133009393261568 , - 132016790288107 , - 131030122140576 , - 130049362165625 , - 129074483789824 , - 128105460519543 , - 127142265940832 , - 126184873719301 , - 125233257600000 , - 124287391407299 , - 123347249044768 , - 122412804495057 , - 121484031819776 , - 120560905159375 , - 119643398733024 , - 118731486838493 , - 117825143852032 , - 116924344228251 , - 116029062500000 , - 115139273278249 , - 114254951251968 , - 113376071188007 , - 112502607930976 , - 111634536403125 , - 110771831604224 , - 109914468611443 , - 109062422579232 , - 108215668739201 , - 107374182400000 , - 106537938947199 , - 105706913843168 , - 104881082626957 , - 104060420914176 , - 103244904396875 , - 102434508843424 , - 101629210098393 , - 100828984082432 , - 100033806792151 , - 99243654300000 , - 98458502754149 , - 97678328378368 , - 96903107471907 , - 96132816409376 , - 95367431640625 , - 94606929690624 , - 93851287159343 , - 93100480721632 , - 92354487127101 , - 91613283200000 , - 90876845839099 , - 90145152017568 , - 89418178782857 , - 88695903256576 , - 87978302634375 , - 87265354185824 , - 86557035254293 , - 85853323256832 , - 85154195684051 , - 84459630100000 , - 83769604142049 , - 83084095520768 , - 82403082019807 , - 81726541495776 , - 81054451878125 , - 80386791169024 , - 79723537443243 , - 79064668848032 , - 78410163603001 , - 77760000000000 , - 77114156402999 , - 76472611247968 , - 75835343042757 , - 75202330366976 , - 74573551871875 , - 73948986280224 , - 73328612386193 , - 72712409055232 , - 72100355223951 , - 71492429900000 , - 70888612161949 , - 70288881159168 , - 69693216111707 , - 69101596310176 , - 68514001115625 , - 67930409959424 , - 67350802343143 , - 66775157838432 , - 66203456086901 , - 65635676800000 , - 65071799758899 , - 64511804814368 , - 63955671886657 , - 63403380965376 , - 62854912109375 , - 62310245446624 , - 61769361174093 , - 61232239557632 , - 60698860931851 , - 60169205700000 , - 59643254333849 , - 59120987373568 , - 58602385427607 , - 58087429172576 , - 57576099353125 , - 57068376781824 , - 56564242339043 , - 56063676972832 , - 55566661698801 , - 55073177600000 , - 54583205826799 , - 54096727596768 , - 53613724194557 , - 53134176971776 , - 52658067346875 , - 52185376805024 , - 51716086897993 , - 51250179244032 , - 50787635527751 , - 50328437500000 , - 49872566977749 , - 49420005843968 , - 48970736047507 , - 48524739602976 , - 48081998590625 , - 47642495156224 , - 47206211510943 , - 46773129931232 , - 46343232758701 , - 45916502400000 , - 45492921326699 , - 45072472075168 , - 44655137246457 , - 44240899506176 , - 43829741584375 , - 43421646275424 , - 43016596437893 , - 42614574994432 , - 42215564931651 , - 41819549300000 , - 41426511213649 , - 41036433850368 , - 40649300451407 , - 40265094321376 , - 39883798828125 , - 39505397402624 , - 39129873538843 , - 38757210793632 , - 38387392786601 , - 38020403200000 , - 37656225778599 , - 37294844329568 , - 36936242722357 , - 36580404888576 , - 36227314821875 , - 35876956577824 , - 35529314273793 , - 35184372088832 , - 34842114263551 , - 34502525100000 , - 34165588961549 , - 33831290272768 , - 33499613519307 , - 33170543247776 , - 32844064065625 , - 32520160641024 , - 32198817702743 , - 31880020040032 , - 31563752502501 , - 31250000000000 , - 30938747502499 , - 30629980039968 , - 30323682702257 , - 30019840638976 , - 29718439059375 , - 29419463232224 , - 29122898485693 , - 28828730207232 , - 28536943843451 , - 28247524900000 , - 27960458941449 , - 27675731591168 , - 27393328531207 , - 27113235502176 , - 26835438303125 , - 26559922791424 , - 26286674882643 , - 26015680550432 , - 25746925826401 , - 25480396800000 , - 25216079618399 , - 24953960486368 , - 24694025666157 , - 24436261477376 , - 24180654296875 , - 23927190558624 , - 23675856753593 , - 23426639429632 , - 23179525191351 , - 22934500700000 , - 22691552673349 , - 22450667885568 , - 22211833167107 , - 21975035404576 , - 21740261540625 , - 21507498573824 , - 21276733558543 , - 21047953604832 , - 20821145878301 , - 20596297600000 , - 20373396046299 , - 20152428548768 , - 19933382494057 , - 19716245323776 , - 19501004534375 , - 19287647677024 , - 19076162357493 , - 18866536236032 , - 18658757027251 , - 18452812500000 , - 18248690477249 , - 18046378835968 , - 17845865507007 , - 17647138474976 , - 17450185778125 , - 17254995508224 , - 17061555810443 , - 16869854883232 , - 16679880978201 , - 16491622400000 , - 16305067506199 , - 16120204707168 , - 15937022465957 , - 15755509298176 , - 15575653771875 , - 15397444507424 , - 15220870177393 , - 15045919506432 , - 14872581271151 , - 14700844300000 , - 14530697473149 , - 14362129722368 , - 14195130030907 , - 14029687433376 , - 13865791015625 , - 13703429914624 , - 13542593318343 , - 13383270465632 , - 13225450646101 , - 13069123200000 , - 12914277518099 , - 12760903041568 , - 12608989261857 , - 12458525720576 , - 12309502009375 , - 12161907769824 , - 12015732693293 , - 11870966520832 , - 11727599043051 , - 11585620100000 , - 11445019581049 , - 11305787424768 , - 11167913618807 , - 11031388199776 , - 10896201253125 , - 10762342913024 , - 10629803362243 , - 10498572832032 , - 10368641602001 , - 10240000000000 , - 10112638401999 , - 9986547231968 , - 9861716961757 , - 9738138110976 , - 9615801246875 , - 9494696984224 , - 9374815985193 , - 9256148959232 , - 9138686662951 , - 9022419900000 , - 8907339520949 , - 8793436423168 , - 8680701550707 , - 8569125894176 , - 8458700490625 , - 8349416423424 , - 8241264822143 , - 8134236862432 , - 8028323765901 , - 7923516800000 , - 7819807277899 , - 7717186558368 , - 7615646045657 , - 7515177189376 , - 7415771484375 , - 7317420470624 , - 7220115733093 , - 7123848901632 , - 7028611650851 , - 6934395700000 , - 6841192812849 , - 6748994797568 , - 6657793506607 , - 6567580836576 , - 6478348728125 , - 6390089165824 , - 6302794178043 , - 6216455836832 , - 6131066257801 , - 6046617600000 , - 5963102065799 , - 5880511900768 , - 5798839393557 , - 5718076875776 , - 5638216721875 , - 5559251349024 , - 5481173216993 , - 5403974828032 , - 5327648726751 , - 5252187500000 , - 5177583776749 , - 5103830227968 , - 5030919566507 , - 4958844546976 , - 4887597965625 , - 4817172660224 , - 4747561509943 , - 4678757435232 , - 4610753397701 , - 4543542400000 , - 4477117485699 , - 4411471739168 , - 4346598285457 , - 4282490290176 , - 4219140959375 , - 4156543539424 , - 4094691316893 , - 4033577618432 , - 3973195810651 , - 3913539300000 , - 3854601532649 , - 3796375994368 , - 3738856210407 , - 3682035745376 , - 3625908203125 , - 3570467226624 , - 3515706497843 , - 3461619737632 , - 3408200705601 , - 3355443200000 , - 3303341057599 , - 3251888153568 , - 3201078401357 , - 3150905752576 , - 3101364196875 , - 3052447761824 , - 3004150512793 , - 2956466552832 , - 2909390022551 , - 2862915100000 , - 2817036000549 , - 2771746976768 , - 2727042318307 , - 2682916351776 , - 2639363440625 , - 2596377985024 , - 2553954421743 , - 2512087224032 , - 2470770901501 , - 2430000000000 , - 2389769101499 , - 2350072823968 , - 2310905821257 , - 2272262782976 , - 2234138434375 , - 2196527536224 , - 2159424884693 , - 2122825311232 , - 2086723682451 , - 2051114900000 , - 2015993900449 , - 1981355655168 , - 1947195170207 , - 1913507486176 , - 1880287678125 , - 1847530855424 , - 1815232161643 , - 1783386774432 , - 1751989905401 , - 1721036800000 , - 1690522737399 , - 1660443030368 , - 1630793025157 , - 1601568101376 , - 1572763671875 , - 1544375182624 , - 1516398112593 , - 1488827973632 , - 1461660310351 , - 1434890700000 , - 1408514752349 , - 1382528109568 , - 1356926446107 , - 1331705468576 , - 1306860915625 , - 1282388557824 , - 1258284197543 , - 1234543668832 , - 1211162837301 , - 1188137600000 , - 1165463885299 , - 1143137652768 , - 1121154893057 , - 1099511627776 , - 1078203909375 , - 1057227821024 , - 1036579476493 , - 1016255020032 , - 996250626251 , - 976562500000 , - 957186876249 , - 938120019968 , - 919358226007 , - 900897818976 , - 882735153125 , - 864866612224 , - 847288609443 , - 829997587232 , - 812990017201 , - 796262400000 , - 779811265199 , - 763633171168 , - 747724704957 , - 732082482176 , - 716703146875 , - 701583371424 , - 686719856393 , - 672109330432 , - 657748550151 , - 643634300000 , - 629763392149 , - 616132666368 , - 602738989907 , - 589579257376 , - 576650390625 , - 563949338624 , - 551473077343 , - 539218609632 , - 527182965101 , - 515363200000 , - 503756397099 , - 492359665568 , - 481170140857 , - 470184984576 , - 459401384375 , - 448816553824 , - 438427732293 , - 428232184832 , - 418227202051 , - 408410100000 , - 398778220049 , - 389328928768 , - 380059617807 , - 370967703776 , - 362050628125 , - 353305857024 , - 344730881243 , - 336323216032 , - 328080401001 , - 320000000000 , - 312079600999 , - 304316815968 , - 296709280757 , - 289254654976 , - 281950621875 , - 274794888224 , - 267785184193 , - 260919263232 , - 254194901951 , - 247609900000 , - 241162079949 , - 234849287168 , - 228669389707 , - 222620278176 , - 216699865625 , - 210906087424 , - 205236901143 , - 199690286432 , - 194264244901 , - 188956800000 , - 183765996899 , - 178689902368 , - 173726604657 , - 168874213376 , - 164130859375 , - 159494694624 , - 154963892093 , - 150536645632 , - 146211169851 , - 141985700000 , - 137858491849 , - 133827821568 , - 129891985607 , - 126049300576 , - 122298103125 , - 118636749824 , - 115063617043 , - 111577100832 , - 108175616801 , - 104857600000 , - 101621504799 , - 98465804768 , - 95388992557 , - 92389579776 , - 89466096875 , - 86617093024 , - 83841135993 , - 81136812032 , - 78502725751 , - 75937500000 , - 73439775749 , - 71008211968 , - 68641485507 , - 66338290976 , - 64097340625 , - 61917364224 , - 59797108943 , - 57735339232 , - 55730836701 , - 53782400000 , - 51888844699 , - 50049003168 , - 48261724457 , - 46525874176 , - 44840334375 , - 43204003424 , - 41615795893 , - 40074642432 , - 38579489651 , - 37129300000 , - 35723051649 , - 34359738368 , - 33038369407 , - 31757969376 , - 30517578125 , - 29316250624 , - 28153056843 , - 27027081632 , - 25937424601 , - 24883200000 , - 23863536599 , - 22877577568 , - 21924480357 , - 21003416576 , - 20113571875 , - 19254145824 , - 18424351793 , - 17623416832 , - 16850581551 , - 16105100000 , - 15386239549 , - 14693280768 , - 14025517307 , - 13382255776 , - 12762815625 , - 12166529024 , - 11592740743 , - 11040808032 , - 10510100501 , - 10000000000 , - 9509900499 , - 9039207968 , - 8587340257 , - 8153726976 , - 7737809375 , - 7339040224 , - 6956883693 , - 6590815232 , - 6240321451 , - 5904900000 , - 5584059449 , - 5277319168 , - 4984209207 , - 4704270176 , - 4437053125 , - 4182119424 , - 3939040643 , - 3707398432 , - 3486784401 , - 3276800000 , - 3077056399 , - 2887174368 , - 2706784157 , - 2535525376 , - 2373046875 , - 2219006624 , - 2073071593 , - 1934917632 , - 1804229351 , - 1680700000 , - 1564031349 , - 1453933568 , - 1350125107 , - 1252332576 , - 1160290625 , - 1073741824 , - 992436543 , - 916132832 , - 844596301 , - 777600000 , - 714924299 , - 656356768 , - 601692057 , - 550731776 , - 503284375 , - 459165024 , - 418195493 , - 380204032 , - 345025251 , - 312500000 , - 282475249 , - 254803968 , - 229345007 , - 205962976 , - 184528125 , - 164916224 , - 147008443 , - 130691232 , - 115856201 , - 102400000 , - 90224199 , - 79235168 , - 69343957 , - 60466176 , - 52521875 , - 45435424 , - 39135393 , - 33554432 , - 28629151 , - 24300000 , - 20511149 , - 17210368 , - 14348907 , - 11881376 , - 9765625 , - 7962624 , - 6436343 , - 5153632 , - 4084101 , - 3200000 , - 2476099 , - 1889568 , - 1419857 , - 1048576 , - 759375 , - 537824 , - 371293 , - 248832 , - 161051 , - 100000 , - 59049 , - 32768 , - 16807 , - 7776 , - 3125 , - 1024 , - 243 , - 32 , - 1 , 0 , 1 , 32 , 243 , 1024 , 3125 , 7776 , 16807 , 32768 , 59049 , 100000 , 161051 , 248832 , 371293 , 537824 , 759375 , 1048576 , 1419857 , 1889568 , 2476099 , 3200000 , 4084101 , 5153632 , 6436343 , 7962624 , 9765625 , 11881376 , 14348907 , 17210368 , 20511149 , 24300000 , 28629151 , 33554432 , 39135393 , 45435424 , 52521875 , 60466176 , 69343957 , 79235168 , 90224199 , 102400000 , 115856201 , 130691232 , 147008443 , 164916224 , 184528125 , 205962976 , 229345007 , 254803968 , 282475249 , 312500000 , 345025251 , 380204032 , 418195493 , 459165024 , 503284375 , 550731776 , 601692057 , 656356768 , 714924299 , 777600000 , 844596301 , 916132832 , 992436543 , 1073741824 , 1160290625 , 1252332576 , 1350125107 , 1453933568 , 1564031349 , 1680700000 , 1804229351 , 1934917632 , 2073071593 , 2219006624 , 2373046875 , 2535525376 , 2706784157 , 2887174368 , 3077056399 , 3276800000 , 3486784401 , 3707398432 , 3939040643 , 4182119424 , 4437053125 , 4704270176 , 4984209207 , 5277319168 , 5584059449 , 5904900000 , 6240321451 , 6590815232 , 6956883693 , 7339040224 , 7737809375 , 8153726976 , 8587340257 , 9039207968 , 9509900499 , 10000000000 , 10510100501 , 11040808032 , 11592740743 , 12166529024 , 12762815625 , 13382255776 , 14025517307 , 14693280768 , 15386239549 , 16105100000 , 16850581551 , 17623416832 , 18424351793 , 19254145824 , 20113571875 , 21003416576 , 21924480357 , 22877577568 , 23863536599 , 24883200000 , 25937424601 , 27027081632 , 28153056843 , 29316250624 , 30517578125 , 31757969376 , 33038369407 , 34359738368 , 35723051649 , 37129300000 , 38579489651 , 40074642432 , 41615795893 , 43204003424 , 44840334375 , 46525874176 , 48261724457 , 50049003168 , 51888844699 , 53782400000 , 55730836701 , 57735339232 , 59797108943 , 61917364224 , 64097340625 , 66338290976 , 68641485507 , 71008211968 , 73439775749 , 75937500000 , 78502725751 , 81136812032 , 83841135993 , 86617093024 , 89466096875 , 92389579776 , 95388992557 , 98465804768 , 101621504799 , 104857600000 , 108175616801 , 111577100832 , 115063617043 , 118636749824 , 122298103125 , 126049300576 , 129891985607 , 133827821568 , 137858491849 , 141985700000 , 146211169851 , 150536645632 , 154963892093 , 159494694624 , 164130859375 , 168874213376 , 173726604657 , 178689902368 , 183765996899 , 188956800000 , 194264244901 , 199690286432 , 205236901143 , 210906087424 , 216699865625 , 222620278176 , 228669389707 , 234849287168 , 241162079949 , 247609900000 , 254194901951 , 260919263232 , 267785184193 , 274794888224 , 281950621875 , 289254654976 , 296709280757 , 304316815968 , 312079600999 , 320000000000 , 328080401001 , 336323216032 , 344730881243 , 353305857024 , 362050628125 , 370967703776 , 380059617807 , 389328928768 , 398778220049 , 408410100000 , 418227202051 , 428232184832 , 438427732293 , 448816553824 , 459401384375 , 470184984576 , 481170140857 , 492359665568 , 503756397099 , 515363200000 , 527182965101 , 539218609632 , 551473077343 , 563949338624 , 576650390625 , 589579257376 , 602738989907 , 616132666368 , 629763392149 , 643634300000 , 657748550151 , 672109330432 , 686719856393 , 701583371424 , 716703146875 , 732082482176 , 747724704957 , 763633171168 , 779811265199 , 796262400000 , 812990017201 , 829997587232 , 847288609443 , 864866612224 , 882735153125 , 900897818976 , 919358226007 , 938120019968 , 957186876249 , 976562500000 , 996250626251 , 1016255020032 , 1036579476493 , 1057227821024 , 1078203909375 , 1099511627776 , 1121154893057 , 1143137652768 , 1165463885299 , 1188137600000 , 1211162837301 , 1234543668832 , 1258284197543 , 1282388557824 , 1306860915625 , 1331705468576 , 1356926446107 , 1382528109568 , 1408514752349 , 1434890700000 , 1461660310351 , 1488827973632 , 1516398112593 , 1544375182624 , 1572763671875 , 1601568101376 , 1630793025157 , 1660443030368 , 1690522737399 , 1721036800000 , 1751989905401 , 1783386774432 , 1815232161643 , 1847530855424 , 1880287678125 , 1913507486176 , 1947195170207 , 1981355655168 , 2015993900449 , 2051114900000 , 2086723682451 , 2122825311232 , 2159424884693 , 2196527536224 , 2234138434375 , 2272262782976 , 2310905821257 , 2350072823968 , 2389769101499 , 2430000000000 , 2470770901501 , 2512087224032 , 2553954421743 , 2596377985024 , 2639363440625 , 2682916351776 , 2727042318307 , 2771746976768 , 2817036000549 , 2862915100000 , 2909390022551 , 2956466552832 , 3004150512793 , 3052447761824 , 3101364196875 , 3150905752576 , 3201078401357 , 3251888153568 , 3303341057599 , 3355443200000 , 3408200705601 , 3461619737632 , 3515706497843 , 3570467226624 , 3625908203125 , 3682035745376 , 3738856210407 , 3796375994368 , 3854601532649 , 3913539300000 , 3973195810651 , 4033577618432 , 4094691316893 , 4156543539424 , 4219140959375 , 4282490290176 , 4346598285457 , 4411471739168 , 4477117485699 , 4543542400000 , 4610753397701 , 4678757435232 , 4747561509943 , 4817172660224 , 4887597965625 , 4958844546976 , 5030919566507 , 5103830227968 , 5177583776749 , 5252187500000 , 5327648726751 , 5403974828032 , 5481173216993 , 5559251349024 , 5638216721875 , 5718076875776 , 5798839393557 , 5880511900768 , 5963102065799 , 6046617600000 , 6131066257801 , 6216455836832 , 6302794178043 , 6390089165824 , 6478348728125 , 6567580836576 , 6657793506607 , 6748994797568 , 6841192812849 , 6934395700000 , 7028611650851 , 7123848901632 , 7220115733093 , 7317420470624 , 7415771484375 , 7515177189376 , 7615646045657 , 7717186558368 , 7819807277899 , 7923516800000 , 8028323765901 , 8134236862432 , 8241264822143 , 8349416423424 , 8458700490625 , 8569125894176 , 8680701550707 , 8793436423168 , 8907339520949 , 9022419900000 , 9138686662951 , 9256148959232 , 9374815985193 , 9494696984224 , 9615801246875 , 9738138110976 , 9861716961757 , 9986547231968 , 10112638401999 , 10240000000000 , 10368641602001 , 10498572832032 , 10629803362243 , 10762342913024 , 10896201253125 , 11031388199776 , 11167913618807 , 11305787424768 , 11445019581049 , 11585620100000 , 11727599043051 , 11870966520832 , 12015732693293 , 12161907769824 , 12309502009375 , 12458525720576 , 12608989261857 , 12760903041568 , 12914277518099 , 13069123200000 , 13225450646101 , 13383270465632 , 13542593318343 , 13703429914624 , 13865791015625 , 14029687433376 , 14195130030907 , 14362129722368 , 14530697473149 , 14700844300000 , 14872581271151 , 15045919506432 , 15220870177393 , 15397444507424 , 15575653771875 , 15755509298176 , 15937022465957 , 16120204707168 , 16305067506199 , 16491622400000 , 16679880978201 , 16869854883232 , 17061555810443 , 17254995508224 , 17450185778125 , 17647138474976 , 17845865507007 , 18046378835968 , 18248690477249 , 18452812500000 , 18658757027251 , 18866536236032 , 19076162357493 , 19287647677024 , 19501004534375 , 19716245323776 , 19933382494057 , 20152428548768 , 20373396046299 , 20596297600000 , 20821145878301 , 21047953604832 , 21276733558543 , 21507498573824 , 21740261540625 , 21975035404576 , 22211833167107 , 22450667885568 , 22691552673349 , 22934500700000 , 23179525191351 , 23426639429632 , 23675856753593 , 23927190558624 , 24180654296875 , 24436261477376 , 24694025666157 , 24953960486368 , 25216079618399 , 25480396800000 , 25746925826401 , 26015680550432 , 26286674882643 , 26559922791424 , 26835438303125 , 27113235502176 , 27393328531207 , 27675731591168 , 27960458941449 , 28247524900000 , 28536943843451 , 28828730207232 , 29122898485693 , 29419463232224 , 29718439059375 , 30019840638976 , 30323682702257 , 30629980039968 , 30938747502499 , 31250000000000 , 31563752502501 , 31880020040032 , 32198817702743 , 32520160641024 , 32844064065625 , 33170543247776 , 33499613519307 , 33831290272768 , 34165588961549 , 34502525100000 , 34842114263551 , 35184372088832 , 35529314273793 , 35876956577824 , 36227314821875 , 36580404888576 , 36936242722357 , 37294844329568 , 37656225778599 , 38020403200000 , 38387392786601 , 38757210793632 , 39129873538843 , 39505397402624 , 39883798828125 , 40265094321376 , 40649300451407 , 41036433850368 , 41426511213649 , 41819549300000 , 42215564931651 , 42614574994432 , 43016596437893 , 43421646275424 , 43829741584375 , 44240899506176 , 44655137246457 , 45072472075168 , 45492921326699 , 45916502400000 , 46343232758701 , 46773129931232 , 47206211510943 , 47642495156224 , 48081998590625 , 48524739602976 , 48970736047507 , 49420005843968 , 49872566977749 , 50328437500000 , 50787635527751 , 51250179244032 , 51716086897993 , 52185376805024 , 52658067346875 , 53134176971776 , 53613724194557 , 54096727596768 , 54583205826799 , 55073177600000 , 55566661698801 , 56063676972832 , 56564242339043 , 57068376781824 , 57576099353125 , 58087429172576 , 58602385427607 , 59120987373568 , 59643254333849 , 60169205700000 , 60698860931851 , 61232239557632 , 61769361174093 , 62310245446624 , 62854912109375 , 63403380965376 , 63955671886657 , 64511804814368 , 65071799758899 , 65635676800000 , 66203456086901 , 66775157838432 , 67350802343143 , 67930409959424 , 68514001115625 , 69101596310176 , 69693216111707 , 70288881159168 , 70888612161949 , 71492429900000 , 72100355223951 , 72712409055232 , 73328612386193 , 73948986280224 , 74573551871875 , 75202330366976 , 75835343042757 , 76472611247968 , 77114156402999 , 77760000000000 , 78410163603001 , 79064668848032 , 79723537443243 , 80386791169024 , 81054451878125 , 81726541495776 , 82403082019807 , 83084095520768 , 83769604142049 , 84459630100000 , 85154195684051 , 85853323256832 , 86557035254293 , 87265354185824 , 87978302634375 , 88695903256576 , 89418178782857 , 90145152017568 , 90876845839099 , 91613283200000 , 92354487127101 , 93100480721632 , 93851287159343 , 94606929690624 , 95367431640625 , 96132816409376 , 96903107471907 , 97678328378368 , 98458502754149 , 99243654300000 , 100033806792151 , 100828984082432 , 101629210098393 , 102434508843424 , 103244904396875 , 104060420914176 , 104881082626957 , 105706913843168 , 106537938947199 , 107374182400000 , 108215668739201 , 109062422579232 , 109914468611443 , 110771831604224 , 111634536403125 , 112502607930976 , 113376071188007 , 114254951251968 , 115139273278249 , 116029062500000 , 116924344228251 , 117825143852032 , 118731486838493 , 119643398733024 , 120560905159375 , 121484031819776 , 122412804495057 , 123347249044768 , 124287391407299 , 125233257600000 , 126184873719301 , 127142265940832 , 128105460519543 , 129074483789824 , 130049362165625 , 131030122140576 , 132016790288107 , 133009393261568 , 134007957794349 , 135012510700000 , 136023078872351 , 137039689285632 , 138062368994593 , 139091145134624 , 140126044921875 , 141167095653376 , 142214324707157 , 143267759542368 , 144327427699399 , 145393356800000 , 146465574547401 , 147544108726432 , 148628987203643 , 149720237927424 , 150817888928125 , 151921968318176 , 153032504292207 , 154149525127168 , 155273059182449 , 156403134900000 , 157539780804451 , 158683025503232 , 159832897686693 , 160989426128224 , 162152639684375 , 163322567294976 , 164499237983257 , 165682680855968 , 166872925103499 , 168070000000000 , 169273934903501 , 170484759256032 , 171702502583743 , 172927194497024 , 174158864690625 , 175397542943776 , 176643259120307 , 177896043168768 , 179155925122549 , 180422935100000 , 181697103304551 , 182978460024832 , 184267035634793 , 185562860593824 , 186865965446875 , 188176380824576 , 189494137443357 , 190819266105568 , 192151797699599 , 193491763200000 , 194839193667601 , 196194120249632 , 197556574179843 , 198926586778624 , 200304189453125 , 201689413697376 , 203082291092407 , 204482853306368 , 205891132094649 , 207307159300000 , 208730966852651 , 210162586770432 , 211602051158893 , 213049392211424 , 214504642209375 , 215967833522176 , 217438998607457 , 218918170011168 , 220405380367699 , 221900662400000 , 223404048919701 , 224915572827232 , 226435267111943 , 227963164852224 , 229499299215625 , 231043703458976 , 232596410928507 , 234157455059968 , 235726869378749 , 237304687500000 , 238890943128751 , 240485670060032 , 242088902178993 , 243700673461024 , 245321017971875 , 246949969867776 , 248587563395557 , 250233832892768 , 251888812787799 , 253552537600000 , 255225041939801 , 256906360508832 , 258596528100043 , 260295579597824 , 262003549978125 , 263720474308576 , 265446387748607 , 267181325549568 , 268925323054849 , 270678415700000 , 272440639012851 , 274212028613632 , 275992620215093 , 277782449622624 , 279581552734375 , 281389965541376 , 283207724127657 , 285034864670368 , 286871423439899 , 288717436800000 , 290572941207901 , 292437973214432 , 294312569464143 , 296196766695424 , 298090601740625 , 299994111526176 , 301907333072707 , 303830303495168 , 305763060002949 , 307705639900000 , 309658080584951 , 311620419551232 , 313592694387193 , 315574942776224 , 317567202496875 , 319569511422976 , 321581907523757 , 323604428863968 , 325637113603999 , 327680000000000 , 329733126404001 , 331796531264032 , 333870253124243 , 335954330625024 , 338048802503125 , 340153707591776 , 342269084820807 , 344394973216768 , 346531411903049 , 348678440100000 , 350836097125051 , 353004422392832 , 355183455415293 , 357373235801824 , 359573803259375 , 361785197592576 , 364007458703857 , 366240626593568 , 368484741360099 , 370739843200000 , 373005972408101 , 375283169377632 , 377571474600343 , 379870928666624 , 382181572265625 , 384503446185376 , 386836591312907 , 389181048634368 , 391536859235149 , 393904064300000 , 396282705113151 , 398672823058432 , 401074459619393 , 403487656379424 , 405912455021875 , 408348897330176 , 410797025187957 , 413256880579168 , 415728505588199 , 418211942400000 , 420707233300201 , 423214420675232 , 425733547012443 , 428264654900224 , 430807787028125 , 433362986186976 , 435930295269007 , 438509757267968 , 441101415279249 , 443705312500000 , 446321492229251 , 448949997868032 , 451590872919493 , 454244160989024 , 456909905784375 , 459588151115776 , 462278940896057 , 464982319140768 , 467698329968299 , 470427017600000 , 473168426360301 , 475922600676832 , 478689585080543 , 481469424205824 , 484262162790625 , 487067845676576 , 489886517809107 , 492718224237568 , 495563010115349 , 498420920700000 , 501292001353351 , 504176297541632 , 507073854835593 , 509984718910624 , 512908935546875 , 515846550629376 , 518797610148157 , 521762160198368 , 524740246980399 , 527731916800000 , 530737216068401 , 533756191302432 , 536788889124643 , 539835356263424 , 542895639553125 , 545969785934176 , 549057842453207 , 552159856263168 , 555275874623449 , 558405944900000 , 561550114565451 , 564708431199232 , 567880942487693 , 571067696224224 , 574268740309375 , 577484122750976 , 580713891664257 , 583958095271968 , 587216781904499 , 590490000000000 , 593777798104501 , 597080224872032 , 600397329064743 , 603729159553024 , 607075765315625 , 610437195439776 , 613813499121307 , 617204725664768 , 620610924483549 , 624032145100000 , 627468437145551 , 630919850360832 , 634386434595793 , 637868239809824 , 641365316071875 , 644877713560576 , 648405482564357 , 651948673481568 , 655507336820599 , 659081523200000 , 662671283348601 , 666276668105632 , 669897728420843 , 673534515354624 , 677187080078125 , 680855473873376 , 684539748133407 , 688239954362368 , 691956144175649 , 695688369300000 , 699436681573651 , 703201132946432 , 706981775479893 , 710778661347424 , 714591842834375 , 718421372338176 , 722267302368457 , 726129685547168 , 730008574608699 , 733904022400000 , 737816081880701 , 741744806123232 , 745690248312943 , 749652461748224 , 753631499840625 , 757627416114976 , 761640264209507 , 765670097875968 , 769716970979749 , 773780937500000 , 777862051529751 , 781960367276032 , 786075939059993 , 790208821317024 , 794359068596875 , 798526735563776 , 802711876996557 , 806914547788768 , 811134802948799 , 815372697600000 , 819628286980801 , 823901626444832 , 828192771461043 , 832501777613824 , 836828700603125 , 841173596244576 , 845536520469607 , 849917529325568 , 854316678975849 , 858734025700000 , 863169625893851 , 867623536069632 , 872095812856093 , 876586512998624 , 881095693359375 , 885623410917376 , 890169722768657 , 894734686126368 , 899318358320899 , 903920796800000 , 908542059128901 , 913182202990432 , 917841286185143 , 922519366631424 , 927216502365625 , 931932751542176 , 936668172433707 , 941422823431168 , 946196763043949 , 950990049900000 , 955802742745951 , 960634900447232 , 965486581988193 , 970357846472224 , 975248753121875 , 980159361278976 , 985089730404757 , 990039920079968 , 995009990004999 , 1000000000000000 ] <NEWLINE> x = int ( input ( ) ) <NEWLINE> for i in range ( 1000 , 2001 ) : <NEWLINE> <INDENT> for j in range ( 2001 ) : <NEWLINE> <INDENT> if tmp [ i ] - tmp [ j ] == x : <NEWLINE> <INDENT> print ( i - 1000 , j - 1000 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max_d = min ( B - 1 , N ) <NEWLINE> max_r = max_d / B <NEWLINE> <NL> res = int ( max_r * A ) <NEWLINE> print ( res ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> ab_list = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> ab_list . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> ans_list = [ 0 for i in range ( M ) ] <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if i == M : <NEWLINE> <INDENT> ans_list [ i - 1 ] = N * ( N - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if uf . find ( ab_list [ i ] [ 0 ] ) != uf . find ( ab_list [ i ] [ 1 ] ) : <NEWLINE> <INDENT> ans_list [ i - 1 ] = ans_list [ i ] - uf . size ( ab_list [ i ] [ 0 ] ) * uf . size ( ab_list [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list [ i - 1 ] = ans_list [ i ] <NEWLINE> <DEDENT> uf . union ( ab_list [ i ] [ 0 ] , ab_list [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans_list ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> mod = 1000000000 + 7 <NEWLINE> <NL> sumJ = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> sumJ += A [ j ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sumJ -= A [ i ] <NEWLINE> sum += A [ i ] * sumJ <NEWLINE> sum = sum % mod <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . table = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def _root ( self , x ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> tbl = self . table <NEWLINE> while tbl [ x ] >= 0 : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> x = tbl [ x ] <NEWLINE> <DEDENT> for y in stack : <NEWLINE> <INDENT> tbl [ y ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def find ( self , x , y ) : <NEWLINE> <INDENT> return self . _root ( x ) == self . _root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> r1 = self . _root ( x ) <NEWLINE> r2 = self . _root ( y ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> d1 = self . table [ r1 ] <NEWLINE> d2 = self . table [ r2 ] <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> self . table [ r2 ] = r1 <NEWLINE> self . table [ r1 ] += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . table [ r1 ] = r2 <NEWLINE> self . table [ r2 ] += d1 <NEWLINE> <NL> <DEDENT> <DEDENT> def get_size ( self , x ) : <NEWLINE> <INDENT> return - self . table [ self . _root ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ppp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> uft = UnionFind ( n ) <NEWLINE> base = 0 <NEWLINE> undefined = [ ] <NEWLINE> for i , p in enumerate ( ppp ) : <NEWLINE> <INDENT> if p == - 1 : <NEWLINE> <INDENT> undefined . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> p -= 1 <NEWLINE> if not uft . find ( i , p ) : <NEWLINE> <INDENT> base += 1 <NEWLINE> uft . unite ( i , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( undefined ) == 0 : <NEWLINE> <INDENT> print ( base % MOD ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( undefined ) == 1 : <NEWLINE> <INDENT> c = uft . get_size ( undefined [ 0 ] ) <NEWLINE> others = n - c <NEWLINE> print ( ( base * ( n - 1 ) + others ) % MOD ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m = len ( undefined ) <NEWLINE> dp = np . zeros ( m + 1 , dtype = np . int64 ) <COMMENT> <NEWLINE> dp [ 0 ] = 1 <NEWLINE> additional = 0 <COMMENT> <NEWLINE> <NL> for i in undefined : <NEWLINE> <INDENT> c = uft . get_size ( i ) <NEWLINE> dp [ 1 : ] += dp [ : - 1 ] * c <NEWLINE> dp %= MOD <NEWLINE> additional += n - c <NEWLINE> <DEDENT> dp = dp . tolist ( ) <NEWLINE> <NL> duplicated = 0 <NEWLINE> pat = pow ( n - 1 , m , MOD ) <NEWLINE> inv = pow ( n - 1 , MOD - 2 , MOD ) <NEWLINE> loop_permutation = 1 <NEWLINE> loop_other_pattern = pat * inv * inv % MOD <NEWLINE> for loop_size in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> duplicated = ( duplicated + dp [ loop_size ] * loop_permutation * loop_other_pattern ) % MOD <NEWLINE> loop_other_pattern = loop_other_pattern * inv % MOD <NEWLINE> loop_permutation = loop_permutation * loop_size % MOD <NEWLINE> <NL> <DEDENT> ans = ( base * pat + additional * pat * inv - duplicated ) % MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> y = 120 <NEWLINE> a = { i ** 5 for i in range ( - y , y ) } <NEWLINE> ans_a = 0 <NEWLINE> ans_b = 0 <NEWLINE> for b in range ( - y , y ) : <NEWLINE> <INDENT> if X + b ** 5 in a : <NEWLINE> <COMMENT> <NL> <INDENT> if X + b ** 5 > 0 : <NEWLINE> <INDENT> ans_a = int ( ( X + b ** 5 ) ** 0.2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_a = - int ( abs ( X + b ** 5 ) ** 0.2 ) <NEWLINE> <DEDENT> ans_b = b <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans_a , ans_b ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> <NL> ori_num = 0 <NEWLINE> turn_num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> : <NEWLINE> <INDENT> ori_num += 1 <NEWLINE> <DEDENT> if S [ i - 1 ] != S [ i ] : <NEWLINE> <INDENT> turn_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i < N - 1 : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ori_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if turn_num >= 2 * K : <NEWLINE> <INDENT> ori_num += 2 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = turn_num // 2 <NEWLINE> num2 = turn_num % 2 <NEWLINE> ori_num += 2 * num + num2 <NEWLINE> <NL> <DEDENT> print ( ori_num ) <NEWLINE>
from collections import deque <NEWLINE> <NL> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ <STRING> ] * h <NEWLINE> <NL> sx , sy = - 1 , - 1 <NEWLINE> pos = - 1 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> g [ i ] = input ( ) <NEWLINE> if pos == - 1 : <NEWLINE> <INDENT> pos = g [ i ] . find ( <STRING> ) <NEWLINE> if pos != - 1 : <NEWLINE> <INDENT> sx = i <NEWLINE> sy = pos <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> book = set ( ) <NEWLINE> queue = deque ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> Next = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> <NL> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> book . clear ( ) <NEWLINE> queue . clear ( ) <NEWLINE> queue . append ( ( sx , sy , 0 ) ) <NEWLINE> aim = str ( a ) <NEWLINE> <NL> while len ( queue ) : <NEWLINE> <INDENT> t = queue . popleft ( ) <NEWLINE> if ( t [ 0 ] , t [ 1 ] ) in book : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if g [ t [ 0 ] ] [ t [ 1 ] ] == aim : <NEWLINE> <INDENT> ans += t [ 2 ] <NEWLINE> <COMMENT> <NL> sx , sy = t [ 0 ] , t [ 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> book . add ( ( t [ 0 ] , t [ 1 ] ) ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> tx = t [ 0 ] + Next [ i ] [ 0 ] <NEWLINE> ty = t [ 1 ] + Next [ i ] [ 1 ] <NEWLINE> if 0 <= tx < h and 0 <= ty < w and g [ tx ] [ ty ] != <STRING> : <NEWLINE> <INDENT> queue . append ( ( tx , ty , t [ 2 ] + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
<NL> <NL> global N , K <NEWLINE> global ws <NEWLINE> <NL> def check ( max_p ) : <NEWLINE> <INDENT> track = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( ws [ i ] > max_p ) : return False <NEWLINE> if ( now + ws [ i ] > max_p ) : <NEWLINE> <INDENT> track += 1 <NEWLINE> now = ws [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += ws [ i ] <NEWLINE> <DEDENT> <DEDENT> if now > 0 : <NEWLINE> <INDENT> track += 1 <NEWLINE> <DEDENT> if ( track > K ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> now = 0 <NEWLINE> ws = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w = int ( input ( ) ) <NEWLINE> ws . append ( w ) <NEWLINE> <NL> <DEDENT> amin = 0 <NEWLINE> amax = int ( 1E30 ) <NEWLINE> <NL> while amin + 1 != amax : <NEWLINE> <INDENT> amid = ( amin + amax ) // 2 <NEWLINE> if ( check ( amid ) ) : <NEWLINE> <INDENT> amax = amid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amin = amid <NEWLINE> <DEDENT> <DEDENT> print ( amax ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque <NEWLINE> <NL> n , k = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> a = [ 0 ] + [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> m = 0 <NEWLINE> b = [ 1 ] <NEWLINE> visited = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> <NL> c = 1 <NEWLINE> visited [ 1 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = a [ c ] <NEWLINE> if visited [ c ] != 1 : <NEWLINE> <INDENT> b . append ( c ) <NEWLINE> visited [ c ] = 1 <NEWLINE> if i == k - 1 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> idx = b . index ( c ) <NEWLINE> bn = len ( b [ idx : ] ) <NEWLINE> sn = len ( b [ : idx ] ) <NEWLINE> <NL> <COMMENT> <NL> kk = ( k - sn ) % bn <NEWLINE> print ( b [ idx + kk ] ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> with open ( 0 ) as f : <NEWLINE> <INDENT> N , H = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> ab = list ( map ( int , f . read ( ) . split ( ) ) ) <NEWLINE> <DEDENT> max_slash = max ( ab [ 0 : : 2 ] ) <NEWLINE> throw = sorted ( [ x for x in ab [ 1 : : 2 ] if x > max_slash ] , reverse = True ) <NEWLINE> cnt = 0 <NEWLINE> for t in throw : <NEWLINE> <INDENT> if H <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> H += - t <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if H > 0 : <NEWLINE> <INDENT> cnt += ( H + max_slash - 1 ) // max_slash <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def exhaustive ( lst , size ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for i in range ( 0 , 1 << size ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for j in range ( 0 , size ) : <NEWLINE> <INDENT> if ( i & 0x01 ) == 1 : <NEWLINE> <INDENT> total += lst [ j ] <NEWLINE> <DEDENT> i = i >> 1 <NEWLINE> <DEDENT> result . append ( total ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lst = [ val . split ( ) for val in sys . stdin . read ( ) . splitlines ( ) ] <NEWLINE> n , data , m , targets = [ [ int ( n ) for n in inner_lst ] for inner_lst in lst ] <NEWLINE> result = exhaustive ( data , int ( n [ 0 ] ) ) <NEWLINE> print ( <STRING> . join ( [ <STRING> if x in result else <STRING> for x in targets ] ) ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> setA = set ( i for i in range ( a , min ( a + k , b + 1 ) ) ) <NEWLINE> setB = set ( j for j in range ( b , max ( b - k , a - 1 ) , - 1 ) ) <NEWLINE> l = list ( setA | setB ) <NEWLINE> l . sort ( ) <NEWLINE> for m in l : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> A = sorted ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> if A [ 0 ] == A [ - 1 ] : <NEWLINE> <INDENT> x = A [ 0 ] <NEWLINE> return x == N - 1 or 2 * x <= N <NEWLINE> <DEDENT> if A [ 0 ] + 1 != A [ - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> a , b = A [ 0 ] , A [ - 1 ] <NEWLINE> full = b <NEWLINE> unique = A . count ( a ) <NEWLINE> people , color = N - unique , A [ - 1 ] - unique <NEWLINE> return color > 0 and 2 * color <= people <NEWLINE> <NL> <DEDENT> print ( <STRING> if main ( A ) else <STRING> ) <NEWLINE>
def lcs ( X , Y ) : <NEWLINE> <INDENT> costs = [ 0 ] <NEWLINE> for c in Y : <NEWLINE> <INDENT> for i in range ( len ( costs ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = X . find ( c , costs [ i ] ) <NEWLINE> if tmp + 1 : <NEWLINE> <INDENT> if i + 1 < len ( costs ) : <NEWLINE> <INDENT> costs [ i + 1 ] = min ( costs [ i + 1 ] , tmp + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> costs . append ( tmp + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return len ( costs ) - 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> X , Y = ( input ( ) for _ in range ( 2 ) ) <NEWLINE> print ( lcs ( X , Y ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if not ( 1 <= N <= 10 ** 18 and 0 <= A and 0 <= B and 0 < A + B <= 10 ** 18 ) : sys . exit ( ) <NEWLINE> if not ( isinstance ( N , int ) and isinstance ( A , int ) and isinstance ( B , int ) ) : sys . exit ( ) <NEWLINE> <NL> count = N // ( A + B ) <NEWLINE> remind = N % ( A + B ) if N % ( A + B ) <= A else A <NEWLINE> <NL> print ( count * A + remind ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> l = [ 1 if s [ i ] == <STRING> else 0 for i in range ( n ) ] <NEWLINE> l = list ( accumulate ( l ) ) <NEWLINE> ans = l [ - 1 ] - l [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = min ( ans , i - l [ i - 1 ] + l [ - 1 ] - l [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = str ( input ( ) ) <NEWLINE> <NL> running_sum = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if i != <STRING> and i != <STRING> : <NEWLINE> <INDENT> running_sum += int ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if running_sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a , b , c , d = [ ] , [ ] , [ ] , [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> inpu = input ( ) <NEWLINE> a . append ( ( int ) ( inpu . split ( <STRING> ) [ 0 ] ) ) <NEWLINE> b . append ( ( int ) ( inpu . split ( <STRING> ) [ 1 ] ) ) <NEWLINE> c . append ( ( int ) ( inpu . split ( <STRING> ) [ 2 ] ) ) <NEWLINE> d . append ( ( int ) ( inpu . split ( <STRING> ) [ 3 ] ) ) <NEWLINE> <NL> <DEDENT> balls = list ( itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <COMMENT> <NL> max = 0 <NEWLINE> for i in range ( len ( balls ) ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if balls [ i ] [ b [ j ] - 1 ] - balls [ i ] [ a [ j ] - 1 ] == c [ j ] : <NEWLINE> <INDENT> temp += d [ j ] <NEWLINE> <DEDENT> <DEDENT> if temp > max : <NEWLINE> <INDENT> max = temp <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ 0 for i in range ( N ) ] <NEWLINE> j = 0 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list . sort ( A ) <NEWLINE> T = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] != T and i != N - 2 : <NEWLINE> <INDENT> B [ T - 1 ] = i - j <NEWLINE> T = A [ i ] <NEWLINE> j = i <NEWLINE> <DEDENT> elif i == N - 2 : <NEWLINE> <INDENT> if A [ i ] == T : <NEWLINE> <INDENT> B [ T - 1 ] = i - j + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ T - 1 ] = i - j <NEWLINE> B [ A [ i ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = sorted ( [ int ( n ) for n in input ( ) . split ( ) ] ) <NEWLINE> <COMMENT> <NL> <NL> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> b = L [ : i ] <NEWLINE> c = L [ i + 1 : ] <NEWLINE> for j in b : <NEWLINE> <INDENT> count += bisect . bisect_left ( c , L [ i ] + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> a , b = 0 , 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( t ) - t [ a - 1 ] + b ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> s = input ( ) . split ( ) <NEWLINE> n = int ( s [ 0 ] ) <NEWLINE> m = int ( s [ 1 ] ) <NEWLINE> graph = defaultdict ( set ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = input ( ) . split ( <STRING> ) <NEWLINE> graph [ int ( s [ 0 ] ) ] . add ( int ( s [ 1 ] ) ) <NEWLINE> graph [ int ( s [ 1 ] ) ] . add ( int ( s [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> visited = [ False ] * ( n + 1 ) <NEWLINE> <NL> def bfs ( node ) : <NEWLINE> <INDENT> queue = [ node ] <NEWLINE> ans = 0 <NEWLINE> visited [ node ] = True <NEWLINE> while queue : <NEWLINE> <INDENT> root = queue . pop ( ) <NEWLINE> ans += 1 <NEWLINE> <NL> for child in graph [ root ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> queue . append ( child ) <NEWLINE> visited [ child ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> ans = max ( ans , bfs ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> def isOK ( x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for _a in a : <NEWLINE> <INDENT> if _a <= x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> cnt += _a // x <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if cnt > k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> ng = 0 <NEWLINE> ok = 10 ** 9 + 1 <NEWLINE> <NL> while abs ( ng - ok ) > 0.1 : <NEWLINE> <INDENT> mid = ( ng + ok ) / 2 <NEWLINE> if isOK ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> if ok < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ok = ceil ( ok ) <NEWLINE> if isOK ( ok - 1 ) : <NEWLINE> <INDENT> print ( ok - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ok ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> G = np . zeros ( ( R + 1 , C + 1 ) , np . int64 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> [ r , c , v ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ r - 1 ] [ c - 1 ] = v <NEWLINE> <NL> <DEDENT> @ jit <NEWLINE> def main ( G , R , C ) : <NEWLINE> <INDENT> dp = np . full ( ( R + 1 , C + 1 , 4 ) , - 1 ) <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> if G [ 0 ] [ 0 ] != None : dp [ 0 ] [ 0 ] [ 1 ] = G [ 0 ] [ 0 ] <NEWLINE> for r in range ( R ) : <NEWLINE> <INDENT> for c in range ( C ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> if dp [ r ] [ c ] [ k ] == - 1 : continue <NEWLINE> if k < 3 : <COMMENT> <NEWLINE> <INDENT> if dp [ r ] [ c + 1 ] [ k + 1 ] < dp [ r ] [ c ] [ k ] + G [ r ] [ c + 1 ] : <NEWLINE> <INDENT> dp [ r ] [ c + 1 ] [ k + 1 ] = dp [ r ] [ c ] [ k ] + G [ r ] [ c + 1 ] <NEWLINE> <DEDENT> <DEDENT> if dp [ r ] [ c + 1 ] [ k ] < dp [ r ] [ c ] [ k ] : <NEWLINE> <INDENT> dp [ r ] [ c + 1 ] [ k ] = dp [ r ] [ c ] [ k ] <NEWLINE> <DEDENT> if dp [ r + 1 ] [ c ] [ 0 ] < dp [ r ] [ c ] [ k ] : <NEWLINE> <INDENT> dp [ r + 1 ] [ c ] [ 0 ] = dp [ r ] [ c ] [ k ] <NEWLINE> <DEDENT> if dp [ r + 1 ] [ c ] [ 1 ] < dp [ r ] [ c ] [ k ] + G [ r + 1 ] [ c ] : <NEWLINE> <INDENT> dp [ r + 1 ] [ c ] [ 1 ] = dp [ r ] [ c ] [ k ] + G [ r + 1 ] [ c ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ( max ( dp [ r ] [ c ] ) ) <NEWLINE> <NL> <DEDENT> ret = main ( G , R , C ) <NEWLINE> print ( ret ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = - 1 <NEWLINE> i = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a = ( x * i ) % y <NEWLINE> if a != 0 : <NEWLINE> <INDENT> ans = x * i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n | m | q ) == 0 : break <NEWLINE> <NL> p = [ ] <NEWLINE> res = [ { _ for _ in range ( n ) } for _ in range ( m ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , b = [ [ int ( c ) for c in s ] for s in input ( ) . split ( ) ] <NEWLINE> if i > 0 : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> s [ j ] ^= p [ j ] <NEWLINE> <DEDENT> <DEDENT> zero = { i for i in range ( n ) if s [ i ] == 0 } <NEWLINE> one = { i for i in range ( n ) if s [ i ] == 1 } <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if ( b [ j ] == 0 ) : res [ j ] -= one <NEWLINE> if ( b [ j ] == 1 ) : res [ j ] -= zero <NEWLINE> <DEDENT> p = s <NEWLINE> <NL> <DEDENT> table = <STRING> . join ( [ str ( i ) for i in range ( 10 ) ] + [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if len ( res [ i ] ) == 1 : <NEWLINE> <INDENT> print ( table [ res [ i ] . pop ( ) ] , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
num_town , num_move = map ( int , input ( ) . split ( ) ) <NEWLINE> teleports = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> current = 0 <NEWLINE> memo = { } <NEWLINE> for i in range ( num_move ) : <NEWLINE> <INDENT> if memo . get ( current ) == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if not memo . get ( current ) : <NEWLINE> <INDENT> memo [ current ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ current ] += 1 <NEWLINE> <DEDENT> destination = teleports [ current ] <NEWLINE> current = destination <NEWLINE> <NL> <DEDENT> loop = { k : v for k , v in memo . items ( ) if v == 2 } <NEWLINE> minus = { k : v for k , v in memo . items ( ) if v == 1 } <NEWLINE> <NL> new_move_count = 0 <NEWLINE> if len ( loop ) == 0 : <NEWLINE> <INDENT> current = 0 <NEWLINE> new_move_count = num_move <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_move_count = ( num_move - len ( minus ) ) % len ( loop ) <NEWLINE> <NL> <DEDENT> for i in range ( new_move_count ) : <NEWLINE> <INDENT> destination = teleports [ current ] <NEWLINE> current = destination <NEWLINE> <NL> <DEDENT> print ( current + 1 ) <NEWLINE>
x , op , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> while op != <STRING> : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( x + y ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( x - y ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( x * y ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( x // y ) <NEWLINE> <DEDENT> x , op , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def main ( N , M , C ) : <NEWLINE> <INDENT> lst = [ n for n in range ( N ) ] <COMMENT> <NEWLINE> <NL> def get_root ( x ) : <COMMENT> <NEWLINE> <INDENT> if lst [ x ] == x : <COMMENT> <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> lst [ x ] = get_root ( lst [ x ] ) <COMMENT> <NEWLINE> return lst [ x ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <COMMENT> <NEWLINE> <INDENT> root_x = get_root ( x ) <NEWLINE> root_y = get_root ( y ) <NEWLINE> if root_x != root_y : <COMMENT> <NEWLINE> <INDENT> lst [ root_x ] = root_y <NEWLINE> <NL> <DEDENT> <DEDENT> { unite ( * c ) for c in C } <COMMENT> <NEWLINE> <NL> print ( max ( Counter ( map ( get_root , lst ) ) . values ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> C . add ( tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) ) <COMMENT> <NEWLINE> <DEDENT> main ( N , M , C ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> mins = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> mins . append ( min ( a [ i ] , mins [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> mx = - 10 ** 12 <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> mx = max ( mx , a [ j ] - mins [ j - 1 ] ) <NEWLINE> <DEDENT> print ( mx ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> p_list = [ ] <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> p_list . append ( S ) <NEWLINE> N -= 1 <NEWLINE> <NL> <DEDENT> p_set = ( set ( p_list ) ) <NEWLINE> print ( len ( p_set ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> A = 100 <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> A = int ( A * 1.01 ) <NEWLINE> if A >= X : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT>
def mws5 ( lookup , hs ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( hs ) ) : <NEWLINE> <INDENT> h = hs [ i ] <NEWLINE> ans += lookup [ i + h ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import defaultdict as DD <NEWLINE> lookup = DD ( int ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> hs = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> for i , h in enumerate ( hs ) : <NEWLINE> <INDENT> lookup [ i - h ] += 1 <NEWLINE> <DEDENT> mws5 ( lookup , hs ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> C = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> vec = [ i for i , a in enumerate ( A , 1 ) for _ in range ( a ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> color = vec [ i * W + j ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> C [ i ] [ j ] = color <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ i ] [ W - j - 1 ] = color <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for row in C : <NEWLINE> <INDENT> print ( * row ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> data = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> s = <STRING> <NEWLINE> for x in data : <NEWLINE> <INDENT> s += ( str ( x ) + <STRING> ) <NEWLINE> <DEDENT> print ( s [ 0 : len ( s ) - 1 ] ) <NEWLINE>
x = input ( ) <NEWLINE> split_x = x . split ( ) <NEWLINE> split_x_int = [ int ( i ) for i in split_x ] <NEWLINE> split_x_int . sort ( ) <NEWLINE> a = split_x_int [ 0 ] <NEWLINE> b = split_x_int [ 1 ] <NEWLINE> c = split_x_int [ 2 ] <NEWLINE> <NL> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> x = [ 0 ] * ( a + 1 ) <NEWLINE> for xi in range ( 1 , 101 ) : <NEWLINE> <INDENT> for yi in range ( 1 , 101 ) : <NEWLINE> <INDENT> for zi in range ( 1 , 101 ) : <NEWLINE> <INDENT> result = xi ** 2 + yi ** 2 + zi ** 2 + xi * yi + yi * zi + zi * xi <NEWLINE> if result <= a : <NEWLINE> <INDENT> x [ result ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from decimal import Decimal , ROUND_HALF_UP <NEWLINE> def lcm ( a ) : <NEWLINE> <INDENT> x = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> x = ( x * a [ i ] ) // math . gcd ( x , a [ i ] ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> def gcd ( a ) : <NEWLINE> <INDENT> temp = math . gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for i in a : <NEWLINE> <INDENT> temp = math . gcd ( temp , i ) <NEWLINE> <DEDENT> return temp <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> zero = False <NEWLINE> count = 0 <NEWLINE> <COMMENT> <NL> mini = lcm ( a ) <NEWLINE> if len ( a ) != 1 : <NEWLINE> <INDENT> maxi = gcd ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxi = a [ 0 ] <NEWLINE> <DEDENT> maxi2 = maxi <NEWLINE> nibai = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if maxi2 % 2 == 0 : <NEWLINE> <INDENT> nibai *= 2 <NEWLINE> maxi2 //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if i % ( 2 * nibai ) == 0 : <NEWLINE> <INDENT> zero = True <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if not zero : <NEWLINE> <INDENT> t = Decimal ( str ( ( m * 2 // mini ) / 2 ) ) <NEWLINE> <COMMENT> <NL> print ( t . quantize ( Decimal ( <STRING> ) , rounding = ROUND_HALF_UP ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> inf = 1 << 30 <NEWLINE> w = 100 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> e = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> if e == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> ans = inf <NEWLINE> <NL> z0 = int ( e ** ( 1 / 3 ) ) <NEWLINE> <NL> for z in range ( max ( 0 , z0 - w ) , z0 + w ) : <NEWLINE> <INDENT> if e - z ** 3 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> y0 = int ( ( e - z ** 3 ) ** 0.5 ) <NEWLINE> for y in range ( max ( 0 , y0 - w ) , y0 + w ) : <NEWLINE> <INDENT> x = e - z ** 3 - y ** 2 <NEWLINE> <NL> if x < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ans = min ( ans , x + y + z ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> from scipy . special import comb <NEWLINE> <NL> s = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = Counter ( A ) <NEWLINE> <NL> sum_c = 0 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> if v >= 2 : <NEWLINE> <INDENT> sum_c += comb ( v , 2 , exact = True ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> x = sum_c - comb ( d [ a ] , 2 , exact = True ) + comb ( d [ a ] - 1 , 2 , exact = True ) <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> arr = np . arange ( n + 1 ) <NEWLINE> a = np . cumsum ( arr ) <NEWLINE> b = np . cumsum ( arr [ : : - 1 ] ) <NEWLINE> <NL> for i in range ( k , n + 1 + 1 ) : <NEWLINE> <INDENT> ans += b [ i - 1 ] - a [ i - 1 ] + 1 <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 5010 ) <NEWLINE> <NL> def solve ( s ) : <NEWLINE> <INDENT> if len ( s ) == 3 : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> and s [ 1 ] == <STRING> and s [ 2 ] == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> i = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> lis = [ ] <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> if i + 2 < len ( s ) and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> lis . append ( <STRING> ) <NEWLINE> i += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( s [ i ] ) <NEWLINE> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if not ( a + b + c == 2 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> if lis [ i ] == <STRING> : <NEWLINE> <INDENT> lis [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> if lis [ i ] == <STRING> : <NEWLINE> <INDENT> lis [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> if lis [ i ] == <STRING> : <NEWLINE> <INDENT> lis [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( s ) == len ( lis ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return solve ( lis ) <NEWLINE> <NL> <NL> <DEDENT> if solve ( input ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> s += int ( N [ i ] ) <NEWLINE> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or str ( i ) . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> temp = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> temp += lst [ i ] <NEWLINE> <DEDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> total += lst [ j ] * temp <NEWLINE> temp -= lst [ j + 1 ] <NEWLINE> <DEDENT> print ( total % ( 10 ** 9 + 7 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return sum ( ( a + x - 1 ) // x - 1 for a in A ) <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> r = 10 ** 9 + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if f ( mid ) <= K : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> num = 7 % k <NEWLINE> ans = 1 <NEWLINE> <NL> while num != 0 : <NEWLINE> <NL> <INDENT> num = ( num * 10 + 7 ) % k <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> wa = 0 <NEWLINE> wa_list = [ ] <NEWLINE> for i in range ( N ) [ : : - 1 ] : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> wa += A [ i ] <NEWLINE> wa_list . append ( wa ) <NEWLINE> <NL> <DEDENT> wa_list . reverse ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> seki = A [ i ] * wa_list [ i ] <NEWLINE> ans += seki <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( set ( a ) ) <NEWLINE> m = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if m [ l [ i ] ] < l [ i ] : <NEWLINE> <INDENT> ans += m [ l [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += m [ l [ i ] ] - l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> a = deque ( A ) <NEWLINE> <NL> arrival = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> while arrival < N : <NEWLINE> <INDENT> score = a . popleft ( ) <NEWLINE> if arrival == 1 : <NEWLINE> <INDENT> ans += score <NEWLINE> arrival += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += score * min ( 2 , N - arrival ) <NEWLINE> arrival += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ i ] = int ( s [ i ] ) <NEWLINE> <DEDENT> p = [ ] <NEWLINE> p . append ( s [ len ( s ) - 1 ] ) <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> p . append ( ( p [ i - 1 ] + s [ len ( s ) - i - 1 ] * pow ( 10 , i , 2019 ) ) % 2019 ) <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> u = 0 <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> u = u + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> r = 1 <NEWLINE> q = [ ] <NEWLINE> for i in range ( len ( p ) - 1 ) : <NEWLINE> <INDENT> if p [ i ] == p [ i + 1 ] : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if r > 1 : <NEWLINE> <INDENT> q . append ( r ) <NEWLINE> r = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q . append ( r ) <NEWLINE> w = 0 <NEWLINE> for i in range ( len ( q ) ) : <NEWLINE> <INDENT> w = w + int ( q [ i ] * ( q [ i ] - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( w + u ) <NEWLINE>
import sys <NEWLINE> <NL> line_num = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> maxv = - 2000000000 <NEWLINE> minv = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> for i in range ( 1 , line_num ) : <NEWLINE> <INDENT> rt = int ( sys . stdin . readline ( ) ) <NEWLINE> if rt - minv > maxv : <NEWLINE> <INDENT> maxv = rt - minv <NEWLINE> <DEDENT> if rt < minv : <NEWLINE> <INDENT> minv = rt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> ct = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - ct ) <NEWLINE>
res = [ <STRING> ] <NEWLINE> for mak in range ( 12 ) : <NEWLINE> <INDENT> tem = [ <STRING> for temp in range ( 10 ) ] <NEWLINE> res . append ( tem ) <NEWLINE> <NL> <DEDENT> for mak in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a , b , c , d = [ int ( temp ) for temp in input ( ) . split ( ) ] <NEWLINE> res [ ( ( a - 1 ) * 3 ) + b ] [ c - 1 ] = str ( int ( res [ ( ( a - 1 ) * 3 ) + b ] [ c - 1 ] ) + d ) <NEWLINE> <NL> <DEDENT> for mak in range ( 1 , 13 ) : <NEWLINE> <INDENT> if mak != 1 and mak % 3 == 1 : <NEWLINE> <INDENT> print ( ( <STRING> * 20 ) ) <NEWLINE> <DEDENT> print ( <STRING> , <STRING> . join ( res [ mak ] ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> all_num = pow ( k , n , mod ) <NEWLINE> <COMMENT> <NL> <NL> <NL> ans = 0 <NEWLINE> <NL> dp = [ 0 ] * ( k + 1 ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> tmp = k - i <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> kazu = 1 <NEWLINE> kakeru = 2 <NEWLINE> heru = 0 <NEWLINE> <NL> if tmp == 1 : <NEWLINE> <INDENT> ans += all_num <NEWLINE> ans %= mod <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( k // tmp - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> heru += dp [ tmp * kakeru ] <NEWLINE> kazu += 1 <NEWLINE> kakeru += 1 <NEWLINE> <DEDENT> <STRING> <NEWLINE> <NL> kazu = pow ( kazu , n , mod ) - heru <NEWLINE> <COMMENT> <NL> ans += tmp * ( kazu ) <NEWLINE> all_num -= ( kazu ) <NEWLINE> <COMMENT> <NL> dp [ tmp ] = kazu <NEWLINE> ans %= mod <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = str ( input ( ) ) <NEWLINE> <NL> red = m . count ( <STRING> ) <NEWLINE> <NL> con = 0 ; <NEWLINE> <NL> for i in range ( red ) : <NEWLINE> <INDENT> if m [ i ] == <STRING> : <NEWLINE> <INDENT> con += 1 <NEWLINE> <DEDENT> <DEDENT> print ( con ) ; <NEWLINE>
from sys import stdin <NEWLINE> n = int ( input ( ) ) <NEWLINE> r = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> rv = r [ : : - 1 ] [ : - 1 ] <NEWLINE> m = None <NEWLINE> p_r_j = None <NEWLINE> for j , r_j in enumerate ( rv ) : <NEWLINE> <INDENT> if p_r_j == None or p_r_j < r_j : <NEWLINE> <INDENT> p_r_j = r_j <NEWLINE> <DEDENT> if p_r_j > r_j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> r_i = min ( r [ : - ( j + 1 ) ] ) <NEWLINE> t = r_j - r_i <NEWLINE> if m == None or t > m : <NEWLINE> <INDENT> m = t <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . r = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . r [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . r [ x ] = self . root ( self . r [ x ] ) <NEWLINE> return self . r [ x ] <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . r [ x ] < self . r [ y ] : <NEWLINE> <INDENT> temp = x <NEWLINE> x = y <NEWLINE> y = temp <NEWLINE> <DEDENT> self . r [ x ] += self . r [ y ] <NEWLINE> self . r [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . r [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> UF = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> UF . unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in UF . r : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( temp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
day = input ( ) <NEWLINE> resMax = 0 <NEWLINE> resTemp = 0 <NEWLINE> for i in range ( len ( day ) ) : <NEWLINE> <INDENT> if day [ i ] == <STRING> : <NEWLINE> <INDENT> resTemp = 0 <NEWLINE> <DEDENT> elif day [ i ] == <STRING> : <NEWLINE> <INDENT> resTemp = 0 <NEWLINE> while ( i < len ( day ) ) and ( day [ i ] != <STRING> ) : <NEWLINE> <INDENT> resTemp += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if resTemp > resMax : <NEWLINE> <INDENT> resMax = resTemp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( resMax ) <NEWLINE>
c = [ 10 , 50 , 100 , 500 ] <NEWLINE> flag = False <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = [ 0 ] * 4 <NEWLINE> n = sum ( x [ 0 ] * x [ 1 ] for x in zip ( m , c ) ) - n <NEWLINE> for i in range ( 4 ) [ : : - 1 ] : <NEWLINE> <INDENT> r [ i ] = n // c [ i ] <NEWLINE> n -= r [ i ] * c [ i ] <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if m [ i ] > r [ i ] : <NEWLINE> <INDENT> print ( <STRING> . format ( c [ i ] , m [ i ] - r [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <COMMENT> <NEWLINE> for i in range ( N ) : <COMMENT> <NEWLINE> <INDENT> j = N - 1 <NEWLINE> while j > i : <NEWLINE> <INDENT> if nums [ j - 1 ] > nums [ j ] : <NEWLINE> <INDENT> temp = nums [ j - 1 ] <NEWLINE> nums [ j - 1 ] = nums [ j ] <NEWLINE> nums [ j ] = temp <NEWLINE> count = count + 1 <COMMENT> <NEWLINE> <DEDENT> j = j - 1 <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , nums ) ) ) <NEWLINE> print ( count ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> count += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = sorted ( input ( ) ) <NEWLINE> A . append ( str ( s ) ) <NEWLINE> <DEDENT> B = collections . Counter ( A ) <NEWLINE> print ( sum ( i * ( i - 1 ) // 2 for i in B . values ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> sum = 0 <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> sum += r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> wi = ( n - i + 1 ) // 2 <NEWLINE> for w in range ( 1 , wi ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + w ] or s [ i + w ] == s [ i + 2 * w ] or s [ i ] == s [ i + 2 * w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if B == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tb = B - 1 <NEWLINE> tp_pre = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> tp = ( A * tb ) // B - A * ( tb // B ) <NEWLINE> if tp > tp_pre : <NEWLINE> <INDENT> tp_pre = tp <NEWLINE> <DEDENT> tb += B <NEWLINE> if tb > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( B > N ) : <NEWLINE> <INDENT> print ( ( A * N ) // B - A * ( N // B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( tp_pre ) ) <NEWLINE> <DEDENT> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> S . sort ( ) <NEWLINE> <NL> sum_ = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> sum_ += s <NEWLINE> <NL> <DEDENT> print ( sum_ ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> AB_dict = defaultdict ( list ) <NEWLINE> dist_list = [ - 1 ] * N <NEWLINE> dist_list [ 0 ] = 0 <NEWLINE> pre_list = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> AB_dict [ a ] . append ( b ) <NEWLINE> AB_dict [ b ] . append ( a ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> pre_list . append ( b ) <NEWLINE> dist_list [ b ] = 0 <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> pre_list . append ( a ) <NEWLINE> dist_list [ a ] = 0 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> <COMMENT> <NL> for p in pre_list : <NEWLINE> <COMMENT> <NL> <INDENT> for node in AB_dict [ p ] : <NEWLINE> <COMMENT> <NL> <INDENT> if dist_list [ node ] == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> dist_list [ node ] = p <NEWLINE> tmp . append ( node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if tmp == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pre_list = tmp <NEWLINE> <NL> <DEDENT> if - 1 in dist_list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for dist in dist_list [ 1 : ] : <NEWLINE> <INDENT> print ( dist + 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> def prime_decomposition ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> table . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> table . append ( n ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> num1 = prime_decomposition ( N ) <NEWLINE> num2 = collections . Counter ( num1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for j in set ( num1 ) : <NEWLINE> <INDENT> number = 0 <NEWLINE> for k in range ( 50 ) : <NEWLINE> <INDENT> number += k <NEWLINE> if number > num2 [ j ] : <NEWLINE> <INDENT> ans += ( k - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = v [ 0 : : 2 ] <NEWLINE> b = v [ 1 : : 2 ] <NEWLINE> <NL> aa = Counter ( a ) <NEWLINE> bb = Counter ( b ) <NEWLINE> <NL> aaa = aa . most_common ( ) <NEWLINE> bbb = bb . most_common ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if aaa [ 0 ] [ 0 ] != bbb [ 0 ] [ 0 ] : <NEWLINE> <INDENT> ans = n - aaa [ 0 ] [ 1 ] - bbb [ 0 ] [ 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if len ( aa ) == len ( bb ) == 1 : <NEWLINE> <INDENT> ans = min ( aaa [ 0 ] [ 1 ] , bbb [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aaa . append ( ( <STRING> , 0 ) ) <NEWLINE> bbb . append ( ( <STRING> , 0 ) ) <NEWLINE> ans = n - max ( aaa [ 0 ] [ 1 ] + bbb [ 1 ] [ 1 ] , aaa [ 1 ] [ 1 ] + bbb [ 0 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> S = input ( ) <NEWLINE> MOD = 2019 <NEWLINE> mods = [ 0 ] <NEWLINE> r = 0 <NEWLINE> for i , c in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> r += int ( c ) * pow ( 10 , i , MOD ) <NEWLINE> mods . append ( r % MOD ) <NEWLINE> <NL> <DEDENT> counter = Counter ( mods ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for v in counter . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def print_node ( i , node ) : <NEWLINE> <INDENT> parent = - 1 if node [ 1 ] == None else node [ 1 ] <NEWLINE> degree = len ( [ x for x in node [ 0 ] if x != - 1 ] ) <NEWLINE> sibling = - 1 if node [ 2 ] == None else node [ 2 ] <NEWLINE> depth = node [ 3 ] <NEWLINE> height = node [ 4 ] <NEWLINE> t = <STRING> if parent == - 1 else <STRING> if height == 0 else <STRING> <NEWLINE> ans = <STRING> . format ( i , parent , sibling , degree , depth , height , t ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> root = set ( [ x for x in range ( n ) ] ) <NEWLINE> T = [ None ] * n <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> i , l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> T [ i ] = [ [ l , r ] , None , None , None , None ] <NEWLINE> root -= set ( [ l , r ] ) <NEWLINE> <NL> <DEDENT> def set_info ( i , depth ) : <NEWLINE> <INDENT> node = T [ i ] <NEWLINE> node [ 3 ] = depth <NEWLINE> l = None <NEWLINE> r = None <NEWLINE> if node [ 0 ] [ 0 ] != - 1 : <NEWLINE> <INDENT> l = T [ node [ 0 ] [ 0 ] ] <NEWLINE> l [ 1 ] = i <NEWLINE> set_info ( node [ 0 ] [ 0 ] , depth + 1 ) <NEWLINE> <DEDENT> if node [ 0 ] [ 1 ] != - 1 : <NEWLINE> <INDENT> r = T [ node [ 0 ] [ 1 ] ] <NEWLINE> r [ 1 ] = i <NEWLINE> set_info ( node [ 0 ] [ 1 ] , depth + 1 ) <NEWLINE> <DEDENT> if l != None and r != None : <NEWLINE> <INDENT> l [ 2 ] = node [ 0 ] [ 1 ] <NEWLINE> r [ 2 ] = node [ 0 ] [ 0 ] <NEWLINE> <NL> <DEDENT> node [ 4 ] = height ( i ) <NEWLINE> <NL> <DEDENT> def height ( i ) : <NEWLINE> <INDENT> node = T [ i ] <NEWLINE> l = node [ 0 ] [ 0 ] <NEWLINE> r = node [ 0 ] [ 1 ] <NEWLINE> lh = None <NEWLINE> rh = None <NEWLINE> h = None <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> lh = height ( l ) <NEWLINE> <DEDENT> if r != - 1 : <NEWLINE> <INDENT> rh = height ( r ) <NEWLINE> <DEDENT> if lh != None and rh != None : <NEWLINE> <INDENT> h = max ( lh , rh ) <NEWLINE> <DEDENT> elif lh != None : <NEWLINE> <INDENT> h = lh <NEWLINE> <DEDENT> elif rh != None : <NEWLINE> <INDENT> h = rh <NEWLINE> <DEDENT> if h == None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 + h <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> r = root . pop ( ) <NEWLINE> T [ r ] [ 1 ] = - 1 <NEWLINE> set_info ( r , 0 ) <NEWLINE> <NL> for i , n in enumerate ( T ) : <NEWLINE> <INDENT> print_node ( i , n ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <COMMENT> <NL> <NL> N = 1000000007 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> node_n = int ( input ( ) ) <NEWLINE> nodes = list ( ) <NEWLINE> for _ in range ( node_n ) : <NEWLINE> <INDENT> nodes . append ( Node ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( node_n - 1 ) : <NEWLINE> <INDENT> i , j = tuple ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> nodes [ i - 1 ] . children . append ( nodes [ j - 1 ] ) <NEWLINE> nodes [ i - 1 ] . index . append ( j - 1 ) <NEWLINE> <NL> <DEDENT> print ( reduce_to_top ( nodes ) . n % N ) <NEWLINE> <NL> <DEDENT> def product ( iterator ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> result = 1 <NEWLINE> for element in iterator : <NEWLINE> <INDENT> result *= element % N <NEWLINE> result %= N <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def step_reducing ( nodes ) : <NEWLINE> <INDENT> last_parents = [ node for node in nodes if node is not None and node . is_last_parent ( ) ] <NEWLINE> for parent in last_parents : <NEWLINE> <INDENT> parent . n = parent . number_of_cases ( ) <NEWLINE> parent . children = list ( ) <NEWLINE> for i in parent . index : <NEWLINE> <INDENT> nodes [ i ] = None <NEWLINE> <DEDENT> <DEDENT> return nodes <NEWLINE> <NL> <DEDENT> def reduce_to_top ( nodes ) : <NEWLINE> <INDENT> while nodes [ 1 : ] != [ None ] * ( len ( nodes ) - 1 ) : <NEWLINE> <INDENT> nodes = step_reducing ( nodes ) <NEWLINE> <DEDENT> return nodes [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> class Node : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , kind , children = None , n = None , index = None ) : <NEWLINE> <INDENT> self . kind = kind <NEWLINE> if children is None : <NEWLINE> <INDENT> children = list ( ) <NEWLINE> <DEDENT> if index is None : <NEWLINE> <INDENT> index = list ( ) <NEWLINE> <DEDENT> self . children = children <NEWLINE> self . index = index <NEWLINE> self . n = None <NEWLINE> <NL> <DEDENT> def number_of_cases ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . n is not None : <NEWLINE> <INDENT> return self . n <NEWLINE> <NL> <DEDENT> cases = self . generate_cases ( ) <NEWLINE> if <STRING> in self . kind : <NEWLINE> <INDENT> result = product ( cases ) <NEWLINE> if <STRING> in self . kind : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> return result % N <NEWLINE> <NL> <DEDENT> elif <STRING> in self . kind : <NEWLINE> <INDENT> result = sum ( cases ) <NEWLINE> if <STRING> in self . kind : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> return result % N <NEWLINE> <NL> <DEDENT> elif <STRING> in self . kind : <NEWLINE> <INDENT> result = product ( ( x + 1 for x in cases ) ) <NEWLINE> if <STRING> not in self . kind : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> return result % N <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def generate_cases ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for child in self . children : <NEWLINE> <INDENT> yield child . number_of_cases ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def is_last_parent ( self ) : <NEWLINE> <INDENT> bools = [ child . children == [ ] for child in self . children ] <NEWLINE> return bools and all ( bools ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> from collections import Counter as co <NEWLINE> D = co ( A ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if D [ A [ - 1 - i ] ] > 0 : <NEWLINE> <INDENT> D [ A [ - 1 - i ] ] -= 1 <NEWLINE> d = A [ - 1 - i ] <NEWLINE> f = len ( bin ( d ) ) - 2 <NEWLINE> e = 2 ** f - d <NEWLINE> if D [ e ] > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> D [ e ] -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in A : <NEWLINE> <INDENT> ans *= l <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , * l = open ( 0 ) . read ( ) . split ( ) <NEWLINE> print ( len ( set ( l ) ) ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> T = N // B <NEWLINE> maxR = - 1 <NEWLINE> maxT = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> t = min ( B - 1 , N ) <NEWLINE> maxR = math . floor ( A * t / B ) - A * math . floor ( t / B ) <NEWLINE> print ( maxR ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> B [ a ] += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , B [ 1 : ] ) ) ) <NEWLINE>
n = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> def calc ( target ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> count = 0 <NEWLINE> if target % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> result = ( result * 10 + 7 ) % target <NEWLINE> count += 1 <NEWLINE> if result == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> calc ( n ) <NEWLINE>
import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> BC = sorted ( BC , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> D = [ ] <NEWLINE> <NL> for B , C in BC : <NEWLINE> <INDENT> for b in range ( B ) : <NEWLINE> <INDENT> if len ( D ) != N : <NEWLINE> <INDENT> D . append ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> if A [ i ] < D [ i ] : <NEWLINE> <INDENT> A [ i ] = D [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> dic = { } <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> dic [ i ] = 0 <NEWLINE> <DEDENT> dic [ 0 ] = 1 <NEWLINE> m = 0 <NEWLINE> decimal = 1 <NEWLINE> for j in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> m += int ( s [ - j ] ) * decimal <NEWLINE> m %= 2019 <NEWLINE> dic [ m ] += 1 <NEWLINE> decimal *= 10 <NEWLINE> decimal %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for v in dic . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> to = [ [ ] for _ in range ( 110000 ) ] <NEWLINE> ans = [ 0 ] * 110000 <NEWLINE> queue = [ ] <NEWLINE> passed = [ 0 ] * 110000 <NEWLINE> passed [ 1 ] = 1 <NEWLINE> <NL> def search ( i ) : <NEWLINE> <INDENT> global queue <NEWLINE> global passed <NEWLINE> global ans <NEWLINE> for j in to [ i ] : <NEWLINE> <INDENT> if passed [ j ] == 0 : <NEWLINE> <INDENT> queue . append ( j ) <NEWLINE> passed [ j ] = 1 <NEWLINE> ans [ j ] = i <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ a ] . append ( b ) <NEWLINE> to [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> search ( 1 ) <NEWLINE> queue . append ( 1 ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> que = queue . pop ( 0 ) <NEWLINE> search ( que ) <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 2 : n + 1 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def resolve ( T , v ) : <NEWLINE> <INDENT> lv = v <NEWLINE> while lv != T [ lv ] : <NEWLINE> <INDENT> lv = T [ lv ] <NEWLINE> <DEDENT> T [ v ] = lv <NEWLINE> return lv <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> T = list ( range ( N + 1 ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> lu = resolve ( T , u ) <NEWLINE> lv = resolve ( T , v ) <NEWLINE> if lv == lu : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> T [ lv ] = lu <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return len ( set ( resolve ( T , v ) for v in range ( 1 , N + 1 ) ) ) - 1 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for n in range ( N ) ] <NEWLINE> a1 = sorted ( A ) [ - 1 ] <NEWLINE> a2 = sorted ( A ) [ - 2 ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == a1 : <NEWLINE> <INDENT> print ( a2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sx = sorted ( x ) <NEWLINE> lx = len ( x ) // 2 <NEWLINE> m = sx [ lx ] <NEWLINE> _m = sx [ lx - 1 ] if 0 < m - 1 else sx [ 0 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> print ( m if i < m else _m ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> <NL> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a < 10050 : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <NL> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for j in range ( K , N ) : <NEWLINE> <INDENT> if A [ j ] > A [ j - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin , setrecursionlimit as srl <NEWLINE> from threading import stack_size <NEWLINE> srl ( int ( 1e9 ) + 7 ) <NEWLINE> stack_size ( int ( 1e8 ) ) <NEWLINE> <NL> def get ( i , value , vis ) : <NEWLINE> <INDENT> if vis [ i ] : <NEWLINE> <INDENT> return value [ i ] <NEWLINE> <DEDENT> vis [ i ] = True <NEWLINE> ans = 0 <NEWLINE> for j in adj [ i ] : <NEWLINE> <INDENT> ans = max ( ans , 1 + get ( j , value , vis ) ) <NEWLINE> <DEDENT> value [ i ] = ans <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> adj [ i ] = [ ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ x - 1 ] . append ( y - 1 ) <NEWLINE> <DEDENT> vis = [ False for i in range ( n ) ] <NEWLINE> value = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> value [ i ] = get ( i , value , vis ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> for i in value : <NEWLINE> <INDENT> x = max ( x , i ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> if i == j and i == k : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or i == k or j == k : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = B + [ 10 ** 10 ] <NEWLINE> <NL> Ac = list ( itertools . accumulate ( A ) ) <NEWLINE> <NL> iA = bisect . bisect_right ( Ac , K ) <NEWLINE> <NL> A_ok = Ac [ : iA ] [ : : - 1 ] + [ 0 ] <NEWLINE> Alen = len ( A_ok ) <NEWLINE> <NL> ans = 0 <NEWLINE> SUM = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( Alen ) : <NEWLINE> <INDENT> K2 = K - A_ok [ i ] <NEWLINE> k = cnt <NEWLINE> for j in range ( M - k ) : <NEWLINE> <INDENT> if SUM + B [ j + k ] <= K2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> SUM += B [ j + k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , ( Alen - i - 1 + cnt ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def gcd ( n , m ) : <NEWLINE> <INDENT> if n < m : <NEWLINE> <INDENT> tmp = m <NEWLINE> m = n <NEWLINE> n = tmp <NEWLINE> <DEDENT> while m > 0 : <NEWLINE> <INDENT> r = n % m <NEWLINE> n = m <NEWLINE> m = r <NEWLINE> <DEDENT> return n <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> tree = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> key_order = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> in1 , in2 = map ( int , input ( ) . split ( ) ) <NEWLINE> in1 -= 1 <NEWLINE> in2 -= 1 <NEWLINE> tree [ in1 ] . append ( in2 ) <NEWLINE> tree [ in2 ] . append ( in1 ) <NEWLINE> <NL> key_order [ i ] = ( in1 , in2 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def bfs ( tree , p ) : <NEWLINE> <INDENT> seen = [ False ] * len ( tree ) <NEWLINE> queue = deque ( ( p , ) ) <NEWLINE> <NL> edge_colors = dict ( ) <NEWLINE> node_colors = [ 0 ] * len ( tree ) <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> q = queue . popleft ( ) <NEWLINE> seen [ q ] = True <NEWLINE> <NL> parent_color = node_colors [ q ] <NEWLINE> <NL> cnt = 1 <NEWLINE> for v in tree [ q ] : <NEWLINE> <INDENT> if not seen [ v ] : <NEWLINE> <INDENT> if cnt == parent_color : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> edge_colors [ ( q , v ) ] = cnt <NEWLINE> node_colors [ v ] = cnt <NEWLINE> queue . append ( v ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> return edge_colors <NEWLINE> <NL> <NL> <DEDENT> edge_colors = bfs ( tree , 0 ) <NEWLINE> <NL> print ( max ( [ c for key , c in edge_colors . items ( ) ] ) ) <NEWLINE> [ print ( edge_colors [ t ] ) for t in key_order ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL>
N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> X = [ 0 for _ in range ( N ) ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) [ : : - 1 ] : <NEWLINE> <INDENT> v = 0 <NEWLINE> for j in range ( i , N , i + 1 ) : <NEWLINE> <INDENT> v += X [ j ] <NEWLINE> <DEDENT> if v % 2 != A [ i ] : <NEWLINE> <INDENT> X [ i ] = 1 <NEWLINE> ans . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> if N != 100 : <NEWLINE> <INDENT> print ( N * ( 100 ** D ) ) <NEWLINE> <DEDENT> elif N == 100 : <NEWLINE> <INDENT> print ( ( N + 1 ) * 100 ** D ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> val = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if val <= n : <NEWLINE> <INDENT> ans [ val ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> S = <STRING> . join ( sorted ( list ( S ) ) ) <NEWLINE> if S in d . keys ( ) : <NEWLINE> <INDENT> d [ S ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ S ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for n in d . values ( ) : <NEWLINE> <INDENT> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif K <= A + B + C : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - C ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dh = 30 * h + m / 2 <NEWLINE> dm = 6 * m <NEWLINE> <NL> if dm == dh : <NEWLINE> <INDENT> rad = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rad = abs ( dm - dh ) <NEWLINE> <NL> <DEDENT> if rad > 180 : <NEWLINE> <INDENT> rad = 360 - rad <NEWLINE> length = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( rad ) ) ) <NEWLINE> <NL> <DEDENT> elif 0 < rad and rad < 180 : <NEWLINE> <INDENT> length = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( rad ) ) ) <NEWLINE> <NL> <DEDENT> elif rad == 180 : <NEWLINE> <INDENT> length = a + b <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> length = abs ( a - b ) <NEWLINE> <NL> <DEDENT> print ( length ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> temp *= i <NEWLINE> if temp > 10 ** 18 : <NEWLINE> <INDENT> temp = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( temp ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> data = { } <NEWLINE> zero_zero = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero_zero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> gcd = math . gcd ( a , b ) <NEWLINE> a , b = a // gcd , b // gcd <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <NL> <DEDENT> if a == 0 : <COMMENT> <NEWLINE> <INDENT> a , b = 0 , 1 <NEWLINE> <NL> <DEDENT> elif b == 0 : <COMMENT> <NEWLINE> <INDENT> a , b = 1 , 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if b <= 0 : <COMMENT> <NEWLINE> <INDENT> if ( - b , a ) in data : <NEWLINE> <INDENT> data [ ( - b , a ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data [ ( - b , a ) ] = [ 0 , 1 ] <NEWLINE> <DEDENT> <DEDENT> elif b > 0 : <COMMENT> <NEWLINE> <INDENT> if ( a , b ) in data : <NEWLINE> <INDENT> data [ ( a , b ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data [ ( a , b ) ] = [ 1 , 0 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> power_2 = [ 1 ] <NEWLINE> for i in range ( 1 , 2 * 10 ** 5 + 100 ) : <NEWLINE> <INDENT> power_2 . append ( power_2 [ i - 1 ] * 2 % mod ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for ( a , b ) , ( l , m ) in data . items ( ) : <NEWLINE> <INDENT> ans *= ( power_2 [ l ] + power_2 [ m ] - 1 ) % mod <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = ans - 1 <COMMENT> <NEWLINE> ans += zero_zero <NEWLINE> print ( ans % mod ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
from sys import stdin , stdout <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( stdin . readline ( ) ) <NEWLINE> S = stdin . readline ( ) . rstrip ( ) <NEWLINE> R , G , B = set ( ) , set ( ) , set ( ) <NEWLINE> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> R . add ( i ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> G . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . add ( i ) <NEWLINE> <DEDENT> <DEDENT> cnt , total = 0 , len ( R ) * len ( G ) * len ( B ) <NEWLINE> for ri in R : <NEWLINE> <INDENT> for gi in G : <NEWLINE> <INDENT> if abs ( ri - gi ) + gi in B : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if abs ( ri - gi ) + ri in B : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ri in G : <NEWLINE> <INDENT> for gi in B : <NEWLINE> <INDENT> if abs ( ri - gi ) + gi in R : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if abs ( ri - gi ) + ri in R : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ri in R : <NEWLINE> <INDENT> for gi in B : <NEWLINE> <INDENT> if abs ( ri - gi ) + gi in G : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if abs ( ri - gi ) + ri in G : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> stdout . write ( str ( total - cnt ) + <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
L , R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if R - L >= 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_mod = 2019 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> tmp = ( i * j ) % 2019 <NEWLINE> if tmp < min_mod : <NEWLINE> <INDENT> min_mod = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min_mod ) <NEWLINE> <DEDENT>
A , B , C , D , E , F = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> CCT = { } <NEWLINE> for a in range ( F // ( 100 * A ) + 1 ) : <NEWLINE> <INDENT> for b in range ( F // ( 100 * B ) + 1 ) : <NEWLINE> <INDENT> water = ( a * A + b * B ) * 100 <NEWLINE> if water > F : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> max_suger = water * E // 100 <NEWLINE> for c in range ( max_suger // C + 1 ) : <NEWLINE> <INDENT> for d in range ( max_suger // D + 1 ) : <NEWLINE> <INDENT> suger = c * C + d * D <NEWLINE> total = water + suger <NEWLINE> if total > F or total == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if max_suger < suger : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> CCT [ water , suger ] = suger / total <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = ( A * 100 , 0 ) <NEWLINE> max_cct = 0 <NEWLINE> for ( water , suger ) , cct in CCT . items ( ) : <NEWLINE> <INDENT> if cct > max_cct : <NEWLINE> <INDENT> max_cct = cct <NEWLINE> ans = ( water + suger , suger ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> temp = sorted ( a ) <NEWLINE> m1 = temp [ - 1 ] <NEWLINE> m2 = temp [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == m1 : <NEWLINE> <INDENT> print ( m2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = max ( a ) <NEWLINE> noww = now <NEWLINE> k = n + 2 * now <NEWLINE> matc = [ 0 ] * ( n + 2 ) <NEWLINE> mat2 = [ 0 ] * ( n + 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> neg = i - a [ i ] <NEWLINE> pos = i + a [ i ] <NEWLINE> if neg >= 0 : <NEWLINE> <INDENT> matc [ neg ] += 1 <NEWLINE> <DEDENT> if pos <= n : <NEWLINE> <INDENT> mat2 [ pos ] += 1 <NEWLINE> <DEDENT> now += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for j in range ( n + 2 ) : <NEWLINE> <INDENT> ans += matc [ j ] * mat2 [ j ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
import numba as nb <NEWLINE> @ nb . njit <NEWLINE> def solve ( n , k , a ) : <NEWLINE> <INDENT> dp = [ 0 ] * n <NEWLINE> dp [ 1 ] = abs ( a [ 1 ] - a [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> mi = 10 ** 9 <NEWLINE> temp = 1 <NEWLINE> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if temp > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> if abs ( a [ i ] - a [ j ] ) + dp [ j ] < mi : <NEWLINE> <INDENT> mi = abs ( a [ i ] - a [ j ] ) + dp [ j ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = mi <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( n , k , a ) <NEWLINE>
<NL> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> ans . append ( a [ i ] - a [ i - k ] ) <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> if j > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_num = 10 ** 6 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] < min_num : <NEWLINE> <INDENT> min_num = p [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> i = 0 <NEWLINE> d = [ 0 ] * k * k <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d [ i ] = math . gcd ( a , b ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += sum ( map ( lambda x : math . gcd ( x , c ) , d ) ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> s = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> a = collections . Counter ( s ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in a . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 2018 <NEWLINE> <NL> if r - l >= 2019 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> if ( i * j ) % 2019 < x : <NEWLINE> <INDENT> x = ( i * j ) % 2019 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for op in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> op = op . split ( ) <NEWLINE> if op [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ op [ 1 ] ] = 1 <NEWLINE> <DEDENT> elif op [ 0 ] == <STRING> : <NEWLINE> <INDENT> if op [ 1 ] in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> <NL> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> rmd = 0 <NEWLINE> num_rate = 1 <NEWLINE> L = len ( S ) <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> rmd = ( int ( S [ L - i - 1 ] ) * num_rate + rmd ) % 2019 <NEWLINE> num_rate = num_rate * 10 % 2019 <NEWLINE> cnt [ rmd ] += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( [ i * ( i - 1 ) // 2 for i in cnt ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> X , N = input ( ) . split ( ) <NEWLINE> X , N = int ( X ) , int ( N ) <NEWLINE> <NL> P = input ( ) . split ( ) <NEWLINE> P = [ int ( c ) for c in P ] <NEWLINE> <NL> if len ( P ) == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = list ( range ( max ( 0 , X - N ) , min ( 102 , X + N ) ) ) <NEWLINE> <NL> if X + N <= 101 : <NEWLINE> <INDENT> L . append ( X + N ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] in L : <NEWLINE> <INDENT> L . remove ( P [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> while len ( L ) > 2 : <NEWLINE> <INDENT> rand = random . randint ( 1 , len ( L ) - 2 ) <NEWLINE> if L [ rand ] == X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif L [ rand ] > X : <NEWLINE> <INDENT> L = L [ 0 : rand + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = L [ rand : len ( L ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> if X in L : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif len ( L ) == 1 : <NEWLINE> <INDENT> print ( L [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( L [ 0 ] - X ) > abs ( L [ 1 ] - X ) : <NEWLINE> <INDENT> print ( L [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( L [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
T = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if T == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> or T [ i ] == <STRING> : <NEWLINE> <INDENT> ans += T [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i != len ( T ) - 1 : <NEWLINE> <INDENT> if ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif ans [ - 1 ] == <STRING> and T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = 1 <NEWLINE> r = N <NEWLINE> dis = set ( ) <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( l , r ) <NEWLINE> l = l + 1 <NEWLINE> r = r - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( M ) : <NEWLINE> <INDENT> print ( l , r ) <NEWLINE> a , b = r - l , N + l - r <NEWLINE> dis . add ( a ) <NEWLINE> dis . add ( b ) <NEWLINE> l = l + 1 <NEWLINE> r = r - 1 <NEWLINE> if r - l in dis or N + l - r in dis or r - l == N + l - r : <NEWLINE> <INDENT> r = r - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : continue <NEWLINE> k = 2 * j - i <NEWLINE> if k >= n : continue <NEWLINE> if s [ i ] == s [ k ] or s [ j ] == s [ k ] : continue <NEWLINE> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> l = 10 ** 18 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> S = S * A [ i ] <NEWLINE> if S > l : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if S <= l : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
b1 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> b2 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> b3 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> b4 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( b == 1 ) : <NEWLINE> <INDENT> b1 [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> elif ( b == 2 ) : <NEWLINE> <INDENT> b2 [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> elif ( b == 3 ) : <NEWLINE> <INDENT> b3 [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> elif ( b == 4 ) : <NEWLINE> <INDENT> b4 [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , b1 [ i ] ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , b2 [ i ] ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , b3 [ i ] ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , b4 [ i ] ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ float ( <STRING> ) ] * n <NEWLINE> def dfs ( s , p , depth ) : <NEWLINE> <INDENT> if depth > 2 : return <NEWLINE> dist [ s ] = min ( dist [ s ] , depth ) <NEWLINE> for to in g [ s ] : <NEWLINE> <INDENT> if to == p : continue <NEWLINE> if dist [ to ] < dist [ s ] + 1 : continue <NEWLINE> dfs ( to , s , depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> if dist [ n - 1 ] <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) and ( s [ i - 1 ] % 2 == 1 ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> listA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in listA : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> result = 1 <NEWLINE> maxA = 10 ** 18 <NEWLINE> for a in listA : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > maxA : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> n_dic = { } <NEWLINE> for i in n_list : <NEWLINE> <INDENT> n_dic . setdefault ( i , 0 ) <NEWLINE> n_dic [ i ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for k in n_dic : <NEWLINE> <INDENT> result += k * n_dic [ k ] <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in n_dic : <NEWLINE> <INDENT> n_dic . setdefault ( c , 0 ) <NEWLINE> n_dic [ c ] += n_dic [ b ] <NEWLINE> result = result + ( c - b ) * n_dic [ b ] <NEWLINE> del n_dic [ b ] <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> c = L [ i ] + L [ j ] <NEWLINE> <COMMENT> <NL> idx = bisect_left ( L , c ) <NEWLINE> ans += max ( 0 , idx - ( j + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if 0 <= k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
import sys <NEWLINE> write = sys . stdout . write <NEWLINE> <NL> buildings = [ [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] ] <NEWLINE> for i in range ( 0 , 4 ) : <NEWLINE> <INDENT> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> buildings [ i ] [ j ] . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> informations = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 0 , informations ) : <NEWLINE> <INDENT> information = [ ] <NEWLINE> information = input ( ) . split ( ) <NEWLINE> information [ 0 ] = int ( information [ 0 ] ) <NEWLINE> information [ 1 ] = int ( information [ 1 ] ) <NEWLINE> information [ 2 ] = int ( information [ 2 ] ) <NEWLINE> information [ 3 ] = int ( information [ 3 ] ) <NEWLINE> buildings [ information [ 0 ] - 1 ] [ information [ 1 ] - 1 ] [ information [ 2 ] - 1 ] += information [ 3 ] <NEWLINE> <NL> <DEDENT> for i in range ( 0 , 4 ) : <NEWLINE> <INDENT> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> write ( <STRING> ) <NEWLINE> write ( str ( buildings [ i ] [ j ] [ k ] ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> for j in range ( 0 , 20 ) : <NEWLINE> <INDENT> write ( <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> d = [ 0 ] * 20002 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> d [ i ] = min ( d [ i - a ] + b for a , b in c ) <NEWLINE> <DEDENT> print ( d [ h - 1 ] ) <NEWLINE>
import copy <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> def dfs ( start , path ) : <NEWLINE> <INDENT> next_path = copy . copy ( path ) <NEWLINE> global ans <NEWLINE> next_path . append ( start ) <NEWLINE> if len ( next_path ) == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return <NEWLINE> <DEDENT> for i in edges [ start ] : <NEWLINE> <INDENT> if i not in next_path : <NEWLINE> <INDENT> dfs ( i , next_path ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , [ ] ) <NEWLINE> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <COMMENT> <NEWLINE> <INDENT> if b % a == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = b % a <NEWLINE> if a < c : <NEWLINE> <INDENT> return gcd ( a , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( c , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( i , j ) * 6 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , k - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k ) : <NEWLINE> <INDENT> for l in range ( j + 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , l ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> if a [ 0 ] == <STRING> or a [ 1 ] == <STRING> or a [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> s = list ( t ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
from collections import Counter <NEWLINE> import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> MX = 10 ** 6 <NEWLINE> P = [ 0 ] * ( MX + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if P [ a ] == 0 : <NEWLINE> <INDENT> for i in range ( MX + 1 ) : <NEWLINE> <INDENT> x = a * i <NEWLINE> if x > MX : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> P [ x ] = 1 <NEWLINE> <DEDENT> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = True <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = np . full ( ( 2 , n // 2 + 1 ) , - 10 ** 18 , dtype = np . int64 ) <NEWLINE> <STRING> <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> dp [ 1 ] [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = i % 2 <NEWLINE> for j in [ 2 , 1 , 0 ] : <NEWLINE> <INDENT> if i // 2 + j <= n // 2 : <NEWLINE> <INDENT> if i // 2 - 1 + j >= 0 : <NEWLINE> <INDENT> dp [ k ] [ i // 2 + j ] = np . maximum ( dp [ 1 - k ] [ i // 2 + j ] , dp [ k ] [ i // 2 - 1 + j ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( dp [ 0 ] [ n // 2 ] , dp [ 1 ] [ n // 2 ] ) ) <NEWLINE>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( w * h / 2 , int ( h == 2 * y and w == 2 * x ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) - 1 for _ in range ( N ) ] <NEWLINE> <NL> light = 0 <NEWLINE> ans = - 1 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> light = A [ light ] <NEWLINE> if light == 1 : <NEWLINE> <INDENT> ans = n <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p2 . append ( ( ( 1 + p1 [ i ] ) / 2 ) ) <NEWLINE> <DEDENT> ans = sum ( p2 [ 0 : k ] ) <NEWLINE> sum1 = sum ( p2 [ 0 : k ] ) <NEWLINE> for j in range ( n - k ) : <NEWLINE> <INDENT> sum1 = sum1 + p2 [ j + k ] - p2 [ j ] <NEWLINE> if ans < sum1 : <NEWLINE> <INDENT> ans = sum1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
<NL> K = int ( input ( ) ) <NEWLINE> <NL> if ( K % 2 == 0 or K % 5 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> s = 7 <NEWLINE> while True : <NEWLINE> <INDENT> if s % K == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( s % K ) * 10 + 7 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <NL> ans = a [ 0 ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> hako = [ 0 ] * ( 10 ** 6 ) <NEWLINE> ind = list ( range ( 10 ** 6 ) ) <NEWLINE> S = sum ( a ) <NEWLINE> s = [ ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> hako [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> S += ( ind [ c ] - ind [ b ] ) * hako [ b ] <NEWLINE> s . append ( S ) <NEWLINE> hako [ c ] += hako [ b ] <NEWLINE> hako [ b ] = 0 <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> S = len ( set ( s ) ) <NEWLINE> <NL> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> write = sys . stdout . write <NEWLINE> <NL> h_numbers = [ ] <NEWLINE> w_numbers = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> numbers = input ( ) . split ( ) <NEWLINE> numbers [ 0 ] = int ( numbers [ 0 ] ) <NEWLINE> numbers [ 1 ] = int ( numbers [ 1 ] ) <NEWLINE> if numbers [ 0 ] == 0 and numbers [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h_numbers . append ( numbers [ 0 ] ) <NEWLINE> w_numbers . append ( numbers [ 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( h_numbers ) ) : <NEWLINE> <INDENT> for j in range ( 0 , h_numbers [ i ] ) : <NEWLINE> <INDENT> for k in range ( 0 , w_numbers [ i ] ) : <NEWLINE> <INDENT> if ( j + k + 2 ) % 2 == 0 : <NEWLINE> <INDENT> write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> import itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> v_1 = v [ : : - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> res = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while ( i + j <= min ( n , k ) ) : <NEWLINE> <NL> <INDENT> q = [ ] <NEWLINE> tmp = 0 <NEWLINE> if ( i > 0 ) : <NEWLINE> <INDENT> for l in range ( i ) : <NEWLINE> <INDENT> if ( v [ l ] < 0 ) : <NEWLINE> <INDENT> heapq . heappush ( q , v [ l ] ) <NEWLINE> <DEDENT> tmp += v [ l ] <NEWLINE> <DEDENT> <DEDENT> if ( j > 0 ) : <NEWLINE> <INDENT> for l in range ( j ) : <NEWLINE> <INDENT> if ( v_1 [ l ] < 0 ) : <NEWLINE> <INDENT> heapq . heappush ( q , v_1 [ l ] ) <NEWLINE> <DEDENT> tmp += v_1 [ l ] <NEWLINE> <DEDENT> <DEDENT> for l in range ( k - ( i + j ) ) : <NEWLINE> <INDENT> if ( len ( q ) > 0 ) : <NEWLINE> <INDENT> z = heapq . heappop ( q ) <NEWLINE> tmp -= z <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> res = max ( res , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from queue import Queue as q <NEWLINE> from copy import deepcopy as cp <NEWLINE> <NL> def l_move ( data ) : <NEWLINE> <INDENT> global flag <NEWLINE> field , n , i , j = data [ 0 ] , data [ 1 ] , data [ 2 ] , data [ 3 ] <NEWLINE> if j == 0 or field [ i ] [ j - 1 ] == 1 or n == 0 : <NEWLINE> <INDENT> return ( None ) <NEWLINE> <DEDENT> while ( j ) : <NEWLINE> <INDENT> if field [ i ] [ j - 1 ] == 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> elif field [ i ] [ j - 1 ] == 3 : <NEWLINE> <INDENT> flag = True <NEWLINE> print ( 11 - n ) <NEWLINE> return ( None ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nfield = field [ : i ] + [ field [ i ] [ : j - 1 ] + [ 0 ] + field [ i ] [ j : ] ] + field [ i + 1 : ] <NEWLINE> <NL> n -= 1 <NEWLINE> return ( [ nfield , n , i , j ] ) <NEWLINE> <DEDENT> <DEDENT> return ( None ) <NEWLINE> <NL> <DEDENT> def u_move ( data ) : <NEWLINE> <INDENT> global flag <NEWLINE> field , n , i , j = data [ 0 ] , data [ 1 ] , data [ 2 ] , data [ 3 ] <NEWLINE> if i == 0 or field [ i - 1 ] [ j ] == 1 or n == 0 : <NEWLINE> <INDENT> return ( None ) <NEWLINE> <DEDENT> while ( i ) : <NEWLINE> <INDENT> if field [ i - 1 ] [ j ] == 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> elif field [ i - 1 ] [ j ] == 3 : <NEWLINE> <INDENT> flag = True <NEWLINE> print ( 11 - n ) <NEWLINE> return ( None ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nfield = field [ : i - 1 ] + [ field [ i - 1 ] [ : j ] + [ 0 ] + field [ i - 1 ] [ j + 1 : ] ] + field [ i : ] <NEWLINE> <NL> n -= 1 <NEWLINE> return ( [ nfield , n , i , j ] ) <NEWLINE> <DEDENT> <DEDENT> return ( None ) <NEWLINE> <NL> <DEDENT> def r_move ( data ) : <NEWLINE> <INDENT> global flag <NEWLINE> field , n , i , j = data [ 0 ] , data [ 1 ] , data [ 2 ] , data [ 3 ] <NEWLINE> <NL> if j == y - 1 or field [ i ] [ j + 1 ] == 1 or n == 0 : <NEWLINE> <INDENT> return ( None ) <NEWLINE> <DEDENT> while ( j < y - 1 ) : <NEWLINE> <INDENT> if field [ i ] [ j + 1 ] == 0 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> elif field [ i ] [ j + 1 ] == 3 : <NEWLINE> <INDENT> flag = True <NEWLINE> print ( 11 - n ) <NEWLINE> return ( None ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nfield = field [ : i ] + [ field [ i ] [ : j + 1 ] + [ 0 ] + field [ i ] [ j + 2 : ] ] + field [ i + 1 : ] <NEWLINE> <NL> n -= 1 <NEWLINE> return ( [ nfield , n , i , j ] ) <NEWLINE> <DEDENT> <DEDENT> return ( None ) <NEWLINE> <NL> <DEDENT> def d_move ( data ) : <NEWLINE> <INDENT> global flag <NEWLINE> field , n , i , j = data [ 0 ] , data [ 1 ] , data [ 2 ] , data [ 3 ] <NEWLINE> if i == x - 1 or field [ i + 1 ] [ j ] == 1 or n == 0 : <NEWLINE> <INDENT> return ( None ) <NEWLINE> <DEDENT> while ( i < x - 1 ) : <NEWLINE> <INDENT> if field [ i + 1 ] [ j ] == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> elif field [ i + 1 ] [ j ] == 3 : <NEWLINE> <INDENT> flag = True <NEWLINE> print ( 11 - n ) <NEWLINE> return ( None ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nfield = field [ : i + 1 ] + [ field [ i + 1 ] [ : j ] + [ 0 ] + field [ i + 1 ] [ j + 1 : ] ] + field [ i + 2 : ] <NEWLINE> <NL> n -= 1 <NEWLINE> return ( [ nfield , n , i , j ] ) <NEWLINE> <DEDENT> <DEDENT> return ( None ) <NEWLINE> <NL> <DEDENT> while ( True ) : <NEWLINE> <INDENT> flag = False <NEWLINE> y , x = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = q ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> field = [ ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> field . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> for j in range ( y ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == 2 : <NEWLINE> <INDENT> start_x , start_y = i , j <NEWLINE> field [ i ] [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> data = [ field , 10 , start_x , start_y ] <NEWLINE> lis . put ( data ) <NEWLINE> while ( lis . qsize ( ) ) : <NEWLINE> <INDENT> d = lis . get ( ) <NEWLINE> tmp = l_move ( d ) <NEWLINE> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tmp != None : <NEWLINE> <INDENT> lis . put ( tmp ) <NEWLINE> <DEDENT> tmp = u_move ( d ) <NEWLINE> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tmp != None : <NEWLINE> <INDENT> lis . put ( tmp ) <NEWLINE> <DEDENT> tmp = d_move ( d ) <NEWLINE> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tmp != None : <NEWLINE> <NL> <INDENT> lis . put ( tmp ) <NEWLINE> <DEDENT> tmp = r_move ( d ) <NEWLINE> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if tmp != None : <NEWLINE> <INDENT> lis . put ( tmp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> X = input ( ) <NEWLINE> que = deque ( ) <NEWLINE> for x in X : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> que . append ( <STRING> ) <NEWLINE> <DEDENT> elif x == <STRING> and ( not que or que [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> que . append ( <STRING> ) <NEWLINE> <DEDENT> elif x == <STRING> and que [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _ = que . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( que ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> S -= a <NEWLINE> ans += a * S <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> V = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> C = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> profit = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if V [ i ] - C [ i ] >= 0 : <NEWLINE> <INDENT> profit += V [ i ] - C [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( profit ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ 0 ] * 101 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in A_i : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> for j in cnt : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> li [ a - 1 ] . append ( b - 1 ) <NEWLINE> li [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> sign = { 0 : 0 } <NEWLINE> step = { 0 : 1 } <NEWLINE> now = { 0 } <NEWLINE> flg = False <NEWLINE> while len ( now ) > 0 : <NEWLINE> <INDENT> if flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> flg = True <NEWLINE> next = set ( ) <NEWLINE> for i in now : <NEWLINE> <INDENT> for j in li [ i ] : <NEWLINE> <INDENT> if not j in sign : <NEWLINE> <INDENT> sign [ j ] = i <NEWLINE> step [ j ] = step [ i ] + 1 <NEWLINE> next . add ( j ) <NEWLINE> flg = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> now . clear ( ) <NEWLINE> now = next <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( sign [ i + 1 ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> t -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
import random <NEWLINE> import sys <NEWLINE> import time <NEWLINE> import copy <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> start_time = time . time ( ) <NEWLINE> beamwidth = 5 <NEWLINE> ans = [ [ ] for _ in range ( beamwidth ) ] <NEWLINE> suff = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> topk = [ { <STRING> : [ 0 for _ in range ( 26 ) ] , <STRING> : 0 , <STRING> : [ ] } for _ in range ( beamwidth ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> nnnnn = [ ] <COMMENT> <NEWLINE> for bi in range ( beamwidth ) : <NEWLINE> <INDENT> last = topk [ bi ] [ <STRING> ] <NEWLINE> tmpsufss = [ ] <NEWLINE> for con in range ( 26 ) : <NEWLINE> <INDENT> tmpsufss . sort ( key = lambda x : - x [ <STRING> ] ) <NEWLINE> ttttt = topk [ bi ] [ <STRING> ] + s [ i ] [ con ] <NEWLINE> minus = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if con == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> minus -= ( i - last [ j ] ) * c [ j ] <NEWLINE> <DEDENT> ttttt += minus <NEWLINE> <NL> if len ( tmpsufss ) < beamwidth : <NEWLINE> <INDENT> tmpsufss . append ( { <NEWLINE> <INDENT> <STRING> : last , <NEWLINE> <STRING> : ttttt , <NEWLINE> <STRING> : copy . deepcopy ( topk [ bi ] [ <STRING> ] ) <NEWLINE> <DEDENT> } ) <NEWLINE> tmpsufss [ - 1 ] [ <STRING> ] [ con ] = i <NEWLINE> tmpsufss [ - 1 ] [ <STRING> ] . append ( con ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tmpsufss [ - 1 ] [ <STRING> ] < ttttt : <NEWLINE> <INDENT> tmpsufss . pop ( ) <NEWLINE> tmpsufss . append ( { <NEWLINE> <INDENT> <STRING> : last , <NEWLINE> <STRING> : ttttt , <NEWLINE> <STRING> : copy . deepcopy ( topk [ bi ] [ <STRING> ] ) <NEWLINE> <DEDENT> } ) <NEWLINE> tmpsufss [ - 1 ] [ <STRING> ] [ con ] = i <NEWLINE> tmpsufss [ - 1 ] [ <STRING> ] . append ( con ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> nnnnn . extend ( tmpsufss ) <NEWLINE> <NL> <DEDENT> nnnnn . sort ( key = lambda x : - x [ <STRING> ] ) <NEWLINE> topk = nnnnn [ : beamwidth ] <NEWLINE> <NL> <NL> <DEDENT> print ( * [ a + 1 for a in topk [ 0 ] [ <STRING> ] ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> error = 0 <NEWLINE> n = 0 <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> n = ( N // 2 ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = N // 2 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for p in range ( n + 1 ) : <NEWLINE> <INDENT> for i in range ( N - ( p * 2 ) ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + p ] or S [ i + p ] == S [ i + 2 * p ] or S [ i ] == S [ i + 2 * p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> error += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> d = r * g * b <NEWLINE> <NL> print ( d - error ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> delta , notP = [ ] , [ ] <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if not i in P : <NEWLINE> <INDENT> delta . append ( abs ( X - i ) ) <NEWLINE> notP . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> i = delta . index ( min ( delta ) ) <NEWLINE> print ( notP [ i ] ) <NEWLINE>
def cnt_car ( w , p ) : <NEWLINE> <INDENT> car = 1 <NEWLINE> wi = 0 <NEWLINE> for i in w : <NEWLINE> <INDENT> if ( wi + i ) <= p : <NEWLINE> <INDENT> wi += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> car += 1 <NEWLINE> wi = i <NEWLINE> <DEDENT> <DEDENT> return car <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> w = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> p = max ( max ( w ) , sum ( w ) // k ) <NEWLINE> while True : <NEWLINE> <INDENT> if cnt_car ( w , p ) <= k : <NEWLINE> <INDENT> print ( p ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if cnt_car ( w , p + 100 ) > k : <NEWLINE> <INDENT> p += 100 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> s . append ( 1 ) <NEWLINE> a1 = 1 <NEWLINE> a2 = a [ a1 - 1 ] <NEWLINE> l = [ 0 ] * n <NEWLINE> l [ 0 ] = 1 <NEWLINE> <NL> while l [ a2 - 1 ] != 1 : <NEWLINE> <INDENT> s . append ( a2 ) <NEWLINE> a1 = a2 <NEWLINE> a2 = a [ a1 - 1 ] <NEWLINE> l [ a1 - 1 ] = 1 <NEWLINE> <NL> <DEDENT> loop_num = s . index ( a2 ) <NEWLINE> loop = s [ loop_num : ] <NEWLINE> cnt = len ( loop ) <NEWLINE> <NL> if k < len ( s ) : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( k - loop_num ) % cnt <NEWLINE> print ( loop [ ans ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> mod = 1000000007 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> calc = dict ( ) <NEWLINE> non_count = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <NL> <INDENT> if A [ i ] == 0 and B [ i ] == 0 : <NEWLINE> <INDENT> non_count += 1 <NEWLINE> <DEDENT> elif A [ i ] == 0 : <NEWLINE> <INDENT> k = ( 0 , 1 ) <NEWLINE> if calc . get ( k ) : <NEWLINE> <INDENT> calc [ k ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> calc [ k ] = [ 1 , 0 ] <NEWLINE> <DEDENT> <DEDENT> elif B [ i ] == 0 : <NEWLINE> <INDENT> k = ( 0 , 1 ) <NEWLINE> if calc . get ( k ) : <NEWLINE> <INDENT> calc [ k ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> calc [ k ] = [ 0 , 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> r = math . gcd ( A [ i ] , B [ i ] ) <NEWLINE> m = 1 <NEWLINE> if A [ i ] * B [ i ] < 0 : <NEWLINE> <INDENT> m = - 1 <NEWLINE> <DEDENT> k1 = ( m * abs ( A [ i ] // r ) , abs ( B [ i ] // r ) ) <NEWLINE> k2 = ( - m * abs ( B [ i ] // r ) , abs ( A [ i ] // r ) ) <NEWLINE> if calc . get ( k1 ) : <NEWLINE> <INDENT> calc [ k1 ] [ 0 ] += 1 <NEWLINE> <DEDENT> elif not calc . get ( k2 ) : <NEWLINE> <INDENT> calc [ k1 ] = [ 1 , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> calc [ k2 ] [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N = N - non_count <NEWLINE> <NL> count = 0 <NEWLINE> for k , v in calc . items ( ) : <NEWLINE> <INDENT> if not v [ 0 ] * v [ 1 ] == 0 : <NEWLINE> <INDENT> count += v [ 0 ] + v [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = pow ( 2 , N - count , mod ) <NEWLINE> for k , v in calc . items ( ) : <NEWLINE> <INDENT> if not v [ 0 ] * v [ 1 ] == 0 : <NEWLINE> <INDENT> comb = ( pow ( 2 , v [ 0 ] ) + pow ( 2 , v [ 1 ] ) - 1 ) <NEWLINE> ans = ( ans * comb ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( ans - 1 + non_count ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( ans ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b > k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_accumulate_cost = [ 0 ] <NEWLINE> lastCost = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lastCost += A [ i ] <NEWLINE> A_accumulate_cost . append ( lastCost ) <NEWLINE> <NL> <DEDENT> B_accumulate_cost = [ 0 ] <NEWLINE> lastCost = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> lastCost += B [ i ] <NEWLINE> B_accumulate_cost . append ( lastCost ) <NEWLINE> <NL> <DEDENT> max_num = 0 <NEWLINE> p = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> A_cost = A_accumulate_cost [ i ] <NEWLINE> if A_cost > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for j in range ( p , - 1 , - 1 ) : <NEWLINE> <INDENT> if A_cost + B_accumulate_cost [ j ] <= K : <NEWLINE> <INDENT> p = j <NEWLINE> if i + j > max_num : <NEWLINE> <INDENT> max_num = i + j <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_num ) <NEWLINE>
import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> a_dict = collections . Counter ( a ) <NEWLINE> a_dict = { key : key * value for key , value in a_dict . items ( ) } <NEWLINE> answer = sum ( a_dict . values ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = 0 <NEWLINE> if b in a_dict : <NEWLINE> <INDENT> b_sum = a_dict . pop ( b ) <NEWLINE> c_add = b_sum // b * c <NEWLINE> diff = c_add - b_sum <NEWLINE> if c in a_dict : <NEWLINE> <INDENT> a_dict [ c ] += c_add <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ c ] = c_add <NEWLINE> <DEDENT> <DEDENT> answer += diff <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> def trial_division ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N = trial_division ( int ( input ( ) ) ) <NEWLINE> <NL> key = [ ] <NEWLINE> val = [ ] <NEWLINE> <NL> dupli = set ( ) <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if ( not N [ i ] in dupli ) : <NEWLINE> <INDENT> key . append ( N [ i ] ) <NEWLINE> dupli . add ( N [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( key ) ) : <NEWLINE> <INDENT> val . append ( N . count ( key [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> def maxvalue ( n ) : <NEWLINE> <INDENT> if ( n < 3 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif ( n < 6 ) : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif ( n < 10 ) : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif ( n < 15 ) : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif ( n < 21 ) : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> elif ( n < 28 ) : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> elif ( n < 36 ) : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif ( n < 45 ) : <NEWLINE> <INDENT> return 8 <NEWLINE> <DEDENT> elif ( n < 55 ) : <NEWLINE> <INDENT> return 9 <NEWLINE> <DEDENT> elif ( n < 66 ) : <NEWLINE> <INDENT> return 10 <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( len ( key ) ) : <NEWLINE> <INDENT> sum += maxvalue ( val [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , B = NMI ( ) <NEWLINE> GCD = math . gcd ( A , B ) <NEWLINE> N = GCD <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> ls = [ ] <NEWLINE> <NL> for n in range ( 2 , int ( N ** 0.5 ) + 2 ) : <NEWLINE> <NL> <INDENT> if GCD % n == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> while GCD % n == 0 : <NEWLINE> <INDENT> GCD = GCD // n <NEWLINE> ls . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if GCD == 1 : <NEWLINE> <INDENT> print ( cnt + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt + 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 10 ** 6 + 1 <NEWLINE> <NL> cnt = [ 0 ] * M <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if cnt [ a ] != 0 : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for b in range ( a , M , a ) : <NEWLINE> <INDENT> cnt [ b ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cnt [ a ] == 1 : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> n = len ( s ) <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> total = 0 <NEWLINE> ans = 0 <NEWLINE> x = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> total += int ( s [ i ] ) * x <NEWLINE> total %= 2019 <NEWLINE> x *= 10 <NEWLINE> x %= 2019 <NEWLINE> ans += cnt [ total ] <NEWLINE> cnt [ total ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> I = input ( ) <NEWLINE> <NL> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( I [ i ] == <STRING> ) : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> if ( I [ i ] == <STRING> ) : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> if ( I [ i ] == <STRING> ) : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sum = R * G * B <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if I [ i ] != I [ j ] : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if I [ i ] != I [ k ] and I [ j ] != I [ k ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> table = [ [ - 1 for i in range ( max ( M ) + 1 ) ] for j in range ( n ) ] <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif table [ i ] [ m ] != - 1 : <NEWLINE> <INDENT> return table [ i ] [ m ] <NEWLINE> <DEDENT> elif m - A [ i ] >= 0 : <NEWLINE> <INDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> table [ i ] [ m ] = res <NEWLINE> return res <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = solve ( i + 1 , m ) <NEWLINE> table [ i ] [ m ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = r ** 2 * math . pi <NEWLINE> circumference = 2 * r * math . pi <NEWLINE> print ( <STRING> . format ( area , circumference ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Flag = False <NEWLINE> MAXC = 0 <NEWLINE> Cout = 0 <NEWLINE> for TN in range ( 0 , N ) : <NEWLINE> <INDENT> D1 , D2 = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> if Flag == False and D1 == D2 : <NEWLINE> <INDENT> Flag = True <NEWLINE> Cout = 1 <NEWLINE> <DEDENT> elif Flag == True and D1 == D2 : <NEWLINE> <INDENT> Cout += 1 <NEWLINE> <DEDENT> elif Flag == True and D1 != D2 : <NEWLINE> <INDENT> Flag = False <NEWLINE> MAXC = max ( MAXC , Cout ) <NEWLINE> <DEDENT> <DEDENT> MAXC = [ MAXC , max ( MAXC , Cout ) ] [ Flag ] <NEWLINE> print ( [ <STRING> , <STRING> ] [ MAXC >= 3 ] ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = np . zeros ( n ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> c [ ai - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( int ( c [ i ] ) ) <NEWLINE> <DEDENT>
n , * x = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> xr = { } <NEWLINE> xl = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> xrt = i + x [ i ] <NEWLINE> if xrt < n : <NEWLINE> <INDENT> if xrt in xr : <NEWLINE> <INDENT> xr [ xrt ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xr [ xrt ] = 1 <NEWLINE> <DEDENT> <DEDENT> xlt = i - x [ i ] <NEWLINE> if xlt >= 0 : <NEWLINE> <INDENT> if xlt in xl : <NEWLINE> <INDENT> xl [ xlt ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xl [ xlt ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in xr . keys ( ) : <NEWLINE> <INDENT> if i in xl : <NEWLINE> <INDENT> ans += xr [ i ] * xl [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> from functools import reduce <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def prod ( x , y ) : <NEWLINE> <INDENT> return x * y % MOD <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> if K % 2 == 1 : <NEWLINE> <INDENT> flg = True <NEWLINE> for a in a_list : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( reduce ( prod , a_list [ : K ] ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> S = [ ] <NEWLINE> a_list = deque ( a_list ) <NEWLINE> i = 0 <NEWLINE> while i < K : <NEWLINE> <INDENT> if len ( a_list ) >= 2 : <NEWLINE> <INDENT> if a_list [ 0 ] * a_list [ 1 ] > a_list [ - 1 ] * a_list [ - 2 ] : <NEWLINE> <INDENT> S . append ( a_list . popleft ( ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif a_list [ 0 ] * a_list [ 1 ] <= a_list [ - 1 ] * a_list [ - 2 ] and i <= K - 2 : <NEWLINE> <INDENT> S . append ( a_list . pop ( ) ) <NEWLINE> S . append ( a_list . pop ( ) ) <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( a_list . popleft ( ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> S . append ( a_list . popleft ( ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = reduce ( prod , S ) <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ 0 ] * N , [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> l [ b - 1 ] = 1 <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> r [ a - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if l [ i ] + r [ i ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c , d = [ 0 ] * q , [ 0 ] * q , [ 0 ] * q , [ 0 ] * q <NEWLINE> score = [ 0 ] * n <NEWLINE> ans = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def calc_score ( score ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if score [ b [ i ] - 1 ] - score [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> ret += d [ i ] <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def dfs ( score , i , num ) : <NEWLINE> <INDENT> global ans <NEWLINE> if i == n : <NEWLINE> <INDENT> ans = max ( ans , calc_score ( score ) ) <NEWLINE> return <NEWLINE> <DEDENT> for j in range ( num , m + 1 ) : <NEWLINE> <INDENT> score [ i ] = j <NEWLINE> dfs ( score , i + 1 , j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( score , 0 , 1 ) <NEWLINE> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> @ njit <NEWLINE> def main ( A , B ) : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> B [ a ] += 1 <NEWLINE> <NL> <DEDENT> for a in set ( A ) : <NEWLINE> <INDENT> v = 2 * a <NEWLINE> while v <= 10 ** 6 : <NEWLINE> <INDENT> B [ v ] += 1 <NEWLINE> v += a <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if B [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> main ( np . array ( A ) , np . array ( B ) ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> self . size = [ 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . size [ y ] += self . size [ x ] <NEWLINE> self . parents [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . size [ x ] += self . size [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def msize ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . size [ self . find ( x ) ] <NEWLINE> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( u - 1 , v - 1 ) <NEWLINE> <DEDENT> print ( uf . group_count ( ) - 1 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def v ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> if A . count ( 0 ) > 0 : return 0 <NEWLINE> else : <NEWLINE> <INDENT> A = list ( filter ( lambda x : x > 1 , A ) ) <NEWLINE> x = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> x *= a <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <DEDENT> <DEDENT> def main ( ) : print ( v ( ) ) <NEWLINE> if __name__ == <STRING> : main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> P . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += P [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> B = 4 <NEWLINE> F = 3 <NEWLINE> R = 10 <NEWLINE> SHARPS = 20 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> info_number = int ( input ( ) ) <NEWLINE> given_info_str = ( info . split ( ) for info in ( <NEWLINE> <INDENT> input ( ) for _ in range ( info_number ) ) ) <NEWLINE> <DEDENT> given_info_int = ( list ( map ( int , info ) ) for info in given_info_str ) <NEWLINE> houses = [ [ [ 0 for i in range ( R ) ] for j in range ( F ) ] for k in range ( B ) ] <NEWLINE> for info in given_info_int : <NEWLINE> <INDENT> houses [ info [ 0 ] - 1 ] [ info [ 1 ] - 1 ] [ info [ 2 ] - 1 ] += info [ 3 ] <NEWLINE> <DEDENT> for num , building in enumerate ( houses ) : <NEWLINE> <INDENT> for floor in building : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , floor ) ) ) <NEWLINE> <DEDENT> if num < ( B - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = ( n ) * ( n - 1 ) // 2 <NEWLINE> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> day_sum = 0 <NEWLINE> year , month , day = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> day_sum += 1 <NEWLINE> <NL> if year % 3 == 0 or month % 2 == 1 : <NEWLINE> <INDENT> day_sum += 20 - day <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> day_sum += 19 - day <NEWLINE> <NL> <DEDENT> for m in range ( month + 1 , 11 ) : <NEWLINE> <INDENT> if year % 3 == 0 or m % 2 == 1 : <NEWLINE> <INDENT> day_sum += 20 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> day_sum += 19 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for y in range ( 1 , 1000 - year ) : <NEWLINE> <INDENT> for m in range ( 1 , 11 ) : <NEWLINE> <INDENT> if ( year + y ) % 3 == 0 or m % 2 == 1 : <NEWLINE> <INDENT> day_sum += 20 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> day_sum += 19 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( day_sum ) <NEWLINE> <DEDENT>
<COMMENT> <NL> class fenwick_tree : <NEWLINE> <INDENT> def __init__ ( s , n ) : <NEWLINE> <INDENT> s . _n = n <NEWLINE> s . data = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def add ( s , p , x ) : <NEWLINE> <INDENT> p += 1 <NEWLINE> while p <= s . _n : <NEWLINE> <INDENT> s . data [ p - 1 ] += x <NEWLINE> p += p & - p <NEWLINE> <NL> <DEDENT> <DEDENT> def sumlr ( s , l , r ) : <NEWLINE> <INDENT> return s . sum ( r ) - s . sum ( l ) <NEWLINE> <NL> <DEDENT> def sum ( self , r ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while r > 0 : <NEWLINE> <INDENT> s += self . data [ r - 1 ] <NEWLINE> r -= r & - r <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Query = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> bit = fenwick_tree ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> bit . add ( i , a [ i ] ) <NEWLINE> <NL> <DEDENT> for q in Query : <NEWLINE> <INDENT> if q [ 0 ] == 0 : <NEWLINE> <INDENT> _ , p , x = q <NEWLINE> bit . add ( p , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _ , l , r = q <NEWLINE> print ( bit . sumlr ( l , r ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = 2019 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = input ( ) . rstrip ( ) <NEWLINE> n = len ( s ) <NEWLINE> d = { } <NEWLINE> d [ 0 ] = 1 <NEWLINE> ten = 1 <NEWLINE> T = 0 <NEWLINE> for x in reversed ( s ) : <NEWLINE> <INDENT> T += ten * int ( x ) <NEWLINE> ten *= 10 <NEWLINE> T %= mod <NEWLINE> ten %= mod <NEWLINE> if T in d : <NEWLINE> <INDENT> d [ T ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ T ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in d . values ( ) ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> ans = 0 <NEWLINE> max = l [ N - 1 ] <NEWLINE> tc = N <NEWLINE> st = [ j + 1 for j in range ( N - 1 ) ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if l [ i ] + l [ i + 1 ] > max : <NEWLINE> <INDENT> k = N - i - 1 <NEWLINE> ans += ( ( k - 1 ) * k * ( k + 1 ) ) // 6 <NEWLINE> break <NEWLINE> <DEDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if j == tc : <NEWLINE> <INDENT> ans += tp <NEWLINE> break <NEWLINE> <DEDENT> s = l [ i ] + l [ j ] <NEWLINE> if s <= l [ j + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s > max : <NEWLINE> <INDENT> tc = j <NEWLINE> tp = ( N - j - 1 ) * ( N - j ) // 2 <COMMENT> <NEWLINE> ans += tp <NEWLINE> break <NEWLINE> <DEDENT> start = st [ j ] <NEWLINE> if s <= l [ start ] : <NEWLINE> <INDENT> ans += start - j - 1 <NEWLINE> continue <NEWLINE> <DEDENT> end = N <NEWLINE> while start != end : <NEWLINE> <INDENT> center = ( start + end ) // 2 <NEWLINE> if s <= l [ center ] : <NEWLINE> <INDENT> end = center <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = center + 1 <NEWLINE> <DEDENT> <DEDENT> st [ j ] = end <NEWLINE> ans += end - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> x1 , x2 , x3 , x4 = map ( float , input ( ) . split ( ) ) <NEWLINE> n = ( x3 - x1 ) ** 2 + ( x4 - x2 ) ** 2 <NEWLINE> ans = math . sqrt ( n ) <NEWLINE> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if c [ 0 ] == 0 : <NEWLINE> <INDENT> heapq . heappush ( a [ c [ 1 ] ] , - c [ 2 ] ) <NEWLINE> <DEDENT> elif c [ 0 ] == 1 : <NEWLINE> <INDENT> if a [ c [ 1 ] ] : <NEWLINE> <INDENT> print ( - a [ c [ 1 ] ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ c [ 1 ] ] : <NEWLINE> <INDENT> heapq . heappop ( a [ c [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
Row = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s = 1 <NEWLINE> res = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> s = List [ s - 1 ] <NEWLINE> res += 1 <NEWLINE> if s == 2 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> print ( t . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> val = sum ( a [ : K ] ) <NEWLINE> max_val = val <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> val += a [ K + i ] <NEWLINE> val -= a [ i ] <NEWLINE> max_val = max ( val , max_val ) <NEWLINE> <DEDENT> print ( max_val / 2 + K * 0.5 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> ok = 0 <NEWLINE> ans = 1 <NEWLINE> lim = 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > lim ) : <NEWLINE> <INDENT> ok = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( ok and 0 not in A ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif ( 0 in A ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> za , wa = - 10 ** 10 , - 10 ** 10 <NEWLINE> zi , wi = 10 ** 10 , 10 ** 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> z = arr [ i ] [ 0 ] + arr [ i ] [ 1 ] <NEWLINE> w = arr [ i ] [ 0 ] - arr [ i ] [ 1 ] <NEWLINE> <NL> za = max ( z , za ) <NEWLINE> zi = min ( z , zi ) <NEWLINE> <NL> wa = max ( w , wa ) <NEWLINE> wi = min ( w , wi ) <NEWLINE> <NL> <DEDENT> print ( max ( za - zi , wa - wi ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> while y == 0 : <NEWLINE> <INDENT> a = x + z <NEWLINE> b = x - z <NEWLINE> if a in p and b in p : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> elif a not in p and b in p : <NEWLINE> <INDENT> print ( a ) <NEWLINE> y = 4 <NEWLINE> <DEDENT> elif b not in p : <NEWLINE> <INDENT> print ( b ) <NEWLINE> y = 5 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flg = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if flg == 1 and li [ i ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif li [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= li [ i ] <NEWLINE> <DEDENT> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> <DEDENT> if flg == 1 and ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif flg == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def root ( list_parent , x ) : <NEWLINE> <INDENT> if ( list_parent [ x ] == x ) : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list_parent [ x ] = root ( list_parent , list_parent [ x ] ) <NEWLINE> return list_parent [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( list_parent , x , y ) : <NEWLINE> <INDENT> x = root ( list_parent , x ) <NEWLINE> y = root ( list_parent , y ) <NEWLINE> <NL> if ( x == y ) : <NEWLINE> <INDENT> return list_parent <NEWLINE> <NL> <DEDENT> if x > y : <NEWLINE> <INDENT> list_parent [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list_parent [ x ] = y <NEWLINE> <NL> <DEDENT> return list_parent <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> list_parent = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> list_parent . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> list_parent = unite ( list_parent , A - 1 , B - 1 ) <NEWLINE> <NL> <DEDENT> set_root = set ( ) <NEWLINE> for i in list_parent : <NEWLINE> <INDENT> root_i = root ( list_parent , i ) <NEWLINE> if root_i not in set_root : <NEWLINE> <INDENT> set_root . add ( root_i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( set_root ) - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = { s } <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( len ( s ) - i ) : a . add ( s [ j : j + i + 1 ] ) <NEWLINE> <DEDENT> print ( sorted ( list ( a ) ) [ k - 1 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += d [ i - a [ i ] ] <NEWLINE> d [ a [ i ] + i ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> <NL> def solve ( input_s : str ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = len ( input_s ) <NEWLINE> mod = 2019 <NEWLINE> dp = defaultdict ( int ) <NEWLINE> cur = 0 <NEWLINE> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> dp [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> cur += pow ( 10 , n - i - 1 , 2019 ) * int ( input_s [ i ] ) % mod <NEWLINE> cur %= mod <NEWLINE> dp [ cur ] += 1 <NEWLINE> <DEDENT> <DEDENT> for v in dp . values ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> print ( solve ( S ) ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> M = [ ] <NEWLINE> con = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> L . append ( i ) <NEWLINE> <DEDENT> L = list ( set ( L ) ) <NEWLINE> L . sort ( ) <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == L [ 0 ] : <NEWLINE> <INDENT> for k in range ( 1 , 6 ) : <NEWLINE> <INDENT> if j + k >= len ( s ) : <NEWLINE> <INDENT> M . append ( s [ j : ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M . append ( s [ j : j + k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( L ) != 1 : <NEWLINE> <INDENT> for l in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ l ] == L [ 1 ] : <NEWLINE> <INDENT> for m in range ( 1 , 6 ) : <NEWLINE> <INDENT> if l + m >= len ( s ) : <NEWLINE> <INDENT> M . append ( s [ l : ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M . append ( s [ l : l + m ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( M ) < K : <NEWLINE> <INDENT> for n in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ n ] == L [ 2 ] : <NEWLINE> <INDENT> for o in range ( 1 , 6 ) : <NEWLINE> <INDENT> if n + o >= len ( s ) : <NEWLINE> <INDENT> M . append ( s [ n : ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M . append ( s [ n : n + o ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> M = list ( set ( M ) ) <NEWLINE> M . sort ( ) <NEWLINE> print ( M [ K - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mx = 10 ** 5 <NEWLINE> table = [ 0 ] * ( mx + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> table [ i ] += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> total = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c , = map ( int , input ( ) . split ( ) ) <NEWLINE> total -= table [ c ] * c + table [ b ] * b <NEWLINE> table [ c ] += table [ b ] <NEWLINE> table [ b ] = 0 <NEWLINE> total += table [ c ] * c <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
def fact ( a ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> while a : <NEWLINE> <INDENT> res *= a <NEWLINE> a -= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> n , m , r = map ( int , input ( ) . split ( ) ) <NEWLINE> r -= n * m <NEWLINE> if r < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( fact ( r + n - 1 ) // fact ( n - 1 ) // fact ( r ) ) <NEWLINE> <DEDENT>
i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , 2 ] ] <NEWLINE> <NL> for a in range ( 3 ) : <NEWLINE> <INDENT> if ( i [ x [ a ] [ 0 ] ] > i [ x [ a ] [ 1 ] ] ) : <NEWLINE> <INDENT> swap = i [ x [ a ] [ 0 ] ] <NEWLINE> i [ x [ a ] [ 0 ] ] = i [ x [ a ] [ 1 ] ] <NEWLINE> i [ x [ a ] [ 1 ] ] = swap <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( i [ 0 ] , end = <STRING> ) <NEWLINE> print ( i [ 1 ] , end = <STRING> ) <NEWLINE> print ( i [ 2 ] , end = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for i in sorted ( arr ) : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> if dp [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , len ( dp ) , i ) : <NEWLINE> <INDENT> dp [ j ] += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> m = 1 - 10 ** 9 <NEWLINE> minv = arr [ 0 ] <NEWLINE> for i in range ( 1 , len ( arr ) ) : <NEWLINE> <INDENT> if arr [ i ] - minv > m : <NEWLINE> <INDENT> m = arr [ i ] - minv <NEWLINE> <DEDENT> minv = min ( minv , arr [ i ] ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> y = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( y ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( Arr [ N - 1 - i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( Arr [ 0 ] ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = range ( 1 , M + 1 ) <NEWLINE> arr = np . asarray ( list ( itertools . combinations_with_replacement ( a , N ) ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> sc = np . zeros ( arr . shape [ 0 ] , dtype = int ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> abcd = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = ( arr [ : , abcd [ 1 ] - 1 ] - arr [ : , abcd [ 0 ] - 1 ] ) == abcd [ 2 ] <NEWLINE> sc += abcd [ 3 ] * f <NEWLINE> <COMMENT> <NL> <DEDENT> print ( sc . max ( ) ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> r = range ( 1 , K + 1 ) <NEWLINE> print ( sum ( gcd ( gcd ( a , b ) , c ) for a in r for b in r for c in r ) ) <NEWLINE>
import math <NEWLINE> a , b , n = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> def calc ( a , b , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> max_x = b <NEWLINE> if b > n : <NEWLINE> <INDENT> max_x = n <NEWLINE> <DEDENT> for x in range ( 1 , max_x + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> r = calc ( a , b , x ) <NEWLINE> if r > ans : <NEWLINE> <INDENT> ans = r <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for b in a : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= b <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def dijkstra ( s , g ) : <NEWLINE> <INDENT> import heapq <NEWLINE> <NL> n = len ( g ) <NEWLINE> heap = [ ( 0 , s ) ] <NEWLINE> heapq . heapify ( heap ) <NEWLINE> <NL> prev = [ - 1 ] * n <NEWLINE> cost = [ float ( <STRING> ) ] * n <NEWLINE> cost [ s ] = 0 <NEWLINE> <NL> while heap : <NEWLINE> <INDENT> c , v = heapq . heappop ( heap ) <NEWLINE> x = cost [ v ] <NEWLINE> if c > x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for d , u in g [ v ] : <NEWLINE> <INDENT> path = d + x <NEWLINE> if path < cost [ u ] : <NEWLINE> <INDENT> cost [ u ] = path <NEWLINE> prev [ u ] = v <NEWLINE> heapq . heappush ( heap , ( path , u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return prev <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> from itertools import accumulate <NEWLINE> from collections import deque <NEWLINE> <NL> n , * uv = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i , j in zip ( * [ iter ( uv ) ] * 2 ) : <NEWLINE> <INDENT> g [ i ] . append ( [ 1 , j ] ) <NEWLINE> g [ j ] . append ( [ 1 , i ] ) <NEWLINE> <NL> <DEDENT> dk = dijkstra ( n , g ) <NEWLINE> <NL> vis = [ False ] * ( n + 1 ) <NEWLINE> <NL> def f ( now , c ) : <NEWLINE> <INDENT> if vis [ now ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> vis [ now ] = True <NEWLINE> cnt = 1 <NEWLINE> for _ , nxt in g [ now ] : <NEWLINE> <INDENT> cnt += f ( nxt , c ) <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> nw = dk [ 1 ] <NEWLINE> <NL> cnt = [ ] <NEWLINE> vis [ 1 ] = True <NEWLINE> vis [ n ] = True <NEWLINE> while nw != n : <NEWLINE> <INDENT> nx = dk [ nw ] <NEWLINE> vis [ nx ] = True <NEWLINE> tmp = f ( nw , 0 ) <NEWLINE> vis [ nx ] = False <NEWLINE> cnt . append ( tmp ) <NEWLINE> nw = nx <NEWLINE> <NL> <DEDENT> fn = 0 <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> vis [ 1 ] = False <NEWLINE> <NL> while q : <NEWLINE> <INDENT> i = q . popleft ( ) <NEWLINE> if vis [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> vis [ i ] = True <NEWLINE> fn += 1 <NEWLINE> for _ , j in g [ i ] : <NEWLINE> <INDENT> q . appendleft ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> * a , = accumulate ( cnt ) <NEWLINE> l = len ( a ) <NEWLINE> k = l // 2 - 1 if l % 2 == 0 else l // 2 <NEWLINE> fn += a [ k ] if l > 0 else 0 <NEWLINE> sn = n - fn <NEWLINE> <NL> print ( <STRING> if fn > sn else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> stdIn1 , stdIn2 = map ( int , input ( ) . split ( ) ) <NEWLINE> stdOut = solve ( stdIn1 , stdIn2 ) <NEWLINE> print ( stdOut ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <NL> def solve ( k , s ) : <NEWLINE> <INDENT> pattern = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> if x > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if x + y > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z = s - x - y <NEWLINE> if z <= k : <NEWLINE> <INDENT> pattern += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return pattern <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> output = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> output = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> output *= i <NEWLINE> if output > 10 ** 18 : <NEWLINE> <INDENT> output = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ 0 ] * 3 <NEWLINE> ans = 1 <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= data . count ( i ) <NEWLINE> ans %= mod <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data [ data . index ( i ) ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> abc = [ chr ( i ) for i in range ( 97 , 123 ) ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = <STRING> <NEWLINE> <NL> L = 0 <NEWLINE> for i in range ( 1 , 12 ) : <NEWLINE> <INDENT> if N >= 26 ** i : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = i <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if N == 0 : <NEWLINE> <INDENT> for i in range ( L - 1 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( L , 1 , - 1 ) : <NEWLINE> <INDENT> if N <= 26 ** ( i - 1 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , 26 ) : <NEWLINE> <INDENT> if 26 ** ( i - 1 ) * j < N and 26 ** ( i - 1 ) * ( j + 1 ) >= N : <NEWLINE> <INDENT> ans += abc [ j ] <NEWLINE> N -= 26 ** ( i - 1 ) * j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans += abc [ N - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL>
s = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> sum_a = sum ( a ) <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> sum_a -= a [ i ] <NEWLINE> ans += sum_a * a [ i ] % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import math <NEWLINE> <NL> def factorize ( n ) : <NEWLINE> <INDENT> p = n <NEWLINE> while True : <NEWLINE> <INDENT> if p % 2 == 0 : <NEWLINE> <INDENT> p //= 2 <NEWLINE> yield 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> r = 3 <NEWLINE> while r < int ( math . sqrt ( p ) + 1 ) : <NEWLINE> <INDENT> if p % r == 0 : <NEWLINE> <INDENT> p //= r <NEWLINE> yield r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if p != 1 : <NEWLINE> <INDENT> yield p <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = factorize ( n ) <NEWLINE> <NL> print ( str ( n ) + <STRING> , * list ( l ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> H . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> H . sort ( ) <NEWLINE> ans = 10 ** 9 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , H [ i + K - 1 ] - H [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class Card : <NEWLINE> <INDENT> def __init__ ( self , suit , value ) : <NEWLINE> <INDENT> self . suit = suit <NEWLINE> self . value = value <NEWLINE> <NL> <DEDENT> <DEDENT> def selection ( ls ) : <NEWLINE> <INDENT> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> minj = i <NEWLINE> <NL> for j in range ( i , len ( ls ) ) : <NEWLINE> <INDENT> if ls [ j ] . value < ls [ minj ] . value : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> ls [ i ] , ls [ minj ] = ls [ minj ] , ls [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def bubblesort ( ls ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( ls ) ) : <NEWLINE> <INDENT> for j in reversed ( range ( i , len ( ls ) ) ) : <NEWLINE> <INDENT> if ls [ j ] . value < ls [ j - 1 ] . value : <NEWLINE> <INDENT> ls [ j ] , ls [ j - 1 ] = ls [ j - 1 ] , ls [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def isStable ( ls1 , ls2 ) : <NEWLINE> <INDENT> if ls1 == ls2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def printcards ( cards ) : <NEWLINE> <INDENT> for x in range ( len ( cards ) ) : <NEWLINE> <INDENT> if x == len ( cards ) - 1 : <NEWLINE> <INDENT> print ( cards [ x ] . suit + cards [ x ] . value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cards [ x ] . suit + cards [ x ] . value , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> cards = [ ] <NEWLINE> for card in list ( input ( ) . split ( <STRING> ) ) : <NEWLINE> <INDENT> cards . append ( Card ( card [ 0 ] , card [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> a = [ x for x in cards ] <NEWLINE> b = [ x for x in cards ] <NEWLINE> <NL> <NL> bubblesort ( a ) <NEWLINE> selection ( b ) <NEWLINE> <NL> printcards ( a ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> printcards ( b ) <NEWLINE> isStable ( a , b ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> from collections import deque <NEWLINE> <NL> functions = { <STRING> : lambda obj , x : obj . insert ( x ) , <NEWLINE> <INDENT> <STRING> : lambda obj , x : obj . delete ( x ) , <NEWLINE> <STRING> : lambda obj : obj . deleteFirst ( ) , <NEWLINE> <STRING> : lambda obj : obj . deleteLast ( ) } <NEWLINE> <NL> <NL> <DEDENT> class DoublyLinkedList ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . list = deque ( ) <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> self . list . appendleft ( x ) <NEWLINE> <NL> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if x in self . list : <NEWLINE> <INDENT> self . list . remove ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> self . list . popleft ( ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . list . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> q = deque ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> if command [ 1 ] in q : <NEWLINE> <INDENT> q . remove ( command [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , q ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x ) - k * d >= 0 : <NEWLINE> <INDENT> print ( abs ( x ) - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xx , kk = abs ( x ) - d * ( abs ( x ) // d ) , k - ( abs ( x ) // d ) <NEWLINE> if kk % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( xx ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( xx - d ) ) <NEWLINE> <DEDENT> <DEDENT>
def freq ( my_list ) : <NEWLINE> <INDENT> count = { } <NEWLINE> for i in my_list : <NEWLINE> <INDENT> count [ i ] = count . get ( i , 0 ) + 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s , f = sum ( l ) , freq ( l ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x in f . keys ( ) : <NEWLINE> <INDENT> v = f [ x ] <NEWLINE> if y in f . keys ( ) : <NEWLINE> <INDENT> f [ y ] += v <NEWLINE> f . pop ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f [ y ] = f . pop ( x ) <NEWLINE> <DEDENT> s += ( y - x ) * v <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> l = lis [ i - k ] <NEWLINE> r = lis [ i ] <NEWLINE> if r > l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> result = 0 <NEWLINE> <NL> num = [ 1 , 3 , 6 , 10 , 15 , 21 , 28 , 36 , 45 , 55 , 66 ] <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> L = factorization ( N ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for p , e in L : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> for i in range ( 2 , 100 ) : <NEWLINE> <INDENT> cnt += i <NEWLINE> if e < cnt : <NEWLINE> <INDENT> result += i - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <STRING> <NEWLINE> s , s2 = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> s2 += a [ i ] * a [ i ] <NEWLINE> <DEDENT> print ( ( ( s * s - s2 ) // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> N , M , Q = LI ( ) <NEWLINE> <NL> abcd = [ ] <NEWLINE> <NL> all = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = LI ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> abcd . append ( [ a , b , c , d ] ) <NEWLINE> all += d <NEWLINE> <NL> <DEDENT> abcd = sorted ( abcd , key = lambda x : x [ 3 ] , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> if Q <= 2 : <NEWLINE> <INDENT> for q in range ( Q ) : <NEWLINE> <INDENT> ans += abcd [ q ] [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> def cal_ans ( A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = abcd [ i ] <NEWLINE> if A [ b ] - A [ a ] == c : <NEWLINE> <INDENT> ans += d <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def n2kdigit ( n , k ) : <NEWLINE> <INDENT> bi = <STRING> <NEWLINE> before = 1 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> if before <= ( n % k ) : <NEWLINE> <COMMENT> <NL> <INDENT> bi += str ( n % abs ( k ) ) <NEWLINE> before = n % k <NEWLINE> if k < 0 : n = - ( - n // k ) <NEWLINE> else : n = n // k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT> if len ( bi ) < N : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> return bi <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> for i in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans = max ( ans , cal_ans ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def cross_section_area ( data ) : <NEWLINE> <INDENT> area = 0 ; <NEWLINE> sections = [ ] ; <NEWLINE> stack = [ ] ; <NEWLINE> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> if data [ i ] == <STRING> : <NEWLINE> <INDENT> stack . append ( i ) ; <NEWLINE> <DEDENT> elif data [ i ] == <STRING> and len ( stack ) > 0 : <NEWLINE> <INDENT> j = stack . pop ( ) ; <NEWLINE> section_area = i - j ; <NEWLINE> area += section_area ; <NEWLINE> while len ( sections ) > 0 and sections [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> section_area += sections [ - 1 ] [ 1 ] ; <NEWLINE> sections . pop ( ) ; <NEWLINE> <DEDENT> sections . append ( [ j , section_area ] ) ; <NEWLINE> <DEDENT> <DEDENT> print ( area ) ; <NEWLINE> print ( len ( sections ) , * [ n [ 1 ] for n in sections ] ) ; <NEWLINE> <NL> <DEDENT> cross_section_area ( input ( ) ) ; <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> NA = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> NA . append ( A [ i ] - i ) <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> <NL> d = Counter ( NA ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> cnt += d [ - i - A [ i ] ] <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ave = [ 0 for i in range ( n - k + 1 ) ] <NEWLINE> <NL> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ i + k ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> result += math . gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> g = n * m // math . gcd ( n , m ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> for i in range ( math . gcd ( n , m ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ i * ( g // m ) ] != t [ i * ( g // n ) ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> def dfs ( here , p , d , parent , depth , connect ) : <NEWLINE> <INDENT> parent [ 0 ] [ here ] = p <NEWLINE> depth [ here ] = d <NEWLINE> for next_v in connect [ here ] : <NEWLINE> <INDENT> dfs ( next_v , here , d + 1 , parent , depth , connect ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lca ( v1 , v2 , parent , depth ) : <NEWLINE> <INDENT> if depth [ v2 ] > depth [ v1 ] : <NEWLINE> <INDENT> v1 , v2 = v2 , v1 <NEWLINE> <DEDENT> for i in range ( max_log ) : <NEWLINE> <INDENT> if depth [ v1 ] - depth [ v2 ] >> i & 1 : <NEWLINE> <INDENT> v1 = parent [ i ] [ v1 ] <NEWLINE> <DEDENT> <DEDENT> if v1 == v2 : <NEWLINE> <INDENT> return v2 <NEWLINE> <DEDENT> for i in range ( max_log - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if parent [ i ] [ v1 ] != parent [ i ] [ v2 ] : <NEWLINE> <INDENT> v1 = parent [ i ] [ v1 ] <NEWLINE> v2 = parent [ i ] [ v2 ] <NEWLINE> <DEDENT> <DEDENT> return parent [ 0 ] [ v1 ] <NEWLINE> <NL> <DEDENT> connect = defaultdict ( list ) <NEWLINE> v_num = int ( input ( ) ) <NEWLINE> root = 0 <NEWLINE> for i in range ( v_num ) : <NEWLINE> <INDENT> edge = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> connect [ i ] . extend ( edge [ 1 : ] ) <NEWLINE> <DEDENT> depth = [ - 1 for n in range ( v_num ) ] <NEWLINE> max_log = max ( int ( math . log ( v_num , 2 ) ) , 1 ) <NEWLINE> parent = [ [ - 1 for n in range ( v_num ) ] for m in range ( max_log ) ] <NEWLINE> dfs ( root , - 1 , 0 , parent , depth , connect ) <NEWLINE> for i in range ( max_log - 1 ) : <NEWLINE> <INDENT> for v in range ( v_num ) : <NEWLINE> <INDENT> parent [ i + 1 ] [ v ] = - 1 if parent [ i ] [ v ] < 0 else parent [ i ] [ parent [ i ] [ v ] ] <NEWLINE> <DEDENT> <DEDENT> q_num = int ( input ( ) ) <NEWLINE> for _ in range ( q_num ) : <NEWLINE> <INDENT> v1 , v2 = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> print ( lca ( v1 , v2 , parent , depth ) ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - x - y <NEWLINE> if 0 <= z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> <NL> def solve ( data ) : <NEWLINE> <INDENT> size = len ( data [ 0 ] ) <NEWLINE> data . insert ( 0 , [ <STRING> for _ in range ( size ) ] ) <NEWLINE> data . insert ( len ( data ) , [ <STRING> for _ in range ( size ) ] ) <NEWLINE> <NL> processing_area = [ ] <NEWLINE> area_id = 0 <NEWLINE> for y in range ( 1 , len ( data ) ) : <NEWLINE> <INDENT> for x in range ( 1 , len ( data [ 0 ] ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> mark = data [ y ] [ x ] <NEWLINE> data [ y ] [ x ] = <STRING> <NEWLINE> if mark != <STRING> : <NEWLINE> <INDENT> area_id += 1 <NEWLINE> processing_area . append ( ( y , x ) ) <NEWLINE> <NL> while processing_area : <NEWLINE> <INDENT> yy , xx = processing_area . pop ( ) <NEWLINE> if data [ yy - 1 ] [ xx ] == mark : <NEWLINE> <INDENT> data [ yy - 1 ] [ xx ] = <STRING> <NEWLINE> processing_area . append ( ( yy - 1 , xx ) ) <NEWLINE> <DEDENT> if data [ yy + 1 ] [ xx ] == mark : <NEWLINE> <INDENT> data [ yy + 1 ] [ xx ] = <STRING> <NEWLINE> processing_area . append ( ( yy + 1 , xx ) ) <NEWLINE> <DEDENT> if data [ yy ] [ xx - 1 ] == mark : <NEWLINE> <INDENT> data [ yy ] [ xx - 1 ] = <STRING> <NEWLINE> processing_area . append ( ( yy , xx - 1 ) ) <NEWLINE> <DEDENT> if data [ yy ] [ xx + 1 ] == mark : <NEWLINE> <INDENT> data [ yy ] [ xx + 1 ] = <STRING> <NEWLINE> processing_area . append ( ( yy , xx + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> mark = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return area_id <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> while True : <NEWLINE> <INDENT> h , w = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> temp = list ( input ( ) ) <NEWLINE> temp . insert ( 0 , <STRING> ) <NEWLINE> temp . append ( <STRING> ) <NEWLINE> data . append ( temp ) <NEWLINE> <NL> <DEDENT> result = solve ( data ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> q = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a = input ( ) . split ( <STRING> ) <NEWLINE> if len ( a ) == 1 : <NEWLINE> <INDENT> q . append ( [ int ( a [ 0 ] ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( [ int ( a [ 0 ] ) , int ( a [ 1 ] ) , a [ 2 ] ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def switch ( s ) : <NEWLINE> <INDENT> d = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> d += s [ len ( s ) - i - 1 ] <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> H = <STRING> <NEWLINE> B = <STRING> <NEWLINE> <NL> direction = 1 <COMMENT> <NEWLINE> <NL> for t in range ( len ( q ) ) : <NEWLINE> <INDENT> T = q [ t ] <NEWLINE> if T [ 0 ] == 1 : <NEWLINE> <INDENT> direction *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> F = T [ 1 ] <NEWLINE> C = T [ 2 ] <NEWLINE> if F == 1 : <NEWLINE> <INDENT> if direction == 1 : <NEWLINE> <INDENT> H += C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += C <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if direction == 1 : <NEWLINE> <INDENT> B += C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H += C <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if direction == 1 : <NEWLINE> <INDENT> print ( switch ( H ) + S + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( switch ( B ) + switch ( S ) + H ) <NEWLINE> <DEDENT>
count = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if ( x == 0 ) : break <NEWLINE> print ( <STRING> . format ( count , x ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
b = { } <NEWLINE> for _ in range ( int ( input ( ) ) ) : s = input ( ) ; b [ s ] = b . get ( s , 0 ) + 1 <NEWLINE> m = max ( b . values ( ) ) <NEWLINE> print ( * sorted ( k for k in b if b [ k ] == m ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = [ 0 ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> sum_a [ 0 ] += a [ i ] <NEWLINE> <NL> <DEDENT> j = 0 <NEWLINE> <NL> max_v = sum_a [ 0 ] <NEWLINE> ele = K - 1 <NEWLINE> expected_value = 0 <NEWLINE> <COMMENT> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> sum_a . append ( sum_a [ j ] + ( a [ i ] - a [ i - K ] ) ) <NEWLINE> if max_v < sum_a [ j + 1 ] : <NEWLINE> <INDENT> max_v = sum_a [ j + 1 ] <NEWLINE> ele = i <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> s_ele = ele + 1 - K <NEWLINE> for n in range ( s_ele , ele + 1 ) : <NEWLINE> <INDENT> expected_value += ( a [ n ] * 0.5 ) + 0.5 <NEWLINE> <DEDENT> print ( expected_value ) <NEWLINE>
cnt = 0 <NEWLINE> m = 0 <NEWLINE> g = [ ] <NEWLINE> <NL> def insertion_sort ( a , n , g ) : <NEWLINE> <COMMENT> <NL> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> k = i - g <NEWLINE> while k >= 0 and a [ k ] > v : <NEWLINE> <INDENT> a [ k + g ] = a [ k ] <NEWLINE> k -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> a [ k + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shell_sort ( a , n ) : <NEWLINE> <INDENT> global m , g <NEWLINE> h = 1 <NEWLINE> while h <= n : <NEWLINE> <INDENT> g . append ( h ) <NEWLINE> h = h * 3 + 1 <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertion_sort ( a , n , g [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> shell_sort ( a , n ) <NEWLINE> print ( m ) <NEWLINE> print ( * g ) <NEWLINE> print ( cnt ) <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n , r = divmod ( n - 1 , 26 ) <NEWLINE> ans = chr ( r + ord ( <STRING> ) ) + ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> x = gcd ( a , b , c ) <NEWLINE> bai = sum ( [ a == b , b == c , a == c ] ) <NEWLINE> if bai == 0 : <NEWLINE> <INDENT> num += x * 6 <NEWLINE> <DEDENT> elif bai == 1 : <NEWLINE> <INDENT> num += x * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> ans *= a <NEWLINE> <NL> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
nml = input ( ) . split ( ) <NEWLINE> n , m , l = map ( int , nml ) <NEWLINE> <NL> A = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( n ) ] <NEWLINE> B = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( m ) ] <NEWLINE> <NL> C = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( l ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> s += A [ j ] [ k ] * B [ k ] [ i ] <NEWLINE> <DEDENT> C [ j ] [ i ] = s <NEWLINE> <NL> <DEDENT> <DEDENT> for i in C : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , i ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def parent ( i ) : <NEWLINE> <INDENT> return math . floor ( i / 2 ) <NEWLINE> <NL> <DEDENT> def left ( i ) : <NEWLINE> <INDENT> return 2 * i <NEWLINE> <NL> <DEDENT> def right ( i ) : <NEWLINE> <INDENT> return 2 * i + 1 <NEWLINE> <NL> <DEDENT> def get_largest ( A , n , i ) : <NEWLINE> <INDENT> l = left ( i ) <NEWLINE> r = right ( i ) <NEWLINE> largest = None <NEWLINE> if l <= n and A [ i ] < A [ l ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= n and A [ largest ] < A [ r ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> return largest <NEWLINE> <NL> <NL> <DEDENT> def max_heapify ( A , n , i ) : <NEWLINE> <INDENT> largest = get_largest ( A , n , i ) <NEWLINE> x = i <NEWLINE> while largest is not x : <NEWLINE> <INDENT> tmp = A [ x ] <NEWLINE> A [ x ] = A [ largest ] <NEWLINE> A [ largest ] = tmp <NEWLINE> x = largest <NEWLINE> largest = get_largest ( A , n , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> def build_max_heap ( A , n ) : <NEWLINE> <INDENT> for i in reversed ( range ( 1 , math . floor ( n / 2 ) + 1 ) ) : <NEWLINE> <INDENT> max_heapify ( A , n , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> heap = [ None ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> build_max_heap ( heap , n ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in heap [ 1 : ] : <NEWLINE> <INDENT> ans += <STRING> . format ( str ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * L , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> from bisect import * <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> while j < N : <NEWLINE> <INDENT> ans += bisect_left ( L , L [ i ] + L [ j ] ) - j - 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> while h : <NEWLINE> <INDENT> h -= 1 <NEWLINE> n = input ( ) <NEWLINE> c = - 1 <NEWLINE> for i in range ( w - 1 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : c = 0 <NEWLINE> print ( c , end = <STRING> ) <NEWLINE> if c != - 1 : c += 1 <NEWLINE> if n [ i + 1 ] == <STRING> : c = 0 <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> val = 7 <NEWLINE> val %= k <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> if ( val == 0 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> val = ( val * 10 + 7 ) % k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> l = a [ left : mid ] + [ sentinel ] <NEWLINE> r = a [ mid : right ] + [ sentinel ] <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if l [ i ] <= r [ j ] : <NEWLINE> <INDENT> a [ k ] = l [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = r [ j ] <NEWLINE> j += 1 <NEWLINE> cnt += mid - left - i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( a , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( a , left , mid ) <NEWLINE> merge_sort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sentinel = 10 ** 9 + 1 <NEWLINE> cnt = 0 <NEWLINE> merge_sort ( a , 0 , len ( a ) ) <NEWLINE> print ( cnt ) <NEWLINE>
MAX_A = 10 ** 6 + 1 <NEWLINE> is_prim = [ True ] * MAX_A <NEWLINE> is_prim [ 0 ] = is_prim [ 1 ] = False <NEWLINE> for i in range ( 2 , MAX_A ) : <NEWLINE> <INDENT> if not is_prim [ i ] : continue <NEWLINE> for j in range ( i + i , MAX_A , i ) : is_prim [ j ] = False <NEWLINE> <DEDENT> prim = [ i for i in range ( MAX_A ) if is_prim [ i ] ] <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> C = [ 0 ] * MAX_A <NEWLINE> for a in A : C [ a ] += 1 <NEWLINE> pairwise = True <NEWLINE> for p in prim : <NEWLINE> <INDENT> if sum ( C [ p : : p ] ) > 1 : pairwise = False <NEWLINE> <DEDENT> if pairwise : return <STRING> <NEWLINE> from math import gcd <NEWLINE> g = 0 <NEWLINE> for a in A : g = gcd ( g , a ) <NEWLINE> if g == 1 : return <STRING> <NEWLINE> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> print ( solve ( ) , <STRING> ) <NEWLINE>
D = 1000000007 <NEWLINE> m , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( pow ( m , n , D ) ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> g = math . gcd ( g , a ) <NEWLINE> <DEDENT> if g != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> is_prime = [ 1 ] * 1000001 <NEWLINE> D = [ 0 ] * 1000001 <NEWLINE> <NL> for i in range ( 2 , 1001 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> D [ i ] = i <NEWLINE> j = 2 * i <NEWLINE> while j <= 1000000 : <NEWLINE> <INDENT> if is_prime [ j ] : <NEWLINE> <INDENT> D [ j ] = i <NEWLINE> is_prime [ j ] = 0 <NEWLINE> <DEDENT> j += i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1001 , 1000001 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> D [ i ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> count = [ 0 ] * 1000001 <NEWLINE> for a in A : <NEWLINE> <INDENT> k = a <NEWLINE> pre = 0 <NEWLINE> while k != 1 : <NEWLINE> <INDENT> if pre != D [ k ] : <NEWLINE> <INDENT> count [ D [ k ] ] += 1 <NEWLINE> if count [ D [ k ] ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> pre = D [ k ] <NEWLINE> k = int ( k / D [ k ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ruiseki = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ruiseki += a [ i ] <NEWLINE> count += ruiseki * a [ i + 1 ] <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> if count >= mod : <NEWLINE> <INDENT> print ( count % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
import sys <NEWLINE> amount = int ( input ( ) ) <NEWLINE> <NL> lst1 = [ 3 , 4 , 5 ] <NEWLINE> if amount in lst1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif amount < 6 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> coins = [ x for x in range ( 3 , amount + 1 ) ] <NEWLINE> <NL> lst = [ amount + 1 for x in range ( amount + 1 ) ] <NEWLINE> <NL> lst [ 0 ] = 1 <NEWLINE> lst [ 1 ] = 0 <NEWLINE> lst [ 2 ] = 0 <NEWLINE> lst [ 3 ] = 1 <NEWLINE> lst [ 4 ] = 1 <NEWLINE> lst [ 5 ] = 1 <NEWLINE> <NL> <NL> for i in range ( 6 , amount + 1 ) : <NEWLINE> <INDENT> counter = 0 <NEWLINE> for coin in coins : <NEWLINE> <INDENT> change = i - coin <NEWLINE> <NL> if change >= 0 : <NEWLINE> <INDENT> counter += lst [ change ] <NEWLINE> <DEDENT> <DEDENT> lst [ i ] = counter <NEWLINE> <NL> <DEDENT> print ( lst [ - 1 ] % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> if all ( a >= 0 for a in A ) : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> ans *= A . pop ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if all ( a < 0 for a in A ) : <NEWLINE> <INDENT> A . sort ( reverse = K % 2 == 0 ) <NEWLINE> ans = 1 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> ans *= A . pop ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> arr = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> arr . append ( ( - a , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . append ( ( a , 0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> arr . sort ( ) <NEWLINE> pz = [ ] <NEWLINE> ng = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> v , s = arr . pop ( ) <NEWLINE> if s : <NEWLINE> <INDENT> ng . append ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pz . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( ng ) % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for v in ng : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for v in pz : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = pz [ - 1 ] if pz else None <NEWLINE> c = ng [ - 1 ] if ng else None <NEWLINE> a = d = None <NEWLINE> while arr and ( a is None or d is None ) : <NEWLINE> <INDENT> v , s = arr . pop ( ) <NEWLINE> if s : <NEWLINE> <INDENT> if a is None : <NEWLINE> <INDENT> a = v <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d is None : <NEWLINE> <INDENT> d = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( a is None or b is None ) and ( c is None or d is None ) : <NEWLINE> <INDENT> assert False <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> if a is None or b is None : <NEWLINE> <INDENT> ans = d <NEWLINE> for v in ng [ : - 1 ] : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for v in pz : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> elif c is None or d is None : <NEWLINE> <INDENT> ans = a <NEWLINE> for v in ng : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for v in pz [ : - 1 ] : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a * c > b * d : <NEWLINE> <INDENT> ans = a <NEWLINE> for v in ng : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for v in pz [ : - 1 ] : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = d <NEWLINE> for v in ng [ : - 1 ] : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for v in pz : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> ACGT = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> tmp = 0 <NEWLINE> X = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] in ACGT : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X . append ( tmp ) <NEWLINE> tmp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> X . append ( tmp ) <NEWLINE> print ( max ( X ) ) <NEWLINE>
import random <NEWLINE> S = input ( ) <NEWLINE> r = random . randint ( 0 , len ( S ) - 3 ) <NEWLINE> result = <STRING> <NEWLINE> result = S [ r ] + S [ r + 1 ] + S [ r + 2 ] <NEWLINE> print ( result ) <NEWLINE>
WORDS = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> REVERSED_WORDS = [ word [ : : - 1 ] for word in WORDS ] <NEWLINE> <NL> <NL> def main ( s ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> for word in REVERSED_WORDS : <NEWLINE> <INDENT> if s [ i : ] . startswith ( word ) : <NEWLINE> <INDENT> i += len ( word ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( input ( ) [ : : - 1 ] ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Q_list = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q_list . append ( ( a , b , c , d ) ) <NEWLINE> <NL> <DEDENT> A_list = [ ] <NEWLINE> for a in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> A_list . append ( a ) <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> score_list = [ ] <NEWLINE> for A in A_list : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = Q_list [ i ] <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if A [ b ] - A [ a ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> answer = max ( answer , score ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
def isprime ( x ) : <NEWLINE> <INDENT> import math <NEWLINE> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 3 <NEWLINE> while i <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> counter = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if isprime ( A [ i ] ) : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
import math <NEWLINE> <NL> target = int ( input ( ) ) <NEWLINE> <NL> year = 0 <NEWLINE> money = 100 <NEWLINE> while money < target : <NEWLINE> <INDENT> year += 1 <NEWLINE> money *= 1.01 <NEWLINE> money = math . floor ( money ) <NEWLINE> <DEDENT> print ( year ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> l = str ( N ) <NEWLINE> A = list ( map ( int , l ) ) <NEWLINE> a = sum ( A ) <NEWLINE> <NL> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> x , n = i2 ( ) <NEWLINE> p = intl ( ) <NEWLINE> <NL> m = 100 <NEWLINE> ls = [ int ( i ) for i in range ( - 200 , 200 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ls . remove ( p [ i ] ) <NEWLINE> <DEDENT> for j in range ( len ( ls ) ) : <NEWLINE> <INDENT> if abs ( x - ls [ j ] ) < m : <NEWLINE> <INDENT> m = abs ( x - ls [ j ] ) <NEWLINE> ans = ls [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for cnt in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> if a [ cnt - 1 ] < a [ cnt + k - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . id = None <NEWLINE> self . parent = - 1 <NEWLINE> self . childs = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def preorder_walk ( data , index , out ) : <NEWLINE> <INDENT> node = data [ index ] <NEWLINE> out . append ( node . id ) <NEWLINE> for cidx in node . childs : <NEWLINE> <INDENT> if cidx >= 0 : <NEWLINE> <INDENT> preorder_walk ( data , cidx , out ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def inorder_walk ( data , index , out ) : <NEWLINE> <INDENT> cid = data [ index ] . childs [ 0 ] <NEWLINE> if cid >= 0 : <NEWLINE> <INDENT> inorder_walk ( data , cid , out ) <NEWLINE> <DEDENT> out . append ( data [ index ] . id ) <NEWLINE> cid = data [ index ] . childs [ 1 ] <NEWLINE> if cid >= 0 : <NEWLINE> <INDENT> inorder_walk ( data , cid , out ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def postorder_wark ( data , index , out ) : <NEWLINE> <INDENT> node = data [ index ] <NEWLINE> for cidx in node . childs : <NEWLINE> <INDENT> if cidx >= 0 : <NEWLINE> <INDENT> postorder_wark ( data , cidx , out ) <NEWLINE> <DEDENT> <DEDENT> out . append ( node . id ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( stdin . readline ( ) ) <NEWLINE> <COMMENT> <NL> data = [ Node ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> idx , left , right = ( int ( s ) for s in stdin . readline ( ) . split ( ) ) <NEWLINE> data [ idx ] . id = idx <NEWLINE> data [ idx ] . childs = [ left , right ] <NEWLINE> for c in data [ idx ] . childs : <NEWLINE> <INDENT> if c >= 0 : <NEWLINE> <INDENT> data [ c ] . parent = idx <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> start = None <NEWLINE> for node in data : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> start = node . id <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for name , func in ( ( <STRING> , preorder_walk ) , <NEWLINE> <INDENT> ( <STRING> , inorder_walk ) , <NEWLINE> ( <STRING> , postorder_wark ) ) : <NEWLINE> out = [ ] <NEWLINE> func ( data , start , out ) <NEWLINE> print ( name , * out ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> import scipy as sp <NEWLINE> import queue <NEWLINE> import collections <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> <NL> def main ( kwargs ) : <NEWLINE> <INDENT> a = kwargs [ <STRING> ] <NEWLINE> b = kwargs [ <STRING> ] <NEWLINE> n = kwargs [ <STRING> ] <NEWLINE> <NL> for i in range ( min ( b , n ) , - 1 , - 1 ) : <NEWLINE> <INDENT> res = a * i // b - a * ( i // b ) <NEWLINE> <NL> if res > 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> kwargs = { } <NEWLINE> <NL> cin = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> kwargs [ <STRING> ] , kwargs [ <STRING> ] , kwargs [ <STRING> ] = [ int ( i ) for i in cin ] <NEWLINE> <NL> cout = main ( kwargs ) <NEWLINE> print ( cout ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ij = math . gcd ( i , j ) <NEWLINE> if ij == 1 : <NEWLINE> <INDENT> ans += n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ij , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> A = [ ] <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> A . append ( math . gcd ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += math . gcd ( a , c ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def find_permutation ( aaa , use ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> max_a = - 1 <NEWLINE> min_a = 1005 <NEWLINE> max_fixed = - 1 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> a = aaa [ i ] <NEWLINE> if i + 1 in use : <NEWLINE> <INDENT> min_a = min ( min_a , a ) <NEWLINE> max_a = max ( max_a , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_fixed = max ( max_fixed , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if max ( max_a , max_fixed + 1 ) > 2 * min_a : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> if max_a < 2 * min_a : <NEWLINE> <INDENT> return sorted ( use ) <NEWLINE> <NL> <DEDENT> front = [ ] <NEWLINE> rear = [ ] <NEWLINE> either = [ ] <NEWLINE> for i in use : <NEWLINE> <INDENT> if aaa [ i - 1 ] == max_a : <NEWLINE> <INDENT> front . append ( i ) <NEWLINE> <DEDENT> elif aaa [ i - 1 ] == min_a : <NEWLINE> <INDENT> rear . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> either . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_front = front [ - 1 ] <NEWLINE> for i in either : <NEWLINE> <INDENT> if i < max_front : <NEWLINE> <INDENT> front . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rear . append ( i ) <NEWLINE> <DEDENT> <DEDENT> front . sort ( ) <NEWLINE> rear . sort ( ) <NEWLINE> front . extend ( rear ) <NEWLINE> <NL> return front <NEWLINE> <NL> <NL> <DEDENT> def solve ( k , aaa ) : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> return [ 1 ] * aaa [ 0 ] <NEWLINE> <NL> <DEDENT> min_a = min ( aaa ) <NEWLINE> max_a = max ( aaa ) <NEWLINE> if min_a * 2 < max_a : <NEWLINE> <INDENT> return [ - 1 ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> ans . extend ( find_permutation ( aaa , set ( range ( 1 , k + 1 ) ) ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> aaa [ i ] -= 1 <NEWLINE> <NL> <DEDENT> remaining = sum ( aaa ) <NEWLINE> while remaining : <NEWLINE> <INDENT> use = set ( range ( 1 , k + 1 ) ) <NEWLINE> candidates = [ ] <NEWLINE> for r in range ( k ) : <NEWLINE> <INDENT> result = find_permutation ( aaa , use ) <NEWLINE> if result is not None : <NEWLINE> <INDENT> candidates . append ( result ) <NEWLINE> <NL> <DEDENT> use . remove ( ans [ - r - 1 ] ) <NEWLINE> <DEDENT> adopted = min ( candidates ) <NEWLINE> ans . extend ( adopted ) <NEWLINE> for i in adopted : <NEWLINE> <INDENT> aaa [ i - 1 ] -= 1 <NEWLINE> <DEDENT> remaining -= len ( adopted ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> k , * aaa = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> print ( * solve ( k , aaa ) ) <NEWLINE>
def findlcs ( x , y ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( len ( y ) + 1 ) <NEWLINE> <NL> for c in x : <NEWLINE> <INDENT> tmp = dp [ : ] <NEWLINE> for j in range ( len ( y ) ) : <NEWLINE> <INDENT> if c == y [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = tmp [ j ] + 1 <NEWLINE> <DEDENT> elif dp [ j + 1 ] < dp [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = dp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> print ( findlcs ( X , Y ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ i - 1 for i in A ] <NEWLINE> <NL> flag = [ False ] * N <NEWLINE> from collections import deque <NEWLINE> <NL> q = deque ( [ ] ) <NEWLINE> q . append ( 0 ) <NEWLINE> flag [ 0 ] = True <NEWLINE> now = 0 <NEWLINE> while True : <NEWLINE> <INDENT> now = A [ now ] <NEWLINE> if flag [ now ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ now ] = True <NEWLINE> q . append ( now ) <NEWLINE> <NL> <DEDENT> <DEDENT> l = list ( q ) <NEWLINE> if K < len ( l ) : <NEWLINE> <INDENT> print ( l [ K ] + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i , x in enumerate ( l ) : <NEWLINE> <INDENT> if x == now : <NEWLINE> <INDENT> l = l [ i : ] <NEWLINE> K -= i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l [ K % len ( l ) ] + 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = input ( ) . split ( ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> result = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> result . append ( c [ str ( i ) ] ) <NEWLINE> <NL> <DEDENT> for r in result : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == ( H - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = [ 0 ] * n <NEWLINE> employee = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in employee : <NEWLINE> <INDENT> num [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in num : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def method ( l ) : <NEWLINE> <INDENT> idx = l . find ( <STRING> ) <NEWLINE> return l if idx < 0 else method ( l . replace ( l [ idx : idx + 3 ] , l [ idx + 2 ] * int ( l [ idx + 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> print ( method ( line . replace ( <STRING> , <STRING> ) ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> A = sorted ( A ) <NEWLINE> total = 0 <NEWLINE> for k in range ( Q ) : <NEWLINE> <INDENT> if A [ ( S [ k ] [ 1 ] - 1 ) ] - A [ S [ k ] [ 0 ] - 1 ] == S [ k ] [ 2 ] : <NEWLINE> <INDENT> total += S [ k ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if total > ans : <NEWLINE> <INDENT> ans = total <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for t in range ( N ) : <NEWLINE> <INDENT> result *= A [ t ] <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = 1 <NEWLINE> r = max ( a ) <NEWLINE> while l < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> cnt = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> cnt += ( x - 1 ) // m <NEWLINE> <DEDENT> if cnt > k : l = m + 1 <NEWLINE> else : r = m <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : break <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE>
from numba import njit <NEWLINE> @ njit ( <STRING> ) <NEWLINE> <NL> def solve ( n ) : <NEWLINE> <INDENT> l = [ 1 ] * ( n + 1 ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> j = i <NEWLINE> while ( j <= n ) : <NEWLINE> <INDENT> l [ j - 1 ] += 1 <NEWLINE> j += i <NEWLINE> <DEDENT> ans += ( i * l [ i - 1 ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( solve ( n ) ) <NEWLINE> <NL>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1251 ) : <NEWLINE> <INDENT> if math . floor ( i * 0.08 ) == a and math . floor ( i * 0.1 ) == b : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) != 0 : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
import math <NEWLINE> val = str ( input ( ) ) . split ( ) <NEWLINE> <NL> numList = list ( map ( float , list ( val ) ) ) <NEWLINE> <NL> print ( math . sqrt ( ( ( numList [ 2 ] - numList [ 0 ] ) ** 2 ) + ( ( numList [ 3 ] - numList [ 1 ] ) ** 2 ) ) ) <NEWLINE>
import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Ac = [ 0 ] * ( N + 1 ) <NEWLINE> Bc = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Ac [ i ] = Ac [ i - 1 ] + A [ i - 1 ] <NEWLINE> <DEDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> Bc [ j ] = Bc [ j - 1 ] + B [ j - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> n = K - Ac [ i ] <NEWLINE> if n < 0 : break <NEWLINE> tmp = bisect . bisect_right ( Bc , n ) - 1 <NEWLINE> ans = max ( ans , i + tmp ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i , j in enumerate ( lis ) : <NEWLINE> <INDENT> L . append ( i + j ) <NEWLINE> <DEDENT> for i , j in enumerate ( lis ) : <NEWLINE> <INDENT> R . append ( i - j ) <NEWLINE> <NL> <DEDENT> ref = dict ( Counter ( R ) ) <NEWLINE> ans = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> ans += ref . get ( i , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import queue <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> routs = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> routs [ a ] . append ( b ) <NEWLINE> routs [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> parent = [ - 1 ] * ( n - 1 ) <NEWLINE> visit = [ <STRING> ] * ( n ) <NEWLINE> visit [ 0 ] = <STRING> <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( 1 ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> temp = q . get ( ) <NEWLINE> for i in routs [ temp ] : <NEWLINE> <INDENT> if visit [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> q . put ( i ) <NEWLINE> if parent [ i - 2 ] == - 1 : <NEWLINE> <INDENT> parent [ i - 2 ] = temp <NEWLINE> <DEDENT> visit [ i - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in parent : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> from collections import Counter <NEWLINE> results = Counter ( s ) <NEWLINE> <NL> max_num = results . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> max_key_list = [ kv [ 0 ] for kv in results . items ( ) if kv [ 1 ] == max_num ] <NEWLINE> for i in sorted ( max_key_list ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ) ) <NEWLINE>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) for i in range ( n ) ) + [ <STRING> ] <NEWLINE> ans = [ <STRING> ] <NEWLINE> <NL> if a + b + c == 0 : <NEWLINE> <INDENT> del ans [ : ] <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> if a + b + c == 1 : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <NL> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> del ans [ : ] <NEWLINE> ans += [ <STRING> ] <NEWLINE> break <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> del ans [ : ] <NEWLINE> ans += [ <STRING> ] <NEWLINE> break <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif c == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> del ans [ : ] <NEWLINE> ans += [ <STRING> ] <NEWLINE> break <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> elif c == 1 : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a + b + c == 2 : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if a == 2 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif c == 2 : <NEWLINE> <INDENT> del ans [ : ] <NEWLINE> ans += [ <STRING> ] <NEWLINE> break <NEWLINE> <DEDENT> elif ( a == 1 and b == 1 ) and ( s [ j + 1 ] == <STRING> or s [ j + 1 ] == <STRING> or s [ j + 1 ] == <STRING> ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif ( a == 1 and b == 1 ) and ( s [ j + 1 ] == <STRING> ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif a == 1 and c == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif b == 1 and c == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if a == 2 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif c == 2 : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> del ans [ : ] <NEWLINE> ans += [ <STRING> ] <NEWLINE> break <NEWLINE> <DEDENT> elif ( a == 1 and c == 1 ) and ( s [ j + 1 ] == <STRING> or s [ j + 1 ] == <STRING> or s [ j + 1 ] == <STRING> ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif ( a == 1 and c == 1 ) and ( s [ j + 1 ] == <STRING> ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif a == 1 and b == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif b == 1 and c == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if c == 2 : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> del ans [ : ] <NEWLINE> ans += [ <STRING> ] <NEWLINE> break <NEWLINE> <DEDENT> elif ( c == 1 and b == 1 ) and ( s [ j + 1 ] == <STRING> or s [ j + 1 ] == <STRING> or s [ j + 1 ] == <STRING> ) : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif ( c == 1 and b == 1 ) and ( s [ j + 1 ] == <STRING> ) : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif a == 1 and c == 1 : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif b == 1 and a == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a + b + c >= 3 : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> and a + b == 0 or s [ 0 ] == <STRING> and a + c == 0 or s [ 0 ] == <STRING> and b + c == 0 : <NEWLINE> <INDENT> del ans [ : ] <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif a <= b : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif a <= c : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <DEDENT> elif b <= c : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans += [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for an in ans : <NEWLINE> <INDENT> print ( an ) <NEWLINE> <DEDENT>
( h , w , m ) , * e = [ [ * map ( int , i . split ( ) ) ] for i in open ( 0 ) ] <NEWLINE> a , b = [ 0 ] * h , [ 0 ] * w <NEWLINE> for y , x in e : <NEWLINE> <INDENT> a [ y - 1 ] += 1 <NEWLINE> b [ x - 1 ] += 1 <NEWLINE> <DEDENT> ans = max ( a ) + max ( b ) <NEWLINE> c = a . count ( max ( a ) ) * b . count ( max ( b ) ) - sum ( a [ y - 1 ] + b [ x - 1 ] == ans for y , x in e ) <NEWLINE> print ( ans - ( c <= 0 ) ) <NEWLINE>
from itertools import product as pr <NEWLINE> n , m , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( n ) ] <NEWLINE> p = list ( pr ( [ 0 , 1 ] , repeat = n ) ) <NEWLINE> suml = [ [ sum ( [ l [ j ] [ k ] * i [ j ] for j in range ( n ) ] ) for k in range ( m + 1 ) ] for i in p ] <NEWLINE> ans = [ i [ 0 ] for i in suml if all ( [ i [ j ] >= x for j in range ( 1 , m + 1 ) ] ) ] <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
def lcs ( x , y ) : <NEWLINE> <INDENT> a = len ( x ) <NEWLINE> b = len ( y ) <NEWLINE> c1 = [ 0 ] * ( b + 1 ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = x [ i ] <NEWLINE> c2 = c1 [ : ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> ret = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = input ( ) . rstrip ( ) <NEWLINE> s2 = input ( ) . rstrip ( ) <NEWLINE> ret . append ( lcs ( s1 , s2 ) ) <NEWLINE> <DEDENT> print ( * ret , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> L = { } <NEWLINE> R = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] + i in L : <NEWLINE> <INDENT> k = L . get ( a [ i ] + i ) <NEWLINE> del L [ a [ i ] + i ] <NEWLINE> L [ a [ i ] + i ] = k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ a [ i ] + i ] = 1 <NEWLINE> <DEDENT> if i - a [ i ] > 0 : <NEWLINE> <INDENT> if i - a [ i ] in R : <NEWLINE> <INDENT> k = R . get ( i - a [ i ] ) <NEWLINE> del R [ i - a [ i ] ] <NEWLINE> R [ i - a [ i ] ] = k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ i - a [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x in L . keys ( ) : <NEWLINE> <INDENT> if x in R : <NEWLINE> <INDENT> ans += L . get ( x ) * R . get ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> a = sorted ( a ) [ : : - 1 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> count = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in s : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <DEDENT> ans = count [ <STRING> ] * count [ <STRING> ] * count [ <STRING> ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> if j + 2 * i > n - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ j ] != s [ j + i ] and s [ j + i ] != s [ j + i + i ] and s [ j ] != s [ j + i + i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> ans = 0 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dic [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> b = A [ i ] + N - i - 1 <NEWLINE> if A [ i ] < N - i : <NEWLINE> <INDENT> a = N - i - A [ i ] - 1 <NEWLINE> dic [ a ] += 1 <NEWLINE> <DEDENT> if b < N : <NEWLINE> <INDENT> ans += dic [ b ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> B = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B . append ( B [ i ] + int ( A [ i ] ) ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += int ( A [ i ] ) * ( B [ N ] - B [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 13 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a1 = abs ( pos [ i ] ) + abs ( pos [ i ] - pos [ i + k - 1 ] ) <NEWLINE> a2 = abs ( pos [ i + k - 1 ] ) + abs ( pos [ i ] - pos [ i + k - 1 ] ) <NEWLINE> ans = min ( ans , a1 , a2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> if k % 7 == 0 : k //= 7 <NEWLINE> if math . gcd ( 10 , k ) != 1 : exit ( print ( - 1 ) ) <NEWLINE> if k == 1 : exit ( print ( 1 ) ) <NEWLINE> v = 1 <NEWLINE> ans = 0 <NEWLINE> while ( v != 0 ) : <NEWLINE> <INDENT> v = ( v * 10 + 1 ) % k <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , p = None , l = None , r = None ) : <NEWLINE> <INDENT> self . parent = p <NEWLINE> self . left = l <NEWLINE> self . right = r <NEWLINE> self . depth = None <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> nodes = [ Node ( ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> id , k , * c = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if k == 0 : continue <NEWLINE> nodes [ id ] . left = c [ 0 ] <NEWLINE> nodes [ c [ 0 ] ] . parent = id <NEWLINE> for j in range ( 1 , k ) : <NEWLINE> <INDENT> nodes [ c [ j - 1 ] ] . right = c [ j ] <NEWLINE> nodes [ c [ j ] ] . parent = id <NEWLINE> <NL> <DEDENT> <DEDENT> root = None <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if nodes [ i ] . parent == None : <NEWLINE> <INDENT> root = i <NEWLINE> <NL> <DEDENT> <DEDENT> def get_childs ( i ) : <NEWLINE> <INDENT> if nodes [ i ] . left == None : return [ ] <NEWLINE> j = 0 <NEWLINE> childs = [ nodes [ i ] . left ] <NEWLINE> while nodes [ childs [ j ] ] . right != None : <NEWLINE> <INDENT> childs . append ( nodes [ childs [ j ] ] . right ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> return childs <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def set_depth ( s ) : <NEWLINE> <INDENT> nodes [ s ] . depth = 0 <NEWLINE> queue = deque ( [ s ] ) <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> u = queue . popleft ( ) <NEWLINE> par_depth = nodes [ u ] . depth <NEWLINE> next_child = nodes [ u ] . left <NEWLINE> while next_child != None : <NEWLINE> <INDENT> nodes [ next_child ] . depth = par_depth + 1 <NEWLINE> queue . append ( next_child ) <NEWLINE> next_child = nodes [ next_child ] . right <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> set_depth ( root ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> nodetype = <STRING> <NEWLINE> childs = get_childs ( i ) <NEWLINE> if childs == [ ] : <NEWLINE> <INDENT> nodetype = <STRING> <NEWLINE> <DEDENT> parent = nodes [ i ] . parent <NEWLINE> if parent == None : <NEWLINE> <INDENT> parent = - 1 <NEWLINE> nodetype = <STRING> <NEWLINE> <DEDENT> print ( <STRING> + str ( i ) + <STRING> + str ( parent ) + <STRING> + str ( nodes [ i ] . depth ) + <STRING> + nodetype + <STRING> + str ( childs ) ) <NEWLINE> <NL> <DEDENT>
n , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D_list = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( c ) ] <NEWLINE> c_list = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> c_num = [ [ 0 for _ in range ( 3 ) ] for __ in range ( c ) ] <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( n ) : <NEWLINE> <INDENT> c_num [ c_list [ b ] [ a ] - 1 ] [ ( a + b + 2 ) % 3 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 10 ** 10 <NEWLINE> for i in range ( 1 , c ** 3 ) : <NEWLINE> <INDENT> x = i % c <NEWLINE> y = ( i % c ** 2 ) // c <NEWLINE> z = i // c ** 2 <NEWLINE> if x == y or y == z or z == x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color = [ x , y , z ] <NEWLINE> count = 0 <NEWLINE> for s in range ( 3 ) : <NEWLINE> <INDENT> for t in range ( c ) : <NEWLINE> <INDENT> count += c_num [ t ] [ s ] * D_list [ t ] [ color [ s ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> if count < ans : <NEWLINE> <INDENT> ans = count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> l = [ - 1 ] * n <NEWLINE> now = 0 <NEWLINE> i = 1 <NEWLINE> result = [ 0 ] <NEWLINE> while i <= k : <NEWLINE> <INDENT> now = a [ now ] <NEWLINE> if l [ now ] != - 1 : <NEWLINE> <NL> <INDENT> length = i - l [ now ] <NEWLINE> d = ( k - i ) % length + l [ now ] <NEWLINE> ans = l . index ( d ) <NEWLINE> break <NEWLINE> <DEDENT> l [ now ] = i <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if ans != - 1 : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = len ( A ) <NEWLINE> z = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> x = sum ( A ) <NEWLINE> x = x ** 2 <NEWLINE> for i in A : <NEWLINE> <INDENT> y = i * i <NEWLINE> x -= y <NEWLINE> <NL> <DEDENT> x = x // 2 <NEWLINE> x = x % z <NEWLINE> print ( x ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = A <NEWLINE> if B >= K - A : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - ( A + B ) ) ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
from itertools import combinations <NEWLINE> <NL> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> cnt = { <STRING> : A , <STRING> : B , <STRING> : C } <NEWLINE> <NL> def out ( T ) : <NEWLINE> <INDENT> now = { <STRING> : A , <STRING> : B , <STRING> : C } <NEWLINE> <NL> ans = [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> u , v = s [ 0 ] , s [ 1 ] <NEWLINE> if now [ u ] == now [ v ] == 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if now [ u ] > now [ v ] : <NEWLINE> <INDENT> ans . append ( v ) <NEWLINE> now [ u ] -= 1 <NEWLINE> now [ v ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if now [ u ] < now [ v ] : <NEWLINE> <INDENT> ans . append ( u ) <NEWLINE> now [ u ] += 1 <NEWLINE> now [ v ] -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> ans . append ( u ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> nx = S [ i + 1 ] <NEWLINE> if u in nx : <NEWLINE> <INDENT> ans . append ( u ) <NEWLINE> now [ u ] += 1 <NEWLINE> now [ v ] -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if v in nx : <NEWLINE> <INDENT> ans . append ( v ) <NEWLINE> now [ v ] += 1 <NEWLINE> now [ u ] -= 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = out ( <STRING> ) <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ <STRING> for _ in range ( h ) ] <NEWLINE> c = 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> a = [ 1 for _ in range ( w ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( * a ) <NEWLINE> <DEDENT> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> sh = [ ] <NEWLINE> nc = 0 <NEWLINE> if s == <STRING> * w : continue <NEWLINE> <NL> for j in range ( w ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> and nc > 0 : c += 1 <NEWLINE> elif s [ j ] == <STRING> : nc += 1 <NEWLINE> sh . append ( str ( c ) ) <NEWLINE> <DEDENT> a [ i ] = sh [ : ] <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> l = 1 <NEWLINE> while a [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> a [ 0 ] = a [ l ] <NEWLINE> <NL> <DEDENT> while <STRING> in a : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> l = i - 1 <NEWLINE> while a [ l ] == <STRING> : <NEWLINE> <INDENT> l -= 1 <NEWLINE> <DEDENT> a [ i ] = a [ l ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for m in a : <NEWLINE> <INDENT> print ( * m ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( ( ( a * x ) // b ) - a * ( x // b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> group = [ ] <NEWLINE> seen = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if seen [ i ] : continue <NEWLINE> que = deque ( ) <NEWLINE> seen [ i ] = 1 <NEWLINE> cnt = 0 <NEWLINE> que . append ( i ) <NEWLINE> while que : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> v = que . popleft ( ) <NEWLINE> for nv in G [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : continue <NEWLINE> seen [ nv ] = 1 <NEWLINE> que . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> def Main ( N , S ) : <NEWLINE> <INDENT> num = [ 0 ] * 3 <NEWLINE> for c in S : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> num [ 0 ] += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> num [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = np . prod ( num ) <NEWLINE> sub = 0 <NEWLINE> i = 0 <NEWLINE> j = 1 <NEWLINE> while ( i - 2 < N ) : <NEWLINE> <INDENT> while ( i + 2 * j < N ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = i + j <NEWLINE> c = i + 2 * j <NEWLINE> if S [ a ] != S [ b ] and S [ a ] != S [ c ] and S [ b ] != S [ c ] : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> j = 1 <NEWLINE> <DEDENT> return ans - sub <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> print ( Main ( N , S ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> A = [ 0 ] * k <NEWLINE> C = [ 7 % k ] <NEWLINE> A [ 7 % k ] = 1 <NEWLINE> if 7 % k == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> now = ( C [ - 1 ] * 10 + 7 ) % k <NEWLINE> if A [ now ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> A [ now ] = 1 <NEWLINE> C . append ( now ) <NEWLINE> if now == 0 : <NEWLINE> <INDENT> print ( len ( C ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> rx = self . find ( x ) <NEWLINE> ry = self . find ( y ) <NEWLINE> if rx != ry : <NEWLINE> <INDENT> self . par [ rx ] += self . par [ ry ] <NEWLINE> self . par [ ry ] = rx <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . par [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> rx = self . find ( x ) <NEWLINE> ry = self . find ( y ) <NEWLINE> return rx == ry <NEWLINE> <NL> <DEDENT> def return_par ( self ) : <NEWLINE> <INDENT> return self . par <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = Counter ( p ) <NEWLINE> <NL> ps = set ( p ) <NEWLINE> plst = list ( ps ) <NEWLINE> plst . sort ( ) <NEWLINE> <NL> ans = [ 0 ] * ( plst [ - 1 ] + 1 ) <NEWLINE> <NL> for i in range ( len ( plst ) ) : <NEWLINE> <INDENT> for j in range ( plst [ i ] , plst [ - 1 ] + 1 , plst [ i ] ) : <NEWLINE> <INDENT> ans [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> d = 0 <NEWLINE> for i in range ( len ( plst ) ) : <NEWLINE> <INDENT> if ans [ plst [ i ] ] == 1 and cnt [ plst [ i ] ] == 1 : d += 1 <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a_p = a // x <NEWLINE> b_p = b // x <NEWLINE> <NL> if a % x == 0 : <NEWLINE> <INDENT> print ( b_p - a_p + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b_p - a_p ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> largest = max ( a ) <NEWLINE> b = [ True ] * ( largest + 1 ) <NEWLINE> dict = { } <NEWLINE> ans = 0 <NEWLINE> for num in a : <NEWLINE> <INDENT> if num in dict . keys ( ) : <NEWLINE> <INDENT> b [ num ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ num ] = 1 <NEWLINE> y = num * 2 <NEWLINE> while ( y <= largest ) : <NEWLINE> <INDENT> b [ y ] = False <NEWLINE> y += num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for num in a : <NEWLINE> <INDENT> if b [ num ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_array . insert ( 0 , 0 ) <NEWLINE> x_sum = { } <NEWLINE> x_dis = { } <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a_sum = i + a_array [ i ] <NEWLINE> if a_sum in x_sum : <NEWLINE> <INDENT> x_sum [ a_sum ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_sum [ a_sum ] = [ i ] <NEWLINE> <DEDENT> if not ( a_sum in x_dis ) : <NEWLINE> <INDENT> x_dis [ a_sum ] = [ ] <NEWLINE> <NL> <DEDENT> a_dis = i - a_array [ i ] <NEWLINE> if a_dis > 0 : <NEWLINE> <INDENT> if a_dis in x_dis : <NEWLINE> <INDENT> x_dis [ a_dis ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_dis [ a_dis ] = [ i ] <NEWLINE> <DEDENT> if not ( a_dis in x_sum ) : <NEWLINE> <INDENT> x_sum [ a_dis ] = [ ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for k in x_sum . keys ( ) : <NEWLINE> <INDENT> count += len ( x_sum [ k ] ) * len ( x_dis [ k ] ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
def mul ( v , u ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( len ( u ) ) : <NEWLINE> <INDENT> s += v [ u [ i ] [ 0 ] ] * u [ i ] [ 1 ] <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> [ n , m ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = [ [ ] for j in range ( n ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if d == [ 0 , 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ d [ 0 ] - 1 ] . append ( [ d [ 1 ] - 1 , d [ 2 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> c = int ( input ( ) ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( c ) ] <NEWLINE> <NL> for i in range ( c ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> r . append ( mul ( p [ i ] , t [ j ] ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , r ) ) ) <NEWLINE> <DEDENT>
alpha = [ s for s in <STRING> ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> while num > 0 : <NEWLINE> <INDENT> ans . append ( alpha [ num % 26 - 1 ] ) <NEWLINE> num //= 26 <NEWLINE> if ans [ - 1 ] == <STRING> : <NEWLINE> <INDENT> num -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans [ : : - 1 ] ) ) <NEWLINE>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> now = 1 <NEWLINE> flag = [ - 1 ] * ( N ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if flag [ now - 1 ] == - 1 : <NEWLINE> <INDENT> flag [ now - 1 ] = i <NEWLINE> now = A [ now - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = i - flag [ now - 1 ] <NEWLINE> zan = ( K - ( i - loop ) ) % loop <NEWLINE> ans = flag . index ( i - loop + zan ) + 1 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( now ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if A == [ ] : <NEWLINE> <INDENT> A . append ( num ) <NEWLINE> <DEDENT> elif num > A [ - 1 ] : <NEWLINE> <INDENT> A . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = bisect . bisect_left ( A , num ) <NEWLINE> A [ j ] = num <NEWLINE> <DEDENT> <DEDENT> print ( len ( A ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( n , b - 1 ) <NEWLINE> print ( a * x // b ) <NEWLINE>
from collections import deque <NEWLINE> <NL> class Car : <NEWLINE> <INDENT> def __init__ ( self , rem , ind ) : <NEWLINE> <INDENT> self . ind = ind <NEWLINE> self . rem = rem <NEWLINE> <NL> <DEDENT> <DEDENT> class Part : <NEWLINE> <INDENT> def __init__ ( self , i ) : <NEWLINE> <INDENT> self . ind = i <NEWLINE> self . top = None <NEWLINE> self . und = None <NEWLINE> self . sta = 0 <NEWLINE> self . rem = - 1 <NEWLINE> <NL> <DEDENT> def prog ( self , time ) : <NEWLINE> <INDENT> if self . top != None : <NEWLINE> <INDENT> self . top . rem -= time <NEWLINE> <DEDENT> if self . und != None : <NEWLINE> <INDENT> self . und . rem -= time <NEWLINE> <DEDENT> if self . sta != 0 : <NEWLINE> <INDENT> self . rem -= time <NEWLINE> <NL> <DEDENT> <DEDENT> def out ( self ) : <NEWLINE> <INDENT> if self . sta == 2 : <NEWLINE> <INDENT> if self . und . rem <= 0 and self . top . rem <= 0 : <NEWLINE> <INDENT> outs = [ self . und . ind , self . top . ind ] <NEWLINE> self . und = None <NEWLINE> self . top = None <NEWLINE> self . sta = 0 <NEWLINE> self . rem = - 1 <NEWLINE> return outs <NEWLINE> <DEDENT> if self . und . rem <= 0 : <NEWLINE> <INDENT> outs = [ self . und . ind ] <NEWLINE> self . und = None <NEWLINE> self . sta = 1 <NEWLINE> self . rem = self . top . rem <NEWLINE> return outs <NEWLINE> <NL> <DEDENT> <DEDENT> if self . sta == 1 : <NEWLINE> <INDENT> if self . top . rem <= 0 : <NEWLINE> <INDENT> outs = [ self . top . ind ] <NEWLINE> self . top = None <NEWLINE> self . sta = 0 <NEWLINE> self . rem = - 1 <NEWLINE> return outs <NEWLINE> <DEDENT> <DEDENT> return [ ] <NEWLINE> <NL> <DEDENT> def into ( self , rem , ind ) : <NEWLINE> <INDENT> if self . sta == 0 : <NEWLINE> <INDENT> self . top = Car ( rem , ind ) <NEWLINE> self . sta = 1 <NEWLINE> self . rem = rem <NEWLINE> <DEDENT> elif self . sta == 1 : <NEWLINE> <INDENT> self . und = Car ( rem , ind ) <NEWLINE> self . sta = 2 <NEWLINE> self . rem = rem <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Parking : <NEWLINE> <INDENT> def __init__ ( self , length ) : <NEWLINE> <INDENT> self . length = length <NEWLINE> self . max_space = length * 2 <NEWLINE> self . space = length * 2 <NEWLINE> self . body = [ Part ( i ) for i in range ( length ) ] <NEWLINE> <NL> <DEDENT> def prog ( self , time ) : <NEWLINE> <INDENT> for part in self . body : <NEWLINE> <INDENT> part . prog ( time ) <NEWLINE> <NL> <DEDENT> <DEDENT> def out ( self ) : <NEWLINE> <INDENT> outs = [ ] <NEWLINE> for part in self . body : <NEWLINE> <INDENT> if part . sta >= 1 and part . rem <= 0 : <NEWLINE> <INDENT> outs . append ( part . out ( ) ) <NEWLINE> <DEDENT> <DEDENT> ret = [ ] <NEWLINE> for out in outs : <NEWLINE> <INDENT> ret += out <NEWLINE> <DEDENT> self . space += len ( ret ) <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> def into ( self , rem , ind ) : <NEWLINE> <INDENT> self . space -= 1 <NEWLINE> for part in self . body : <NEWLINE> <INDENT> if part . sta == 0 : <NEWLINE> <INDENT> part . into ( rem , ind ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> rem_lst = [ ] <NEWLINE> for part in self . body : <NEWLINE> <INDENT> if part . sta == 1 : <NEWLINE> <INDENT> rem_lst . append ( ( part . rem , part . ind ) ) <NEWLINE> <DEDENT> <DEDENT> rem_lst . sort ( ) <NEWLINE> <NL> for r , i in rem_lst : <NEWLINE> <INDENT> if r >= rem : <NEWLINE> <INDENT> self . body [ i ] . into ( rem , ind ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> max_r = r <NEWLINE> for r , i in rem_lst : <NEWLINE> <INDENT> if r == max_r : <NEWLINE> <INDENT> self . body [ i ] . into ( rem , ind ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> parking = Parking ( m ) <NEWLINE> que = deque ( ) <NEWLINE> ans = [ ] <NEWLINE> for t in range ( n * 120 - 1 ) : <NEWLINE> <INDENT> parking . prog ( 1 ) <NEWLINE> ans += parking . out ( ) <NEWLINE> if t <= ( n - 1 ) * 10 and t % 10 == 0 : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> que . append ( ( r , t // 10 + 1 ) ) <NEWLINE> <NL> <DEDENT> for i in range ( min ( parking . space , len ( que ) ) ) : <NEWLINE> <INDENT> rem , ind = que . popleft ( ) <NEWLINE> parking . into ( rem , ind ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> <COMMENT> <NL> if X > K * D : <NEWLINE> <INDENT> ans = X - K * D <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> time = X // D + 1 <NEWLINE> K = K - time <NEWLINE> X = X - time * D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> ans = abs ( X ) <NEWLINE> <DEDENT> if K % 2 != 0 : <NEWLINE> <INDENT> ans = X + D <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ms = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> numbers = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for com in combinations ( A , i ) : <NEWLINE> <INDENT> numbers . append ( sum ( com ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for m in ms : <NEWLINE> <INDENT> if m in numbers : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> queue = [ ] <NEWLINE> targ = input ( ) <NEWLINE> while targ != <STRING> : <NEWLINE> <INDENT> if targ [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( queue , - int ( targ . split ( <STRING> ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - heapq . heappop ( queue ) ) <NEWLINE> <DEDENT> targ = input ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <NL> <INDENT> sum += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> M [ a ] . append ( b ) <NEWLINE> M [ b ] . append ( a ) <NEWLINE> <DEDENT> yes = <STRING> ; no = <STRING> <NEWLINE> <NL> for i in M [ 0 ] : <NEWLINE> <INDENT> if n - 1 in M [ i ] : <NEWLINE> <INDENT> print ( yes ) ; exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( no ) <NEWLINE> <NL>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = 1 <NEWLINE> <NL> c = 0 <NEWLINE> d = 0 <NEWLINE> <NL> for i in b : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif i > 10 ** 18 : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if c > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if d > 1 and c == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in b : <NEWLINE> <INDENT> n *= i <NEWLINE> if n > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
import numpy as np <NEWLINE> <NL> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == a ** 2 * b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if x < 1 / 2 * b * a ** 2 : <NEWLINE> <INDENT> a1 = 2 * x / ( a * b ) <NEWLINE> rad = np . arctan ( a1 / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = 2 * ( b - x / a ** 2 ) <NEWLINE> rad = np . arctan ( a / y ) <NEWLINE> <NL> <DEDENT> print ( 90 - rad * 180 / np . pi ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ set ( ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ A - 1 ] . add ( B ) <NEWLINE> a [ B - 1 ] . add ( A ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> if a [ i ] == set ( ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in a [ i ] : <NEWLINE> <INDENT> if H [ j - 1 ] >= H [ i ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import OrderedDict <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n >= 52 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> m = OrderedDict ( ) <NEWLINE> for c in <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> m [ c + <STRING> + str ( i ) ] = 0 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> del m [ input ( ) ] <NEWLINE> <DEDENT> print ( * m . keys ( ) , sep = <STRING> ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <NL>
def inN ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inL ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def inNL ( n ) : <NEWLINE> <INDENT> return [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> n = int ( s ) <NEWLINE> l = len ( s ) <NEWLINE> cnt = 0 <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> m = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> m = ( int ( s [ l - 1 - i ] ) * pow ( 10 , i , 2019 ) + m ) % 2019 <NEWLINE> mod [ m ] += 1 <NEWLINE> <NL> <DEDENT> cnt += mod [ 0 ] <NEWLINE> <NL> for i in range ( 2019 ) : <NEWLINE> <INDENT> if mod [ i ] > 1 : <NEWLINE> <INDENT> cnt += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( int ( cnt ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Pls = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for i in ls : <NEWLINE> <INDENT> Pls [ i ] += 1 <NEWLINE> <NL> <DEDENT> ii = 0 <NEWLINE> for j in range ( len ( Pls ) ) : <NEWLINE> <INDENT> if Pls [ j ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif Pls [ j ] == 1 : <NEWLINE> <INDENT> ii += 1 <NEWLINE> t = 2 * j <NEWLINE> while t <= 10 ** 6 : <NEWLINE> <INDENT> Pls [ t ] = 0 <NEWLINE> t += j <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t = 2 * j <NEWLINE> while t <= 10 ** 6 : <NEWLINE> <INDENT> Pls [ t ] = 0 <NEWLINE> t += j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ii ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> p = 10 ** 18 <NEWLINE> <NL> for a in A_list : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > p : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> <NL> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def cinr ( i ) : <NEWLINE> <INDENT> tmp = ( i . split ( <STRING> ) ) <NEWLINE> W = int ( tmp [ 0 ] ) <NEWLINE> H = int ( tmp [ 1 ] ) <NEWLINE> x = int ( tmp [ 2 ] ) <NEWLINE> y = int ( tmp [ 3 ] ) <NEWLINE> r = int ( tmp [ 4 ] ) <NEWLINE> <NL> if x >= 0 + r and x <= W - r and y >= 0 + r and y <= H - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ret = cinr ( input ( ) ) <NEWLINE> <DEDENT>
from numpy import cumsum <NEWLINE> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = cumsum ( [ 0 ] + A ) <NEWLINE> B = cumsum ( [ 0 ] + B ) <NEWLINE> n_read = 0 <NEWLINE> l = len ( B ) - 1 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j , b in enumerate ( B [ l : : - 1 ] ) : <NEWLINE> <INDENT> if a + b <= k : <NEWLINE> <INDENT> l -= j <NEWLINE> n_read = max ( n_read , i + l ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n_read ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> union = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> union . union ( A - 1 , B - 1 ) <NEWLINE> <DEDENT> print ( union . group_count ( ) - 1 ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> w = gcd ( i , j ) <NEWLINE> if w == 1 : <NEWLINE> <INDENT> m += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> m += gcd ( w , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
<STRING> <NEWLINE> from sys import stdin , stdout <NEWLINE> from math import * <NEWLINE> from collections import * <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> def set_bits ( X ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while X : <NEWLINE> <INDENT> X &= ( X - 1 ) ; c += 1 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def compute_MOD ( N , M ) : return ( N % M + M ) % M <NEWLINE> <NL> def get_array ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def get_ints ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> def get_int ( ) : return int ( stdin . readline ( ) ) <NEWLINE> <NL> def get_input ( ) : return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = get_input ( ) <NEWLINE> Sum = 0 <NEWLINE> for i in N : Sum += int ( i ) <NEWLINE> if Sum % 9 == 0 : stdout . write ( <STRING> ) <NEWLINE> else : stdout . write ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> if A [ i - K - 1 ] < A [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> def solve ( S ) : <NEWLINE> <INDENT> buf = [ 1 ] * len ( S ) <NEWLINE> <NL> for i in range ( len ( buf ) - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> buf [ i + 2 ] += buf [ i ] <NEWLINE> buf [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( buf ) - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> buf [ i - 2 ] += buf [ i ] <NEWLINE> buf [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> . join ( map ( str , buf ) ) <NEWLINE> <NL> <DEDENT> print ( solve ( S ) ) <NEWLINE>
num_sunuke , num_okashi_kind = map ( int , input ( ) . split ( ) ) <NEWLINE> sunuke = [ 0 ] * ( num_sunuke + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for idx_okashi_kind in range ( 1 , num_okashi_kind + 1 ) : <NEWLINE> <INDENT> num_have_okashi = int ( input ( ) ) <NEWLINE> idx_sunuke_with_okashi = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , num_have_okashi + 1 ) : <NEWLINE> <INDENT> for j in idx_sunuke_with_okashi : <NEWLINE> <INDENT> sunuke [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for s in sunuke : <NEWLINE> <INDENT> if s == 1 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num_sunuke - ans ) <NEWLINE>
import itertools <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> def gcd ( p , q ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( p % q == 0 ) : <NEWLINE> <INDENT> return q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( q , p % q ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for abc in itertools . combinations_with_replacement ( [ i + 1 for i in range ( K ) ] , 3 ) : <NEWLINE> <INDENT> a , b , c = abc <NEWLINE> gcd_ab = gcd ( a , b ) <NEWLINE> gcd_abc = gcd ( gcd_ab , c ) <NEWLINE> <NL> <COMMENT> <NL> if a == b == c : <NEWLINE> <INDENT> ans += gcd_abc <NEWLINE> <DEDENT> elif a == b or b == c or a == c : <NEWLINE> <INDENT> ans += gcd_abc * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd_abc * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> f_i = sys . stdin <NEWLINE> <NL> V , E = map ( int , f_i . readline ( ) . split ( ) ) <NEWLINE> <NL> adj_sets = [ set ( ) for i in range ( V ) ] <NEWLINE> <NL> for l_i in f_i : <NEWLINE> <INDENT> s , t = map ( int , l_i . split ( ) ) <NEWLINE> adj_sets [ s ] . add ( t ) <NEWLINE> adj_sets [ t ] . add ( s ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> prenum = [ 0 ] * V <NEWLINE> parent = [ 0 ] * V <NEWLINE> lowest = [ V ] * V <NEWLINE> <NL> import collections <NEWLINE> <NL> path = collections . deque ( ) <NEWLINE> path . append ( 0 ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> while path : <NEWLINE> <INDENT> u = path [ - 1 ] <NEWLINE> adj_v = adj_sets [ u ] . copy ( ) <NEWLINE> v_candidate = adj_v . difference ( path ) <NEWLINE> if v_candidate : <NEWLINE> <INDENT> v = v_candidate . pop ( ) <NEWLINE> cnt += 1 <NEWLINE> prenum [ v ] = cnt <NEWLINE> parent [ v ] = u <NEWLINE> path . append ( v ) <NEWLINE> adj_sets [ u ] . remove ( v ) <NEWLINE> adj_sets [ v ] . remove ( u ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = min ( prenum [ u ] , lowest [ u ] ) <NEWLINE> for v in adj_v : <NEWLINE> <INDENT> l = min ( l , prenum [ v ] ) <NEWLINE> adj_sets [ u ] . remove ( v ) <NEWLINE> adj_sets [ v ] . remove ( u ) <NEWLINE> <DEDENT> lowest [ u ] = l <NEWLINE> p = parent [ u ] <NEWLINE> lowest [ p ] = min ( l , lowest [ p ] ) <NEWLINE> path . pop ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = set ( ) <NEWLINE> <NL> for u in range ( 1 , V ) : <NEWLINE> <INDENT> p = parent [ u ] <NEWLINE> if prenum [ p ] <= lowest [ u ] : <NEWLINE> <INDENT> ans . add ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> if parent . count ( 0 ) >= 3 : <NEWLINE> <INDENT> ans . add ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . discard ( 0 ) <NEWLINE> <NL> <DEDENT> ans = list ( ans ) <NEWLINE> ans . sort ( ) <NEWLINE> <NL> if ans : <NEWLINE> <INDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> g = 0 <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> for b in range ( N ) : <NEWLINE> <INDENT> g_1 = math . gcd ( ( a + 1 ) , ( b + 1 ) ) <NEWLINE> for c in range ( N ) : <NEWLINE> <INDENT> g = g + math . gcd ( g_1 , ( c + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from decimal import Decimal <NEWLINE> <NL> def is_parallel ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : <NEWLINE> <INDENT> d1x = x2 - x1 <NEWLINE> d1y = y2 - y1 <NEWLINE> d2x = x4 - x3 <NEWLINE> d2y = y4 - y3 <NEWLINE> <NL> return d1x * d2y == d1y * d2x <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> data = sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> x1 = Decimal ( data [ 0 ] ) <NEWLINE> y1 = Decimal ( data [ 1 ] ) <NEWLINE> x2 = Decimal ( data [ 2 ] ) <NEWLINE> y2 = Decimal ( data [ 3 ] ) <NEWLINE> x3 = Decimal ( data [ 4 ] ) <NEWLINE> y3 = Decimal ( data [ 5 ] ) <NEWLINE> x4 = Decimal ( data [ 6 ] ) <NEWLINE> y4 = Decimal ( data [ 7 ] ) <NEWLINE> <NL> if is_parallel ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def func ( amat , bmat , nm ) : <NEWLINE> <INDENT> ans = [ [ 0 for i in range ( nm [ 2 ] ) ] for j in range ( nm [ 0 ] ) ] <NEWLINE> for i in range ( nm [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( nm [ 1 ] ) : <NEWLINE> <INDENT> for l in range ( nm [ 2 ] ) : <NEWLINE> <INDENT> ans [ i ] [ l ] += amat [ i ] [ j ] * bmat [ j ] [ l ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , i ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> nm = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> amat = [ [ 0 for i in range ( nm [ 1 ] ) ] for j in range ( nm [ 0 ] ) ] <NEWLINE> bmat = [ [ 0 for i in range ( nm [ 2 ] ) ] for i in range ( nm [ 1 ] ) ] <NEWLINE> <NL> for i in range ( nm [ 0 ] ) : <NEWLINE> <INDENT> a = input ( ) . split ( <STRING> ) <NEWLINE> for j in range ( nm [ 1 ] ) : <NEWLINE> <INDENT> amat [ i ] [ j ] = int ( a [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( nm [ 1 ] ) : <NEWLINE> <INDENT> b = input ( ) . split ( <STRING> ) <NEWLINE> for j in range ( nm [ 2 ] ) : <NEWLINE> <INDENT> bmat [ i ] [ j ] = int ( b [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> func ( amat , bmat , nm ) <NEWLINE> <DEDENT>
print_cnt = int ( input ( ) ) <NEWLINE> <NL> result = [ 0 ] * 10000 <NEWLINE> <NL> for x in range ( 100 ) : <NEWLINE> <INDENT> for y in range ( 100 ) : <NEWLINE> <INDENT> for z in range ( 100 ) : <NEWLINE> <INDENT> if x * y * z == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tmp = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if tmp <= 10000 : <NEWLINE> <INDENT> result [ tmp - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( print_cnt ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ 0 ] * 2000000 <NEWLINE> for i in range ( 1 , 2 * 10 ** 6 ) : <NEWLINE> <INDENT> if i % 100 == 0 : <NEWLINE> <INDENT> ls [ i ] = 1 <NEWLINE> <DEDENT> if i % 10000 == 0 : <NEWLINE> <INDENT> ls [ i ] = 2 <NEWLINE> <DEDENT> if i % 1000000 == 0 : <NEWLINE> <INDENT> ls [ i ] = 3 <NEWLINE> <DEDENT> <DEDENT> ii = 0 <NEWLINE> for i in range ( 1 , 2 * 10 ** 6 ) : <NEWLINE> <INDENT> if ls [ i ] == D : <NEWLINE> <INDENT> ii += 1 <NEWLINE> <DEDENT> if ii == N : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( lambda a : int ( a ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 1 <NEWLINE> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans != - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x = ( int ) ( input ( ) ) <NEWLINE> <NL> flg = False <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> for i in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( - i - 1 , i + 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( - i - 1 , i + 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( str ( j ) + <STRING> + str ( i ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumlist = [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sumlist . append ( sumlist [ i ] + A [ N - 1 - i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * sumlist [ N - 1 - i ] <NEWLINE> <DEDENT> print ( ans % ( 1000000007 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> LR = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> LR . sort ( ) <NEWLINE> <NL> dpsum = [ 0 ] * ( N + 1 ) <NEWLINE> dpsum [ 1 ] = 1 <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for L , R in LR : <NEWLINE> <INDENT> l = i - R <NEWLINE> r = i - L <NEWLINE> <NL> if r < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l = max ( l , 0 ) <NEWLINE> <NL> dp [ i ] += dpsum [ r ] - dpsum [ l - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> dpsum [ i ] = dpsum [ i - 1 ] + dp [ i ] <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <NL> <DEDENT> visited = [ - 1 ] * n <NEWLINE> now = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if visited [ now ] != - 1 : <COMMENT> <NEWLINE> <INDENT> loop = i - visited [ now ] <COMMENT> <NEWLINE> k = ( k - ( i - loop ) ) % loop <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> now = a [ now ] <NEWLINE> <NL> <DEDENT> break <NEWLINE> <NL> <DEDENT> visited [ now ] = i <NEWLINE> now = a [ now ] <NEWLINE> <NL> <DEDENT> print ( now + 1 ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> ans = INF <NEWLINE> <NL> for i in range ( 1 , 2 ** N ) : <NEWLINE> <INDENT> skills = [ 0 ] * M <NEWLINE> total_cost = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> total_cost += C [ j ] [ 0 ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> skills [ k ] += C [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( skills ) >= X : <NEWLINE> <INDENT> ans = min ( ans , total_cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans if ans != INF else - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> <INDENT> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = s [ 0 ] <NEWLINE> <NL> if not 0 in s : <NEWLINE> <INDENT> if len ( s ) > 1 : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = a * s [ i ] <NEWLINE> <NL> if a > 10 ** 18 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> K = int ( input ( ) ) <NEWLINE> L = 9 * K <NEWLINE> if L % 7 == 0 : <NEWLINE> <INDENT> L = L // 7 <NEWLINE> <DEDENT> n = 1 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> n = n * 10 % L <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> K = int ( input ( ) ) <NEWLINE> x = np . arange ( 1 , K + 1 ) <NEWLINE> nums = np . gcd . outer ( np . gcd . outer ( x , x ) , x ) <NEWLINE> print ( nums . sum ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for _ in range ( n ) ] <NEWLINE> f = lambda x : int ( x ) - 1 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( f , input ( ) . split ( ) ) <NEWLINE> root [ a ] . append ( b ) <NEWLINE> root [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> score = [ 0 ] * n <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visit = [ False ] * n <NEWLINE> def dfs ( now ) : <NEWLINE> <INDENT> visit [ now ] = True <NEWLINE> for go in root [ now ] : <NEWLINE> <INDENT> if visit [ go ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> score [ go ] += score [ now ] <NEWLINE> dfs ( go ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * score ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> nb = str ( bin ( n ) ) [ 2 : ] <NEWLINE> nblis = [ ] <NEWLINE> for k in range ( len ( nb ) ) : <NEWLINE> <INDENT> if nb [ - k - 1 ] == <STRING> : <NEWLINE> <INDENT> nblis . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> two = [ 2 ] <NEWLINE> for k in range ( len ( nb ) - 1 ) : <NEWLINE> <INDENT> two . append ( two [ - 1 ] * two [ - 1 ] % mod ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> for item in nblis : <NEWLINE> <INDENT> ans = ans * two [ item ] % mod <NEWLINE> <NL> <NL> <NL> <DEDENT> bi = str ( bin ( mod - 2 ) ) [ 2 : ] <NEWLINE> blis = [ ] <NEWLINE> for k in range ( len ( bi ) ) : <NEWLINE> <INDENT> if bi [ - k - 1 ] == <STRING> : <NEWLINE> <INDENT> blis . append ( k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def modinv ( N ) : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> li = [ ] <NEWLINE> for _ in range ( len ( bi ) ) : <NEWLINE> <INDENT> li . append ( N % mod ) <NEWLINE> N = N * N % mod <NEWLINE> <DEDENT> for item in blis : <NEWLINE> <INDENT> res = res * li [ item ] % mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> ans_a = 1 <NEWLINE> for k in range ( n - a + 1 , n + 1 ) : <NEWLINE> <INDENT> ans_a = ans_a * k % mod <NEWLINE> <DEDENT> amother = 1 <NEWLINE> for k in range ( 2 , a + 1 ) : <NEWLINE> <INDENT> amother = amother * k % mod <NEWLINE> <DEDENT> ans_a = ans_a * modinv ( amother ) % mod <NEWLINE> <NL> <NL> ans_b = 1 <NEWLINE> for k in range ( n - b + 1 , n + 1 ) : <NEWLINE> <INDENT> ans_b = ans_b * k % mod <NEWLINE> <DEDENT> bmother = 1 <NEWLINE> for k in range ( 2 , b + 1 ) : <NEWLINE> <INDENT> bmother = bmother * k % mod <NEWLINE> <DEDENT> ans_b = ans_b * modinv ( bmother ) % mod <NEWLINE> <NL> print ( ( ans - ans_a - ans_b - 1 ) % mod ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> import networkx as nx <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = np . frombuffer ( read ( ) , <STRING> ) . reshape ( N , - 1 ) [ : , : M ] . astype ( <STRING> ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> E = [ ] <NEWLINE> <NL> for i , j in itertools . product ( range ( N ) , range ( M ) ) : <NEWLINE> <INDENT> if S [ i , j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ( i + j ) & 1 : <NEWLINE> <INDENT> A . append ( ( i , j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , j in A : <NEWLINE> <INDENT> for dx , dy in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> i1 , j1 = i + dx , j + dy <NEWLINE> if 0 <= i1 < N and 0 <= j1 < M and S [ i1 , j1 ] != <STRING> : <NEWLINE> <INDENT> E . append ( ( ( i , j ) , ( i1 , j1 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> G = nx . Graph ( ) <NEWLINE> G . add_nodes_from ( A , bipartite = 0 ) <NEWLINE> G . add_nodes_from ( B , bipartite = 1 ) <NEWLINE> G . add_edges_from ( E ) <NEWLINE> <NL> M = nx . bipartite . eppstein_matching ( G , A ) <NEWLINE> for key , item in M . items ( ) : <NEWLINE> <INDENT> i , j = key <NEWLINE> i1 , j1 = item <NEWLINE> if i1 == i + 1 : <NEWLINE> <INDENT> a , b = <STRING> , <STRING> <NEWLINE> <DEDENT> elif i1 == i - 1 : <NEWLINE> <INDENT> a , b = <STRING> , <STRING> <NEWLINE> <DEDENT> elif j1 == j + 1 : <NEWLINE> <INDENT> a , b = <STRING> , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = <STRING> , <STRING> <NEWLINE> <DEDENT> S [ i , j ] , S [ i1 , j1 ] = a , b <NEWLINE> <NL> <DEDENT> print ( len ( M ) // 2 ) <NEWLINE> for row in S : <NEWLINE> <INDENT> print ( <STRING> . join ( row ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for x in range ( 1 , 9 + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , 9 + 1 ) : <NEWLINE> <INDENT> if x * y == n : <NEWLINE> <INDENT> a = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ True ] * ( N + 1 ) <NEWLINE> D = [ 1 ] + [ 0 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> B [ a ] = False <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( N , i + 2 ) + 1 ) : <NEWLINE> <INDENT> if B [ j ] : <NEWLINE> <INDENT> D [ j ] = ( D [ j ] + D [ i ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( D [ N ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in li : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> p = 2019 <NEWLINE> n = 0 <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * p <NEWLINE> mods [ 0 ] = 1 <NEWLINE> for i , j in enumerate ( reversed ( s ) ) : <NEWLINE> <INDENT> n += int ( j ) * pow ( 10 , i , p ) <NEWLINE> n %= p <NEWLINE> mods [ n ] += 1 <NEWLINE> <DEDENT> for i in mods : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> quantity , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( input ( ) ) <NEWLINE> yes = 0 <NEWLINE> abroad = 0 <NEWLINE> <NL> for i in range ( quantity ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> if yes < ( A + B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yes = yes + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> abroad = abroad + 1 <NEWLINE> if yes < ( A + B ) and abroad <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yes = yes + 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( n , b - 1 ) <NEWLINE> print ( ( ( a * x ) // b ) - ( a * ( x // b ) ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd_ab = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd_ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> r = x % y <NEWLINE> <NL> while r != 0 : <NEWLINE> <INDENT> x = y <NEWLINE> y = r <NEWLINE> r = x % y <NEWLINE> <DEDENT> print ( y ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> an = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> <NL> answer = [ 0 for _ in range ( n ) ] <NEWLINE> for index in range ( n ) : <NEWLINE> <INDENT> answer [ an [ index ] - 1 ] = str ( index + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( answer ) ) <NEWLINE>
row = int ( input ( ) ) <NEWLINE> item_list = [ input ( ) for i in range ( row ) ] <NEWLINE> print ( len ( set ( item_list ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( x , m ) : <NEWLINE> <INDENT> return x ** 2 % m <NEWLINE> <NL> <DEDENT> check = [ False for _ in range ( M ) ] <NEWLINE> d = [ X ] <NEWLINE> max_x = 0 <NEWLINE> for _ in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> X = f ( X , M ) <NEWLINE> if check [ X ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check [ X ] = True <NEWLINE> <DEDENT> d . append ( X ) <NEWLINE> <NL> <DEDENT> idx = d . index ( X ) <NEWLINE> ans = sum ( d [ : idx ] ) <NEWLINE> N -= idx <NEWLINE> d = d [ idx : ] <NEWLINE> <NL> sumd = sum ( d ) <NEWLINE> ans += N // len ( d ) * sumd <NEWLINE> <NL> ans += sum ( d [ : N % len ( d ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> s = sum ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> s -= a <NEWLINE> ans += s * a <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> l [ a ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if l [ i ] > 0 : <NEWLINE> <INDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
g = { } <NEWLINE> a = int ( input ( ) ) <NEWLINE> for i in range ( a - 1 ) : <NEWLINE> <INDENT> c = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> if c [ 0 ] not in g : g [ c [ 0 ] ] = [ ( c [ 1 ] , c [ 2 ] ) ] <NEWLINE> else : g [ c [ 0 ] ] . append ( ( c [ 1 ] , c [ 2 ] ) ) <NEWLINE> <NL> if c [ 1 ] not in g : g [ c [ 1 ] ] = [ ( c [ 0 ] , c [ 2 ] ) ] <NEWLINE> else : g [ c [ 1 ] ] . append ( ( c [ 0 ] , c [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> c = { } <NEWLINE> d = { i : False for i in range ( 1 , a + 1 ) } <NEWLINE> c [ 1 ] , d [ 1 ] = 0 , True <NEWLINE> Q = [ 1 ] <NEWLINE> while ( Q != [ ] ) : <NEWLINE> <INDENT> r = Q . pop ( 0 ) <NEWLINE> for i in g [ r ] : <NEWLINE> <INDENT> if d [ i [ 0 ] ] == False : <NEWLINE> <INDENT> d [ i [ 0 ] ] = True <NEWLINE> Q . append ( i [ 0 ] ) <NEWLINE> if i [ 1 ] % 2 == 0 : c [ i [ 0 ] ] = c [ r ] <NEWLINE> else : c [ i [ 0 ] ] = ( c [ r ] + 1 ) % 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , a + 1 ) : print ( c [ i ] ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( a - b ) == 1 : <NEWLINE> <INDENT> c = math . factorial ( a ) % ( 10 ** 9 + 7 ) <NEWLINE> d = math . factorial ( b ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( c * d % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> if abs ( a - b ) == 0 : <NEWLINE> <INDENT> c = math . factorial ( a ) % ( 10 ** 9 + 7 ) <NEWLINE> d = math . factorial ( b ) % ( 10 ** 9 + 7 ) <NEWLINE> print ( c * d * 2 % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> if abs ( a - b ) >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> price = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> price += l [ i ] <NEWLINE> <DEDENT> print ( price ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = len ( Alst ) <NEWLINE> Blst = [ 0 ] * l <NEWLINE> k = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( l - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> k = ( k + Alst [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> Blst [ i ] = k <NEWLINE> <NL> <DEDENT> for j in range ( l - 1 ) : <NEWLINE> <INDENT> ans = ( ans + Alst [ j ] * Blst [ j + 1 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x , y = x - 1 , y - 1 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp = [ n ] * n <NEWLINE> dp [ i ] = 0 <NEWLINE> calcstep ( i , dp ) <NEWLINE> dp [ y ] = min ( dp [ y ] , dp [ x ] + 1 ) <NEWLINE> dp [ x ] = min ( dp [ x ] , dp [ y ] + 1 ) <NEWLINE> calcstep ( x , dp ) <NEWLINE> calcstep ( y , dp ) <NEWLINE> <COMMENT> <NL> ans += dp <NEWLINE> <DEDENT> ans = Counter ( ans ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def calcstep ( i , dp ) : <NEWLINE> <INDENT> for j in range ( i , len ( dp ) - 1 ) : <NEWLINE> <INDENT> if dp [ j + 1 ] > dp [ j ] + 1 : <NEWLINE> <INDENT> dp [ j + 1 ] = dp [ j ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , i + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> if dp [ j - 1 ] > dp [ j ] + 1 : <NEWLINE> <INDENT> dp [ j - 1 ] = dp [ j ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> <COMMENT> <NL> BC . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> temp = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> temp += [ BC [ i ] [ 1 ] ] * BC [ i ] [ 0 ] <NEWLINE> if len ( temp ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += temp <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( A [ : N ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> if a [ i + k - 1 ] / a [ i - 1 ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> boss = [ 0 ] * N <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> boss [ x - 1 ] += 1 <NEWLINE> <DEDENT> for i in boss : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> distance = ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> print ( <STRING> . format ( distance ) ) <NEWLINE>
S = input ( ) <NEWLINE> count = [ 0 ] <NEWLINE> s = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 2 or S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s = s + 1 <NEWLINE> count . append ( s ) <NEWLINE> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( count ) ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> buf = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if buf [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> cnt = cnt * buf [ i ] <NEWLINE> if cnt > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if int ( input ( ) ) % 9 else <STRING> ) <NEWLINE>
try : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> lis1 = [ ] <NEWLINE> for i in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> for a in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> if a != i : <NEWLINE> <INDENT> z = ( int ( n [ a ] ) + int ( n [ i ] ) ) <NEWLINE> lis1 . append ( z ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> minscore = <STRING> <NEWLINE> for i in range ( 0 , len ( lis1 ) ) : <NEWLINE> <INDENT> if float ( minscore ) > float ( lis1 [ i ] ) : <NEWLINE> <INDENT> minscore = lis1 [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minscore ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_cum , B_cum = [ 0 ] , [ 0 ] <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> A_cum . append ( A_cum [ i ] + a ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B_cum . append ( B_cum [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> best = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> a_time = A_cum [ i ] <NEWLINE> for j in range ( best , - 1 , - 1 ) : <NEWLINE> <INDENT> if B_cum [ j ] <= k - a_time : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> best = j <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( 1 , k ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k ) : <NEWLINE> <INDENT> ans += math . gcd ( d , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> ans = 0 <NEWLINE> if b > n : <NEWLINE> <INDENT> x = n <NEWLINE> ans = math . floor ( a * n / b ) - a * math . floor ( n / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = b - 1 <NEWLINE> ans = math . floor ( a * n / b ) - a * math . floor ( n / b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - ( k - a - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> min_card , max_card = 0 , n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> min_card = max ( min_card , l ) <NEWLINE> max_card = min ( max_card , r ) <NEWLINE> <COMMENT> <NL> <DEDENT> if min_card <= max_card : <NEWLINE> <INDENT> print ( max_card - min_card + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> M = [ 0 for _ in range ( 2019 ) ] <NEWLINE> <COMMENT> <NL> M [ 0 ] += 1 <NEWLINE> old = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> new_s = int ( S [ N - 1 - i ] ) * pow ( 10 , i , 2019 ) <NEWLINE> new = ( new_s + old ) % 2019 <NEWLINE> M [ new ] += 1 <NEWLINE> old = new <NEWLINE> <DEDENT> count = 0 <NEWLINE> for m in M : <NEWLINE> <INDENT> count += int ( m * ( m - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = ( j - i ) + j <NEWLINE> if k >= n : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <NL> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if result <= 10 ** 18 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import collections <NEWLINE> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( N ) ] <NEWLINE> cnt = collections . Counter ( S ) <NEWLINE> ans = 0 <NEWLINE> for v in cnt . values ( ) : <NEWLINE> <INDENT> if v != 1 : <NEWLINE> <INDENT> ans += math . factorial ( v ) // ( math . factorial ( v - 2 ) * 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
t = [ { ( 0 , 1 ) , ( 1 , 0 ) , ( 1 , 1 ) } , <NEWLINE> <INDENT> { ( 1 , 0 ) , ( 2 , 0 ) , ( 3 , 0 ) } , <NEWLINE> { ( 0 , 1 ) , ( 0 , 2 ) , ( 0 , 3 ) } , <NEWLINE> { ( 1 , - 1 ) , ( 1 , 0 ) , ( 2 , - 1 ) } , <NEWLINE> { ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 2 ) } , <NEWLINE> { ( 1 , 0 ) , ( 1 , 1 ) , ( 2 , 1 ) } , <NEWLINE> { ( 0 , 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) } <NEWLINE> <DEDENT> ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> l = [ input ( ) for _ in range ( 8 ) ] <NEWLINE> pos = sorted ( [ ( i , j ) for i in range ( 8 ) for j in range ( 8 ) if l [ i ] [ j ] == <STRING> ] ) <NEWLINE> cv = lambda v : tuple ( [ v [ 0 ] - pos [ 0 ] [ 0 ] , v [ 1 ] - pos [ 0 ] [ 1 ] ] ) <NEWLINE> pt = set ( map ( cv , pos ) ) <NEWLINE> [ print ( chr ( 65 + i ) ) for ( i , j ) in enumerate ( t ) if pt & j == j ] <NEWLINE> try : <NEWLINE> <INDENT> input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> result = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for fst_idx in range ( n ) : <NEWLINE> <INDENT> for scd_idx in range ( fst_idx + 1 , n ) : <NEWLINE> <INDENT> trd_idx = scd_idx * 2 - fst_idx <NEWLINE> if trd_idx >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ fst_idx ] != s [ scd_idx ] and s [ scd_idx ] != s [ trd_idx ] and s [ trd_idx ] != s [ fst_idx ] : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> lim = n // i <NEWLINE> ans += lim * ( lim + 1 ) * i // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = readline ( ) . strip ( ) [ : : - 1 ] <NEWLINE> N = len ( S ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += int ( S [ i ] ) * pow ( 10 , i , 2019 ) <NEWLINE> a . append ( s % 2019 ) <NEWLINE> <NL> <DEDENT> t = Counter ( a ) <NEWLINE> <NL> ans = 0 <NEWLINE> for _ , v in t . items ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = str ( input ( ) ) <NEWLINE> c = b . count ( <STRING> ) <NEWLINE> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = input ( ) . split ( ) <NEWLINE> x = int ( a ) <NEWLINE> y = int ( b ) <NEWLINE> z = int ( c ) <NEWLINE> p = [ x , y , z ] <NEWLINE> p . sort ( ) <NEWLINE> if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> a = 1 <NEWLINE> ok = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> ar . sort ( ) <NEWLINE> for i in ar : <NEWLINE> <INDENT> a *= i <NEWLINE> if ( i == 0 ) : <NEWLINE> <INDENT> ok = 1 <NEWLINE> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> if ( a > 1000000000000000000 ) : <NEWLINE> <INDENT> ok = 1 <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if ( ok == 0 ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys , pprint <NEWLINE> <NL> ( N , M ) = map ( int , input ( ) . split ( ) ) <NEWLINE> paths = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> paths [ i ] = set ( ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> ( a , b ) = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ a ] . add ( b ) <NEWLINE> paths [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> result = [ 0 ] * N <NEWLINE> <NL> searchroom = [ ] <NEWLINE> nextsearch = [ ] <NEWLINE> searchroom . append ( 1 ) <NEWLINE> while len ( searchroom ) > 0 : <NEWLINE> <INDENT> for n in searchroom : <NEWLINE> <INDENT> for s in paths [ n ] : <NEWLINE> <INDENT> if result [ s - 1 ] == 0 : <NEWLINE> <INDENT> result [ s - 1 ] = n <NEWLINE> nextsearch . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> searchroom = nextsearch . copy ( ) <NEWLINE> nextsearch . clear ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in result [ 1 : ] : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in result [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> <NL> <STRING> <NEWLINE> <NL> L . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> target = L [ i ] + L [ j ] <NEWLINE> left = bisect_left ( L , target ) <COMMENT> <NEWLINE> ans += max ( 0 , left - j - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def f ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> if a % n == 0 : <NEWLINE> <INDENT> cnt += a // n - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> cnt += a // n <NEWLINE> <DEDENT> <DEDENT> return True if K >= cnt else False <NEWLINE> <NL> <NL> <DEDENT> l = 0 <NEWLINE> r = max ( A ) <NEWLINE> <COMMENT> <NL> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if f ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def mysum ( A , B , C , K ) : <NEWLINE> <INDENT> if K <= A : <NEWLINE> <INDENT> return ( K ) <NEWLINE> <NL> <DEDENT> if K <= A + B : <NEWLINE> <INDENT> return ( A ) <NEWLINE> <NL> <DEDENT> return ( A + - 1 * ( K - A - B ) ) <NEWLINE> <NL> <DEDENT> print ( mysum ( A , B , C , K ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if K - ( A % K ) <= B - A or A % K == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> if n < 3 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) and ( s [ i + 1 ] == <STRING> ) and ( s [ i + 2 ] == <STRING> ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( d ) for d in input ( ) . split ( ) ] <NEWLINE> <NL> MOD = int ( 1e9 + 7 ) <NEWLINE> <NL> A_cum = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_cum . append ( ( A_cum [ - 1 ] + A [ i ] ) % MOD ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> t = ( A [ i ] * ( A_cum [ - 1 ] - A_cum [ i + 1 ] ) % MOD ) % MOD <NEWLINE> ans = ( t + ans ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N , P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( P ** ( 1 / N ) + 1.0E-7 ) <NEWLINE> for i in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> if P % ( i ** N ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> def calculate ( k ) : <NEWLINE> <NL> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> <NL> m = ( ( ( 10 ** res ) - 1 ) // 9 ) * 7 <NEWLINE> <NL> <NL> while m % k > 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> m = m % k <NEWLINE> m = m * 10 + 7 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( K ) <NEWLINE> <NL>
n , m = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = set ( [ ] ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> ans . add ( b ) <NEWLINE> <DEDENT> elif h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> ans . add ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . add ( a ) <NEWLINE> ans . add ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - len ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ l [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import setrecursionlimit <NEWLINE> <NL> <NL> def encode ( i , j ) : <NEWLINE> <INDENT> if i < j : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <DEDENT> return i * ( i - 1 ) // 2 + j + 1 <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v ) : <NEWLINE> <INDENT> if visited [ v ] == 2 : <NEWLINE> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> visited [ v ] = 1 <NEWLINE> for nv in g [ v ] : <NEWLINE> <INDENT> if visited [ nv ] == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dp [ v ] = max ( dp [ v ] , dfs ( nv ) + 1 ) <NEWLINE> <DEDENT> visited [ v ] = 2 <NEWLINE> return dp [ v ] <NEWLINE> <NL> <NL> <DEDENT> setrecursionlimit ( 10 ** 6 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> GAMES_CNT = N * ( N - 1 ) // 2 <NEWLINE> g = [ [ ] for _ in range ( GAMES_CNT + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> orig = 0 <NEWLINE> for j in map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) : <NEWLINE> <INDENT> dest = encode ( i , j ) <NEWLINE> g [ orig ] . append ( dest ) <NEWLINE> orig = dest <NEWLINE> <DEDENT> <DEDENT> dp = [ 0 ] * ( GAMES_CNT + 1 ) <NEWLINE> visited = [ 0 ] * ( GAMES_CNT + 1 ) <NEWLINE> print ( dfs ( 0 ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if a >= k : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> elif a < k : <NEWLINE> <INDENT> ans += a <NEWLINE> if b >= ( k - a ) : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <DEDENT> elif b < ( k - a ) : <NEWLINE> <INDENT> ans += ( ( k - a ) - b ) * - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = [ None ] * N <NEWLINE> i = 0 <NEWLINE> cur = 0 <NEWLINE> m = None <NEWLINE> while True : <NEWLINE> <INDENT> if m is None and r [ cur ] is not None : <NEWLINE> <INDENT> m = i - r [ cur ] <NEWLINE> K = i + ( K - i ) % m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ cur ] = i <NEWLINE> <DEDENT> if i == K : <NEWLINE> <INDENT> print ( cur + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> cur = A [ cur ] - 1 <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> aa . append ( aa [ - 1 ] + i ) <NEWLINE> <DEDENT> bb = [ 0 ] <NEWLINE> for i in b : <NEWLINE> <INDENT> bb . append ( bb [ - 1 ] + i ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if aa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while aa [ i ] + bb [ j ] > k and j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = sorted ( s [ i ] ) <NEWLINE> s [ i ] = <STRING> . join ( s [ i ] ) <NEWLINE> <NL> <DEDENT> t = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] in t : <NEWLINE> <INDENT> t [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ s [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( t [ k ] * ( t [ k ] - 1 ) // 2 for k in t ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U = 10 ** 6 <NEWLINE> D = list ( range ( U + 1 ) ) <NEWLINE> i = 2 <NEWLINE> while i * i <= U : <NEWLINE> <INDENT> if D [ i ] != i : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i * i , U + 1 , i ) : <NEWLINE> <INDENT> D [ j ] = min ( D [ j ] , i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> C = [ 0 ] * ( U + 1 ) <NEWLINE> is_pairwise = True <NEWLINE> for a in A : <NEWLINE> <INDENT> while a > 1 : <NEWLINE> <INDENT> d = D [ a ] <NEWLINE> while a % d == 0 : <NEWLINE> <INDENT> a //= d <NEWLINE> <DEDENT> if C [ d ] : <NEWLINE> <INDENT> is_pairwise = False <NEWLINE> <DEDENT> C [ d ] += 1 <NEWLINE> <DEDENT> <DEDENT> if max ( C ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if is_pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = set ( [ ] ) <NEWLINE> counter = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in lst : continue <NEWLINE> lst . add ( s ) <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> print ( counter ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> S = input ( ) <NEWLINE> B = defaultdict ( int ) <NEWLINE> B [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> prev = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> m = ( prev + int ( S [ - i - 1 ] ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> ans += B [ m ] <NEWLINE> B [ m ] += 1 <NEWLINE> prev = m <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i + 1 ] += a [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b [ i + 1 ] += b [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> r = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while 0 < r and k < a [ i ] + b [ r ] : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <NL> <DEDENT> if a [ i ] + b [ r ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + r ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ a - 1 ] . append ( b - 1 ) <NEWLINE> L [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> d = deque ( [ 0 ] ) <NEWLINE> D = [ - 1 ] * n <NEWLINE> D [ 0 ] = 0 <NEWLINE> while len ( d ) > 0 : <NEWLINE> <INDENT> t = d . popleft ( ) <NEWLINE> for i in L [ t ] : <NEWLINE> <INDENT> if D [ i ] == - 1 : <NEWLINE> <INDENT> D [ i ] = t <NEWLINE> d . append ( i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( D [ i ] + 1 ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> l1 = list ( int ( l ) + i - 1 for i in range ( 1 , n + 1 ) ) <NEWLINE> n1 = sum ( l1 ) <NEWLINE> ans = min ( l1 , key = abs ) <NEWLINE> <NL> print ( n1 - ( ans ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = 1 <NEWLINE> INF = 1000000000000000000 <NEWLINE> <NL> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans > INF ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def price ( target , item , recipe ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> <NL> if target in recipe : <NEWLINE> <INDENT> ret . append ( sum ( price ( r , item , recipe ) for r in recipe [ target ] ) ) <NEWLINE> <DEDENT> if target in item : <NEWLINE> <INDENT> ret . append ( item [ target ] ) <NEWLINE> <DEDENT> if len ( ret ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> return min ( ret ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( f . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> item = [ f . readline ( ) . split ( ) for _ in range ( n ) ] <NEWLINE> item = { name : int ( price ) for name , price in item } <NEWLINE> recipe = [ f . readline ( ) . strip ( ) . split ( ) for _ in range ( int ( f . readline ( ) ) ) ] <NEWLINE> recipe = { r [ 0 ] : r [ 2 : ] for r in recipe } <NEWLINE> print ( price ( f . readline ( ) . strip ( ) , item , recipe ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> Cs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ss = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ss . append ( s ) <NEWLINE> <NL> <DEDENT> Ss = np . array ( Ss ) <NEWLINE> <NL> solution = np . argmax ( Ss , axis = 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for s in solution : <NEWLINE> <INDENT> print ( s + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = [ [ 1 ] * 201 for _ in range ( 201 ) ] <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> A , B = a , b <NEWLINE> if L [ a ] [ b ] != 1 : <NEWLINE> <INDENT> return L [ a ] [ b ] <NEWLINE> <DEDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> L [ A ] [ B ] = a <NEWLINE> return a <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for y in range ( x , N + 1 ) : <NEWLINE> <INDENT> for z in range ( y , N + 1 ) : <NEWLINE> <INDENT> t = gcd ( x , y ) <NEWLINE> u = gcd ( t , z ) <NEWLINE> if x == y == z : <NEWLINE> <INDENT> ans += u <NEWLINE> <DEDENT> elif x != y and y != z : <NEWLINE> <INDENT> ans += u * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += u * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> H , W , M = map ( int , next ( in_ ) . split ( ) ) <NEWLINE> targets = tuple ( tuple ( map ( int , line . split ( ) ) ) for line in in_ ) <NEWLINE> <NL> target_h = { } <NEWLINE> target_w = { } <NEWLINE> target_hw = set ( ) <NEWLINE> for h , w in targets : <NEWLINE> <INDENT> target_h [ h ] = target_h . setdefault ( h , 0 ) + 1 <NEWLINE> target_w [ w ] = target_w . setdefault ( w , 0 ) + 1 <NEWLINE> target_hw . add ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> max_h = max ( target_h . values ( ) ) <NEWLINE> max_w = max ( target_w . values ( ) ) <NEWLINE> <NL> h_set = { h for h , v in target_h . items ( ) if max_h == v } <NEWLINE> w_set = { w for w , v in target_w . items ( ) if max_w == v } <NEWLINE> <NL> ans = max_h + max_w - 1 <NEWLINE> for hw in itertools . product ( h_set , w_set ) : <NEWLINE> <INDENT> if hw not in target_hw : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i + 1 ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> cnt = len ( r ) * len ( g ) * len ( b ) <NEWLINE> if n <= 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if j * 2 - i < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ j * 2 - i ] and s [ j * 2 - i ] != s [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> src = [ tuple ( map ( float , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> if M <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dists = [ [ None for j in range ( N ) ] for i in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> l1 , a1 , b1 = src [ i ] <NEWLINE> l2 , a2 , b2 = src [ j ] <NEWLINE> dist = 0 <NEWLINE> dist += ( l1 - l2 ) ** 2 + ( a1 - a2 ) ** 2 + ( b1 - b2 ) ** 2 <NEWLINE> dists [ i ] [ j ] = dists [ j ] [ i ] = dist <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ptn in list ( itertools . combinations ( range ( N ) , M ) ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , M ) : <NEWLINE> <INDENT> total += dists [ ptn [ i ] ] [ ptn [ j ] ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , total ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 10 ** 18 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if cnt >= P [ i ] : <NEWLINE> <INDENT> cnt = P [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
M = 1000000007 <NEWLINE> def findProductSum ( A , n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> <DEDENT> array_sum_square = s * s <NEWLINE> individual_square_sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> individual_square_sum += A [ i ] * A [ i ] <NEWLINE> <DEDENT> return ( array_sum_square - individual_square_sum ) // 2 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( findProductSum ( a , n ) % M ) <NEWLINE>
<NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . root = list ( range ( N + 1 ) ) <NEWLINE> self . size = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , x ) : <NEWLINE> <INDENT> root = self . root <NEWLINE> while root [ x ] != x : <NEWLINE> <INDENT> root [ x ] = root [ root [ x ] ] <NEWLINE> x = root [ x ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def merge ( self , x , y ) : <NEWLINE> <INDENT> x = self [ x ] <NEWLINE> y = self [ y ] <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> sx , sy = self . size [ x ] , self . size [ y ] <NEWLINE> if sx < sy : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> sx , sy = sy , sx <NEWLINE> <DEDENT> self . root [ y ] = x <NEWLINE> self . size [ x ] += sy <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self [ x ] == self [ y ] <NEWLINE> <NL> <DEDENT> def find_max ( self ) : <NEWLINE> <INDENT> return max ( self . size ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> merge = uf . merge <NEWLINE> same = uf . same <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> merge ( a , b ) <NEWLINE> <DEDENT> count = - 1 <NEWLINE> for ind , j in enumerate ( uf . root ) : <NEWLINE> <INDENT> if ind == j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count - 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> mod1 = 998244353 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def MI ( ) : return map ( int , inp ( ) . strip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , inp ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in sys . stdin . readlines ( ) . strip ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in inp ( ) . strip ( ) . split ( ) ] <COMMENT> <NEWLINE> def LF ( ) : return [ float ( x ) for x in inp ( ) . strip ( ) . split ( ) ] <COMMENT> <NEWLINE> def LS ( ) : return inp ( ) . strip ( ) . split ( ) <COMMENT> <NEWLINE> def I ( ) : return int ( inp ( ) . strip ( ) ) <COMMENT> <NEWLINE> def F ( ) : return float ( inp ( ) . strip ( ) ) <COMMENT> <NEWLINE> def S ( ) : return inp ( ) . strip ( ) <COMMENT> <NEWLINE> def pf ( s ) : return out ( s + <STRING> ) <NEWLINE> def JA ( a , sep ) : return sep . join ( map ( str , a ) ) <COMMENT> <NEWLINE> def JAA ( a , s , t ) : return s . join ( t . join ( map ( str , b ) ) for b in a ) <NEWLINE> def modinv ( n , p ) : return pow ( n , p - 2 , p ) <NEWLINE> def ncr ( n , r , p ) : <NEWLINE> <INDENT> t = ( ( fact [ n ] ) * ( ( ifact [ r ] * ifact [ n - r ] ) % p ) ) % p <NEWLINE> return t <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> a = LI ( ) <NEWLINE> p = 1 <NEWLINE> flag = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> p *= i <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif p > 10 ** 18 or flag == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> py2 = round ( 0.5 ) <NEWLINE> if py2 : <NEWLINE> <INDENT> from future_builtins import ascii , filter , hex , map , oct , zip <NEWLINE> range = xrange <NEWLINE> <NL> <DEDENT> import os , sys <NEWLINE> from io import IOBase , BytesIO <NEWLINE> <NL> BUFSIZE = 8192 <NEWLINE> class FastIO ( BytesIO ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _file = file <NEWLINE> self . _fd = file . fileno ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> in file . mode <NEWLINE> self . write = super ( FastIO , self ) . write if self . writable else None <NEWLINE> <NL> <DEDENT> def _fill ( self ) : <NEWLINE> <INDENT> s = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . seek ( ( self . tell ( ) , self . seek ( 0 , 2 ) , super ( FastIO , self ) . write ( s ) ) [ 0 ] ) <NEWLINE> return s <NEWLINE> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while self . _fill ( ) : pass <NEWLINE> return super ( FastIO , self ) . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> s = self . _fill ( ) ; self . newlines = s . count ( <STRING> ) + ( not s ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return super ( FastIO , self ) . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . getvalue ( ) ) <NEWLINE> self . truncate ( 0 ) , self . seek ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> if py2 : <NEWLINE> <INDENT> self . write = self . buffer . write <NEWLINE> self . read = self . buffer . read <NEWLINE> self . readline = self . buffer . readline <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> <NL> inp = lambda : sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> out = lambda x : sys . stdout . write ( x ) <NEWLINE> flsh = lambda : sys . stdout . flush ( ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += i * ( y * ( y + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> def insertion_sort ( num_list , length , interval ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( interval , length ) : <NEWLINE> <INDENT> v = num_list [ i ] <NEWLINE> j = i - interval <NEWLINE> while j >= 0 and num_list [ j ] > v : <NEWLINE> <INDENT> num_list [ j + interval ] = num_list [ j ] <NEWLINE> j = j - interval <NEWLINE> cnt = cnt + 1 <NEWLINE> <DEDENT> num_list [ j + interval ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shell_sort ( num_list , length ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> h = 4 <NEWLINE> intervals = [ 1 , ] <NEWLINE> while length > h : <NEWLINE> <INDENT> intervals . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> for i in reversed ( range ( len ( intervals ) ) ) : <NEWLINE> <INDENT> cnt = cnt + insertion_sort ( num_list , length , intervals [ i ] ) <NEWLINE> <DEDENT> print ( len ( intervals ) ) <NEWLINE> show_list ( intervals ) <NEWLINE> print ( cnt ) <NEWLINE> <NL> <DEDENT> def show_list ( list ) : <NEWLINE> <INDENT> i = len ( list ) - 1 ; <NEWLINE> while i > 0 : <NEWLINE> <INDENT> print ( list [ i ] , end = <STRING> ) <NEWLINE> i = i - 1 <NEWLINE> <DEDENT> print ( list [ i ] ) <NEWLINE> <NL> <DEDENT> input_num = int ( input ( ) ) <NEWLINE> input_list = list ( ) <NEWLINE> for i in range ( input_num ) : <NEWLINE> <INDENT> input_list . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shell_sort ( input_list , input_num ) <NEWLINE> for num in input_list : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r_count = s . count ( <STRING> ) <NEWLINE> new_s = s [ : r_count ] <NEWLINE> print ( new_s . count ( <STRING> ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = n // ( a + b ) * a <NEWLINE> rem = n % ( a + b ) <NEWLINE> ans += min ( rem , a ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
words = input ( ) <NEWLINE> for i in range ( 1 , len ( words ) + 1 ) : <NEWLINE> <INDENT> print ( words [ - i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
T = list ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if i == len ( T ) - 1 : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i > 0 and T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> or T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import time <NEWLINE> sys . setrecursionlimit ( 20000 ) <NEWLINE> INT_MAX = 2 ** 31 - 1 <NEWLINE> <NL> def update ( tree , x , y , z , N ) : <NEWLINE> <INDENT> left = x + N <COMMENT> <NEWLINE> right = y + N <COMMENT> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if ( left >= right ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( right % 2 == 1 ) : <NEWLINE> <INDENT> right -= 1 <NEWLINE> tree [ right - 1 ] = z <NEWLINE> <DEDENT> if ( left % 2 == 1 ) : <NEWLINE> <INDENT> tree [ left - 1 ] = z <NEWLINE> left += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> left >>= 1 <NEWLINE> right >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( tree , x , N ) : <NEWLINE> <INDENT> x += N - 1 <NEWLINE> s = ( INT_MAX , - 1 ) <NEWLINE> while True : <NEWLINE> <INDENT> if ( x < 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( tree [ x ] [ 0 ] is not None and ( tree [ x ] [ 1 ] > s [ 1 ] ) ) : <NEWLINE> <INDENT> s = tree [ x ] <NEWLINE> <DEDENT> x = math . floor ( ( x - 1 ) / 2 ) <NEWLINE> <DEDENT> return s [ 0 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _N , query_num = map ( int , input ( ) . split ( ) ) <NEWLINE> N = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( N >= _N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N *= 2 <NEWLINE> <DEDENT> A = [ ( None , - 1 ) ] * ( 2 * N - 1 ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( query_num ) : <NEWLINE> <INDENT> query = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if ( query [ 0 ] == 0 ) : <NEWLINE> <INDENT> update ( A , query [ 1 ] , query [ 2 ] + 1 , ( query [ 3 ] , i ) , N ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if ( query [ 0 ] == 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> z = find ( A , query [ 1 ] , N ) <NEWLINE> print ( z ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> kai = 0 <NEWLINE> xy = abs ( X ) <NEWLINE> if xy >= K * D : <NEWLINE> <INDENT> kotae = abs ( xy - ( K * D ) ) <NEWLINE> <DEDENT> if xy < K * D : <NEWLINE> <INDENT> kai , mod = divmod ( xy , D ) <NEWLINE> ds = kai * D <NEWLINE> if ( K - kai ) % 2 == 0 : <NEWLINE> <INDENT> kotae = abs ( xy - ds ) <NEWLINE> <DEDENT> if ( K - kai ) % 2 != 0 : <NEWLINE> <INDENT> kouho1 = abs ( xy - ds - D ) <NEWLINE> kouho2 = abs ( xy - ds + D ) <NEWLINE> if kouho1 >= kouho2 : <NEWLINE> <INDENT> kotae = kouho2 <NEWLINE> <DEDENT> if kouho1 < kouho2 : <NEWLINE> <INDENT> kotae = kouho1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( kotae ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from decimal import Decimal <NEWLINE> <NL> r = Decimal ( sys . stdin . readline ( ) ) <NEWLINE> area = r ** Decimal ( 2 ) * Decimal ( math . pi ) <NEWLINE> circumference = r * Decimal ( 2 ) * Decimal ( math . pi ) <NEWLINE> <NL> print ( round ( area , 5 ) , round ( circumference , 5 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> way_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> org = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> org . sort ( ) <NEWLINE> way_list . append ( org ) <NEWLINE> <NL> <DEDENT> bad = [ ] <NEWLINE> <NL> for j in range ( m ) : <NEWLINE> <INDENT> way = way_list [ j ] <NEWLINE> if h_list [ way [ 0 ] - 1 ] > h_list [ way [ 1 ] - 1 ] : <NEWLINE> <INDENT> bad . append ( way [ 1 ] ) <NEWLINE> <DEDENT> elif h_list [ way [ 0 ] - 1 ] < h_list [ way [ 1 ] - 1 ] : <NEWLINE> <INDENT> bad . append ( way [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad . append ( way [ 0 ] ) <NEWLINE> bad . append ( way [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> bad = list ( set ( bad ) ) <NEWLINE> print ( n - len ( bad ) ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> dist = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> print ( <STRING> % ( dist ) ) <NEWLINE>
class Queue ( ) : <NEWLINE> <INDENT> def __init__ ( self , size = 10 ) : <NEWLINE> <INDENT> self . queue = [ None ] * size <NEWLINE> self . head = self . tail = 0 <NEWLINE> self . MAX = size <NEWLINE> self . num_items = 0 <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . num_items == 0 <NEWLINE> <NL> <DEDENT> def is_full ( self ) : <NEWLINE> <INDENT> return self . num_items == self . MAX <NEWLINE> <NL> <DEDENT> def enqueue ( self , x ) : <NEWLINE> <INDENT> if self . is_full ( ) : <NEWLINE> <INDENT> raise IndexError <NEWLINE> <NL> <DEDENT> self . queue [ self . tail ] = x <NEWLINE> self . num_items += 1 <NEWLINE> if self . tail + 1 == self . MAX : <NEWLINE> <INDENT> self . tail = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . tail += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> raise IndexError <NEWLINE> <NL> <DEDENT> x = self . queue [ self . head ] <NEWLINE> self . num_items -= 1 <NEWLINE> if self . head + 1 == self . MAX : <NEWLINE> <INDENT> self . head = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . head += 1 <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Process : <NEWLINE> <INDENT> def __init__ ( self , name , time ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . time = time <NEWLINE> <NL> <DEDENT> def print_time ( self ) : <NEWLINE> <INDENT> return self . time <NEWLINE> <NL> <DEDENT> def print_name ( self ) : <NEWLINE> <INDENT> return self . name <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> qq = Queue ( n ) <NEWLINE> <NL> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> p = Process ( name , int ( time ) ) <NEWLINE> qq . enqueue ( p ) <NEWLINE> <NL> <DEDENT> while not qq . is_empty ( ) : <NEWLINE> <INDENT> p = qq . dequeue ( ) <NEWLINE> <NL> if p . time - q <= 0 : <NEWLINE> <INDENT> t += p . time <NEWLINE> print ( <STRING> . format ( p . name , t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . time -= q <NEWLINE> t += q <NEWLINE> qq . enqueue ( p ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = 1 <NEWLINE> l = [ ] <NEWLINE> s = [ 1 ] * n <NEWLINE> <NL> while s [ num - 1 ] : <NEWLINE> <INDENT> l . append ( num ) <NEWLINE> s [ num - 1 ] = 0 <NEWLINE> num = a [ num - 1 ] <NEWLINE> <NL> <DEDENT> if l . index ( num ) <= k : <NEWLINE> <INDENT> l2 = l [ l . index ( num ) : ] <NEWLINE> kk = ( k - len ( set ( l ) - set ( l2 ) ) ) % len ( l2 ) <NEWLINE> print ( l2 [ kk ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> A . sort ( ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = { } <NEWLINE> list1 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> list . setdefault ( b , i ) <NEWLINE> <DEDENT> if a == <STRING> : <NEWLINE> <INDENT> if b in list : <NEWLINE> <INDENT> list1 . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list1 . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in list1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( int ( 1e5 ) ) <NEWLINE> nvertices , nedges = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj = [ [ ] for i in range ( nvertices ) ] <NEWLINE> Adjrev = [ [ ] for i in range ( nvertices ) ] <NEWLINE> for i in range ( nedges ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj [ s ] . append ( t ) <NEWLINE> Adjrev [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> ordering = [ ] <NEWLINE> visited = [ False ] * nvertices <NEWLINE> for u in range ( nvertices ) : <NEWLINE> <INDENT> if not visited [ u ] : <NEWLINE> <INDENT> dfs1 ( u , Adj , visited , ordering ) <NEWLINE> <NL> <DEDENT> <DEDENT> ordering . reverse ( ) <NEWLINE> component_ids = [ - 1 ] * nvertices <NEWLINE> id = 0 <NEWLINE> visited = [ False ] * nvertices <NEWLINE> for u in ordering : <NEWLINE> <INDENT> if visited [ u ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs2 ( u , Adjrev , id , visited , component_ids ) <NEWLINE> id += 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if component_ids [ s ] == component_ids [ t ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs1 ( u , Adj , visited , ordering ) : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> for v in Adj [ u ] : <NEWLINE> <INDENT> if visited [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs1 ( v , Adj , visited , ordering ) <NEWLINE> <DEDENT> ordering . append ( u ) <NEWLINE> <NL> <NL> <DEDENT> def dfs2 ( u , Adj , id , visited , component_ids ) : <NEWLINE> <INDENT> visited [ u ] = True <NEWLINE> component_ids [ u ] = id <NEWLINE> for v in Adj [ u ] : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> dfs2 ( v , Adj , id , visited , component_ids ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> def c ( P1 , P2 , P3 ) : <NEWLINE> <INDENT> x1 , y1 = P1 ; x2 , y2 = P2 ; x3 , y3 = P3 <NEWLINE> a = 2 * ( x1 - x2 ) ; b = 2 * ( y1 - y2 ) ; p = x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2 <NEWLINE> c = 2 * ( x1 - x3 ) ; d = 2 * ( y1 - y3 ) ; q = x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2 <NEWLINE> det = a * d - b * c <NEWLINE> x = d * p - b * q ; y = a * q - c * p <NEWLINE> if det < 0 : <NEWLINE> <INDENT> x = - x ; y = - y ; det = - det <NEWLINE> <DEDENT> if det != 0 : <NEWLINE> <INDENT> x /= det ; y /= det <NEWLINE> <DEDENT> r = ( ( x - x1 ) ** 2 + ( y - y1 ) ** 2 ) ** 0.5 <NEWLINE> return x , y , r <NEWLINE> <NL> <DEDENT> ans = ( 200000 ) ** 2 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> x1 , y1 = A [ i ] [ 0 ] , A [ i ] [ 1 ] <NEWLINE> x2 , y2 = A [ j ] [ 0 ] , A [ j ] [ 1 ] <NEWLINE> x , y = ( x1 + x2 ) / 2 , ( y1 + y2 ) / 2 <NEWLINE> r = ( ( x1 - x ) ** 2 + ( y1 - y ) ** 2 ) ** 0.5 <NEWLINE> for a , b in A : <NEWLINE> <INDENT> d = ( ( a - x ) ** 2 + ( b - y ) ** 2 ) ** 0.5 <NEWLINE> if d > r : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> ans = min ( ans , r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> f = 0 <NEWLINE> <NL> if N > 2 : <NEWLINE> <INDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> x , y , r = c ( A [ i ] , A [ j ] , A [ k ] ) <NEWLINE> if r > 0 : <NEWLINE> <INDENT> for a , b in A : <NEWLINE> <INDENT> d = ( ( a - x ) ** 2 + ( b - y ) ** 2 ) ** 0.5 <NEWLINE> if d > r : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> ans = min ( ans , r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> r , _ = map ( int , e . split ( ) ) <NEWLINE> d = [ int ( <STRING> . join ( x ) , 2 ) for x in zip ( * [ input ( ) . split ( ) for _ in [ 0 ] * r ] ) ] <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 << r ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> for j in d : <NEWLINE> <INDENT> c = bin ( i ^ j ) . count ( <STRING> ) <NEWLINE> b += c if c > r // 2 else r - c <NEWLINE> <DEDENT> a = max ( a , b ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
<NL> <NL> x = int ( input ( ) ) <NEWLINE> h = x // 3600 <NEWLINE> m = ( x - h * 3600 ) // 60 <NEWLINE> s = x - h * 3600 - m * 60 <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
from itertools import product <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> books . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> books_set_all = [ ] <NEWLINE> books_pattern = product ( ( 0 , 1 ) , repeat = n ) <NEWLINE> for each_pattern in books_pattern : <NEWLINE> <INDENT> books_set = [ 0 ] * ( m + 1 ) <NEWLINE> for i1 in range ( n ) : <NEWLINE> <INDENT> if each_pattern [ i1 ] == 1 : <NEWLINE> <INDENT> for i2 in range ( m + 1 ) : <NEWLINE> <INDENT> books_set [ i2 ] += books [ i1 ] [ i2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> books_set_all . append ( books_set ) <NEWLINE> <DEDENT> price_all = [ ] <NEWLINE> for ebs in books_set_all : <NEWLINE> <INDENT> price = ebs [ 0 ] <NEWLINE> ebs [ 0 ] = x <NEWLINE> if len ( [ j for j in ebs if j >= x ] ) == m + 1 : <NEWLINE> <INDENT> price_all . append ( price ) <NEWLINE> <DEDENT> <DEDENT> if len ( price_all ) > 0 : <NEWLINE> <INDENT> print ( min ( price_all ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> import heapq <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def isok ( x ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c += math . ceil ( A [ i ] / x ) - 1 <NEWLINE> <DEDENT> if c <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> start = 0 <NEWLINE> end = max ( A ) <NEWLINE> mid = ( start + end ) // 2 <NEWLINE> while end - start > 1 : <NEWLINE> <INDENT> mid = ( start + end ) // 2 <NEWLINE> if isok ( mid ) == True : <NEWLINE> <INDENT> end = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = mid <NEWLINE> <DEDENT> <DEDENT> print ( end ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans_list = [ ] <NEWLINE> <NL> if X + K * D <= 0 : <NEWLINE> <INDENT> ans = abs ( X + K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( X + K * D ) // ( 2 * D ) <NEWLINE> if a >= K : <NEWLINE> <INDENT> a = K <NEWLINE> ans = abs ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_1 = abs ( X + K * D - 2 * a * D ) <NEWLINE> ans_2 = abs ( X + K * D - 2 * ( a + 1 ) * D ) <NEWLINE> ans = min ( ans_1 , ans_2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import random <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> len_s = len ( s ) <NEWLINE> <NL> if len_s == 3 : <NEWLINE> <INDENT> num = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = random . randint ( 0 , len_s - 4 ) <NEWLINE> <NL> <DEDENT> name = s [ num ] + s [ num + 1 ] + s [ num + 2 ] <NEWLINE> <NL> print ( name ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> def find ( parent , i ) : <NEWLINE> <INDENT> t = parent [ i ] <NEWLINE> if t < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> t = find ( parent , t ) <NEWLINE> parent [ i ] = t <NEWLINE> return t <NEWLINE> <NL> <DEDENT> def unite ( parent , i , j ) : <NEWLINE> <INDENT> i = find ( parent , i ) <NEWLINE> j = find ( parent , j ) <NEWLINE> if i == j : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> parent [ j ] += parent [ i ] <NEWLINE> parent [ i ] = j <NEWLINE> <NL> <DEDENT> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ int ( c ) - 1 for c in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> <NL> parent = [ - 1 ] * N <NEWLINE> inconvenience = N * ( N - 1 ) // 2 <NEWLINE> result = [ ] <NEWLINE> for a , b in AB [ : : - 1 ] : <NEWLINE> <INDENT> result . append ( inconvenience ) <NEWLINE> pa , pb = find ( parent , a ) , find ( parent , b ) <NEWLINE> if pa != pb : <NEWLINE> <INDENT> inconvenience -= parent [ pa ] * parent [ pb ] <NEWLINE> <DEDENT> unite ( parent , a , b ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( result ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> next = 1 <NEWLINE> a = True <NEWLINE> while ( a ) : <NEWLINE> <INDENT> a = False <NEWLINE> b = False <NEWLINE> for i in range ( next , len ( array ) ) : <NEWLINE> <INDENT> if array [ i ] < array [ i - 1 ] : <NEWLINE> <INDENT> ans += array [ i - 1 ] - array [ i ] <NEWLINE> array [ i ] = array [ i - 1 ] <NEWLINE> a = True <NEWLINE> if b == False : <NEWLINE> <INDENT> b = True <NEWLINE> next = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> AList = input ( ) . split ( ) <NEWLINE> <NL> result = 1 <NEWLINE> <NL> if <STRING> in AList : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for element in AList : <NEWLINE> <INDENT> result = result * int ( element ) <NEWLINE> <NL> if result > 1e+18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i < K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> lan = [ <STRING> . join ( sorted ( input ( ) ) ) for n in range ( N ) ] <NEWLINE> <COMMENT> <NL> lans = collections . Counter ( lan ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for si in set ( lan ) : <NEWLINE> <INDENT> n = lans [ si ] <NEWLINE> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < b : print ( math . floor ( ( a * n ) / b ) - a * math . floor ( n / b ) ) <NEWLINE> else : print ( math . floor ( ( a * ( b - 1 ) ) / b ) - a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b - a <= k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( a , a + k ) : <NEWLINE> <INDENT> if i not in ans : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if j not in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> res = [ 0 for i in range ( 2019 ) ] <NEWLINE> res [ 0 ] += 1 <NEWLINE> <NL> resten = 1 <NEWLINE> ressum = int ( s [ - 1 ] ) <NEWLINE> res [ ressum ] += 1 <NEWLINE> <NL> for i in range ( 2 , len ( s ) + 1 ) : <NEWLINE> <INDENT> resten = ( resten * 10 ) % 2019 <NEWLINE> ressum = ( int ( s [ - i ] ) * resten + ressum ) % 2019 <NEWLINE> res [ ressum ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += res [ i ] * ( res [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> S_i = input ( ) <NEWLINE> S . append ( S_i ) <NEWLINE> <DEDENT> A = set ( S ) <NEWLINE> print ( len ( A ) ) <NEWLINE>
import collections <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R = [ 0 ] <NEWLINE> sums = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> sums += i <NEWLINE> sums = sums % M <NEWLINE> R . append ( sums ) <NEWLINE> <DEDENT> c = collections . Counter ( R ) <NEWLINE> A = list ( c . values ( ) ) <NEWLINE> A = [ i * ( i - 1 ) // 2 for i in A ] <NEWLINE> print ( sum ( A ) ) <NEWLINE>
from collections import deque <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> queue . append ( { <STRING> : name , <STRING> : int ( time ) } ) <NEWLINE> <DEDENT> t = 0 <NEWLINE> while len ( queue ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> head = queue . popleft ( ) <NEWLINE> if head [ <STRING> ] <= q : <NEWLINE> <INDENT> t += head [ <STRING> ] <NEWLINE> name = head [ <STRING> ] <NEWLINE> print ( <STRING> . format ( name , t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> queue . append ( { <STRING> : head [ <STRING> ] , <STRING> : head [ <STRING> ] - q } ) <NEWLINE> t += q <NEWLINE> <NL> <DEDENT> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> sq = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> ans = False <NEWLINE> c = H * W <NEWLINE> pos = [ [ 0 , 0 , 0 ] ] <NEWLINE> <NL> while pos != [ ] : <NEWLINE> <INDENT> y , x , depth = pos . pop ( 0 ) <NEWLINE> <NL> if x == W - 1 and y == H - 1 : <NEWLINE> <INDENT> ans = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> if 0 <= x + 1 <= W - 1 : <NEWLINE> <INDENT> if sq [ y ] [ x + 1 ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y , x + 1 , depth + 1 ] ) <NEWLINE> sq [ y ] [ x + 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 <= x - 1 <= W - 1 : <NEWLINE> <INDENT> if sq [ y ] [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y , x - 1 , depth + 1 ] ) <NEWLINE> sq [ y ] [ x - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 <= y + 1 <= H - 1 : <NEWLINE> <INDENT> if sq [ y + 1 ] [ x ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y + 1 , x , depth + 1 ] ) <NEWLINE> sq [ y + 1 ] [ x ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 <= y - 1 <= H - 1 : <NEWLINE> <INDENT> if sq [ y - 1 ] [ x ] == <STRING> : <NEWLINE> <INDENT> pos . append ( [ y - 1 , x , depth + 1 ] ) <NEWLINE> sq [ y - 1 ] [ x ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( H ) : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> if sq [ j ] [ k ] == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == True : <NEWLINE> <INDENT> print ( c - depth - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> di = { } <NEWLINE> for i in ar : <NEWLINE> <INDENT> di [ i ] = di . get ( i , 0 ) + 1 <NEWLINE> <DEDENT> sm = sum ( ar ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( b not in di ) : <NEWLINE> <INDENT> print ( sm ) <NEWLINE> <DEDENT> elif ( b in di ) : <NEWLINE> <INDENT> x = di [ b ] <NEWLINE> del di [ b ] <NEWLINE> if ( c in di ) : <NEWLINE> <INDENT> di [ c ] += x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> di [ c ] = x <NEWLINE> <DEDENT> s = 0 <NEWLINE> s = sm - ( b * x ) + ( x * c ) <NEWLINE> sm = s <NEWLINE> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in i : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for n in range ( num ) : <NEWLINE> <INDENT> ans = ans * i [ n ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main2 ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> numbers = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> dp = [ 0 ] * n <NEWLINE> for number in numbers : <NEWLINE> <INDENT> for n in number : <NEWLINE> <INDENT> dp [ n - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for ans in dp : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> numbers = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> numbers = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> dp = { } <NEWLINE> for number in numbers : <NEWLINE> <INDENT> for n in number : <NEWLINE> <INDENT> if n not in dp : <NEWLINE> <INDENT> dp [ n ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp ) <NEWLINE> for i in range ( 1 , len ( dp ) + 1 ) : <NEWLINE> <INDENT> print ( dp [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> b , c = [ 0 ] * q , [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( 10 ** 5 + 5 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> tot = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> if cnt [ b [ i ] ] > 0 : <NEWLINE> <INDENT> tot += cnt [ b [ i ] ] * ( c [ i ] - b [ i ] ) <NEWLINE> cnt [ c [ i ] ] += cnt [ b [ i ] ] <NEWLINE> cnt [ b [ i ] ] = 0 <NEWLINE> <DEDENT> print ( tot ) <NEWLINE> <DEDENT>
class D_Linked_List : <NEWLINE> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , next = None , prev = None ) : <NEWLINE> <INDENT> self . next = next <NEWLINE> self . prev = prev <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nil = D_Linked_List . Node ( None ) <NEWLINE> self . nil . next = self . nil <NEWLINE> self . nil . prev = self . nil <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> node_x = D_Linked_List . Node ( key , self . nil . next , self . nil ) <NEWLINE> self . nil . next . prev = node_x <NEWLINE> self . nil . next = node_x <NEWLINE> <NL> <DEDENT> def _listSearch ( self , key ) : <NEWLINE> <INDENT> cur_node = self . nil . next <NEWLINE> while ( cur_node != self . nil ) and ( cur_node . key != key ) : <NEWLINE> <INDENT> cur_node = cur_node . next <NEWLINE> <DEDENT> return cur_node <NEWLINE> <NL> <DEDENT> def _deleteNode ( self , node ) : <NEWLINE> <INDENT> if node == self . nil : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> node . prev . next = node . next <NEWLINE> node . next . prev = node . prev <NEWLINE> <NL> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . _deleteNode ( self . nil . next ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . _deleteNode ( self . nil . prev ) <NEWLINE> <NL> <DEDENT> def deleteKey ( self , key ) : <NEWLINE> <INDENT> node = self . _listSearch ( key ) <NEWLINE> self . _deleteNode ( node ) <NEWLINE> <NL> <DEDENT> def show_keys ( self ) : <NEWLINE> <INDENT> cur_node = self . nil . next <NEWLINE> keys_str = <STRING> <NEWLINE> while cur_node != self . nil : <NEWLINE> <INDENT> keys_str += <STRING> . format ( cur_node . key ) <NEWLINE> cur_node = cur_node . next <NEWLINE> <DEDENT> print ( keys_str . rstrip ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> d_ll = D_Linked_List ( ) <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> x = int ( i . split ( ) [ 1 ] ) <NEWLINE> d_ll . insert ( x ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> d_ll . deleteFirst ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> d_ll . deleteLast ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> x = int ( i . split ( ) [ 1 ] ) <NEWLINE> d_ll . deleteKey ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> d_ll . show_keys ( ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 ( i8 , i8 , i8 [ : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def solve ( N , W , weights , values ) : <NEWLINE> <INDENT> dp = np . full ( ( N + 1 , W + 1 ) , 0 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) <NEWLINE> if j + weights [ i ] <= W : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + weights [ i ] ] = max ( <NEWLINE> <INDENT> dp [ i + 1 ] [ j + weights [ i ] ] , dp [ i ] [ j ] + values [ i ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] . max ( ) <NEWLINE> <NL> <NL> <DEDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> weights = np . zeros ( N , dtype = np . int64 ) <NEWLINE> values = np . zeros ( N , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> weights [ i ] = w <NEWLINE> values [ i ] = v <NEWLINE> <DEDENT> print ( solve ( N , W , weights , values ) ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 ; <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> visited = [ False for _ in range ( N ) ] <NEWLINE> color = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> def dfs ( now , c ) : <NEWLINE> <NL> <INDENT> color [ now ] = c <NEWLINE> <NL> for adj in graph [ now ] : <NEWLINE> <INDENT> if color [ adj ] == c : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if color [ adj ] == 0 and not dfs ( adj , - c ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> ans = dfs ( 0 , 1 ) <NEWLINE> white = color . count ( - 1 ) <NEWLINE> black = N - white <NEWLINE> if ans : <NEWLINE> <INDENT> print ( black * white - M ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * ( N - 1 ) // 2 - M ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> res = 10 ** 8 <NEWLINE> <NL> C = [ 0 ] * N <NEWLINE> A = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] = L [ 0 ] <NEWLINE> A [ i ] = L [ 1 : ] <NEWLINE> <NL> <DEDENT> def check_x ( a ) : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] < X : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def calc_money_under ( n ) : <NEWLINE> <INDENT> global res <NEWLINE> <NL> understand = [ 0 ] * M <NEWLINE> money = 0 <NEWLINE> for s in range ( N ) : <NEWLINE> <INDENT> if ( n >> s ) & 1 : <NEWLINE> <INDENT> money += C [ s ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> understand [ j ] += A [ s ] [ j ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if check_x ( understand ) : <NEWLINE> <INDENT> res = min ( money , res ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> for n in range ( 2 ** N ) : <NEWLINE> <INDENT> calc_money_under ( n ) <NEWLINE> <NL> <DEDENT> if res == 10 ** 8 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
import math <NEWLINE> s = int ( input ( ) ) <NEWLINE> if s < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bar = ( s // 3 ) - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( bar + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = s - 3 * ( i + 1 ) <NEWLINE> count = math . factorial ( val + i ) // ( math . factorial ( val ) * math . factorial ( i ) ) <NEWLINE> ans += count % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ deque ( [ ] ) for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> a = [ 0 ] * - ~ n <NEWLINE> b = [ True ] * - ~ n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ p ] += x <NEWLINE> <NL> <DEDENT> d = deque ( [ 1 ] ) <NEWLINE> b [ 1 ] = False <NEWLINE> <NL> while len ( d ) : <NEWLINE> <INDENT> p = d . popleft ( ) <NEWLINE> for i in graph [ p ] : <NEWLINE> <INDENT> if b [ i ] : <NEWLINE> <INDENT> a [ i ] += a [ p ] <NEWLINE> b [ i ] = False <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a [ 1 : ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> from math import gcd <NEWLINE> <COMMENT> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // gcd ( x , y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def solve ( n , m , s , t ) : <NEWLINE> <INDENT> L = lcm ( n , m ) <NEWLINE> G = gcd ( n , m ) <NEWLINE> s_interval = L // n <NEWLINE> t_interval = L // m <NEWLINE> for i in range ( G ) : <NEWLINE> <INDENT> if s [ i * n // G ] != t [ i * m // G ] : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return L <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> print ( solve ( N , M , s , t ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s_list = list ( s ) <NEWLINE> t_list = list ( t ) <NEWLINE> compare = [ ] <NEWLINE> score = [ ] <NEWLINE> <NL> if s == t : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> compare . append ( s [ i : i + len ( t ) ] ) <NEWLINE> <NL> <DEDENT> for v in compare : <NEWLINE> <INDENT> count = 0 <NEWLINE> for v1 , v2 in zip ( list ( v ) , t_list ) : <NEWLINE> <COMMENT> <NL> <INDENT> if v1 == v2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> score . append ( count ) <NEWLINE> <DEDENT> print ( len ( t ) - max ( score ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def factorize ( n ) : <NEWLINE> <INDENT> fct = [ ] <COMMENT> <NEWLINE> b , e = 2 , 0 <COMMENT> <NEWLINE> while b * b <= n : <NEWLINE> <INDENT> while n % b == 0 : <NEWLINE> <INDENT> n = n // b <NEWLINE> e = e + 1 <NEWLINE> <DEDENT> if e > 0 : <NEWLINE> <INDENT> fct . append ( ( b , e ) ) <NEWLINE> <DEDENT> b , e = b + 1 , 0 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> fct . append ( ( n , 1 ) ) <NEWLINE> <DEDENT> return fct <NEWLINE> <NL> <DEDENT> f = factorize ( n ) <NEWLINE> ans = 0 <NEWLINE> for i , j in f : <NEWLINE> <INDENT> ans += int ( ( - 1 + pow ( 1 + 8 * j , 0.5 ) ) / 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> b = 1 <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
h = [ ] <NEWLINE> w = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( not ( a == 0 or b == 0 ) ) : <NEWLINE> <INDENT> h . append ( a ) <NEWLINE> w . append ( b ) <NEWLINE> <DEDENT> elif ( a == b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> n = 0 <NEWLINE> for e in h : <NEWLINE> <INDENT> c = 0 <NEWLINE> for f in range ( e ) : <NEWLINE> <INDENT> if ( w [ n ] % 2 == 0 ) : <NEWLINE> <INDENT> if ( c == 0 ) : <NEWLINE> <INDENT> print ( <STRING> * ( w [ n ] // 2 ) ) <NEWLINE> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( w [ n ] // 2 ) ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( c == 0 ) : <NEWLINE> <INDENT> print ( <STRING> * ( w [ n ] // 2 ) + <STRING> ) <NEWLINE> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( w [ n ] // 2 ) + <STRING> ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> n += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> if ( S [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> if ( S [ i + 2 ] == <STRING> ) : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
class Node : <NEWLINE> <INDENT> def __init__ ( self , val = None , prev = None , next = None ) : <NEWLINE> <INDENT> self . val = val <NEWLINE> self . prev = prev <NEWLINE> self . next = next <NEWLINE> <NL> <DEDENT> <DEDENT> class DoublyLinkedList ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . end = Node ( val = <STRING> , prev = None , next = None ) <NEWLINE> self . cur = self . end <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> new_node = Node ( val = x , prev = self . cur . prev , next = self . cur ) <NEWLINE> if self . cur . prev != None : self . cur . prev . next = new_node <NEWLINE> self . cur . prev = new_node <NEWLINE> self . cur = new_node <NEWLINE> <NL> <DEDENT> def move ( self , d ) : <NEWLINE> <INDENT> if d > 0 : <NEWLINE> <INDENT> for i in range ( d ) : <NEWLINE> <INDENT> if self . cur . next == None : break <NEWLINE> self . cur = self . cur . next <NEWLINE> <DEDENT> <DEDENT> elif d < 0 : <NEWLINE> <INDENT> for i in range ( abs ( d ) ) : <NEWLINE> <INDENT> if self . cur . prev == None : break <NEWLINE> self . cur = self . cur . prev <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def erase ( self ) : <NEWLINE> <INDENT> if self . cur == self . end : return <NEWLINE> if self . cur . prev != None : self . cur . prev . next = self . cur . next <NEWLINE> self . cur . next . prev = self . cur . prev <NEWLINE> self . cur = self . cur . next <NEWLINE> <NL> <DEDENT> def print_elements ( self ) : <NEWLINE> <INDENT> node_list = [ ] <NEWLINE> crnode = self . end <NEWLINE> while True : <NEWLINE> <INDENT> if crnode . prev == None : break <NEWLINE> node_list . append ( crnode . prev . val ) <NEWLINE> crnode = crnode . prev <NEWLINE> <DEDENT> for i in range ( len ( node_list ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( node_list [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dll = DoublyLinkedList ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> op = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if op [ 0 ] == 0 : <NEWLINE> <INDENT> dll . insert ( op [ 1 ] ) <NEWLINE> <DEDENT> elif op [ 0 ] == 1 : <NEWLINE> <INDENT> dll . move ( op [ 1 ] ) <NEWLINE> <DEDENT> elif op [ 0 ] == 2 : <NEWLINE> <INDENT> dll . erase ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> dll . print_elements ( ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> b = 1 <NEWLINE> A = sorted ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if b > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b *= a <NEWLINE> <DEDENT> print ( - 1 if b > 10 ** 18 else b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> num_r = s . count ( <STRING> ) <NEWLINE> num_g = s . count ( <STRING> ) <NEWLINE> num_b = s . count ( <STRING> ) <NEWLINE> <NL> ans = num_r * num_g * num_b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if ( k < n ) and ( s [ i ] != s [ j ] ) and ( s [ j ] != s [ k ] ) and ( s [ k ] != s [ i ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import unittest <NEWLINE> from io import StringIO <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> <NL> def gcd ( a , b , c ) : <NEWLINE> <INDENT> n = 1 <NEWLINE> if a == b : <NEWLINE> <INDENT> if b != c : <NEWLINE> <INDENT> n = 3 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b != c : <NEWLINE> <INDENT> n = 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 3 <NEWLINE> <DEDENT> <DEDENT> return math . gcd ( math . gcd ( a , b ) , c ) * n <NEWLINE> <NL> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> T = [ i for i in range ( 1 , K + 1 ) ] <NEWLINE> Tr = itertools . combinations_with_replacement ( T , 3 ) <NEWLINE> sumT = 0 <NEWLINE> for a , b , c in Tr : <NEWLINE> <INDENT> sumT += gcd ( a , b , c ) <NEWLINE> <DEDENT> print ( sumT ) <NEWLINE> <NL> <NL> <DEDENT> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_add ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> sum_of_digits = 0 <NEWLINE> <NL> cnts = [ 0 ] * 2019 <NEWLINE> <NL> cnts [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> sum_of_digits += int ( c ) * d <NEWLINE> sum_of_digits %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> cnts [ sum_of_digits ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for cnt in cnts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , dice : list ) : <NEWLINE> <INDENT> self . top = dice [ 0 ] <NEWLINE> self . bottom = dice [ 5 ] <NEWLINE> self . front = dice [ 1 ] <NEWLINE> self . behind = dice [ 4 ] <NEWLINE> self . right = dice [ 2 ] <NEWLINE> self . left = dice [ 3 ] <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> if not isinstance ( other , Dice ) : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <DEDENT> return self . top == other . top and self . bottom == other . bottom and self . front == other . front and self . behind == other . behind and self . right == other . right <NEWLINE> <NL> <DEDENT> def roll ( self , direction : str ) : <NEWLINE> <INDENT> buffer = self . top <NEWLINE> if direction == <STRING> : <NEWLINE> <INDENT> self . top = self . left <NEWLINE> self . left = self . bottom <NEWLINE> self . bottom = self . right <NEWLINE> self . right = buffer <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . top = self . front <NEWLINE> self . front = self . bottom <NEWLINE> self . bottom = self . behind <NEWLINE> self . behind = buffer <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . top = self . behind <NEWLINE> self . behind = self . bottom <NEWLINE> self . bottom = self . front <NEWLINE> self . front = buffer <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . top = self . right <NEWLINE> self . right = self . bottom <NEWLINE> self . bottom = self . left <NEWLINE> self . left = buffer <NEWLINE> <NL> <DEDENT> <DEDENT> def turn ( self ) : <NEWLINE> <INDENT> buffer = self . front <NEWLINE> self . front = self . right <NEWLINE> self . right = self . behind <NEWLINE> self . behind = self . left <NEWLINE> self . left = buffer <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> dice1 , dice2 = [ Dice ( list ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( 2 ) ] <NEWLINE> for _ in range ( 2 ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> if dice1 == dice2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> dice2 . turn ( ) <NEWLINE> <DEDENT> dice2 . roll ( <STRING> ) <NEWLINE> <DEDENT> dice2 . roll ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> det = a * e - b * d <NEWLINE> x = ( c * e - b * f ) / det <NEWLINE> y = ( a * f - c * d ) / det <NEWLINE> if x == 0 : x = 0 <NEWLINE> if y == 0 : y = 0 <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> sentense = input ( ) <NEWLINE> count_1 = sentense . count ( <STRING> ) * sentense . count ( <STRING> ) * sentense . count ( <STRING> ) <NEWLINE> count_1_and_not_2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = ( j - i ) + j <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if sentense [ i ] != sentense [ j ] and sentense [ j ] != sentense [ k ] and sentense [ k ] != sentense [ i ] : <NEWLINE> <INDENT> count_1_and_not_2 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count_1 - count_1_and_not_2 ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> left = k - ( abs ( x ) // d ) <NEWLINE> <NL> if abs ( x ) // d > k : <NEWLINE> <INDENT> print ( abs ( x ) - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_abs = abs ( x ) % d <NEWLINE> if left % 2 == 0 : <NEWLINE> <INDENT> print ( ans_abs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - ans_abs ) <NEWLINE> <DEDENT> <DEDENT>
cnt = 0 <NEWLINE> def merge ( L , R ) : <NEWLINE> <INDENT> global cnt <NEWLINE> n = len ( L ) + len ( R ) <NEWLINE> lenL = len ( L ) <NEWLINE> A = [ ] <NEWLINE> i = j = 0 <NEWLINE> L . append ( 10 ** 9 + 1 ) <NEWLINE> R . append ( 10 ** 9 + 1 ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A . append ( L [ i ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( R [ j ] ) <NEWLINE> j += 1 <NEWLINE> cnt += lenL - i <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def mergeSort ( A ) : <NEWLINE> <INDENT> if len ( A ) == 1 : return A <NEWLINE> m = len ( A ) // 2 <NEWLINE> return merge ( mergeSort ( A [ : m ] ) , mergeSort ( A [ m : ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> mergeSort ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( input ( ) ) <NEWLINE> x = a . count ( <STRING> ) <NEWLINE> b = a [ : x ] <NEWLINE> print ( b . count ( <STRING> ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == c == - 1 : break <NEWLINE> if a == - 1 or b == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> if 80 <= a + b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif 65 <= a + b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif 50 <= a + b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif 30 <= a + b : <NEWLINE> <INDENT> if 50 <= c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> elif a + b < 30 : print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
<NL> class UnionFind : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ j ] == s [ i + j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> a . append ( count ) <NEWLINE> <DEDENT> print ( len ( t ) - max ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , len ( arr ) + ( n % 2 ) , 2 ) : <NEWLINE> <INDENT> if arr [ i ] % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N != 100 : <NEWLINE> <INDENT> if D == 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> elif D == 1 : <NEWLINE> <INDENT> x = [ 100 * i for i in range ( 1 , 101 ) ] <NEWLINE> print ( x [ N - 1 ] ) <NEWLINE> <DEDENT> elif D == 2 : <NEWLINE> <INDENT> x = [ 10000 * i for i in range ( 1 , 101 ) ] <NEWLINE> print ( x [ N - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if D == 0 : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> elif D == 1 : <NEWLINE> <INDENT> x = [ 100 * i for i in range ( 1 , 101 ) ] <NEWLINE> print ( x [ N - 1 ] + 100 ) <NEWLINE> <DEDENT> elif D == 2 : <NEWLINE> <INDENT> x = [ 10000 * i for i in range ( 1 , 101 ) ] <NEWLINE> print ( x [ N - 1 ] + 10000 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> from queue import deque <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> <NL> def geta ( fn = lambda s : s . decode ( ) ) : <NEWLINE> <INDENT> return map ( fn , readline ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def gete ( fn = lambda s : s . decode ( ) ) : <NEWLINE> <INDENT> return fn ( readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def egcd ( a : int , b : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if a == 0 : <NEWLINE> <INDENT> return b , 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g , x , y = egcd ( b % a , a ) <NEWLINE> return g , y - ( b // a ) * x , x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def modinv ( a : int , mod : int = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> g , x , y = egcd ( a , mod ) <NEWLINE> if g > 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> . format ( a , mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , S = geta ( int ) <NEWLINE> A = list ( geta ( int ) ) <NEWLINE> A . sort ( ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> inv2 = modinv ( 2 , mod ) <NEWLINE> <NL> dp = np . zeros ( ( N + 1 , S + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> _t = pow ( 2 , N , mod ) <NEWLINE> dp [ : , 0 ] = _t <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i , : ] = dp [ i - 1 , : ] <NEWLINE> if A [ i - 1 ] <= S : <NEWLINE> <INDENT> tmp = np . roll ( dp [ i - 1 , : ] , A [ i - 1 ] ) <NEWLINE> tmp [ : A [ i - 1 ] ] = 0 <NEWLINE> dp [ i , : ] += tmp * inv2 <NEWLINE> dp [ i , : ] %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] [ S ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> ans = 0 <NEWLINE> amari = [ 0 ] * 2019 <NEWLINE> amari [ 0 ] = 1 <NEWLINE> follow = 0 <NEWLINE> POW = 1 <NEWLINE> <NL> for i in reversed ( S ) : <NEWLINE> <INDENT> follow += int ( i ) * POW <NEWLINE> follow %= 2019 <NEWLINE> amari [ follow ] += 1 <NEWLINE> POW *= 10 <NEWLINE> POW %= 2019 <NEWLINE> <NL> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in amari ) ) <NEWLINE>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> b = [ [ 0 for i in range ( l ) ] for j in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> <DEDENT> c = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l - 1 ) : <NEWLINE> <INDENT> print ( c [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( c [ i ] [ l - 1 ] ) <NEWLINE> <DEDENT>
def gcd ( b , s ) : <NEWLINE> <INDENT> mod = b % s <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> return gcd ( s , mod ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return s <NEWLINE> <NL> <DEDENT> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> b = max ( x , y ) <NEWLINE> s = min ( x , y ) <NEWLINE> a = gcd ( b , s ) <NEWLINE> print ( a ) <NEWLINE>
<COMMENT> <NL> <NL> from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> s_len = len ( S ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> nums_2019 = [ 0 ] * 2019 <NEWLINE> nums_2019 [ 0 ] = 1 <NEWLINE> tmp_num = 0 <NEWLINE> for i in range ( s_len - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp_num += int ( S [ i ] ) * pow ( 10 , s_len - i - 1 , 2019 ) <NEWLINE> nums_2019 [ tmp_num % 2019 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for m_c in nums_2019 : <NEWLINE> <INDENT> if m_c >= 2 : <NEWLINE> <INDENT> ans += m_c * ( m_c - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> count = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> total = 1 <NEWLINE> for j in a : <NEWLINE> <INDENT> total = total * j <NEWLINE> <COMMENT> <NL> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> to = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , sysread ( ) . split ( ) ) <NEWLINE> to [ u ] . append ( v ) <NEWLINE> to [ v ] . append ( u ) <NEWLINE> <DEDENT> seen = [ False ] * ( N + 1 ) <NEWLINE> dp = [ float ( <STRING> ) ] * ( N + 2 ) <NEWLINE> dp [ 0 ] = - float ( <STRING> ) <NEWLINE> ddp2 = [ 0 ] <NEWLINE> paths = [ ] <NEWLINE> actions = [ ] <COMMENT> <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> def dfs ( node , parent = None ) : <NEWLINE> <NL> <INDENT> a = A [ node ] <NEWLINE> seen [ node ] = True <NEWLINE> if parent == None : <NEWLINE> <INDENT> actions . append ( ( 1 , dp [ 1 ] , a , 1 ) ) <NEWLINE> dp [ 1 ] = a <NEWLINE> ddp2 [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = bin_search ( dp , a ) <NEWLINE> if dp [ idx ] == float ( <STRING> ) : <NEWLINE> <INDENT> actions . append ( ( idx , dp [ idx ] , a , 1 ) ) <NEWLINE> ddp2 [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> actions . append ( ( idx , dp [ idx ] , a , 0 ) ) <NEWLINE> <DEDENT> dp [ idx ] = a <NEWLINE> <DEDENT> ans [ node ] = ddp2 [ 0 ] <NEWLINE> for next in to [ node ] : <NEWLINE> <INDENT> if not seen [ next ] : <NEWLINE> <INDENT> dfs ( next , node ) <NEWLINE> <NL> <DEDENT> <DEDENT> idx , pre , pro , change = actions . pop ( ) <NEWLINE> dp [ idx ] = pre <NEWLINE> ddp2 [ 0 ] -= change <NEWLINE> <NL> <DEDENT> dfs ( 1 ) <NEWLINE> for s in ans [ 1 : ] : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def bin_search ( A , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> low = 0 <NEWLINE> high = len ( A ) - 1 <NEWLINE> c = ( low + high ) // 2 <NEWLINE> if A [ - 1 ] < x : return float ( <STRING> ) <NEWLINE> while high - low > 1 : <NEWLINE> <INDENT> if A [ c ] < x : <NEWLINE> <INDENT> low = c <NEWLINE> c = ( low + high ) // 2 <NEWLINE> <NL> <DEDENT> elif A [ c ] > x : <NEWLINE> <INDENT> high = c <NEWLINE> c = ( high + low ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> <DEDENT> return high <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( round ( r ** 2 * math . pi , 6 ) , round ( r * 2 * math . pi , 6 ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> for x in a : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > int ( 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( A + B ) == K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif ( A + B ) > K : <NEWLINE> <INDENT> if A > K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> <DEDENT> elif ( A + B ) < K : <NEWLINE> <INDENT> print ( A - ( K - ( A + B ) ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LRD = [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( M ) ] <NEWLINE> Graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for l , r , d in LRD : <NEWLINE> <INDENT> Graph [ r - 1 ] . append ( ( l - 1 , d ) ) <NEWLINE> Graph [ l - 1 ] . append ( ( r - 1 , - d ) ) <NEWLINE> <NL> <DEDENT> seen = set ( ) <NEWLINE> Dfr = [ 0 ] * N <COMMENT> <NEWLINE> for root in range ( N ) : <NEWLINE> <INDENT> if root in seen : continue <NEWLINE> seen . add ( root ) <NEWLINE> V = [ root ] <NEWLINE> while len ( V ) != 0 : <COMMENT> <NEWLINE> <INDENT> v = V . pop ( 0 ) <NEWLINE> for nv , d in Graph [ v ] : <NEWLINE> <INDENT> if nv in seen and Dfr [ nv ] != Dfr [ v ] + d : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if nv in seen : continue <NEWLINE> else : <NEWLINE> <INDENT> seen . add ( nv ) <NEWLINE> Dfr [ nv ] = Dfr [ v ] + d <NEWLINE> V . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L_1 = set ( [ i for i in range ( A , min ( A + K , B + 1 ) ) ] ) <NEWLINE> L_2 = set ( [ i for i in range ( max ( A , B - K + 1 ) , B + 1 ) ] ) <NEWLINE> L = sorted ( L_1 | L_2 ) <NEWLINE> for l in L : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( t , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for t , ( c , k ) in enumerate ( sorted ( ( c , k ) for k , c in enumerate ( a ) ) [ : : - 1 ] ) : <NEWLINE> <INDENT> for i in range ( t + 1 ) : <NEWLINE> <INDENT> j = t - i <NEWLINE> if dp [ i + 1 ] [ j ] <= ( s : = dp [ i ] [ j ] + c * abs ( i - k ) ) : dp [ i + 1 ] [ j ] = s <NEWLINE> if dp [ i ] [ j + 1 ] <= ( s : = dp [ i ] [ j ] + c * abs ( n - 1 - k - j ) ) : dp [ i ] [ j + 1 ] = s <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp [ i ] [ ~ i ] for i in range ( n + 1 ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = n // a <NEWLINE> ans += num * ( num + 1 ) // 2 * a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> s_uniq = list ( set ( s ) ) <NEWLINE> print ( len ( s_uniq ) ) <NEWLINE>
from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> g = gcd ( g , a ) <NEWLINE> <DEDENT> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> MAXN = 10 ** 6 + 10 <NEWLINE> sieve = [ i for i in range ( MAXN + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while p * p <= MAXN : <NEWLINE> <INDENT> if sieve [ p ] == p : <NEWLINE> <INDENT> for q in range ( 2 * p , MAXN + 1 , p ) : <NEWLINE> <INDENT> if sieve [ q ] == q : <NEWLINE> <INDENT> sieve [ q ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> st = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> tmp = set ( ) <NEWLINE> while a > 1 : <NEWLINE> <INDENT> tmp . add ( sieve [ a ] ) <NEWLINE> a //= sieve [ a ] <NEWLINE> <DEDENT> for p in tmp : <NEWLINE> <INDENT> if p in st : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> st . add ( p ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
input ( ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> a . append ( i - 1 ) <NEWLINE> <DEDENT> if n // i - 1 != 0 : <NEWLINE> <INDENT> a . append ( ( n // i ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] != 1 and ( n // a [ i ] == n % a [ i ] ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def lucas ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return lucas ( n - 1 ) + lucas ( n - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> print ( lucas ( N ) ) <NEWLINE>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = input ( ) <NEWLINE> list_A = A . split ( ) <NEWLINE> waza = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> waza = waza + int ( list_A [ i ] ) <NEWLINE> <DEDENT> if waza >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , K , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def sgn ( x ) : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x < 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> if X > 0 : <NEWLINE> <INDENT> x_greedy = X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_greedy = X + K * D <NEWLINE> <NL> <DEDENT> if sgn ( X ) == sgn ( x_greedy ) : <NEWLINE> <INDENT> return print ( abs ( x_greedy ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x_r = X % D <NEWLINE> x_l = x_r - D <NEWLINE> <NL> r_parity = ( abs ( X - x_r ) // D ) % 2 <NEWLINE> if K % 2 == r_parity : <NEWLINE> <INDENT> return print ( abs ( x_r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return print ( abs ( x_l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if X == a ** 5 - b ** 5 : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( M * 1900 + 100 * ( N - M ) ) * ( 2 ** M ) ) <NEWLINE>
import numpy as np <NEWLINE> K = int ( input ( ) ) <NEWLINE> l = [ 0 ] * ( K + 1 ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_ab = np . gcd ( i , j ) <NEWLINE> l [ gcd_ab ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd_c = np . gcd ( i , j ) <NEWLINE> res += l [ j ] * gcd_c <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <DEDENT> num = 0 <NEWLINE> <NL> for i in range ( 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> if l [ i ] != 0 : <NEWLINE> <INDENT> for j in range ( 2 * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> if l [ j ] : <NEWLINE> <INDENT> l [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
<COMMENT> <NL> <NL> from itertools import repeat <NEWLINE> from itertools import combinations <NEWLINE> <NL> def rec ( s , i , total , m ) : <NEWLINE> <INDENT> if total == m : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> if len ( s ) == i or total > m : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> return rec ( s , i + 1 , total , m ) + rec ( s , i + 1 , total + s [ i ] , m ) <NEWLINE> <NL> <NL> <DEDENT> def makeCache ( s ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> comb = list ( combinations ( s , i ) ) <NEWLINE> for c in comb : <NEWLINE> <INDENT> cache [ sum ( c ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return cache <NEWLINE> <NL> <DEDENT> def loop ( s , m ) : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> comb = list ( combinations ( s , i ) ) <NEWLINE> for c in comb : <NEWLINE> <INDENT> if sum ( c ) == m : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = makeCache ( a ) <NEWLINE> for i in m : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( <STRING> ) if i in s else print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> ans = 0 <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> num = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if num == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . gcd ( num , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> a = np . array ( a ) <NEWLINE> ans = np . zeros ( n ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( int ( i ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) . strip ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for key in range ( 1000 ) : <NEWLINE> <INDENT> key = <STRING> . format ( str ( key ) ) <COMMENT> <NEWLINE> i0 = s . find ( key [ 0 ] ) <NEWLINE> if 0 <= i0 < N - 2 : <NEWLINE> <INDENT> i1 = s . find ( key [ 1 ] , i0 + 1 ) <NEWLINE> if 0 < i1 < N - 1 : <NEWLINE> <INDENT> i2 = s . find ( key [ 2 ] , i1 + 1 ) <NEWLINE> if i2 != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def is_good ( mid , key ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> res += ( a + mid - 1 ) // mid <NEWLINE> <DEDENT> return res - N <= key <NEWLINE> <NL> <NL> <DEDENT> def binary_search ( bad , good , key ) : <NEWLINE> <INDENT> while good - bad > 1 : <NEWLINE> <INDENT> mid = ( bad + good ) // 2 <NEWLINE> if is_good ( mid , key ) : <NEWLINE> <INDENT> good = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad = mid <NEWLINE> <DEDENT> <DEDENT> return good <NEWLINE> <NL> <NL> <DEDENT> N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( binary_search ( 0 , 1_000_000_000 , K ) ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> <NL> <NL> def dfs ( num ) : <NEWLINE> <INDENT> if len ( num ) == n : <NEWLINE> <INDENT> A . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = num [ - 1 ] <NEWLINE> for i in range ( now , m + 1 ) : <NEWLINE> <INDENT> dfs ( num + [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> dfs ( [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for now in A : <NEWLINE> <INDENT> point = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if now [ b - 1 ] - now [ a - 1 ] == c : <NEWLINE> <INDENT> point += d <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , point ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cnt += d [ i - A [ i ] ] <NEWLINE> d [ i + A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sub = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> sub . append ( 0 ) <NEWLINE> <DEDENT> for j in a : <NEWLINE> <INDENT> sub [ j - 1 ] += 1 <NEWLINE> <DEDENT> for i in sub : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> def int_mtx ( N ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> return np . array ( x ) <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> MOD = ( 10 ** 9 ) + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> sum_a = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_a [ i + 1 ] = sum_a [ i ] + A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ai = A [ i ] <NEWLINE> ans = ( ans + ai * ( sum_a [ - 1 ] - sum_a [ i + 1 ] ) ) % MOD <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans = ( ans + MOD ) % MOD <NEWLINE> print ( ans ) <NEWLINE>
def management ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> static_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result_list = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> result_list . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( 0 , len ( static_list ) ) : <NEWLINE> <INDENT> result_list [ static_list [ i ] - 1 ] = result_list [ static_list [ i ] - 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> print ( result_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> management ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> <NL> T = int ( input ( ) ) <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> L0 = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = input ( ) <NEWLINE> for i , s in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> tmp = A [ N - 1 - i ] <NEWLINE> for l0 in L0 : <NEWLINE> <INDENT> if tmp ^ l0 < tmp : <NEWLINE> <INDENT> tmp = tmp ^ l0 <NEWLINE> <DEDENT> <DEDENT> if tmp > 0 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> L0 . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs . append ( ( h , w ) ) <NEWLINE> <DEDENT> bombs_set = set ( bombs ) <NEWLINE> g = list ( zip ( * bombs ) ) <NEWLINE> g0 = collections . Counter ( g [ 0 ] ) <NEWLINE> g1 = collections . Counter ( g [ 1 ] ) <NEWLINE> g0items = list ( g0 . items ( ) ) ; g0items . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> g1items = list ( g1 . items ( ) ) ; g1items . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> x = g0items [ 0 ] [ 0 ] ; countx = g0items [ 0 ] [ 1 ] <NEWLINE> y = g1items [ 0 ] [ 0 ] ; county = g1items [ 0 ] [ 1 ] <NEWLINE> for xx , s in g0items : <NEWLINE> <INDENT> if s != countx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for yy , t in g1items : <NEWLINE> <INDENT> if t != county : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( xx , yy ) not in bombs_set : <NEWLINE> <INDENT> x , y = xx , yy <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = countx + county - ( ( x , y ) in bombs ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> m = m * i <NEWLINE> if m > 1000000000000000000 : <NEWLINE> <INDENT> m = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a = 7 <NEWLINE> count = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if a % K == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> a = ( a * 10 + 7 ) % K <NEWLINE> count += 1 <NEWLINE> <DEDENT> if count == K + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def mapline ( t = int ) : <NEWLINE> <INDENT> return map ( t , sysread ( ) . split ( ) ) <NEWLINE> <DEDENT> def mapread ( t = int ) : <NEWLINE> <INDENT> return map ( t , read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def dfs ( c , to , cols , max_counts , pre_col = 0 ) : <NEWLINE> <INDENT> colors = set ( ) <NEWLINE> colors . add ( pre_col ) <NEWLINE> num = 1 <NEWLINE> for idx , n in to [ c ] : <NEWLINE> <INDENT> if cols [ idx ] : continue <NEWLINE> for i in range ( num , max_counts + 1 ) : <NEWLINE> <INDENT> if not i in colors : <NEWLINE> <INDENT> num = i <NEWLINE> cols [ idx ] = i <NEWLINE> colors . add ( i ) <NEWLINE> dfs ( n , to , cols , max_counts , i ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N = int ( sysread ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> cols = [ 0 ] * ( N - 1 ) <NEWLINE> counts = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = mapline ( ) <NEWLINE> to [ a ] . append ( ( i , b ) ) <NEWLINE> to [ b ] . append ( ( i , a ) ) <NEWLINE> counts [ a ] += 1 <NEWLINE> counts [ b ] += 1 <NEWLINE> <NL> <DEDENT> max_counts = max ( counts ) <NEWLINE> print ( max_counts ) <NEWLINE> dfs ( 1 , to , cols , max_counts ) <NEWLINE> <NL> for c in cols : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) . rstrip ( <STRING> ) ) <NEWLINE> s = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> if B in s : <NEWLINE> <INDENT> s [ B ] += A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ B ] = A <NEWLINE> <DEDENT> <DEDENT> m = sorted ( list ( set ( s ) ) ) <NEWLINE> check = 0 <NEWLINE> used = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> used += s [ i ] <NEWLINE> if used > i : <NEWLINE> <INDENT> check += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> answer = solve ( S ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( S ) : <NEWLINE> <INDENT> patterns = { <NEWLINE> <INDENT> <STRING> : 0 , <NEWLINE> <STRING> : 1 , <NEWLINE> <STRING> : 1 , <NEWLINE> <STRING> : 2 , <NEWLINE> <STRING> : 3 , <NEWLINE> <STRING> : 2 , <NEWLINE> <STRING> : 1 , <NEWLINE> <STRING> : 1 <NEWLINE> <DEDENT> } <NEWLINE> <NL> return patterns [ S ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( r * r * math . pi ) , <STRING> . format ( 2 * r * math . pi ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> array = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> s = 0 <NEWLINE> sums = [ ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> sums . append ( array [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sums . append ( sums [ - 1 ] + array [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> sums . pop ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s += array [ i ] * sums . pop ( ) <NEWLINE> <NL> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w - 1 ) : <NEWLINE> <INDENT> if arr [ i ] [ j ] % 2 == 1 : <NEWLINE> <INDENT> arr [ i ] [ j ] -= 1 <NEWLINE> arr [ i ] [ j + 1 ] += 1 <NEWLINE> ans . append ( [ i + 1 , j + 1 , i + 1 , j + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h - 1 ) : <NEWLINE> <INDENT> if arr [ i ] [ w - 1 ] % 2 == 1 : <NEWLINE> <INDENT> arr [ i ] [ w - 1 ] -= 1 <NEWLINE> arr [ i + 1 ] [ w - 1 ] += 1 <NEWLINE> ans . append ( [ i + 1 , w , i + 2 , w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> for x in ans : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = [ - 1 for _ in range ( n ) ] <NEWLINE> stack = [ ] <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> adj [ t ] . append ( s ) <NEWLINE> <COMMENT> <NL> <DEDENT> def dfs ( u , color ) : <NEWLINE> <INDENT> if v [ u ] > 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> v [ u ] = color <NEWLINE> <COMMENT> <NL> for k in adj [ u ] : <NEWLINE> <INDENT> if v [ k ] > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( k , color ) <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> color = 1 <NEWLINE> for start in range ( n ) : <NEWLINE> <INDENT> if dfs ( start , color ) == 1 : <NEWLINE> <INDENT> color += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if v [ s ] == v [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) <NEWLINE> As = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( len ( As ) ) : <NEWLINE> <INDENT> if i >= K : <NEWLINE> <INDENT> if As [ i ] > As [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 7 + 10 ** 9 <NEWLINE> if N == K : <NEWLINE> <INDENT> r = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> r *= i <NEWLINE> r %= mod <NEWLINE> <DEDENT> return r % mod <NEWLINE> <DEDENT> if max ( A ) <= 0 and K % 2 == 1 : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> r = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> r *= A [ i ] <NEWLINE> r %= mod <NEWLINE> <DEDENT> return r % mod <NEWLINE> <DEDENT> a = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> a . append ( ( abs ( i ) , i ) ) <NEWLINE> <DEDENT> a . sort ( reverse = True ) <NEWLINE> cm = 0 <NEWLINE> lp = None <NEWLINE> lm = None <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] >= 0 : <NEWLINE> <INDENT> lp = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lm = i <NEWLINE> cm += 1 <NEWLINE> <DEDENT> <DEDENT> if cm % 2 == 0 : <NEWLINE> <INDENT> r = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> r *= a [ i ] [ 1 ] <NEWLINE> r %= mod <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT> if not lp : <NEWLINE> <INDENT> r = 1 <NEWLINE> for i in range ( K - 1 ) : <NEWLINE> <INDENT> r *= a [ i ] [ 1 ] <NEWLINE> r %= mod <NEWLINE> <DEDENT> r *= max ( A ) <NEWLINE> return r % mod <NEWLINE> <DEDENT> np = None <NEWLINE> nm = None <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] >= 0 and not np : <NEWLINE> <INDENT> np = i <NEWLINE> <DEDENT> if a [ i ] [ 1 ] < 0 and not nm : <NEWLINE> <INDENT> nm = i <NEWLINE> <DEDENT> if np and nm : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not np : <NEWLINE> <INDENT> r = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i != lp : <NEWLINE> <INDENT> r *= a [ i ] [ 1 ] <NEWLINE> r %= mod <NEWLINE> <DEDENT> <DEDENT> r *= a [ nm ] [ 1 ] <NEWLINE> return r % mod <NEWLINE> <DEDENT> if not nm : <NEWLINE> <INDENT> r = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i != lm : <NEWLINE> <INDENT> r *= a [ i ] [ 1 ] <NEWLINE> r %= mod <NEWLINE> <DEDENT> <DEDENT> r *= a [ np ] [ 1 ] <NEWLINE> return r % mod <NEWLINE> <DEDENT> r = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i not in ( lp , lm ) : <NEWLINE> <INDENT> r *= a [ i ] [ 1 ] <NEWLINE> r %= mod <NEWLINE> <DEDENT> <DEDENT> r *= max ( a [ np ] [ 1 ] * a [ lp ] [ 1 ] , a [ lm ] [ 1 ] * a [ nm ] [ 1 ] ) <NEWLINE> return r % mod <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] >= 0 : <NEWLINE> <INDENT> ori = i <NEWLINE> X . insert ( ori , 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ori = n <NEWLINE> X . insert ( ori , 0 ) <NEWLINE> <NL> <DEDENT> res = f_inf <NEWLINE> start = max ( 0 , ori - k ) <NEWLINE> end = min ( n - k + 1 , ori + 1 ) <NEWLINE> for j in range ( start , end ) : <NEWLINE> <INDENT> left = abs ( X [ j ] ) * 2 + abs ( X [ j + k ] ) <NEWLINE> right = abs ( X [ j ] ) + abs ( X [ j + k ] ) * 2 <NEWLINE> res = min ( res , min ( left , right ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y != 0 : <NEWLINE> <INDENT> tmp = x % y <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> l = [ 1 ] * N <NEWLINE> l [ 0 ] = a [ 0 ] <NEWLINE> r = [ 1 ] * N <NEWLINE> r [ N - 1 ] = a [ N - 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> l [ i ] = gcd ( l [ i - 1 ] , a [ i ] ) <NEWLINE> r [ N - 1 - i ] = gcd ( r [ N - i ] , a [ N - 1 - i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> n = r [ 1 ] <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> n = l [ N - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = gcd ( l [ i - 1 ] , r [ i + 1 ] ) <NEWLINE> <DEDENT> ans = max ( ans , n ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> self . left , self . right = None , None <NEWLINE> <NL> <DEDENT> def insert ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if data < self . data : <NEWLINE> <INDENT> if self . left is None : <NEWLINE> <INDENT> self . left = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . left . insert ( data ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if self . right is None : <NEWLINE> <INDENT> self . right = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . right . insert ( data ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pre_order ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> pre_order ( node . left ) <NEWLINE> pre_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def in_order ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> in_order ( node . left ) <NEWLINE> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> in_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def action ( command , content ) : <NEWLINE> <INDENT> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree_root . insert ( data = int ( content ) ) <NEWLINE> <NL> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> in_order ( tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> pre_order ( tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> command_list = list ( map ( lambda x : x . split ( ) , _input [ 1 : ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> flag , tree_root = False , None <NEWLINE> for each in command_list : <NEWLINE> <INDENT> command , content = each [ 0 ] , each [ - 1 ] <NEWLINE> if ( not flag ) and command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root = Node ( data = int ( content ) ) <NEWLINE> flag = True <NEWLINE> continue <NEWLINE> <DEDENT> action ( command = command , content = content ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> Row = int ( input ( ) ) <NEWLINE> List = [ input ( ) for i in range ( Row ) ] <NEWLINE> <NL> c = collections . Counter ( List ) <NEWLINE> <NL> <NL> print ( len ( list ( c . keys ( ) ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) [ : : - 1 ] <NEWLINE> l , mod = len ( s ) , 2019 <NEWLINE> x = [ 0 ] * mod <NEWLINE> x [ 0 ] = 1 <NEWLINE> a , t = 0 , 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> a = ( a + int ( s [ i ] ) * t ) % 2019 <NEWLINE> x [ a ] += 1 <NEWLINE> t = ( t * 10 ) % mod <NEWLINE> <DEDENT> ans = sum ( [ i * ( i - 1 ) // 2 for i in x ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = [ int ( input ( ) ) for x in range ( n ) ] <NEWLINE> maxv = - 2000000000 <NEWLINE> minv = r [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( maxv , r [ i ] - minv ) <NEWLINE> minv = min ( minv , r [ i ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
from collections import deque <NEWLINE> S = deque ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> if ans % 2 == 0 : <NEWLINE> <INDENT> if q [ 2 ] == <STRING> : <NEWLINE> <INDENT> S . appendleft ( q [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( q [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if q [ 2 ] == <STRING> : <NEWLINE> <INDENT> S . append ( q [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . appendleft ( q [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> S = <STRING> . join ( S ) <NEWLINE> print ( S if ans % 2 == 0 else S [ : : - 1 ] ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> N , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> S = sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> l = x = ans = 0 <NEWLINE> for r in range ( N ) : <NEWLINE> <INDENT> if S [ r ] == <STRING> : <NEWLINE> <INDENT> if r == 0 or S [ r - 1 ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> if x > K : <NEWLINE> <INDENT> while S [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> while S [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> x -= 1 <NEWLINE> <DEDENT> ans = max ( ans , r - l + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> P = 0 <NEWLINE> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> P = R * G * B <NEWLINE> for i in range ( 1 , ( N // 2 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( N - 2 * i ) : <NEWLINE> <INDENT> if S [ j ] != S [ j + i ] and S [ j + i ] != S [ j + 2 * i ] and S [ j ] != S [ j + 2 * i ] : <NEWLINE> <INDENT> P -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( P ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def process_command ( dll , commands ) : <NEWLINE> <INDENT> for cmd in commands : <NEWLINE> <COMMENT> <NL> <INDENT> if cmd . startswith ( <STRING> ) or cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> t = cmd . split ( <STRING> ) <NEWLINE> cmd = t [ 0 ] <NEWLINE> num_str = t [ 1 ] <NEWLINE> <DEDENT> if cmd == <STRING> : <NEWLINE> <INDENT> dll . appendleft ( int ( num_str ) ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> if int ( num_str ) in dll : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> result = dll . popleft ( ) <NEWLINE> while result != int ( num_str ) : <NEWLINE> <INDENT> temp . append ( result ) <NEWLINE> result = dll . popleft ( ) <NEWLINE> <DEDENT> temp = temp [ : : - 1 ] <NEWLINE> dll . extendleft ( temp ) <NEWLINE> <DEDENT> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> commands = [ ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> commands . append ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dll = deque ( ) <NEWLINE> process_command ( dll , commands ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( <STRING> . format ( <STRING> . join ( map ( str , dll ) ) ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( la ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> while a < 1001 : <NEWLINE> <INDENT> for i in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> if a ** 5 - i ** 5 == X : <NEWLINE> <INDENT> b = i <NEWLINE> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> a += 1 <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> dp = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> dp [ 1 ] = 1 <NEWLINE> s = 0 <NEWLINE> mod = 998244353 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s += dp [ i ] <NEWLINE> for l , r in LR : <NEWLINE> <INDENT> if i + l <= n : <NEWLINE> <INDENT> dp [ i + l ] = ( dp [ i + l ] + s ) % mod <NEWLINE> if i + r + 1 <= n : <NEWLINE> <INDENT> dp [ i + r + 1 ] = ( dp [ i + r + 1 ] - s ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
a , b , c = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> if a == <STRING> and b == <STRING> and c == <STRING> : <NEWLINE> <INDENT> count = 3 <NEWLINE> <DEDENT> elif ( a == <STRING> and b == <STRING> ) or ( b == <STRING> and c == <STRING> ) : <NEWLINE> <INDENT> count = 2 <NEWLINE> <DEDENT> elif a == <STRING> or b == <STRING> or c == <STRING> : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
def is_prime ( num : int ) : <NEWLINE> <INDENT> if num == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif num % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> r_num = int ( num ** 0.5 ) <NEWLINE> for i in range ( 3 , r_num + 1 , 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> r_n = int ( n ** 0.5 ) <NEWLINE> divided = [ ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if n < i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif cnt == 0 and r_n + 1 < i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 and is_prime ( i ) : <NEWLINE> <INDENT> n = int ( n / i ) <NEWLINE> divided . append ( i ) <NEWLINE> cnt += 1 <NEWLINE> x = 2 <NEWLINE> while True : <NEWLINE> <INDENT> q = i ** x <NEWLINE> if q > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if n % q == 0 : <NEWLINE> <INDENT> n = int ( n / q ) <NEWLINE> x += 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if is_prime ( n ) and n not in divided : <NEWLINE> <INDENT> n = 1 <NEWLINE> cnt += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ sorted ( input ( ) ) for i in range ( N ) ] <NEWLINE> SS = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> SS . append ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> <NL> c = collections . Counter ( SS ) <NEWLINE> <NL> for i in c . values ( ) : <NEWLINE> <INDENT> count += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> sumA = 0 <NEWLINE> num = [ 0 ] * 100100 <NEWLINE> for aa in a : <NEWLINE> <INDENT> num [ aa ] += 1 <NEWLINE> sumA += aa <NEWLINE> <NL> <DEDENT> for b , c in bc : <NEWLINE> <INDENT> sumA = sumA + ( ( c - b ) * num [ b ] ) <NEWLINE> num [ c ] += num [ b ] <NEWLINE> num [ b ] = 0 <NEWLINE> print ( sumA ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> <NL> l = <STRING> <NEWLINE> <NL> for i in range ( 300 ) : <NEWLINE> <INDENT> if l == <STRING> : <NEWLINE> <INDENT> if len ( A ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( A ) == 1 : <NEWLINE> <INDENT> l = A [ 0 ] <NEWLINE> A = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = A [ 0 ] <NEWLINE> A = A [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> if len ( B ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( B ) == 1 : <NEWLINE> <INDENT> l = B [ 0 ] <NEWLINE> B = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = B [ 0 ] <NEWLINE> B = B [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( C ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( C ) == 1 : <NEWLINE> <INDENT> l = C [ 0 ] <NEWLINE> C = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = C [ 0 ] <NEWLINE> C = C [ 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , c , k = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> s , i = 0 , 0 <NEWLINE> if k <= a : <NEWLINE> <INDENT> s = k <NEWLINE> <DEDENT> elif k > a : <NEWLINE> <INDENT> s = a <NEWLINE> k -= a <NEWLINE> if k > b : <NEWLINE> <INDENT> k -= b <NEWLINE> s -= k <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> Sr = Sg = Sb = 0 <NEWLINE> for c in S : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> Sr += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> Sg += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Sb += 1 <NEWLINE> <DEDENT> <DEDENT> A = Sr * Sg * Sb <NEWLINE> for sep in range ( 1 , ( N + 1 ) // 2 ) : <NEWLINE> <INDENT> for i in range ( N - 2 * sep ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + sep ] and S [ i + sep ] != S [ i + 2 * sep ] and S [ i ] != S [ i + 2 * sep ] : <NEWLINE> <INDENT> A -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> D = { c : 0 for c in range ( 1 , 10 ** 5 + 1 ) } <NEWLINE> for a in A : <NEWLINE> <INDENT> D [ a ] += 1 <NEWLINE> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S += ( C - B ) * D [ B ] <NEWLINE> D [ C ] += D [ B ] <NEWLINE> D [ B ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if ( x % 100 == 0 ) or ( x % 101 == 0 ) or ( x % 102 == 0 ) or ( x % 103 == 0 ) or ( x % 104 == 0 ) or ( x % 105 == 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return f ( x - 100 ) or f ( x - 101 ) or f ( x - 102 ) or f ( x - 103 ) or f ( x - 104 ) or f ( x - 105 ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X = ii ( ) <NEWLINE> print ( 1 if f ( X ) else 0 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> que = deque ( s ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q = input ( ) . split ( ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> reverse = cnt % 2 <NEWLINE> if q [ 1 ] == <STRING> : <NEWLINE> <INDENT> if reverse == 0 : <NEWLINE> <INDENT> s = que . appendleft ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = que . append ( q [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if reverse == 0 : <NEWLINE> <INDENT> s = que . append ( q [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = que . appendleft ( q [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> . join ( que ) <NEWLINE> if cnt % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] * M <NEWLINE> w = [ 0 ] * M <NEWLINE> <NL> nh = [ 0 ] * H <COMMENT> <NEWLINE> nw = [ 0 ] * W <COMMENT> <NEWLINE> dic = defaultdict ( bool ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h [ i ] , w [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ i ] -= 1 <NEWLINE> w [ i ] -= 1 <NEWLINE> nh [ h [ i ] ] += 1 <NEWLINE> nw [ w [ i ] ] += 1 <NEWLINE> dic [ <STRING> . format ( h [ i ] , w [ i ] ) ] = True <NEWLINE> <NL> <DEDENT> mnh = max ( nh ) <NEWLINE> mnw = max ( nw ) <NEWLINE> <NL> mh = [ i for i , nh1 in enumerate ( nh ) if nh1 == mnh ] <NEWLINE> mw = [ i for i , nw1 in enumerate ( nw ) if nw1 == mnw ] <NEWLINE> <NL> for h1 in mh : <NEWLINE> <INDENT> for w1 in mw : <NEWLINE> <INDENT> if not dic [ <STRING> . format ( h1 , w1 ) ] : <NEWLINE> <INDENT> print ( mnh + mnw ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mnh + mnw - 1 ) <NEWLINE>
class complete_btree : <NEWLINE> <INDENT> def __init__ ( self , vals ) : <NEWLINE> <INDENT> self . vals = vals <NEWLINE> self . index_max = len ( self . vals ) <NEWLINE> <NL> <DEDENT> def check ( self , i ) : <NEWLINE> <INDENT> assert ( i >= 1 ) <NEWLINE> assert ( i <= self . index_max ) <NEWLINE> <NL> <DEDENT> def val_at ( self , i ) : <NEWLINE> <INDENT> self . check ( i ) <NEWLINE> return self . vals [ i - 1 ] <NEWLINE> <NL> <DEDENT> def left_idx ( self , i ) : <NEWLINE> <INDENT> self . check ( i ) <NEWLINE> t = 2 * i <NEWLINE> if t <= self . index_max : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> def right_idx ( self , i ) : <NEWLINE> <INDENT> self . check ( i ) <NEWLINE> t = 2 * i + 1 <NEWLINE> if t <= self . index_max : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> def parent_idx ( self , i ) : <NEWLINE> <INDENT> self . check ( i ) <NEWLINE> t = i // 2 <NEWLINE> if t > 0 : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H = int ( input ( ) ) <COMMENT> <NEWLINE> vals_str = input ( ) <COMMENT> <NEWLINE> vals = vals_str . split ( <STRING> ) <NEWLINE> <NL> cbt = complete_btree ( vals ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i = i , k = cbt . val_at ( i ) ) , end = <STRING> ) <NEWLINE> p_idx = cbt . parent_idx ( i ) <NEWLINE> l_idx = cbt . left_idx ( i ) <NEWLINE> r_idx = cbt . right_idx ( i ) <NEWLINE> if p_idx is not None : <NEWLINE> <INDENT> print ( <STRING> . format ( k = cbt . val_at ( p_idx ) ) , end = <STRING> ) <NEWLINE> <DEDENT> if l_idx is not None : <NEWLINE> <INDENT> print ( <STRING> . format ( k = cbt . val_at ( l_idx ) ) , end = <STRING> ) <NEWLINE> <DEDENT> if r_idx is not None : <NEWLINE> <INDENT> print ( <STRING> . format ( k = cbt . val_at ( r_idx ) ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b += B [ i ] <NEWLINE> if b <= K : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> a = 0 <NEWLINE> b = sum ( B ) <NEWLINE> j = M <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a += A [ i ] <NEWLINE> if a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a + b > K : <NEWLINE> <INDENT> b -= B [ - 1 ] <NEWLINE> B . pop ( - 1 ) <NEWLINE> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j + 1 ) <NEWLINE> <DEDENT> ans = max ( ans , c ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) ; <NEWLINE> ans = 1 ; <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = False <NEWLINE> flag2 = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lis [ i ] == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> if ans * lis [ i ] >= 1000000000000000001 : <NEWLINE> <INDENT> flag2 = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= lis [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif flag2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numset = set ( range ( 0 , 10 ) ) <NEWLINE> d = numset . difference ( D ) <NEWLINE> <NL> for n in range ( N , pow ( 10 , 6 ) + 10 ) : <NEWLINE> <INDENT> check = set ( list ( str ( n ) ) ) <NEWLINE> ngflag = False <NEWLINE> for i in check : <NEWLINE> <INDENT> if int ( i ) in D : <NEWLINE> <INDENT> ngflag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not ngflag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> for ii in range ( k ) : <NEWLINE> <INDENT> ans += gcd ( i + 1 , gcd ( j + 1 , ii + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> a = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = Counter ( l ) <NEWLINE> <COMMENT> <NL> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> def powerDX ( n , r , mod ) : <NEWLINE> <INDENT> if r == 0 : return 1 <NEWLINE> if r % 2 == 0 : <NEWLINE> <INDENT> return powerDX ( n * n % mod , r // 2 , mod ) % mod <NEWLINE> <DEDENT> if r % 2 == 1 : <NEWLINE> <INDENT> return n * powerDX ( n , r - 1 , mod ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> ans += m * cmb ( n - 1 , i , mod ) * powerDX ( m - 1 , n - i - 1 , mod ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import functools <NEWLINE> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> N = int ( next ( in_ ) ) <NEWLINE> A = tuple ( map ( int , next ( in_ ) . split ( ) ) ) <NEWLINE> <NL> max_a = max ( A ) <NEWLINE> temp = [ 0 ] * ( max_a + 1 ) <NEWLINE> temp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , max_a + 1 ) : <NEWLINE> <INDENT> if temp [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> j = i <NEWLINE> while j < max_a + 1 : <NEWLINE> <INDENT> if not temp [ j ] : <NEWLINE> <INDENT> temp [ j ] = i <NEWLINE> <DEDENT> j += i <NEWLINE> <NL> <DEDENT> <DEDENT> B = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> s = set ( ) <NEWLINE> while a > 1 : <NEWLINE> <INDENT> s . add ( temp [ a ] ) <NEWLINE> a = a // temp [ a ] <NEWLINE> <DEDENT> for v in s : <NEWLINE> <INDENT> if v in B : <NEWLINE> <INDENT> if functools . reduce ( math . gcd , A ) == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> B . add ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( a - b ) > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k % 2 == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , num , prv = None , nxt = None ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . prv = prv <NEWLINE> self . nxt = nxt <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class DoublyLinkedList ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <NL> <DEDENT> def insert ( self , num ) : <NEWLINE> <INDENT> new_elem = Node ( num ) <NEWLINE> <NL> if self . start is None : <NEWLINE> <INDENT> self . start = self . last = new_elem <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_elem . nxt = self . start <NEWLINE> self . start . prv = new_elem <NEWLINE> self . start = new_elem <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_num ( self , target ) : <NEWLINE> <INDENT> it = self . start <NEWLINE> while it is not None : <NEWLINE> <INDENT> if it . num == target : <NEWLINE> <INDENT> if it . prv is None and it . nxt is None : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if it . prv is not None : <NEWLINE> <INDENT> it . prv . nxt = it . nxt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . start = self . start . nxt <NEWLINE> <NL> <DEDENT> if it . nxt is not None : <NEWLINE> <INDENT> it . nxt . prv = it . prv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . last = self . last . prv <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> it = it . nxt <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_start ( self ) : <NEWLINE> <INDENT> if self . start is self . last : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . start . nxt . prv = None <NEWLINE> self . start = self . start . nxt <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_last ( self ) : <NEWLINE> <INDENT> if self . start is self . last : <NEWLINE> <INDENT> self . start = self . last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . last . prv . nxt = None <NEWLINE> self . last = self . last . prv <NEWLINE> <NL> <DEDENT> <DEDENT> def get_content ( self ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> it = self . start <NEWLINE> <NL> while it is not None : <NEWLINE> <INDENT> ret . append ( it . num ) <NEWLINE> it = it . nxt <NEWLINE> <NL> <DEDENT> return <STRING> . join ( ret ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def _main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> lst = DoublyLinkedList ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . insert ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_num ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_start ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> lst . delete_last ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lst . get_content ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _main ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> k = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = b - 1 <NEWLINE> <DEDENT> print ( ( a * k ) // b - a * ( k // b ) ) <NEWLINE>
<NL> def solve ( S ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( 2000 + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 3 ] = 1 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> for n in range ( 4 , S + 1 ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> for c in range ( 3 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> answer = ( answer + dp [ n - c ] ) % MOD <NEWLINE> <DEDENT> dp [ n ] = answer % MOD <NEWLINE> <COMMENT> <NL> <DEDENT> return dp [ S ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( solve ( int ( input ( ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def luc ( x ) : <NEWLINE> <INDENT> x1 = 2 <NEWLINE> x2 = 1 <NEWLINE> if x == 1 : <NEWLINE> <INDENT> return x1 <NEWLINE> <DEDENT> elif x == 2 : <NEWLINE> <INDENT> return x2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x - 2 ) : <NEWLINE> <INDENT> x1 , x2 = x2 , x1 + x2 <NEWLINE> <DEDENT> return x2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( luc ( n + 1 ) ) <NEWLINE>
from collections import deque <NEWLINE> from bisect import bisect_left as bile <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> inf = 1e18 <NEWLINE> dp = [ inf ] * ( n + 10 ) <NEWLINE> parent = [ - 1 ] * n <NEWLINE> def dfs ( s ) : <NEWLINE> <INDENT> idx = bile ( dp , arr [ s ] ) <NEWLINE> tmp = dp [ idx ] <NEWLINE> dp [ idx ] = arr [ s ] <NEWLINE> ans [ s ] = bile ( dp , inf ) <NEWLINE> <NL> for v in adj [ s ] : <NEWLINE> <INDENT> if v == parent [ s ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ v ] = s <NEWLINE> dfs ( v ) <NEWLINE> <DEDENT> dp [ idx ] = tmp <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> ans = dfs ( 0 ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> <NL> class Edge ( ) : <NEWLINE> <INDENT> def __init__ ( self , end , cost , time ) : <NEWLINE> <INDENT> self . end = end <NEWLINE> self . cost = cost <NEWLINE> self . time = time <NEWLINE> <NL> <DEDENT> <DEDENT> dp = [ ] <NEWLINE> h = [ ] <NEWLINE> <NL> def push ( t , v , x ) : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if dp [ v ] [ x ] <= t : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> dp [ v ] [ x ] = t <NEWLINE> heapq . heappush ( h , ( t , v , x ) ) <NEWLINE> <NL> <DEDENT> def dijkstra ( n , G , cd , start , s , max_s ) : <NEWLINE> <INDENT> global dp <NEWLINE> dp = [ [ INF for j in range ( max_s + 1 ) ] for i in range ( n ) ] <NEWLINE> push ( 0 , start , s ) <NEWLINE> <NL> while h : <NEWLINE> <COMMENT> <NL> <INDENT> t , v , x = heapq . heappop ( h ) <NEWLINE> if dp [ v ] [ x ] < t : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if x < max_s : <NEWLINE> <INDENT> push ( t + cd [ v ] [ 1 ] , v , min ( x + cd [ v ] [ 0 ] , max_s ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> for e in G [ v ] : <NEWLINE> <INDENT> push ( t + e . time , e . end , x - e . cost ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> uvab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> es = [ [ ] for i in range ( n ) ] <NEWLINE> max_s = 50 * ( n - 1 ) <NEWLINE> <NL> for u , v , a , b in uvab : <NEWLINE> <INDENT> es [ u - 1 ] . append ( Edge ( v - 1 , a , b ) ) <NEWLINE> es [ v - 1 ] . append ( Edge ( u - 1 , a , b ) ) <NEWLINE> <NL> <DEDENT> dijkstra ( n , es , cd , 0 , min ( max_s , s ) , max_s ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( min ( dp [ i ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def create_array ( n : int , r : int , mod , mod2 ) : <NEWLINE> <INDENT> m_ls = [ 1 ] * ( r + 1 ) <NEWLINE> <NL> for i , j in zip ( range ( n , 0 , - 1 ) , range ( 1 , r + 1 ) ) : <NEWLINE> <INDENT> m_ls [ j ] = ( m_ls [ j - 1 ] * i * pow ( j , mod2 , mod ) ) % mod <NEWLINE> <DEDENT> return m_ls <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> _mod = 998244353 <NEWLINE> _mod2 = 998244351 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> comb_ar = create_array ( n - 1 , k , _mod , _mod2 ) <NEWLINE> _z = ( m - 1 ) ** ( n - 1 - k ) <NEWLINE> res = m * _z * comb_ar [ k ] <NEWLINE> res %= _mod <NEWLINE> <NL> if k > 0 : <NEWLINE> <INDENT> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> _z *= m - 1 <NEWLINE> _z %= _mod <NEWLINE> res += m * _z * comb_ar [ k - x ] <NEWLINE> res %= _mod <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> rList = [ ] <NEWLINE> gList = [ ] <NEWLINE> bList = [ ] <NEWLINE> <NL> for indx in range ( N ) : <NEWLINE> <INDENT> if S [ indx ] == <STRING> : <NEWLINE> <INDENT> rList . append ( indx ) <NEWLINE> <DEDENT> elif S [ indx ] == <STRING> : <NEWLINE> <INDENT> gList . append ( indx ) <NEWLINE> <DEDENT> elif S [ indx ] == <STRING> : <NEWLINE> <INDENT> bList . append ( indx ) <NEWLINE> <NL> <DEDENT> <DEDENT> NoSum = 0 <NEWLINE> fList = rList <NEWLINE> sList = gList <NEWLINE> remain = <STRING> <NEWLINE> <NL> for fItem in fList : <NEWLINE> <INDENT> for sItem in sList : <NEWLINE> <INDENT> prsMax = max ( fItem , sItem ) <NEWLINE> prsMin = min ( fItem , sItem ) <NEWLINE> if ( ( 2 * prsMax - prsMin ) <= N - 1 ) : <NEWLINE> <INDENT> if ( S [ ( 2 * prsMax - prsMin ) ] == remain ) : <NEWLINE> <INDENT> NoSum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ( prsMax - prsMin ) % 2 == 0 ) : <NEWLINE> <INDENT> if ( S [ int ( ( prsMax + prsMin ) / 2 ) ] == remain ) : <NEWLINE> <INDENT> NoSum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ( 2 * prsMin - prsMax ) >= 0 ) : <NEWLINE> <INDENT> if ( S [ ( 2 * prsMin - prsMax ) ] == remain ) : <NEWLINE> <INDENT> NoSum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( rList ) * len ( gList ) * len ( bList ) - NoSum ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> d = ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> stones = [ l for l in input ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> memo = N - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( memo , i , - 1 ) : <NEWLINE> <INDENT> if stones [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if stones [ j ] == <STRING> : <NEWLINE> <INDENT> stones [ i ] = <STRING> <NEWLINE> stones [ j ] = <STRING> <NEWLINE> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> memo = j <NEWLINE> if memo == i : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> my_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> my_dict1 = { } <NEWLINE> my_dict2 = { } <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> key = my_list [ i ] + i <NEWLINE> if key in my_dict1 . keys ( ) : <NEWLINE> <INDENT> my_dict1 [ key ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> my_dict1 [ key ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> key = j - my_list [ j ] <NEWLINE> if key in my_dict2 . keys ( ) : <NEWLINE> <INDENT> my_dict2 [ key ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> my_dict2 [ key ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for key in my_dict1 . keys ( ) : <NEWLINE> <INDENT> if key in my_dict2 . keys ( ) : <NEWLINE> <INDENT> ans += my_dict1 [ key ] * my_dict2 [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 60 * ( h2 - h1 ) + m2 - m1 - k ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> parents = [ i for i in range ( N + 1 ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if x == parents [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parents [ x ] = find ( parents [ x ] ) <NEWLINE> return parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( A , B ) : <NEWLINE> <INDENT> x , y = find ( A ) , find ( B ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parents [ x ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> same ( A , B ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> find ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( parents ) ) - 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> g = [ set ( ) for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . add ( b - 1 ) <NEWLINE> g [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( s ) : <NEWLINE> <INDENT> visited = [ - 1 ] * n <NEWLINE> visited [ s ] = 0 <NEWLINE> temp = [ s ] <NEWLINE> lst = [ ] <NEWLINE> while temp : <NEWLINE> <INDENT> p = temp . pop ( ) <NEWLINE> for a in g [ p ] : <NEWLINE> <INDENT> if visited [ a ] != - 1 : continue <NEWLINE> visited [ a ] = visited [ p ] + 1 <NEWLINE> temp . append ( a ) <NEWLINE> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> lst0 = dfs ( 0 ) <NEWLINE> lstn = dfs ( n - 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lst0 [ i ] <= lstn [ i ] : cnt += 1 <NEWLINE> <NL> <DEDENT> if cnt > n - cnt : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AA = [ 0 ] * ( N + 1 ) <NEWLINE> BB = [ 0 ] * ( M + 1 ) <NEWLINE> A3 = 0 <NEWLINE> B3 = 0 <NEWLINE> high = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> A3 += A [ i ] <NEWLINE> AA [ i + 1 ] = A3 <NEWLINE> <DEDENT> for j in range ( 0 , M ) : <NEWLINE> <INDENT> B3 += B [ j ] <NEWLINE> BB [ j + 1 ] = B3 <NEWLINE> <DEDENT> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> if AA [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if BB == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif BB == [ 0 ] : <NEWLINE> <INDENT> BB = [ ] <NEWLINE> break <NEWLINE> <DEDENT> elif AA [ i ] + BB [ - 1 ] > K : <NEWLINE> <INDENT> BB . pop ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if BB != [ ] : <NEWLINE> <INDENT> time = AA [ i ] + BB [ - 1 ] <NEWLINE> judge = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time = AA [ i ] <NEWLINE> judge = 0 <NEWLINE> <DEDENT> if time <= K : <NEWLINE> <INDENT> if judge == 0 : <NEWLINE> <INDENT> if high < i : <NEWLINE> <INDENT> high = i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if high < i + len ( BB ) - 1 : <NEWLINE> <INDENT> high = i + len ( BB ) - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( high ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AM = max ( A ) + 1 <NEWLINE> B = [ 0 ] * AM <NEWLINE> x = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in range ( i , AM , i ) : <NEWLINE> <INDENT> B [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> if B [ i ] == 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( mi ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ii ( ) <NEWLINE> x = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = mi ( ) <NEWLINE> x . append ( a + b ) <NEWLINE> ans -= b <NEWLINE> <DEDENT> x . sort ( reverse = True ) <NEWLINE> ans += sum ( x [ : : 2 ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> <NL> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> x = int ( s [ 2 ] ) <NEWLINE> <NL> def bet_ween ( p , q ) : <NEWLINE> <INDENT> if p < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( p // q ) + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> fa = bet_ween ( a - 1 , x ) <NEWLINE> fb = bet_ween ( b , x ) <NEWLINE> answer = fb - fa <NEWLINE> print ( int ( answer ) ) <NEWLINE>
NIL = - 1 <NEWLINE> <NL> <NL> class Node : <NEWLINE> <INDENT> parent = NIL <NEWLINE> left = NIL <NEWLINE> right = NIL <NEWLINE> <NL> <NL> <DEDENT> def getDepth ( u ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> while T [ u ] . parent != NIL : <NEWLINE> <INDENT> u = T [ u ] . parent <NEWLINE> d += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def getChildren ( u ) : <NEWLINE> <INDENT> c = T [ u ] . left <NEWLINE> result = [ ] <NEWLINE> while c != NIL : <NEWLINE> <INDENT> result . append ( c ) <NEWLINE> c = T [ c ] . right <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> T = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> T [ i ] = Node ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> id = tmp . pop ( 0 ) <NEWLINE> k = tmp . pop ( 0 ) <NEWLINE> c = tmp <NEWLINE> if k != 0 : <NEWLINE> <INDENT> for j in range ( len ( c ) ) : <NEWLINE> <INDENT> T [ c [ j ] ] . parent = id <NEWLINE> <DEDENT> T [ id ] . left = c [ 0 ] <NEWLINE> for j in range ( len ( c ) - 1 ) : <NEWLINE> <INDENT> T [ c [ j ] ] . right = c [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d = getDepth ( i ) <NEWLINE> c = getChildren ( i ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> elif c == [ ] : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> print ( <STRING> , i , <STRING> , <STRING> , T [ i ] . parent , <STRING> , d , <STRING> , t , <STRING> , c , sep = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> MAX_LENGTH = len ( A ) <NEWLINE> dp = [ [ - 1 for i in range ( max ( m ) + 1 ) ] for j in range ( MAX_LENGTH + 1 ) ] <NEWLINE> <COMMENT> <NL> def fullSearch ( i , m ) : <NEWLINE> <COMMENT> <NL> <INDENT> if m < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif dp [ i ] [ m ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] [ m ] <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif i >= MAX_LENGTH : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> res = fullSearch ( i + 1 , m ) or fullSearch ( i + 1 , m - A [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> dp [ i ] [ m ] = res <NEWLINE> return res <NEWLINE> <DEDENT> for mi in m : <NEWLINE> <INDENT> print ( <STRING> if fullSearch ( 0 , mi ) else <STRING> ) <NEWLINE> <DEDENT>
str_list = [ ] <NEWLINE> i = 1 <NEWLINE> n_number , l_length = map ( int , input ( ) . split ( ) ) <NEWLINE> while i <= n_number : <NEWLINE> <INDENT> w_1 = input ( ) <NEWLINE> str_list . append ( w_1 ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> str_list . sort ( ) <NEWLINE> print ( <STRING> . join ( str_list ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> d = np . zeros ( 2019 , np . int64 ) <NEWLINE> ans = 0 <NEWLINE> num = 0 <NEWLINE> pow10 = 1 <NEWLINE> d [ 0 ] = 1 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> pow10 = pow10 * 10 % 2019 <NEWLINE> num += int ( s [ i ] ) * pow10 <NEWLINE> <COMMENT> <NL> mod = num % 2019 <NEWLINE> ans += d [ mod ] <NEWLINE> d [ mod ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import floor <NEWLINE> A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = min ( ( B - 1 ) , N ) <NEWLINE> ans = floor ( A * x / B ) - A * floor ( x / B ) <NEWLINE> print ( ans ) <NEWLINE>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> An = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> i = 0 <NEWLINE> checked = [ 0 for _ in range ( N ) ] <NEWLINE> c = 0 <NEWLINE> while checked [ i ] == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> checked [ i ] = c <NEWLINE> i = An [ i ] - 1 <NEWLINE> <DEDENT> if checked [ i ] >= K : <NEWLINE> <INDENT> i = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> i = An [ i ] - 1 <NEWLINE> <DEDENT> print ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> period = c - checked [ i ] + 1 <NEWLINE> diff = K - checked [ i ] + 1 <NEWLINE> mod_diff = diff % period <NEWLINE> for k in range ( mod_diff ) : <NEWLINE> <INDENT> i = An [ i ] - 1 <NEWLINE> <DEDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
class D_Linked_List : <NEWLINE> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , next = None , prev = None ) : <NEWLINE> <INDENT> self . next = next <NEWLINE> self . prev = prev <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nil = D_Linked_List . Node ( None ) <NEWLINE> self . nil . next = self . nil <NEWLINE> self . nil . prev = self . nil <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> node_x = D_Linked_List . Node ( key , self . nil . next , self . nil ) <NEWLINE> self . nil . next . prev = node_x <NEWLINE> self . nil . next = node_x <NEWLINE> <NL> <DEDENT> def _listSearch ( self , key ) : <NEWLINE> <INDENT> cur_node = self . nil . next <NEWLINE> while ( cur_node != self . nil ) and ( cur_node . key != key ) : <NEWLINE> <INDENT> cur_node = cur_node . next <NEWLINE> <DEDENT> return cur_node <NEWLINE> <NL> <DEDENT> def _deleteNode ( self , node ) : <NEWLINE> <INDENT> if node == self . nil : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> node . prev . next = node . next <NEWLINE> node . next . prev = node . prev <NEWLINE> <NL> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . _deleteNode ( self . nil . next ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . _deleteNode ( self . nil . prev ) <NEWLINE> <NL> <DEDENT> def deleteKey ( self , key ) : <NEWLINE> <INDENT> node = self . _listSearch ( key ) <NEWLINE> self . _deleteNode ( node ) <NEWLINE> <NL> <DEDENT> def show_keys ( self ) : <NEWLINE> <INDENT> cur_node = self . nil . next <NEWLINE> keys = [ ] <NEWLINE> while cur_node != self . nil : <NEWLINE> <INDENT> keys . append ( cur_node . key ) <NEWLINE> cur_node = cur_node . next <NEWLINE> <DEDENT> print ( <STRING> . join ( keys ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> d_ll = D_Linked_List ( ) <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> x = i [ 7 : - 1 ] <NEWLINE> d_ll . insert ( x ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> d_ll . deleteFirst ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> d_ll . deleteLast ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> x = i [ 7 : - 1 ] <NEWLINE> d_ll . deleteKey ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> d_ll . show_keys ( ) <NEWLINE>
import numpy as np <NEWLINE> import numba <NEWLINE> from typing import List <NEWLINE> <NL> <NL> @ numba . jit <NEWLINE> def solver ( N : int , S : int , A : np . array ) -> int : <NEWLINE> <INDENT> dp = np . zeros ( ( N + 1 , S + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> dp [ 0 , 0 ] = 1 <NEWLINE> MOD = 998244353 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( S + 1 ) : <NEWLINE> <INDENT> dp [ i + 1 , j ] += 2 * dp [ i , j ] <NEWLINE> dp [ i + 1 , j ] %= MOD <NEWLINE> if j + A [ i ] <= S : <NEWLINE> <INDENT> dp [ i + 1 , j + A [ i ] ] += dp [ i , j ] <NEWLINE> dp [ i + 1 , j + A [ i ] ] %= MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ N , S ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , S = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = solver ( N , S , np . array ( A ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import re <NEWLINE> T = input ( ) <NEWLINE> x = 0 <NEWLINE> Td = T <NEWLINE> d = len ( re . sub ( <STRING> , <STRING> , Td ) ) <NEWLINE> x += math . ceil ( ( d / 2 + 1 ) * d / 2 ) <NEWLINE> spT = T . split ( <STRING> ) <NEWLINE> lenT = list ( map ( len , spT ) ) <NEWLINE> <NL> tmpX = math . ceil ( d / 2 ) <NEWLINE> bT = 0 <NEWLINE> aT = d <NEWLINE> tmp = <STRING> <NEWLINE> for i in range ( len ( spT ) - 1 ) : <NEWLINE> <INDENT> tmp += spT [ i ] <NEWLINE> bT += lenT [ i ] <NEWLINE> aT -= lenT [ i ] <NEWLINE> if bT % 2 == 1 : <NEWLINE> <INDENT> bT += 1 <NEWLINE> if aT % 2 == 1 : <NEWLINE> <INDENT> tmpX += 1 <NEWLINE> <DEDENT> x += tmpX <NEWLINE> tmp += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += <STRING> <NEWLINE> <DEDENT> <DEDENT> tmp += spT [ - 1 ] <NEWLINE> <NL> spT = tmp . split ( <STRING> ) <NEWLINE> vT = [ ] <NEWLINE> aT = bT <NEWLINE> bT = 0 <NEWLINE> <NL> odT = 0 <NEWLINE> tmpOd = True <NEWLINE> <NL> for i in range ( len ( spT ) ) : <NEWLINE> <NL> <INDENT> od = len ( re . sub ( <STRING> , <STRING> , spT [ i ] [ 0 if tmpOd else 1 : : 2 ] ) ) <NEWLINE> ev = len ( re . sub ( <STRING> , <STRING> , spT [ i ] [ 1 if tmpOd else 0 : : 2 ] ) ) <NEWLINE> odT += od <NEWLINE> vT . append ( od - ev ) <NEWLINE> if len ( spT [ i ] ) % 2 == 1 : <NEWLINE> <INDENT> tmpOd = not tmpOd <NEWLINE> <NL> <DEDENT> <DEDENT> for i in reversed ( range ( 1 , len ( spT ) ) ) : <NEWLINE> <INDENT> odT = odT - vT [ i ] <NEWLINE> x += odT <NEWLINE> vT [ i - 1 ] -= vT [ i ] <NEWLINE> <NL> <NL> <DEDENT> print ( x ) <NEWLINE>
def cal ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in lst : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prod = 1 <NEWLINE> for a in lst : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return prod <NEWLINE> <DEDENT> print ( cal ( ) ) <NEWLINE>
import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> X , Y = map ( int , r ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if 2 * X - Y < 0 or ( 2 * X - Y ) % 3 != 0 or 2 * Y - X < 0 or ( 2 * Y - X ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> a = ( 2 * Y - X ) // 3 <NEWLINE> b = ( 2 * X - Y ) // 3 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def pow ( a , b ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> while b : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> ans = ( ans * a ) % MOD <NEWLINE> <DEDENT> a = ( a ** 2 ) % MOD <NEWLINE> b = b // 2 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> N = a + b <NEWLINE> K = a <NEWLINE> fac = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fac [ i ] = ( fac [ i - 1 ] * i ) % MOD <NEWLINE> <DEDENT> A = fac [ N ] <NEWLINE> B = ( fac [ N - K ] * fac [ K ] ) % MOD <NEWLINE> print ( ( A % MOD ) * pow ( B , MOD - 2 ) % MOD ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power = power * i % mod <NEWLINE> <DEDENT> print ( power ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> total = 0 <NEWLINE> t = sum ( x ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> t = t - x [ i ] <NEWLINE> total = total + x [ i ] * ( t ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( total % 1000000007 ) <NEWLINE> <NL>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if X > 0 : <NEWLINE> <INDENT> k = X // D <NEWLINE> if k <= K : <NEWLINE> <INDENT> X -= D * k <NEWLINE> K -= k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X -= D * K <NEWLINE> K = 0 <NEWLINE> print ( abs ( X ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cur_abs = abs ( X ) <NEWLINE> while K > 0 : <NEWLINE> <INDENT> X -= D <NEWLINE> if abs ( X ) > cur_abs : <NEWLINE> <INDENT> X += D <NEWLINE> break <NEWLINE> <DEDENT> cur_abs = abs ( X ) <NEWLINE> K -= 1 <NEWLINE> <DEDENT> K = K % 2 <NEWLINE> if K % 2 != 0 : <NEWLINE> <INDENT> print ( min ( abs ( X + D ) , abs ( X - D ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cur_abs ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> elif X < 0 : <NEWLINE> <INDENT> k = abs ( X ) // D <NEWLINE> if k <= K : <NEWLINE> <INDENT> X += D * k <NEWLINE> K -= k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X += D * K <NEWLINE> K = 0 <NEWLINE> print ( abs ( X ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cur_abs = abs ( X ) <NEWLINE> while K > 0 : <NEWLINE> <INDENT> X += D <NEWLINE> if abs ( X ) > cur_abs : <NEWLINE> <INDENT> X -= D <NEWLINE> break <NEWLINE> <DEDENT> cur_abs = abs ( X ) <NEWLINE> K -= 1 <NEWLINE> <DEDENT> K = K % 2 <NEWLINE> if K % 2 != 0 : <NEWLINE> <INDENT> print ( min ( abs ( X + D ) , abs ( X - D ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cur_abs ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( X + D ) , abs ( X - D ) ) ) <NEWLINE> <DEDENT> <DEDENT>
n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s . insert ( 0 , 0 ) <NEWLINE> for i in range ( a , max ( c , d ) ) : <NEWLINE> <INDENT> if <STRING> == s [ i ] and <STRING> == s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if c < d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( b - 1 , d ) : <NEWLINE> <INDENT> if <STRING> == s [ i ] and <STRING> == s [ i + 1 ] and <STRING> == s [ i + 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> lsx = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in lsx : <NEWLINE> <INDENT> K = K - 1 <NEWLINE> lsx . remove ( 0 ) <NEWLINE> <DEDENT> if bool ( lsx ) == False or K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> lshu = [ ] <NEWLINE> sei = len ( lsx ) <NEWLINE> for i in range ( len ( lsx ) ) : <NEWLINE> <INDENT> if lsx [ i ] < 0 : <NEWLINE> <INDENT> lshu . append ( lsx [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sei = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> lssei = lsx [ sei : ] <NEWLINE> lenhu = len ( lshu ) <NEWLINE> lensei = len ( lssei ) <NEWLINE> lshu2 = [ abs ( lshu [ i ] ) for i in range ( lenhu - 1 , - 1 , - 1 ) ] <NEWLINE> dishu = [ 0 ] + lshu2 <NEWLINE> dissei = [ 0 ] + lssei <NEWLINE> ans = 10 * 10 ** 8 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if i <= lenhu and K - i <= lensei : <NEWLINE> <INDENT> ans = min ( ans , 2 * dishu [ i ] + dissei [ K - i ] , dishu [ i ] + 2 * dissei [ K - i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> [ X , K , D ] = input ( ) . split ( ) <NEWLINE> X = int ( X ) <NEWLINE> K = int ( K ) <NEWLINE> D = int ( D ) <NEWLINE> c = 0 <NEWLINE> N = min ( math . floor ( abs ( X ) / D ) , K ) <NEWLINE> if abs ( abs ( X ) - N * D ) > abs ( abs ( X ) - ( N - 1 ) * D ) : <NEWLINE> <INDENT> N = N - 1 <NEWLINE> <DEDENT> if abs ( X - N * D ) < abs ( X + N * D ) : <NEWLINE> <INDENT> Z = X - N * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Z = X + N * D <NEWLINE> <NL> <DEDENT> if ( K - N ) % 2 == 1 : <NEWLINE> <INDENT> if abs ( Z + D ) < abs ( Z - D ) : <NEWLINE> <INDENT> Z = Z + D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Z = Z - D <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( abs ( Z ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> xa = min ( A , K ) <NEWLINE> K = K - xa <NEWLINE> xb = min ( B , K ) <NEWLINE> K = K - xb <NEWLINE> xc = min ( C , K ) <NEWLINE> total = xa * 1 + xb * 0 + xc * - 1 <NEWLINE> print ( total ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> xorSum = 0 <NEWLINE> <NL> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> xorSum ^= A [ i ] <NEWLINE> <NL> <DEDENT> res . append ( xorSum ) <NEWLINE> A_reversed = A [ : : - 1 ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> xorSum = xorSum ^ A_reversed [ i ] ^ A_reversed [ i + 1 ] <NEWLINE> res . append ( xorSum ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , res [ : : - 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> s = input ( ) [ : : - 1 ] <NEWLINE> cntr = defaultdict ( int ) <NEWLINE> cntr [ 0 ] += 1 <NEWLINE> tens = 1 <NEWLINE> n = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> n += tens * int ( c ) % 2019 <NEWLINE> n %= 2019 <NEWLINE> cntr [ n ] += 1 <NEWLINE> tens = tens * 10 % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for v in cntr . values ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import math <NEWLINE> mini = min ( alist ) <NEWLINE> if mini == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= alist [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s_list = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> s_list . append ( s ) <NEWLINE> <DEDENT> s_list = list ( set ( s_list ) ) <NEWLINE> print ( len ( s_list ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> cc = r * r * math . pi <NEWLINE> ab = ( r + r ) * math . pi <NEWLINE> print ( <STRING> % ( cc ) , <STRING> % ( ab ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def binarySearch ( A , key ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( A ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif key < A [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> a = 0 <NEWLINE> for t in T : a += binarySearch ( S , t ) <NEWLINE> print ( a ) <NEWLINE>
import random <NEWLINE> <NL> <NL> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> i = 0 + int ( random . random ( ) * ( n - 3 ) ) <NEWLINE> print ( S [ i ] + S [ i + 1 ] + S [ i + 2 ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> t = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> LCM = t [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> LCM = lcm ( LCM , t [ i ] ) <NEWLINE> <NL> <DEDENT> print ( LCM ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( K ) : <NEWLINE> <INDENT> g = gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( K ) : <NEWLINE> <INDENT> sum += gcd ( g , c + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> from collections import Counter <NEWLINE> MOD = 2019 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = list ( map ( int , list ( readline ( ) . rstrip ( ) ) ) ) <NEWLINE> N = len ( S ) <NEWLINE> T = [ 0 ] * ( N + 1 ) <NEWLINE> e = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> T [ i ] = ( T [ i + 1 ] + int ( S [ i ] ) * e ) % MOD <NEWLINE> e = e * 10 % MOD <NEWLINE> <NL> <DEDENT> T = [ t % MOD for t in T ] <NEWLINE> c = Counter ( T ) <NEWLINE> ans = 0 <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <INDENT> ans += ( v * ( v - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def Ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def Mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def Li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = Ii ( ) <NEWLINE> a = Li ( ) <NEWLINE> sa = sum ( a ) <NEWLINE> af = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> af [ i ] += 1 <NEWLINE> <DEDENT> q = Ii ( ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = Mi ( ) <NEWLINE> sa = sa + ( c - b ) * af [ b ] <NEWLINE> af [ c ] += af [ b ] <NEWLINE> af [ b ] = 0 ; <NEWLINE> print ( sa ) <NEWLINE> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> from itertools import combinations_with_replacement as cwr <NEWLINE> AList = list ( cwr ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <NL> <NL> maxPoint = 0 <NEWLINE> for A in AList : <NEWLINE> <INDENT> point = 0 <NEWLINE> for abc in abcd : <NEWLINE> <INDENT> a = abc [ 0 ] <NEWLINE> b = abc [ 1 ] <NEWLINE> c = abc [ 2 ] <NEWLINE> d = abc [ 3 ] <NEWLINE> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> point += d <NEWLINE> <DEDENT> <DEDENT> if point > maxPoint : <NEWLINE> <INDENT> maxPoint = point <NEWLINE> <DEDENT> <DEDENT> print ( maxPoint ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> nlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 0 <NEWLINE> <NL> <COMMENT> <NL> mrest = k <NEWLINE> <NL> <COMMENT> <NL> mcount = m <NEWLINE> <NL> <COMMENT> <NL> mtime = sum ( mlist ) <NEWLINE> <NL> <COMMENT> <NL> ntime = 0 <NEWLINE> <NL> <COMMENT> <NL> for ncount in range ( len ( nlist ) + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ncount > 0 : <NEWLINE> <INDENT> mrest -= nlist [ ncount - 1 ] <NEWLINE> ntime += nlist [ ncount - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> if ntime > k : <NEWLINE> <INDENT> break ; <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> while mcount > 0 and mtime > mrest : <NEWLINE> <INDENT> mcount -= 1 <NEWLINE> mtime -= mlist [ mcount ] <NEWLINE> <COMMENT> <NL> <DEDENT> result = max ( result , ncount + mcount ) <NEWLINE> <COMMENT> <NL> if ncount == n : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> d = { } <NEWLINE> k1 = [ 0 for i in range ( 10 ) ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if k1 [ int ( S [ i ] ) ] != 0 : continue <NEWLINE> k1 [ int ( S [ i ] ) ] += 1 <NEWLINE> k2 = [ 0 for i in range ( 10 ) ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if k2 [ int ( S [ j ] ) ] != 0 : continue <NEWLINE> k2 [ int ( S [ j ] ) ] += 1 <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> st = <STRING> . join ( [ S [ i ] , S [ j ] , S [ k ] ] ) <NEWLINE> d [ st ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( d ) ) <NEWLINE>
N , A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sx = sum ( x ) <NEWLINE> dp = [ [ 0 ] * ( N + 1 ) for i in range ( sx + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dp_sub = [ [ 0 ] * ( N + 1 ) for j in range ( sx + 1 ) ] <COMMENT> <NEWLINE> for j in range ( sx + 1 ) : <NEWLINE> <INDENT> for k in range ( N + 1 ) : <NEWLINE> <INDENT> if dp [ j ] [ k ] != 0 : <NEWLINE> <INDENT> dp_sub [ j + x [ i ] ] [ k + 1 ] = dp [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( sx + 1 ) : <NEWLINE> <INDENT> for k in range ( N + 1 ) : <NEWLINE> <INDENT> dp [ j ] [ k ] += dp_sub [ j ] [ k ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> for i in range ( min ( sx // A , N ) ) : <NEWLINE> <INDENT> cnt += dp [ A * ( i + 1 ) ] [ i + 1 ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if ( i . isupper ( ) ) : <NEWLINE> <INDENT> print ( i . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = int ( 1 ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def coin_change ( coins , payment ) : <NEWLINE> <INDENT> T = [ 0 ] + [ 50001 ] * payment <NEWLINE> for c in coins : <NEWLINE> <INDENT> for i in range ( c , payment + 1 ) : <NEWLINE> <INDENT> T [ i ] = min ( T [ i ] , T [ i - c ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> return T [ payment ] <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = coin_change ( c , n ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def dfs ( v , parent , odd ) : <NEWLINE> <INDENT> hi = INF <NEWLINE> lo = - INF <NEWLINE> if fixed [ v ] != INF : <NEWLINE> <INDENT> if odd_even [ v ] != odd : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> hi = lo = fixed [ v ] <NEWLINE> <DEDENT> for u in links [ v ] : <NEWLINE> <INDENT> if u == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> chi , clo = dfs ( u , v , odd ^ 1 ) <NEWLINE> if hi < clo or chi < lo : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> hi = min ( hi , chi ) <NEWLINE> lo = max ( lo , clo ) <NEWLINE> <DEDENT> upper [ v ] = hi <NEWLINE> lower [ v ] = lo <NEWLINE> return hi + 1 , lo - 1 <NEWLINE> <NL> <NL> <DEDENT> def fill ( v , parent , pp ) : <NEWLINE> <INDENT> if pp + 1 > upper [ v ] : <NEWLINE> <INDENT> assert pp - 1 >= lower [ v ] <NEWLINE> vp = fixed [ v ] = pp - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vp = fixed [ v ] = pp + 1 <NEWLINE> <DEDENT> for u in links [ v ] : <NEWLINE> <INDENT> if u == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> fill ( u , v , vp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> inp = list ( map ( int , sys . stdin . buffer . read ( ) . split ( ) ) ) <NEWLINE> n = inp [ 0 ] <NEWLINE> links = [ set ( ) for _ in range ( n ) ] <NEWLINE> for a , b in zip ( inp [ 1 : 2 * n - 1 : 2 ] , inp [ 2 : 2 * n - 1 : 2 ] ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> links [ a ] . add ( b ) <NEWLINE> links [ b ] . add ( a ) <NEWLINE> <DEDENT> INF = 10 ** 9 <NEWLINE> k = inp [ 2 * n - 1 ] <NEWLINE> fixed = [ INF ] * n <NEWLINE> odd_even = { } <NEWLINE> fixed_v = 0 <NEWLINE> for v , p in zip ( inp [ 2 * n : : 2 ] , inp [ 2 * n + 1 : : 2 ] ) : <NEWLINE> <INDENT> v -= 1 <NEWLINE> fixed [ v ] = p <NEWLINE> odd_even [ v ] = p % 2 <NEWLINE> fixed_v = v <NEWLINE> <NL> <DEDENT> lower = [ - INF ] * n <NEWLINE> upper = [ INF ] * n <NEWLINE> dfs ( fixed_v , - 1 , odd_even [ fixed_v ] ) <NEWLINE> fill ( fixed_v , - 1 , fixed [ fixed_v ] + 1 ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , fixed ) ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> MOD = 1000000007 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n_li = list ( range ( n + 1 ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> while ( k <= n + 1 ) : <NEWLINE> <INDENT> p = ( k - 1 ) * k / 2 <NEWLINE> q = ( ( n + n - k + 1 ) * k ) / 2 <NEWLINE> <NL> ans += q - p + 1 <NEWLINE> ans %= MOD <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> data = list ( input ( ) ) <NEWLINE> for i , _str in enumerate ( data ) : <NEWLINE> <INDENT> if _str == <STRING> : <NEWLINE> <INDENT> data [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> . join ( data ) <NEWLINE> print ( ans ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , k = I ( ) <NEWLINE> a = l ( ) <NEWLINE> x = a . index ( 1 ) <NEWLINE> if n == k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( 1 + math . ceil ( ( n - k ) / ( k - 1 ) ) ) <NEWLINE>
<COMMENT> <NL> S = str ( input ( ) ) [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> <COMMENT> <NL> N = len ( S ) <NEWLINE> <COMMENT> <NL> dp = [ 0 ] * ( N ) <NEWLINE> dp [ 0 ] = int ( S [ 0 ] ) <NEWLINE> times = 10 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] + times * int ( S [ i + 1 ] ) <NEWLINE> dp [ i + 1 ] %= 2019 <NEWLINE> times *= 10 <NEWLINE> times %= 2019 <NEWLINE> <NL> <DEDENT> T = Counter ( dp ) <NEWLINE> <NL> answer = T [ 0 ] <NEWLINE> <NL> for t in T . values ( ) : <NEWLINE> <INDENT> answer += t * ( t - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
def common_multiple ( x , y ) : <NEWLINE> <INDENT> for i in range ( 2 , min ( x , y ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 or y % i == 0 : <NEWLINE> <INDENT> return common_multiple ( x // i if x % i == 0 else x , y // i if y % i == 0 else y ) * i <NEWLINE> <DEDENT> <DEDENT> return x * y <NEWLINE> <NL> <DEDENT> a = input ( ) . split ( <STRING> ) <NEWLINE> A , B , C , D = int ( a [ 0 ] ) - 1 , int ( a [ 1 ] ) , int ( a [ 2 ] ) , int ( a [ 3 ] ) <NEWLINE> <NL> M = common_multiple ( C , D ) <NEWLINE> B0 = B // C + B // D - B // M <NEWLINE> A0 = A // C + A // D - A // M <NEWLINE> print ( B - A - B0 + A0 ) <NEWLINE>
import sys , math , collections , itertools , bisect <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> process = [ ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> tmp = A . pop ( ) <NEWLINE> y = A . pop ( ) <NEWLINE> A . append ( tmp ) <NEWLINE> if y >= 0 : <NEWLINE> <INDENT> process . append ( [ A [ 0 ] , y ] ) <NEWLINE> A [ 0 ] -= y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> process . append ( [ A [ - 1 ] , y ] ) <NEWLINE> A [ - 1 ] -= y <NEWLINE> <DEDENT> <DEDENT> process . append ( [ A [ - 1 ] , A [ 0 ] ] ) <NEWLINE> print ( A [ - 1 ] - A [ 0 ] ) <NEWLINE> for pro in process : <NEWLINE> <INDENT> print ( * pro ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> dec = { } <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if gcd ( a , b ) not in dec : <NEWLINE> <INDENT> dec [ gcd ( a , b ) ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dec [ gcd ( a , b ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for key in dec . keys ( ) : <NEWLINE> <INDENT> ans += gcd ( c , key ) * dec [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( 999983 ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> MX = 10 ** 18 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > MX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n > 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = set ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = set ( ) <NEWLINE> <NL> <DEDENT> if x not in p : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = x - 1 <NEWLINE> j = x + 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if i not in p and j not in p : <NEWLINE> <INDENT> ans = min ( i , j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if i not in p : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> elif j not in p : <NEWLINE> <INDENT> ans = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> i -= 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : return 1 <NEWLINE> if x % 2 == 0 : return 0 <NEWLINE> for i in range ( 3 , int ( x ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> c += is_prime ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
<STRING> <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ [ a , i ] for a , i in zip ( map ( int , input ( ) . split ( ) ) , range ( N ) ) ] <NEWLINE> A . sort ( key = lambda a : a [ 0 ] , reverse = True ) <NEWLINE> <NL> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> a , l = A [ i ] <NEWLINE> for x in range ( 0 , i + 1 ) : <NEWLINE> <INDENT> y = i - x <COMMENT> <NEWLINE> dp [ x + 1 ] [ y ] = max ( dp [ x + 1 ] [ y ] , dp [ x ] [ y ] + a * abs ( l - x ) ) <NEWLINE> dp [ x ] [ y + 1 ] = max ( dp [ x ] [ y + 1 ] , dp [ x ] [ y ] + a * abs ( l - ( N - y - 1 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp [ N - i ] [ i ] for i in range ( N + 1 ) ) ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
<COMMENT> <NL> <NL> import sys , math , os , struct <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def valid ( k , a ) : <NEWLINE> <INDENT> if k % 15 == 0 : <NEWLINE> <INDENT> return a == <STRING> <NEWLINE> <DEDENT> elif k % 3 == 0 : <NEWLINE> <INDENT> return a == <STRING> <NEWLINE> <DEDENT> elif k % 5 == 0 : <NEWLINE> <INDENT> return a == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a == str ( k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def fizz_buzz ( m , n , A ) : <NEWLINE> <INDENT> players = list ( range ( 1 , m + 1 ) ) <NEWLINE> p = 0 <NEWLINE> k = 0 <NEWLINE> while len ( A ) > 0 : <NEWLINE> <INDENT> k += 1 <NEWLINE> a = A . pop ( 0 ) <NEWLINE> if valid ( k , a ) : <NEWLINE> <INDENT> p = ( p + 1 ) % m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( players ) == 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> return <NEWLINE> <DEDENT> players . pop ( p ) <NEWLINE> if len ( players ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m -= 1 <NEWLINE> p %= m <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( p ) for p in players ] ) ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m , n = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = [ input ( ) . strip ( ) for _ in range ( n ) ] <NEWLINE> fizz_buzz ( m , n , A ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * H , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D = [ float ( <STRING> ) ] * N <NEWLINE> D [ 0 ] = 0 <NEWLINE> D [ 1 ] = abs ( H [ 1 ] - H [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> D [ i ] = min ( abs ( H [ i ] - H [ k ] ) + D [ k ] for k in range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( D [ - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> XY = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> dXY = Counter ( [ ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> dXY += Counter ( [ str ( XY [ i ] [ 0 ] - XY [ j ] [ 0 ] ) + <STRING> + str ( XY [ i ] [ 1 ] - XY [ j ] [ 1 ] ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - dXY . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for x in ls : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> print ( int ( A * N / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) / B ) ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> exist = [ False ] * 101 <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> exist [ p [ i ] ] = True <NEWLINE> <NL> <DEDENT> for i in range ( 200 ) : <NEWLINE> <INDENT> if X - i <= 0 : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if not exist [ X - i ] : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if X + i > 100 : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if not exist [ X + i ] : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n % 2 == 0 and n >= 4 : <NEWLINE> <INDENT> dp = [ [ 0 , 0 ] for i in range ( n ) ] <NEWLINE> dp [ 0 ] [ 0 ] = a [ 0 ] <NEWLINE> dp [ 1 ] [ 1 ] = a [ 1 ] <NEWLINE> dp [ 2 ] [ 0 ] = a [ 0 ] + a [ 2 ] <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 2 ] [ 0 ] + a [ i ] <NEWLINE> dp [ i ] [ 1 ] = max ( dp [ i - 3 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + a [ i ] <NEWLINE> <DEDENT> print ( max ( dp [ n - 2 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT> elif n % 2 != 0 and n >= 5 : <NEWLINE> <INDENT> dp = [ [ 0 , 0 , 0 ] for i in range ( n ) ] <NEWLINE> dp [ 0 ] [ 0 ] = a [ 0 ] <NEWLINE> dp [ 1 ] [ 1 ] = a [ 1 ] <NEWLINE> dp [ 2 ] [ 0 ] = a [ 0 ] + a [ 2 ] <NEWLINE> dp [ 2 ] [ 2 ] = a [ 2 ] <NEWLINE> dp [ 3 ] [ 1 ] = a [ 1 ] + a [ 3 ] <NEWLINE> dp [ 3 ] [ 2 ] = a [ 0 ] + a [ 3 ] <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = dp [ i - 2 ] [ 0 ] + a [ i ] <NEWLINE> dp [ i ] [ 1 ] = max ( dp [ i - 3 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + a [ i ] <NEWLINE> dp [ i ] [ 2 ] = max ( dp [ i - 4 ] [ 0 ] , dp [ i - 3 ] [ 1 ] , dp [ i - 2 ] [ 2 ] ) + a [ i ] <NEWLINE> <DEDENT> print ( max ( dp [ n - 3 ] [ 0 ] , dp [ n - 2 ] [ 1 ] , dp [ n - 1 ] [ 2 ] ) ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( max ( a [ 0 ] , a [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) ) <NEWLINE> <DEDENT>
from collections import Counter as Ct <NEWLINE> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> dic = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = STR ( ) <NEWLINE> dic . append ( s ) <NEWLINE> <DEDENT> ctd = Ct ( dic ) <NEWLINE> ctm = max ( ctd . values ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for key , value in ctd . items ( ) : <NEWLINE> <INDENT> if value == ctm : <NEWLINE> <INDENT> ans . append ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sorted ( ans ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , k , * P = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> p = [ ( i + 1 ) / 2 for i in P ] <NEWLINE> c = sum ( p [ : k ] ) <NEWLINE> ans = c <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> c = c + p [ i + k ] - p [ i ] <NEWLINE> ans = max ( c , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def partition ( n , a , p , r ) : <NEWLINE> <INDENT> x = a [ r ] <NEWLINE> i = p - 1 <NEWLINE> <NL> for j in range ( p , r ) : <NEWLINE> <INDENT> if x >= a [ j ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> a [ i + 1 ] , a [ r ] = a [ r ] , a [ i + 1 ] <NEWLINE> <NL> for k in range ( i + 1 ) : <NEWLINE> <INDENT> print ( a [ k ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( x ) , end = <STRING> ) <NEWLINE> <NL> for k in range ( i + 2 , r ) : <NEWLINE> <INDENT> print ( a [ k ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( a [ r ] ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> partition ( n , a , 0 , len ( a ) - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> dp = [ INF for i in range ( n ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( i , k ) + 1 ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = x1 - 1 , y1 - 1 , x2 - 1 , y2 - 1 <NEWLINE> <NL> m = [ [ - 1 ] * w for _ in range ( h ) ] <NEWLINE> for hh in range ( h ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> for ww , cc in enumerate ( c ) : <NEWLINE> <INDENT> if cc == <STRING> : <NEWLINE> <INDENT> m [ hh ] [ ww ] = h * w <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> from collections import deque <NEWLINE> q = deque ( ) <NEWLINE> <NL> q . append ( ( 0 , x1 , y1 ) ) <NEWLINE> while q : <NEWLINE> <INDENT> s , x , y = q . popleft ( ) <NEWLINE> s1 = s + 1 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> xx , yy = x + i , y <NEWLINE> if xx >= h or m [ xx ] [ yy ] <= s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m [ xx ] [ yy ] == s1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if xx == x2 and yy == y2 : <NEWLINE> <INDENT> print ( s1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> m [ xx ] [ yy ] = s1 <NEWLINE> q . append ( ( s1 , xx , yy ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> xx , yy = x - i , y <NEWLINE> if xx < 0 or m [ xx ] [ yy ] <= s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m [ xx ] [ yy ] == s1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if xx == x2 and yy == y2 : <NEWLINE> <INDENT> print ( s1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> m [ xx ] [ yy ] = s1 <NEWLINE> q . append ( ( s1 , xx , yy ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> xx , yy = x , y + i <NEWLINE> if yy >= w or m [ xx ] [ yy ] <= s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m [ xx ] [ yy ] == s1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if xx == x2 and yy == y2 : <NEWLINE> <INDENT> print ( s1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> m [ xx ] [ yy ] = s1 <NEWLINE> q . append ( ( s1 , xx , yy ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> xx , yy = x , y - i <NEWLINE> if yy < 0 or m [ xx ] [ yy ] <= s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m [ xx ] [ yy ] == s1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if xx == x2 and yy == y2 : <NEWLINE> <INDENT> print ( s1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> m [ xx ] [ yy ] = s1 <NEWLINE> q . append ( ( s1 , xx , yy ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> temp1 = math . floor ( A * 1 / B ) - A * math . floor ( 1 / B ) <NEWLINE> temp2 = math . floor ( A * N / B ) - A * math . floor ( N / B ) <NEWLINE> ans = max ( temp1 , temp2 ) <NEWLINE> <NL> <DEDENT> if N >= B : <NEWLINE> <INDENT> temp1 = math . floor ( A * 1 / B ) - A * math . floor ( 1 / B ) <NEWLINE> temp2 = math . floor ( A * ( B - 1 ) / B ) - A * math . floor ( ( B - 1 ) / B ) <NEWLINE> ans = max ( temp1 , temp2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> COUNT = { } <NEWLINE> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> whole = pow ( ( K // i ) , N , MOD ) <NEWLINE> <NL> c = 2 <NEWLINE> while i * c <= K : <NEWLINE> <INDENT> whole -= COUNT [ i * c ] <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> COUNT [ i ] = whole % MOD <NEWLINE> <NL> <DEDENT> SUM = 0 <NEWLINE> for k , v in COUNT . items ( ) : <NEWLINE> <INDENT> SUM += k * v <NEWLINE> SUM %= MOD <NEWLINE> <NL> <DEDENT> print ( SUM ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if N < B - 1 : <NEWLINE> <INDENT> ans = math . floor ( A * N / B ) - A * math . floor ( N / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = B - 1 <NEWLINE> cnt = 1 <NEWLINE> while c <= N : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t = math . floor ( A * c / B ) - A * math . floor ( c / B ) <NEWLINE> ans = max ( ans , t ) <NEWLINE> c += B <NEWLINE> if B < cnt : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> list = input ( ) . split ( <STRING> ) <NEWLINE> list_int = [ ] <NEWLINE> for i in list : <NEWLINE> <INDENT> list_int . append ( int ( i ) ) <NEWLINE> <DEDENT> k = [ 0 ] * n <COMMENT> <NEWLINE> for i in list_int : <NEWLINE> <INDENT> k [ i - 1 ] = k [ i - 1 ] + 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( k [ j ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> <NL> d = int ( input ( ) . rstrip ( ) ) <NEWLINE> c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( d ) ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> now = [ s [ i ] [ j ] - ( c [ j ] * ( i - last [ j ] ) ) for j in range ( 26 ) ] <NEWLINE> <COMMENT> <NL> kouho = now . index ( max ( now ) ) + 1 <NEWLINE> print ( kouho ) <NEWLINE> last [ kouho - 1 ] = i <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> mod = 1000000007 <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ab = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = math . gcd ( a , b ) <NEWLINE> a //= gcd <NEWLINE> b //= gcd <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> <DEDENT> ab . setdefault ( ( a , b ) , 0 ) <NEWLINE> ab [ ( a , b ) ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> pairs = [ ] <NEWLINE> s = set ( ab . keys ( ) ) <NEWLINE> for i in ab . keys ( ) : <NEWLINE> <INDENT> a = i [ 0 ] ; b = i [ 1 ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> ans = ab [ ( 0 , 0 ) ] <NEWLINE> n -= ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( - b , a ) in s : <NEWLINE> <INDENT> pairs . append ( [ ab [ ( a , b ) ] , ab [ ( - b , a ) ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> select = 1 <NEWLINE> for pair in pairs : <NEWLINE> <INDENT> select *= ( pow ( 2 , pair [ 0 ] , mod ) + pow ( 2 , pair [ 1 ] , mod ) - 1 ) <NEWLINE> n -= ( pair [ 0 ] + pair [ 1 ] ) <NEWLINE> <DEDENT> all_ans = ( pow ( 2 , n , mod ) * select ) % mod + ans - 1 <NEWLINE> all_ans %= mod <NEWLINE> print ( all_ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l , r = N // 2 - 1 , N // 2 <NEWLINE> sort_x = sorted ( X ) <NEWLINE> lx , rx = sort_x [ l ] , sort_x [ r ] <NEWLINE> <NL> if lx == rx : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( lx ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for ind in range ( N ) : <NEWLINE> <INDENT> target = X [ ind ] <NEWLINE> if target <= lx : <NEWLINE> <INDENT> print ( rx ) <NEWLINE> <DEDENT> if target >= rx : <NEWLINE> <INDENT> print ( lx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> from heapq import heapify , heappush <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> def hl ( ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> heapify ( ret ) <NEWLINE> return ret <NEWLINE> <DEDENT> d = defaultdict ( hl ) <NEWLINE> for x in s : <NEWLINE> <INDENT> heappush ( d [ x [ 0 ] ] , - x [ 1 ] ) <NEWLINE> heappush ( d [ x [ 1 ] ] , - x [ 0 ] ) <NEWLINE> <DEDENT> for e in d [ 1 ] : <NEWLINE> <INDENT> if d [ - e ] [ 0 ] == - n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> ans_list = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> ans_list [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans_list [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> now = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> ans = [ now ] <NEWLINE> <NL> for n in range ( N - 1 ) : <NEWLINE> <INDENT> now = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> if now > ans [ 0 ] : <NEWLINE> <INDENT> ans [ 0 ] = now <NEWLINE> <DEDENT> elif ans [ - 1 ] >= now : <NEWLINE> <INDENT> ans . append ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> left = 0 <COMMENT> <NEWLINE> right = len ( ans ) - 1 <COMMENT> <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> if now > ans [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> ans [ right ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = 0 <NEWLINE> for x in ( range ( 1 , b + 1 , b - 2 ) if b <= n else range ( 1 , n + 1 , n - 1 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> calc = a * x // b - a * ( x // b ) <NEWLINE> if calc > tmp : <NEWLINE> <INDENT> tmp = calc <NEWLINE> <NL> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> h , w = [ int ( val ) for val in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> if 0 == h and 0 == w : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> mn = 10 ** 10 <NEWLINE> cal = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <NL> <INDENT> cal = ( ( i % 2019 ) * ( j % 2019 ) ) % 2019 <NEWLINE> if cal < mn : <NEWLINE> <INDENT> mn = cal <NEWLINE> <DEDENT> if cal == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ans == 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count == n - 2 : <NEWLINE> <INDENT> ans += i <NEWLINE> break <NEWLINE> <DEDENT> elif count == n - 3 : <NEWLINE> <INDENT> ans += i * 2 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i * 2 <NEWLINE> count += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if n == 2 : <NEWLINE> <INDENT> ans = max ( a ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> s = input ( ) <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> base = 1 <NEWLINE> value = 0 <NEWLINE> for c in map ( int , reversed ( s ) ) : <NEWLINE> <INDENT> value += ( c * base ) % 2019 <NEWLINE> base = ( base * 10 ) % 2019 <NEWLINE> <COMMENT> <NL> mods [ value % 2019 ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ mod * ( mod - 1 ) // 2 for mod in mods ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for m in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = n // m <NEWLINE> s += k * ( k + 1 ) * m // 2 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
k , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> print ( len ( set ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> min_p = n <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> if i <= min_p : <NEWLINE> <INDENT> min_p = i <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> MOD = 2019 <NEWLINE> count = [ 0 ] * MOD <NEWLINE> r = 0 <NEWLINE> t = 1 <NEWLINE> for i in reversed ( S ) : <NEWLINE> <INDENT> r += int ( i ) * t <NEWLINE> r %= MOD <NEWLINE> t *= 10 <NEWLINE> t %= MOD <NEWLINE> count [ r ] += 1 <NEWLINE> <NL> <DEDENT> count [ 0 ] += 1 <NEWLINE> print ( int ( sum ( i * ( i - 1 ) / 2 for i in count ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> table = [ 0 for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> a . sort ( ) <NEWLINE> a . append ( 10 ** 7 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> el = a [ i ] <NEWLINE> if table [ el ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if el != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> idx = el <NEWLINE> while idx <= 10 ** 6 : <NEWLINE> <INDENT> table [ idx ] += 1 <NEWLINE> idx += el <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> res = <STRING> . join ( [ str ( x ) for x in range ( 1 , num + 1 ) if x % 3 == 0 or str ( x ) . find ( <STRING> ) != - 1 ] ) <NEWLINE> print ( <STRING> . format ( res ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> ins = lambda : input ( ) . rstrip ( ) <NEWLINE> ini = lambda : int ( input ( ) . rstrip ( ) ) <NEWLINE> inm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> out = lambda x : print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <NL> n = ini ( ) <NEWLINE> a = inl ( ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> out ( ans ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> <NL> <NL> def euclidean ( num_list : list ) : <NEWLINE> <INDENT> a , b = sorted ( num_list ) <NEWLINE> while b % a != 0 : <NEWLINE> <INDENT> redi = b % a <NEWLINE> b = a <NEWLINE> a = redi <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> k_range = list ( range ( 1 , K + 1 ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for comb in combinations_with_replacement ( k_range , 3 ) : <NEWLINE> <INDENT> min_abc = min ( comb ) <NEWLINE> gcd = euclidean ( comb [ 0 : 2 ] ) <NEWLINE> gcd = euclidean ( [ gcd , comb [ 2 ] ] ) <NEWLINE> if comb [ 0 ] == comb [ 1 ] and comb [ 1 ] == comb [ 2 ] : <NEWLINE> <INDENT> coef = 1 <NEWLINE> <DEDENT> elif ( comb [ 0 ] != comb [ 1 ] and comb [ 1 ] != comb [ 2 ] ) and comb [ 2 ] != comb [ 0 ] : <NEWLINE> <INDENT> coef = 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> coef = 3 <NEWLINE> <DEDENT> result += gcd * coef <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> nlst = [ 1 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = min ( H [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> if c == H [ a - 1 ] : <NEWLINE> <INDENT> nlst [ a - 1 ] = 0 <NEWLINE> <DEDENT> if c == H [ b - 1 ] : <NEWLINE> <INDENT> nlst [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( nlst ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> xyh = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xyh . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> xyh_sorted = sorted ( xyh , key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> answer = [ 0 , 0 , 0 ] <NEWLINE> for cy in range ( 0 , 101 ) : <NEWLINE> <INDENT> for cx in range ( 0 , 101 ) : <NEWLINE> <INDENT> H = xyh_sorted [ 0 ] [ 2 ] + abs ( xyh_sorted [ 0 ] [ 0 ] - cx ) + abs ( xyh_sorted [ 0 ] [ 1 ] - cy ) <NEWLINE> flag = True <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> h2 = max ( H - abs ( xyh_sorted [ i ] [ 0 ] - cx ) - abs ( xyh_sorted [ i ] [ 1 ] - cy ) , 0 ) <NEWLINE> if h2 != xyh_sorted [ i ] [ 2 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> answer = [ cx , cy , H ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> answerString = str ( answer [ 0 ] ) + <STRING> + str ( answer [ 1 ] ) + <STRING> + str ( answer [ 2 ] ) <NEWLINE> print ( answerString ) <NEWLINE>
import numpy <NEWLINE> import math <NEWLINE> <NL> L = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> for j in range ( L ) : <NEWLINE> <INDENT> t = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( L ) : <NEWLINE> <INDENT> ans += math . gcd ( t , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> k = [ - 1 , 0 , 1 ] <NEWLINE> def search ( x , y , m ) : <NEWLINE> <INDENT> if x < 0 or x >= len ( m [ 0 ] ) or y < 0 or y >= len ( m ) : return <NEWLINE> if m [ y ] [ x ] == 0 : return <NEWLINE> m [ y ] [ x ] = 0 <NEWLINE> for i in k : <NEWLINE> <INDENT> for j in k : <NEWLINE> <INDENT> search ( x + i , y + j , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> c = 0 <NEWLINE> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 : break <NEWLINE> m = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if m [ i ] [ j ] == 1 : <NEWLINE> <INDENT> search ( j , i , m ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n_minus = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> n_minus += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> elif n_minus == N and K % 2 == 1 : <NEWLINE> <INDENT> A = sorted ( A , key = lambda x : 10 ** 9 if x == 0 else abs ( x ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> A = sorted ( A , key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> padding = None <NEWLINE> plus = deque ( ) <NEWLINE> minus = deque ( ) <NEWLINE> buf_p = deque ( ) <NEWLINE> buf_m = deque ( ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> if padding is None and K % 2 == 1 : <NEWLINE> <INDENT> padding = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> buf_p . append ( a ) <NEWLINE> <NL> if len ( buf_p ) == 2 : <NEWLINE> <INDENT> plus . append ( buf_p . popleft ( ) * buf_p . popleft ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> buf_m . append ( a ) <NEWLINE> <NL> if len ( buf_m ) == 2 : <NEWLINE> <INDENT> minus . append ( buf_m . popleft ( ) * buf_m . popleft ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> if padding is not None : <NEWLINE> <INDENT> ans *= padding <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> for _ in range ( K // 2 ) : <NEWLINE> <INDENT> if len ( plus ) == 0 : <NEWLINE> <INDENT> ans *= minus . popleft ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> elif len ( minus ) == 0 : <NEWLINE> <INDENT> ans *= plus . popleft ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> elif plus [ 0 ] >= minus [ 0 ] : <NEWLINE> <INDENT> ans *= plus . popleft ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= minus . popleft ( ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> scores = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answers = [ ] <NEWLINE> <NL> prev_score = scores [ 0 ] <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if prev_score < scores [ i ] : <NEWLINE> <INDENT> answers . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answers . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> prev_score = scores [ i - ( k - 1 ) ] <NEWLINE> <NL> <DEDENT> for answer in answers : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in L : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> <NL> for n in L : <NEWLINE> <INDENT> res *= n <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( N ) ] <NEWLINE> ans = [ None ] * N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> def dfs ( v , parent , c ) : <NEWLINE> <INDENT> ans [ v ] = c <NEWLINE> for u , w in adj [ v ] : <NEWLINE> <INDENT> if u == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( u , v , 1 - c ) if w & 1 else dfs ( u , v , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ u - 1 ] . append ( ( v - 1 , w ) ) <NEWLINE> adj [ v - 1 ] . append ( ( u - 1 , w ) ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 , 1 ) <NEWLINE> [ print ( v ) for v in ans ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <NL> <DEDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> <COMMENT> <NL> count += K * ( K + 1 ) / 2 <NEWLINE> <NL> <COMMENT> <NL> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K + 1 ) : <NEWLINE> <INDENT> count += gcd ( b , a ) * 6 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for a in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <INDENT> ab = gcd ( b , a ) <NEWLINE> <NL> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> count += gcd ( c , ab ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( count ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if i * j <= n - 1 : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> count += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> def s0 ( ) : return input ( ) <NEWLINE> def s1 ( ) : return input ( ) . split ( ) <NEWLINE> def s2 ( n ) : return [ input ( ) for x in range ( n ) ] <NEWLINE> def s3 ( n ) : return [ input ( ) . split ( ) for _ in range ( n ) ] <NEWLINE> def s4 ( n ) : return [ [ x for x in s ] for s in s2 ( n ) ] <NEWLINE> def n0 ( ) : return int ( input ( ) ) <NEWLINE> def n1 ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def n2 ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def n3 ( n ) : return [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> def t3 ( n ) : return [ tuple ( int ( x ) for x in input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> def p0 ( b , yes = <STRING> , no = <STRING> ) : print ( yes if b else no ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter , deque , defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = n0 ( ) <NEWLINE> A = n1 ( ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> m = A [ - 1 ] <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> d2 = defaultdict ( int ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> d2 [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if d [ a ] == 0 : <NEWLINE> <INDENT> if d2 [ a ] <= 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> i = a <NEWLINE> while i <= m : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> i += a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> allsum = 0 <NEWLINE> sums_list = deque ( ) <NEWLINE> sums = 0 <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> sums = ( sums + A [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> sums_list . appendleft ( sums ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> allsum = ( allsum + A [ i ] * sums_list [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( allsum ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> went = [ 0 ] * N <NEWLINE> went [ 0 ] = 1 <NEWLINE> Flag = True <NEWLINE> check = [ 0 ] <NEWLINE> cnt = 1 <NEWLINE> now = 0 <NEWLINE> while Flag and ( cnt <= K + 1 ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> if went [ now ] == 1 : <NEWLINE> <INDENT> ind = check . index ( now ) <NEWLINE> if ind == 0 : <NEWLINE> <INDENT> cnt = len ( check ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = len ( check ) - ind <NEWLINE> <NL> <DEDENT> Flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check . append ( now ) <NEWLINE> went [ now ] = 1 <NEWLINE> cnt += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( check ) > K : <NEWLINE> <INDENT> print ( check [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ind == 0 : <NEWLINE> <INDENT> K = K % cnt <NEWLINE> print ( check [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind -= 1 <NEWLINE> K = ( K - ind - 1 ) % cnt <NEWLINE> print ( check [ ind + K + 1 ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> str_list = list ( x ) <NEWLINE> dict_ = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <DEDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <INDENT> } <NEWLINE> <NL> <DEDENT> for a in str_list : <NEWLINE> <INDENT> print ( dict_ . get ( a ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ i ] < A [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> k = N // i <NEWLINE> ans += ( i + i * k ) * k // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> S = readline ( ) . rstrip ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> numlist = [ [ ] for i in range ( 10 ) ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> numlist [ int ( S [ i ] ) ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> import bisect <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> target = str ( i ) . zfill ( 3 ) <NEWLINE> now = 0 <NEWLINE> for j in range ( len ( target ) ) : <NEWLINE> <INDENT> tar = int ( target [ j ] ) <NEWLINE> pos = bisect . bisect_left ( numlist [ tar ] , now ) <NEWLINE> if pos >= len ( numlist [ tar ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> now = numlist [ tar ] [ pos ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import math <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = { } <NEWLINE> Empty = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> g = math . gcd ( x , y ) <NEWLINE> if g == 0 : <NEWLINE> <INDENT> Empty += 1 <NEWLINE> continue <NEWLINE> <DEDENT> x , y = x // g , y // g <NEWLINE> if y < 0 or ( y == 0 and x < 0 ) : <NEWLINE> <INDENT> y = - y <NEWLINE> x = - x <NEWLINE> <DEDENT> if ( x , y ) in As : <NEWLINE> <INDENT> As [ ( x , y ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> As [ ( x , y ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for ( x , y ) , num in As . items ( ) : <NEWLINE> <INDENT> if ( - y , x ) in As : <NEWLINE> <INDENT> ans = ( ans * ( pow ( 2 , num , mod ) + pow ( 2 , As [ ( - y , x ) ] , mod ) - 1 ) ) % mod <NEWLINE> <DEDENT> elif not ( y , - x ) in As : <NEWLINE> <INDENT> ans = ( ans * pow ( 2 , num , mod ) ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( ans - 1 + Empty ) % mod ) <NEWLINE>
li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> a = li [ 0 ] * li [ 2 ] <NEWLINE> b = li [ 0 ] * li [ 3 ] <NEWLINE> c = li [ 1 ] * li [ 2 ] <NEWLINE> d = li [ 1 ] * li [ 3 ] <NEWLINE> ans . append ( a ) <NEWLINE> ans . append ( b ) <NEWLINE> ans . append ( c ) <NEWLINE> ans . append ( d ) <NEWLINE> <NL> print ( max ( ans ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x . strip ( ) ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> ans = str ( <STRING> ) <NEWLINE> for i in enumerate ( a ) : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> b . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> for i in b : <NEWLINE> <INDENT> print ( i [ 0 ] + 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = input ( ) <NEWLINE> S = 0 <NEWLINE> mod_count = [ 0 ] <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> for X in N [ : : - 1 ] : <NEWLINE> <INDENT> S = int ( X ) * pow ( 10 , i , 2019 ) % 2019 <NEWLINE> S = mod_count [ i ] + S <NEWLINE> mod_count . append ( S % 2019 ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> c = Counter ( mod_count ) <NEWLINE> ans = sum ( Y * ( Y - 1 ) / 2 for Y in c . values ( ) ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * N <NEWLINE> dist [ 0 ] = 0 <NEWLINE> <NL> queue = deque ( [ 0 ] ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> if ( dist [ nv ] != - 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nv ] = v <NEWLINE> queue . append ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in dist [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import itertools <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import numpy as np <NEWLINE> <NL> import heapq <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_i = a <NEWLINE> a_i = 1 <NEWLINE> for i in range ( b , 0 , - 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> print ( b_i - i , b_i ) <NEWLINE> b_i -= 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( a_i , a_i + i ) <NEWLINE> a_i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> <NL> counts = [ 0 for _ in range ( maxA + 1 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> counts [ a ] += 1 <NEWLINE> <NL> <DEDENT> integers = [ 1 for _ in range ( maxA + 1 ) ] <NEWLINE> integers [ 0 ] = 0 <NEWLINE> integers [ 1 ] = 0 <NEWLINE> max_count = 0 <NEWLINE> for i in range ( maxA + 1 ) : <NEWLINE> <INDENT> if integers [ i ] >= 1 : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( i , maxA + 1 , i ) : <NEWLINE> <INDENT> count += counts [ j ] <NEWLINE> integers [ j ] = 0 <NEWLINE> <DEDENT> max_count = max ( max_count , count ) <NEWLINE> <NL> <DEDENT> <DEDENT> if max_count == N : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> elif max_count >= 2 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 3000 ) <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> def comb ( n , k ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return comb ( n - 1 , k - 1 ) * n // k <NEWLINE> <DEDENT> R = N - K <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> A = K - 1 <NEWLINE> B = R - 1 <NEWLINE> if N == K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> for i in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = comb ( A , i - 1 ) <NEWLINE> y = comb ( B , i - 2 ) <NEWLINE> z = comb ( B , i - 1 ) <NEWLINE> w = comb ( B , i ) <NEWLINE> ans = x * ( y + 2 * z + w ) <NEWLINE> print ( ans % MOD ) <NEWLINE> <DEDENT> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> Indata = int ( input ( ) ) <NEWLINE> if Indata == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> print ( <STRING> + str ( i ) + <STRING> + str ( Indata ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tree = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = <STRING> + str ( i + 1 ) + <STRING> + str ( tree [ i ] ) <NEWLINE> if ( i > 0 ) & ( i % 2 == 0 ) : <NEWLINE> <INDENT> s += <STRING> + str ( tree [ i // 2 - 1 ] ) <NEWLINE> <DEDENT> elif ( i > 0 ) & ( i % 2 == 1 ) : <NEWLINE> <INDENT> s += <STRING> + str ( tree [ i // 2 ] ) <NEWLINE> <NL> <DEDENT> if i * 2 + 2 < n : <NEWLINE> <INDENT> s += <STRING> + str ( tree [ i * 2 + 1 ] ) + <STRING> + str ( tree [ i * 2 + 2 ] ) <NEWLINE> <DEDENT> elif i * 2 + 1 < n : <NEWLINE> <INDENT> s += <STRING> + str ( tree [ i * 2 + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( s , <STRING> , sep = <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> i = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if i < N + 1 : <NEWLINE> <INDENT> A [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
def maxHeapify ( A , i , H ) : <NEWLINE> <INDENT> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> <NL> if l <= H and A [ l - 1 ] > A [ i - 1 ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= H and A [ r - 1 ] > A [ largest - 1 ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i - 1 ] , A [ largest - 1 ] = A [ largest - 1 ] , A [ i - 1 ] <NEWLINE> maxHeapify ( A , largest , H ) <NEWLINE> <NL> <DEDENT> <DEDENT> H = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( H // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( A , i , H ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( <STRING> . join ( map ( str , A ) ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n_min = sum ( [ i for i in range ( 0 , k - 1 ) ] ) <NEWLINE> n_max = sum ( [ n - i for i in range ( 0 , k - 1 ) ] ) <NEWLINE> <NL> for i in range ( k - 1 , n + 1 ) : <NEWLINE> <INDENT> n_min += i <NEWLINE> n_max += n - i <NEWLINE> ans += n_max - n_min + 1 <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> NList = [ 0 for i in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> tmp = 0 <NEWLINE> <NL> sqrt_n = int ( math . sqrt ( N ) ) <NEWLINE> <NL> for i in range ( 1 , sqrt_n ) : <NEWLINE> <INDENT> for p in range ( 1 , sqrt_n ) : <NEWLINE> <INDENT> for q in range ( 1 , sqrt_n ) : <NEWLINE> <INDENT> if i ** 2 + p ** 2 + q ** 2 + i * p + p * q + i * q > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NList [ i ** 2 + p ** 2 + q ** 2 + i * p + p * q + i * q - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n_count in NList : <NEWLINE> <INDENT> print ( n_count ) <NEWLINE> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2018 <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( L + 1 , R + 1 ) : <NEWLINE> <INDENT> if ans > ( i * j ) % 2019 : <NEWLINE> <INDENT> ans = ( i * j ) % 2019 <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = min ( N % K , K - ( N % K ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> snuke = [ 0 ] * N <NEWLINE> for n in range ( K ) : <NEWLINE> <INDENT> snack = int ( input ( ) ) <NEWLINE> d_snuke = map ( int , input ( ) . split ( ) ) <NEWLINE> for d in d_snuke : <NEWLINE> <INDENT> snuke [ d - 1 ] = snack <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if snuke [ n ] == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> print ( i , n - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> left_end = 1 + m if m % 2 == 1 else m <NEWLINE> left_start = left_end // 2 <NEWLINE> right_start = left_end + m // 2 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> print ( left_start , left_start + i ) <NEWLINE> left_start -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( right_start , right_start + i ) <NEWLINE> right_start -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> N = str ( N ) <NEWLINE> <NL> if len ( N ) == 2 : <NEWLINE> <INDENT> b = int ( N [ - 2 ] ) <NEWLINE> c = int ( N [ - 1 ] ) <NEWLINE> x = 10 * b + c <NEWLINE> <DEDENT> elif len ( N ) == 1 : <NEWLINE> <INDENT> c = int ( N [ - 1 ] ) <NEWLINE> x = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( N [ - 3 ] ) <NEWLINE> b = int ( N [ - 2 ] ) <NEWLINE> c = int ( N [ - 1 ] ) <NEWLINE> x = 100 * a + 10 * b + c <NEWLINE> <DEDENT> ans = 1000 - x <NEWLINE> if ans == 1000 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = 1 <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> r = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d = min ( abs ( l - r ) , n - abs ( l - r ) ) <NEWLINE> print ( l , r ) <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n % 4 == 0 : <NEWLINE> <INDENT> r = n - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = n <NEWLINE> <DEDENT> rev = False <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d = min ( abs ( l - r ) , n - abs ( l - r ) ) <NEWLINE> if d == n // 2 : <NEWLINE> <INDENT> rev = True <NEWLINE> l += 1 <NEWLINE> print ( l , r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l , r ) <NEWLINE> <DEDENT> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> <DEDENT>
def solve ( A , i , m , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n or m < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return solve ( A , i + 1 , m , n ) or solve ( A , i + 1 , m - A [ i ] , n ) <NEWLINE> <NL> <NL> <DEDENT> import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> A = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> q = sys . stdin . readline ( ) <NEWLINE> M = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> s_A = sum ( A ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> for m in M : <NEWLINE> <INDENT> if s_A < m : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> elif solve ( A , 0 , m , n ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans , end = <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> b_c = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> ans = sum ( A ) <NEWLINE> l = Counter ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ans += l [ b_c [ i ] [ 0 ] ] * ( b_c [ i ] [ 1 ] - b_c [ i ] [ 0 ] ) <NEWLINE> l [ b_c [ i ] [ 1 ] ] += l [ b_c [ i ] [ 0 ] ] <NEWLINE> l [ b_c [ i ] [ 0 ] ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> for i , n in enumerate ( range ( K - 1 , N ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ n - K ] < A [ n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X , num = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <NL> if num == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if X - i not in l : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif X + i not in l : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( X - num ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> s = <STRING> <NEWLINE> s2 = <STRING> <NEWLINE> def prime_factorize ( n ) : <NEWLINE> <INDENT> m = math . sqrt ( n ) + 1 <NEWLINE> i = 2 <NEWLINE> prime = [ ] <NEWLINE> while n != 1 and i < m : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> n //= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> prime . append ( n ) <NEWLINE> <DEDENT> return prime <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> lst = prime_factorize ( n ) <NEWLINE> print ( s . format ( n ) , end = <STRING> ) <NEWLINE> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> print ( s2 . format ( lst [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> dekai = False <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> dekai = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif dekai : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> aa = sorted ( a ) [ : n - 1 ] <NEWLINE> maxa = max ( a ) <NEWLINE> b = a . index ( maxa ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == b : <NEWLINE> <INDENT> print ( max ( aa ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxa ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 0 <NEWLINE> dif = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ( A [ i - 1 ] + dif ) - A [ i ] > 0 : <NEWLINE> <INDENT> total += ( A [ i - 1 ] + dif ) - A [ i ] <NEWLINE> dif = ( A [ i - 1 ] + dif ) - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dif = 0 <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> sub = <STRING> <NEWLINE> cnt = 0 <NEWLINE> sum = 0 <NEWLINE> <NL> <COMMENT> <NL> st = 0 <NEWLINE> end = 0 <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> S = S [ st : len ( S ) - end ] <NEWLINE> <COMMENT> <NL> <NL> foundB = False <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> foundB = True <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> sum += cnt <NEWLINE> foundB = False <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> check_A = [ 0 ] <NEWLINE> check_B = [ 0 ] <NEWLINE> <NL> for a in range ( N ) : <NEWLINE> <INDENT> check_A . append ( check_A [ a ] + A [ a ] ) <NEWLINE> <NL> <DEDENT> for b in range ( M ) : <NEWLINE> <INDENT> check_B . append ( check_B [ b ] + B [ b ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if check_A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while check_B [ j ] > K - check_A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> cnts = [ 0 for i in range ( N + 1 ) ] <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> x2 = x * x <NEWLINE> for y in range ( x , 100 ) : <NEWLINE> <INDENT> y2 = y * y <NEWLINE> xy = x * y <NEWLINE> if x2 + y * y + x * y + x + y > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for z in range ( y , 100 ) : <NEWLINE> <INDENT> z2 = z * z <NEWLINE> M = x2 + y2 + z2 + xy + y * z + z * x <NEWLINE> if M > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x != y : <NEWLINE> <INDENT> if y != z : <NEWLINE> <INDENT> cnts [ M ] += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnts [ M ] += 3 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if y != z : <NEWLINE> <INDENT> cnts [ M ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnts [ M ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in cnts [ 1 : N + 1 ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> limit = [ 1 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i == N : <COMMENT> <NEWLINE> <INDENT> limit . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> limit . append ( ( limit [ - 1 ] - A [ i - 1 ] ) * 2 ) <NEWLINE> if limit [ - 1 ] < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if N == 0 : <NEWLINE> <INDENT> if A [ 0 ] != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = [ A [ - 1 ] ] <NEWLINE> now_leaf = A [ - 1 ] <COMMENT> <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans . append ( min ( now_leaf + A [ i ] , limit [ i ] ) ) <NEWLINE> now_leaf = ans [ - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( ans [ N - i ] - A [ i ] ) * 2 < A [ i + 1 ] : <COMMENT> <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> c = np . array ( list ( input ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> n_white = np . count_nonzero ( c == <STRING> ) <NEWLINE> n_red = np . count_nonzero ( c == <STRING> ) <NEWLINE> <NL> if n_red : <NEWLINE> <INDENT> if n_white : <NEWLINE> <INDENT> p_white = np . where ( c == <STRING> ) [ 0 ] . tolist ( ) <NEWLINE> p_red = np . where ( c == <STRING> ) [ 0 ] . tolist ( ) <NEWLINE> num = min ( len ( p_white ) , len ( p_red ) ) <NEWLINE> i = 0 <NEWLINE> while ( i < num ) : <NEWLINE> <INDENT> if p_white [ i ] < p_red [ - 1 - i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = sum ( a ) <NEWLINE> sb = sum ( b ) <NEWLINE> counta = 0 <NEWLINE> countb = 0 <NEWLINE> for i , j in zip ( a , b ) : <NEWLINE> <INDENT> if j > i : <NEWLINE> <INDENT> if ( j - i ) % 2 : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> counta += ( j - i + 1 ) // 2 <NEWLINE> <DEDENT> elif i > j : <NEWLINE> <INDENT> countb += i - j <NEWLINE> <DEDENT> <DEDENT> if counta <= sb - sa and countb <= sb - sa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for _ in range ( n ) ] <NEWLINE> num = Counter ( s ) <NEWLINE> ans = [ ] <NEWLINE> ma = max ( num . values ( ) ) <NEWLINE> for i in sorted ( num ) : <NEWLINE> <INDENT> if num [ i ] == ma : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = sum ( alst ) <NEWLINE> sum = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> for a in alst : <NEWLINE> <INDENT> sum = sum + a * ( total - a ) <NEWLINE> sum %= MOD <NEWLINE> <NL> <DEDENT> sum *= pow ( 2 , MOD - 2 , MOD ) <NEWLINE> sum %= MOD <NEWLINE> print ( sum ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 1 + ( i - 1 ) / 2 for i in p ] <NEWLINE> l = sum ( a [ : k ] ) <NEWLINE> ans = l <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> l = l - a [ i - 1 ] + a [ k + i - 1 ] <NEWLINE> ans = max ( ans , l ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> answer *= i <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if answer <= 10 ** 18 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( n - 2 ) * b - ( n - 2 ) * a ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <STRING> <NEWLINE> L_i = [ A [ i ] + i for i in range ( N ) ] <NEWLINE> L_j = [ j - A [ j ] for j in range ( N ) ] <NEWLINE> <COMMENT> <NL> ans_lis = [ 0 ] * ( 2 * ( 10 ** 5 ) ) <NEWLINE> for x in L_i : <NEWLINE> <INDENT> if x < 2 * ( 10 ** 5 ) : <NEWLINE> <INDENT> ans_lis [ x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for y in L_j : <NEWLINE> <INDENT> if y > 0 : <NEWLINE> <INDENT> ans += ans_lis [ y - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> <NL> NOT_FOUND = False <NEWLINE> <NL> <COMMENT> <NL> def binarySearch ( n , S , t ) : <NEWLINE> <NL> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> key = t <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if S [ mid ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif key < S [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return NOT_FOUND <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> n = int ( input ( ) ) <COMMENT> <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> q = int ( input ( ) ) <COMMENT> <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> C = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( q ) : <NEWLINE> <INDENT> isExist = binarySearch ( n , S , T [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> if isExist : <NEWLINE> <INDENT> C = C + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( C ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for number in a : <NEWLINE> <INDENT> result *= number <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> k = S - j - i <NEWLINE> if k >= 0 and k <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> H = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> dp = np . full ( n , INF , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ max ( i - k , 0 ) : i ] + np . abs ( H [ max ( i - k , 0 ) : i ] - H [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] < h [ b - 1 ] and l [ a - 1 ] == 0 : <NEWLINE> <INDENT> l [ a - 1 ] = - 1 <NEWLINE> <DEDENT> elif h [ a - 1 ] > h [ b - 1 ] and l [ b - 1 ] == 0 : <NEWLINE> <INDENT> l [ b - 1 ] = - 1 <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> l [ a - 1 ] = - 1 <NEWLINE> l [ b - 1 ] = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( l . count ( 0 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def dfs ( num ) : <NEWLINE> <INDENT> if dp [ num ] != - 1 : <NEWLINE> <INDENT> return dp [ num ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for obj in G [ num ] : <NEWLINE> <INDENT> res = max ( res , dfs ( obj ) + 1 ) <NEWLINE> <NL> <DEDENT> dp [ num ] = res <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ - 1 ] * N <NEWLINE> G = { i : [ ] for i in range ( N ) } <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res = max ( res , dfs ( i ) ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_collection = collections . Counter ( A_list ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( A_collection [ i + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> state = list ( s . strip ( ) ) <NEWLINE> j = 0 <NEWLINE> for d in state : <NEWLINE> <INDENT> if <STRING> <= d and d <= <STRING> : <NEWLINE> <INDENT> state [ j ] = chr ( ( ord ( d ) + i - ord ( <STRING> ) ) % 26 + ord ( <STRING> ) ) <NEWLINE> <DEDENT> elif <STRING> <= d and d <= <STRING> : <NEWLINE> <INDENT> state [ j ] = chr ( ( ord ( d ) + i - ord ( <STRING> ) ) % 26 + ord ( <STRING> ) ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> state = <STRING> . join ( state ) <NEWLINE> <NL> if <STRING> in state or <STRING> in state or <STRING> in state : <NEWLINE> <INDENT> print ( state ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> x = [ 0 ] * ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x [ a - 1 ] = max ( h [ b - 1 ] , x [ a - 1 ] ) <NEWLINE> x [ b - 1 ] = max ( h [ a - 1 ] , x [ b - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( h [ i ] > x [ i ] ) or x [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = l [ i ] <NEWLINE> ans *= x <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> count += ( N - 1 ) // i <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> alist = [ False ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> alist [ int ( input ( ) ) - 1 ] = True <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> dp = deque ( [ 0 ] * 2 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if alist [ 0 ] : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if alist [ i - 1 ] : <NEWLINE> <INDENT> dp . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp . append ( ( dp [ 0 ] + dp [ 1 ] ) % mod ) <NEWLINE> <DEDENT> dp . popleft ( ) <NEWLINE> <DEDENT> ans = dp [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in aa : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = [ s for s in aa if s != 1 ] <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> prod = 1 <NEWLINE> for item in a : <NEWLINE> <INDENT> prod *= item <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans = ans * A [ i ] <NEWLINE> if ans > 1e+18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . reverse ( ) <NEWLINE> <NL> print ( a [ 0 ] , end = <STRING> ) <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( i , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> y = i <NEWLINE> if y % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if int ( y ) % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> y /= 10 <NEWLINE> if int ( y ) == 0 : break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> vmin = min ( data ) <COMMENT> <NEWLINE> vmax = max ( data ) <COMMENT> <NEWLINE> vsum = sum ( data ) <COMMENT> <NEWLINE> <COMMENT> <NL> print ( vmin , vmax , vsum ) <COMMENT> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 10 ** 9 + 7 <NEWLINE> <NL> Total = sum ( A ) - A [ 0 ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * Total <NEWLINE> ans = ans % M <NEWLINE> Total -= A [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list1 = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> taisho = input ( ) <NEWLINE> if not taisho in list1 : <NEWLINE> <INDENT> list1 . add ( taisho ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( list1 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> past = [ 0 ] * min ( K , 2 * 10 ** 5 ) <NEWLINE> ps = set ( ) <NEWLINE> now = 1 <NEWLINE> step = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> past [ i ] = now <NEWLINE> ps . add ( now ) <NEWLINE> now = A [ now - 1 ] <NEWLINE> if now in ps : <NEWLINE> <INDENT> step += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if step > 0 : <NEWLINE> <INDENT> id = past . index ( now ) <NEWLINE> step = i + 1 - id <NEWLINE> p = ( K - id ) % step <NEWLINE> now = past [ id + p ] <NEWLINE> <NL> <DEDENT> print ( now ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = ( 10 * a + 7 ) % K <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> x = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> current = ( current + x * int ( s ) ) % 2019 <NEWLINE> ans += mods [ current % 2019 ] <NEWLINE> mods [ current % 2019 ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> d = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a , b = l [ i ] <NEWLINE> c , e = l [ j ] <NEWLINE> d [ ( a - c , b - e ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = n <NEWLINE> m = max ( d . values ( ) ) <NEWLINE> for i , j in d . items ( ) : <NEWLINE> <INDENT> if j != m : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> x , y = i <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count = 0 <NEWLINE> for c , d in l : <NEWLINE> <INDENT> if [ c + x , d + y ] in l : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , n - count ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = n // i <NEWLINE> ans += ( ( num * ( num + 1 ) ) // 2 ) * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] * n <NEWLINE> ans = 1 <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for i in range ( N ) ] <NEWLINE> cnt = [ 0 ] * N <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> v = [ False ] * N <NEWLINE> <NL> <COMMENT> <NL> def dfs ( n , prv ) : <NEWLINE> <COMMENT> <NL> <INDENT> if v [ n ] : return <NEWLINE> cnt [ n ] += prv <NEWLINE> v [ n ] = True <NEWLINE> for nv in graph [ n ] : <NEWLINE> <INDENT> dfs ( nv , cnt [ n ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> print ( * cnt ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> S = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i + 1 ] != S [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> store_list = [ ] <NEWLINE> dictA = { } <NEWLINE> ans_list = [ 1 ] * n <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s_list = list ( s ) <NEWLINE> s_list . sort ( ) <NEWLINE> a = tuple ( s_list ) <NEWLINE> dictA . setdefault ( a , 0 ) <NEWLINE> dictA [ a ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> total = 0 <NEWLINE> for value in dictA . values ( ) : <NEWLINE> <INDENT> total += value * ( value - 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( total ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rd = 0 <NEWLINE> c = 1 <NEWLINE> N_ = N * c <NEWLINE> while ( N_ % M != 0 ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> N_ = c * N <NEWLINE> <DEDENT> rd = N_ // M <NEWLINE> <NL> As = As * ( N_ // N + 1 ) <NEWLINE> <NL> ls = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( rd ) : <NEWLINE> <INDENT> lstmp = [ ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> lstmp . append ( As [ cnt ] ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ls . append ( lstmp ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in ls : <NEWLINE> <INDENT> s += max ( i ) - min ( i ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL>
hist = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> i , b = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> hist [ b ] += 1 <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> % ( hist [ <STRING> ] , hist [ <STRING> ] , hist [ <STRING> ] , hist [ <STRING> ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> H = sorted ( H ) <NEWLINE> if K >= len ( H ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , K ) : <NEWLINE> <INDENT> del H [ - 1 ] <NEWLINE> <DEDENT> result = sum ( H ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = [ 0 ] * ( n - 1 ) <NEWLINE> ans [ 0 ] = a [ 0 ] <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> p = i // 2 <NEWLINE> ans [ i - 1 ] = a [ p ] <NEWLINE> <NL> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nn = lambda : list ( stdin . readline ( ) . split ( ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n , k = na ( ) <NEWLINE> a = na ( ) <NEWLINE> dp = [ - 1 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> i = 1 <NEWLINE> now = 0 <NEWLINE> loop = - 1 <NEWLINE> start = - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> now = a [ now ] - 1 <NEWLINE> if i == k : <NEWLINE> <INDENT> print ( now + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if dp [ now ] == - 1 : <NEWLINE> <INDENT> dp [ now ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = i - dp [ now ] <NEWLINE> start = dp [ now ] <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( dp . index ( ( k - start ) % loop + start ) + 1 ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ 0 ] * m for j in range ( n ) ] <NEWLINE> c = [ 0 ] * n <NEWLINE> <NL> ans = 10 ** 10 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c [ i ] = arr [ 0 ] <NEWLINE> a [ i ] = arr [ 1 : ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import itertools <NEWLINE> for bit in itertools . product ( [ 0 , 1 ] , repeat = n ) : <NEWLINE> <INDENT> arr = [ 0 ] * m <NEWLINE> cost = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if bit [ i ] == 1 : <NEWLINE> <INDENT> for k in range ( len ( a [ i ] ) ) : <NEWLINE> <INDENT> arr [ k ] += a [ i ] [ k ] <NEWLINE> <DEDENT> cost += c [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> NG = False <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ i ] < x : <NEWLINE> <INDENT> NG = True <NEWLINE> <NL> <DEDENT> <DEDENT> if NG : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans != 10 ** 10 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def solver ( s , k ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> cnt = [ 1 ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> cnt [ - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> for x in cnt : <NEWLINE> <INDENT> res += ( x // 2 ) * k <NEWLINE> <NL> <DEDENT> if len ( cnt ) == 1 : <COMMENT> <NEWLINE> <INDENT> return ( len ( s ) * k ) // 2 <NEWLINE> <NL> <DEDENT> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> res -= ( cnt [ 0 ] // 2 ) * ( k - 1 ) + ( cnt [ - 1 ] // 2 ) * ( k - 1 ) <NEWLINE> res += ( ( cnt [ 0 ] + cnt [ - 1 ] ) // 2 ) * ( k - 1 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def solver2 ( s , k ) : <NEWLINE> <INDENT> t = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> t += s <NEWLINE> <DEDENT> res = 0 <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == t [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += cnt // 2 <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> res += cnt // 2 <NEWLINE> return res <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( solver ( s , k ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> import random <NEWLINE> import string <NEWLINE> <NL> <COMMENT> <NL> def randomCharacter ( n ) : <NEWLINE> <INDENT> alphabet_m = string . ascii_lowercase <NEWLINE> return <STRING> . join ( [ random . choice ( alphabet_m ) for _ in range ( n ) ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> dp = [ [ - INF for i in range ( 2 ) ] for j in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> dp [ 1 ] [ 0 ] = 0 <NEWLINE> dp [ 2 ] [ 0 ] = 0 <NEWLINE> dp [ 1 ] [ 1 ] = A [ 0 ] <NEWLINE> dp [ 2 ] [ 1 ] = A [ 1 ] <NEWLINE> <NL> for i in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i - 2 ] [ 0 ] + A [ i - 1 ] , dp [ i - 2 ] [ 1 ] ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i - 3 ] [ 0 ] + A [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i - 3 ] [ 1 ] + A [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> dp [ i ] [ 1 ] = dp [ i - 2 ] [ 1 ] + A [ i - 1 ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 3 ] [ 1 ] + A [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N % 2 == 0 : <NEWLINE> <INDENT> print ( max ( dp [ N ] [ 1 ] , dp [ N - 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( dp [ N ] [ 0 ] , dp [ N - 1 ] [ 1 ] , dp [ N - 2 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
def isPrime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( x ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> cnt += isPrime ( i ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 ] * Q <NEWLINE> C = [ 0 ] * Q <NEWLINE> <NL> num = [ 0 ] * 100000 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> num [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> sum = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum += ( C [ i ] - B [ i ] ) * num [ B [ i ] - 1 ] <NEWLINE> num [ C [ i ] - 1 ] += num [ B [ i ] - 1 ] <NEWLINE> num [ B [ i ] - 1 ] = 0 <NEWLINE> <NL> print ( sum ) <NEWLINE> <DEDENT>
from collections import Counter , defaultdict , deque <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> import sys , bisect , math , itertools , fractions , pprint <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = inp ( ) <NEWLINE> a = [ inpl ( ) for _ in range ( n ) ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> c = [ ] <NEWLINE> for i , ( x , y ) in enumerate ( a ) : <NEWLINE> <INDENT> for j , ( z , w ) in enumerate ( a ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> c . append ( ( ( x - z ) , ( y - w ) ) ) <NEWLINE> <DEDENT> <DEDENT> h = Counter ( c ) <NEWLINE> print ( n - max ( h . values ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> from itertools import groupby <NEWLINE> <NL> gr = groupby ( s ) <NEWLINE> <COMMENT> <NL> flg = 0 <NEWLINE> black = [ ] <NEWLINE> white = [ ] <NEWLINE> for k , v in gr : <NEWLINE> <INDENT> if flg == 0 and k == <STRING> : <NEWLINE> <INDENT> flg = 1 <NEWLINE> black . append ( len ( list ( v ) ) ) <NEWLINE> <DEDENT> elif flg == 1 : <NEWLINE> <INDENT> if k == <STRING> : <NEWLINE> <INDENT> black . append ( len ( list ( v ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> white . append ( len ( list ( v ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( black ) == 0 or len ( white ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> cnt = sum ( white ) <NEWLINE> ans = [ cnt ] <NEWLINE> for i in range ( len ( white ) ) : <NEWLINE> <INDENT> cnt += ( black [ i ] - white [ i ] ) <NEWLINE> ans . append ( cnt ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE> <NL> <NL> <NL>
from itertools import product <NEWLINE> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = deque ( input ( ) ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> i = 0 <NEWLINE> while s : <NEWLINE> <INDENT> x = s . popleft ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i * 2 ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> ans = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> B = set ( B ) <NEWLINE> S = product ( R , G ) <NEWLINE> for i , j in S : <NEWLINE> <INDENT> if i + j in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 4 * i - 2 * j in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 4 * j - 2 * i in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( k , length , MOD , div , dp ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> dp [ 0 ] = dp [ 0 ] * 25 * div * ( length + i - 1 ) * pow ( i , - 1 , MOD ) % MOD <NEWLINE> dp [ 1 ] = ( dp [ 1 ] + dp [ 0 ] ) % MOD <NEWLINE> <NL> <DEDENT> return ( dp [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> length = len ( s ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> div = pow ( 26 , - 1 , MOD ) <NEWLINE> <NL> dp = [ pow ( 26 , k , MOD ) ] * 2 <NEWLINE> <NL> print ( solve ( k , length , MOD , div , dp ) ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> kotae = 0 <NEWLINE> for Z in range ( K + 1 ) : <NEWLINE> <INDENT> X_plus_Y = S - Z <NEWLINE> for Y in range ( K + 1 ) : <NEWLINE> <INDENT> X = X_plus_Y - Y <NEWLINE> if 0 <= X <= K : <NEWLINE> <INDENT> kotae += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( kotae ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> dp [ n - 1 ] = int ( S [ - 1 ] ) <NEWLINE> <NL> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i + 1 ] + pow ( 10 , n - i - 1 , 2019 ) * int ( S [ i ] ) ) % 2019 <NEWLINE> <NL> <DEDENT> ans = Counter ( dp ) <NEWLINE> cnt = 0 <NEWLINE> for i in ans . values ( ) : <NEWLINE> <INDENT> cnt += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def combinations_count ( n , r ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> import math <NEWLINE> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ms = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ms . reverse ( ) <NEWLINE> combs = combinations_count ( n , 2 ) <NEWLINE> res = deque ( [ combs ] ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in ms [ : - 1 ] : <NEWLINE> <INDENT> if not ( uf . same ( i [ 0 ] - 1 , i [ 1 ] - 1 ) ) : <NEWLINE> <INDENT> combs -= uf . size ( i [ 0 ] - 1 ) * uf . size ( i [ 1 ] - 1 ) <NEWLINE> <DEDENT> res . appendleft ( combs ) <NEWLINE> uf . union ( i [ 0 ] - 1 , i [ 1 ] - 1 ) <NEWLINE> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> import sys <NEWLINE> <NL> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( ) <NEWLINE> name_dict = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> } <NEWLINE> name = <STRING> <NEWLINE> <NL> while n != 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> l . append ( n % 26 ) <NEWLINE> n = n // 26 <NEWLINE> <NL> <DEDENT> if l != [ ] : <NEWLINE> <INDENT> for i in reversed ( l ) : <NEWLINE> <INDENT> name += name_dict [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( name ) <NEWLINE>
import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> Al = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> center = int ( N / 2 ) <NEWLINE> cnt = 0 <NEWLINE> m = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> m [ i + Al [ i ] ] += 1 <NEWLINE> cnt += m [ i - Al [ i ] ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = t [ 0 ] <NEWLINE> b = t [ 1 ] <NEWLINE> h = t [ 2 ] <NEWLINE> m = t [ 3 ] <NEWLINE> import math <NEWLINE> <NL> h_c = 30 * h + 0.5 * m <NEWLINE> m_c = 6 * m <NEWLINE> <NL> z = abs ( h_c - m_c ) <NEWLINE> if z > 180 : <NEWLINE> <INDENT> z = 360 - z <NEWLINE> <DEDENT> if z == 180 : <NEWLINE> <INDENT> print ( t [ 0 ] + t [ 1 ] ) <NEWLINE> <DEDENT> elif z == 0 : <NEWLINE> <INDENT> print ( abs ( t [ 0 ] - t [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a ** 2 <NEWLINE> b = b ** 2 <NEWLINE> k = round ( math . cos ( math . radians ( z ) ) , 30 ) <NEWLINE> print ( math . sqrt ( a + b - 2 * t [ 0 ] * t [ 1 ] * k ) ) <NEWLINE> <DEDENT>
<NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> move = [ ] <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> move . append ( ( L , R ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( 2 * N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for l , r in move : <NEWLINE> <INDENT> dp [ i + l ] += dp [ i ] <NEWLINE> dp [ i + l ] %= mod <NEWLINE> dp [ i + r + 1 ] -= dp [ i ] <NEWLINE> dp [ i + r + 1 ] %= mod <NEWLINE> <DEDENT> if i : <NEWLINE> <INDENT> dp [ i + 1 ] += dp [ i ] <NEWLINE> <DEDENT> dp [ i ] %= mod <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> prof = 0 <NEWLINE> d = int ( input ( ) ) <NEWLINE> li = [ int ( input ( ) ) for i in range ( d ) ] <NEWLINE> max = float ( <STRING> ) <NEWLINE> min = li [ 0 ] <NEWLINE> for j in range ( 1 , d ) : <NEWLINE> <INDENT> if li [ j ] - min > max : <NEWLINE> <INDENT> max = li [ j ] - min <NEWLINE> <DEDENT> if li [ j ] < min : <NEWLINE> <INDENT> min = li [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] * - 1 <NEWLINE> <DEDENT> import heapq <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t = ( heapq . heappop ( a ) ) * - 1 <NEWLINE> heapq . heappush ( a , ( t // 2 ) * - 1 ) <NEWLINE> <DEDENT> print ( sum ( a ) * - 1 ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> dic = { } <NEWLINE> def ADD ( x ) : <NEWLINE> <INDENT> if x in dic : <NEWLINE> <INDENT> dic [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 2 , int ( m ** 0.5 + 2 ) ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> ADD ( i ) <NEWLINE> m //= i <NEWLINE> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> ADD ( m ) <NEWLINE> <DEDENT> dic = tuple ( dic . values ( ) ) <NEWLINE> ans = 1 <NEWLINE> fac = [ 1 ] <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> fac . append ( fac [ - 1 ] * ( i + 1 ) % mod ) <NEWLINE> <DEDENT> def c ( a , b ) : <NEWLINE> <INDENT> r = pow ( fac [ b ] * fac [ a - b ] % mod , mod - 2 , mod ) <NEWLINE> return fac [ a ] * r % mod <NEWLINE> <DEDENT> for x in dic : <NEWLINE> <INDENT> ans *= c ( x + n - 1 , x ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
l = list ( input ( ) ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = 0 <NEWLINE> B = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = max ( A , a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> B = sorted ( [ b for b in B if b > A ] , reverse = True ) <NEWLINE> from itertools import accumulate <NEWLINE> B = list ( accumulate ( B ) ) <NEWLINE> total_throw_damage = ( B [ - 1 ] if len ( B ) > 0 else 0 ) <NEWLINE> <NL> HP_after_throw = H - total_throw_damage <NEWLINE> if HP_after_throw <= 0 : <NEWLINE> <INDENT> for i , b in enumerate ( B , 1 ) : <NEWLINE> <INDENT> if H <= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> raise AssertionError ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q , r = divmod ( HP_after_throw , A ) <NEWLINE> print ( len ( B ) + q + min ( 1 , r ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sum ( [ ( i ** 2 ) for i in a ] ) <NEWLINE> print ( ( ( sum ( a ) ** 2 - b ) // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def function ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> if n < 2 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n = n // 2 <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> n = n // i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> print ( str ( n ) + <STRING> , * function ( n ) ) <NEWLINE>
def _integral ( A ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> sum_value = 0 <NEWLINE> result . append ( sum_value ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> sum_value += A [ i ] <NEWLINE> result . append ( sum_value ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def _main ( N , M , K , A , B ) : <NEWLINE> <INDENT> integral_a = _integral ( A ) <NEWLINE> integral_b = _integral ( B ) <NEWLINE> top_count = 0 <NEWLINE> b_max = len ( B ) <NEWLINE> for a_index in range ( len ( A ) + 1 ) : <NEWLINE> <INDENT> a_value = integral_a [ a_index ] <NEWLINE> if K < a_value : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for b_index in range ( 0 , min ( len ( B ) + 1 , b_max + 1 ) ) [ : : - 1 ] : <NEWLINE> <INDENT> if a_value + integral_b [ b_index ] <= K : <NEWLINE> <INDENT> if top_count < a_index + b_index : <NEWLINE> <INDENT> top_count = a_index + b_index <NEWLINE> <DEDENT> b_max = b_index <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( top_count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Na , Ma , Ka = map ( int , input ( ) . split ( ) ) <NEWLINE> Aa = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> Ba = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> _main ( Na , Ma , Ka , Aa , Ba ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> query = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> x , y = 1 , 1 <NEWLINE> for t , a in query : <NEWLINE> <INDENT> if t >= x and a >= y : <NEWLINE> <INDENT> x = t <NEWLINE> y = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t < x and a < y : <NEWLINE> <INDENT> x = t * max ( ( x + t - 1 ) // t , ( y + a - 1 ) // a ) <NEWLINE> y = a * max ( ( x + t - 1 ) // t , ( y + a - 1 ) // a ) <NEWLINE> <DEDENT> elif t < x : <NEWLINE> <INDENT> x = t * ( ( x + t - 1 ) // t ) <NEWLINE> y = a * ( ( x + t - 1 ) // t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = t * ( ( y + a - 1 ) // a ) <NEWLINE> y = a * ( ( y + a - 1 ) // a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x + y ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = sum ( A ) <NEWLINE> x = t - A [ 0 ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ct = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ct += A [ i ] * x <NEWLINE> x = x - A [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( ( ct % mod ) ) <NEWLINE> int ( ( ct % mod ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> <NL> def bfs ( x1 , y1 , d ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( ( d , x1 , y1 ) ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> d , x1 , y1 = q . popleft ( ) <NEWLINE> <NL> M [ x1 ] [ y1 ] = d <NEWLINE> <NL> if [ x1 , y1 ] == [ xg , yg ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for dx , dy in ( ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x2 = x1 + dx * k <NEWLINE> y2 = y1 + dy * k <NEWLINE> <NL> if ( 0 <= x2 < H ) and ( 0 <= y2 < W ) : <NEWLINE> <INDENT> if m [ x2 ] [ y2 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] == - 1 : <NEWLINE> <INDENT> M [ x2 ] [ y2 ] = d + 1 <NEWLINE> q . append ( ( d + 1 , x2 , y2 ) ) <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = map ( int , input ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = xs - 1 , ys - 1 , xg - 1 , yg - 1 <NEWLINE> <NL> m = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> m . append ( list ( map ( str , sys . stdin . readline ( ) . strip ( ) ) ) ) <NEWLINE> <NL> <DEDENT> M = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> <NL> bfs ( xs , ys , 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pdt = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pdt *= a [ i ] <NEWLINE> if pdt == 0 : <NEWLINE> <INDENT> print ( pdt ) <NEWLINE> break <NEWLINE> <DEDENT> elif pdt > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( pdt ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> m = max ( m , A [ i ] ) <NEWLINE> ans += m - A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> list_s = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> list_h = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> list_c = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> list_d = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> c , cn = input ( ) . split ( <STRING> ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> if str ( c + cn ) in list_s : <NEWLINE> <INDENT> a = list_s . index ( str ( c + cn ) ) <NEWLINE> list_s . pop ( a ) <NEWLINE> <DEDENT> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> if str ( c + cn ) in list_h : <NEWLINE> <INDENT> a = list_h . index ( str ( c + cn ) ) <NEWLINE> list_h . pop ( a ) <NEWLINE> <DEDENT> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> if str ( c + cn ) in list_c : <NEWLINE> <INDENT> a = list_c . index ( str ( c + cn ) ) <NEWLINE> list_c . pop ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> if str ( c + cn ) in list_d : <NEWLINE> <INDENT> a = list_d . index ( str ( c + cn ) ) <NEWLINE> list_d . pop ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> [ print ( i [ 0 : 1 ] , i [ 1 : ] ) for i in list_s ] <NEWLINE> [ print ( i [ 0 : 1 ] , i [ 1 : ] ) for i in list_h ] <NEWLINE> [ print ( i [ 0 : 1 ] , i [ 1 : ] ) for i in list_c ] <NEWLINE> [ print ( i [ 0 : 1 ] , i [ 1 : ] ) for i in list_d ] <NEWLINE> <NL>
import bisect <COMMENT> <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ * input ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> d = defaultdict ( list ) <NEWLINE> <NL> <COMMENT> <NL> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> d [ c ] += [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> q , y , z = input ( ) . split ( ) <NEWLINE> <NL> if q == <STRING> : <NEWLINE> <INDENT> i = int ( y ) - 1 <COMMENT> <NEWLINE> <NL> if S [ i ] == z : continue <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> b = bisect . bisect ( d [ S [ i ] ] , i ) <COMMENT> <NEWLINE> d [ S [ i ] ] . pop ( b - 1 ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> S [ i ] = z <NEWLINE> bisect . insort ( d [ z ] , i ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> left = int ( y ) - 1 <NEWLINE> right = int ( z ) - 1 <NEWLINE> <NL> count = 0 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> count += 1 if bisect . bisect ( v , right ) - bisect . bisect_left ( v , left ) > 0 else 0 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
import random <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> <NL> <NL> def calc ( T ) : <NEWLINE> <INDENT> L = [ 0 for i in range ( 26 ) ] <NEWLINE> score = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> score += S [ d ] [ T [ d ] - 1 ] <NEWLINE> <NL> L [ T [ d ] - 1 ] = d + 1 <NEWLINE> down = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> down += C [ i ] * ( ( d + 1 ) - L [ i ] ) <NEWLINE> <NL> <DEDENT> score -= down <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <DEDENT> max_score = 0 <NEWLINE> bestT = [ ] <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> T = [ random . randrange ( 1 , 26 ) for i in range ( D ) ] <NEWLINE> score = calc ( T ) <NEWLINE> <NL> if score > max_score : <NEWLINE> <INDENT> bestT = T <NEWLINE> max_score = score <NEWLINE> <NL> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cycles , check = [ ] , [ False ] * n <NEWLINE> for pi in p : <NEWLINE> <INDENT> if not check [ pi - 1 ] : <NEWLINE> <INDENT> curr , cycle = pi , [ ] <NEWLINE> check [ pi - 1 ] = True <NEWLINE> while pi != p [ curr - 1 ] : <NEWLINE> <INDENT> check [ curr - 1 ] = True <NEWLINE> cycle . append ( c [ curr - 1 ] ) <NEWLINE> curr = p [ curr - 1 ] <NEWLINE> <DEDENT> check [ curr - 1 ] = True <NEWLINE> cycles . append ( cycle + [ c [ curr - 1 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> scores = [ ] <NEWLINE> for cycle in ( np . array ( cycle ) for cycle in cycles ) : <NEWLINE> <INDENT> for i in range ( cycle . size ) : <NEWLINE> <INDENT> cum = np . roll ( cycle , i ) . cumsum ( ) <NEWLINE> if cum [ - 1 ] > 0 and k > cycle . size : <NEWLINE> <INDENT> scores . append ( cum [ - 1 ] * ( k // cycle . size - 1 ) + np . concatenate ( [ cum , cum [ : k % cycle . size ] + cum [ - 1 ] ] ) . max ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> scores . append ( cum [ : min ( k , cum . size ) ] . max ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( scores ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import division , print_function <NEWLINE> try : <NEWLINE> <INDENT> input = raw_input <NEWLINE> range = xrange <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> value = [ 0 ] * 1000 <NEWLINE> weight = [ 0 ] * 1000 <NEWLINE> casenum = 1 <NEWLINE> while True : <NEWLINE> <INDENT> W = int ( input ( ) ) <NEWLINE> if ( W == 0 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> dp = [ [ 0 for x in range ( W + 1 ) ] for y in range ( N + 1 ) ] <NEWLINE> for x in range ( 0 , N ) : <NEWLINE> <INDENT> value [ x ] , weight [ x ] = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for w in range ( 0 , W + 1 ) : <NEWLINE> <INDENT> if w - weight [ i ] >= 0 : <NEWLINE> <INDENT> use = dp [ i ] [ w - weight [ i ] ] + value [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> use = 0 <NEWLINE> <DEDENT> unuse = dp [ i ] [ w ] <NEWLINE> dp [ i + 1 ] [ w ] = max ( use , unuse ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( casenum ) + <STRING> ) <NEWLINE> for w in range ( W + 1 ) : <NEWLINE> <INDENT> if ( dp [ N ] [ w ] == dp [ N ] [ W ] ) : <NEWLINE> <INDENT> print ( str ( dp [ N ] [ w ] ) + <STRING> + str ( w ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> casenum += 1 <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import deque , Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ <NEWLINE> <INDENT> int ( j ) - i for i , j in enumerate ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> ] <NEWLINE> cnt_A = Counter ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> d = deque ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = d . popleft ( ) <NEWLINE> <COMMENT> <NL> c = cnt_A [ - a - 2 * i ] <NEWLINE> ans += c <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import * <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> aaa = [ ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> aaa . append ( i ) <NEWLINE> <DEDENT> l = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> a = list ( combinations_with_replacement ( aaa , n ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> aa = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> if i [ j [ 1 ] - 1 ] - i [ j [ 0 ] - 1 ] == j [ 2 ] : <NEWLINE> <INDENT> aa += j [ 3 ] <NEWLINE> <DEDENT> if aa > ans : <NEWLINE> <INDENT> ans = aa <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = [ input ( ) for i in range ( 2 ) ] <NEWLINE> li = list ( map ( int , s [ 1 ] . split ( ) ) ) <NEWLINE> s0 = int ( s [ 0 ] ) <NEWLINE> f1 = 1 <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if 0 not in li : <NEWLINE> <INDENT> for i in range ( s0 ) : <NEWLINE> <INDENT> f1 = f1 * li [ i ] <NEWLINE> if f1 > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f1 <= 1000000000000000000 : <NEWLINE> <INDENT> print ( f1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import copy <NEWLINE> from itertools import combinations <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N , A , B , C = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ i ] = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mp = [ ] <NEWLINE> for na in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for ja in combinations ( l , na ) : <NEWLINE> <NL> <INDENT> l_b = copy . copy ( l ) <NEWLINE> for i2 in ja : <NEWLINE> <INDENT> if i2 in l_b : <NEWLINE> <INDENT> l_b . remove ( i2 ) <NEWLINE> <DEDENT> <DEDENT> for nb in range ( 1 , N ) : <NEWLINE> <INDENT> for jb in combinations ( l_b , nb ) : <NEWLINE> <NL> <INDENT> l_c = copy . copy ( l_b ) <NEWLINE> for i3 in jb : <NEWLINE> <INDENT> if i3 in l_c : <NEWLINE> <INDENT> l_c . remove ( i3 ) <NEWLINE> <DEDENT> <DEDENT> for nc in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for jc in combinations ( l_c , nc ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> AA = abs ( A - sum ( ja ) ) + 10 * ( na - 1 ) <NEWLINE> BB = abs ( B - sum ( jb ) ) + 10 * ( nb - 1 ) <NEWLINE> CC = abs ( C - sum ( jc ) ) + 10 * ( nc - 1 ) <NEWLINE> mp . append ( AA + BB + CC ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min ( mp ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> s = 0 <NEWLINE> K = int ( input ( ) ) + 1 <NEWLINE> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( a , K ) : <NEWLINE> <INDENT> for c in range ( b , K ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> s += a <NEWLINE> continue <NEWLINE> <DEDENT> x = reduce ( math . gcd , ( a , b , c ) ) <NEWLINE> if a == b or b == c or c == a : <NEWLINE> <INDENT> s += x * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += x * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if <STRING> in s : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os , bisect <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def primes2 ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n , correction = n - n % 6 + 6 , 2 - ( n % 6 > 1 ) <NEWLINE> sieve = [ True ] * ( n // 3 ) <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) // 3 + 1 ) : <NEWLINE> <INDENT> if sieve [ i ] : <NEWLINE> <INDENT> k = 3 * i + 1 | 1 <NEWLINE> sieve [ k * k // 3 : : 2 * k ] = [ False ] * ( ( n // 6 - k * k // 6 - 1 ) // k + 1 ) <NEWLINE> sieve [ k * ( k - 2 * ( i & 1 ) + 4 ) // 3 : : 2 * k ] = [ False ] * ( ( n // 6 - k * ( k - 2 * ( i & 1 ) + 4 ) // 6 - 1 ) // k + 1 ) <NEWLINE> <DEDENT> <DEDENT> return [ 2 , 3 ] + [ 3 * i + 1 | 1 for i in range ( 1 , n // 3 - correction ) if sieve [ i ] ] <NEWLINE> <NL> <DEDENT> primes = primes2 ( 10050 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> idx = bisect . bisect_left ( primes , n ) <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if primes [ idx ] > n : <NEWLINE> <INDENT> idx -= 1 <NEWLINE> <DEDENT> if primes [ idx ] - primes [ idx - 1 ] == 2 : <NEWLINE> <INDENT> print ( primes [ idx - 1 ] , primes [ idx ] ) <NEWLINE> break <NEWLINE> <DEDENT> idx -= 1 <NEWLINE> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> toggle = True <NEWLINE> while h != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> char = <STRING> if ( i + j ) % 2 == 0 else <STRING> <NEWLINE> print ( char , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from collections import deque , Counter <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def Main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> a = list ( IL ( ) ) <NEWLINE> C = Counter ( a ) <NEWLINE> m = sum ( a ) <NEWLINE> q = I ( ) <NEWLINE> s = [ ] <NEWLINE> for rep in range ( q ) : <NEWLINE> <INDENT> b , c = IL ( ) <NEWLINE> if b in C : <NEWLINE> <INDENT> m += ( c - b ) * C [ b ] <NEWLINE> C [ c ] += C [ b ] <NEWLINE> C [ b ] = 0 <NEWLINE> <DEDENT> s . append ( m ) <NEWLINE> <DEDENT> for rep in s : <NEWLINE> <INDENT> print ( rep ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum_gcd = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> sum_gcd += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> sum_gcd += 3 * math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_gcd += 6 * math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum_gcd ) <NEWLINE>
import sys <NEWLINE> class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> z = Node ( key ) <NEWLINE> y = None <NEWLINE> x = self . root <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y == None : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , self . root . inwalk ( ) ) ) ) <NEWLINE> print ( <STRING> , <STRING> . join ( map ( str , self . root . prewalk ( ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = self . left = self . right = None <NEWLINE> <DEDENT> def prewalk ( self ) : <NEWLINE> <INDENT> ret = [ self . key ] <NEWLINE> if self . left : <NEWLINE> <INDENT> ret += self . left . prewalk ( ) <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> ret += self . right . prewalk ( ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> def inwalk ( self ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> if self . left : <NEWLINE> <INDENT> ret += self . left . inwalk ( ) <NEWLINE> <DEDENT> ret += [ self . key ] <NEWLINE> if self . right : <NEWLINE> <INDENT> ret += self . right . inwalk ( ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> n = sys . stdin . readline ( ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( line . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . print ( ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = gcd ( A , B ) <NEWLINE> ans = 1 <NEWLINE> i = 2 <NEWLINE> while i <= pow ( d , 1 / 2 ) + 1 : <NEWLINE> <INDENT> if d % i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> while d % i == 0 : <NEWLINE> <INDENT> d //= i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> ans += ( d > 1 ) <NEWLINE> print ( ans ) <NEWLINE>
f = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> n , m = f ( ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = f ( ) <NEWLINE> g [ a - 1 ] += [ b - 1 ] <NEWLINE> g [ b - 1 ] += [ a - 1 ] <NEWLINE> <DEDENT> p = [ 0 ] * n <NEWLINE> from collections import * <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for c in g [ v ] : <NEWLINE> <INDENT> if p [ c ] < 1 : p [ c ] = v + 1 ; q . append ( c ) <NEWLINE> <DEDENT> <DEDENT> if 0 in p : print ( <STRING> ) <NEWLINE> else : print ( <STRING> , * p [ 1 : ] , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> s_li = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s_i = input ( ) <NEWLINE> s_li . append ( s_i ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( s_li ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> a = collections . deque ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> if b [ 0 ] == <STRING> : a . appendleft ( b [ 7 : ] ) <NEWLINE> elif b [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : a . remove ( b [ 7 : ] ) <NEWLINE> except : pass <NEWLINE> <DEDENT> elif len ( b ) > 10 : a . popleft ( ) <NEWLINE> elif len ( b ) > 6 : a . pop ( ) <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( 0 , m ) : <NEWLINE> <INDENT> b . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcd ( i , j ) , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( 1 , 50000 ) : <NEWLINE> <INDENT> dic [ int ( i * 1.08 ) ] = i <NEWLINE> <NL> <DEDENT> if n in dic : <NEWLINE> <INDENT> print ( dic [ n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = ( int ( d ) for d in input ( ) . split ( ) ) <NEWLINE> <NL> C = [ set ( ) for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = ( int ( d ) for d in input ( ) . split ( ) ) <NEWLINE> C [ A ] . update ( [ B ] ) <NEWLINE> C [ B ] . update ( [ A ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> seen = set ( ) <NEWLINE> G = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in seen : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> G . append ( set ( ) ) <NEWLINE> <NL> <COMMENT> <NL> Q = [ i ] <NEWLINE> G [ - 1 ] . update ( Q ) <NEWLINE> seen . update ( Q ) <NEWLINE> <NL> while len ( Q ) > 0 : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> I = Q . pop ( 0 ) <NEWLINE> J = C [ I ] . difference ( seen ) <NEWLINE> Q += list ( J ) <NEWLINE> G [ - 1 ] . update ( J ) <NEWLINE> <NL> seen . update ( J ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( [ len ( g ) for g in G ] ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 10010 <NEWLINE> <NL> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if v <= 10005 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def shellsort ( a ) : <NEWLINE> <INDENT> l = len ( a ) <NEWLINE> gaps = [ 1 ] <NEWLINE> while gaps [ 0 ] * 3 + 1 < l and len ( gaps ) <= 100 : <NEWLINE> <INDENT> gaps . insert ( 0 , gaps [ 0 ] * 3 + 1 ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for g in gaps : <NEWLINE> <INDENT> for i in range ( g , l ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and v < a [ j ] : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j -= g <NEWLINE> count += 1 <NEWLINE> <DEDENT> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( gaps ) ) <NEWLINE> print ( <STRING> . join ( [ str ( n ) for n in gaps ] ) ) <NEWLINE> print ( count ) <NEWLINE> print ( <STRING> . join ( [ str ( n ) for n in a ] ) ) <NEWLINE> <NL> <DEDENT> shellsort ( [ int ( input ( ) ) for _ in [ None ] * ( int ( input ( ) ) ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> while ( y ) : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> lcm = ( x * y ) // gcd ( x , y ) <NEWLINE> return lcm <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = lcm ( ans , i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> P = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( p ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 15 <NEWLINE> <NL> <NL> def F ( i , n , GetPoint ) : <NEWLINE> <INDENT> if i == D : <NEWLINE> <INDENT> if GetPoint >= G : <NEWLINE> <INDENT> return n , GetPoint <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return INF , INF <NEWLINE> <NL> <DEDENT> <DEDENT> PerPoint = ( i + 1 ) * 100 <NEWLINE> <NL> if GetPoint < G : <NEWLINE> <INDENT> ANS = INF , INF <NEWLINE> <COMMENT> <NL> N , GP = F ( i + 1 , n + P [ i ] , GetPoint + PerPoint * P [ i ] + C [ i ] ) <NEWLINE> if N < ANS [ 0 ] : <NEWLINE> <INDENT> ANS = N , GP <NEWLINE> <COMMENT> <NL> <DEDENT> N , GP = F ( i + 1 , n , GetPoint ) <NEWLINE> if N < ANS [ 0 ] : <NEWLINE> <INDENT> ANS = N , GP <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> PupperAll = sum ( [ ( j + 1 ) * 100 * P [ j ] + C [ j ] for j in range ( i + 1 , D ) ] ) <NEWLINE> rN = math . ceil ( ( G - GetPoint - PupperAll ) / PerPoint ) <NEWLINE> if 0 < rN < P [ i ] : <NEWLINE> <INDENT> GP = GetPoint + PerPoint * rN + PupperAll <NEWLINE> N = n + rN + sum ( P [ i + 1 : ] ) <NEWLINE> if N < ANS [ 0 ] : <NEWLINE> <INDENT> ANS = N , GP <NEWLINE> <NL> <DEDENT> <DEDENT> return ANS <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n , GetPoint <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( F ( 0 , 0 , 0 ) [ 0 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <DEDENT> ttl = sum ( A ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b in cnt : <NEWLINE> <INDENT> occ = cnt . pop ( b ) <NEWLINE> cnt [ c ] += occ <NEWLINE> ttl = ttl - b * occ + c * occ <NEWLINE> <NL> <DEDENT> print ( ttl ) <NEWLINE> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n , r ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cards = list ( range ( 1 , n + 1 ) ) [ : : - 1 ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cards = cards [ p - 1 : p - 1 + c ] + cards [ : p - 1 ] + cards [ p - 1 + c : ] <NEWLINE> <DEDENT> print ( cards [ 0 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def distance ( a , b ) : <NEWLINE> <INDENT> dx = abs ( a [ 0 ] - b [ 0 ] ) <NEWLINE> dy = abs ( a [ 1 ] - b [ 1 ] ) <NEWLINE> return math . sqrt ( dx * dx + dy * dy ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( distance ( ( x1 , y1 ) , ( x2 , y2 ) ) ) <NEWLINE> <NL> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( int ( a * min ( b - 1 , n ) / b ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if ( n <= k ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h . sort ( ) <NEWLINE> a = [ ] <NEWLINE> a = h [ : n - k ] <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> s = sum ( a ) <NEWLINE> <NL> L = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for aa in a : <NEWLINE> <INDENT> L [ aa ] += 1 <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L [ c ] += L [ b ] <NEWLINE> s += L [ b ] * ( c - b ) <NEWLINE> L [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp ( n , A , q , M ) <NEWLINE> <NL> <NL> <DEDENT> def combination ( n , A , q , M ) : <NEWLINE> <INDENT> for m in M : <NEWLINE> <INDENT> if m == 0 or solve ( m , A , n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def dp ( n , A , q , M ) : <NEWLINE> <INDENT> M_max = 2000 <NEWLINE> _dp = [ False ] * ( M_max + 1 ) <NEWLINE> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( M_max , 0 , - 1 ) : <NEWLINE> <INDENT> if _dp [ i ] and i + a <= M_max : <NEWLINE> <INDENT> _dp [ i + a ] = True <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> _dp [ a ] = True <NEWLINE> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if _dp [ m ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( m , A , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> for b in product ( [ 0 , 1 ] , repeat = n ) : <NEWLINE> <INDENT> s = sum ( a * bit for a , bit in zip ( A , b ) ) <NEWLINE> if m == s : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def f1 ( n ) : <NEWLINE> <INDENT> for i in range ( 2 ** n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> bit = bin ( i ) [ 2 : ] <NEWLINE> yield map ( int , bit . zfill ( n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> l = [ 0 ] * 100000 <NEWLINE> suml = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> l [ i - 1 ] += 1 <NEWLINE> suml += i <NEWLINE> <DEDENT> for i in bc : <NEWLINE> <INDENT> suml += l [ i [ 0 ] - 1 ] * ( i [ 1 ] - i [ 0 ] ) <NEWLINE> l [ i [ 1 ] - 1 ] += l [ i [ 0 ] - 1 ] <NEWLINE> l [ i [ 0 ] - 1 ] = 0 <NEWLINE> print ( suml ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> l = abs ( a - b ) <NEWLINE> s = abs ( v - w ) <NEWLINE> <NL> if w >= v or l / s > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import time <NEWLINE> start = time . time ( ) <NEWLINE> A , B , N = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> x = ( ( N + 1 ) // B ) * B - 1 <NEWLINE> ans = set ( ) <NEWLINE> ans . add ( ( A * N ) // B - A * ( N // B ) ) <NEWLINE> while x > 0 : <NEWLINE> <INDENT> ans . add ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE> x -= B <NEWLINE> if ( time . time ( ) - start ) > 1.7 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> N , Q = I ( ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = I ( ) <NEWLINE> edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> edge [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> ans = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = I ( ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <DEDENT> que = [ 0 ] <NEWLINE> visited = { 0 } <NEWLINE> while que : <NEWLINE> <INDENT> p = [ ] <NEWLINE> for i in que : <NEWLINE> <INDENT> for j in edge [ i ] : <NEWLINE> <INDENT> if j in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited . add ( j ) <NEWLINE> ans [ j ] += ans [ i ] <NEWLINE> p . append ( j ) <NEWLINE> <DEDENT> <DEDENT> que = p <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> a = 100000000000000 <NEWLINE> m = 0 <NEWLINE> lm = 0 <NEWLINE> rm = 0 <NEWLINE> lt = [ ] <NEWLINE> rt = [ ] <NEWLINE> lb = [ ] <NEWLINE> rb = [ ] <NEWLINE> <NL> for l in c : <NEWLINE> <INDENT> m = max ( m , l [ 0 ] + l [ 1 ] ) <NEWLINE> a = min ( a , l [ 0 ] + l [ 1 ] ) <NEWLINE> if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> rm = max ( rm , l [ 0 ] - l [ 1 ] ) <NEWLINE> <DEDENT> if l [ 0 ] < l [ 1 ] : <NEWLINE> <INDENT> lm = max ( lm , l [ 1 ] - l [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l in c : <NEWLINE> <INDENT> if l [ 0 ] + l [ 1 ] == m : <NEWLINE> <INDENT> rt . append ( l ) <NEWLINE> <DEDENT> if l [ 0 ] + l [ 1 ] == a : <NEWLINE> <INDENT> lb . append ( l ) <NEWLINE> <DEDENT> if l [ 0 ] > l [ 1 ] and l [ 0 ] - l [ 1 ] == rm : <NEWLINE> <INDENT> rb . append ( l ) <NEWLINE> <DEDENT> if l [ 0 ] < l [ 1 ] and l [ 1 ] - l [ 0 ] == lm : <NEWLINE> <INDENT> lt . append ( l ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if len ( lt ) > 0 and len ( rb ) > 0 : <NEWLINE> <INDENT> i = lt [ 0 ] <NEWLINE> j = rb [ 0 ] <NEWLINE> ans = max ( ans , abs ( i [ 0 ] - j [ 0 ] ) + abs ( i [ 1 ] - j [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> if len ( rt ) > 0 and len ( lb ) > 0 : <NEWLINE> <INDENT> i = rt [ 0 ] <NEWLINE> j = lb [ 0 ] <NEWLINE> ans = max ( ans , abs ( i [ 0 ] - j [ 0 ] ) + abs ( i [ 1 ] - j [ 1 ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def solve ( line ) : <NEWLINE> <INDENT> r = line [ 0 ] <NEWLINE> area = round ( ( r * r * math . pi ) , 6 ) <NEWLINE> circumference = round ( ( 2 * r * math . pi ) , 6 ) <NEWLINE> print ( <STRING> . format ( area , circumference ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def answer ( ) : <NEWLINE> <INDENT> line = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> solve ( line ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> answer ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> m = 0 <NEWLINE> s = 1 <NEWLINE> i = 0 <NEWLINE> o = 0 <NEWLINE> while i < a : <NEWLINE> <INDENT> if int ( b [ i ] ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> o = o + 1 <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> while m < a and o == 0 : <NEWLINE> <INDENT> s = s * int ( b [ m ] ) <NEWLINE> m = m + 1 <NEWLINE> if s > 10 ** 18 and o == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> o = o + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if o == 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> S = [ i for i in str ( input ( ) ) ] <NEWLINE> c = Counter ( S ) <NEWLINE> m = c . most_common ( ) <NEWLINE> <NL> n = len ( S ) // 3 <NEWLINE> if len ( S ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( S ) == 2 : <NEWLINE> <INDENT> if len ( m ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( m ) < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( S ) % 3 == 0 : <NEWLINE> <INDENT> if ( m [ 0 ] [ 1 ] == n ) and ( m [ 1 ] [ 1 ] == n ) and ( m [ 2 ] [ 1 ] == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( S ) % 3 == 1 : <NEWLINE> <INDENT> if ( m [ 0 ] [ 1 ] == n + 1 ) and ( m [ 1 ] [ 1 ] == n ) and ( m [ 2 ] [ 1 ] == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( m [ 0 ] [ 1 ] == n + 1 ) and ( m [ 1 ] [ 1 ] == n + 1 ) and ( m [ 2 ] [ 1 ] == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import bisect <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ u ] . append ( v ) <NEWLINE> graph [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> rooted = [ [ ] for _ in range ( n ) ] <NEWLINE> que = [ ( 0 , - 1 ) ] <NEWLINE> while que : <NEWLINE> <INDENT> node , parent = que . pop ( ) <NEWLINE> for child in graph [ node ] : <NEWLINE> <INDENT> if child != parent : <NEWLINE> <INDENT> rooted [ node ] . append ( child ) <NEWLINE> <COMMENT> <NL> que . append ( ( child , node ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> table = [ float ( <STRING> ) ] * n <NEWLINE> lis = [ None ] * n <NEWLINE> def dfs ( node , length = 0 ) : <NEWLINE> <INDENT> p = bisect . bisect_left ( table , a [ node ] ) <NEWLINE> table [ p ] , old = a [ node ] , table [ p ] <NEWLINE> length = max ( p + 1 , length ) <NEWLINE> for child in rooted [ node ] : <NEWLINE> <INDENT> dfs ( child , length ) <NEWLINE> <DEDENT> table [ p ] = old <NEWLINE> lis [ node ] = length <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * map ( str , lis ) , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> table = [ 0 ] * 100001 <NEWLINE> <NL> c = 0 <NEWLINE> s = 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> table [ i ] += 1 <NEWLINE> s += i <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> c = table [ B ] <NEWLINE> s += ( C - B ) * c <NEWLINE> table [ C ] += table [ B ] <NEWLINE> table [ B ] = 0 <NEWLINE> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <COMMENT> <NEWLINE> <NL> def modpow ( x , n , mod ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n % 2 : <NEWLINE> <INDENT> res *= x % mod <NEWLINE> res %= mod <NEWLINE> <DEDENT> x *= x % mod <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> all_p = modpow ( 10 , n , mod ) <NEWLINE> <COMMENT> <NL> not_0 = modpow ( 9 , n , mod ) <NEWLINE> <COMMENT> <NL> not_9 = modpow ( 9 , n , mod ) <NEWLINE> <COMMENT> <NL> not_0_9 = modpow ( 8 , n , mod ) <NEWLINE> <COMMENT> <NL> ans = ( all_p - not_0 - not_9 + not_0_9 ) % mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def check ( aline ) : <NEWLINE> <INDENT> pools = [ ] <NEWLINE> leftedge = [ ] <NEWLINE> <NL> for i , c in enumerate ( aline ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> leftedge . append ( i ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if leftedge : <NEWLINE> <INDENT> left = leftedge . pop ( ) <NEWLINE> w = i - left <NEWLINE> <NL> while pools and left < pools [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> w += pools . pop ( ) [ 1 ] <NEWLINE> <NL> <DEDENT> pools . append ( ( left , w ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return pools <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> al = input ( ) . strip ( ) <NEWLINE> ps = check ( al ) <NEWLINE> <NL> print ( sum ( [ x [ 1 ] for x in ps ] ) ) <NEWLINE> print ( len ( ps ) , * [ x [ 1 ] for x in ps ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> k = S . count ( <STRING> ) <NEWLINE> l = S . count ( <STRING> ) <NEWLINE> m = S . count ( <STRING> ) <NEWLINE> <NL> if abs ( k - l ) <= 1 and abs ( l - m ) <= 1 and abs ( m - k ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import fractions <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> def gcd2 ( x , y , z ) : <NEWLINE> <INDENT> return math . gcd ( math . gcd ( x , y ) , z ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if ( i == j == k ) : <NEWLINE> <INDENT> sum += gcd2 ( i , j , k ) <NEWLINE> <DEDENT> elif i != j and j != k : <NEWLINE> <INDENT> sum += gcd2 ( i , j , k ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += gcd2 ( i , j , k ) * 3 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <STRING> <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> while i + ( num ) * 2 <= n - 1 : <NEWLINE> <INDENT> if s [ i ] != s [ i + num ] and s [ i ] != s [ i + 2 * num ] and s [ i + num ] != s [ i + 2 * num ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) - cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ ] , [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( a ) <NEWLINE> r . append ( b ) <NEWLINE> <DEDENT> num = list ( range ( 1 , n + 1 ) ) <NEWLINE> lmax = max ( l ) <NEWLINE> rmin = min ( r ) <NEWLINE> if lmax > rmin : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gate = set ( range ( lmax , rmin + 1 ) ) <NEWLINE> ans = list ( set ( num ) & gate ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> lis = [ ] <NEWLINE> ans = 0 <NEWLINE> for x in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> lis . append ( math . gcd ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT> for z in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for l in lis : <NEWLINE> <INDENT> ans += math . gcd ( z , l ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Row = int ( input ( ) ) <NEWLINE> QList = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> QList . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> dictA = { } <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dictA . setdefault ( List [ i ] , 0 ) <NEWLINE> dictA [ List [ i ] ] += 1 <NEWLINE> res += List [ i ] <NEWLINE> <DEDENT> num = 0 <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> if QList [ i ] [ 0 ] not in dictA : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = dictA [ QList [ i ] [ 0 ] ] <NEWLINE> res = res - dictA [ QList [ i ] [ 0 ] ] * QList [ i ] [ 0 ] <NEWLINE> dictA [ QList [ i ] [ 0 ] ] = 0 <NEWLINE> dictA . setdefault ( QList [ i ] [ 1 ] , 0 ) <NEWLINE> dictA [ QList [ i ] [ 1 ] ] += num <NEWLINE> res += QList [ i ] [ 1 ] * num <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_cum = [ 0 ] <NEWLINE> B_cum = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A_cum . append ( A_cum [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B_cum . append ( B_cum [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> rest = k - A_cum [ i ] <NEWLINE> if rest < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ans = max ( ans , bisect . bisect_right ( B_cum , rest ) - 1 + i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = 0 <NEWLINE> i = int ( input ( ) ) <NEWLINE> while i != 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> print ( <STRING> + str ( n ) + <STRING> + str ( i ) ) <NEWLINE> i = int ( input ( ) ) <NEWLINE> <DEDENT>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i < K : <NEWLINE> <INDENT> P . append ( str ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S < 10 ** 9 : <NEWLINE> <INDENT> P . append ( str ( S + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P . append ( str ( 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( P ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r_ary = [ ] <NEWLINE> g_ary = [ ] <NEWLINE> b_ary = [ ] <NEWLINE> for i in ( s ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r_ary . append ( i ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g_ary . append ( i ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> b_ary . append ( i ) <NEWLINE> <DEDENT> <DEDENT> r = len ( r_ary ) <NEWLINE> g = len ( g_ary ) <NEWLINE> b = len ( b_ary ) <NEWLINE> first_conditions = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if 2 * j - i < n and s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] and s [ i ] != s [ j ] : <NEWLINE> <INDENT> first_conditions -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( first_conditions ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> result = <STRING> <NEWLINE> if a <= 0 <= b : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif b < 0 and ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = x . copy ( ) <NEWLINE> y . sort ( ) <NEWLINE> z = set ( x ) <NEWLINE> t1 = y [ n // 2 - 1 ] <NEWLINE> t2 = y [ n // 2 ] <NEWLINE> idx = dict ( [ ] ) <NEWLINE> idx [ y [ 0 ] ] = 0 <NEWLINE> l = y [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in y : <NEWLINE> <INDENT> if i == l : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx [ i ] = cnt <NEWLINE> l = i <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in x : <NEWLINE> <INDENT> t = idx [ i ] <NEWLINE> if t < n // 2 : <NEWLINE> <INDENT> print ( t2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for number in A : <NEWLINE> <INDENT> result *= number <NEWLINE> if ( result > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = ( sum ( lst ) ** 2 - sum ( [ z ** 2 for z in lst ] ) ) // 2 <NEWLINE> print ( s % ( pow ( 10 , 9 ) + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // a <NEWLINE> ans += ( y * ( y + 1 ) * a ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> d = { } <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> d . setdefault ( s , 1 ) <NEWLINE> d [ s ] += 1 <NEWLINE> <NL> <DEDENT> d = sorted ( d . items ( ) ) <NEWLINE> d = sorted ( d , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> n = d [ 0 ] [ 1 ] <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if d [ i ] [ 1 ] != n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( d [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( 0 ) <NEWLINE> a . insert ( 0 , 0 ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> s += abs ( a [ i ] - a [ i + 1 ] ) <NEWLINE> <DEDENT> for h in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = abs ( a [ h + 1 ] - a [ h - 1 ] ) - abs ( a [ h ] - a [ h - 1 ] ) - abs ( a [ h + 1 ] - a [ h ] ) <NEWLINE> print ( s + t ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> s = r * r * math . pi <NEWLINE> c = 2 * r * math . pi <NEWLINE> print ( <STRING> . format ( s , c ) ) <NEWLINE>
n , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> value = [ ] <NEWLINE> weight = [ ] <NEWLINE> dp = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> <NL> for el in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> value . append ( x ) <NEWLINE> weight . append ( y ) <NEWLINE> <NL> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> dp [ 0 ] [ w ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for w in range ( W + 1 ) : <NEWLINE> <INDENT> if w >= weight [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i + 1 ] [ w ] = max ( dp [ i ] [ w - weight [ i ] ] + value [ i ] , dp [ i ] [ w ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ w ] = dp [ i ] [ w ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] [ W ] ) <NEWLINE> <NL>
from sys import stdin <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> U = 10 ** 6 + 10 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> readline = stdin . readline <NEWLINE> N = int ( readline ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> ret = 0 <NEWLINE> exist_counts = [ 0 ] * U <NEWLINE> for x in a : <NEWLINE> <INDENT> if exist_counts [ x ] : <NEWLINE> <INDENT> exist_counts [ x ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> idx = x <NEWLINE> while idx < U : <NEWLINE> <INDENT> exist_counts [ idx ] += 1 <NEWLINE> idx += x <NEWLINE> <DEDENT> <DEDENT> for x in a : <NEWLINE> <INDENT> ret += exist_counts [ x ] == 1 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> summ = 0 <NEWLINE> quadsum = 0 <NEWLINE> <NL> for k in range ( n ) : <NEWLINE> <INDENT> summ = ( summ + A [ k ] ) % mod <NEWLINE> quadsum = ( quadsum + A [ k ] * A [ k ] ) % mod <NEWLINE> <NL> <DEDENT> ans = ( summ * summ ) % mod - quadsum <NEWLINE> if ans % 2 == 1 : <NEWLINE> <INDENT> ans += mod <NEWLINE> <DEDENT> ans = ( ans / 2 ) % mod <NEWLINE> print ( int ( ans ) ) <NEWLINE>
import itertools <NEWLINE> a0 , b0 , c0 = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> p = itertools . product ( range ( 3 ) , repeat = k ) <NEWLINE> ans = <STRING> <NEWLINE> for i in p : <NEWLINE> <INDENT> a , b , c = a0 , b0 , c0 <NEWLINE> for ii in i : <NEWLINE> <INDENT> if ii == 0 : <NEWLINE> <INDENT> a = 2 * a <NEWLINE> <DEDENT> elif ii == 1 : <NEWLINE> <INDENT> b = 2 * b <NEWLINE> <DEDENT> elif ii == 2 : <NEWLINE> <INDENT> c = 2 * c <NEWLINE> <NL> <DEDENT> if b > a and c > b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a2 = [ a [ n - 1 ] ] <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> a2 . append ( a2 [ - 1 ] + a [ i - 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans = ( ans + ( a [ i ] * a2 [ - i - 2 ] ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> E = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> E [ a ] . append ( b ) <NEWLINE> E [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> flag = [ False ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> vs = deque ( [ 1 ] ) <NEWLINE> <NL> flag [ 1 ] = True <NEWLINE> res = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> while ( vs ) : <NEWLINE> <INDENT> this_v = vs [ 0 ] <NEWLINE> for i in E [ this_v ] : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res [ i ] = this_v <NEWLINE> flag [ i ] = True <NEWLINE> vs . append ( i ) <NEWLINE> <DEDENT> <DEDENT> vs . popleft ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in res [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ ] <NEWLINE> [ cnt . append ( 0 ) for _ in range ( len ( A ) ) ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> cnt [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
import copy <NEWLINE> <COMMENT> <NL> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a // gcd ( a , b ) ) * b <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> a_lcm = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> a_lcm = lcm ( a_lcm , a ) <NEWLINE> <COMMENT> <NL> if ( a_lcm / 2 ) > m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if ( a_lcm / 2 ) % a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = int ( ( m - ( a_lcm / 2 ) ) // a_lcm ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> res = <STRING> <NEWLINE> if s [ 0 ] != <STRING> : res = <STRING> <NEWLINE> elif s [ 2 : - 1 ] . count ( <STRING> ) != 1 : res = <STRING> <NEWLINE> else : <NEWLINE> <INDENT> li = list ( s ) <NEWLINE> li . remove ( <STRING> ) <NEWLINE> li . remove ( <STRING> ) <NEWLINE> for i in li : <NEWLINE> <INDENT> if i != i . lower ( ) : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import numpy as np <NEWLINE> dic = dict ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> p = 0 <NEWLINE> <NL> def reg ( a , b ) : <NEWLINE> <INDENT> if a < 0 or ( a == 0 and b < 0 ) : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> if b > 0 : <NEWLINE> <INDENT> return 0 , a , b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 , - b , a <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> p += 1 <NEWLINE> continue <NEWLINE> <DEDENT> ab = np . gcd ( a , b ) <NEWLINE> a , b = a // ab , b // ab <NEWLINE> idx , a , b = reg ( a , b ) <NEWLINE> k = ( a , b ) <NEWLINE> if k not in dic . keys ( ) : <NEWLINE> <INDENT> dic [ k ] = [ 0 , 0 ] <NEWLINE> <DEDENT> dic [ k ] [ idx ] += 1 <NEWLINE> <NL> <DEDENT> not_p = 1 <NEWLINE> for k in dic . keys ( ) : <NEWLINE> <INDENT> a , b = k <NEWLINE> pp , pm = dic [ k ] <NEWLINE> not_p *= ( pow ( 2 , pp , mod ) + pow ( 2 , pm , mod ) - 1 ) % mod <NEWLINE> not_p %= mod <NEWLINE> <NL> <DEDENT> print ( ( p + not_p - 1 ) % mod ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> c = [ ] <NEWLINE> for j in zip ( * b ) : <NEWLINE> <INDENT> c . append ( sum ( [ k * l for k , l in zip ( i , j ) ] ) ) <NEWLINE> <DEDENT> print ( * c ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def gg ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 and b % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gg ( b , a % b ) <NEWLINE> <NL> <DEDENT> if x > y : <NEWLINE> <INDENT> print ( gg ( x , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( gg ( y , x ) ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> from copy import copy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> result = [ 0 ] * N <NEWLINE> <NL> if N < 6 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> result [ 5 ] += 1 <NEWLINE> <NL> coord = deque ( ) <NEWLINE> coord . append ( [ [ 1 , 1 , 1 ] , 6 , 0 ] ) <NEWLINE> <NL> while len ( coord ) : <NEWLINE> <INDENT> sol , ans , level = coord . popleft ( ) <NEWLINE> for i in range ( level , 3 ) : <NEWLINE> <INDENT> new_sol = copy ( sol ) <NEWLINE> new_sol [ i ] += 1 <NEWLINE> new_ans = ans + sum ( sol ) + sol [ i ] + 1 <NEWLINE> if new_ans <= N : <NEWLINE> <INDENT> coord . append ( [ new_sol , new_ans , i ] ) <NEWLINE> result [ new_ans - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * result , sep = <STRING> , end = <STRING> ) <NEWLINE> <NL>
import numpy as np <NEWLINE> <NL> <NL> def check ( x ) : <NEWLINE> <INDENT> dp = np . zeros ( k , np . bool ) <NEWLINE> dp [ 0 ] = True <NEWLINE> for e in a [ : x ] + a [ x + 1 : ] : <NEWLINE> <INDENT> dp [ e : ] |= dp [ : - e ] <NEWLINE> <NL> <DEDENT> return dp [ - a [ x ] : ] . any ( ) <NEWLINE> <NL> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> lb = - 1 <NEWLINE> ub = n <NEWLINE> while ub - lb > 1 : <NEWLINE> <INDENT> m = ( lb + ub ) // 2 <NEWLINE> if check ( m ) : <NEWLINE> <INDENT> ub = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lb = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ub ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ret = 0 <NEWLINE> pos = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ret += i - pos <NEWLINE> pos += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
d = { n : <STRING> for n in <STRING> } <NEWLINE> d . update ( { n : <STRING> for n in <STRING> } ) <NEWLINE> d . update ( { <STRING> : <STRING> } ) <NEWLINE> <NL> print ( d [ input ( ) [ - 1 ] ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> f = [ - 1 ] * ( n + 10 ) <NEWLINE> f [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , n + 10 ) : <NEWLINE> <COMMENT> <NL> <INDENT> f [ i ] = f [ i % bin ( i ) . count ( <STRING> ) ] + 1 <NEWLINE> <NL> <DEDENT> init_bitcount = x . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> x_mod_01 = 0 <NEWLINE> x_mod_10 = 0 <NEWLINE> for digit in x : <NEWLINE> <INDENT> x_mod_01 *= 2 <NEWLINE> x_mod_10 *= 2 <NEWLINE> if digit == <STRING> : <NEWLINE> <INDENT> x_mod_01 += 1 <NEWLINE> x_mod_10 += 1 <NEWLINE> <DEDENT> x_mod_01 %= ( init_bitcount + 1 ) <NEWLINE> if init_bitcount != 1 : <NEWLINE> <INDENT> x_mod_10 %= ( init_bitcount - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> power_mod_01 = [ - 1 ] * ( n + 10 ) <NEWLINE> power_mod_01 [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 10 ) : <NEWLINE> <INDENT> power_mod_01 [ i ] = power_mod_01 [ i - 1 ] * 2 % ( init_bitcount + 1 ) <NEWLINE> <NL> <DEDENT> if init_bitcount != 1 : <NEWLINE> <INDENT> power_mod_10 = [ - 1 ] * ( n + 10 ) <NEWLINE> power_mod_10 [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 10 ) : <NEWLINE> <INDENT> power_mod_10 [ i ] = power_mod_10 [ i - 1 ] * 2 % ( init_bitcount - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> first_residue = ( x_mod_01 + power_mod_01 [ n - i - 1 ] ) % ( init_bitcount + 1 ) <NEWLINE> print ( f [ first_residue ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if init_bitcount == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> first_residue = ( x_mod_10 - power_mod_10 [ n - i - 1 ] ) % ( init_bitcount - 1 ) <NEWLINE> print ( f [ first_residue ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <NL> <INDENT> n = int ( s ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> P = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> P . append ( complex ( x , y ) ) <NEWLINE> <NL> <DEDENT> def get_intersections ( p0 , p1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> dist = abs ( p0 - p1 ) <NEWLINE> <NL> if dist > 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> elif dist == 2 : <NEWLINE> <INDENT> return [ ( p0 + p1 ) / 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = ( p0 + p1 ) / 2 <NEWLINE> v = m - p0 <NEWLINE> w = complex ( v . imag , - v . real ) <NEWLINE> n = w / abs ( w ) <NEWLINE> d = abs ( v ) <NEWLINE> l = math . sqrt ( 1 - d ** 2 ) <NEWLINE> <NL> inter0 = m + l * n <NEWLINE> inter1 = m - l * n <NEWLINE> return [ inter0 , inter1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> intersections = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> intersections += get_intersections ( P [ i ] , P [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> counts = [ ] <NEWLINE> <NL> <COMMENT> <NL> for intersection in intersections : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> if abs ( intersection - p ) <= 1.01 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> counts . append ( cnt ) <NEWLINE> <NL> <DEDENT> if counts : <NEWLINE> <INDENT> print ( max ( counts ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> x = x . split ( ) <NEWLINE> y = [ int ( s ) for s in x ] <NEWLINE> dict = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> dict [ <STRING> ] = y [ 0 ] <NEWLINE> dict [ <STRING> ] = y [ 1 ] <NEWLINE> count = 0 <NEWLINE> if dict [ <STRING> ] < dict [ <STRING> ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for N in range ( k ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> dict [ <STRING> ] = dict [ <STRING> ] * 2 <NEWLINE> if dict [ <STRING> ] < dict [ <STRING> ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dict [ <STRING> ] = y [ 2 ] <NEWLINE> if k - count == 0 : <NEWLINE> <INDENT> if dict [ <STRING> ] > dict [ <STRING> ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> i = k - count <NEWLINE> if dict [ <STRING> ] < dict [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for N in range ( i ) : <NEWLINE> <INDENT> dict [ <STRING> ] = dict [ <STRING> ] * 2 <NEWLINE> if dict [ <STRING> ] < dict [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> fact = [ 1 ] <NEWLINE> fact_inv = [ 1 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> fact . append ( fact [ - 1 ] * ( i + 1 ) % MOD ) <NEWLINE> <DEDENT> fact_inv = [ 1 ] * ( m + 1 ) <NEWLINE> fact_inv [ m ] = pow ( fact [ m ] , MOD - 2 , MOD ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> fact_inv [ m - i - 1 ] = fact_inv [ m - i ] * ( m - i ) % MOD <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> ｍPn = fact [ m ] * pow ( fact [ m - n ] , MOD - 2 , MOD ) % MOD <NEWLINE> <NL> a = pow ( mPn , 2 , MOD ) <NEWLINE> b = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> nCr = fact [ n ] * fact_inv [ i ] % MOD * fact_inv [ n - i ] % MOD <NEWLINE> b += ( - 1 ) ** ( i % 2 ) * nCr * fact [ m - i ] % MOD * fact_inv [ m - n ] % MOD <NEWLINE> b %= MOD <NEWLINE> <DEDENT> ans = a + b * mPn <NEWLINE> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <NL>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B - 1 > N : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> print ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> I = [ H [ i + 1 ] - H [ i ] for i in range ( N - 1 ) ] <NEWLINE> N = len ( I ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if I [ i ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif I [ i ] < - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if I [ j ] >= 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif I [ j ] <= - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a_list = [ x ] <NEWLINE> a = x <NEWLINE> i = 1 <NEWLINE> while ( i < n and i < m + 1 ) : <NEWLINE> <INDENT> a = ( a * a ) % m <NEWLINE> a_list . append ( a ) <NEWLINE> i += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if i == n : <NEWLINE> <INDENT> ans = sum ( a_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a_list . index ( a ) <NEWLINE> sum1 = sum ( a_list [ : b + 1 ] ) <NEWLINE> sum2 = sum ( a_list [ b + 1 : i ] ) <NEWLINE> blen = i - b - 1 <NEWLINE> repeat = ( n - b - 1 ) // blen <NEWLINE> amari = ( n - b - 1 ) % blen <NEWLINE> sum3 = 0 <NEWLINE> if amari != 0 : <NEWLINE> <INDENT> sum3 = sum ( a_list [ b + 1 : b + amari + 1 ] ) <NEWLINE> <DEDENT> ans = sum1 + sum2 * repeat + sum3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if i * j <= n - 1 : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * a + 2 * b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ppl = list ( input ( ) ) <NEWLINE> <NL> buff = [ ] <NEWLINE> w = 0 <NEWLINE> e = ppl [ 1 : ] . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> w += ( ppl [ i - 1 ] == <STRING> and 1 or 0 ) <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> e -= ( ppl [ i ] == <STRING> and 1 or 0 ) <NEWLINE> <DEDENT> n = w + e <NEWLINE> buff . append ( n ) <NEWLINE> <NL> <DEDENT> print ( min ( buff ) ) <NEWLINE>
nk = input ( ) . split ( ) <NEWLINE> n , k = int ( nk [ 0 ] ) , int ( nk [ 1 ] ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> t = 1 <NEWLINE> tl = [ 1 ] <NEWLINE> ts = { 1 } <NEWLINE> <NL> <NL> for i in range ( len ( a ) ) : <NEWLINE> <NL> <INDENT> t = a [ t - 1 ] <NEWLINE> if t in ts : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl . append ( t ) <NEWLINE> ts . add ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> tl2 = tl [ tl . index ( t ) : len ( tl ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> if k < len ( tl ) : <NEWLINE> <INDENT> ans = tl [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - len ( tl ) <NEWLINE> j = k % len ( tl2 ) <NEWLINE> ans = tl2 [ j ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> money = 1000 <NEWLINE> stock = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> money += stock * A [ i ] <NEWLINE> stock = 0 <NEWLINE> <DEDENT> elif money >= A [ i ] : <NEWLINE> <INDENT> stock = money // A [ i ] <NEWLINE> money -= stock * A [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( stock * A [ n - 1 ] + money ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> H , W = LI ( ) <NEWLINE> S = [ list ( _S ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> def check ( x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> res = False <NEWLINE> <COMMENT> <NL> dxs = [ - 1 , 1 ] <NEWLINE> dys = [ - 1 , 1 ] <NEWLINE> for dx in dxs : <NEWLINE> <INDENT> nx = x + dx <NEWLINE> ny = y <NEWLINE> if 0 <= nx and nx < H and S [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> res = True <NEWLINE> <DEDENT> <DEDENT> for dy in dys : <NEWLINE> <INDENT> nx = x <NEWLINE> ny = y + dy <NEWLINE> if 0 <= ny and ny < W and S [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> res = True <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> if not check ( i , j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> <NL> <NL> wk = pow ( 26 , K , mod ) <NEWLINE> inv26 = pow ( 26 , - 1 , mod ) <NEWLINE> <NL> ans = wk <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> wk = ( wk * 25 * inv26 ) % mod <NEWLINE> wk = ( wk * ( N - 1 + i ) * pow ( i , - 1 , mod ) % mod ) <NEWLINE> ans = ( ans + wk ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( - 10 , 102 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> sa = [ ] <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> sa . append ( abs ( ans [ i ] - x ) ) <NEWLINE> <DEDENT> MIN = min ( sa ) <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if MIN == abs ( ans [ i ] - x ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> num = int ( input ( ) ) <NEWLINE> <NL> qm = 1000000000000001 <NEWLINE> <NL> alf = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> <COMMENT> <NL> <NL> ans = [ ] <NEWLINE> f = False <NEWLINE> <NL> for i in range ( 12 ) : <NEWLINE> <INDENT> c = ( num - 1 ) % 26 <NEWLINE> ans += alf [ c ] <NEWLINE> num = ( num - 1 ) // 26 <NEWLINE> if num < 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( reversed ( ans ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = set ( a ) <NEWLINE> if len ( set ( a ) ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> def dict_sort ( ans ) : <NEWLINE> <INDENT> ans = sorted ( ans . items ( ) , reverse = True , key = lambda kv : ( kv [ 1 ] ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> def swap ( a , b ) : <NEWLINE> <INDENT> temp = a <NEWLINE> a = b <NEWLINE> b = temp <NEWLINE> return a , b <NEWLINE> <COMMENT> <NL> <DEDENT> def seive_primes ( n ) : <NEWLINE> <INDENT> flag = [ 0 ] * ( n + 10 ) <NEWLINE> flag [ 1 ] = flag [ 0 ] = 1 <NEWLINE> i = 2 <NEWLINE> while i * i <= n + 1 : <NEWLINE> <INDENT> if flag [ i ] == 0 : <NEWLINE> <INDENT> j = i * i <NEWLINE> while j <= n + 1 : <NEWLINE> <INDENT> flag [ j ] = 1 <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return flag <NEWLINE> <COMMENT> <NL> <DEDENT> def checkRecursive ( x , n , curr_num = 1 , curr_sum = 0 ) : <NEWLINE> <INDENT> results = 0 <NEWLINE> p = curr_num ** n <NEWLINE> while ( p + curr_sum < x ) : <NEWLINE> <INDENT> results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) <NEWLINE> curr_num = curr_num + 1 <NEWLINE> p = curr_num ** n <NEWLINE> <DEDENT> if ( p + curr_sum == x ) : <NEWLINE> <INDENT> results = results + 1 <NEWLINE> <DEDENT> return results <NEWLINE> <COMMENT> <NL> <DEDENT> def findMinSwap ( arr , n ) : <NEWLINE> <INDENT> vec = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> vec . append ( [ arr [ i ] , i ] ) <NEWLINE> <DEDENT> vec = sorted ( vec ) <NEWLINE> ans , c , j = - 1 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( vec [ i ] [ 1 ] == i ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vec [ i ] [ 0 ] , vec [ vec [ i ] [ 1 ] ] [ 1 ] = swap ( vec [ i ] [ 0 ] , vec [ vec [ i ] [ 1 ] ] [ 1 ] ) <NEWLINE> vec [ i ] [ 1 ] , vec [ vec [ i ] [ 1 ] ] [ 1 ] = swap ( vec [ i ] [ 1 ] , vec [ vec [ i ] [ 1 ] ] [ 1 ] ) <NEWLINE> <DEDENT> if ( i != vec [ i ] [ 1 ] ) : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <COMMENT> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <COMMENT> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <COMMENT> <NL> <DEDENT> def alphabates ( ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> def binary_search ( ls , n , flag ) : <NEWLINE> <INDENT> low = 0 <NEWLINE> hi = n - 1 <NEWLINE> while ( low <= hi ) : <NEWLINE> <INDENT> mid = ( low + hi ) // 2 <NEWLINE> if ls [ mid ] == flag : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> elif ls [ mid ] > flag : <NEWLINE> <INDENT> hi = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> def Binary ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> binary = <STRING> <NEWLINE> i = 0 <NEWLINE> while n > 0 and i <= 8 : <NEWLINE> <INDENT> s1 = str ( int ( n % 2 ) ) <NEWLINE> binary = binary + s1 <NEWLINE> n /= 2 <NEWLINE> i = i + 1 <NEWLINE> d = binary [ : : - 1 ] <NEWLINE> <DEDENT> return d <NEWLINE> <COMMENT> <NL> <DEDENT> def qdrt ( x , a , b , c ) : <NEWLINE> <INDENT> return a * x * x + b * x + c <NEWLINE> <COMMENT> <NL> <DEDENT> def inp ( ) : <NEWLINE> <INDENT> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return ls <NEWLINE> <COMMENT> <NL> <DEDENT> def mult_inp ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> def knapSack ( W , wt , val , n ) : <NEWLINE> <INDENT> K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for w in range ( W + 1 ) : <NEWLINE> <INDENT> if i == 0 or w == 0 : <NEWLINE> <INDENT> K [ i ] [ w ] = 0 <NEWLINE> <DEDENT> elif wt [ i - 1 ] <= w : <NEWLINE> <INDENT> K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K [ i ] [ w ] = K [ i - 1 ] [ w ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return K [ n ] [ W ] <NEWLINE> <COMMENT> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ls = inp ( ) <NEWLINE> ans = sum ( ls ) ** 2 <NEWLINE> sq = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sq += ls [ i ] ** 2 <NEWLINE> <DEDENT> print ( ( ( ans - sq ) // 2 ) % 1000000007 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> ve = math . floor ( math . sqrt ( N ) ) <NEWLINE> for st in range ( ve ) : <NEWLINE> <INDENT> tmp = math . floor ( N / ( st + 1 ) - 0.000001 ) <NEWLINE> score = 2 * ( tmp - st ) <NEWLINE> if score > 0 : <NEWLINE> <INDENT> score -= 1 <NEWLINE> <DEDENT> ans += score <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_count = s . count ( <STRING> ) <NEWLINE> g_count = s . count ( <STRING> ) <NEWLINE> b_count = s . count ( <STRING> ) <NEWLINE> <NL> discount = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = i + 2 * ( j - i ) <NEWLINE> if k > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> discount += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r_count * g_count * b_count - discount ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> s = [ <STRING> . join ( sorted ( list ( SS ( ) ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> cnt = collections . Counter ( s ) <NEWLINE> ans = sum ( [ i * ( i - 1 ) // 2 for i in cnt . values ( ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> x = math . floor ( math . pow ( P , 1 / N ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x += 1 <NEWLINE> for i in range ( x , 0 , - 1 ) : <NEWLINE> <INDENT> if P % pow ( i , N ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> <NL> pattern = re . compile ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> print ( len ( re . search ( pattern , input ( ) ) . group ( 0 ) ) ) <NEWLINE> <DEDENT> except AttributeError : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> X , N = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ALL = list ( int ( i ) for i in range ( - 100 , 201 ) ) <NEWLINE> P . sort ( ) <NEWLINE> Q = list ( set ( P ) ^ set ( ALL ) ) <NEWLINE> number = bisect . bisect ( Q , X ) <NEWLINE> <NL> if number == 0 : <NEWLINE> <INDENT> print ( Q [ 0 ] ) <NEWLINE> <DEDENT> elif number == len ( Q ) : <NEWLINE> <INDENT> print ( Q [ len ( Q ) - 1 ] ) <NEWLINE> <DEDENT> elif X - Q [ number - 1 ] <= Q [ number ] - X : <NEWLINE> <INDENT> print ( Q [ number - 1 ] ) <NEWLINE> <DEDENT> elif X - Q [ number - 1 ] > Q [ number ] - X : <NEWLINE> <INDENT> print ( Q [ number ] ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a >= k ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a + b >= k ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> import copy <NEWLINE> N = input ( ) <NEWLINE> N = np . int64 ( N ) <NEWLINE> <COMMENT> <NL> l = [ ] <NEWLINE> x = 2 <NEWLINE> xen = np . sqrt ( N ) <NEWLINE> while N > 1 : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> l . append ( x ) <NEWLINE> N = N / x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x + 1 <NEWLINE> if x > xen : <NEWLINE> <INDENT> l . append ( int ( N ) ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> l2 = [ ] <NEWLINE> while l != [ ] : <NEWLINE> <COMMENT> <NL> <INDENT> i = l [ 0 ] <NEWLINE> n = l . count ( i ) <NEWLINE> l = l [ n : ] <NEWLINE> l2 . append ( n ) <NEWLINE> if l == [ ] : break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> i = 0 <NEWLINE> m = 0 <NEWLINE> l2 = np . array ( l2 ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> l2 = l2 - i <NEWLINE> l2 = l2 [ l2 >= 0 ] <NEWLINE> ans = ans + len ( l2 ) <NEWLINE> <COMMENT> <NL> if len ( l2 ) == 0 : break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> counter = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if len ( [ i for i in s if i % 2 == 0 ] ) == 1 : <NEWLINE> <INDENT> s = [ i for i in s if i % 2 == 0 ] <NEWLINE> print ( int ( s [ 0 ] ) * ( 2 ** counter ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = [ i / 2 for i in s ] <NEWLINE> counter += 1 <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s += gcd ( i , gcd ( j , l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> total = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> S = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> S [ i ] += 1 <NEWLINE> <NL> <DEDENT> for s in S [ 1 : ] : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> se = set ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> tmp = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> for i in tmp : <NEWLINE> <INDENT> cmd , v = i <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> if v in se : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> se . add ( v ) <NEWLINE> <DEDENT> <DEDENT>
chr = input ( ) . split ( ) <NEWLINE> a = ( int ( chr [ 2 ] ) - int ( chr [ 0 ] ) ) * 60 + ( int ( chr [ 3 ] ) - int ( chr [ 1 ] ) ) - int ( chr [ - 1 ] ) <NEWLINE> print ( a ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if X == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A_history = [ - 1 ] * M <NEWLINE> sum_history = [ 0 ] * ( M + 1 ) <NEWLINE> A = X <NEWLINE> all_sum = A <NEWLINE> <NL> sum_history [ 0 ] = A <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> Anext = ( A * A ) % M <NEWLINE> all_sum += Anext <NEWLINE> sum_history [ i + 1 ] = all_sum <NEWLINE> if A_history [ A ] == - 1 : <NEWLINE> <INDENT> A_history [ A ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = Anext <NEWLINE> <NL> <DEDENT> if i >= N : <NEWLINE> <INDENT> print ( sum_history [ N - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cycle_start = A_history [ A ] <NEWLINE> cycle_end = i - 1 <NEWLINE> cycle_length = cycle_end - cycle_start + 1 <NEWLINE> cycle_time = N - cycle_start <NEWLINE> cycle_count = cycle_time // cycle_length <NEWLINE> cycle_mod = cycle_time % cycle_length <NEWLINE> ans = sum_history [ cycle_start ] + ( sum_history [ cycle_end + 1 ] - sum_history [ cycle_start ] ) * cycle_count + ( sum_history [ cycle_start + cycle_mod - 1 ] - sum_history [ cycle_start ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> MOD2 = 998244353 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> AB = [ NLI ( ) for _ in range ( N ) ] <NEWLINE> <NL> for n in range ( N - 2 ) : <NEWLINE> <INDENT> if AB [ n ] [ 0 ] == AB [ n ] [ 1 ] : <NEWLINE> <INDENT> if AB [ n + 1 ] [ 0 ] == AB [ n + 1 ] [ 1 ] : <NEWLINE> <INDENT> if AB [ n + 2 ] [ 0 ] == AB [ n + 2 ] [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MAP1 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> Q = [ tuple ( MAP1 ( ) ) for _ in range ( n - 1 ) ] <NEWLINE> <NL> deg = [ 0 ] * n <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> color = dict ( ) <NEWLINE> <NL> for a , b in Q : <NEWLINE> <INDENT> deg [ a ] += 1 <NEWLINE> deg [ b ] += 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def dfs ( s , p ) : <NEWLINE> <INDENT> nouse = - 1 <NEWLINE> if p > - 1 : <NEWLINE> <INDENT> nouse = color [ ( min ( s , p ) , max ( s , p ) ) ] <NEWLINE> <DEDENT> c = 1 <NEWLINE> for t in adj [ s ] : <NEWLINE> <INDENT> if t == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c == nouse : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> color [ ( min ( s , t ) , max ( s , t ) ) ] = c <NEWLINE> dfs ( t , s ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , - 1 ) <NEWLINE> <NL> print ( max ( deg ) ) <NEWLINE> for a , b in Q : <NEWLINE> <INDENT> print ( color [ ( a , b ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . rstrip ( ) . rsplit ( ) ) ) <NEWLINE> A_dict = { } <NEWLINE> <NL> for val in A : <NEWLINE> <INDENT> A_dict [ val ] = A_dict . get ( val , 0 ) + 1 <NEWLINE> <NL> <DEDENT> limit = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> <NL> if A_dict . get ( 0 , 0 ) > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for val in A_dict : <NEWLINE> <INDENT> ans *= val ** A_dict [ val ] <NEWLINE> <NL> if ans > limit : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
d = input ( ) . split ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> p = [ ( - 1 , 2 , 4 , 1 , 3 , - 1 ) , ( 3 , - 1 , 0 , 5 , - 1 , 2 ) , ( 1 , 5 , - 1 , - 1 , 0 , 4 ) , <NEWLINE> ( 4 , 0 , - 1 , - 1 , 5 , 1 ) , ( 2 , - 1 , 5 , 0 , - 1 , 3 ) , ( - 1 , 3 , 1 , 4 , 2 , - 1 ) ] <NEWLINE> ts = [ i for i , x in enumerate ( d ) if x == a [ 0 ] ] <NEWLINE> fs = [ i for i , x in enumerate ( d ) if x == a [ 1 ] ] <NEWLINE> b = 0 <NEWLINE> for t in ts : <NEWLINE> <INDENT> for f in fs : <NEWLINE> <INDENT> if t == f : continue <NEWLINE> r = p [ t ] [ f ] <NEWLINE> if r == - 1 : continue <NEWLINE> l = [ d [ t ] , d [ f ] , d [ r ] , d [ 5 - r ] , d [ 5 - f ] , d [ 5 - t ] ] <NEWLINE> if a == l : b += 1 ; break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) if b > 0 else print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> D [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> print ( D [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> XY = list ( list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( N ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x1 , y1 = XY [ i ] <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> x2 , y2 = XY [ j ] <NEWLINE> x = x2 - x1 <NEWLINE> y = y2 - y1 <NEWLINE> d [ x , y ] += 1 <NEWLINE> d [ - x , - y ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( N - max ( d . values ( ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> <NL> def solve ( n , k , ppp , ccc ) : <NEWLINE> <INDENT> NINF = - ( 10 ** 18 ) <NEWLINE> ans = NINF <NEWLINE> <NL> checked = [ False ] * n <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> if checked [ s ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> checked [ s ] = True <NEWLINE> scores = [ ccc [ ppp [ s ] ] ] <NEWLINE> v = ppp [ s ] <NEWLINE> while v != s : <NEWLINE> <INDENT> scores . append ( ccc [ ppp [ v ] ] ) <NEWLINE> checked [ v ] = True <NEWLINE> v = ppp [ v ] <NEWLINE> <NL> <DEDENT> l = len ( scores ) <NEWLINE> d , m = divmod ( k , l ) <NEWLINE> loop = sum ( scores ) <NEWLINE> <NL> if d > 0 : <NEWLINE> <INDENT> d -= 1 <NEWLINE> m += l <NEWLINE> <NL> <DEDENT> scores += scores * 2 <NEWLINE> scores . insert ( 0 , 0 ) <NEWLINE> acc = list ( accumulate ( scores ) ) <NEWLINE> tmp = max ( max ( acc [ i + 1 : i + m + 1 ] ) - acc [ i ] for i in range ( l ) ) <NEWLINE> ans = max ( ans , tmp , loop * d + tmp ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ppp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ppp = [ p - 1 for p in ppp ] <NEWLINE> ccc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( solve ( n , k , ppp , ccc ) ) <NEWLINE>
import copy <NEWLINE> import heapq <NEWLINE> <NL> from typing import List , Tuple <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ ] <NEWLINE> for _ in range ( d ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> v . append ( ( p , c ) ) <NEWLINE> <NL> <DEDENT> print ( ag ( v , g ) ) <NEWLINE> <NL> <NL> <DEDENT> def ag ( v : List [ Tuple [ int , int ] ] , g : int ) -> int : <NEWLINE> <INDENT> rs = [ ] <NEWLINE> <COMMENT> <NL> v = [ ( i , p , c ) for i , ( p , c ) in enumerate ( v , 1 ) ] <NEWLINE> <NL> for j in range ( 2 ** len ( v ) ) : <NEWLINE> <INDENT> cb = [ ] <NEWLINE> for k in range ( len ( v ) ) : <NEWLINE> <INDENT> if ( ( j >> k ) & 1 ) : <NEWLINE> <INDENT> cb . append ( v [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> sc = 0 <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> for ( i , p , c ) in cb : <NEWLINE> <INDENT> sc += i * 100 * p + c <NEWLINE> cnt += p <NEWLINE> <NL> <DEDENT> vv = [ x for x in copy . copy ( v ) if not x in cb ] <NEWLINE> while sc < g : <NEWLINE> <INDENT> if not vv : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i , p , _ = vv . pop ( ) <NEWLINE> for _ in range ( p - 1 ) : <NEWLINE> <INDENT> if sc >= g : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sc += i * 100 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if sc >= g : <NEWLINE> <INDENT> heapq . heappush ( rs , cnt ) <NEWLINE> <DEDENT> <DEDENT> return heapq . heappop ( rs ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> l = <STRING> <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> l += i . lower ( ) . rstrip ( ) <NEWLINE> <DEDENT> word = <STRING> <NEWLINE> for i in word : <NEWLINE> <INDENT> n = l . count ( i ) <NEWLINE> print ( <STRING> . format ( i , n ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for e in a : <NEWLINE> <INDENT> sum_a *= e <NEWLINE> if sum_a > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if sum_a > 1e18 : <NEWLINE> <INDENT> sum_a = - 1 <NEWLINE> <NL> <DEDENT> print ( sum_a ) <NEWLINE>
( N , K ) = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> route = [ 1 ] <NEWLINE> App = [ 0 ] * N <NEWLINE> past = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> past = A [ past - 1 ] <NEWLINE> if App [ past - 1 ] == 1 : <NEWLINE> <INDENT> loop = ( route . index ( past ) , i + 1 ) <NEWLINE> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> App [ past - 1 ] = 1 <NEWLINE> flag = 1 <NEWLINE> route . append ( past ) <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( route [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( route [ loop [ 0 ] + ( K - loop [ 0 ] ) % ( loop [ 1 ] - loop [ 0 ] ) ] ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - ( i + j ) <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> goto = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> l = [ [ _ , 0 ] for _ in range ( 2 * n ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> cnt = [ 0 for _ in range ( n + 1 ) ] <COMMENT> <NEWLINE> <NL> tmp = 1 <NEWLINE> for i in range ( 1 , 2 * n ) : <NEWLINE> <INDENT> l [ i ] [ 1 ] = tmp <NEWLINE> cnt [ l [ i ] [ 1 ] ] += 1 <NEWLINE> tmp = goto [ tmp ] <NEWLINE> if cnt [ l [ i ] [ 1 ] ] == 2 : <NEWLINE> <INDENT> x = l [ i ] <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if l [ j ] [ 1 ] == x [ 1 ] : <NEWLINE> <INDENT> y = l [ j ] <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if y [ 0 ] > k : <NEWLINE> <INDENT> print ( l [ k + 1 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = ( k - y [ 0 ] + 1 ) % ( x [ 0 ] - y [ 0 ] ) + y [ 0 ] <NEWLINE> print ( l [ z ] [ 1 ] ) <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> AB = sorted ( AB ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> K -= AB [ i ] [ 1 ] <NEWLINE> if K <= 0 : <NEWLINE> <INDENT> print ( AB [ i ] [ 0 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> import itertools <NEWLINE> <NL> N = int ( input ( ) ) <COMMENT> <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> b_counts = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b_count = bisect . bisect_left ( A , B [ i ] ) <NEWLINE> b_counts [ i ] = b_count <NEWLINE> <NL> <DEDENT> cumsum_b_counts = list ( itertools . accumulate ( b_counts ) ) <NEWLINE> cumsum_b_counts = [ 0 ] + cumsum_b_counts <NEWLINE> <NL> <COMMENT> <NL> total = 0 <NEWLINE> for c in C : <NEWLINE> <INDENT> count = bisect . bisect_left ( B , c ) <NEWLINE> total += cumsum_b_counts [ count ] <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> min_a = a [ 0 ] <NEWLINE> max_a = a [ n - 1 ] <NEWLINE> <COMMENT> <NL> dic = Counter ( a ) <NEWLINE> <COMMENT> <NL> check = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] not in check : <NEWLINE> <INDENT> if dic [ a [ i ] ] >= 2 : <NEWLINE> <INDENT> check . add ( a [ i ] ) <NEWLINE> <DEDENT> for j in range ( 2 , int ( ( max_a ) / a [ i ] ) + 1 ) : <NEWLINE> <INDENT> check . add ( a [ i ] * j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] not in check : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> if K < 1 / 2 * ( S - x ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for y in range ( min ( S - x + 1 , K + 1 ) ) : <NEWLINE> <INDENT> if K < ( S - x - y ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> kkn = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> MOD = 998244353 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dpac = [ 0 ] * ( n + 1 ) <NEWLINE> dpac [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for kl , kr in kkn : <NEWLINE> <INDENT> l = i - kr <NEWLINE> r = i - kl <NEWLINE> if r < 0 : continue <NEWLINE> l = max ( l , 0 ) <NEWLINE> dp [ i ] += dpac [ r ] - dpac [ l - 1 ] <NEWLINE> dp [ i ] %= MOD <NEWLINE> <DEDENT> dpac [ i ] = dpac [ i - 1 ] + dp [ i ] <NEWLINE> dpac [ i ] %= MOD <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = min ( a , b ) <NEWLINE> d = max ( a , b ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( c ) : <NEWLINE> <INDENT> if c % ( i + 1 ) == 0 and d % ( i + 1 ) == 0 : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ - k ] ) <NEWLINE>
n , * l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> p = [ 0 , 0 ] <NEWLINE> d = [ 0 , 0 ] <NEWLINE> i = 0 <NEWLINE> for l in l : d += max ( l + d [ - 2 ] , [ d , p ] [ i & 1 ] [ - 1 ] ) , ; p += l + p [ - 2 ] , ; i += 1 <NEWLINE> print ( d [ - 1 ] ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> N = int ( stdin . readline ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> R = set ( ) <NEWLINE> G = set ( ) <NEWLINE> B = set ( ) <NEWLINE> for i , s in enumerate ( S , 1 ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> R . add ( i ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> G . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> b = len ( B ) <NEWLINE> ans = 0 <NEWLINE> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> M = max ( r , g ) <NEWLINE> m = min ( r , g ) <NEWLINE> if 2 * m - M in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 2 * M - m in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ( M + m ) / 2 in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> ans += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def cross ( a , b ) : <NEWLINE> <INDENT> return a . real * b . imag - a . imag * b . real <NEWLINE> <NL> <NL> <DEDENT> def cross_point ( c , d ) : <NEWLINE> <INDENT> l = d - c <NEWLINE> v1 = cross ( lv , l ) <NEWLINE> v2 = cross ( lv , lt - c ) <NEWLINE> return c + v2 / v1 * l <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> points = [ complex ( * map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> point0 = points . pop ( 0 ) <NEWLINE> points . append ( point0 ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> while q : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> ls , lt = ( x1 + 1j * y1 , x2 + 1j * y2 ) <NEWLINE> lv = lt - ls <NEWLINE> <NL> area = 0 <NEWLINE> prev = point0 <NEWLINE> prev_flag = cross ( lv , prev - ls ) >= 0 <NEWLINE> cp1 , cp2 = None , None <NEWLINE> for p in points : <NEWLINE> <INDENT> curr_flag = cross ( lv , p - ls ) >= 0 <NEWLINE> if prev_flag and curr_flag : <NEWLINE> <INDENT> area += cross ( prev , p ) <NEWLINE> <DEDENT> elif prev_flag != curr_flag : <NEWLINE> <INDENT> cp = cross_point ( prev , p ) <NEWLINE> if prev_flag : <NEWLINE> <INDENT> area += cross ( prev , cp ) <NEWLINE> cp1 = cp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> area += cross ( cp , p ) <NEWLINE> cp2 = cp <NEWLINE> <DEDENT> <DEDENT> prev , prev_flag = p , curr_flag <NEWLINE> <DEDENT> if cp1 is not None and cp2 is not None : <NEWLINE> <INDENT> area += cross ( cp1 , cp2 ) <NEWLINE> <DEDENT> print ( area / 2 ) <NEWLINE> q -= 1 <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> count = X // D <NEWLINE> <NL> <NL> <NL> if X >= 0 : <NEWLINE> <INDENT> if K <= count : <NEWLINE> <INDENT> ans = X - D * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = X - D * count <NEWLINE> if ( ( K - count ) % 2 == 1 ) : <NEWLINE> <INDENT> ans = ans - D <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K <= ( - 1 ) * count : <NEWLINE> <INDENT> ans = X + D * K <NEWLINE> <DEDENT> elif X % D == 0 : <NEWLINE> <INDENT> ans = X - D * count <NEWLINE> if ( ( K + count ) % 2 == 1 ) : <NEWLINE> <INDENT> ans = ans + D <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = X - D * ( count + 1 ) <NEWLINE> if ( ( K + count + 1 ) % 2 == 1 ) : <NEWLINE> <INDENT> ans = ans + D <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans < 0 : <NEWLINE> <INDENT> ans = ans * ( - 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> opp = a [ a [ i - 1 ] - 1 ] <NEWLINE> if i == opp : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
n , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A , B = map ( sorted , [ AB [ : : 2 ] , AB [ 1 : : 2 ] ] ) <NEWLINE> mid = n // 2 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> a0 , a1 = A [ mid - 1 ] , A [ mid ] <NEWLINE> b0 , b1 = B [ mid - 1 ] , B [ mid ] <NEWLINE> print ( b0 + b1 - ( a0 + a1 ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ mid ] - A [ mid ] + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> V , E = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> <NL> adj = [ [ ] for i in range ( V ) ] <NEWLINE> <NL> for i in range ( E ) : <NEWLINE> <INDENT> s , t = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> import collections <NEWLINE> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> S = collections . deque ( ) <NEWLINE> indices = [ None ] * V <NEWLINE> lowlink = [ None ] * V <NEWLINE> onStack = [ False ] * V <NEWLINE> index = 0 <NEWLINE> scc_id = [ None ] * V <NEWLINE> <NL> def strong_connect ( v ) : <NEWLINE> <INDENT> global index <NEWLINE> indices [ v ] = index <NEWLINE> lowlink [ v ] = index <NEWLINE> index += 1 <NEWLINE> S . append ( v ) <NEWLINE> onStack [ v ] = True <NEWLINE> <NL> for w in adj [ v ] : <NEWLINE> <INDENT> if indices [ w ] == None : <NEWLINE> <INDENT> strong_connect ( w ) <NEWLINE> lowlink [ v ] = min ( lowlink [ v ] , lowlink [ w ] ) <NEWLINE> <DEDENT> elif onStack [ w ] : <NEWLINE> <INDENT> lowlink [ v ] = min ( lowlink [ v ] , indices [ w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if lowlink [ v ] == indices [ v ] : <NEWLINE> <INDENT> while S : <NEWLINE> <INDENT> w = S . pop ( ) <NEWLINE> onStack [ w ] = False <NEWLINE> scc_id [ w ] = v <NEWLINE> if w == v : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for v in range ( V ) : <NEWLINE> <INDENT> if not indices [ v ] : <NEWLINE> <INDENT> strong_connect ( v ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> Q = file_input . readline ( ) <NEWLINE> <NL> for line in file_input : <NEWLINE> <INDENT> u , v = map ( int , line . split ( ) ) <NEWLINE> if scc_id [ u ] == scc_id [ v ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for s in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ s ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> limit = pow ( 10 , 18 ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for e in nums : <NEWLINE> <INDENT> if ans > limit / e : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= e <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > limit : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> nums = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> nums [ i ] += 1 <NEWLINE> <DEDENT> nsum = sum ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , map ( int , input ( ) . split ( ) ) ) <NEWLINE> nsum = nsum + ( c - b ) * nums [ b ] <NEWLINE> print ( nsum ) <NEWLINE> nums [ c ] += nums [ b ] <NEWLINE> nums [ b ] = 0 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> l [ a - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> for x in l : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = 1 <NEWLINE> div = int ( 1e9 ) + 7 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = num * i % div <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> from bisect import bisect_right <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * N ] <NEWLINE> <NL> def bitdp ( items ) : <NEWLINE> <INDENT> n = len ( items ) <NEWLINE> dp = [ ( 0 , 0 ) for _ in [ 0 ] * ( 2 ** n ) ] <NEWLINE> for bitset in range ( 1 , 2 ** n ) : <NEWLINE> <INDENT> for item_num , ( item_v , item_w ) in enumerate ( items ) : <NEWLINE> <INDENT> if bitset & 2 ** item_num : <NEWLINE> <INDENT> w , v = dp [ bitset - 2 ** item_num ] <NEWLINE> if w + item_w <= W : <NEWLINE> <INDENT> dp [ bitset ] = ( w + item_w , v + item_v ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dp . sort ( ) <NEWLINE> l , maxv , inf = [ ( 0 , 0 ) ] , 0 , float ( <STRING> ) <NEWLINE> append = l . append <NEWLINE> for item , ( w , v ) , ( nextw , _ ) in zip ( dp , dp , dp [ 1 : ] + [ ( inf , inf ) ] ) : <NEWLINE> <INDENT> if w < nextw and maxv < v : <NEWLINE> <INDENT> append ( item ) <NEWLINE> maxv = v <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> dp1 = bitdp ( a [ : N // 2 ] ) <NEWLINE> dp2 = bitdp ( a [ N // 2 : ] ) <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> result = 0 <NEWLINE> for w , v in dp1 : <NEWLINE> <INDENT> total = v + dp2 [ bisect_right ( dp2 , ( W - w , inf ) ) - 1 ] [ 1 ] <NEWLINE> if result < total : <NEWLINE> <INDENT> result = total <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = { } <NEWLINE> y = { } <NEWLINE> dic = { } <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> dic [ ( a , b ) ] = 1 <NEWLINE> x [ a ] = x . get ( a , 0 ) + 1 <NEWLINE> y [ b ] = y . get ( b , 0 ) + 1 <NEWLINE> <DEDENT> p = max ( x . values ( ) ) <NEWLINE> q = max ( y . values ( ) ) <NEWLINE> cnt = 1 <NEWLINE> a = [ i for i in x if x [ i ] == p ] <NEWLINE> b = [ j for j in y if y [ j ] == q ] <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> if dic . get ( ( i , j ) , - 1 ) == - 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not cnt : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( p + q - cnt ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAP = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> IN = lambda : int ( input ( ) ) <NEWLINE> S = lambda : input ( ) <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> m = 10 ** 6 + 1 <NEWLINE> sieve = [ - 1 ] * m <NEWLINE> n = IN ( ) <NEWLINE> a = sorted ( LI ( ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> for j in range ( 2 * i , m , i ) : <NEWLINE> <INDENT> sieve [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sieve [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if sieve [ i ] == - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = deque ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> total = sum ( a ) <NEWLINE> sm = 0 <NEWLINE> while len ( a ) > 1 : <NEWLINE> <INDENT> sm += a . pop ( ) <NEWLINE> ans = min ( abs ( 2 * sm - total ) , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> y = abs ( x ) // d <NEWLINE> if y >= k : <NEWLINE> <INDENT> ans = abs ( abs ( x ) - d * k ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ( k - y ) % 2 == 0 : <NEWLINE> <INDENT> ans = abs ( abs ( x ) - d * y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( abs ( abs ( x ) - d * y + d ) , abs ( abs ( x ) - d * y - d ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from bisect import bisect_left , insort <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> src = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> A , B = [ ] , [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = src [ i ] , src [ - i - 1 ] <NEWLINE> addA = False <NEWLINE> addB = False <NEWLINE> <NL> if a != b : <NEWLINE> <INDENT> j = bisect_left ( B , a ) <NEWLINE> if j != len ( B ) and B [ j ] == a : <NEWLINE> <INDENT> del B [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> addA = True <NEWLINE> <NL> <DEDENT> j = bisect_left ( A , b ) <NEWLINE> if j != len ( A ) and A [ j ] == b : <NEWLINE> <INDENT> del A [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insort ( B , b ) <NEWLINE> <NL> <DEDENT> if addA : <NEWLINE> <INDENT> insort ( A , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( A ) == len ( B ) == 0 : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE> <NL>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 , 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 , 1 ) : <NEWLINE> <INDENT> for k in range ( j , N + 1 , 1 ) : <NEWLINE> <INDENT> list = [ i , j , k ] <NEWLINE> ff = len ( set ( list ) ) <NEWLINE> a = math . gcd ( i , j ) <NEWLINE> b = math . gcd ( a , k ) <NEWLINE> if ff == 1 : <NEWLINE> <INDENT> ans += b <NEWLINE> <DEDENT> elif ff == 2 : <NEWLINE> <INDENT> ans += 3 * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import Counter , deque <NEWLINE> <COMMENT> <NL> from itertools import combinations , permutations , accumulate , groupby , product <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = input ( ) . rstrip ( ) <NEWLINE> n = n [ : : - 1 ] <NEWLINE> res = [ 0 ] * 2019 <NEWLINE> res [ 0 ] += 1 <NEWLINE> b = 1 <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> a = int ( n [ i ] ) <NEWLINE> c += a * b <NEWLINE> c %= 2019 <NEWLINE> res [ c ] += 1 <NEWLINE> b = b * 10 % 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in res : <NEWLINE> <INDENT> if i >= 2 : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import operator <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> a , b = map ( int , readline ( ) . split ( ) ) <NEWLINE> c = set ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ ( i , abs ( i - a ) ) for i in range ( 0 , 102 ) if i not in c ] <NEWLINE> L . sort ( key = operator . itemgetter ( 1 ) ) <NEWLINE> print ( L [ 0 ] [ 0 ] ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> mS = [ ] <NEWLINE> d = len ( S ) - len ( T ) <NEWLINE> m = 0 <NEWLINE> <NL> if len ( S ) == len ( T ) : <NEWLINE> <INDENT> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> for j in range ( d ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mS . append ( m ) <NEWLINE> S = S [ 1 : ] <NEWLINE> <DEDENT> print ( min ( mS ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> hb = sum ( L ) <NEWLINE> val = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> val += L [ i ] <NEWLINE> total += L [ i ] * ( hb - val ) <NEWLINE> <DEDENT> print ( total % mod ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_l = [ 0 ] * n <NEWLINE> for i in A : <NEWLINE> <INDENT> ans_l [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans_l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , d , mods = 0 , 1 , [ 1 ] + [ 0 ] * 2019 <NEWLINE> for i in reversed ( input ( ) ) : <NEWLINE> <INDENT> n = ( n + int ( i ) * d ) % 2019 <NEWLINE> d = d * 10 % 2019 <NEWLINE> mods [ n ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in mods ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( K ) <NEWLINE> maxi = 1 <NEWLINE> for i in range ( 18 ) : <NEWLINE> <INDENT> maxi = maxi * 10 <NEWLINE> <DEDENT> pro = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pro = pro * L [ i ] <NEWLINE> if maxi < pro : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if maxi >= pro : <NEWLINE> <INDENT> print ( pro ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> S_A = deque ( input ( ) ) <NEWLINE> S_B = deque ( input ( ) ) <NEWLINE> S_C = deque ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> next_turn = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( S_A ) == 0 and next_turn == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( S_B ) == 0 and next_turn == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( S_C ) == 0 and next_turn == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if next_turn == <STRING> : <NEWLINE> <INDENT> next_turn = S_A . popleft ( ) <NEWLINE> <DEDENT> elif next_turn == <STRING> : <NEWLINE> <INDENT> next_turn = S_B . popleft ( ) <NEWLINE> <DEDENT> elif next_turn == <STRING> : <NEWLINE> <INDENT> next_turn = S_C . popleft ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> P . sort ( ) <NEWLINE> print ( sum ( P [ 0 : K ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> vote_lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> vote_arr = np . array ( vote_lists ) <NEWLINE> total_vote = vote_arr . sum ( ) <NEWLINE> is_popular = total_vote / ( 4 * m ) <NEWLINE> <NL> answer_lists = [ ] <NEWLINE> <NL> for i in vote_lists : <NEWLINE> <INDENT> if i >= is_popular : <NEWLINE> <INDENT> answer_lists . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( answer_lists ) >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <NL> <DEDENT> sA = sorted ( A ) <NEWLINE> sB = sorted ( B , reverse = True ) <NEWLINE> <NL> <NL> <NL> m = N // 2 <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> minMid = sA [ m ] <NEWLINE> maxMid = sB [ m ] <NEWLINE> <NL> print ( maxMid - minMid + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = m - 1 <NEWLINE> minMidL = sA [ m ] <NEWLINE> maxMidL = sB [ m + 1 ] <NEWLINE> <NL> minMidH = sA [ m + 1 ] <NEWLINE> maxMidH = sB [ m ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = set ( ) <NEWLINE> aa = minMidL + minMidH <NEWLINE> bb = maxMidL + maxMidH <NEWLINE> <COMMENT> <NL> print ( bb - aa + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> l = - ( - x // 105 ) <NEWLINE> h = x // 100 <NEWLINE> fix = l * 100 <NEWLINE> <NL> for b in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> for c in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> for d in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> for e in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> for f in range ( 0 , h + 1 ) : <NEWLINE> <INDENT> if fix + 1 * b + 2 * c + 3 * d + 4 * e + 5 * f == x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( <STRING> ) . split ( <STRING> ) ) <NEWLINE> a = input ( <STRING> ) <NEWLINE> a = a . split ( <STRING> ) <NEWLINE> o = [ ] <NEWLINE> l = [ ] <NEWLINE> for p in range ( n ) : <NEWLINE> <INDENT> a [ p ] = int ( a [ p ] ) <NEWLINE> o . append ( 0 ) <NEWLINE> l . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> p = 1 <NEWLINE> h = [ ] <NEWLINE> h . append ( 1 ) <NEWLINE> j = k <NEWLINE> aj = 0 <NEWLINE> while j > 0 : <NEWLINE> <INDENT> p = a [ p - 1 ] <NEWLINE> o [ p - 1 ] += 1 <NEWLINE> if o [ p - 1 ] >= 2 : <NEWLINE> <INDENT> j = j - 1 <NEWLINE> c = len ( h ) - l [ p - 1 ] <COMMENT> <NEWLINE> j = j % c <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> h . append ( p ) <NEWLINE> j = j - 1 <NEWLINE> <NL> aj += 1 <NEWLINE> <NL> <DEDENT> l [ p - 1 ] = aj <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> d = n // ( a + b ) <NEWLINE> q = n % ( a + b ) <NEWLINE> <NL> <NL> if q <= a : <NEWLINE> <INDENT> print ( a * d + q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * d + a ) <NEWLINE> <NL> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lengh = len ( data ) <NEWLINE> for tmp in range ( lengh ) : <NEWLINE> <INDENT> if tmp == lengh - 1 : <NEWLINE> <INDENT> print ( data . pop ( - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( data . pop ( - 1 ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nl . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> ans = ans * nl [ s ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> at = [ ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> t += a [ n - j ] % mod <NEWLINE> at . append ( t ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += at [ n - 2 - i ] * a [ i ] <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r ** 2 , 2 * math . pi * r ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> res = - 1 <NEWLINE> count = 0 <NEWLINE> ai = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> ai = ( ai * 10 + 7 ) % K <NEWLINE> count += 1 <NEWLINE> if ( ai == 0 ) : <NEWLINE> <INDENT> res = count <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> st = [ 1 , 2 , 4 ] <NEWLINE> for i in range ( n - 3 ) : <NEWLINE> <INDENT> s = st [ - 1 ] + st [ - 2 ] + st [ - 3 ] <NEWLINE> st . append ( s ) <NEWLINE> <DEDENT> while ( n != 0 ) : <NEWLINE> <INDENT> pn = st [ n - 1 ] <NEWLINE> if ( pn % 10 == 0 ) : <NEWLINE> <INDENT> pn //= 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pn = pn // 10 + 1 <NEWLINE> <NL> <DEDENT> if ( pn % 365 == 0 ) : <NEWLINE> <INDENT> pn //= 365 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pn = pn // 365 + 1 <NEWLINE> <DEDENT> print ( pn ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> st = [ 1 , 2 , 4 ] <NEWLINE> for i in range ( n - 3 ) : <NEWLINE> <INDENT> s = st [ - 1 ] + st [ - 2 ] + st [ - 3 ] <NEWLINE> st . append ( s ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
inputs = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> sumAns = 0 <NEWLINE> <NL> if inputs [ 0 ] > inputs [ 3 ] : <NEWLINE> <INDENT> sumAns = sumAns + inputs [ 3 ] <NEWLINE> inputs [ 3 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sumAns = sumAns + inputs [ 0 ] <NEWLINE> inputs [ 3 ] = inputs [ 3 ] - inputs [ 0 ] <NEWLINE> <NL> <DEDENT> if inputs [ 1 ] > inputs [ 3 ] : <NEWLINE> <INDENT> inputs [ 3 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inputs [ 3 ] = inputs [ 3 ] - inputs [ 1 ] <NEWLINE> <NL> <DEDENT> if inputs [ 2 ] > inputs [ 3 ] : <NEWLINE> <INDENT> sumAns = sumAns - inputs [ 3 ] <NEWLINE> inputs [ 3 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sumAns = sumAns - inputs [ 3 ] <NEWLINE> inputs [ 3 ] = inputs [ 3 ] - inputs [ 2 ] <NEWLINE> <NL> <DEDENT> print ( sumAns ) <NEWLINE>
<NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> AList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = str ( K ) <NEWLINE> i = int ( A ) <NEWLINE> j = 0 <NEWLINE> while j <= N - K : <NEWLINE> <COMMENT> <NL> <INDENT> if j == 0 : <NEWLINE> <INDENT> MAE = AList [ j ] <NEWLINE> <DEDENT> elif MAE >= AList [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> MAE = AList [ j ] <NEWLINE> <DEDENT> elif MAE < AList [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> MAE = AList [ j ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> x , move , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = int ( abs ( x ) / d ) <NEWLINE> ans = 0 <NEWLINE> <NL> if move <= num : <NEWLINE> <INDENT> if np . sign ( x ) == 1 : <NEWLINE> <INDENT> ans = x - d * move <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x + d * move <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( move - num ) % 2 == 0 : <NEWLINE> <INDENT> if np . sign ( x ) == 1 : <NEWLINE> <INDENT> ans = x - d * num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x + d * num <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( move - num ) % 2 != 0 : <NEWLINE> <INDENT> if np . sign ( x ) == 1 : <NEWLINE> <INDENT> ans = x - d * ( num + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x + d * ( num + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( abs ( ans ) ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if d . get ( A [ n ] ) == None : <NEWLINE> <INDENT> d [ A [ n ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ n ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> d = sorted ( d . items ( ) , reverse = True ) <NEWLINE> <NL> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if cnt == 0 : <NEWLINE> <INDENT> if d [ i ] [ 1 ] >= 4 : <NEWLINE> <INDENT> ans = d [ i ] [ 0 ] ** 2 <NEWLINE> break <NEWLINE> <DEDENT> elif d [ i ] [ 1 ] >= 2 : <NEWLINE> <INDENT> temp = d [ i ] [ 0 ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d [ i ] [ 1 ] >= 2 : <NEWLINE> <INDENT> ans = temp * d [ i ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = [ input ( ) for l in range ( 2 ) ] <NEWLINE> N , A = int ( s [ 0 ] ) , [ int ( x ) for x in s [ 1 ] . split ( ) ] <NEWLINE> <STRING> <NEWLINE> <COMMENT> <NL> maxA = max ( A ) <NEWLINE> <COMMENT> <NL> C = { a : 0 for a in A } <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> D = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] > 0 : <NEWLINE> <INDENT> t = 2 <NEWLINE> while a * t <= maxA : <NEWLINE> <INDENT> D [ a * t ] = 1 <NEWLINE> t += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> if C [ a ] == 1 and D [ a ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = input ( ) + <STRING> <NEWLINE> S = input ( ) <NEWLINE> T = [ ] <NEWLINE> i = 0 <NEWLINE> <NL> <NL> while n - 1 >= i : <NEWLINE> <INDENT> if L [ i ] == L [ i + 1 ] : <NEWLINE> <INDENT> T . append ( 0 ) <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T . append ( 1 ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def f ( x , y ) : <NEWLINE> <INDENT> if x == 0 and y == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> if x == 1 and y == 1 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> if x == 1 and y == 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> <DEDENT> if T [ 0 ] == 0 : <NEWLINE> <INDENT> ans = 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( len ( T ) - 1 ) : <NEWLINE> <INDENT> ans = ans * f ( T [ i ] , T [ i + 1 ] ) <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import Counter <NEWLINE> import random <NEWLINE> N = int ( sys . stdin . readline ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> judge = [ 0 for _ in range ( 10 ** 6 + 1 ) ] <NEWLINE> A . sort ( ) <NEWLINE> B = Counter ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> judge [ a ] = 1 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> if judge [ a ] == 1 : <NEWLINE> <INDENT> if B [ a ] >= 2 : <NEWLINE> <INDENT> judge [ a ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 * a , 10 ** 6 + 1 , a ) : <NEWLINE> <INDENT> judge [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( judge . count ( 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class AlgUnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <COMMENT> <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <COMMENT> <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <COMMENT> <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <COMMENT> <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <COMMENT> <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <COMMENT> <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <COMMENT> <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <COMMENT> <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <COMMENT> <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> A [ j ] [ 0 ] -= 1 <NEWLINE> A [ j ] [ 1 ] -= 1 <NEWLINE> <DEDENT> uf = AlgUnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> uf . union ( A [ i ] [ 0 ] , A [ i ] [ 1 ] ) <NEWLINE> <DEDENT> count = uf . group_count ( ) - 1 <NEWLINE> print ( count ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> def insertionsort ( n , A ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> t = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > t : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> A [ j + 1 ] = t <NEWLINE> <NL> <NL> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> if k < n - 1 : <NEWLINE> <INDENT> print ( A [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> insertionsort ( n , A ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> l = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE>
def factorize ( n ) : <NEWLINE> <INDENT> b = 2 <NEWLINE> fct = [ ] <NEWLINE> while b * b <= n : <NEWLINE> <INDENT> while n % b == 0 : <NEWLINE> <INDENT> n //= b <NEWLINE> fct . append ( b ) <NEWLINE> <DEDENT> b = b + 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> fct . append ( n ) <NEWLINE> <DEDENT> return fct <NEWLINE> <NL> <DEDENT> number = int ( input ( ) ) <NEWLINE> consequence = factorize ( number ) <NEWLINE> c = list ( set ( consequence ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> Count = consequence . count ( c [ i ] ) <NEWLINE> d = f = 1 <NEWLINE> while Count >= d : <NEWLINE> <INDENT> f += 1 <NEWLINE> d += f <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k and b >= k - a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> max_n = int ( n ** 0.5 ) <NEWLINE> memo = np . zeros ( ( max_n , max_n , max_n ) ) <NEWLINE> <NL> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for x in range ( 1 , max_n ) : <NEWLINE> <INDENT> for y in range ( 1 , max_n ) : <NEWLINE> <INDENT> for z in range ( 1 , max_n ) : <NEWLINE> <INDENT> s = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if s < n + 1 : <NEWLINE> <INDENT> ans [ s ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> . join ( input ( ) . split ( ) [ : : - 1 ] ) ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> An = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> mod = int ( math . pow ( 10 , 9 ) + 7 ) <NEWLINE> <NL> sum_an = sum ( An ) <NEWLINE> sum_result = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> Ai = An [ i ] <NEWLINE> sum_an -= Ai <NEWLINE> sum_result += ( Ai * sum_an ) % mod <NEWLINE> <NL> <NL> <DEDENT> print ( sum_result % mod ) <NEWLINE>
import sys <NEWLINE> mod = 10 ** 9 + 7 ; inf = float ( <STRING> ) <NEWLINE> from math import sqrt , ceil <NEWLINE> from collections import deque , Counter , defaultdict <COMMENT> <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> sys . setrecursionlimit ( 11451419 ) <NEWLINE> from decimal import ROUND_HALF_UP , Decimal <COMMENT> <NEWLINE> <COMMENT> <NL> from functools import lru_cache <NEWLINE> from bisect import bisect_left as bileft , bisect_right as biright <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> NG = [ 0 ] * ( 10 ** 5 + 10 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> NG [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = 10 ** 10 ) <NEWLINE> def qwe ( x ) : <NEWLINE> <INDENT> if x == n : return 1 <NEWLINE> if x > n : return 0 <NEWLINE> if NG [ x + 1 ] and NG [ x + 2 ] : print ( 0 ) ; exit ( ) <NEWLINE> if NG [ x + 1 ] : return qwe ( x + 2 ) % mod <NEWLINE> if NG [ x + 2 ] : return qwe ( x + 1 ) % mod <NEWLINE> return ( qwe ( x + 2 ) + qwe ( x + 1 ) ) % mod <NEWLINE> <DEDENT> print ( qwe ( 0 ) ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( ( <STRING> * W ) + <STRING> ) * H ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> tot = sum ( A ) <NEWLINE> tot %= MOD <NEWLINE> <NL> ans = 0 <NEWLINE> rmv = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> rmv += a <NEWLINE> rmv %= MOD <NEWLINE> ans += a * ( tot - rmv ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> A [ int ( i ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <NL> def check ( a , b , c ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if c [ i ] [ j ] != a [ i ] + b [ j ] : <NEWLINE> <INDENT> flag = False <NEWLINE> return flag <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> arr_c = np . array ( c ) <NEWLINE> a_max = np . amax ( arr_c , axis = 1 ) <NEWLINE> b_max = np . amax ( arr_c , axis = 0 ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if len ( list ( range ( 0 , a_max [ i ] + 1 , 1 ) ) ) == 0 : <NEWLINE> <INDENT> a . append ( [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( list ( range ( 0 , a_max [ i ] + 1 , 1 ) ) ) <NEWLINE> <NL> <DEDENT> if len ( list ( range ( 0 , b_max [ i ] + 1 , 1 ) ) ) == 0 : <NEWLINE> <INDENT> b . append ( [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( list ( range ( 0 , b_max [ i ] + 1 , 1 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> cnt = 0 <NEWLINE> for a0 in a [ 0 ] : <NEWLINE> <INDENT> for b0 in b [ 0 ] : <NEWLINE> <INDENT> if c [ 0 ] [ 0 ] != a0 + b0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for a1 in a [ 1 ] : <NEWLINE> <INDENT> if c [ 1 ] [ 0 ] != a1 + b0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for b1 in b [ 1 ] : <NEWLINE> <INDENT> if c [ 0 ] [ 1 ] != a0 + b1 or c [ 1 ] [ 1 ] != a1 + b1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for a2 in a [ 2 ] : <NEWLINE> <INDENT> if c [ 2 ] [ 0 ] != a2 + b0 or c [ 2 ] [ 1 ] != a2 + b1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for b2 in b [ 2 ] : <NEWLINE> <INDENT> if c [ 0 ] [ 2 ] != a0 + b2 or c [ 1 ] [ 2 ] != a1 + b2 or c [ 2 ] [ 2 ] != a2 + b2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> par = [ i for i in range ( n ) ] <NEWLINE> ro = dict ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ro [ i ] = 1 <NEWLINE> <DEDENT> def root ( i ) : <NEWLINE> <INDENT> if par [ i ] == i : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = root ( par [ i ] ) <NEWLINE> par [ i ] = a <NEWLINE> return a <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> rx = root ( x ) <NEWLINE> ry = root ( y ) <NEWLINE> if rx != ry : <NEWLINE> <INDENT> par [ rx ] = ry <NEWLINE> ro [ ry ] += ro [ rx ] <NEWLINE> ro [ rx ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> print ( max ( ro . values ( ) ) ) <NEWLINE>
a = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> a = a [ : 3 ] <NEWLINE> print ( a [ 0 ] ) <NEWLINE> print ( a [ 1 ] ) <NEWLINE> print ( a [ 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> X . reverse ( ) <NEWLINE> def int2bit ( n ) : <NEWLINE> <INDENT> ret = [ 0 for i in range ( 18 ) ] <NEWLINE> cnt = 0 <NEWLINE> i = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> ret [ i ] = n % 2 <NEWLINE> cnt += n % 2 <NEWLINE> n = n // 2 <NEWLINE> i += 1 <NEWLINE> <DEDENT> return ( ret , cnt ) <NEWLINE> <NL> <DEDENT> def func ( bit , popcount ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> base = 1 <NEWLINE> for b in bit : <NEWLINE> <INDENT> ret = ( ret + base * b ) % popcount <NEWLINE> base = ( base * 2 ) % popcount <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def func2 ( n ) : <NEWLINE> <INDENT> ( bit , popcount ) = int2bit ( n ) <NEWLINE> return func ( bit , popcount ) <NEWLINE> <NL> <DEDENT> F = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> <NL> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = func2 ( n ) <NEWLINE> F [ n ] = 1 + F [ a ] <NEWLINE> <DEDENT> P = sum ( X ) <NEWLINE> <NL> f_1 = func ( X , P + 1 ) <NEWLINE> f_0 = func ( X , max ( 1 , P - 1 ) ) <NEWLINE> <NL> base_1 = [ 1 ] <NEWLINE> base_0 = [ 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> base_1 . append ( ( base_1 [ i ] * 2 ) % ( P + 1 ) ) <NEWLINE> base_0 . append ( ( base_0 [ i ] * 2 ) % max ( 1 , P - 1 ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> idx = N - 1 - i <NEWLINE> if X [ idx ] == 0 : <NEWLINE> <INDENT> print ( 1 + F [ ( f_1 + base_1 [ idx ] ) % ( P + 1 ) ] ) <NEWLINE> <DEDENT> if X [ idx ] == 1 : <NEWLINE> <INDENT> if P == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 + F [ ( f_0 - base_0 [ idx ] ) % ( P - 1 ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> first = { } <NEWLINE> second = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if v [ i ] in first : <NEWLINE> <INDENT> first [ v [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first [ v [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if v [ i ] in second : <NEWLINE> <INDENT> second [ v [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> second [ v [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> first = sorted ( first . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> second = sorted ( second . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> f = first . pop ( ) <NEWLINE> s = second . pop ( ) <NEWLINE> <NL> if f [ 0 ] == s [ 0 ] : <NEWLINE> <INDENT> if len ( first ) >= 1 : <NEWLINE> <INDENT> if len ( second ) >= 1 : <NEWLINE> <INDENT> f2 = first . pop ( ) <NEWLINE> s2 = second . pop ( ) <NEWLINE> <NL> if f2 [ 1 ] + s [ 1 ] > f [ 1 ] + s2 [ 1 ] : <NEWLINE> <INDENT> f = f2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = second . pop ( ) <NEWLINE> <DEDENT> <DEDENT> elif len ( second ) >= 1 : <NEWLINE> <INDENT> f = first . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( 0 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - f [ 1 ] - s [ 1 ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ float ( <STRING> ) ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) , dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 1 ] <NEWLINE> s = set ( [ 1 ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ C [ i ] - 1 ] in s : <NEWLINE> <INDENT> l = C . index ( A [ C [ i ] - 1 ] ) + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C . append ( A [ C [ i ] - 1 ] ) <NEWLINE> s . add ( A [ C [ i ] - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if K + 1 <= l : <NEWLINE> <INDENT> print ( C [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C [ l - 1 + ( K + 1 - l ) % ( len ( C ) - l + 1 ) ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def int1 ( x ) : <NEWLINE> <INDENT> return int ( x ) - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_map ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple_minus1 ( ) : <NEWLINE> <INDENT> return tuple ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = input_to_int_map ( ) <NEWLINE> a = { i + 1 : int ( val ) for i , val in enumerate ( input ( ) . split ( ) ) } <NEWLINE> <NL> place = 1 <NEWLINE> visit = { place } <NEWLINE> place_visits = [ place ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> place = a [ place ] <NEWLINE> if place in visit : <NEWLINE> <INDENT> left = place_visits . index ( place ) <NEWLINE> return place_visits [ left + ( k - left ) % ( i + 1 - left ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visit . add ( place ) <NEWLINE> place_visits . append ( place ) <NEWLINE> <NL> <DEDENT> <DEDENT> return place <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
cnt = 0 <NEWLINE> <NL> <NL> def insSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <NL> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> G = [ ] <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> i = i * 3 + 1 <NEWLINE> if i > n - 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> G . reverse ( ) <NEWLINE> <NL> print ( len ( G ) ) <NEWLINE> print ( * G ) <NEWLINE> <NL> for i in G : <NEWLINE> <INDENT> insSort ( A , n , i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> shellSort ( arr , n ) <NEWLINE> <NL> print ( cnt ) <NEWLINE> <NL> for s in arr : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT>
from sys import stdin <NEWLINE> data = stdin . readlines ( ) <NEWLINE> <NL> n = int ( data [ 0 ] . split ( ) [ 0 ] ) <NEWLINE> a = [ int ( s ) for s in data [ 1 ] . split ( ) ] <NEWLINE> a = sorted ( a ) <NEWLINE> <NL> max = a [ - 1 ] <NEWLINE> <NL> l = [ 0 ] * ( max + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> if l [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , max + 1 , i ) : <NEWLINE> <INDENT> l [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( l . count ( 1 ) ) <NEWLINE>
inlist = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> n = int ( inlist [ 0 ] ) <NEWLINE> m = int ( inlist [ 1 ] ) <NEWLINE> lista = [ ] <NEWLINE> listb = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lista += [ [ ] ] <NEWLINE> listb += [ - 1 ] <NEWLINE> <DEDENT> listb [ 0 ] = - 2 <NEWLINE> <NL> listnum = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> inlist = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> s = int ( inlist [ 0 ] ) <NEWLINE> t = int ( inlist [ 1 ] ) <NEWLINE> lista [ s - 1 ] += [ t - 1 ] <NEWLINE> lista [ t - 1 ] += [ s - 1 ] <NEWLINE> <DEDENT> k = 0 <NEWLINE> while ( k < len ( listnum ) ) : <NEWLINE> <INDENT> for i in lista [ listnum [ k ] ] : <NEWLINE> <NL> <INDENT> if ( listb [ i ] == - 1 ) : <NEWLINE> <INDENT> listb [ i ] = listnum [ k ] <NEWLINE> listnum += [ i ] <NEWLINE> <DEDENT> <DEDENT> k += 1 <NEWLINE> <NL> <DEDENT> if ( - 1 in listb ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in listb [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
r = input ( ) <NEWLINE> r = float ( r ) <NEWLINE> print ( 3.141592653589 * r ** 2 , 2 * 3.141592653589 * r ) <NEWLINE> <NL>
from collections import defaultdict <NEWLINE> row = defaultdict ( int ) <NEWLINE> col = defaultdict ( int ) <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> matrix = defaultdict ( bool ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> row [ h - 1 ] += 1 <NEWLINE> col [ w - 1 ] += 1 <NEWLINE> matrix [ ( h - 1 , w - 1 ) ] = True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> temp = list ( row . items ( ) ) <NEWLINE> temp . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> a , b = temp [ - 1 ] [ 0 ] , temp [ - 1 ] [ 1 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> if matrix [ ( a , i ) ] : <NEWLINE> <INDENT> temp = ( b + col [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = ( b + col [ i ] ) <NEWLINE> <DEDENT> cnt = max ( cnt , temp ) <NEWLINE> <COMMENT> <NL> <DEDENT> temp = list ( col . items ( ) ) <NEWLINE> temp . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> a , b = temp [ - 1 ] [ 0 ] , temp [ - 1 ] [ 1 ] <NEWLINE> cnt2 = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> if matrix [ ( i , a ) ] : <NEWLINE> <INDENT> temp = ( b + row [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = ( b + row [ i ] ) <NEWLINE> <DEDENT> cnt2 = max ( cnt2 , temp ) <NEWLINE> <DEDENT> print ( max ( cnt , cnt2 ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> max = 0 <NEWLINE> tall = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if max <= tall [ i ] : <NEWLINE> <INDENT> max = tall [ i ] <NEWLINE> <DEDENT> if max > tall [ i ] : <NEWLINE> <INDENT> total += max - tall [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
ans = 0 <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if not a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = ( b ** 2 - 4 * a * c ) ** 0.5 <NEWLINE> if isinstance ( d , complex ) or d - int ( d ) > 1e-6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> num1 , num2 = - b + int ( d ) , - b - int ( d ) <NEWLINE> den = 2 * a <NEWLINE> cmn1 , cmn2 = fractions . gcd ( num1 , den ) , fractions . gcd ( num2 , den ) <NEWLINE> p , q , r , s = den // cmn1 , - num1 // cmn1 , den // cmn2 , - num2 // cmn2 <NEWLINE> if ( p , q ) < ( r , s ) : <NEWLINE> <INDENT> p , q , r , s = r , s , p , q <NEWLINE> <DEDENT> print ( p , q , r , s ) <NEWLINE> <DEDENT>
class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , index ) : <NEWLINE> <INDENT> self . index = index <NEWLINE> self . parent = self <NEWLINE> self . size = 1 <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def find_set ( node ) : <NEWLINE> <INDENT> if node . parent == node : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> root = Node . find_set ( node . parent ) <NEWLINE> node . parent = root <NEWLINE> return root <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def union ( node_a , node_b ) : <NEWLINE> <INDENT> root_a = Node . find_set ( node_a ) <NEWLINE> root_b = Node . find_set ( node_b ) <NEWLINE> if root_a != root_b : <NEWLINE> <INDENT> if root_a . size < root_b . size : <NEWLINE> <INDENT> root_a . parent = root_b <NEWLINE> root_b . size == root_a . size <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root_b . parent = root_a <NEWLINE> root_a . size += root_b . size <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = [ int ( val ) for val in input ( ) . split ( ) ] <NEWLINE> <NL> persons = [ ] <NEWLINE> count = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> persons . append ( Node ( i ) ) <NEWLINE> count . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( val ) for val in input ( ) . split ( ) ] <NEWLINE> if a > b : <NEWLINE> <INDENT> Node . union ( persons [ a - 1 ] , persons [ b - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Node . union ( persons [ b - 1 ] , persons [ a - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for idx , person in enumerate ( persons ) : <NEWLINE> <INDENT> count [ Node . find_set ( person ) . index ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> result = max ( count ) <NEWLINE> print ( result ) <NEWLINE> <NL> <DEDENT>
def calc ( x , y ) : <NEWLINE> <INDENT> n = len ( x ) <NEWLINE> m = len ( y ) <NEWLINE> dp1 = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = x [ i ] <NEWLINE> dp2 = dp1 [ : ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if s == y [ j ] : <NEWLINE> <INDENT> dp1 [ j + 1 ] = dp2 [ j ] + 1 <NEWLINE> <DEDENT> elif dp1 [ j + 1 ] < dp1 [ j ] : <NEWLINE> <INDENT> dp1 [ j + 1 ] = dp1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp1 [ - 1 ] <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> print ( calc ( x , y ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a ] . append ( b ) <NEWLINE> ab [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> l = deque ( [ 1 ] ) <NEWLINE> ans = [ - 1 ] * n <NEWLINE> while l : <NEWLINE> <INDENT> x = l . popleft ( ) <NEWLINE> for i in ab [ x ] : <NEWLINE> <INDENT> if ans [ i - 1 ] == - 1 : <NEWLINE> <INDENT> ans [ i - 1 ] = x <NEWLINE> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> to [ A ] . append ( B ) <NEWLINE> to [ B ] . append ( A ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v , to , seen ) : <NEWLINE> <INDENT> global count <NEWLINE> seen [ v ] = True <NEWLINE> count += 1 <NEWLINE> for nv in to [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( nv , to , seen ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global count <NEWLINE> seen = [ False ] * N <NEWLINE> cnts = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not seen [ i ] : <NEWLINE> <INDENT> dfs ( i , to , seen ) <NEWLINE> cnts . append ( count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( cnts ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( l ) <NEWLINE> <NL> from math import gcd <NEWLINE> g = gcd ( l [ 0 ] , l [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> g = gcd ( g , l [ i ] ) <NEWLINE> <DEDENT> if g != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> prime = [ True ] * ( m + 1 ) <NEWLINE> prime [ 0 ] = False <NEWLINE> prime [ 1 ] = False <NEWLINE> d = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( 2 , int ( m ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if prime [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , m + 1 , i ) : <NEWLINE> <INDENT> prime [ j ] = False <NEWLINE> d [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = [ i for i in range ( m + 1 ) if prime [ i ] ] <NEWLINE> for ss in s : <NEWLINE> <INDENT> d [ ss ] = ss <NEWLINE> <NL> <DEDENT> sl = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> div = set ( ) <NEWLINE> ll = l [ i ] <NEWLINE> while ll > 1 : <NEWLINE> <INDENT> div . add ( d [ ll ] ) <NEWLINE> ll //= d [ ll ] <NEWLINE> <DEDENT> div = list ( div ) <NEWLINE> for dd in div : <NEWLINE> <INDENT> if dd not in sl : <NEWLINE> <INDENT> sl . add ( dd ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> amari = a % b <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , amari ) <NEWLINE> <NL> <DEDENT> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab = gcd ( a , b ) <NEWLINE> if ab == 1 : <NEWLINE> <INDENT> ans += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import itertools as it <NEWLINE> <NL> <COMMENT> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( res ) == 0 : <NEWLINE> <INDENT> res = [ n ] <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> m = n <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def comb ( n , r ) : <COMMENT> <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> l = min ( r , n - r ) <NEWLINE> m = n <NEWLINE> u = 1 <NEWLINE> for _i in range ( l ) : <NEWLINE> <INDENT> u *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return u // fact ( l ) <NEWLINE> <DEDENT> def combmod ( n , r , mod ) : <NEWLINE> <INDENT> return ( fact ( n ) / fact ( n - r ) * pow ( fact ( r ) , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> def printQueue ( q ) : <NEWLINE> <INDENT> r = copyQueue ( q ) <NEWLINE> ans = [ 0 ] * r . qsize ( ) <NEWLINE> for i in range ( r . qsize ( ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans [ i ] = r . get ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <COMMENT> <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - 1 * self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <COMMENT> <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <COMMENT> <NEWLINE> <DEDENT> <DEDENT> def bitArr ( n ) : <COMMENT> <NEWLINE> <INDENT> x = 1 <NEWLINE> zero = <STRING> * n <NEWLINE> ans = [ ] <NEWLINE> ans . append ( [ 0 ] * n ) <NEWLINE> for i in range ( 2 ** n - 1 ) : <NEWLINE> <INDENT> ans . append ( list ( map ( lambda x : int ( x ) , list ( ( zero + bin ( x ) [ 2 : ] ) [ - 1 * n : ] ) ) ) ) <NEWLINE> x += 1 <NEWLINE> <DEDENT> return ans ; <NEWLINE> <DEDENT> def arrsSum ( a1 , a2 ) : <NEWLINE> <INDENT> for i in range ( len ( a1 ) ) : <NEWLINE> <INDENT> a1 [ i ] += a2 [ i ] <NEWLINE> <DEDENT> return a1 <NEWLINE> <DEDENT> def maxValue ( a , b , v ) : <NEWLINE> <INDENT> v2 = v <NEWLINE> for i in range ( v2 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( v2 // a + 1 ) : <COMMENT> <NEWLINE> <INDENT> k = i - a * j <NEWLINE> if k % b == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> def copyQueue ( q ) : <NEWLINE> <INDENT> nq = queue . Queue ( ) <NEWLINE> n = q . qsize ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = q . get ( ) <NEWLINE> q . put ( x ) <NEWLINE> nq . put ( x ) <NEWLINE> <DEDENT> return nq <NEWLINE> <DEDENT> def get_sieve_of_eratosthenes ( n ) : <NEWLINE> <INDENT> data = [ 2 ] <NEWLINE> <COMMENT> <NL> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> data . append ( i ) <NEWLINE> data . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> interval = data [ i ] <NEWLINE> if interval != 0 : <NEWLINE> <INDENT> for j in range ( i + interval , n - 1 , interval ) : <NEWLINE> <INDENT> data [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = [ x for x in data if x != 0 ] <NEWLINE> <COMMENT> <NL> return ans <NEWLINE> <NL> <DEDENT> n = readInt ( ) <NEWLINE> a = readInts ( ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> arr = [ ] <NEWLINE> remain = set ( ) <NEWLINE> for i in d : <NEWLINE> <INDENT> if d [ i ] != 1 : <NEWLINE> <INDENT> remain . add ( i ) <NEWLINE> <DEDENT> <DEDENT> arr = list ( set ( a ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> if len ( arr ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> maxa = 10 ** 6 + 1 <NEWLINE> ans = [ 0 ] * ( maxa + 1 ) <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <NL> <DEDENT> for i in arr : <NEWLINE> <INDENT> if ans [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , len ( ans ) , i ) : <NEWLINE> <INDENT> ans [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tyo = 0 <NEWLINE> <NL> for i in remain : <NEWLINE> <INDENT> if ans [ i ] == 1 : <NEWLINE> <INDENT> tyo += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans . count ( 1 ) - tyo ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> k = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> A = int ( X , 2 ) <NEWLINE> <COMMENT> <NL> ap = A % ( k + 1 ) <NEWLINE> <NL> am = 100 <NEWLINE> if k != 1 : <NEWLINE> <INDENT> am = A % ( k - 1 ) <NEWLINE> <NL> <DEDENT> popc_list = [ - 1 ] * ( k + 3 ) <NEWLINE> <NL> def F ( num ) : <NEWLINE> <COMMENT> <NL> <INDENT> if num == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if popc_list [ num ] != - 1 : <NEWLINE> <INDENT> return popc_list [ num ] <NEWLINE> <NL> <DEDENT> popc = 0 <NEWLINE> for s in bin ( num ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> popc += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> popc_list [ num ] = F ( num % popc ) + 1 <NEWLINE> return popc_list [ num ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( F ( ( ap + pow ( 2 , N - 1 - i , k + 1 ) ) % ( k + 1 ) ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( F ( ( am - pow ( 2 , N - 1 - i , k - 1 ) ) % ( k - 1 ) ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> c += A [ i ] - A [ i + 1 ] <NEWLINE> A [ i + 1 ] = A [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 10 ** 6 + 7 <NEWLINE> <NL> count = [ 0 ] * m <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if count [ x ] != 0 : <NEWLINE> <INDENT> count [ x ] = 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for i in range ( x , m , x ) : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if count [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = sorted ( list ( input ( ) for _ in range ( N ) ) ) <NEWLINE> print ( * S , sep = <STRING> ) <NEWLINE>
from decimal import Decimal <NEWLINE> k = int ( input ( ) ) <NEWLINE> num = 100 <NEWLINE> ans = 0 <NEWLINE> while k > num : <NEWLINE> <INDENT> num = int ( Decimal ( num ) * Decimal ( 101 ) / Decimal ( 100 ) ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> curr = 7 <NEWLINE> curr = curr % k <NEWLINE> count = 1 <NEWLINE> if ( k % 2 == 0 or k % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if ( curr == 0 ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> curr = ( curr * 10 + 7 ) % k <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> x = [ - 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> x . append ( n - 1 ) <NEWLINE> t = len ( x ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( t - 1 ) : <NEWLINE> <INDENT> if i % 2 == s [ 0 ] : <NEWLINE> <INDENT> ans = max ( ans , x [ min ( t - 1 , i + 2 * k ) ] - x [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , x [ min ( t - 1 , i + 2 * k + 1 ) ] - x [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <COMMENT> <NL> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> <NL> sum = R * G * B <NEWLINE> <COMMENT> <NL> for i in range ( N - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( i + 1 , - ( - ( N + i ) // 2 ) ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <COMMENT> <NL> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = n // i <NEWLINE> ans += m * i * ( m + 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> def program ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = max ( [ uf . size ( i ) for i in range ( N ) ] ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( program ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = input ( ) . split ( ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> b . append ( int ( a [ i ] ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> answer = str ( b [ n - 1 ] ) <NEWLINE> while n > 1 : <NEWLINE> <INDENT> answer = answer + <STRING> + str ( b [ n - 2 ] ) <NEWLINE> n = n - 1 <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> query = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> query . append ( [ a - 1 , b - 1 , c , d ] ) <NEWLINE> <NL> <NL> <DEDENT> results = [ ] <NEWLINE> def f ( x , A , depth = 0 ) : <NEWLINE> <INDENT> if depth == n : <NEWLINE> <COMMENT> <NL> <INDENT> score = 0 <NEWLINE> for a , b , c , d in query : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ b ] - A [ a ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> results . append ( score ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> A [ n - depth - 1 ] = i <NEWLINE> f ( i , A , depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> f ( m , [ 0 ] * n ) <NEWLINE> print ( max ( results ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P_ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> diff , rst = - 1 , 0 <NEWLINE> for i in range ( 101 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i not in P_ls : <NEWLINE> <INDENT> if diff == - 1 : <NEWLINE> <INDENT> diff = abs ( X - i ) <NEWLINE> rst = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = min ( diff , abs ( X - i ) ) <NEWLINE> if diff == abs ( X - i ) : <NEWLINE> <INDENT> rst = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rst ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( q ) ] <NEWLINE> b , c = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> sum_all = 0 <NEWLINE> for cnt in range ( n ) : <NEWLINE> <INDENT> sum_all += a [ cnt ] <NEWLINE> <NL> <DEDENT> a = sorted ( a ) <NEWLINE> list_a_num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for cnt in range ( n ) : <NEWLINE> <INDENT> list_a_num [ a [ cnt ] ] += 1 <NEWLINE> <NL> <DEDENT> for cnt in range ( q ) : <NEWLINE> <INDENT> sum_all += ( c [ cnt ] - b [ cnt ] ) * list_a_num [ b [ cnt ] ] <NEWLINE> list_a_num [ c [ cnt ] ] += list_a_num [ b [ cnt ] ] <NEWLINE> list_a_num [ b [ cnt ] ] = 0 <NEWLINE> print ( sum_all ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . fabs ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> AA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = A + AA <NEWLINE> <NL> B = set ( ) <NEWLINE> cnt = 0 <NEWLINE> ind = 1 <NEWLINE> startind = 0 <NEWLINE> D = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if A [ ind ] not in B : <NEWLINE> <INDENT> B . add ( ind ) <NEWLINE> D . append ( ind ) <NEWLINE> cnt += 1 <NEWLINE> ind = A [ ind ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . add ( ind ) <NEWLINE> D . append ( ind ) <NEWLINE> cnt += 1 <NEWLINE> startind = A [ ind ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> C = set ( ) <NEWLINE> ind = startind <NEWLINE> ANS = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if A [ ind ] not in C : <NEWLINE> <INDENT> C . add ( ind ) <NEWLINE> ind = A [ ind ] <NEWLINE> ANS . append ( ind ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C . add ( ind ) <NEWLINE> ANS . append ( A [ ind ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k >= cnt : <NEWLINE> <INDENT> tmp = k - cnt <NEWLINE> tmp = tmp % ( len ( C ) ) <NEWLINE> print ( ANS [ tmp - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D [ k ] ) <NEWLINE> <DEDENT> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sorted ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ord = [ - 1 for _ in range ( N ) ] <NEWLINE> ord [ 0 ] = 0 <NEWLINE> v = A [ 0 ] - 1 <NEWLINE> root = [ 0 ] <NEWLINE> <NL> while ord [ v ] == - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> ord [ v ] = len ( root ) <NEWLINE> <COMMENT> <NL> root . append ( v ) <NEWLINE> <NL> <COMMENT> <NL> v = A [ v ] - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> l = ord [ v ] <NEWLINE> <COMMENT> <NL> c = len ( root ) - l <NEWLINE> <NL> if K < l : <NEWLINE> <COMMENT> <NL> <INDENT> ans = root [ K ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> K -= l <NEWLINE> <COMMENT> <NL> K %= c <NEWLINE> <COMMENT> <NL> ans = root [ l + K ] <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE> <NL>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> <NL> plus = list ( filter ( lambda x : x > 0 , A ) ) [ : : - 1 ] <NEWLINE> plus = list ( map ( lambda x : np . longdouble ( math . log ( x , 10000000 ) ) , plus ) ) <NEWLINE> from itertools import accumulate <NEWLINE> acc_plu = [ 0 ] + list ( accumulate ( plus ) ) <NEWLINE> minu = filter ( lambda x : x < 0 , A ) <NEWLINE> minu = list ( map ( lambda x : np . longdouble ( math . log ( - x , 10000000 ) ) , minu ) ) <NEWLINE> acc_min = [ 0 ] + list ( accumulate ( minu ) ) <NEWLINE> <NL> <NL> if K % 2 == 0 : num = K // 2 + 1 <NEWLINE> else : num = ( K + 1 ) // 2 <NEWLINE> cand = [ ] <NEWLINE> x = K <NEWLINE> y = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> cand . append ( ( acc_plu [ x ] + acc_min [ y ] , x , y ) ) <NEWLINE> <DEDENT> except : pass <NEWLINE> x -= 2 <NEWLINE> y += 2 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> if cand == [ ] : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> <COMMENT> <NL> abss = sorted ( list ( map ( lambda x : abs ( x ) , A ) ) ) <NEWLINE> for x in abss : <NEWLINE> <INDENT> if cnt == K : break <NEWLINE> ans *= x <NEWLINE> ans %= MOD <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> ans *= - 1 <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand = sorted ( cand ) [ : : - 1 ] <NEWLINE> plus = list ( filter ( lambda x : x > 0 , A ) ) [ : : - 1 ] <NEWLINE> minu = list ( filter ( lambda x : x < 0 , A ) ) <NEWLINE> c = cand [ 0 ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( c [ 1 ] ) : <NEWLINE> <INDENT> ans *= plus [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> for i in range ( c [ 2 ] ) : <NEWLINE> <INDENT> ans *= minu [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def check ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for l in a : <NEWLINE> <INDENT> if l % n == 0 : <NEWLINE> <INDENT> cnt = cnt + l // n - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = cnt + l // n <NEWLINE> <DEDENT> <DEDENT> if cnt <= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> left = 0 <NEWLINE> right = max ( a ) <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> print ( right ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> c = sum ( aa ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c -= aa [ i ] <NEWLINE> total += aa [ i ] * c <NEWLINE> <NL> <DEDENT> x = 10 ** 9 + 7 <NEWLINE> ans = total % x <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> s = { input ( ) for _ in range ( n ) } <NEWLINE> <NL> print ( len ( s ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= b [ i ] : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> b [ i ] -= a [ i ] <NEWLINE> if a [ i + 1 ] >= b [ i ] : <NEWLINE> <INDENT> a [ i + 1 ] -= b [ i ] <NEWLINE> ans += b [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i + 1 ] <NEWLINE> a [ i + 1 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , A - K ) , max ( 0 , B - max ( 0 , K - A ) ) ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ct = collections . Counter ( t ) <NEWLINE> cd = collections . Counter ( d ) <NEWLINE> cct = list ( ct . items ( ) ) <NEWLINE> <COMMENT> <NL> if n < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( cct ) ) : <NEWLINE> <INDENT> if cd [ cct [ i ] [ 0 ] ] < cct [ i ] [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import exit <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : print ( 0 ) ; exit ( ) <NEWLINE> al = [ 0 for _ in range ( n ) ] <NEWLINE> for index in range ( n - 1 ) : <NEWLINE> <INDENT> person = a [ index ] <NEWLINE> person_behind = a [ index + 1 ] <NEWLINE> if person_behind < person : <NEWLINE> <INDENT> k = person - person_behind <NEWLINE> a [ index + 1 ] += k <NEWLINE> al [ index + 1 ] = k <NEWLINE> <DEDENT> <DEDENT> print ( sum ( al ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = { input ( ) for i in range ( n ) } <COMMENT> <NEWLINE> <NL> print ( len ( s ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> array_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> input ( ) <NEWLINE> array_q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def can_construct_q ( q , i , sum_sofar ) : <NEWLINE> <INDENT> if sum_sofar == q or sum_sofar + array_a [ i ] == q : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif sum_sofar > q or i >= len ( array_a ) - 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if can_construct_q ( q , i + 1 , sum_sofar + array_a [ i ] ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if can_construct_q ( q , i + 1 , sum_sofar ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> sum_array_a = sum ( array_a ) <NEWLINE> for q in array_q : <NEWLINE> <COMMENT> <NL> <INDENT> if sum_array_a < q : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif can_construct_q ( q , 0 , 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> a = w - 2 <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * a + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data . sort ( ) <NEWLINE> data . reverse ( ) <NEWLINE> <NL> while data [ - 1 ] == 0 : <NEWLINE> <INDENT> data . insert ( 0 , 0 ) <NEWLINE> data . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for d in data : <NEWLINE> <INDENT> ans = ans * int ( d ) <NEWLINE> if ans > 10 ** 18 or ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> MOD = 10 ** 4 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> d = deque ( [ ] ) <NEWLINE> for a in A : <NEWLINE> <INDENT> l = - 1 <NEWLINE> r = len ( d ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = l + ( r - l ) // 2 <NEWLINE> if d [ m ] >= a : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> if r == 0 : <NEWLINE> <INDENT> d . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ r - 1 ] = a <NEWLINE> <DEDENT> <DEDENT> print ( len ( d ) ) <NEWLINE>
data = int ( input ( ) ) <NEWLINE> for i in range ( 1 , data + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 ) or ( <STRING> in str ( i ) ) : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = [ 0 ] <NEWLINE> D = [ 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> C . append ( C [ - 1 ] + a ) <NEWLINE> <DEDENT> for b in B : <NEWLINE> <INDENT> D . append ( D [ - 1 ] + b ) <NEWLINE> <NL> <DEDENT> p = n <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if C [ i ] > k : <NEWLINE> <INDENT> p = i - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> _max = p <NEWLINE> keep = 0 <NEWLINE> for i in range ( p , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( keep , m + 1 ) : <NEWLINE> <INDENT> if C [ i ] + D [ j ] > k : <NEWLINE> <INDENT> keep = j - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif _max < i + j : <NEWLINE> <INDENT> _max = i + j <NEWLINE> <DEDENT> <DEDENT> if j == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( _max ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> def solve ( N , C , AB ) : <NEWLINE> <INDENT> def edges_to_array ( A , B , N , M ) : <NEWLINE> <INDENT> head = [ - 1 ] * ( N + 1 ) <NEWLINE> nxt = [ 0 ] * ( M + M ) <NEWLINE> to = [ 0 ] * ( M + M ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> b = B [ i ] <NEWLINE> nxt [ i << 1 ] = head [ a ] <NEWLINE> to [ i << 1 ] = b <NEWLINE> head [ a ] = i << 1 <NEWLINE> nxt [ i << 1 | 1 ] = head [ b ] <NEWLINE> to [ i << 1 | 1 ] = a <NEWLINE> head [ b ] = i << 1 | 1 <NEWLINE> <DEDENT> return head , nxt , to <NEWLINE> <NL> <DEDENT> def EulerTour ( head , nxt , to , root = 1 ) : <NEWLINE> <INDENT> N = len ( head ) - 1 <NEWLINE> parent = [ 0 ] * ( N + 1 ) <NEWLINE> ind_L = [ 0 ] * ( N + 1 ) <NEWLINE> ind_R = [ 0 ] * ( N + 1 ) <NEWLINE> i = - 1 <NEWLINE> tour = [ ] <NEWLINE> stack = [ - root , root ] <NEWLINE> stack [ 0 ] = - root <NEWLINE> stack [ 1 ] = root <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> tour . append ( v ) <NEWLINE> i += 1 <NEWLINE> if v > 0 : <NEWLINE> <INDENT> ind_L [ v ] = i <NEWLINE> p = parent [ v ] <NEWLINE> k = head [ v ] <NEWLINE> while k != - 1 : <NEWLINE> <INDENT> w = to [ k ] <NEWLINE> if w == p : <NEWLINE> <INDENT> k = nxt [ k ] <NEWLINE> continue <NEWLINE> <DEDENT> parent [ w ] = v <NEWLINE> stack . append ( - w ) <NEWLINE> stack . append ( w ) <NEWLINE> k = nxt [ k ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ind_R [ - v ] = i <NEWLINE> <DEDENT> <DEDENT> return tour , ind_L , ind_R , parent <NEWLINE> <DEDENT> head , nxt , to = edges_to_array ( AB [ : : 2 ] , AB [ 1 : : 2 ] , N , N - 1 ) <NEWLINE> tour , ind_L , ind_R , parent = EulerTour ( head , nxt , to ) <NEWLINE> removed = [ 0 ] * ( N + 1 ) <NEWLINE> answer = [ N * ( N + 1 ) // 2 ] * ( N + 1 ) <NEWLINE> memo = [ 0 ] * ( N + 1 ) <NEWLINE> for v in tour : <NEWLINE> <INDENT> if v > 0 : <NEWLINE> <INDENT> memo [ v ] = removed [ C [ parent [ v ] ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = - v <NEWLINE> removed [ C [ v ] ] += 1 <NEWLINE> p = parent [ v ] <NEWLINE> x = ( ind_R [ v ] - ind_L [ v ] ) // 2 + 1 <COMMENT> <NEWLINE> x -= removed [ C [ p ] ] - memo [ v ] <NEWLINE> answer [ C [ p ] ] -= x * ( x + 1 ) // 2 <NEWLINE> removed [ C [ p ] ] += x <NEWLINE> <DEDENT> <DEDENT> for i , x in enumerate ( removed ) : <NEWLINE> <INDENT> x = N - x <NEWLINE> answer [ i ] -= x * ( x + 1 ) // 2 <NEWLINE> <DEDENT> return answer <NEWLINE> <NL> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> C = ( 0 , ) + tuple ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> AB = tuple ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> answer = solve ( N , C , AB ) <NEWLINE> print ( <STRING> . join ( map ( str , answer [ 1 : ] ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> import queue <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_list = [ ] <NEWLINE> g_list = [ ] <NEWLINE> b_list = [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r_list . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g_list . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += check ( i , g_list , b_list ) <NEWLINE> <NL> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += check ( i , r_list , b_list ) <NEWLINE> <NL> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += check ( i , r_list , g_list ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> def check ( spot , first , second ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> small_first = [ ] <NEWLINE> big_first = [ ] <NEWLINE> small_second = [ ] <NEWLINE> big_second = [ ] <NEWLINE> <NL> for f in first : <NEWLINE> <INDENT> if f < spot : small_first . append ( spot - f ) <NEWLINE> else : big_first . append ( f - spot ) <NEWLINE> <NL> <DEDENT> for s in second : <NEWLINE> <INDENT> if s < spot : small_second . append ( spot - s ) <NEWLINE> else : big_second . append ( s - spot ) <NEWLINE> <NL> <DEDENT> return len ( small_first ) * len ( big_second ) + len ( small_second ) * len ( big_first ) - len ( set ( small_first ) & set ( big_second ) ) - len ( set ( small_second ) & set ( big_first ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for i in range ( h ) ] <NEWLINE> t = [ [ None ] * w for i in range ( h ) ] <NEWLINE> d = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> def dfs ( i , j , bw ) : <NEWLINE> <INDENT> global h , w <NEWLINE> if not ( 0 <= i < h and 0 <= j < w ) or s [ i ] [ j ] == bw or t [ i ] [ j ] : <NEWLINE> <INDENT> return 0 , 0 <NEWLINE> <DEDENT> t [ i ] [ j ] = True <NEWLINE> W , b = 0 , 0 <NEWLINE> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> W += 1 <NEWLINE> <DEDENT> for k in d : <NEWLINE> <INDENT> n , m = dfs ( i + k [ 0 ] , j + k [ 1 ] , s [ i ] [ j ] ) <NEWLINE> W += n <NEWLINE> b += m <NEWLINE> <DEDENT> return W , b <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> X , Y = dfs ( i , j , <STRING> ) <NEWLINE> ans += X * Y <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tel = deque ( ) <NEWLINE> tel . append ( 1 ) <NEWLINE> visit = [ False for _ in range ( n ) ] <NEWLINE> visit [ 0 ] = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nx = a [ tel [ i ] - 1 ] <NEWLINE> if visit [ nx - 1 ] == True : <NEWLINE> <INDENT> tel . append ( nx ) <NEWLINE> <COMMENT> <NL> idx = tel . index ( nx ) <NEWLINE> break <NEWLINE> <DEDENT> tel . append ( nx ) <NEWLINE> visit [ nx - 1 ] = True <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if k <= idx : <NEWLINE> <INDENT> goal = tel [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= idx <NEWLINE> loop_num = len ( tel ) - idx - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> goal = tel [ idx + k % loop_num ] <NEWLINE> <NL> <DEDENT> print ( goal ) <NEWLINE>
import copy <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = sorted ( [ ( a , abs ( a ) ) for a in A ] , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> R = 10 ** 9 + 7 <NEWLINE> P = 1 <NEWLINE> minus = 0 <NEWLINE> last_neg = - 1 <NEWLINE> last_pos = - 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if B [ i ] [ 0 ] > 0 : <NEWLINE> <INDENT> if last_pos != - 1 : <NEWLINE> <INDENT> P = ( P * B [ last_pos ] [ 1 ] ) % R <NEWLINE> <DEDENT> last_pos = i <NEWLINE> <DEDENT> elif B [ i ] [ 0 ] < 0 : <NEWLINE> <INDENT> if last_neg != - 1 : <NEWLINE> <INDENT> P = ( P * B [ last_neg ] [ 1 ] ) % R <NEWLINE> <DEDENT> minus += 1 <NEWLINE> last_neg = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> F = copy . copy ( P ) <NEWLINE> if last_pos != - 1 : <NEWLINE> <INDENT> F = ( F * B [ last_pos ] [ 1 ] ) % R <NEWLINE> <DEDENT> if last_neg != - 1 : <NEWLINE> <INDENT> F = ( F * B [ last_neg ] [ 1 ] ) % R <NEWLINE> <DEDENT> if minus % 2 == 1 : <NEWLINE> <INDENT> if K == N : <NEWLINE> <INDENT> print ( - F % R ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> first_neg = - 1 <NEWLINE> first_pos = - 1 <NEWLINE> count = [ 0 , 0 ] <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if count [ 0 ] == 0 and B [ i ] [ 0 ] > 0 : <NEWLINE> <INDENT> first_pos = i <NEWLINE> count [ 0 ] = 1 <NEWLINE> <DEDENT> elif count [ 1 ] == 0 and B [ i ] [ 0 ] < 0 : <NEWLINE> <INDENT> first_neg = i <NEWLINE> count [ 1 ] = 1 <NEWLINE> <DEDENT> elif count == [ 1 , 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if first_pos == - 1 and last_pos == - 1 : <NEWLINE> <INDENT> P = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> P = ( P * B [ N - i - 1 ] [ 0 ] ) % R <NEWLINE> <DEDENT> print ( P ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if first_pos == - 1 and first_neg == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> list_product = [ ] <NEWLINE> if first_neg != - 1 and last_pos != - 1 : <NEWLINE> <INDENT> list_product . append ( B [ last_neg ] [ 1 ] * B [ first_neg ] [ 1 ] ) <NEWLINE> <DEDENT> if first_pos != - 1 : <NEWLINE> <INDENT> P1 = B [ first_pos ] [ 1 ] <NEWLINE> if last_pos != - 1 : <NEWLINE> <INDENT> P1 = P1 * B [ last_pos ] [ 1 ] <NEWLINE> <DEDENT> list_product . append ( P1 ) <NEWLINE> <DEDENT> print ( max ( list_product ) * P % R ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( F ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
a = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( s [ i ] ) ) <NEWLINE> <DEDENT> a = a [ : : - 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ n - 1 ] ) <NEWLINE>
import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) [ : : - 1 ] <COMMENT> <NEWLINE> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> num , d = 0 , 1 <NEWLINE> <NL> for char in S : <NEWLINE> <INDENT> num = num + int ( char ) * d <NEWLINE> num = num % 2019 <NEWLINE> d = d * 10 <NEWLINE> d = d % 2019 <NEWLINE> counts [ num ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in counts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = - float ( <STRING> ) <NEWLINE> n = min ( b - 1 , n ) <NEWLINE> f1 = math . floor ( a * n / b ) <NEWLINE> f2 = math . floor ( n / b ) <NEWLINE> ans = f1 - ( a * f2 ) <NEWLINE> print ( ans ) <NEWLINE>
ans = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A . sort ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = X <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if not X - i in p : <NEWLINE> <INDENT> ans = X - i <NEWLINE> break <NEWLINE> <DEDENT> elif not X + i in p : <NEWLINE> <INDENT> ans = X + i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while A % 2 == 0 and B % 2 == 0 and C % 2 == 0 : <NEWLINE> <INDENT> a = B // 2 + C // 2 <NEWLINE> b = A // 2 + C // 2 <NEWLINE> c = A // 2 + B // 2 <NEWLINE> if A == a and B == b and C == c : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> A = a <NEWLINE> B = b <NEWLINE> C = c <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> confo = [ A [ N - 1 ] ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += confo [ i ] <NEWLINE> confo . append ( A [ N - i - 2 ] ) <NEWLINE> confo . append ( A [ N - i - 2 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cs = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sorted = N - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if cs [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( sorted , i , - 1 ) : <NEWLINE> <INDENT> sorted = j - 1 <NEWLINE> if cs [ j ] == <STRING> : <NEWLINE> <INDENT> cs [ i ] , cs [ j ] = cs [ j ] , cs [ i ] <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( i + 1 ) > sorted : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> goods = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> goods . append ( s ) <NEWLINE> <DEDENT> goods = set ( goods ) <NEWLINE> print ( len ( goods ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cards = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> suit , num = input ( ) . split ( ) <NEWLINE> num = int ( num ) <NEWLINE> cards . append ( ( suit , num ) ) <NEWLINE> <NL> <DEDENT> for suit in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> for num in range ( 13 ) : <NEWLINE> <INDENT> if not ( ( suit , num + 1 ) in cards ) : <NEWLINE> <INDENT> print ( suit , num + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hlist = [ 0 ] * H <NEWLINE> wlist = [ 0 ] * W <NEWLINE> hw = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> hlist [ h - 1 ] += 1 <NEWLINE> wlist [ w - 1 ] += 1 <NEWLINE> hw . add ( ( h - 1 , w - 1 ) ) <NEWLINE> <NL> <DEDENT> hmax = max ( hlist ) <NEWLINE> wmax = max ( wlist ) <NEWLINE> hmaxlist = [ i for i , v in enumerate ( hlist ) if v == hmax ] <NEWLINE> wmaxlist = [ i for i , v in enumerate ( wlist ) if v == wmax ] <NEWLINE> cnt = - 1 <NEWLINE> for i in hmaxlist : <NEWLINE> <INDENT> bf = False <NEWLINE> for j in wmaxlist : <NEWLINE> <INDENT> if not ( i , j ) in hw : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> bf = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if bf : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( hmax + wmax + cnt ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b >= c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c - b <= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> def gcd ( * number ) : <NEWLINE> <INDENT> return reduce ( math . gcd , number ) <NEWLINE> <NL> <DEDENT> def gcd_list ( number ) : <NEWLINE> <INDENT> return reduce ( math . gcd , number ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> UV = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N - 1 ) ] <NEWLINE> c = [ [ ] for i in range ( N ) ] <NEWLINE> for i , j in UV : <NEWLINE> <INDENT> c [ i - 1 ] . append ( j - 1 ) <NEWLINE> c [ j - 1 ] . append ( i - 1 ) <NEWLINE> <DEDENT> v = [ 0 ] * N <NEWLINE> d = [ 10 ** 9 + 1 ] * N <NEWLINE> stk = [ ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def dfs ( p , l ) : <NEWLINE> <INDENT> i = bisect_left ( d , A [ p ] ) <NEWLINE> stk . append ( ( i , d [ i ] ) ) <NEWLINE> d [ i ] = A [ p ] <NEWLINE> if i == l : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> ans [ p ] = l <NEWLINE> for n in c [ p ] : <NEWLINE> <INDENT> if v [ n ] == 0 : <NEWLINE> <INDENT> v [ n ] = 1 <NEWLINE> dfs ( n , l ) <NEWLINE> <DEDENT> <DEDENT> i , x = stk . pop ( ) <NEWLINE> d [ i ] = x <NEWLINE> <DEDENT> v [ 0 ] = 1 <NEWLINE> dfs ( 0 , 0 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import heapq <NEWLINE> <NL> left = [ 0 ] * ( N + 1 ) <NEWLINE> l = a [ : N ] <NEWLINE> left [ 0 ] = sum ( l ) <NEWLINE> <NL> heapq . heapify ( l ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c = a [ N + i - 1 ] <NEWLINE> lmin = heapq . heappop ( l ) <NEWLINE> if lmin < c : <NEWLINE> <INDENT> left [ i ] = left [ i - 1 ] + c - lmin <NEWLINE> heapq . heappush ( l , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left [ i ] = left [ i - 1 ] <NEWLINE> heapq . heappush ( l , lmin ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ - x for x in a [ : : - 1 ] ] <NEWLINE> right = [ 0 ] * ( N + 1 ) <NEWLINE> r = a [ : N ] <NEWLINE> right [ 0 ] = sum ( r ) <NEWLINE> <NL> heapq . heapify ( r ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c = - a [ N + i - 1 ] <NEWLINE> rmax = - heapq . heappop ( r ) <NEWLINE> if rmax > c : <NEWLINE> <INDENT> right [ i ] = right [ i - 1 ] - c + rmax <NEWLINE> heapq . heappush ( r , - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right [ i ] = right [ i - 1 ] <NEWLINE> heapq . heappush ( r , - rmax ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = - 10 ** 20 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , left [ i ] + right [ N - i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
h , w , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count_row = [ 0 for _ in range ( h ) ] <NEWLINE> count_col = [ 0 for _ in range ( w ) ] <NEWLINE> <COMMENT> <NL> max_col = 0 <NEWLINE> max_row = 0 <NEWLINE> max_row_index = [ ] <NEWLINE> max_col_index = [ ] <NEWLINE> M = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> mh , mw = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> M . add ( ( mh - 1 , mw - 1 ) ) <NEWLINE> count_row [ mh - 1 ] += 1 <NEWLINE> count_col [ mw - 1 ] += 1 <NEWLINE> if count_row [ mh - 1 ] > max_row : <NEWLINE> <INDENT> max_row = count_row [ mh - 1 ] <NEWLINE> max_row_index = [ mh - 1 ] <NEWLINE> <DEDENT> elif count_row [ mh - 1 ] == max_row : <NEWLINE> <INDENT> max_row_index . append ( mh - 1 ) <NEWLINE> <NL> <DEDENT> if count_col [ mw - 1 ] > max_col : <NEWLINE> <INDENT> max_col = count_col [ mw - 1 ] <NEWLINE> max_col_index = [ mw - 1 ] <NEWLINE> <DEDENT> elif count_col [ mw - 1 ] == max_col : <NEWLINE> <INDENT> max_col_index . append ( mw - 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max_col + max_row - 1 <NEWLINE> <NL> if len ( max_col_index ) * len ( max_row_index ) > m : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> for i in max_row_index : <NEWLINE> <INDENT> for j in max_col_index : <NEWLINE> <INDENT> if ( i , j ) not in M : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ K - Q ] * N <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> A [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> if a < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> B = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ j ] == S [ i + j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = B + 1 <NEWLINE> <DEDENT> <DEDENT> A . append ( B ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> print ( A [ 0 ] ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> ls = len ( s ) <NEWLINE> for i in range ( ls ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for j in range ( 1 , ls - 1 ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < ls : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , ( n - i - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i ] != s [ i + 2 * j ] and s [ i + j ] != s [ i + 2 * j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> books . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = INF <NEWLINE> for s in ( range ( 1 << N ) ) : <NEWLINE> <INDENT> A = defaultdict ( int ) <NEWLINE> cost = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s >> i & 1 : <NEWLINE> <INDENT> book = books [ i ] <NEWLINE> cost += book [ 0 ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> A [ i ] += book [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ok = True <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if A [ i ] < X : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - x , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> mx = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , mx / 2 ) <NEWLINE> <DEDENT> print ( sum ( [ int ( - a ) for a in A ] ) ) <NEWLINE>
count = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if <STRING> == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( count , x ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect_right <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> As . sort ( ) <NEWLINE> <NL> def isOK ( x ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for k , A in enumerate ( As , start = 1 ) : <NEWLINE> <INDENT> i = bisect_left ( As , x - A ) <NEWLINE> num += N - i <NEWLINE> if num >= M : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif num + ( N - k ) * N < M : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return num >= M <NEWLINE> <NL> <DEDENT> ng , ok = 2 * 10 ** 5 + 1 , 0 <NEWLINE> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ng + ok ) // 2 <NEWLINE> if isOK ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> score = 0 <NEWLINE> num = 0 <NEWLINE> accAs = list ( accumulate ( [ 0 ] + As ) ) <NEWLINE> for A in As : <NEWLINE> <INDENT> i = bisect_right ( As , ok - A ) <NEWLINE> score += A * ( N - i ) + accAs [ N ] - accAs [ i ] <NEWLINE> num += N - i <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = score + ok * ( M - num ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> solve ( ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . p = [ i for i in range ( n ) ] <NEWLINE> self . components = n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . p [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ x ] = self . root ( self . p [ x ] ) <NEWLINE> return self . p [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . root ( x ) , self . root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> self . p [ x ] = y <NEWLINE> self . components -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return ( self . root ( x ) == self . root ( y ) ) <NEWLINE> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> UF = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> X , Y , Z = map ( int , input ( ) . split ( ) ) <NEWLINE> X , Y = X - 1 , Y - 1 <NEWLINE> UF . unite ( X , Y ) <NEWLINE> <NL> <DEDENT> print ( UF . components ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( max ( num ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> need = 0 <NEWLINE> stock = 0 <NEWLINE> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> if a > b : need += ( a - b ) <NEWLINE> if b > a : stock += ( b - a ) // 2 <NEWLINE> <NL> <DEDENT> if stock >= need : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> zero = 0 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> A . append ( [ a [ i ] , 0 ] ) <NEWLINE> <DEDENT> elif a [ i ] < 0 : <NEWLINE> <INDENT> A . append ( [ - a [ i ] , 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> <DEDENT> if k > n - zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> A = list ( reversed ( sorted ( A ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> cnt += A [ i ] [ 1 ] <NEWLINE> <DEDENT> chk = 0 <NEWLINE> for i in range ( n - zero ) : <NEWLINE> <INDENT> chk += A [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * A [ i ] [ 0 ] % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> elif chk == n - zero : <NEWLINE> <INDENT> if zero > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * A [ n - i - 1 ] [ 0 ] % mod <NEWLINE> <DEDENT> print ( ( - ans ) % mod ) <NEWLINE> <DEDENT> elif k == n - zero : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if zero > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * A [ i ] [ 0 ] % mod <NEWLINE> <DEDENT> print ( ( - ans ) % mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if A [ k ] [ 1 ] == 0 : <NEWLINE> <INDENT> p = A [ k ] [ 0 ] <NEWLINE> m = 0 <NEWLINE> for i in range ( k + 1 , n - zero ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == 1 : <NEWLINE> <INDENT> m = A [ i ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = A [ k ] [ 0 ] <NEWLINE> p = 0 <NEWLINE> for i in range ( k + 1 , n - zero ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == 0 : <NEWLINE> <INDENT> p = A [ i ] [ 0 ] <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if A [ k - 1 ] [ 1 ] == 0 : <NEWLINE> <INDENT> l = 0 <NEWLINE> Xl = - 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> if A [ k - i - 2 ] [ 1 ] == 1 : <NEWLINE> <INDENT> l = A [ k - i - 2 ] [ 0 ] <NEWLINE> Xl = k - i - 2 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if m * l > p * A [ k - 1 ] [ 0 ] or Xl == - 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans = ans * A [ i ] [ 0 ] % mod <NEWLINE> <DEDENT> ans = ans * m % mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if i == Xl : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = ans * A [ i ] [ 0 ] % mod <NEWLINE> <DEDENT> ans = ans * p % mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = 0 <NEWLINE> Xl = - 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> if A [ k - i - 2 ] [ 1 ] == 0 : <NEWLINE> <INDENT> l = A [ k - i - 2 ] [ 0 ] <NEWLINE> Xl = k - i - 2 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if p * l > m * A [ k - 1 ] [ 0 ] or Xl == - 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans = ans * A [ i ] [ 0 ] % mod <NEWLINE> <DEDENT> ans = ans * p % mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if i == Xl : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = ans * A [ i ] [ 0 ] % mod <NEWLINE> <DEDENT> ans = ans * m % mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> al = { } <NEWLINE> suma = sum ( a ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i not in al : <NEWLINE> <INDENT> al [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> al [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if b [ i ] [ 0 ] in al : <NEWLINE> <INDENT> suma += ( b [ i ] [ 1 ] - b [ i ] [ 0 ] ) * al [ b [ i ] [ 0 ] ] <NEWLINE> <NL> if b [ i ] [ 1 ] in al : <NEWLINE> <NL> <INDENT> al [ b [ i ] [ 1 ] ] += al [ b [ i ] [ 0 ] ] <NEWLINE> al [ b [ i ] [ 0 ] ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> al [ b [ i ] [ 1 ] ] = al [ b [ i ] [ 0 ] ] <NEWLINE> al [ b [ i ] [ 0 ] ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( suma ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += int ( ( N - 1 ) / i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> z = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> z += a [ i ] <NEWLINE> <DEDENT> e = z % 2 <NEWLINE> <NL> y = ( z ** 2 ) % 2000000014 <NEWLINE> <NL> x = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> x += a [ j ] ** 2 <NEWLINE> x = x % 2000000014 <NEWLINE> <NL> <DEDENT> w = int ( ( ( y - x ) / 2 ) % 1000000007 ) <NEWLINE> print ( w ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> start = a [ 0 ] [ 0 ] <NEWLINE> goal = n <NEWLINE> tmp , ans = [ ] , [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] == goal : <NEWLINE> <INDENT> tmp . append ( a [ i ] [ 0 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if a [ j ] [ 0 ] == start : <NEWLINE> <INDENT> ans . append ( a [ j ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( tmp ) & set ( ans ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import itertools <COMMENT> <NEWLINE> import bisect <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> bo = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> bo . sort ( ) <NEWLINE> <NL> for a in range ( n - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> cnt += bisect . bisect_left ( bo , bo [ a ] + bo [ b ] ) - ( b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> tmp = - 1 <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if As [ k + i ] > As [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> sum = 0 <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sum = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( ( N - i ) // 2 + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = S [ i ] <NEWLINE> b = S [ i + j ] <NEWLINE> c = S [ i + 2 * j ] <NEWLINE> if a != b and b != c and c != a : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> def fact ( n , p ) : <NEWLINE> <INDENT> a = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> a [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i + 1 ] = ( a [ i ] * ( i + 1 ) ) % p <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> f = fact ( n , p ) <NEWLINE> invf = [ ] <NEWLINE> for i in f : <NEWLINE> <INDENT> invf . append ( pow ( i , - 1 , p ) ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i > n - k + 1 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> ans . append ( ( ( f [ n - k + 1 ] * invf [ n - k + 1 - i ] ) % p ) * ( ( invf [ i ] * f [ k - 1 ] ) % p ) * ( ( invf [ i - 1 ] * invf [ k - i ] ) ) % p ) <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i % p ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def rpn ( str ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> stack = [ ] <NEWLINE> for i in range ( 0 , len ( str ) ) : <NEWLINE> <INDENT> c = str [ i ] <NEWLINE> if c in <STRING> : <NEWLINE> <INDENT> while len ( stack ) > 0 : <NEWLINE> <INDENT> if stack [ - 1 ] in <STRING> : <NEWLINE> <INDENT> a = stack . pop ( ) <NEWLINE> r . extend ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> stack . extend ( c ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> stack . extend ( c ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> stack . extend ( c ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> while len ( stack ) > 0 : <NEWLINE> <INDENT> a = stack . pop ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r . extend ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> r . extend ( c ) <NEWLINE> <DEDENT> <DEDENT> while len ( stack ) > 0 : <NEWLINE> <INDENT> a = stack . pop ( ) <NEWLINE> r . extend ( a ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def intersect ( a , b ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for e in a : <NEWLINE> <INDENT> if e in b : <NEWLINE> <INDENT> r . extend ( [ e ] ) <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def union ( a , b ) : <NEWLINE> <INDENT> r = list ( set ( a + b ) ) <NEWLINE> return r <NEWLINE> <NL> <DEDENT> def diff ( a , b ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for e in a : <NEWLINE> <INDENT> if e not in b : <NEWLINE> <INDENT> r . extend ( [ e ] ) <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def universal ( sets ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for v in sets . values ( ) : <NEWLINE> <INDENT> r . extend ( v ) <NEWLINE> <DEDENT> r = list ( set ( r ) ) <NEWLINE> return r <NEWLINE> <NL> <DEDENT> def calc ( rpn , sets ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> U = universal ( sets ) <NEWLINE> for c in rpn : <NEWLINE> <INDENT> if c in <STRING> : <NEWLINE> <INDENT> op2 = stack . pop ( ) <NEWLINE> op1 = stack . pop ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> x = intersect ( op1 , op2 ) <NEWLINE> stack . append ( x ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> x = union ( op1 , op2 ) <NEWLINE> stack . append ( x ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> x = diff ( op1 , op2 ) <NEWLINE> stack . append ( x ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> x = diff ( op1 , op2 ) <NEWLINE> y = diff ( op2 , op1 ) <NEWLINE> z = union ( x , y ) <NEWLINE> stack . append ( z ) <NEWLINE> <DEDENT> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> op1 = stack . pop ( ) <NEWLINE> x = diff ( U , op1 ) <NEWLINE> stack . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( sets [ c ] ) <NEWLINE> <DEDENT> <DEDENT> return stack . pop ( ) <NEWLINE> <NL> <DEDENT> lno = 0 <NEWLINE> sets = { } <NEWLINE> name = <STRING> <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> lno += 1 <NEWLINE> if lno % 2 == 1 : <NEWLINE> <INDENT> name = line . strip ( ) . split ( ) [ 0 ] <NEWLINE> <DEDENT> elif name != <STRING> : <NEWLINE> <INDENT> elem = list ( map ( int , line . strip ( ) . split ( ) ) ) <NEWLINE> sets [ name ] = elem <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = rpn ( line . strip ( ) ) <NEWLINE> result = calc ( e , sets ) <NEWLINE> result . sort ( ) <NEWLINE> if len ( result ) > 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( n ) for n in result ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> sets = { } <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <NEWLINE> ans = [ ] <NEWLINE> while n > 26 : <NEWLINE> <INDENT> ans . append ( x [ n % 26 - 1 ] ) <NEWLINE> if n % 26 == 0 : <NEWLINE> <INDENT> n = n // 26 - 1 <NEWLINE> <DEDENT> else : n //= 26 <NEWLINE> <DEDENT> ans . append ( x [ n - 1 ] ) <NEWLINE> print ( <STRING> . join ( ans [ : : - 1 ] ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def nck ( k ) : <NEWLINE> <INDENT> y , z = 1 , 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> y = ( y * ( n + 1 - i ) ) % mod <NEWLINE> z = ( z * pow ( i , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> return ( y * z ) % mod <NEWLINE> <NL> <DEDENT> ans = ( pow ( 2 , n , mod ) - 1 - nck ( a ) - nck ( b ) ) % mod <NEWLINE> print ( ans ) <NEWLINE>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ism ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def isl ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> from math import gcd <NEWLINE> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> n = ii ( ) <NEWLINE> cnd = { } <NEWLINE> azero = 0 <NEWLINE> bzero = 0 <NEWLINE> allzero = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = iim ( ) <NEWLINE> if a * b == 0 : <NEWLINE> <INDENT> if a == 0 and b != 0 : <NEWLINE> <INDENT> azero += 1 <NEWLINE> <DEDENT> elif a != 0 and b == 0 : <NEWLINE> <INDENT> bzero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> allzero += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> before = cnd . get ( ( a , b ) , False ) <NEWLINE> if b > 0 : <NEWLINE> <INDENT> check = cnd . get ( ( b , - a ) , False ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check = cnd . get ( ( - b , a ) , False ) <NEWLINE> <DEDENT> if before : <NEWLINE> <INDENT> cnd [ ( a , b ) ] = [ before [ 0 ] + 1 , before [ 1 ] ] <NEWLINE> <DEDENT> elif check : <NEWLINE> <INDENT> if b > 0 : <NEWLINE> <INDENT> cnd [ ( b , - a ) ] = [ check [ 0 ] , check [ 1 ] + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnd [ ( - b , a ) ] = [ check [ 0 ] , check [ 1 ] + 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnd [ ( a , b ) ] = [ 1 , 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnd [ 0 ] = [ azero , bzero ] <NEWLINE> noreg = 0 <NEWLINE> ans = 1 <NEWLINE> <COMMENT> <NL> for item in cnd . values ( ) : <NEWLINE> <INDENT> if item [ 0 ] == 0 or item [ 1 ] == 0 : <NEWLINE> <INDENT> noreg += max ( item [ 0 ] , item [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= ( 2 ** item [ 0 ] + 2 ** item [ 1 ] - 1 ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ( ans * ( ( 2 ** noreg ) % mod ) - 1 + allzero ) % mod ) <NEWLINE>
import random <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> max_a = 0 <NEWLINE> for i in range ( 1 , max ( n + 1 , m + 1 ) ) : <NEWLINE> <INDENT> if i < n + 1 : <NEWLINE> <INDENT> a_sum . append ( a_sum [ i - 1 ] + a_list [ i - 1 ] ) <NEWLINE> if a_sum [ i ] <= k : <NEWLINE> <INDENT> max_a = i <NEWLINE> <DEDENT> <DEDENT> if i < m + 1 : <NEWLINE> <INDENT> b_sum . append ( b_sum [ i - 1 ] + b_list [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( 0 , max_a + 1 ) : <NEWLINE> <INDENT> while b_sum [ j ] > k - a_sum [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <INDENT> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( a , b ) , c ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( a , b ) , b ) * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum -= 2 * i <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 2019 <NEWLINE> for i in range ( l , min ( l + 2019 , r ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( l + 2020 , r + 1 ) ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , Y , Z , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> p_queue = [ ( A [ 0 ] + B [ 0 ] + C [ 0 ] , 0 , 0 , 0 ) ] <NEWLINE> visited = set ( ) <NEWLINE> visited . add ( ( 0 , 0 , 0 ) ) <NEWLINE> ans = [ ] <NEWLINE> while len ( ans ) < K : <NEWLINE> <INDENT> s , i_A , i_B , i_C = heapq . heappop ( p_queue ) <NEWLINE> ans . append ( - s ) <NEWLINE> if i_A < X - 1 and ( i_A + 1 , i_B , i_C ) not in visited : <NEWLINE> <INDENT> visited . add ( ( i_A + 1 , i_B , i_C ) ) <NEWLINE> t = s - A [ i_A ] + A [ i_A + 1 ] <NEWLINE> heapq . heappush ( p_queue , ( t , i_A + 1 , i_B , i_C ) ) <NEWLINE> <DEDENT> if i_B < Y - 1 and ( i_A , i_B + 1 , i_C ) not in visited : <NEWLINE> <INDENT> visited . add ( ( i_A , i_B + 1 , i_C ) ) <NEWLINE> t = s - B [ i_B ] + B [ i_B + 1 ] <NEWLINE> heapq . heappush ( p_queue , ( t , i_A , i_B + 1 , i_C ) ) <NEWLINE> <DEDENT> if i_C < Z - 1 and ( i_A , i_B , i_C + 1 ) not in visited : <NEWLINE> <INDENT> visited . add ( ( i_A , i_B , i_C + 1 ) ) <NEWLINE> t = s - C [ i_C ] + C [ i_C + 1 ] <NEWLINE> heapq . heappush ( p_queue , ( t , i_A , i_B , i_C + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> op = [ 0 ] * M <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> op [ i ] = ( c , b ) <NEWLINE> <NL> <DEDENT> op . sort ( reverse = True ) <NEWLINE> <NL> now = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> val , maisu = op [ i ] <NEWLINE> if now >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ now ] < val : <NEWLINE> <INDENT> for j in range ( maisu ) : <NEWLINE> <INDENT> if now + j < N : <NEWLINE> <INDENT> if A [ now + j ] < val : <NEWLINE> <INDENT> A [ now + j ] = val <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> now += maisu <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> temp_prev = 0 <NEWLINE> temp_curr = 0 <NEWLINE> x = min ( n , b - 1 ) <NEWLINE> <NL> while x <= n : <NEWLINE> <INDENT> temp_prev = temp_curr <NEWLINE> temp_curr = int ( a * x / b ) - a * int ( x / b ) <NEWLINE> x += 1.0 <NEWLINE> <NL> if temp_curr <= temp_prev : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( temp_curr , temp_prev ) ) <NEWLINE>
class UnionFind ( ) : <COMMENT> <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> union_find = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> union_find . union ( A , B ) <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> answer = max ( answer , union_find . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n + 1 ) ] <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> self . size = [ 1 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . par [ y ] = x <NEWLINE> self . size [ x ] += self . size [ y ] <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def same_check ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = max ( uf . size ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> b = ( n - 1 ) // a <NEWLINE> ans += b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if a [ i - K ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if B == 1 or A == 1 : <NEWLINE> <INDENT> floor = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N < B : <NEWLINE> <INDENT> floor = int ( A * N / B ) - A * int ( N / B ) <NEWLINE> <DEDENT> elif N == B : <NEWLINE> <INDENT> floor = int ( A * ( N - 1 ) / B ) - A * int ( ( N - 1 ) / B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> floor = max ( [ ( int ( A * ( x - 1 ) / B ) - A * int ( ( x - 1 ) / B ) ) for x in range ( B , N , B ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( floor ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> tmp = b <NEWLINE> b = a <NEWLINE> a = tmp <NEWLINE> <NL> <DEDENT> if b > c : <NEWLINE> <INDENT> tmp = c <NEWLINE> c = b <NEWLINE> b = tmp <NEWLINE> <NL> <DEDENT> if a > b : <NEWLINE> <INDENT> tmp = b <NEWLINE> b = a <NEWLINE> a = tmp <NEWLINE> <NL> <DEDENT> print ( a , b , c ) <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if a [ m - 1 ] < ( sum ( a ) / ( 4 * m ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> ans = 1 <NEWLINE> v = True <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> v = False <NEWLINE> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> v = False <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if v : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> i_i = lambda : int ( i_s ( ) ) <NEWLINE> i_l = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> i_s = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> N = i_i ( ) <NEWLINE> S = i_s ( ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ( r * g * b ) - cnt ) <NEWLINE>
import itertools <NEWLINE> n , m , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q_l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <COMMENT> <NL> bar_m = [ i for i in range ( m ) ] <NEWLINE> bar_l = list ( itertools . combinations_with_replacement ( bar_m , n ) ) <NEWLINE> score = 0 <NEWLINE> for bar in bar_l : <NEWLINE> <INDENT> score_tmp = 0 <NEWLINE> for queue in q_l : <NEWLINE> <INDENT> if bar [ queue [ 1 ] - 1 ] - bar [ queue [ 0 ] - 1 ] == queue [ 2 ] : <NEWLINE> <INDENT> score_tmp += queue [ 3 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if score <= score_tmp : <NEWLINE> <INDENT> score = score_tmp <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( num [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter = 0 <NEWLINE> for i in ( reversed ( num ) ) : <NEWLINE> <INDENT> if counter == 0 : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> elif counter == n - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from builtins import pow <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> m = 1000000007 <NEWLINE> <NL> result = 0 <NEWLINE> t = pow ( 26 , K , m ) <NEWLINE> u = pow ( 26 , - 1 , m ) * 25 % m <NEWLINE> l = len ( S ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> result = ( result + t ) % m <NEWLINE> t = ( t * u ) % m * ( l + i ) * pow ( i + 1 , - 1 , m ) % m <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lsA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lsA += lsA <NEWLINE> lsA . sort ( reverse = True ) <NEWLINE> <NL> lsA . pop ( 0 ) <NEWLINE> ans = sum ( lsA [ : N - 1 ] ) <NEWLINE> print ( ans ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( sqrt ( abs ( x2 - x1 ) ** 2 + abs ( y2 - y1 ) ** 2 ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> N = i ( ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if 2 * N <= ( i + 1 ) * i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if N >= B : <NEWLINE> <INDENT> i = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = N <NEWLINE> <DEDENT> d = ( math . floor ( ( A * i ) / B ) - A * math . floor ( i / B ) ) <NEWLINE> print ( d ) <NEWLINE>
c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> . format ( c , x ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> root_dict = { } <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a not in root_dict : <NEWLINE> <INDENT> root_dict [ a ] = deque ( [ b ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root_dict [ a ] . append ( b ) <NEWLINE> <DEDENT> if b not in root_dict : <NEWLINE> <INDENT> root_dict [ b ] = deque ( [ a ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root_dict [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> visited = [ 1 ] + [ - 1 ] * ( n - 1 ) <NEWLINE> <NL> done = deque ( [ 1 ] ) <NEWLINE> <NL> while done : <NEWLINE> <INDENT> x = done . popleft ( ) <NEWLINE> while root_dict [ x ] : <NEWLINE> <INDENT> i = root_dict [ x ] . popleft ( ) <NEWLINE> if visited [ i - 1 ] < 0 : <NEWLINE> <INDENT> visited [ i - 1 ] = x <NEWLINE> done . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in visited : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( visited [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> R [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( R [ i ] ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return ( a * ( x % b ) - ( a * b ) % b ) // b <NEWLINE> <NL> <DEDENT> ans = f ( min ( n , b - 1 ) ) <NEWLINE> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += ( gcd ( i , gcd ( j , l ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce , lru_cache <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MAP1 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> def LIST1 ( ) : return list ( MAP1 ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> @ lru_cache ( None ) <NEWLINE> def F ( s , k ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if k == len ( s ) - 1 : <NEWLINE> <INDENT> return int ( s [ k ] ) <NEWLINE> <DEDENT> ret = F ( s , k + 1 ) + int ( s [ k ] ) * pow ( 10 , len ( s ) - 1 - k , 2019 ) <NEWLINE> ret %= 2019 <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> a = [ 0 ] * 2020 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> a [ F ( s , i ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 2020 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( a [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> minNum = nums [ 0 ] <NEWLINE> maxDiff = False <NEWLINE> for i in nums [ 1 : ] : <NEWLINE> <INDENT> diff = i - minNum <NEWLINE> if maxDiff == False or diff > maxDiff : <NEWLINE> <INDENT> maxDiff = diff <NEWLINE> <DEDENT> if minNum > i : <NEWLINE> <INDENT> minNum = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxDiff ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = len ( a ) <NEWLINE> result = 1 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if a [ i ] == result : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> if i >= b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if result == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - result + 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def bfs ( graph , N , start ) : <NEWLINE> <INDENT> visited = [ 0 ] * N <NEWLINE> visited [ start ] = 1 <NEWLINE> que = deque ( [ start ] ) <NEWLINE> while que : <NEWLINE> <INDENT> node = que . popleft ( ) <NEWLINE> for n in graph [ node ] : <NEWLINE> <INDENT> if not visited [ n ] : <NEWLINE> <INDENT> visited [ n ] = node + 1 <NEWLINE> que . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> visited = bfs ( graph , N , 0 ) <NEWLINE> <NL> if all ( visited [ 1 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * visited [ 1 : ] , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , l1 , l2 , l3 , l4 , l5 , l6 ) : <NEWLINE> <INDENT> self . l1 = l1 <NEWLINE> self . l2 = l2 <NEWLINE> self . l3 = l3 <NEWLINE> self . l4 = l4 <NEWLINE> self . l5 = l5 <NEWLINE> self . l6 = l6 <NEWLINE> self . top = 1 <NEWLINE> self . front = 2 <NEWLINE> self . right = 3 <NEWLINE> <NL> <DEDENT> def get_up_front ( self ) : <NEWLINE> <INDENT> return eval ( <STRING> + <STRING> + <STRING> + str ( self . top ) + <STRING> + <STRING> + <STRING> + str ( self . front ) + <STRING> ) <NEWLINE> <NL> <DEDENT> def get_right ( self ) : <NEWLINE> <INDENT> return eval ( <STRING> + <STRING> + str ( self . right ) ) <NEWLINE> <NL> <DEDENT> def rot ( self ) : <NEWLINE> <INDENT> self . front , self . right = self . right , 7 - self . front <NEWLINE> <NL> <DEDENT> def move ( self , order ) : <NEWLINE> <INDENT> if order == <STRING> : <NEWLINE> <INDENT> pretop = self . top <NEWLINE> self . top = 7 - self . front <NEWLINE> self . front = pretop <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> pretop = self . top <NEWLINE> self . top = 7 - self . right <NEWLINE> self . right = pretop <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> pretop = self . top <NEWLINE> self . top = self . front <NEWLINE> self . front = 7 - pretop <NEWLINE> <DEDENT> elif order == <STRING> : <NEWLINE> <INDENT> pretop = self . top <NEWLINE> self . top = self . right <NEWLINE> self . right = 7 - pretop <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = Dice ( l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] , l [ 4 ] , l [ 5 ] ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> up , front = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> while ( up , front ) != d . get_up_front ( ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> d . move ( <STRING> ) <NEWLINE> if up == d . get_up_front ( ) [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if up != d . get_up_front ( ) [ 0 ] : <NEWLINE> <INDENT> for l in range ( 4 ) : <NEWLINE> <INDENT> d . move ( <STRING> ) <NEWLINE> if up == d . get_up_front ( ) [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> d . rot ( ) <NEWLINE> if front == d . get_up_front ( ) [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d . get_right ( ) ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> info = list ( ) <NEWLINE> buildings = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> info = input ( ) . split ( ) <NEWLINE> buildings [ int ( info [ 0 ] ) - 1 ] [ int ( info [ 1 ] ) - 1 ] [ int ( info [ 2 ] ) - 1 ] += int ( info [ 3 ] ) <NEWLINE> <NL> <DEDENT> for i , b in enumerate ( buildings ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , f ) ) ) <NEWLINE> <DEDENT> if not i == ( len ( buildings ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> x = len ( str ( n ) ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , 26 ) : <NEWLINE> <INDENT> cnt += n // ( ( 5 ** i ) * 2 ) <NEWLINE> <NL> <NL> <DEDENT> print ( cnt ) <NEWLINE>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> left , right = 0 , a [ n - 1 ] <NEWLINE> mid = right <NEWLINE> while abs ( right - left ) > 2 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> temp = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] <= mid : break <NEWLINE> temp += a [ i ] // mid <NEWLINE> <DEDENT> if temp > k : left = mid <NEWLINE> else : right = mid <NEWLINE> <DEDENT> mid -= 1 <NEWLINE> if mid <= 0 : mid = 1 <NEWLINE> while True : <NEWLINE> <INDENT> temp = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] <= mid : break <NEWLINE> temp += a [ i ] // mid <NEWLINE> <DEDENT> if temp > k : mid += 1 <NEWLINE> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if flag : break <NEWLINE> <DEDENT> print ( mid ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> evals = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( k , n , 1 ) : <NEWLINE> <INDENT> edge = scores [ cnt ] <NEWLINE> new_edge = scores [ i ] <NEWLINE> if edge < new_edge : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = len ( str ( N ) ) <NEWLINE> <NL> f = 1 <NEWLINE> while f * f <= N : <NEWLINE> <INDENT> if N % f == 0 : <NEWLINE> <INDENT> ans = min ( ans , max ( len ( str ( f ) ) , len ( str ( N // f ) ) ) ) <NEWLINE> <DEDENT> f += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if s <= k : <NEWLINE> <INDENT> ans = ( s + 2 ) * ( s + 1 ) / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> ans = ans + ( 0 <= s - i - j <= k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = N + 1 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> x = min ( x , i + N // i ) <NEWLINE> <DEDENT> <DEDENT> print ( x - 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = dict ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R = i + a [ i ] <NEWLINE> if not R in X : <NEWLINE> <INDENT> X [ R ] = 1 <NEWLINE> <DEDENT> else : X [ R ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> L = i - a [ i ] <NEWLINE> if L in X : <NEWLINE> <INDENT> ans += X [ L ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> X = int ( input ( ) ) <NEWLINE> <NL> if X > 29 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
paramA , paramB , paramC , paramK = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> result = min ( paramA , paramK ) <NEWLINE> paramK -= paramA <NEWLINE> if paramK > 0 : <NEWLINE> <INDENT> paramK -= paramB <NEWLINE> if paramK > 0 : <NEWLINE> <INDENT> result -= min ( paramC , paramK ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> print ( input ( ) [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in d : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mx = max ( d . values ( ) ) <NEWLINE> for s in sorted ( k for k in d if d [ k ] == mx ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> min_v = R [ 0 ] <NEWLINE> max_v = R [ 1 ] - R [ 0 ] <NEWLINE> for i in range ( 1 , len ( R ) ) : <NEWLINE> <INDENT> if min_v > R [ i - 1 ] : <NEWLINE> <INDENT> min_v = R [ i - 1 ] <NEWLINE> <DEDENT> if max_v < R [ i ] - min_v : <NEWLINE> <INDENT> max_v = R [ i ] - min_v <NEWLINE> <DEDENT> <DEDENT> print ( max_v ) <NEWLINE>
from collections import deque <NEWLINE> def bfs ( graph , N ) : <NEWLINE> <INDENT> que = deque ( [ 0 ] ) <NEWLINE> visited = [ 0 ] * N <NEWLINE> visited [ 0 ] = 1 <NEWLINE> while que : <NEWLINE> <INDENT> node = que . popleft ( ) <NEWLINE> for i in graph [ node ] : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> visited [ i ] = node + 1 <NEWLINE> que . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <DEDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = bfs ( l , N ) [ 1 : ] <NEWLINE> if all ( ans ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alp = <STRING> <NEWLINE> d = { i + 1 : s for i , s in enumerate ( alp ) } <NEWLINE> s = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> q , mod = divmod ( n , 26 ) <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> s = <STRING> + s <NEWLINE> n = q - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = d [ mod ] + s <NEWLINE> n = q <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def solve ( A : int , B : int ) : <NEWLINE> <INDENT> r = str ( A * B ) <NEWLINE> if len ( r ) > 3 : <NEWLINE> <INDENT> print ( r [ : len ( r ) - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> A = int ( next ( tokens ) ) <COMMENT> <NEWLINE> B = next ( tokens ) <NEWLINE> startWithZero = True <NEWLINE> everyZero = True <NEWLINE> l = 0 <NEWLINE> bstr = <STRING> <NEWLINE> for c in B : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> if startWithZero : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bstr += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> everyZero = False <NEWLINE> l += 1 <NEWLINE> startWithZero = False <NEWLINE> bstr += c <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 - l ) : <NEWLINE> <INDENT> bstr += <STRING> <NEWLINE> <DEDENT> if everyZero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> solve ( A , int ( bstr ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = LI ( ) <NEWLINE> <NL> M_div = [ ] <NEWLINE> for i in range ( 1 , int ( M ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if M % i == 0 : <NEWLINE> <INDENT> M_div . append ( i ) <NEWLINE> M_div . append ( M // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in M_div : <NEWLINE> <INDENT> if M // i >= N : <NEWLINE> <INDENT> ans = max ( i , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a , b , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = 998244353 <NEWLINE> fac = [ 0 ] * a <COMMENT> <NEWLINE> finv = [ 0 ] * a <COMMENT> <NEWLINE> inv = [ 0 ] * a <NEWLINE> N = a - 1 <NEWLINE> def com_init ( ) : <NEWLINE> <INDENT> fac [ 0 ] , finv [ 0 ] = 1 , 1 <NEWLINE> if a < 2 : return <NEWLINE> fac [ 1 ] , finv [ 1 ] = 1 , 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % C <NEWLINE> inv [ i ] = C - inv [ C % i ] * ( C // i ) % C <COMMENT> <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % C <NEWLINE> <DEDENT> <DEDENT> def com ( m , k ) : <NEWLINE> <INDENT> if m < k : return 0 <NEWLINE> elif m < 0 or k < 0 : return 0 <NEWLINE> else : <NEWLINE> <INDENT> return fac [ m ] * ( finv [ k ] * finv [ m - k ] % C ) % C <NEWLINE> <DEDENT> <DEDENT> com_init ( ) <NEWLINE> bfac = [ 0 ] * a <NEWLINE> bfac [ 0 ] = 1 <NEWLINE> for i in range ( 1 , a ) : <NEWLINE> <INDENT> bfac [ i ] = bfac [ i - 1 ] * ( b - 1 ) % C <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans += com ( a - 1 , i ) * bfac [ a - 1 - i ] % C <NEWLINE> <DEDENT> print ( ans * b % C ) <NEWLINE>
n = ( int ) ( input ( ) ) <NEWLINE> a = [ 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> temp = i ** 2 <NEWLINE> while ( temp <= n ) : <NEWLINE> <INDENT> a . append ( temp ) <NEWLINE> temp *= i <NEWLINE> <DEDENT> <DEDENT> a = sorted ( set ( a ) ) <NEWLINE> <COMMENT> <NL> print ( list ( i for i in a if i <= n ) [ - 1 ] ) <NEWLINE>
def f ( n ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> while n > 1 : <NEWLINE> <INDENT> res *= n <NEWLINE> n -= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def h ( n , m ) : <NEWLINE> <INDENT> return f ( n + m - 1 ) // f ( n ) // f ( m - 1 ) <NEWLINE> <NL> <DEDENT> s = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> pair = s // 3 <NEWLINE> <NL> for i in range ( 1 , pair + 1 ) : <NEWLINE> <INDENT> res += h ( s - 3 * i , i ) <NEWLINE> <DEDENT> print ( res % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> amax = max ( a ) + 1 <NEWLINE> e = [ 0 ] * amax <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> e [ a [ i ] ] += 1 <NEWLINE> if e [ a [ i ] ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * a [ i ] , amax , a [ i ] ) : <NEWLINE> <INDENT> e [ j ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( e . count ( 1 ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> pi = math . pi <NEWLINE> print ( <STRING> . format ( r ** 2 * pi , r * 2 * pi ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> a_dict = dict ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if i in a_dict : <NEWLINE> <INDENT> a_dict [ i ] = a_dict [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> a_sum = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if not b in a_dict : <NEWLINE> <INDENT> print ( a_sum ) <NEWLINE> continue <NEWLINE> <DEDENT> a_sum = a_sum - a_dict [ b ] * b + a_dict [ b ] * c <NEWLINE> if c in a_dict : <NEWLINE> <INDENT> a_dict [ c ] = a_dict [ c ] + a_dict [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ c ] = a_dict [ b ] <NEWLINE> <DEDENT> a_dict [ b ] = 0 <NEWLINE> print ( a_sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for _ in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> to [ A ] . append ( B ) <NEWLINE> to [ B ] . append ( A ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( v , to , seen ) : <NEWLINE> <INDENT> global count <NEWLINE> seen [ v ] = True <NEWLINE> count += 1 <NEWLINE> for nv in to [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( nv , to , seen ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global count <NEWLINE> seen = [ False ] * N <NEWLINE> cnts = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not seen [ i ] : <NEWLINE> <INDENT> dfs ( i , to , seen ) <NEWLINE> cnts . append ( count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( cnts ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = collections . Counter ( a ) <NEWLINE> b , c = [ ] , [ ] <NEWLINE> for t in a : <NEWLINE> <INDENT> if a [ t ] == 1 : <NEWLINE> <INDENT> b . append ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( t ) <NEWLINE> <DEDENT> <DEDENT> if len ( b ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b . sort ( ) <NEWLINE> bm = b [ - 1 ] <NEWLINE> ok = [ True ] * ( bm + 1 ) <NEWLINE> <NL> if len ( c ) > 0 : <NEWLINE> <INDENT> c . sort ( ) <NEWLINE> for t in c : <NEWLINE> <INDENT> if t >= bm : continue <NEWLINE> if ok [ t ] == False : continue <NEWLINE> i = 1 <NEWLINE> while i * t <= bm : <NEWLINE> <INDENT> ok [ i * t ] = False <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for t in b : <NEWLINE> <INDENT> if ok [ t ] == False : continue <NEWLINE> i = 2 <NEWLINE> while i * t <= bm : <NEWLINE> <INDENT> ok [ i * t ] = False <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for t in b : <NEWLINE> <INDENT> if ok [ t ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if k <= a : <NEWLINE> <INDENT> sum = k <NEWLINE> print ( sum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = a <NEWLINE> k = k - a <NEWLINE> <DEDENT> if k <= b : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - b <NEWLINE> sum = sum - k <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_A = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum_A . append ( sum_A [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> sum_B = [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> sum_B . append ( sum_B [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if sum_A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while sum_B [ j ] > K - sum_A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> root [ a - 1 ] . append ( b - 1 ) <NEWLINE> root [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> times = [ 0 ] * n <NEWLINE> sign = [ - 1 ] * n <NEWLINE> sign [ 0 ] = 0 <NEWLINE> color = [ False ] * n <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> while que : <COMMENT> <NEWLINE> <INDENT> i = que . popleft ( ) <NEWLINE> if color [ i ] == False : <NEWLINE> <INDENT> for edge in root [ i ] : <NEWLINE> <INDENT> if color [ edge ] == False and sign [ edge ] == - 1 : <COMMENT> <NEWLINE> <INDENT> sign [ edge ] = i <NEWLINE> que . append ( edge ) <NEWLINE> <DEDENT> <DEDENT> color [ i ] = True <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( sign [ i + 1 ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sm = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans += a [ i ] * ( sm - a [ i ] ) <NEWLINE> sm = sm - a [ i ] <NEWLINE> ans %= ( 10 ** 9 ) + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import networkx as nx <NEWLINE> n , m , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> G = nx . Graph ( ) <NEWLINE> G . add_nodes_from ( range ( 1 , n + 1 ) ) <NEWLINE> G . add_edges_from ( zip ( AB [ : : 2 ] , AB [ 1 : : 2 ] ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> d = dict ( nx . bfs_predecessors ( G , 1 ) ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> sample_input = list ( range ( 4 ) ) <NEWLINE> sample_input [ 0 ] = <STRING> <NEWLINE> sample_input [ 1 ] = <STRING> <NEWLINE> sample_input [ 2 ] = <STRING> <NEWLINE> sample_input [ 3 ] = <STRING> <NEWLINE> give_sample_input = None <NEWLINE> if give_sample_input is not None : <NEWLINE> <INDENT> sample_input_list = sample_input [ give_sample_input ] . split ( <STRING> ) <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sample_input_list . pop ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> class ACGTDictNode ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . A = None <COMMENT> <NEWLINE> self . C = None <NEWLINE> self . G = None <NEWLINE> self . T = None <NEWLINE> self . has_end = False <NEWLINE> <NL> <NL> <DEDENT> def add_if_none ( self , acgt ) : <NEWLINE> <INDENT> if acgt == <STRING> : <NEWLINE> <INDENT> if self . A is not None : <NEWLINE> <INDENT> return self . A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . A = ACGTDictNode ( ) <NEWLINE> return self . A <NEWLINE> <DEDENT> <DEDENT> elif acgt == <STRING> : <NEWLINE> <INDENT> if self . C is not None : <NEWLINE> <INDENT> return self . C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . C = ACGTDictNode ( ) <NEWLINE> return self . C <NEWLINE> <DEDENT> <DEDENT> elif acgt == <STRING> : <NEWLINE> <INDENT> if self . G is not None : <NEWLINE> <INDENT> return self . G <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . G = ACGTDictNode ( ) <NEWLINE> return self . G <NEWLINE> <DEDENT> <DEDENT> elif acgt == <STRING> : <NEWLINE> <INDENT> if self . T is not None : <NEWLINE> <INDENT> return self . T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . T = ACGTDictNode ( ) <NEWLINE> return self . T <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> assert False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get ( self , acgt ) : <NEWLINE> <INDENT> if acgt == <STRING> : <NEWLINE> <INDENT> return self . A <NEWLINE> <DEDENT> elif acgt == <STRING> : <NEWLINE> <INDENT> return self . C <NEWLINE> <DEDENT> elif acgt == <STRING> : <NEWLINE> <INDENT> return self . G <NEWLINE> <DEDENT> elif acgt == <STRING> : <NEWLINE> <INDENT> return self . T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def add_end ( self ) : <NEWLINE> <INDENT> self . has_end = True <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> class ACGTDict ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . tree = ACGTDictNode ( ) <NEWLINE> <NL> <NL> <DEDENT> def insert ( self , string ) : <NEWLINE> <INDENT> node = self . tree <NEWLINE> for c in string : <NEWLINE> <INDENT> node = node . add_if_none ( c ) <NEWLINE> <DEDENT> node . add_end ( ) <NEWLINE> <NL> <NL> <DEDENT> def find ( self , string ) : <NEWLINE> <INDENT> node = self . tree <NEWLINE> for c in string : <NEWLINE> <INDENT> node = node . get ( c ) <NEWLINE> if node is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return node . has_end <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> dict = ACGTDict ( ) <NEWLINE> num_of_commands = int ( input ( ) ) <NEWLINE> for n in range ( num_of_commands ) : <NEWLINE> <INDENT> input_str = input ( ) <NEWLINE> command , data = input_str . split ( <STRING> ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> dict . insert ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dict . find ( data ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) . rstrip ( ) ) <NEWLINE> R = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R [ i ] = int ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> margin = - 10 ** 9 <NEWLINE> min_R = R [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> margin = max ( margin , R [ j ] - min_R ) <NEWLINE> min_R = min ( min_R , R [ j ] ) <NEWLINE> <NL> <DEDENT> print ( margin ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = NI ( ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( N // n ) * ( 2 * n + ( N // n - 1 ) * n ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( x ) <NEWLINE> kk = x // d <NEWLINE> <NL> if kk >= k : <NEWLINE> <INDENT> print ( str ( x - ( d * k ) ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> k -= kk <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( str ( x - ( d * kk ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( abs ( x - ( d * ( kk + 1 ) ) ) ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def expectation ( N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return N / 2 + 0.5 <NEWLINE> <NL> <DEDENT> Ps = [ ] <NEWLINE> s = 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> s += p <NEWLINE> Ps . append ( s ) <NEWLINE> <NL> <DEDENT> cmax = Ps [ K - 1 ] <NEWLINE> max_sp = 0 <NEWLINE> <NL> for ix in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> csum = Ps [ ix + K - 1 ] - Ps [ ix - 1 ] <NEWLINE> if cmax < csum : <NEWLINE> <INDENT> max_sp = ix <NEWLINE> cmax = csum <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ix in range ( max_sp , max_sp + K ) : <NEWLINE> <INDENT> ans += expectation ( P [ ix ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> nums = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : nums [ i ] += 1 <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if nums [ b ] > 0 : <NEWLINE> <INDENT> ans -= b * nums [ b ] <NEWLINE> nums [ c ] += nums [ b ] <NEWLINE> ans += c * nums [ b ] <NEWLINE> print ( ans ) <NEWLINE> nums [ b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
def insertionSort ( A , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> j = i <NEWLINE> while ( j > 0 ) and ( A [ j - 1 ] > A [ j ] ) : <NEWLINE> <INDENT> tmp = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = A [ j ] <NEWLINE> A [ j ] = tmp <NEWLINE> j -= 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> A = input ( ) <NEWLINE> A = list ( map ( int , A . split ( ) ) ) <NEWLINE> insertionSort ( A , N ) <NEWLINE>
import numpy <NEWLINE> import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = numpy . cumsum ( numpy . array ( A ) ) <NEWLINE> A = list ( A ) <NEWLINE> A . insert ( 0 , 0 ) <NEWLINE> B = numpy . cumsum ( numpy . array ( B ) ) <NEWLINE> B = list ( B ) <NEWLINE> B . insert ( 0 , 0 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if K - A [ i ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b = bisect . bisect ( B , K - A [ i ] ) <NEWLINE> ans = max ( ans , i + b - 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if ( re . match ( <STRING> , s ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( int ( eval ( s ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> multinums = [ 0 ] <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( 0 , n ) : <COMMENT> <NEWLINE> <INDENT> multinums . append ( multinums [ i ] + nums [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> total += nums [ i ] * ( multinums [ n ] - multinums [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( total % ( 10 ** 9 + 7 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( M ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> list = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if H [ x [ i ] - 1 ] < H [ y [ i ] - 1 ] : <NEWLINE> <INDENT> list [ x [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> elif H [ x [ i ] - 1 ] == H [ y [ i ] - 1 ] : <NEWLINE> <INDENT> list [ x [ i ] - 1 ] += 1 <NEWLINE> list [ y [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list [ y [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if list [ i ] == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a_ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_csum = [ 0 ] * n <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> now += a_ls [ i ] <NEWLINE> a_csum [ i ] = now <NEWLINE> <DEDENT> a_csum . append ( 0 ) <NEWLINE> a_csum . sort ( ) <NEWLINE> ans = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a_csum [ i ] == a_csum [ i + 1 ] : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now > 0 : <NEWLINE> <INDENT> ans += combinations_count ( now + 1 , 2 ) <NEWLINE> <DEDENT> now = 0 <NEWLINE> <DEDENT> <DEDENT> if now > 0 : <NEWLINE> <INDENT> ans += combinations_count ( now + 1 , 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
line1 = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( line1 [ 0 ] ) <NEWLINE> m = int ( line1 [ 1 ] ) <NEWLINE> <NL> line2 = input ( ) . split ( <STRING> ) <NEWLINE> hs = [ ] <NEWLINE> for h in line2 : <NEWLINE> <INDENT> hs . append ( int ( h ) ) <NEWLINE> <NL> <DEDENT> roads = [ ] <NEWLINE> for _ in range ( 0 , m ) : <NEWLINE> <INDENT> line = input ( ) . split ( <STRING> ) <NEWLINE> roads . append ( [ int ( line [ 0 ] ) , int ( line [ 1 ] ) ] ) <NEWLINE> <NL> <DEDENT> graph = { } <NEWLINE> for o in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> graph [ o ] = [ ] <NEWLINE> <NL> <DEDENT> for road in roads : <NEWLINE> <INDENT> graph [ road [ 0 ] ] . append ( road [ 1 ] ) <NEWLINE> graph [ road [ 1 ] ] . append ( road [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> def is_good ( x ) : <NEWLINE> <INDENT> height = hs [ x - 1 ] <NEWLINE> for adj in graph [ x ] : <NEWLINE> <INDENT> if hs [ adj - 1 ] >= height : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <STRING> <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for o in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if is_good ( o ) : <NEWLINE> <INDENT> ans . append ( o ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
leng = int ( input ( ) ) <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> x = 1 <NEWLINE> <NL> if <STRING> in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( leng ) : <NEWLINE> <INDENT> a = int ( nums [ i ] ) <NEWLINE> x = x * a <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> from itertools import islice <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> result = deque ( S ) <NEWLINE> <NL> <NL> def input_str ( line ) : <NEWLINE> <INDENT> r = line . split ( ) <NEWLINE> if len ( r ) == 1 : <NEWLINE> <INDENT> return int ( r [ 0 ] ) , None , None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return int ( r [ 0 ] ) , int ( r [ 1 ] ) , r [ 2 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> reverse_flag = False <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> Q , F , C = input_str ( input ( ) ) <NEWLINE> if Q == 1 : <NEWLINE> <INDENT> reverse_flag ^= True <NEWLINE> <DEDENT> if Q == 2 : <NEWLINE> <INDENT> if reverse_flag : <NEWLINE> <INDENT> if F == 1 : <NEWLINE> <INDENT> result . append ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . appendleft ( C ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if F == 1 : <NEWLINE> <INDENT> result . appendleft ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( C ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if reverse_flag : <NEWLINE> <INDENT> result . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( l [ 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> l . append ( l [ i - 2 ] + l [ i - 1 ] ) <NEWLINE> <DEDENT> print ( l [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def f ( A , B , n ) : <NEWLINE> <INDENT> judge = B - A <NEWLINE> <NL> if judge % 2 == 0 : <NEWLINE> <INDENT> n += judge // 2 <NEWLINE> return ( n ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if abs ( A - 1 ) < abs ( N - B ) : <NEWLINE> <INDENT> if A == 1 : <NEWLINE> <INDENT> A = A <NEWLINE> B -= 1 <NEWLINE> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= A - 1 <NEWLINE> n += A - 1 <NEWLINE> A -= A - 1 <NEWLINE> <DEDENT> return f ( A , B , n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B == N : <NEWLINE> <INDENT> B = B <NEWLINE> A += 1 <NEWLINE> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += abs ( N - B ) <NEWLINE> n += abs ( N - B ) <NEWLINE> B += abs ( N - B ) <NEWLINE> <DEDENT> return f ( A , B , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( A , B , 0 ) ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> A = [ None ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> def maxHeapify ( H , A , i ) : <NEWLINE> <INDENT> left = 2 * i <NEWLINE> right = left + 1 <NEWLINE> <NL> if left <= H and A [ left ] > A [ i ] : <NEWLINE> <INDENT> largest = left <NEWLINE> <DEDENT> else : largest = i <NEWLINE> if right <= H and A [ right ] > A [ largest ] : <NEWLINE> <INDENT> largest = right <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( H , A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildmaxHeap ( H , A ) : <NEWLINE> <INDENT> for i in range ( H // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( H , A , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> buildmaxHeap ( H , A ) <NEWLINE> <NL> for i in A [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> <NL> <NL> def CHECK_NUM2 ( n , i ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> if i <= n : <NEWLINE> <INDENT> CHECK_NUM ( n , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def CHECK_NUM ( n , i ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x //= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> if i > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def call ( n ) : <NEWLINE> <INDENT> CHECK_NUM ( n , 1 ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> call ( n ) <NEWLINE> print ( <STRING> + <STRING> . join ( [ str ( r ) for r in res ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> mod = 7 <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> if mod % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = ( 10 * mod + 7 ) % K <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def fac ( x ) : <NEWLINE> <INDENT> if x <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> s = 1 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> s = s * i <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> def com ( m , n ) : <NEWLINE> <INDENT> return fac ( m ) / ( fac ( n ) * fac ( m - n ) ) <NEWLINE> <NL> <NL> <DEDENT> temps = input ( ) . split ( ) <NEWLINE> n = int ( temps [ 0 ] ) <NEWLINE> m = int ( temps [ 1 ] ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( m , n + 2 ) : <NEWLINE> <INDENT> min = int ( ( i - 1 ) * i / 2 ) <NEWLINE> max = int ( ( 2 * n - i + 1 ) * i / 2 ) <NEWLINE> sum = sum + max - min + 1 <NEWLINE> <DEDENT> print ( int ( sum % ( math . pow ( 10 , 9 ) + 7 ) ) ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <COMMENT> <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> ab . append ( { a , b } ) <NEWLINE> <DEDENT> import itertools <NEWLINE> <NL> cnt = 0 <NEWLINE> for v in itertools . permutations ( range ( 1 , n ) ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> ok = True <NEWLINE> for v2 in v : <NEWLINE> <INDENT> if { l , v2 } not in ab : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> l = v2 <NEWLINE> <DEDENT> if ok : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import os <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> args = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nb = args [ 0 ] <NEWLINE> nl = args [ 1 ] <NEWLINE> if nb == 0 or ( nl % 2 == 1 ) or nl == 0 or nb > nl or ( nl / 4.0 ) > nb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( nb + 1 ) : <NEWLINE> <INDENT> if ( ( nb - i ) * 4 + i * 2 ) == nl : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = sorted ( a ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <NL> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i , x in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> a . append ( a [ i ] + int ( x ) ) <NEWLINE> <DEDENT> for i , x in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> b . append ( b [ i ] + int ( x ) ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> a_ = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j = bisect . bisect ( b , k - a [ i ] ) - 1 <NEWLINE> res = max ( res , i + j ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
human_num = int ( input ( ) ) <NEWLINE> jousi_num = [ 0 for i in range ( human_num ) ] <NEWLINE> <NL> nyu = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for k in nyu : <NEWLINE> <INDENT> jousi_num [ k - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for ri in jousi_num : <NEWLINE> <INDENT> print ( ri ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> S , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( S ) <NEWLINE> c . append ( C ) <NEWLINE> <DEDENT> for i in range ( 10 ** ( n + 1 ) ) : <NEWLINE> <INDENT> tmp = str ( i ) <NEWLINE> if len ( tmp ) == n and all ( [ tmp [ s [ j ] - 1 ] == str ( c [ j ] ) for j in range ( m ) ] ) : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <COMMENT> <NEWLINE> a = [ 0 for i in range ( h + 1 ) ] <COMMENT> <NEWLINE> b = [ 0 for _ in range ( w + 1 ) ] <COMMENT> <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ bomb [ i ] [ 0 ] ] += 1 <NEWLINE> b [ bomb [ i ] [ 1 ] ] += 1 <NEWLINE> <DEDENT> am = max ( a ) <COMMENT> <NEWLINE> bm = max ( b ) <COMMENT> <NEWLINE> hmax = [ 0 ] * ( h + 1 ) <COMMENT> <NEWLINE> wmax = [ 0 ] * ( w + 1 ) <COMMENT> <NEWLINE> for i in range ( h + 1 ) : <NEWLINE> <INDENT> if am == a [ i ] : <NEWLINE> <INDENT> hmax [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( w + 1 ) : <NEWLINE> <INDENT> if bm == b [ i ] : <NEWLINE> <INDENT> wmax [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = am + bm <COMMENT> <NEWLINE> k = sum ( hmax ) * sum ( wmax ) <NEWLINE> if k > m : <COMMENT> <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in bomb : <NEWLINE> <INDENT> if hmax [ i [ 0 ] ] == 1 and wmax [ i [ 1 ] ] == 1 : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <DEDENT> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> from builtins import max , min , range <NEWLINE> <NL> INF = 10 ** 6 <NEWLINE> <NL> H , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> Ch , Cw = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> Dh , Dw = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> S = [ readline ( ) [ : - 1 ] for _ in range ( H ) ] <NEWLINE> <NL> t = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> th = t [ h ] <NEWLINE> Sh = S [ h ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if Sh [ w ] == <STRING> : <NEWLINE> <INDENT> th [ w ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t [ Ch ] [ Cw ] = 0 <NEWLINE> q = deque ( [ ( Ch , Cw ) ] ) <NEWLINE> a = 0 <NEWLINE> while q : <NEWLINE> <INDENT> warpq = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> h , w = q . popleft ( ) <NEWLINE> warpq . append ( ( h , w ) ) <NEWLINE> if h - 1 >= 0 and t [ h - 1 ] [ w ] > a : <NEWLINE> <INDENT> q . append ( ( h - 1 , w ) ) <NEWLINE> t [ h - 1 ] [ w ] = a <NEWLINE> <DEDENT> if h + 1 < H and t [ h + 1 ] [ w ] > a : <NEWLINE> <INDENT> q . append ( ( h + 1 , w ) ) <NEWLINE> t [ h + 1 ] [ w ] = a <NEWLINE> <DEDENT> if w - 1 >= 0 and t [ h ] [ w - 1 ] > a : <NEWLINE> <INDENT> q . append ( ( h , w - 1 ) ) <NEWLINE> t [ h ] [ w - 1 ] = a <NEWLINE> <DEDENT> if w + 1 < W and t [ h ] [ w + 1 ] > a : <NEWLINE> <INDENT> q . append ( ( h , w + 1 ) ) <NEWLINE> t [ h ] [ w + 1 ] = a <NEWLINE> <NL> <DEDENT> <DEDENT> if t [ Dh ] [ Dw ] != INF : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a += 1 <NEWLINE> for h , w in warpq : <NEWLINE> <INDENT> for i in range ( max ( 0 , h - 2 ) , min ( H , h + 3 ) ) : <NEWLINE> <INDENT> ti = t [ i ] <NEWLINE> for j in range ( max ( 0 , w - 2 ) , min ( W , w + 3 ) ) : <NEWLINE> <INDENT> if ti [ j ] > a : <NEWLINE> <INDENT> ti [ j ] = a <NEWLINE> q . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if t [ Dh ] [ Dw ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t [ Dh ] [ Dw ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def judge ( ) : <NEWLINE> <INDENT> cnt = 0 <COMMENT> <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == y : <NEWLINE> <COMMENT> <NL> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> if cnt == 3 : <NEWLINE> <COMMENT> <NL> <INDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> if judge ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> low = 0 <NEWLINE> high = K <NEWLINE> <NL> while low <= high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> i = mid <NEWLINE> j = K - mid <NEWLINE> ans_pre = ( X + D * i - D * j ) <NEWLINE> if ans_pre > 0 : <NEWLINE> <INDENT> high = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if low > K : <NEWLINE> <INDENT> low = high <NEWLINE> <DEDENT> if high < 0 : <NEWLINE> <INDENT> high = low <NEWLINE> <NL> <DEDENT> ans_h = min ( abs ( ( X + D * high - D * ( K - high ) ) ) , abs ( X + D * ( K - high ) - D * high ) ) <NEWLINE> ans_l = min ( abs ( ( X + D * low - D * ( K - low ) ) ) , abs ( X + D * ( K - low ) - D * low ) ) <NEWLINE> <NL> print ( min ( ans_l , ans_h ) ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> val = math . gcd ( i , j ) <NEWLINE> val = math . gcd ( val , k ) <NEWLINE> ans += val * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> ac_done = [ False ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if ac_done [ p - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += l [ p - 1 ] <NEWLINE> ac_done [ p - 1 ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> data = list ( sys . stdin . readline ( ) [ : - 1 ] ) <NEWLINE> <NL> ponds = deque ( ) <NEWLINE> result = deque ( ) <NEWLINE> index = 0 <NEWLINE> amount = 0 <NEWLINE> lefs = deque ( ) <NEWLINE> <NL> for i in data : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> ponds . append ( [ i , index ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> while 1 <= len ( ponds ) : <NEWLINE> <INDENT> pond , ind = ponds . pop ( ) <NEWLINE> if pond == <STRING> : <NEWLINE> <INDENT> count += ( index - ind ) <NEWLINE> amount += count <NEWLINE> pre_pond = 0 <NEWLINE> pre_left = 0 <NEWLINE> while 0 < len ( lefs ) and ind < lefs [ - 1 ] : <NEWLINE> <INDENT> pre_left = lefs . pop ( ) <NEWLINE> pre_pond += result . pop ( ) <NEWLINE> <DEDENT> lefs . append ( ind ) <NEWLINE> result . append ( count + pre_pond ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> index += 1 <NEWLINE> <NL> <DEDENT> print ( amount ) <NEWLINE> if 0 == len ( result ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( result ) , <STRING> . join ( map ( str , result ) ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> arr = deque ( ) <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> cmd = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if cmd [ 0 ] == 0 : <NEWLINE> <INDENT> if cmd [ 1 ] : <NEWLINE> <INDENT> arr . append ( cmd [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . appendleft ( cmd [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 0 ] == 1 : <NEWLINE> <INDENT> print ( arr [ cmd [ 1 ] ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cmd [ 1 ] : <NEWLINE> <INDENT> arr . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> prev = ans = - 1 <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i - prev > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif i - prev == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> prev = i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import log2 , ceil <NEWLINE> <NL> <NL> class SegmentTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> tn = 2 ** ceil ( log2 ( n ) ) <NEWLINE> self . a = [ 2 ** 31 - 1 ] * ( tn * 2 ) <NEWLINE> <NL> <DEDENT> def find ( self , c , l , r , i ) : <NEWLINE> <INDENT> if self . a [ c ] != - 1 : <NEWLINE> <INDENT> return self . a [ c ] <NEWLINE> <DEDENT> mid = ( l + r ) // 2 <NEWLINE> if i <= mid : <NEWLINE> <INDENT> return self . find ( c * 2 , l , mid , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . find ( c * 2 + 1 , mid + 1 , r , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , c , l , r , s , t , x ) : <NEWLINE> <INDENT> if l == s and r == t : <NEWLINE> <INDENT> self . a [ c ] = x <NEWLINE> return <NEWLINE> <DEDENT> cv = self . a [ c ] <NEWLINE> if cv != - 1 : <NEWLINE> <INDENT> self . a [ c * 2 ] = self . a [ c * 2 + 1 ] = cv <NEWLINE> self . a [ c ] = - 1 <NEWLINE> <DEDENT> mid = ( l + r ) // 2 <NEWLINE> if t <= mid : <NEWLINE> <INDENT> self . update ( c * 2 , l , mid , s , t , x ) <NEWLINE> <DEDENT> elif s > mid : <NEWLINE> <INDENT> self . update ( c * 2 + 1 , mid + 1 , r , s , t , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . update ( c * 2 , l , mid , s , mid , x ) <NEWLINE> self . update ( c * 2 + 1 , mid + 1 , r , mid + 1 , t , x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> st = SegmentTree ( n ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> s , t , x = map ( int , query [ 1 : ] ) <NEWLINE> st . update ( 1 , 0 , n - 1 , s , t , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( st . find ( 1 , 0 , n - 1 , int ( query [ 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> gcd = math . gcd ( a , b ) <NEWLINE> <NL> def prime_factorization ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> prime = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n //= i <NEWLINE> prime . append ( i ) <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> prime . append ( n ) <NEWLINE> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> print ( len ( prime_factorization ( gcd ) ) + 1 ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r ** 2 * math . pi , r * 2 * math . pi ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> Sum_a = 0 <NEWLINE> Sum_j_list = np . cumsum ( alist ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> Sum_j = int ( ( Sum_j_list [ N - 1 ] - Sum_j_list [ i ] ) % int ( 1e9 + 7 ) ) <NEWLINE> Sum_a += ( alist [ i ] * Sum_j ) % int ( 1e9 + 7 ) <NEWLINE> <DEDENT> print ( int ( Sum_a % int ( 1e9 + 7 ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> a = len ( S ) <NEWLINE> mod = 0 <NEWLINE> ten = 1 <NEWLINE> L = [ 0 ] * 2019 <COMMENT> <NEWLINE> L [ 0 ] = 1 <NEWLINE> for i in range ( a - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> mod = ( int ( S [ i ] ) * ( ten ) + mod ) % 2019 <NEWLINE> L [ mod ] += 1 <NEWLINE> ten = ( ten * 10 ) % 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> sum = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> sum *= a [ i ] <NEWLINE> if ( sum > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> S = int ( input ( ) ) <NEWLINE> h = math . floor ( S / 3600 ) <NEWLINE> m = math . floor ( ( S - h * 3600 ) / 60 ) <NEWLINE> s = ( S - ( h * 3600 + m * 60 ) ) % 60 <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
import math , itertools , fractions , heapq , collections , bisect , sys , queue , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> <NL> <COMMENT> <NL> def summarizeList ( l ) : <NEWLINE> <INDENT> sl = sorted ( l ) <NEWLINE> <NL> a = sl [ 0 ] <NEWLINE> c = 1 <NEWLINE> res = [ ] <NEWLINE> <NL> for x in sl [ 1 : ] : <NEWLINE> <INDENT> if x == a : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( [ a , c ] ) <NEWLINE> a = x <NEWLINE> c = 1 <NEWLINE> <DEDENT> <DEDENT> res . append ( [ a , c ] ) <NEWLINE> <NL> return res <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> n = len ( s ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> <NL> rl = [ 0 ] * ( n + 1 ) <NEWLINE> for i , x in enumerate ( s ) : <NEWLINE> <INDENT> rl [ i + 1 ] = ( int ( x ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> rl [ i + 1 ] += rl [ i ] <NEWLINE> rl [ i + 1 ] %= 2019 <NEWLINE> <NL> <NL> <DEDENT> sl = summarizeList ( rl ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for x , c in sl : <NEWLINE> <INDENT> ans += ( c * ( c - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
<COMMENT> <NL> def Marge ( A , left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( n1 ) : <NEWLINE> <INDENT> L . append ( A [ left + i ] ) <NEWLINE> <DEDENT> for i in range ( n2 ) : <NEWLINE> <INDENT> R . append ( A [ mid + i ] ) <NEWLINE> <DEDENT> L . append ( 100000000000000000 ) <NEWLINE> R . append ( 100000000000000000 ) <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> c += n1 - i <NEWLINE> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def MS ( A , left , right , c ) : <NEWLINE> <NL> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> c1 = MS ( A , left , mid , c ) <NEWLINE> c2 = MS ( A , mid , right , c ) <NEWLINE> c3 = Marge ( A , left , mid , right ) <NEWLINE> return c1 + c2 + c3 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = int ( A [ i ] ) <NEWLINE> <DEDENT> cnt = MS ( A , 0 , n , 0 ) <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> e = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> dist = [ - 1 ] * ( n + 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a ] . append ( ( b , c ) ) <NEWLINE> e [ b ] . append ( ( a , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = deque ( ) <NEWLINE> a . append ( ( k , 0 ) ) <NEWLINE> while a : <NEWLINE> <INDENT> x , d = a . popleft ( ) <NEWLINE> dist [ x ] = d <NEWLINE> for j , nc in e [ x ] : <NEWLINE> <INDENT> if dist [ j ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( ( j , d + nc ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( dist [ x ] + dist [ y ] ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> X , K , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def sgn ( X ) : <NEWLINE> <INDENT> if X > 0 : return 1 <NEWLINE> if X < 0 : return - 1 <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if X > 0 : <NEWLINE> <INDENT> x_greedy = X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_greedy = X + K * D <NEWLINE> <NL> <DEDENT> if sgn ( X ) == sgn ( x_greedy ) : <NEWLINE> <INDENT> print ( abs ( x_greedy ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> x_r = X % D <NEWLINE> x_l = x_r - D <NEWLINE> <NL> r_parity = ( abs ( X - x_r ) // D ) % 2 <NEWLINE> <NL> if K % 2 == r_parity : <NEWLINE> <INDENT> print ( abs ( x_r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x_l ) ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> seq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += seq [ i ] <NEWLINE> <NL> <DEDENT> s2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s2 += seq [ i ] ** 2 <NEWLINE> <NL> <NL> <DEDENT> s0 = ( s ** 2 - s2 ) // 2 <NEWLINE> <NL> print ( s0 % ( 10 ** 9 + 7 ) ) <NEWLINE>
figure = <STRING> <NEWLINE> height , width = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> while height or width : <NEWLINE> <INDENT> side = ( <STRING> * width ) + <STRING> <NEWLINE> rect = ( side * height ) + <STRING> <NEWLINE> figure += rect <NEWLINE> height , width = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> print ( figure [ : - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = deque ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = C . copy ( ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> C . popleft ( ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( N - K ) : <NEWLINE> <INDENT> preans = D . popleft ( ) <NEWLINE> ans = C . popleft ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if preans < ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if preans >= ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> mx = 3503 <NEWLINE> found = False <NEWLINE> for i in range ( 1 , mx ) : <NEWLINE> <INDENT> for j in range ( 1 , mx ) : <NEWLINE> <INDENT> if i * j * 4 % N != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> den = ( ( i * j * 4 ) // N ) - i - j <NEWLINE> num = i * j <NEWLINE> if den == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num % den == 0 and num // den > 0 and num // den < mx : <NEWLINE> <INDENT> print ( i , j , num // den ) <NEWLINE> found = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if found : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = Counter ( A ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> if cnt [ 0 ] == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cnt . most_common ( 1 ) [ 0 ] [ 1 ] == N * 2 // 3 and cnt [ 0 ] == N // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = cnt . most_common ( 3 ) <NEWLINE> if x [ 0 ] [ 1 ] == x [ 1 ] [ 1 ] == x [ 2 ] [ 1 ] == N // 3 : <NEWLINE> <INDENT> if x [ 0 ] [ 0 ] ^ x [ 1 ] [ 0 ] ^ x [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , 101 , 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 , 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 , 1 ) : <NEWLINE> <INDENT> n = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if n > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ n - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> ans = ( ans * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> ans_count = [ ] <NEWLINE> total = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total += a [ i ] <NEWLINE> <NL> <DEDENT> count = collections . Counter ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> num = count [ bc [ i ] [ 0 ] ] <NEWLINE> count [ bc [ i ] [ 0 ] ] = 0 <NEWLINE> count [ bc [ i ] [ 1 ] ] += num <NEWLINE> total += ( bc [ i ] [ 1 ] - bc [ i ] [ 0 ] ) * num <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tou = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> tou [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * tou [ i ] [ j ] ) <NEWLINE> <DEDENT> if i != 3 : print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x [ 0 ] == 0 and x [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for w in range ( x [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for h in range ( x [ 0 ] - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for w in range ( x [ 1 ] - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> for w in range ( x [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
S = input ( ) <NEWLINE> week = { <STRING> : 7 , <STRING> : 6 , <STRING> : 5 , <STRING> : 4 , <STRING> : 3 , <STRING> : 2 , <STRING> : 1 } <NEWLINE> print ( week [ S ] ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sorted_x = sorted ( X ) <NEWLINE> <NL> l , r = sorted_x [ n // 2 ] , sorted_x [ n // 2 - 1 ] <NEWLINE> <NL> for x in X : <NEWLINE> <INDENT> if bisect . bisect_left ( sorted_x , x ) < n // 2 : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT>
def dfs ( u , cnt ) : <NEWLINE> <INDENT> cnt += point [ u ] <NEWLINE> counter [ u ] = cnt <NEWLINE> color [ u ] = GRAY <NEWLINE> for v in M [ u ] : <NEWLINE> <INDENT> if color [ v ] == WHITE : <NEWLINE> <INDENT> dfs ( v , cnt ) <NEWLINE> <DEDENT> <DEDENT> color [ u ] = BLACK <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ [ ] for _ in range ( n ) ] <NEWLINE> point = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> M [ a - 1 ] . append ( b - 1 ) <NEWLINE> M [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> WHITE , GRAY , BLACK = 0 , 1 , 2 <NEWLINE> color = [ WHITE ] * n <NEWLINE> <NL> counter = [ 0 ] * n <NEWLINE> dfs ( 0 , 0 ) <NEWLINE> <NL> print ( * counter ) <NEWLINE>
import collections , itertools , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> xy = [ LI ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> x_coord = [ i [ 0 ] for i in xy ] <NEWLINE> x_coord . sort ( ) <NEWLINE> x_val_num = { x_coord [ i ] : i for i in range ( N ) } <NEWLINE> y_coord = [ i [ 1 ] for i in xy ] <NEWLINE> y_coord . sort ( ) <NEWLINE> y_val_num = { y_coord [ i ] : i for i in range ( N ) } <NEWLINE> <NL> <COMMENT> <NL> xy_cnt = [ [ 0 ] * N for _ in range ( N ) ] <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> xy_cnt [ y_val_num [ y ] ] [ x_val_num [ x ] ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> xy_acm = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> xy_acm [ i + 1 ] [ j + 1 ] = xy_cnt [ i ] [ j ] + xy_acm [ i + 1 ] [ j ] + xy_acm [ i ] [ j + 1 ] - xy_acm [ i ] [ j ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = INF <NEWLINE> for yl , yu in itertools . combinations ( range ( N + 1 ) , 2 ) : <NEWLINE> <INDENT> for xl , xu in itertools . combinations ( range ( N + 1 ) , 2 ) : <NEWLINE> <INDENT> cnt = xy_acm [ yu ] [ xu ] - xy_acm [ yu ] [ xl ] - xy_acm [ yl ] [ xu ] + xy_acm [ yl ] [ xl ] <NEWLINE> <COMMENT> <NL> if cnt >= K : <NEWLINE> <INDENT> ans = min ( ( x_coord [ xu - 1 ] - x_coord [ xl ] ) * ( y_coord [ yu - 1 ] - y_coord [ yl ] ) , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> x = <STRING> <NEWLINE> a_idx = 0 <NEWLINE> b_idx = 0 <NEWLINE> c_idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if a_idx == len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = str ( a [ a_idx ] ) <NEWLINE> a_idx += 1 <NEWLINE> <DEDENT> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> if b_idx == len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = str ( b [ b_idx ] ) <NEWLINE> b_idx += 1 <NEWLINE> <DEDENT> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> if c_idx == len ( c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = str ( c [ c_idx ] ) <NEWLINE> c_idx += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = <STRING> <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( len ( Counter ( l ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ 0 ] * k <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num [ i % k ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in range ( k ) : <NEWLINE> <INDENT> b = ( k - a ) % k <NEWLINE> c = ( k - a ) % k <NEWLINE> if ( ( b + c ) % k != 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += num [ a ] * num [ b ] * num [ c ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) ; exit ( ) <NEWLINE> <NL> <DEDENT> cnt = num = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> num += 7 * pow ( 10 , cnt , k ) <NEWLINE> num %= k <NEWLINE> cnt += 1 <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nums = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> nums [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans0 = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] <NEWLINE> ans = ans0 <NEWLINE> for i in range ( 2 , 10 ** 5 - 1 ) : <NEWLINE> <INDENT> ans1 = ans0 - nums [ i - 2 ] + nums [ i + 1 ] <NEWLINE> ans = max ( ans , ans1 ) <NEWLINE> ans0 = ans1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 and a [ i ] % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = ( Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C in A : <NEWLINE> <INDENT> A [ C ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ C ] = B <NEWLINE> <DEDENT> <DEDENT> A = sorted ( A . items ( ) , reverse = True ) <NEWLINE> tmp = 0 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> while tmp < N : <NEWLINE> <INDENT> i , j = A [ cnt ] <NEWLINE> ans += min ( N - tmp , j ) * i <NEWLINE> cnt += 1 <NEWLINE> tmp += min ( N - tmp , j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> items = { } <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> items [ input ( ) ] = None <NEWLINE> <DEDENT> print ( len ( items ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> listA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> L1 = [ 0 ] * N <NEWLINE> R1 = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L += [ i + listA [ i ] ] <NEWLINE> R += [ i - listA [ i ] ] <NEWLINE> try : <NEWLINE> <INDENT> L1 [ i + 1 + listA [ i ] ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> if i - listA [ i ] > 0 : <NEWLINE> <INDENT> R1 [ i + 1 - listA [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans += L1 [ i ] * R1 [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> num = [ 0 for i in range ( 2019 ) ] <NEWLINE> num [ 0 ] = 1 <NEWLINE> t = 1 <NEWLINE> rem = 0 <NEWLINE> <NL> for i in reversed ( S ) : <NEWLINE> <INDENT> rem += int ( i ) * t <NEWLINE> rem %= mod <NEWLINE> t *= 10 <NEWLINE> t %= mod <NEWLINE> num [ rem ] += 1 <NEWLINE> <NL> <DEDENT> print ( int ( sum ( [ i * ( i - 1 ) / 2 for i in num ] ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> a , b = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> a [ i ] += c <NEWLINE> x = a [ i ] % b [ i ] <NEWLINE> if x : <NEWLINE> <INDENT> if a [ i ] < b [ i ] : <NEWLINE> <INDENT> c += b [ i ] - a [ i ] <NEWLINE> <DEDENT> elif a [ i ] > b [ i ] : <NEWLINE> <INDENT> c += b [ i ] - x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> _mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> min0 = sum ( range ( 0 , k ) ) <NEWLINE> max0 = sum ( range ( n + 1 - k , n + 1 ) ) <NEWLINE> cnt = max0 - min0 + 1 <NEWLINE> ans = cnt <NEWLINE> <NL> for i in range ( k + 1 , n + 2 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> cnt = cnt + ( n + 1 - i ) - ( i - 1 ) <NEWLINE> ans += cnt % _mod <NEWLINE> <NL> <DEDENT> print ( ans % _mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> while h != 0 : <NEWLINE> <INDENT> for _ in range ( h ) : <NEWLINE> <INDENT> for _ in range ( w ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> def dp ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif i >= 2 : <NEWLINE> <INDENT> if memo [ i ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] = min ( dp ( i - 2 ) + abs ( h [ i ] - h [ i - 2 ] ) , dp ( i - 1 ) + abs ( h [ i ] - h [ i - 1 ] ) ) <NEWLINE> return memo [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp ( n - 1 ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> list_sum = sum ( num_list ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> list_sum -= num_list [ i ] <NEWLINE> ans += num_list [ i ] * list_sum <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> result = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def myfunc ( N ) : <NEWLINE> <INDENT> if ( N <= 1 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 2 * myfunc ( int ( N / 2 ) ) + 1 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( myfunc ( N ) ) <NEWLINE> <DEDENT>
n , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> ary = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def search_v ( p ) : <NEWLINE> <INDENT> v = 0 <NEWLINE> w = 0 <NEWLINE> tmp_k = 1 <NEWLINE> ind = 0 <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> if tmp_k > k : <NEWLINE> <INDENT> return v <NEWLINE> <DEDENT> if ind == n : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> tmp = ary [ ind ] <NEWLINE> if w + tmp <= p : <NEWLINE> <INDENT> w += tmp <NEWLINE> v += 1 <NEWLINE> ind += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = 0 <NEWLINE> tmp_k += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> max_p = n * 10000 <NEWLINE> ps = range ( max_p + 1 ) <NEWLINE> left = 0 <NEWLINE> right = max_p <NEWLINE> <NL> while left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> v = search_v ( ps [ mid ] ) <NEWLINE> <NL> if v >= n : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ps [ right ] ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> m = N // i <NEWLINE> ans += m * i * ( m + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> if S [ 2 ] == S [ 3 ] and S [ 4 ] == S [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = 0 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <NL> <INDENT> if l [ i ] > l [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <NL> if s >= 3 : <NEWLINE> <INDENT> red = [ None ] * s <NEWLINE> red [ 0 ] = 0 <NEWLINE> red [ 1 ] = 0 <NEWLINE> red [ 2 ] = 0 <NEWLINE> for x in range ( 3 , s ) : <NEWLINE> <INDENT> red [ x ] = ( red [ x - 1 ] + red [ x - 3 ] + 1 ) % 1000000007 <NEWLINE> <DEDENT> print ( ( red [ s - 3 ] + 1 ) % 1000000007 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> if a [ i ] <= a [ i - k ] : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> <DEDENT> print ( str ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , N = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> ans = math . floor ( A * min ( B - 1 , N ) / B ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X = sum ( A ) <NEWLINE> x = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x += A [ i ] <NEWLINE> ans += A [ i ] * ( X - x ) <NEWLINE> <NL> <DEDENT> print ( ans % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> lst = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> lst [ i ] = int ( lst [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> lst . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> def get_cost ( x , y ) : <NEWLINE> <INDENT> return ( x - y ) ** 2 <NEWLINE> <NL> <DEDENT> costs = [ ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( lst [ 0 ] , lst [ - 1 ] ) : <COMMENT> <NEWLINE> <INDENT> cost = 0 <NEWLINE> for j in lst : <NEWLINE> <INDENT> cost = cost + get_cost ( j , i ) <NEWLINE> <DEDENT> costs . append ( cost ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> costs . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if costs != [ ] : <NEWLINE> <INDENT> print ( costs [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ 0 ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> now = a [ visited [ - 1 ] ] - 1 <NEWLINE> visited . append ( now ) <NEWLINE> <NL> <DEDENT> if k < n : <NEWLINE> <INDENT> print ( visited [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = visited . index ( visited [ - 1 ] ) <NEWLINE> loop = visited [ : : - 1 ] [ 1 : ] . index ( visited [ - 1 ] ) + 1 <NEWLINE> x = ( k - p - 1 ) % loop <NEWLINE> print ( visited [ p + x + 1 ] + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> List . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> resList = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> resList [ List [ i ] [ 0 ] - 1 ] += 1 <NEWLINE> if List [ i ] [ 1 ] < N : <NEWLINE> <INDENT> resList [ List [ i ] [ 1 ] ] += - 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> resList [ j ] = resList [ j ] + resList [ j - 1 ] <NEWLINE> <DEDENT> print ( resList . count ( M ) ) <NEWLINE>
import networkx as nx <NEWLINE> import numpy as np <NEWLINE> <NL> h , w , * X , = open ( 0 ) . read ( ) . split ( ) <NEWLINE> h , w = int ( h ) , int ( w ) <NEWLINE> <NL> G = nx . grid_2d_graph ( h , w ) <NEWLINE> for i , S in enumerate ( X ) : <NEWLINE> <INDENT> for j , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> G . remove_node ( ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> path = nx . shortest_path ( G , ( 0 , 0 ) , ( h - 1 , w - 1 ) ) <NEWLINE> <DEDENT> except nx . NetworkXNoPath : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for node in path : <NEWLINE> <INDENT> G . remove_node ( node ) <NEWLINE> <DEDENT> print ( len ( G . nodes ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> v = li [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and li [ j ] > v : <NEWLINE> <INDENT> li [ j + 1 ] = li [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> li [ j + 1 ] = v <NEWLINE> for j in range ( x ) : <NEWLINE> <INDENT> if j != x - 1 : <NEWLINE> <INDENT> print ( li [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> elif j == x - 1 : <NEWLINE> <INDENT> print ( li [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> def sum ( a , b ) : <NEWLINE> <INDENT> r = ( a + b ) * ( b - a + 1 ) / 2 <NEWLINE> return int ( r ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sum_num = 0 <NEWLINE> N , K = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> mi = sum ( 0 , i - 1 ) <NEWLINE> ma = sum ( N - i + 1 , N ) <NEWLINE> sum_num += ma - mi + 1 <NEWLINE> <NL> <DEDENT> print ( sum_num % mod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import numba as nb <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> @ nb . njit <NEWLINE> def solve ( w , weight , value ) : <NEWLINE> <INDENT> total = w <NEWLINE> dp = np . zeros ( shape = ( n + 1 , w + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for w in range ( total + 1 ) : <NEWLINE> <INDENT> if weight [ i ] <= w : <NEWLINE> <INDENT> dp [ i ] [ w ] = max ( value [ i ] + dp [ i - 1 ] [ w - weight [ i ] ] , dp [ i - 1 ] [ w ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ w ] = dp [ i - 1 ] [ w ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ l - 1 ] [ total ] ) <NEWLINE> <DEDENT> n , w = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> weight = [ 0 ] * n <NEWLINE> value = [ 0 ] * n <NEWLINE> total = w <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> weight [ i ] = x <NEWLINE> value [ i ] = y <NEWLINE> <DEDENT> l = len ( weight ) <NEWLINE> solve ( w , weight , value ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> if abs ( ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> orig_n = n <NEWLINE> res = [ ] <NEWLINE> i = 2 <NEWLINE> half_n = n // 2 <NEWLINE> root_n = int ( n ** ( 1 / 2 ) ) <NEWLINE> is_prime = True <NEWLINE> while i <= ( root_n ) : <NEWLINE> <INDENT> if orig_n % i == 0 : <NEWLINE> <INDENT> is_prime = False <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if is_prime : res . append ( orig_n ) <NEWLINE> <NL> while i <= half_n and not ( is_prime ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> n = n // i <NEWLINE> res . append ( i ) <NEWLINE> i = 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( orig_n , <STRING> . join ( map ( str , res ) ) ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> a_ls = [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b_ls = [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a_ls [ i ] += a_ls [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b_ls [ i ] += b_ls [ i - 1 ] <NEWLINE> <NL> <DEDENT> b_cnt = m <NEWLINE> for a_cnt in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> if a_ls [ a_cnt ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while a_ls [ a_cnt ] + b_ls [ b_cnt ] > k : <NEWLINE> <INDENT> b_cnt -= 1 <NEWLINE> <DEDENT> ans = max ( ans , a_cnt + b_cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = re . findall ( <STRING> , S ) <NEWLINE> G = re . findall ( <STRING> , S ) <NEWLINE> B = re . findall ( <STRING> , S ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for d in range ( ( N - 1 - i ) // 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + d + 1 ] and S [ i + d + 1 ] != S [ i + 2 * d + 2 ] and S [ i + 2 * d + 2 ] != S [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( R ) * len ( G ) * len ( B ) - c ) <NEWLINE>
from collections import deque <NEWLINE> def calcXor ( nums ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for n in nums : <NEWLINE> <INDENT> x = x ^ n <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_xor = calcXor ( A ) <NEWLINE> <NL> ans = deque ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans . append ( A_xor ^ a ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL>
import math <NEWLINE> import queue <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> m = n <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def comb ( n , r ) : <COMMENT> <NEWLINE> <INDENT> l = min ( r , n - r ) <NEWLINE> m = n <NEWLINE> u = 1 <NEWLINE> for _i in range ( l ) : <NEWLINE> <INDENT> u *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return u // fact ( l ) <NEWLINE> <DEDENT> def printQueue ( q ) : <NEWLINE> <INDENT> r = q <NEWLINE> ans = [ 0 ] * r . qsize ( ) <NEWLINE> for i in range ( r . qsize ( ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans [ i ] = r . get ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> def binary_search ( li , item ) : <COMMENT> <NEWLINE> <INDENT> left , right = 0 , len ( li ) <NEWLINE> while left <= right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if li [ mid ] == item : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> elif li [ mid ] < item : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid - 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> N = readInt ( ) <NEWLINE> S = readChar ( ) <NEWLINE> rgb = { <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> rgb [ S [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> c = s = 0 <NEWLINE> c = len ( rgb [ <STRING> ] ) * len ( rgb [ <STRING> ] ) * len ( rgb [ <STRING> ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ k ] != S [ j ] : <NEWLINE> <INDENT> s += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = c - s <NEWLINE> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( X ) <= K * D : <NEWLINE> <INDENT> X2 = abs ( X ) % D <NEWLINE> K2 = K - abs ( X ) // D <NEWLINE> if K2 % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( X2 + D ) , abs ( X2 - D ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - K * D ) ) <NEWLINE> <DEDENT>
def make_set ( x , disjoint ) : <NEWLINE> <INDENT> disjoint [ x ] = x <NEWLINE> <NL> <DEDENT> def find_set ( x , disjoint ) : <NEWLINE> <INDENT> if x not in disjoint . keys ( ) : <NEWLINE> <INDENT> make_set ( x , disjoint ) <NEWLINE> <DEDENT> if x != disjoint [ x ] : <NEWLINE> <INDENT> disjoint [ x ] = find_set ( disjoint [ x ] , disjoint ) <NEWLINE> <DEDENT> return disjoint [ x ] <NEWLINE> <NL> <DEDENT> def link ( x , y , disjoint ) : <NEWLINE> <INDENT> disjoint [ y ] = x <NEWLINE> <NL> <DEDENT> def unite ( x , y , disjoint ) : <NEWLINE> <INDENT> link ( find_set ( x , disjoint ) , find_set ( y , disjoint ) , disjoint ) <NEWLINE> <NL> <DEDENT> def same ( x , y , disjoint ) : <NEWLINE> <INDENT> if find_set ( x , disjoint ) == find_set ( y , disjoint ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> com_list = list ( ) <NEWLINE> x_list = list ( ) <NEWLINE> y_list = list ( ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> com_list . append ( com ) <NEWLINE> x_list . append ( x ) <NEWLINE> y_list . append ( y ) <NEWLINE> <NL> <DEDENT> disjoint = dict ( ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> com = com_list [ i ] <NEWLINE> x = x_list [ i ] <NEWLINE> y = y_list [ i ] <NEWLINE> <NL> if com == 0 : <NEWLINE> <INDENT> unite ( x , y , disjoint ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( same ( x , y , disjoint ) ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> dp = [ 0 ] * N <NEWLINE> if N < 4 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> D = [ 0 ] * N <NEWLINE> D [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> D [ i ] = D [ i - 1 ] * 10 % 2019 <NEWLINE> <DEDENT> t = collections . defaultdict ( int ) <NEWLINE> tmp = 0 <NEWLINE> <NL> t [ 0 ] += 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp += S [ N - 1 - i ] * D [ i ] <NEWLINE> tmp %= 2019 <NEWLINE> t [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> for x in t : <NEWLINE> <INDENT> ans += t [ x ] * ( t [ x ] - 1 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> start = 1000 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if price [ i ] < price [ i + 1 ] : <NEWLINE> <INDENT> times = start // price [ i ] <NEWLINE> start += times * ( price [ i + 1 ] - price [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ( 1000 , start ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S_list = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> S_set = set ( S_list ) <NEWLINE> print ( len ( S_set ) ) <NEWLINE>
<COMMENT> <NL> <NL> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def get_objective_function ( output ) : <NEWLINE> <INDENT> objective_function = 0 <NEWLINE> last = [ [ - 1 for i in range ( 26 ) ] for d in range ( D ) ] <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <INDENT> objective_function += s [ d ] [ output [ d ] ] <NEWLINE> <NL> last [ d ] [ output [ d ] ] = d <NEWLINE> if d < D - 1 : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> last [ d + 1 ] [ i ] = max ( last [ d ] [ i ] , last [ d + 1 ] [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> objective_function -= c [ i ] * ( d - last [ d ] [ i ] ) <NEWLINE> <DEDENT> print ( objective_function ) <NEWLINE> <NL> <DEDENT> point = max ( 10 ** 6 + objective_function , 0 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> output = [ ] <NEWLINE> for _ in range ( D ) : <NEWLINE> <INDENT> output . append ( int ( input ( ) ) - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> get_objective_function ( output ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from functools import reduce <NEWLINE> import collections <NEWLINE> <NL> S = list ( map ( int , input ( ) . rstrip ( ) ) ) <NEWLINE> N = len ( S ) <NEWLINE> mod_list = [ 0 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> new1 = pow ( 10 , i - 1 , 2019 ) <NEWLINE> new = ( new1 * S [ - i ] + mod_list [ - 1 ] ) % 2019 <NEWLINE> <COMMENT> <NL> mod_list . append ( new ) <NEWLINE> <NL> <DEDENT> count = collections . Counter ( mod_list ) <NEWLINE> ans = 0 <NEWLINE> for j in range ( 2019 ) : <NEWLINE> <INDENT> n = count [ j ] <NEWLINE> ans += n * ( n - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
class BisectSearch : <NEWLINE> <INDENT> def __init__ ( self , f , l = 0 , r = 10 ** 9 ) : <NEWLINE> <INDENT> self . f = f <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> <DEDENT> def __call__ ( self , dist ) : <NEWLINE> <INDENT> f = self . f <NEWLINE> l = self . l <NEWLINE> r = self . r <NEWLINE> if dist <= f ( l ) : <NEWLINE> <INDENT> return l <NEWLINE> <DEDENT> if f ( r ) <= dist : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> while r - l > 1 : <NEWLINE> <INDENT> n = ( r + l ) // 2 <NEWLINE> if f ( n ) <= dist : <NEWLINE> <INDENT> l = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = n <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) * n // 2 <NEWLINE> <DEDENT> m = BisectSearch ( f , l = 1 , r = 10 ** 7 ) ( n ) <NEWLINE> m += f ( m ) != n <NEWLINE> A = set ( range ( 1 , m + 1 ) ) <NEWLINE> A . discard ( f ( m ) - n ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> diff_dist = B - A <NEWLINE> diff_v = V - W <NEWLINE> flag = False <NEWLINE> if diff_v == 0 : <NEWLINE> <INDENT> if diff_dist == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> elif diff_dist == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if diff_v > 0 : <NEWLINE> <INDENT> t = abs ( diff_dist ) / diff_v <NEWLINE> if t <= T : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> n = int ( stdin . readline ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 or x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> x //= 10 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> x //= 10 <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> XY = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif x == 0 and y > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if x > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif x == 0 and y < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif x == 0 and y > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif x == 0 and y < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if y > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif y == 0 and x > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if y < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif y == 0 and x > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if y > 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif y == 0 and x < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp = [ 0 , 0 ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> if y < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <DEDENT> elif y == 0 and x < 0 : <NEWLINE> <INDENT> tmp [ 0 ] += x <NEWLINE> tmp [ 1 ] += y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 ) ) <NEWLINE> <NL> for i , ( x , y ) in enumerate ( XY ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> katamuki = 0 <NEWLINE> katamuki2 = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> katamuki = y / x <NEWLINE> if y == 0 : <NEWLINE> <INDENT> katamuki2 = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> katamuki2 = - ( x / y ) <NEWLINE> <DEDENT> <DEDENT> plus = [ 0 , 0 ] <NEWLINE> minus = [ 0 , 0 ] <NEWLINE> plus2 = [ 0 , 0 ] <NEWLINE> minus2 = [ 0 , 0 ] <NEWLINE> for j , ( xx , yy ) in enumerate ( XY ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if yy > katamuki * xx : <NEWLINE> <INDENT> plus [ 0 ] += xx <NEWLINE> plus [ 1 ] += yy <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus [ 0 ] += xx <NEWLINE> minus [ 1 ] += yy <NEWLINE> <NL> <DEDENT> if katamuki2 == float ( <STRING> ) : <NEWLINE> <INDENT> if xx > 0 : <NEWLINE> <INDENT> plus2 [ 0 ] += xx <NEWLINE> plus2 [ 1 ] += yy <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus2 [ 0 ] += xx <NEWLINE> minus2 [ 1 ] += yy <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if yy > katamuki2 * xx : <NEWLINE> <INDENT> plus2 [ 0 ] += xx <NEWLINE> plus2 [ 1 ] += yy <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus2 [ 0 ] += xx <NEWLINE> minus2 [ 1 ] += yy <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , math . sqrt ( plus [ 0 ] ** 2 + plus [ 1 ] ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( minus [ 0 ] ** 2 + minus [ 1 ] ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( plus2 [ 0 ] ** 2 + plus2 [ 1 ] ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( minus2 [ 0 ] ** 2 + minus2 [ 1 ] ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( ( plus [ 0 ] + x ) ** 2 + ( plus [ 1 ] + y ) ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( ( minus [ 0 ] + x ) ** 2 + ( minus [ 1 ] + y ) ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( ( plus2 [ 0 ] + x ) ** 2 + ( plus2 [ 1 ] + y ) ** 2 ) ) <NEWLINE> ans = max ( ans , math . sqrt ( ( minus2 [ 0 ] + x ) ** 2 + ( minus2 [ 1 ] + y ) ** 2 ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> X , A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( 10 if A <= X else 0 ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 20 <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> ab = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> def dfs ( a0 ) : <NEWLINE> <INDENT> seen = [ 0 ] * len ( G ) <NEWLINE> todo = [ ~ a0 , a0 ] <NEWLINE> while todo : <NEWLINE> <INDENT> a = todo . pop ( ) <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> seen [ a ] = 1 <NEWLINE> idx = bisect_left ( lis , A [ a ] ) <NEWLINE> his [ a ] = ( idx , lis [ idx ] ) <NEWLINE> lis [ idx ] = A [ a ] <NEWLINE> dp [ a ] = bisect_left ( lis , INF ) <NEWLINE> for b in G [ a ] : <NEWLINE> <INDENT> if seen [ b ] : continue <NEWLINE> todo . append ( ~ b ) <NEWLINE> todo . append ( b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx , val = his [ ~ a ] <NEWLINE> lis [ idx ] = val <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> lis = [ INF ] * N <NEWLINE> dp = [ 0 ] * N <NEWLINE> his = { } <NEWLINE> dfs ( 0 ) <NEWLINE> print ( * dp , sep = <STRING> ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> START = 1 <NEWLINE> <COMMENT> <NL> town_with_i = { START : 0 } <NEWLINE> <COMMENT> <NL> current = START <NEWLINE> <COMMENT> <NL> known_towns = set ( [ START ] ) <NEWLINE> i = 0 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> <COMMENT> <NL> current = a_list [ current - 1 ] <NEWLINE> <NL> <COMMENT> <NL> if current in known_towns : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> town_with_i [ current ] = i <NEWLINE> known_towns . add ( current ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> first_step = town_with_i [ current ] <NEWLINE> <COMMENT> <NL> r = i - town_with_i [ current ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> loop_num = ( k - first_step ) % r if r > 0 else ( k - first_step ) <NEWLINE> <NL> for i in range ( loop_num ) : <NEWLINE> <INDENT> current = a_list [ current - 1 ] <NEWLINE> <NL> <DEDENT> print ( current ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> <COMMENT> <NL> sum += int ( ( 1 + k ) * k / 2 ) <NEWLINE> <NL> <COMMENT> <NL> if k >= 2 : <NEWLINE> <INDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( i , j ) * 6 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if k >= 3 : <NEWLINE> <INDENT> for i in range ( 1 , k - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k ) : <NEWLINE> <INDENT> for l in range ( j + 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , l ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , m , q_ = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> pq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q_ ) ] <NEWLINE> from collections import defaultdict <NEWLINE> dmap = defaultdict ( int ) <NEWLINE> smap = defaultdict ( int ) <NEWLINE> ssmap = defaultdict ( int ) <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> if ( l , r ) in dmap : <NEWLINE> <INDENT> dmap [ ( l , r ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dmap [ ( l , r ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> if ( i , j ) in dmap : <NEWLINE> <INDENT> tmp += dmap [ ( i , j ) ] <NEWLINE> <DEDENT> smap [ ( i , j ) ] = tmp <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> tmp += smap [ ( j , i ) ] <NEWLINE> ssmap [ ( j , i ) ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for p , q in pq : <NEWLINE> <INDENT> ans = ssmap [ ( q , q ) ] - ssmap [ ( p - 1 , q ) ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> v = { <STRING> : - 1 , <STRING> : 0 , <STRING> : 1 } <NEWLINE> h = 0 <COMMENT> <NEWLINE> H = [ h ] <NEWLINE> for s in S : <NEWLINE> <INDENT> h += v [ s ] <NEWLINE> H . append ( h ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> R = [ 0 ] * len ( H ) <NEWLINE> R [ - 1 ] = - float ( <STRING> ) <NEWLINE> for i in range ( len ( R ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> R [ i ] = max ( R [ i + 1 ] , H [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> while i < len ( S ) and S [ i ] != <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> while i < len ( S ) and ( H [ i ] > R [ i ] or S [ i ] == <STRING> ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> if i >= len ( S ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> h = H [ i ] <COMMENT> <NEWLINE> a = 0 <COMMENT> <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> a += ( h - H [ i ] ) + ( H [ i ] - H [ i + 1 ] ) / 2 <NEWLINE> i += 1 <NEWLINE> if H [ i ] == h : break <NEWLINE> <DEDENT> A . append ( int ( a ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE> print ( <STRING> . join ( map ( str , [ len ( A ) ] + A ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if N % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> low = D [ 0 : N // 2 ] <NEWLINE> high = D [ N // 2 : : ] <NEWLINE> <NL> flg = all ( low [ - 1 ] + 1 > x for x in low ) <NEWLINE> flg |= all ( high [ 0 ] - 1 >= x for x in high ) <NEWLINE> <NL> if flg == True : <NEWLINE> <INDENT> print ( high [ 0 ] - low [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> b = 10 ** 18 <NEWLINE> tm = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tm . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> c = [ 0 for i in range ( m ) ] <NEWLINE> sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> sum += tm [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> c [ k ] += tm [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( c ) >= x : <NEWLINE> <INDENT> b = min ( b , sum ) <NEWLINE> <DEDENT> <DEDENT> if b == 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> total = sum ( [ v * ( v - 1 ) // 2 for v in c . values ( ) ] ) <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( total - ( c [ i ] - 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { i : 0 for i in range ( 1 , n + 1 ) } <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> k = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if k <= n : <NEWLINE> <INDENT> if x == y == z : dic [ k ] += 1 <NEWLINE> elif x == y or y == z : dic [ k ] += 3 <NEWLINE> else : dic [ k ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for l in range ( n ) : <NEWLINE> <INDENT> print ( dic [ l + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 10 ** 9 + 7 <NEWLINE> sumA = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sumA -= A [ i ] <NEWLINE> ans += A [ i ] * sumA <NEWLINE> ans %= a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = int ( 0.5 * K * ( K + 1 ) ) <NEWLINE> <NL> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += 6 * math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += 6 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> num = min ( B - 1 , N ) <NEWLINE> <NL> print ( ( A * num // B ) - A * ( num // B ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def dfs ( x ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> if int ( x ) > N : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if all ( x . count ( i ) > 0 for i in <STRING> ) : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> for i in <STRING> : <NEWLINE> <INDENT> ret += dfs ( x + i ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> print ( dfs ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def is_prime ( q ) : <NEWLINE> <INDENT> q = abs ( q ) <NEWLINE> if q == 2 : return True <NEWLINE> if q < 2 or q & 1 == 0 : return False <NEWLINE> return pow ( 2 , q - 1 , q ) == 1 <NEWLINE> <NL> <DEDENT> k = make_divisors ( n ) <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( k ) ) : <NEWLINE> <INDENT> if i == 0 : pass <NEWLINE> else : <NEWLINE> <INDENT> l1 = factorization ( k [ i ] ) <NEWLINE> seigo = is_prime ( l1 [ 0 ] [ 0 ] ) <NEWLINE> if len ( l1 ) == 1 and seigo == True and n % k [ i ] == 0 : <NEWLINE> <INDENT> n //= k [ i ] <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> MAX_N = N + 10 <NEWLINE> <NL> <COMMENT> <NL> def modPow ( a , n , p ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> return a % p <NEWLINE> <NL> <DEDENT> elif n % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> return a * modPow ( a , n - 1 , p ) % p <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> t = modPow ( a , n // 2 , p ) <NEWLINE> return t * t % p <NEWLINE> <NL> <DEDENT> <DEDENT> fac = [ None for i in range ( MAX_N ) ] <NEWLINE> finv = [ None for i in range ( MAX_N ) ] <NEWLINE> inv = [ None for i in range ( MAX_N ) ] <NEWLINE> <NL> def COMinit ( num ) : <NEWLINE> <INDENT> global fac <NEWLINE> global finv <NEWLINE> global inv <NEWLINE> fac [ 0 ] = 1 <NEWLINE> fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = 1 <NEWLINE> finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , num ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - inv [ MOD % i ] * ( MOD // i ) % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> def COM ( n , k ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return int ( fac [ n ] * ( finv [ k ] * finv [ n - k ] % MOD ) % MOD ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> COMinit ( MAX_N ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> v = COM ( N - 1 , N - 1 - K + i ) % MOD <NEWLINE> v *= M <NEWLINE> v = v % MOD <NEWLINE> v *= modPow ( M - 1 , N - 1 - K + i , MOD ) <NEWLINE> v = v % MOD <NEWLINE> ans += v <NEWLINE> ans = ans % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> from itertools import chain <NEWLINE> from operator import mul <NEWLINE> <NL> exp10 = [ 10 ** a for a in range ( 8 , - 1 , - 1 ) ] <NEWLINE> movables = [ { 1 , 3 } , { 0 , 2 , 4 } , { 1 , 5 } , { 0 , 4 , 6 } , { 1 , 3 , 5 , 7 } , { 2 , 4 , 8 } , { 3 , 7 } , { 4 , 6 , 8 } , { 5 , 7 } ] <NEWLINE> <NL> destination = 123456780 <NEWLINE> <NL> <NL> def swap ( board , move_from , move_to ) : <NEWLINE> <INDENT> return board + ( exp10 [ move_to ] - exp10 [ move_from ] ) * ( board // exp10 [ move_from ] % 10 ) <NEWLINE> <NL> <NL> <DEDENT> board0 = sum ( map ( mul , exp10 , chain . from_iterable ( map ( int , input ( ) . split ( ) ) for _ in range ( 3 ) ) ) ) <NEWLINE> p0 = ( <STRING> + str ( board0 ) ) [ - 9 : ] . index ( <STRING> ) <NEWLINE> <NL> appeared = ( { board0 : 0 } , { destination : 0 } ) <NEWLINE> queue = [ ] <NEWLINE> queue . extend ( ( 0 , 0 , move_from , p0 , board0 ) for move_from in movables [ p0 ] ) <NEWLINE> queue . extend ( ( 0 , 1 , move_from , 8 , destination ) for move_from in movables [ 8 ] ) <NEWLINE> heapq . heapify ( queue ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> total_cost , direction , move_from , move_to , board = heapq . heappop ( queue ) <NEWLINE> if board in appeared [ not direction ] : <NEWLINE> <INDENT> print ( total_cost + appeared [ not direction ] [ board ] ) <NEWLINE> break <NEWLINE> <DEDENT> new_board = swap ( board , move_from , move_to ) <NEWLINE> if new_board in appeared [ direction ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> appeared [ direction ] [ new_board ] = total_cost + 1 <NEWLINE> for move_from2 in movables [ move_from ] : <NEWLINE> <INDENT> if move_from2 != move_to : <NEWLINE> <INDENT> heapq . heappush ( queue , ( total_cost + 1 , direction , move_from2 , move_from , new_board ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import itertools <NEWLINE> import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_acc = [ 0 ] + list ( itertools . accumulate ( a ) ) <NEWLINE> b_acc = [ 0 ] + list ( itertools . accumulate ( b ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if k - a_acc [ i ] >= 0 : <NEWLINE> <INDENT> ans = max ( ans , i + bisect . bisect ( b_acc , k - a_acc [ i ] ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> <COMMENT> <NL> line = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( line [ 0 ] ) <NEWLINE> B = int ( line [ 1 ] ) <NEWLINE> H = int ( line [ 2 ] ) <NEWLINE> M = int ( line [ 3 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> ang_a = H * 5 + M / 12 <NEWLINE> <COMMENT> <NL> ang_b = M <NEWLINE> <NL> if ang_a == ang_b : <NEWLINE> <INDENT> ans = A - B <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> diff = abs ( ang_a - ang_b ) <NEWLINE> theta = ( diff / 60 ) * 360 <NEWLINE> ans_pow = A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( theta ) ) <NEWLINE> ans = ans_pow ** 0.5 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = 0 <NEWLINE> for a in range ( 100000000000000 ) : <NEWLINE> <INDENT> if N > K : <NEWLINE> <INDENT> kot = N % K <NEWLINE> if abs ( K - kot ) > kot : <NEWLINE> <INDENT> print ( kot ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( K - kot ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if N % K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> if N < K : <NEWLINE> <INDENT> if abs ( N - K ) < N : <NEWLINE> <INDENT> print ( abs ( N - K ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> tugi = abs ( N - K ) <NEWLINE> N = tugi <NEWLINE> A = tugi <NEWLINE> tugi = abs ( N - K ) <NEWLINE> B = tugi <NEWLINE> N = tugi <NEWLINE> tugi = abs ( N - K ) <NEWLINE> if A == tugi : <NEWLINE> <INDENT> if B < A : <NEWLINE> <INDENT> print ( B ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> if ( A [ K - 1 + i ] / A [ i - 1 ] ) > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def doubling_numpy ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = K . bit_length ( ) <NEWLINE> U = N + 1 <NEWLINE> dbl = np . zeros ( ( D , U ) , dtype = np . int64 ) <NEWLINE> dbl [ 0 , 1 : ] = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> for d in range ( D - 1 ) : <NEWLINE> <INDENT> dbl [ d + 1 ] = dbl [ d , dbl [ d ] ] <NEWLINE> <NL> <DEDENT> v = 1 <NEWLINE> for i in reversed ( range ( D ) ) : <NEWLINE> <INDENT> if K & ( 1 << i ) : <NEWLINE> <INDENT> v = dbl [ i , v ] <NEWLINE> <DEDENT> <DEDENT> print ( v ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> doubling_numpy ( ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> step = - ( - abs ( X ) // D ) <NEWLINE> if ( abs ( X ) - step * D ) > ( abs ( X ) - ( step - 1 ) * D ) : <NEWLINE> <INDENT> step = step - 1 <NEWLINE> <DEDENT> if step >= K : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - K * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - step ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - step * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - abs ( abs ( X ) - step * D ) ) <NEWLINE> <DEDENT> <DEDENT>
n , x , mod = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ 0 , x ] <NEWLINE> num_set = set ( [ x ] ) <NEWLINE> num_lst = [ 0 , x ] <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( mod - 1 ) : <NEWLINE> <INDENT> x = ( x * x ) % mod <NEWLINE> s = x + lst [ - 1 ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> lst . append ( s ) <NEWLINE> break <NEWLINE> <DEDENT> if x in num_set : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> lst . append ( s ) <NEWLINE> num_set . add ( x ) <NEWLINE> num_lst . append ( x ) <NEWLINE> if i + 2 == n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for i , ele in enumerate ( num_lst ) : <NEWLINE> <INDENT> if x == ele : <NEWLINE> <INDENT> loop_s = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l = len ( lst ) <NEWLINE> if lst [ l - 1 ] == lst [ l - 2 ] : <NEWLINE> <INDENT> print ( lst [ l - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not flag : <NEWLINE> <INDENT> print ( lst [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = len ( lst ) - loop_s <NEWLINE> n -= loop_s - 1 <NEWLINE> c = n // loop <NEWLINE> r = n % loop <NEWLINE> ans = lst [ l - 1 ] + ( c - 1 ) * ( lst [ l - 1 ] - lst [ loop_s - 1 ] ) + lst [ loop_s + r - 1 ] - lst [ loop_s - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
from math import factorial <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if abs ( N - M ) > 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N == M : <NEWLINE> <INDENT> a = N <NEWLINE> b = M <NEWLINE> ans = factorial ( a ) * factorial ( b ) * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = max ( N , M ) <NEWLINE> b = min ( N , M ) <NEWLINE> ans = factorial ( a ) * factorial ( b ) <NEWLINE> <DEDENT> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> result = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> S = sum ( As ) <NEWLINE> <NL> for i in range ( len ( As ) - 1 ) : <NEWLINE> <INDENT> S -= As [ i ] <NEWLINE> tmp = As [ i ] * S <NEWLINE> result += tmp <NEWLINE> result %= MOD <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> kouho = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> kouho . remove ( i ) <NEWLINE> <DEDENT> if kouho == [ ] : <NEWLINE> <INDENT> kouho . append ( s . pop ( - 1 ) ) <NEWLINE> for i in range ( 25 ) : <NEWLINE> <INDENT> dum = s . pop ( - 1 ) <NEWLINE> for j in range ( len ( kouho ) ) : <NEWLINE> <INDENT> if dum < kouho [ j ] : <NEWLINE> <INDENT> s . append ( kouho [ j ] ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> kouho . append ( dum ) <NEWLINE> kouho . sort ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( kouho [ 0 ] ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for a in range ( 0 , 10 ** 3 ) : <NEWLINE> <INDENT> for b in range ( 0 , 10 ** 3 ) : <NEWLINE> <INDENT> if X == a ** 5 - b ** 5 : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif X == a ** 5 + b ** 5 : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif X == - a ** 5 - ( 10 ** 4 - b ) ** 5 : <NEWLINE> <INDENT> print ( - a , 10 ** 4 - b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> def _p ( * _a ) : <NEWLINE> <INDENT> _s = <STRING> . join ( map ( str , _a ) ) <NEWLINE> <COMMENT> <NL> sys . stderr . write ( _s + <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> import math <NEWLINE> <NL> def factorize ( n ) : <NEWLINE> <INDENT> ret , a = [ ] , n <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if a % i > 0 : continue <NEWLINE> c = 0 <NEWLINE> while a % i == 0 : <NEWLINE> <INDENT> a //= i <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret . append ( ( i , c ) ) <NEWLINE> <DEDENT> <DEDENT> if a != 1 : ret . append ( ( a , 1 ) ) <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> N = factorize ( n ) <NEWLINE> <NL> ans = 0 <NEWLINE> for p , i in N : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> a = pow ( p , j + 1 ) <NEWLINE> if n % a == 0 : <NEWLINE> <INDENT> n /= a <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in a ] <NEWLINE> ans = 1 <NEWLINE> <NL> <NL> if 0 in a : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> elif len ( a ) % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , int ( len ( a ) / 2 ) + 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ans > 10 ** 18 or ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == int ( len ( a ) / 2 ) + 1 : <NEWLINE> <INDENT> ans = ans * a [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * a [ i - 1 ] * a [ - 1 * i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , int ( len ( a ) / 2 ) ) : <NEWLINE> <INDENT> if ans > 10 ** 18 or ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = ans * a [ i ] * a [ - 1 - i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l = [ [ ] for i in range ( n ) ] <COMMENT> <NEWLINE> m = [ [ ] for i in range ( n - k + 1 ) ] <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = ( 1 + p [ i ] ) / 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> m [ 0 ] = sum ( l [ 0 : k ] ) <NEWLINE> ans = m [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> m [ i ] = m [ i - 1 ] - l [ i - 1 ] + l [ i + k - 1 ] <NEWLINE> if m [ i ] > ans : <NEWLINE> <INDENT> ans = m [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> HL , ML , h , m = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> HW = float ( ( 60 * h + m ) / 2 ) <NEWLINE> MW = float ( 6 * m ) <NEWLINE> <NL> if HW > MW : <NEWLINE> <INDENT> if HW - MW > 180 : <NEWLINE> <INDENT> w = 360 - ( HW - MW ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = HW - MW <NEWLINE> <DEDENT> print ( math . sqrt ( HL * HL + ML * ML - 2 * HL * ML * math . cos ( math . radians ( w ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if HW - MW > 180 : <NEWLINE> <INDENT> w = 360 - ( HW - MW ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = HW - MW <NEWLINE> <DEDENT> print ( math . sqrt ( HL * HL + ML * ML - 2 * HL * ML * math . cos ( math . radians ( - w ) ) ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( a + 1 ) : <NEWLINE> <INDENT> if 0 <= ( b - i - j ) <= a : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> t = [ int ( val ) for val in raw_input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> s = [ int ( val ) for val in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for si in s : <NEWLINE> <INDENT> for ti in t : <NEWLINE> <INDENT> if si == ti : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ 0 ] <NEWLINE> visited_set = set ( ) <NEWLINE> now = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> if now in visited_set : <NEWLINE> <INDENT> start = visited . index ( now ) <NEWLINE> shuki = k + 1 - start <NEWLINE> print ( visited [ start : ] [ ( K - start ) % shuki ] + 1 ) <NEWLINE> return <NEWLINE> <DEDENT> visited . append ( now ) <NEWLINE> visited_set . add ( now ) <NEWLINE> <DEDENT> print ( visited [ - 1 ] + 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> l = [ 0 ] * 2019 <NEWLINE> temp = 0 <NEWLINE> e = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> temp += int ( S [ i ] ) * e <NEWLINE> temp %= 2019 <NEWLINE> l [ temp ] += 1 <NEWLINE> e *= 10 <NEWLINE> e %= 2019 <NEWLINE> <NL> <DEDENT> ans = l [ 0 ] <NEWLINE> <NL> for i in range ( 0 , 2019 ) : <NEWLINE> <INDENT> ans += l [ i ] * ( l [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , q = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> stacks = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> op = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if op [ 0 ] == 0 : <NEWLINE> <INDENT> stacks [ op [ 1 ] ] . append ( op [ 2 ] ) <NEWLINE> <DEDENT> elif op [ 0 ] == 1 : <NEWLINE> <INDENT> if len ( stacks [ op [ 1 ] ] ) != 0 : <NEWLINE> <INDENT> print ( stacks [ op [ 1 ] ] [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif op [ 0 ] == 2 : <NEWLINE> <INDENT> if len ( stacks [ op [ 1 ] ] ) != 0 : <NEWLINE> <INDENT> stacks [ op [ 1 ] ] . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> org = <STRING> <NEWLINE> dist = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c1 , c2 = input ( ) . split ( ) <NEWLINE> org += c1 <NEWLINE> dist += c2 <NEWLINE> <DEDENT> m = int ( input ( ) ) <NEWLINE> oSt = <STRING> <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> oSt += input ( ) [ 0 ] <NEWLINE> <DEDENT> print ( oSt . translate ( str . maketrans ( org , dist ) ) ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> def get_modulos ( ) : <NEWLINE> <INDENT> modulos = [ ] <NEWLINE> for i in range ( 224 ) : <NEWLINE> <INDENT> modulos . append ( 10 ** i % 2019 ) <NEWLINE> <DEDENT> return modulos <NEWLINE> <NL> <DEDENT> def count_substring ( s ) : <NEWLINE> <INDENT> found_remainder = defaultdict ( int ) <NEWLINE> current_mod = 0 <NEWLINE> found_remainder [ 0 ] = 1 <NEWLINE> <NL> output = 0 <NEWLINE> <NL> modulos = get_modulos ( ) <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> digit = s [ i ] <NEWLINE> current_mod = ( int ( digit ) * modulos [ ( len ( s ) - 1 - i ) % 224 ] % 2019 + current_mod ) % 2019 <NEWLINE> <COMMENT> <NL> output += found_remainder [ current_mod ] <NEWLINE> found_remainder [ current_mod ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> return output <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> print ( count_substring ( s ) ) <NEWLINE>
from math import gcd <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> L = N // gcd ( N , M ) * M <NEWLINE> <NL> ds = L // N <NEWLINE> dt = L // M <NEWLINE> S = S [ 0 : : dt ] <NEWLINE> T = T [ 0 : : ds ] <NEWLINE> <NL> if S == T : <NEWLINE> <INDENT> print ( L ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = n // i <NEWLINE> ans += ( i + a * i ) * a <NEWLINE> <DEDENT> print ( ans // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <NEWLINE> dic [ ( 0 , 0 ) ] = dic [ ( 0 , 1 ) ] = 0 <NEWLINE> import math <NEWLINE> mod = 1000000007 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A < 0 : <NEWLINE> <INDENT> A , B = - A , - B <NEWLINE> <DEDENT> if A == 0 : <NEWLINE> <INDENT> if B == 0 : <NEWLINE> <INDENT> dic [ ( 0 , 0 ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ ( 0 , 1 ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> dic [ ( 1 , 0 ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = math . gcd ( A , B ) <NEWLINE> A , B = A // gcd , B // gcd <NEWLINE> dic [ ( A , B ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> N -= dic [ ( 0 , 0 ) ] <NEWLINE> for k , v in dic . items ( ) : <NEWLINE> <INDENT> if k == ( 0 , 0 ) or k == ( 0 , 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if k == ( 1 , 0 ) : <NEWLINE> <INDENT> v_dash = dic [ ( 0 , 1 ) ] <NEWLINE> ans *= ( ( pow ( 2 , v , mod ) - 1 ) + ( pow ( 2 , v_dash , mod ) - 1 ) + 1 ) <NEWLINE> ans %= mod <NEWLINE> N -= v + v_dash <NEWLINE> continue <NEWLINE> <DEDENT> a , b = k <NEWLINE> if not ( b , - a ) in dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v_dash = dic [ ( b , - a ) ] <NEWLINE> ans *= ( ( pow ( 2 , v , mod ) - 1 ) + ( pow ( 2 , v_dash , mod ) - 1 ) + 1 ) <NEWLINE> ans %= mod <NEWLINE> N -= v + v_dash <NEWLINE> <DEDENT> ans *= pow ( 2 , N , mod ) <NEWLINE> ans += dic [ ( 0 , 0 ) ] - 1 <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( reverse = True ) <NEWLINE> h = h [ k : ] <NEWLINE> print ( sum ( h ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> AS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 1 <NEWLINE> j = 0 <NEWLINE> <NL> if 0 in AS : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> j = 1 <NEWLINE> <NL> <NL> <DEDENT> if j == 0 : <NEWLINE> <INDENT> for i in AS : <NEWLINE> <INDENT> m = m * i <NEWLINE> if m > 10 ** 18 and j == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> j = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if j == 0 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT>
import statistics as st <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> NGs = 0 <NEWLINE> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> b = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for d in range ( ( n - i - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if i in r and j in g and k in b : <NEWLINE> <INDENT> NGs += 1 <NEWLINE> <DEDENT> elif i in r and j in b and k in g : <NEWLINE> <INDENT> NGs += 1 <NEWLINE> <DEDENT> elif i in g and j in r and k in b : <NEWLINE> <INDENT> NGs += 1 <NEWLINE> <DEDENT> elif i in g and j in b and k in r : <NEWLINE> <INDENT> NGs += 1 <NEWLINE> <DEDENT> elif i in b and j in r and k in g : <NEWLINE> <INDENT> NGs += 1 <NEWLINE> <DEDENT> elif i in b and j in g and k in r : <NEWLINE> <INDENT> NGs += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( r ) * len ( g ) * len ( b ) - NGs ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> C = min ( [ N , B - 1 ] ) <NEWLINE> ans = int ( A * C / B ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * pi * r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> total = 1 ; <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 not in a : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> total *= i <NEWLINE> if total > int ( 1e18 ) : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <DEDENT> else : print ( 0 ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = input ( ) <NEWLINE> N = int ( n ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> q = input ( ) <NEWLINE> Q = int ( q ) <NEWLINE> B , C = [ ] , [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = input ( ) . split ( ) <NEWLINE> B . append ( int ( b ) ) <NEWLINE> C . append ( int ( c ) ) <NEWLINE> <NL> <NL> <DEDENT> my_dict = Counter ( A ) <NEWLINE> <NL> def cals_sum ( my_dict ) : <NEWLINE> <INDENT> values = [ my_dict [ key ] * key for key in my_dict . keys ( ) if my_dict [ key ] != 0 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> return sum ( values ) <NEWLINE> <NL> <DEDENT> my_sum = cals_sum ( my_dict ) <NEWLINE> <NL> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> b = B [ i ] <NEWLINE> c = C [ i ] <NEWLINE> tmpb = my_dict [ b ] <NEWLINE> my_dict [ b ] = 0 <NEWLINE> tmpc = my_dict [ c ] <NEWLINE> my_dict [ c ] = tmpb + tmpc <NEWLINE> <NL> my_sum += ( ( tmpb ) * c - tmpb * b ) <NEWLINE> <NL> print ( my_sum ) <NEWLINE> <NL> <NL> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> t_lst = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> t_lst . sort ( ) <NEWLINE> answer = t_lst [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> t = t_lst [ i ] <NEWLINE> answer = lcm ( answer , t ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> self . left , self . right = None , None <NEWLINE> <NL> <DEDENT> def insert ( self , data ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if data < self . data : <NEWLINE> <INDENT> if not self . left : <NEWLINE> <INDENT> self . left = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . left . insert ( data ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not self . right : <NEWLINE> <INDENT> self . right = Node ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . right . insert ( data ) <NEWLINE> <NL> <DEDENT> <DEDENT> return self . data <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pre_order ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> pre_order ( node . left ) <NEWLINE> pre_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def in_order ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> in_order ( node . left ) <NEWLINE> print ( <STRING> , node . data , end = <STRING> ) <NEWLINE> in_order ( node . right ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def action ( command , content ) : <NEWLINE> <INDENT> if command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root . insert ( int ( content ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> in_order ( tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> pre_order ( tree_root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> command_list = list ( map ( lambda x : x . split ( ) , _input [ 1 : ] ) ) <NEWLINE> <COMMENT> <NL> <NL> flag , tree_root = False , None <NEWLINE> for each in command_list : <NEWLINE> <INDENT> command , content = each [ 0 ] , each [ - 1 ] <NEWLINE> if ( not flag ) and command . startswith ( <STRING> ) : <NEWLINE> <INDENT> tree_root = Node ( data = int ( content ) ) <NEWLINE> flag = True <NEWLINE> continue <NEWLINE> <DEDENT> action ( command , content ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> from math import sqrt <NEWLINE> <NL> <NL> def is_prime ( q , primes ) : <NEWLINE> <INDENT> if len ( primes ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> maxq = int ( sqrt ( q ) ) <NEWLINE> for prime in primes : <NEWLINE> <INDENT> if prime > maxq : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if q % prime == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def get_primes ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return [ 2 ] <NEWLINE> <NL> <DEDENT> max = int ( sqrt ( n ) ) <NEWLINE> primes = [ 2 ] <NEWLINE> for q in range ( 3 , max + 1 ) : <NEWLINE> <INDENT> if is_prime ( q , primes ) : <NEWLINE> <INDENT> primes . append ( q ) <NEWLINE> <NL> <DEDENT> <DEDENT> return primes <NEWLINE> <NL> <DEDENT> def breakdown_to_primes_as_dic ( n , primes ) : <NEWLINE> <INDENT> prime_dic = { } <NEWLINE> for prime in primes : <NEWLINE> <INDENT> if n % prime != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prime_dic [ prime ] = 0 <NEWLINE> while n % prime == 0 : <NEWLINE> <INDENT> prime_dic [ prime ] += 1 <NEWLINE> n = n // prime <NEWLINE> <DEDENT> <DEDENT> if n >= 2 : <NEWLINE> <INDENT> prime_dic [ n ] = 1 <NEWLINE> <DEDENT> return prime_dic <NEWLINE> <NL> <DEDENT> def get_int_sums ( n ) : <NEWLINE> <INDENT> int_sums = [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> int_sums . append ( int_sums [ i - 1 ] + i ) <NEWLINE> <DEDENT> int_sums . pop ( 0 ) <NEWLINE> return int_sums <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for line in stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> primes = get_primes ( n ) <NEWLINE> prime_dic = breakdown_to_primes_as_dic ( n , primes ) <NEWLINE> <NL> if len ( prime_dic . keys ( ) ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> max_prime_occurance = max ( prime_dic . values ( ) ) <NEWLINE> int_sums = get_int_sums ( max_prime_occurance + 1 ) <NEWLINE> <NL> answer = 0 <NEWLINE> for prime in prime_dic . keys ( ) : <NEWLINE> <INDENT> occr = prime_dic [ prime ] <NEWLINE> for i in range ( 1 , len ( int_sums ) ) : <NEWLINE> <INDENT> if occr >= int_sums [ i - 1 ] and occr < int_sums [ i ] : <NEWLINE> <INDENT> answer += i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( ( S - h * 3600 ) / 60 ) <NEWLINE> s = int ( S - h * 3600 - m * 60 ) <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> cp_list = a_list . copy ( ) <NEWLINE> cp_list . sort ( ) <NEWLINE> second_ans = cp_list [ - 2 ] <NEWLINE> ans = cp_list [ - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a_list [ i ] == ans : <NEWLINE> <INDENT> print ( second_ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def check ( i , j , N ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( 0 > ( 2 * j - i ) or ( 2 * j - i ) >= N ) : <NEWLINE> <COMMENT> <NL> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( S [ j ] != S [ 2 * j - i ] and S [ 2 * j - i ] != S [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> n_equal = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , int ( ( N + i ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if ( S [ i ] == S [ j ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( check ( i , j , N ) == True ) : <NEWLINE> <INDENT> n_equal += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n_R = S . count ( <STRING> ) <NEWLINE> n_G = S . count ( <STRING> ) <NEWLINE> n_B = S . count ( <STRING> ) <NEWLINE> <NL> n_all = n_R * n_G * n_B <NEWLINE> <COMMENT> <NL> <NL> print ( n_all - n_equal ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> n , k = na ( ) <NEWLINE> l = [ 1 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> l [ a [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> c = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> c [ i - 1 ] += 1 <NEWLINE> <DEDENT> for k in c : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
def binarySearch ( e , n , A ) : <NEWLINE> <INDENT> if e < A [ 0 ] or e > A [ - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> l , r = 0 , n <NEWLINE> while l <= r : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if m == r or m == l : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if e == A [ m ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif e < A [ m ] : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def ALDS1_4B ( ) : <NEWLINE> <INDENT> n , S = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q , T = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( [ 1 for e in T if binarySearch ( e , n , S ) ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ALDS1_4B ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> ab = sorted ( ab , key = lambda x : x [ 0 ] ) <NEWLINE> res = ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if res + ab [ i ] [ 1 ] >= m : <NEWLINE> <INDENT> ans += ( ab [ i ] [ 0 ] ) * ( m - res ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( ab [ i ] [ 0 ] ) * ab [ i ] [ 1 ] <NEWLINE> res += ab [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> result = math . sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) <NEWLINE> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> sum1 = sum ( li ) <NEWLINE> sum2 = 0 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> for i in range ( 0 , len ( li ) - 1 ) : <NEWLINE> <INDENT> sum2 += li [ i ] <NEWLINE> res = ( res + li [ i ] * ( sum1 - sum2 ) ) % m <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> <DEDENT> import numpy as np <NEWLINE> <NL> def dfs1 ( v , G , Siz ) : <NEWLINE> <INDENT> siz = 1 <NEWLINE> for u in G [ v ] : <NEWLINE> <INDENT> G [ u ] . remove ( v ) <NEWLINE> siz += dfs1 ( u , G , Siz ) <NEWLINE> <DEDENT> Siz [ v ] = siz <NEWLINE> return siz <NEWLINE> <NL> <DEDENT> def dfs ( v , N , C , G , Cnt , Siz , Ans ) : <NEWLINE> <INDENT> color = C [ v ] <NEWLINE> cnt_old = Cnt [ color ] <NEWLINE> siz = 1 <NEWLINE> siz_up = N <NEWLINE> for u in G [ v ] : <NEWLINE> <INDENT> Cnt [ color ] = N - Siz [ u ] <COMMENT> <NEWLINE> s = dfs ( u , N , C , G , Cnt , Siz , Ans ) <NEWLINE> siz += s <NEWLINE> siz_up -= s <NEWLINE> Ans [ color ] += s * ( siz_up - cnt_old ) <NEWLINE> <DEDENT> Ans [ color ] += siz_up - cnt_old <NEWLINE> Cnt [ color ] = cnt_old + siz <NEWLINE> return siz <NEWLINE> <NL> <DEDENT> def solve ( N , C , AB ) : <NEWLINE> <INDENT> G = [ [ 0 ] * 0 for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = AB [ i ] <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <DEDENT> Cnt = np . zeros ( N , dtype = np . int64 ) <NEWLINE> Ans = np . zeros ( N , dtype = np . int64 ) <NEWLINE> Siz = np . zeros ( N , dtype = np . int64 ) <NEWLINE> dfs1 ( 0 , G , Siz ) <NEWLINE> dfs ( 0 , N , C , G , Cnt , Siz , Ans ) <NEWLINE> return Ans <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ dfs1 , <STRING> ] , <NEWLINE> [ dfs , <STRING> ] , <NEWLINE> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 505050 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = np . array ( input ( ) . split ( ) , dtype = np . int64 ) - 1 <NEWLINE> AB = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] , dtype = np . int64 ) - 1 <NEWLINE> Ans = solve ( N , C , AB ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans . tolist ( ) ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> Yoko = [ ] <NEWLINE> Tate = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> Yoko . append ( [ x - r , x + r ] ) <NEWLINE> Tate . append ( [ y - r , y + r ] ) <NEWLINE> <DEDENT> Yoko = sorted ( Yoko ) <NEWLINE> Tate = sorted ( Tate ) <NEWLINE> <NL> if Yoko [ 0 ] [ 0 ] > 0 and Tate [ 0 ] [ 0 ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> Yoko_han = [ Yoko [ 0 ] [ 0 ] , Yoko [ 0 ] [ 1 ] ] <NEWLINE> Tate_han = [ Tate [ 0 ] [ 0 ] , Tate [ 0 ] [ 1 ] ] <NEWLINE> if Yoko [ 0 ] [ 0 ] <= 0 : <NEWLINE> <INDENT> if Yoko_han [ 1 ] >= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , len ( Tate ) ) : <NEWLINE> <INDENT> if Yoko [ j ] [ 0 ] <= Yoko_han [ 1 ] and Yoko_han [ 1 ] < Yoko [ j ] [ 1 ] : <NEWLINE> <INDENT> Yoko_han [ 1 ] = Yoko [ j ] [ 1 ] <NEWLINE> if Yoko_han [ 1 ] >= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif Yoko_han [ 1 ] < Yoko [ j ] [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if Tate [ 0 ] [ 0 ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Tate_han [ 1 ] >= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , len ( Yoko ) ) : <NEWLINE> <INDENT> if Tate [ k ] [ 0 ] <= Tate_han [ 1 ] and Tate_han [ 1 ] < Tate [ k ] [ 1 ] : <NEWLINE> <INDENT> Tate_han [ 1 ] = Tate [ k ] [ 1 ] <NEWLINE> if Tate_han [ 1 ] >= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif Yoko_han [ 1 ] < Yoko [ k ] [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = gcd ( i , j ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> hoge = gcd ( x , k ) <NEWLINE> sum += hoge <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> an = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> <NL> an_total = sum ( an ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( len ( an ) - 1 ) : <NEWLINE> <INDENT> an_total -= an [ i ] <NEWLINE> answer += an [ i ] * an_total <NEWLINE> <DEDENT> print ( answer % 1000000007 ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> num = [ 0 ] * 2019 <NEWLINE> num [ 0 ] = 1 <NEWLINE> prev = 0 <NEWLINE> result = 0 <NEWLINE> _10 = 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> prev = ( prev + int ( S [ i ] ) * _10 ) % 2019 <NEWLINE> _10 *= 10 <NEWLINE> _10 %= 2019 <NEWLINE> result += num [ prev ] <NEWLINE> num [ prev ] += 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> o = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> <DEDENT> e = n - o <NEWLINE> if o != 0 : <NEWLINE> <INDENT> print ( ( 2 ** e ) * int ( 2 ** ( o - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p == 0 : <NEWLINE> <INDENT> print ( 2 ** n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
num = [ i ** 5 for i in range ( - 121 , 121 ) ] <NEWLINE> X = int ( input ( ) ) <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> a = num [ i ] <NEWLINE> for j in range ( i + 1 ) : <NEWLINE> <INDENT> if a - num [ j ] == X : <NEWLINE> <INDENT> print ( i - 121 , j - 121 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> lines = 1 <NEWLINE> inp = list ( ) <NEWLINE> <NL> for _ in range ( lines ) : <NEWLINE> <INDENT> inp . append ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> <NL> <DEDENT> s = inp [ 0 ] <NEWLINE> n = len ( s ) <NEWLINE> <NL> tmp = defaultdict ( int ) <NEWLINE> tmp [ 0 ] = 1 <NEWLINE> <NL> b = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = int ( s [ n - i ] ) <NEWLINE> b = ( ( d * a ) + b ) % 2019 <NEWLINE> tmp [ b ] += 1 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> <NL> for v in tmp . values ( ) : <NEWLINE> <INDENT> result += int ( v * ( v - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ b - 1 ] . append ( a - 1 ) <NEWLINE> A [ a - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> depth = [ - 1 ] * n <NEWLINE> visit = deque ( [ 0 ] ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if len ( visit ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = visit . popleft ( ) <NEWLINE> for i in A [ x ] : <NEWLINE> <INDENT> if depth [ i ] == - 1 : <NEWLINE> <INDENT> depth [ i ] = x + 1 <NEWLINE> visit . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> [ print ( i ) for i in depth [ 1 : ] ] <NEWLINE>
def d170 ( n , a ) : <NEWLINE> <INDENT> k = max ( a ) + 1 <NEWLINE> count = 0 <NEWLINE> dp = [ 0 for i in range ( k ) ] <NEWLINE> for x in a : <NEWLINE> <INDENT> if dp [ x ] != 0 : <NEWLINE> <INDENT> dp [ x ] = 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( x , k , x ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x in a : <NEWLINE> <INDENT> if dp [ x ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( d170 ( n , a ) ) <NEWLINE>
<COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> <NL> import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def segment_sieve ( begin , end ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> assert 1 < begin <= end <NEWLINE> sqrt_end = math . ceil ( math . sqrt ( end ) ) <NEWLINE> is_prime_small = [ True for i in range ( sqrt_end ) ] <NEWLINE> is_prime_small [ 0 ] = False <NEWLINE> is_prime_small [ 1 ] = False <NEWLINE> is_prime = [ True for i in range ( end - begin ) ] <NEWLINE> for i in range ( 2 , sqrt_end ) : <NEWLINE> <INDENT> if is_prime_small [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , sqrt_end , i ) : <NEWLINE> <INDENT> is_prime_small [ j ] = False <NEWLINE> <DEDENT> for k in range ( max ( 2 , ( begin + i - 1 ) // i ) * i , end , i ) : <NEWLINE> <INDENT> is_prime [ k - begin ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> primes = [ i for i , cond in enumerate ( is_prime , begin ) if cond ] <NEWLINE> return is_prime , primes <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ns = [ int ( n ) for n in sys . stdin . readlines ( ) ] <NEWLINE> max_n = max ( ns ) <NEWLINE> begin = 2 <NEWLINE> is_prime , _ = segment_sieve ( begin , max_n + 1 ) <NEWLINE> for n in ns : <NEWLINE> <INDENT> print ( sum ( is_prime [ : n + 1 - begin ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s1 = set ( s [ : i ] ) <NEWLINE> s2 = set ( s [ i : ] ) <NEWLINE> a . append ( len ( s1 & s2 ) ) <NEWLINE> <DEDENT> print ( max ( a ) ) <NEWLINE>
N = input ( ) <NEWLINE> if N [ - 3 : ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - int ( N [ - 3 : ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = - ( 10 ** 9 + 3 ) <COMMENT> <NEWLINE> b = 10 ** 9 + 3 <COMMENT> <NEWLINE> c = - ( 10 ** 9 + 3 ) <COMMENT> <NEWLINE> d = 10 ** 9 + 3 <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = max ( a , x + y ) <NEWLINE> b = min ( b , x + y ) <NEWLINE> c = max ( c , x - y ) <NEWLINE> d = min ( d , x - y ) <NEWLINE> <DEDENT> ans = max ( [ a - b , c - d ] ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> tot = 0 <NEWLINE> dif = { } <NEWLINE> for k , v in cnt . items ( ) : <NEWLINE> <INDENT> tot += v * ( v - 1 ) // 2 <NEWLINE> dif [ k ] = v - 1 <NEWLINE> <DEDENT> ans = [ tot - dif [ a ] for a in A ] <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = 1 <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> b = b * a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * 3.14159265359 , 2 * r * 3.14159265359 ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> s = list ( s ) <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> s . insert ( 0 , <STRING> ) <NEWLINE> <DEDENT> if len ( s ) >= 5 : <NEWLINE> <INDENT> if s [ 4 ] != <STRING> : <NEWLINE> <INDENT> s . insert ( 4 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if len ( s ) >= 7 : <NEWLINE> <INDENT> if s [ 6 ] != <STRING> : <NEWLINE> <INDENT> s . insert ( 6 , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s [ len ( s ) - 1 ] != <STRING> : <NEWLINE> <INDENT> s . append ( <STRING> ) <NEWLINE> <DEDENT> if <STRING> . join ( s ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> S = input ( ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> i = 1 <NEWLINE> x = 0 <NEWLINE> MOD = 2019 <NEWLINE> for s in S : <NEWLINE> <INDENT> x += ( int ( s ) * i ) % MOD <NEWLINE> x %= MOD <NEWLINE> d [ x ] += 1 <NEWLINE> i *= 10 <NEWLINE> i %= MOD <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for k in d . values ( ) : <NEWLINE> <INDENT> ans = ans + k * ( k - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans + d [ 0 ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = [ None ] + [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p_to_i = [ None ] * ( N + 1 ) <NEWLINE> for i , x in enumerate ( P [ 1 : ] , 1 ) : <NEWLINE> <INDENT> p_to_i [ x ] = i <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def BIT_add ( i ) : <NEWLINE> <INDENT> while i <= N : <NEWLINE> <INDENT> tree [ i ] += 1 <NEWLINE> i += i & ( - i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def BIT_sum ( i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i : <NEWLINE> <INDENT> s += tree [ i ] <NEWLINE> i -= i & ( - i ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def BIT_search ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 0 <NEWLINE> s = 0 <NEWLINE> step = 1 << ( N . bit_length ( ) - 1 ) <NEWLINE> while step : <NEWLINE> <INDENT> if i + step <= N and s + tree [ i + step ] < x : <NEWLINE> <INDENT> i += step <NEWLINE> s += tree [ i ] <NEWLINE> <DEDENT> step >>= 1 <NEWLINE> <DEDENT> return i + 1 <NEWLINE> left = 0 <NEWLINE> right = N <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if BIT_sum ( mid ) >= x : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> return right <NEWLINE> <NL> <DEDENT> tree = [ 0 ] * ( N + 1 ) <NEWLINE> answer = 0 <NEWLINE> for x in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> c = p_to_i [ x ] <NEWLINE> L = BIT_sum ( c ) <COMMENT> <NEWLINE> BIT_add ( c ) <NEWLINE> R = N - x - L <COMMENT> <NEWLINE> a = BIT_search ( L - 1 ) if L >= 2 else 0 <NEWLINE> b = BIT_search ( L ) if L >= 1 else 0 <NEWLINE> d = BIT_search ( L + 2 ) if R >= 1 else N + 1 <NEWLINE> e = BIT_search ( L + 3 ) if R >= 2 else N + 1 <NEWLINE> coef = 0 <NEWLINE> if b != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> coef += ( b - a ) * ( d - c ) <NEWLINE> <DEDENT> if d != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> coef += ( e - d ) * ( c - b ) <NEWLINE> <DEDENT> answer += x * coef <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <NL>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 100000 <NEWLINE> flag = False <NEWLINE> for i in range ( - 1 , 102 ) : <NEWLINE> <INDENT> if i in P : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( X - ans ) > abs ( X - i ) : <NEWLINE> <INDENT> flag = True <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> max = 10 ** 18 <NEWLINE> <NL> if 0 in c : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans < max : <NEWLINE> <INDENT> ans = ans * c [ i ] <NEWLINE> if ans > max : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> bit = [ 0 ] * 60 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> n1 = np . count_nonzero ( ( a >> i ) & 1 ) <NEWLINE> n0 = n - n1 <NEWLINE> ans += ( 2 ** i ) * n1 * n0 % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> count = [ ] <NEWLINE> for x1 , y1 in xy : <NEWLINE> <INDENT> for x2 , y2 in xy : <NEWLINE> <INDENT> if x1 == x2 and y1 == y2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c = str ( x1 - x2 ) + <STRING> + str ( y1 - y2 ) <NEWLINE> count . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> from collections import * <NEWLINE> C = Counter ( count ) <NEWLINE> C [ <STRING> ] = 0 <NEWLINE> print ( N - max ( C . values ( ) ) ) <NEWLINE>
<NL> from math import gcd <NEWLINE> <NL> def gcd2 ( p , q ) : <COMMENT> <NEWLINE> <INDENT> if p % q == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> return q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( q , p % q ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> gcd_ij = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> gcd_ijk = gcd ( gcd_ij , k ) <NEWLINE> <COMMENT> <NL> ans += gcd_ijk <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> A = [ ] <NEWLINE> A = list ( s ) <NEWLINE> <NL> <COMMENT> <NL> <NL> add = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> if A [ i ] == <STRING> and A [ i + 1 ] == <STRING> and A [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> add = add + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( add ) <NEWLINE>
import numpy as np <NEWLINE> def finalFunc ( n , s , A ) : <NEWLINE> <INDENT> var = np . array ( [ 0 for i in range ( min ( 3001 , s + 1 ) ) ] ) <NEWLINE> var [ 0 ] = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> tmp = var [ : - i ] . copy ( ) <NEWLINE> var *= 2 <NEWLINE> var [ i : ] += tmp <NEWLINE> var %= 998244353 <NEWLINE> <DEDENT> return var [ s ] <NEWLINE> <DEDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( finalFunc ( n , s , A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) for i in range ( n ) ) <NEWLINE> print ( len ( set ( a ) ) ) <NEWLINE>
rooms = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> info = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rooms [ info [ 0 ] - 1 ] [ info [ 1 ] - 1 ] [ info [ 2 ] - 1 ] += info [ 3 ] <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in rooms [ b ] : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( str , f ) ) ) ) <NEWLINE> <DEDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = str ( input ( ) ) <NEWLINE> count = X . count ( <STRING> ) <NEWLINE> num , nump , numm = 0 , 0 , 0 <NEWLINE> now , nowp , nowm = 1 , 1 , 1 <NEWLINE> <NL> if count == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> elif count == 1 : <NEWLINE> <INDENT> if X [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i != N - 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i != N - 1 : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> quit ( ) <NEWLINE> <NL> <NL> <DEDENT> xx = [ 0 ] * N <NEWLINE> x_plus = [ 0 ] * N <NEWLINE> x_minus = [ 0 ] * N <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> now *= 2 <NEWLINE> nowp *= 2 <NEWLINE> <NL> now %= count <NEWLINE> nowp %= ( count + 1 ) <NEWLINE> <NL> <NL> nowm *= 2 <NEWLINE> nowm %= ( count - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> now %= count <NEWLINE> nowp %= ( count + 1 ) <NEWLINE> nowm %= ( count - 1 ) <NEWLINE> <DEDENT> xx [ i - 1 ] = now <NEWLINE> x_plus [ i - 1 ] = nowp <NEWLINE> x_minus [ i - 1 ] = nowm <NEWLINE> if X [ - i ] == <STRING> : <NEWLINE> <INDENT> num += now <NEWLINE> num %= count <NEWLINE> nump += nowp <NEWLINE> nump %= count + 1 <NEWLINE> numm += nowm <NEWLINE> numm %= count - 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> nextn = [ 0 ] * N <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> a = nump + x_plus [ N - 1 - i ] <NEWLINE> b = count + 1 <NEWLINE> <COMMENT> <NL> nextn [ i ] = a % b <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a = numm - x_minus [ N - 1 - i ] <NEWLINE> b = count - 1 <NEWLINE> nextn [ i ] = a % b <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if nextn [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nownow = nextn [ i ] <NEWLINE> ans = 1 <NEWLINE> while nownow != 0 : <NEWLINE> <INDENT> alpha = bin ( nownow ) [ 2 : ] <NEWLINE> beta = str ( alpha ) . count ( <STRING> ) <NEWLINE> nownow %= beta <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = int ( input ( ) ) <NEWLINE> <NL> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = ( b - a ) / ( v - w ) <NEWLINE> if t >= abs ( ans ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> x = int ( input ( ) ) <NEWLINE> <NL> def enum_div ( n ) : <NEWLINE> <INDENT> ir = int ( n ** ( 0.5 ) ) + 1 <NEWLINE> <COMMENT> <NL> ret = set ( ) <NEWLINE> for i in range ( 1 , ir ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ret . add ( i ) <NEWLINE> <COMMENT> <NL> if ( i != 1 ) & ( i * i != n ) : <NEWLINE> <COMMENT> <NL> <INDENT> ret . add ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> ret = enum_div ( x ) <NEWLINE> <NL> y = 20000 <NEWLINE> for ai in range ( - y , y ) : <NEWLINE> <INDENT> yn = <STRING> <NEWLINE> for r in ret : <NEWLINE> <INDENT> bi = ai - r <NEWLINE> if ai ** 5 - bi ** 5 == x : <NEWLINE> <INDENT> yn = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> bi = ai + r <NEWLINE> if ai ** 5 - bi ** 5 == x : <NEWLINE> <INDENT> yn = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if yn == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if yn == <STRING> : <NEWLINE> <INDENT> print ( ai , bi ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def bfs ( g_list , visited ) : <NEWLINE> <INDENT> q = deque ( [ 1 ] ) <NEWLINE> visited [ 1 ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> curr_room = q . popleft ( ) <NEWLINE> for next_room in g_list [ curr_room ] : <NEWLINE> <INDENT> if visited [ next_room ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ next_room ] = curr_room <NEWLINE> q . append ( next_room ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g_list = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> visited = [ - 1 ] * ( n + 1 ) <NEWLINE> visited [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g_list [ a ] . append ( b ) <NEWLINE> g_list [ b ] . append ( a ) <NEWLINE> <DEDENT> bfs ( g_list , visited ) <NEWLINE> <COMMENT> <NL> ans = visited [ 2 : ] <NEWLINE> if - 1 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <COMMENT> <NEWLINE> N = 10 ** 6 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> x , y = MAP ( ) <NEWLINE> a = 2 * x - y <NEWLINE> b = 2 * y - x <NEWLINE> <NL> if a >= 0 and b >= 0 and a % 3 == 0 and b % 3 == 0 : <NEWLINE> <INDENT> a //= 3 <NEWLINE> b //= 3 <NEWLINE> ans = cmb ( a + b , a , 10 ** 9 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class Node : <NEWLINE> <INDENT> def __init__ ( self , num , parent , leftmostChild , rightSibling ) : <NEWLINE> <INDENT> self . id = num <NEWLINE> self . parent = parent <NEWLINE> self . leftmostChild = leftmostChild <NEWLINE> self . rightSibling = rightSibling <NEWLINE> self . depth = 0 <NEWLINE> <NL> <DEDENT> def show_info ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . id ) , end = <STRING> ) <NEWLINE> print ( <STRING> . format ( self . parent . id ) , end = <STRING> ) <NEWLINE> print ( <STRING> . format ( self . depth ) , end = <STRING> ) <NEWLINE> if self . leftmostChild and self . parent . id != - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif self . parent . id != - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> t_n = self . leftmostChild <NEWLINE> if t_n : <NEWLINE> <INDENT> print ( t_n . id , end = <STRING> ) <NEWLINE> t_n = t_n . rightSibling <NEWLINE> <DEDENT> while t_n : <NEWLINE> <INDENT> print ( <STRING> . format ( t_n . id ) , end = <STRING> ) <NEWLINE> t_n = t_n . rightSibling <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class RootedTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . base_node = Node ( - 1 , None , None , None ) <NEWLINE> self . nodes = [ Node ( i , self . base_node , None , None ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def set_node ( self , num , k , * children ) : <NEWLINE> <INDENT> if children : <NEWLINE> <INDENT> self . nodes [ num ] . leftmostChild = self . nodes [ children [ 0 ] ] <NEWLINE> for i , x in enumerate ( children [ : - 1 ] ) : <NEWLINE> <INDENT> self . nodes [ x ] . parent = self . nodes [ num ] <NEWLINE> self . nodes [ x ] . rightSibling = self . nodes [ children [ i + 1 ] ] <NEWLINE> <DEDENT> self . nodes [ children [ - 1 ] ] . parent = self . nodes [ num ] <NEWLINE> <NL> <DEDENT> <DEDENT> def set_depth ( self ) : <NEWLINE> <INDENT> for n in self . nodes : <NEWLINE> <INDENT> t_n = n <NEWLINE> while t_n . parent . id != - 1 : <NEWLINE> <INDENT> n . depth += 1 <NEWLINE> t_n = t_n . parent <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def show_nodes_info ( self ) : <NEWLINE> <INDENT> for n in self . nodes : <NEWLINE> <INDENT> n . show_info ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> T = RootedTree ( n ) <NEWLINE> <NL> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> T . set_node ( * list ( map ( int , x . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> T . set_depth ( ) <NEWLINE> <NL> T . show_nodes_info ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> subs = [ 0 ] * N <NEWLINE> <NL> for boss in A : <NEWLINE> <INDENT> subs [ boss - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in subs : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt_s = Counter ( [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( n ) ] ) <NEWLINE> print ( sum ( v * ( v - 1 ) // 2 for v in cnt_s . values ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> wa = 1 <NEWLINE> ka = 0 <NEWLINE> if ( a . count ( 0 ) >= 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> ka += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> wa = wa * a [ i ] <NEWLINE> if ( wa > 10 ** 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ka += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( ka == 0 ) : <NEWLINE> <INDENT> print ( wa ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> i = 0 <NEWLINE> hidari = str ( ) <NEWLINE> migi = str ( ) <NEWLINE> a = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> hidari += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if a < 0 : <NEWLINE> <INDENT> hidari += abs ( a ) * <STRING> <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> migi += a * <STRING> <NEWLINE> <DEDENT> s = hidari + S + migi <NEWLINE> <NL> <NL> i = 0 <NEWLINE> hidari = str ( ) <NEWLINE> migi = str ( ) <NEWLINE> a = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> hidari += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> a += 1 <NEWLINE> mina = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> if a < 0 : <NEWLINE> <INDENT> if mina > a : <NEWLINE> <INDENT> hidari += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if a > 0 : <NEWLINE> <INDENT> migi += a * <STRING> <NEWLINE> <DEDENT> t = hidari + S + migi <NEWLINE> if len ( s ) == len ( t ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif len ( s ) > len ( t ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> import heapq <NEWLINE> k = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if gcd ( i , j ) == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> continue <NEWLINE> <DEDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , j , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
import sys <NEWLINE> import os <NEWLINE> from collections import deque <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) == <STRING> : <NEWLINE> <INDENT> file_input ( ) <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> r = { } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if A not in r : <NEWLINE> <INDENT> r [ A ] = [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ A ] . append ( B ) <NEWLINE> <DEDENT> if B not in r : <NEWLINE> <INDENT> r [ B ] = [ A ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ B ] . append ( A ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> visited = set ( ) <NEWLINE> visited . add ( 1 ) <NEWLINE> out = [ 0 ] * ( N - 1 ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> position = q . popleft ( ) <NEWLINE> <COMMENT> <NL> for des in r [ position ] : <COMMENT> <NEWLINE> <INDENT> if des not in visited : <COMMENT> <NEWLINE> <INDENT> q . append ( des ) <COMMENT> <NEWLINE> visited . add ( des ) <COMMENT> <NEWLINE> out [ des - 2 ] = position <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> [ print ( x ) for x in out ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( x , k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if y <= z <= k : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> count += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> scores = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if ( int ( scores [ i ] ) > int ( scores [ i - K ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def sh ( num ) : <NEWLINE> <INDENT> for n in num : <NEWLINE> <INDENT> out ( n ) <NEWLINE> <DEDENT> <DEDENT> def out ( n ) : <NEWLINE> <INDENT> number = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n [ 1 ] ) : <NEWLINE> <INDENT> number . append ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( n [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> . join ( number ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> num = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n [ 0 ] == 0 and n [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num . append ( n ) <NEWLINE> <DEDENT> <DEDENT> sh ( num ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> stars = defaultdict ( int ) <NEWLINE> for s in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> stars [ s ] += 1 <NEWLINE> <DEDENT> half_n = n // 2 <NEWLINE> for i , s in stars . items ( ) : <NEWLINE> <INDENT> if s > half_n : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> check = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> check [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> [ print ( x , end = <STRING> ) for x in check ] <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ int ( y ) for y in input ( ) . split ( ) ] <NEWLINE> <NL> Ma = max ( A ) <NEWLINE> mi = 1 <NEWLINE> <NL> ans = Ma <NEWLINE> <NL> def execute ( f ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> count += math . ceil ( i / f ) - 1 <NEWLINE> <DEDENT> if count <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> median = ( Ma + mi ) // 2 <NEWLINE> <NL> bobo = execute ( median ) <NEWLINE> <NL> if bobo : <NEWLINE> <INDENT> ans = min ( ans , median ) <NEWLINE> Ma = median <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mi = median + 1 <NEWLINE> <NL> <DEDENT> if Ma == mi : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( ans ) ) <NEWLINE>
from math import sqrt <NEWLINE> from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in permutations ( range ( N ) ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> dx = xy [ i [ j + 1 ] ] [ 0 ] - xy [ i [ j ] ] [ 0 ] <NEWLINE> dy = xy [ i [ j + 1 ] ] [ 1 ] - xy [ i [ j ] ] [ 1 ] <NEWLINE> d += sqrt ( dx ** 2 + dy ** 2 ) <NEWLINE> <DEDENT> ans += d <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( ans / cnt ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> N , K , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> A = [ - 1 ] + A <NEWLINE> INF = 1 << 50 <NEWLINE> X = [ INF , 1 , 1 ] <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i + 1 ] > A [ i - K + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> f = [ set ( ) for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> f [ a - 1 ] . add ( b - 1 ) <NEWLINE> f [ b - 1 ] . add ( a - 1 ) <NEWLINE> <DEDENT> chk = [ False ] * n <NEWLINE> q = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if chk [ i ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( i ) <NEWLINE> chk [ i ] = True <NEWLINE> cnt = 1 <NEWLINE> while q : <NEWLINE> <INDENT> x = q . pop ( ) <NEWLINE> for nx in f [ x ] : <NEWLINE> <INDENT> if chk [ nx ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( nx ) <NEWLINE> chk [ nx ] = True <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> c = collections . Counter ( List ) <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( c [ i ] ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pos = [ ] <NEWLINE> neg = [ ] <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if x >= 0 : <NEWLINE> <INDENT> pos . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> neg . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> pos . sort ( reverse = True ) <NEWLINE> neg . sort ( ) <NEWLINE> <NL> if len ( pos ) == 0 and k % 2 : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans *= neg [ - i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pi = 0 <NEWLINE> ni = 0 <NEWLINE> if k % 2 : <NEWLINE> <INDENT> ans *= pos [ pi ] <NEWLINE> pi += 1 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> while k > 0 : <NEWLINE> <INDENT> if pi < len ( pos ) - 1 : <NEWLINE> <INDENT> sp = pos [ pi ] * pos [ pi + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sp = 0 <NEWLINE> <NL> <DEDENT> if ni < len ( neg ) - 1 : <NEWLINE> <INDENT> sn = neg [ ni ] * neg [ ni + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sn = 0 <NEWLINE> <NL> <DEDENT> if sp > sn : <NEWLINE> <INDENT> ans *= sp <NEWLINE> pi += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= sn <NEWLINE> ni += 2 <NEWLINE> <NL> <DEDENT> ans %= MOD <NEWLINE> k -= 2 <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> total = sum ( s ) <NEWLINE> <NL> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> total -= s [ i ] <NEWLINE> ans += total * s [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <NL> S = list ( str ( input ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> a = 0 <NEWLINE> ab = 0 <NEWLINE> abc = 0 <NEWLINE> pat = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> a = ( a + pat ) % MOD <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> ab = ( ab + a ) % MOD <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> abc = ( abc + ab ) % MOD <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> tmpa = a <NEWLINE> tmpab = ab <NEWLINE> a = ( 3 * a + pat ) % MOD <NEWLINE> ab = ( 3 * ab + tmpa ) % MOD <NEWLINE> abc = ( 3 * abc + tmpab ) % MOD <NEWLINE> pat = ( pat * 3 ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( abc ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> s = list ( s ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> sb = [ 0 ] * ( q + 1 ) <NEWLINE> sa = [ 0 ] * ( q + 1 ) <NEWLINE> sbi = 0 <NEWLINE> sai = 0 <NEWLINE> ta = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> temp = str ( input ( ) ) <NEWLINE> temp = list ( temp ) <NEWLINE> if temp [ 0 ] == <STRING> : <NEWLINE> <INDENT> ta = ta + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( temp [ 2 ] == <STRING> and ta % 2 == 0 ) or ( temp [ 2 ] == <STRING> and ta % 2 != 0 ) : <NEWLINE> <INDENT> sb [ sbi ] = temp [ 4 ] <NEWLINE> sbi = sbi + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sa [ sai ] = temp [ 4 ] <NEWLINE> sai = sai + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> lsb = sb . index ( 0 ) <NEWLINE> lsa = sa . index ( 0 ) <NEWLINE> sb . reverse ( ) <NEWLINE> ans = sb [ len ( sb ) - lsb : len ( sb ) ] + s + sa [ 0 : lsa ] <NEWLINE> if ta % 2 != 0 : <NEWLINE> <INDENT> ans . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> mod = 7 % K <NEWLINE> path = [ mod ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if mod == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> mod = ( mod * 10 + 7 ) % K <NEWLINE> path . append ( mod ) <NEWLINE> if mod == path [ 0 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> numlist = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> a = s [ i : i + len ( t ) ] <NEWLINE> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if a [ j ] != t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> numlist . append ( count ) <NEWLINE> <DEDENT> print ( min ( numlist ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 or <STRING> in str ( i ) ) : <NEWLINE> <INDENT> print ( <STRING> , i , sep = <STRING> , end = <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Amax = max ( A ) <NEWLINE> <NL> ans = [ False ] * ( Amax + 1 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> for j in range ( x , Amax + 1 , x ) : <NEWLINE> <INDENT> ans [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans [ i ] == 1 for i in A ) ) <NEWLINE>
def manipulate ( x , k ) : <NEWLINE> <INDENT> return abs ( x - k ) <NEWLINE> <NL> <DEDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = n % k <NEWLINE> <NL> while n > k / 2 : <NEWLINE> <INDENT> n = manipulate ( n , k ) <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> n = gcd ( a , b ) <NEWLINE> ans = 0 <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
<COMMENT> <NL> <NL> import itertools <NEWLINE> from functools import reduce <NEWLINE> from collections import deque <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i > K - 1 : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import heapq <NEWLINE> import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( lambda x : x * ( - 1 ) , A ) ) <NEWLINE> <NL> heapq . heapify ( A ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> max_value = heapq . heappop ( A ) * ( - 1 ) <NEWLINE> heapq . heappush ( A , max_value // 2 * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = [ None ] * ( n1 + 1 ) <NEWLINE> R = [ None ] * ( n2 + 1 ) <NEWLINE> L [ : n1 ] = A [ left : left + n1 ] <NEWLINE> R [ : n2 ] = A [ mid : mid + n2 ] <NEWLINE> <NL> L [ n1 ] = float ( <STRING> ) <NEWLINE> R [ n2 ] = float ( <STRING> ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> mergeSort ( S , 0 , n ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , S ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> cntA = Counter ( A ) <NEWLINE> <NL> ans = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans += cntA [ B ] * ( C - B ) <NEWLINE> cntA [ C ] += cntA [ B ] <NEWLINE> cntA [ B ] = 0 <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> over = 10 ** 18 <NEWLINE> <NL> for num in nums : <NEWLINE> <INDENT> ans = ans * num <NEWLINE> <NL> if ans > over : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> matrix1 = list ( ) <NEWLINE> matrix2 = list ( ) <NEWLINE> ans = list ( ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> matrix1 . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for j in range ( y ) : <NEWLINE> <INDENT> matrix2 . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> row = list ( ) <NEWLINE> for j in range ( z ) : <NEWLINE> <INDENT> term = 0 <NEWLINE> for k in range ( y ) : <NEWLINE> <INDENT> term += matrix1 [ i ] [ k ] * matrix2 [ k ] [ j ] <NEWLINE> <DEDENT> row . append ( term ) <NEWLINE> <DEDENT> ans . append ( row ) <NEWLINE> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , ans [ i ] ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ k + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pros = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] ) <NEWLINE> index = 0 <NEWLINE> covered = 0 <NEWLINE> right = 0 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , b = pros [ index ] <NEWLINE> if a > covered + 1 : <NEWLINE> <INDENT> if covered == right : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> covered = right <NEWLINE> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = max ( right , b ) <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> if covered == n : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if index == m : <NEWLINE> <INDENT> covered = right <NEWLINE> ans += 1 <NEWLINE> print ( ans if covered == n else <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( i == j == k ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> if ( i == j and j != k ) : <NEWLINE> <INDENT> ans += 3 * math . gcd ( k , math . gcd ( i , j ) ) <NEWLINE> <DEDENT> if ( i < j < k and i != j != k ) : <NEWLINE> <INDENT> ans += 6 * math . gcd ( k , math . gcd ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ [ int ( i ) for i in input ( ) . split ( ) ] for l in range ( q ) ] <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> s = sum ( [ j * k for j , k in c . items ( ) ] ) <NEWLINE> for x in b : <NEWLINE> <INDENT> s = s - x [ 0 ] * c [ x [ 0 ] ] + x [ 1 ] * c [ x [ 0 ] ] <NEWLINE> c [ x [ 0 ] ] , c [ x [ 1 ] ] = 0 , c [ x [ 0 ] ] + c [ x [ 1 ] ] <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> import numpy as np <NEWLINE> import itertools <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if k == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> b = math . gcd ( a , k ) <NEWLINE> ans += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <COMMENT> <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from copy import deepcopy <NEWLINE> from itertools import accumulate <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from functools import lru_cache <COMMENT> <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <STRING> <NEWLINE> <COMMENT> <NL> N2 = [ pow ( i , 2 , INF ) for i in N ] <NEWLINE> N3 = pow ( sum ( N ) , 2 , INF ) <NEWLINE> <COMMENT> <NL> N4 = ( N3 - sum ( N2 ) ) <NEWLINE> if N4 % 2 == 1 : <NEWLINE> <INDENT> N4 += INF <NEWLINE> <DEDENT> ans = ( N4 / 2 ) % INF <NEWLINE> print ( int ( ans ) ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> start_set = set ( ) <NEWLINE> goal_set = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , g = map ( int , input ( ) . split ( ) ) <NEWLINE> if s == 1 : <NEWLINE> <INDENT> start_set . add ( g ) <NEWLINE> <DEDENT> if g == n : <NEWLINE> <INDENT> goal_set . add ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> if ( start_set & goal_set ) else <STRING> <NEWLINE> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> sm = sum ( A ) ** 2 <NEWLINE> <COMMENT> <NL> com = sum ( [ i * i for i in A ] ) <NEWLINE> <NL> ans = ( sm - com ) // 2 <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b = gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a += gcd ( k , b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> from math import isinf <NEWLINE> INF = float ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> def dfs ( v , tm ) : <NEWLINE> <INDENT> dts [ v ] = est [ v ] = tm + 1 <NEWLINE> child = 0 <NEWLINE> for i in adj [ v ] : <NEWLINE> <INDENT> if isinf ( est [ i ] ) : <NEWLINE> <INDENT> child += 1 <NEWLINE> parents [ i ] = v <NEWLINE> dfs ( i , tm + 1 ) <NEWLINE> est [ v ] = min ( est [ v ] , est [ i ] ) <NEWLINE> if parents [ v ] is None and child > 1 : aps [ v ] = True <NEWLINE> if parents [ v ] is not None and est [ i ] >= dts [ v ] : aps [ v ] = True <NEWLINE> <DEDENT> elif parents [ v ] != i : <NEWLINE> <INDENT> est [ v ] = min ( est [ v ] , dts [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> est = [ float ( <STRING> ) ] * n <NEWLINE> parents = [ None ] * n <NEWLINE> aps = [ False ] * n <NEWLINE> dts = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> adj [ s ] . append ( t ) <NEWLINE> adj [ t ] . append ( s ) <NEWLINE> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if aps [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> res = [ 0 ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in A : <NEWLINE> <INDENT> res [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res . count ( 0 ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> na , nb = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> na . append ( na [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> nb . append ( nb [ j ] + b [ j ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> l = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if na [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while nb [ l ] > k - na [ i ] : <NEWLINE> <INDENT> l -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + l ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> cnt_list = collections . Counter ( A ) <NEWLINE> total = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> cnt_list [ BC [ i ] [ 1 ] ] += cnt_list [ BC [ i ] [ 0 ] ] <NEWLINE> total += ( BC [ i ] [ 1 ] - BC [ i ] [ 0 ] ) * cnt_list [ BC [ i ] [ 0 ] ] <NEWLINE> cnt_list [ BC [ i ] [ 0 ] ] = 0 <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
from itertools import * <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> M = m <NEWLINE> a = [ 1 ] <NEWLINE> for i in range ( 2 , int ( m ** .5 ) + 1 ) : <NEWLINE> <INDENT> while m % i == 0 : <NEWLINE> <INDENT> m //= i <NEWLINE> a += [ i ] <NEWLINE> <DEDENT> <DEDENT> if m != 1 : a += [ m ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> for b in combinations_with_replacement ( set ( a ) , i ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> for j in b : c *= j <NEWLINE> if c >= n and M % c == 0 : ans = max ( ans , M // c ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> r = range ( 1 , int ( n ** 0.5 ) + 1 ) <NEWLINE> for x in r : <NEWLINE> <INDENT> for y in r : <NEWLINE> <INDENT> for z in r : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a <= n : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from itertools import groupby <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> def fast_prime_factorization ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> from subprocess import Popen , PIPE <NEWLINE> return list ( map ( int , Popen ( [ <STRING> , str ( n ) ] , stdout = PIPE ) . communicate ( ) [ 0 ] . split ( ) [ 1 : ] ) ) <NEWLINE> <NL> <NL> <DEDENT> def egcd ( a , b ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b , 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g , y , x = egcd ( b % a , a ) <NEWLINE> return g , x - ( b // a ) * y , y <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def a ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> f = fast_prime_factorization ( 2 * n ) <NEWLINE> f2 = [ v ** len ( list ( gr ) ) for v , gr in groupby ( f ) ] <NEWLINE> l = len ( f2 ) <NEWLINE> ans = 1 << 62 <NEWLINE> for s in range ( 1 << l ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> q = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if s >> i & 1 : <NEWLINE> <INDENT> p *= f2 [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q *= f2 [ i ] <NEWLINE> <DEDENT> <DEDENT> if p == 1 or q == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> g , x , y = egcd ( - p , q ) <NEWLINE> a = abs ( y ) * q <NEWLINE> <COMMENT> <NL> if ans > a : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( a ( N ) ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pn_list = [ 0 ] * n <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> ans_ac = 0 <NEWLINE> ans_pn = 0 <NEWLINE> pn_list [ 0 ] == - 1 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = input ( ) . split ( ) <NEWLINE> a [ i ] = ( int ( a [ i ] ) ) <NEWLINE> <COMMENT> <NL> if pn_list [ a [ i ] - 1 ] != - 1 : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> ans_pn += pn_list [ a [ i ] - 1 ] <NEWLINE> ans_ac += 1 <NEWLINE> pn_list [ a [ i ] - 1 ] = - 1 <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pn_list [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans_ac , ans_pn ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> res = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> if res > 10 ** 18 : continue <NEWLINE> else : res *= i <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 if res > 10 ** 18 else res ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> s = input ( ) <NEWLINE> alphabet = <STRING> <NEWLINE> <NL> result = [ ] <NEWLINE> if len ( set ( s ) ) == 1 : <NEWLINE> <INDENT> result . append ( 0 ) <NEWLINE> <DEDENT> for i in alphabet : <NEWLINE> <INDENT> s_tmp = s <NEWLINE> cnt = 0 <NEWLINE> for k in range ( len ( s_tmp ) ) : <NEWLINE> <INDENT> s_new = <STRING> <NEWLINE> for j in range ( len ( s_tmp ) - 1 ) : <NEWLINE> <INDENT> if s_tmp [ j ] == i or s_tmp [ j + 1 ] == i : <NEWLINE> <INDENT> s_new += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_new += s_tmp [ j ] <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> if len ( set ( s_new ) ) == 1 : <NEWLINE> <INDENT> result . append ( cnt ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> s_tmp = s_new <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( min ( result ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> N = input ( ) <NEWLINE> a = np . arange ( np . float ( N ) ) + 1 <NEWLINE> a = np . where ( a % 3 == 0. , 0 , a ) <NEWLINE> a = np . where ( a % 5 == 0. , 0 , a ) <NEWLINE> print ( int ( sum ( a ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if A . count ( 0 ) >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = [ i for i in A if i != 1 ] <NEWLINE> if len ( B ) >= 100 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( len ( B ) ) : <NEWLINE> <INDENT> ans = ans * B [ k ] <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> dist = [ - 1 ] * N <NEWLINE> dist [ 0 ] = 0 <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for nv in G [ v ] : <NEWLINE> <INDENT> if dist [ nv ] == - 1 : <NEWLINE> <INDENT> dist [ nv ] = v + 1 <NEWLINE> q . append ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * dist [ 1 : ] , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( math . pi * r * r , 2 * math . pi * r ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> if k * 3 == s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 10010 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> x = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if x <= n : <NEWLINE> <INDENT> ans [ x ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = 0 <NEWLINE> ans = 0 <NEWLINE> A = [ 0 ] * 2019 <NEWLINE> A [ 0 ] = 1 <NEWLINE> for i , j in enumerate ( reversed ( s ) ) : <NEWLINE> <INDENT> n = ( n + int ( j ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> <COMMENT> <NL> A [ n ] += 1 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> if ( __name__ == <STRING> ) : <NEWLINE> <NL> <INDENT> N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> divisor = 10 ** 9 + 7 <NEWLINE> list_a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> multiplies = 1 <NEWLINE> if ( N == K ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> multiplies = multiplies * list_a [ i ] % divisor <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> list_a . sort ( ) <NEWLINE> <STRING> <NEWLINE> if ( list_a [ - 1 ] < 0 and K % 2 != 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> multiplies = multiplies * list_a [ N - 1 - i ] % divisor <NEWLINE> <DEDENT> <DEDENT> elif ( K == 1 ) : <NEWLINE> <INDENT> multiplies = list_a [ N - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = N - 1 <NEWLINE> if ( K % 2 != 0 ) : <NEWLINE> <INDENT> multiplies = multiplies * list_a [ right ] % divisor <NEWLINE> right -= 1 <NEWLINE> <DEDENT> multiply_left = list_a [ left ] * list_a [ left + 1 ] <NEWLINE> multiply_right = list_a [ right ] * list_a [ right - 1 ] <NEWLINE> <NL> for s in range ( K // 2 - 1 ) : <NEWLINE> <INDENT> if ( multiply_left < multiply_right ) : <NEWLINE> <INDENT> multiply_right %= divisor <NEWLINE> multiplies = multiplies * multiply_right % divisor <NEWLINE> right -= 2 <NEWLINE> multiply_right = list_a [ right ] * list_a [ right - 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> multiply_left %= divisor <NEWLINE> multiplies = multiplies * multiply_left % divisor <NEWLINE> left += 2 <NEWLINE> multiply_left = list_a [ left ] * list_a [ left + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if ( multiply_left < multiply_right ) : <NEWLINE> <INDENT> multiply_right %= divisor <NEWLINE> multiplies = multiplies * multiply_right % divisor <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> multiply_left %= divisor <NEWLINE> multiplies = multiplies * multiply_left % divisor <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( multiplies ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> not_in_p = [ i for i in range ( 0 , 102 ) if i not in p ] <NEWLINE> nip_temp = list ( map ( lambda s : abs ( x - s ) , not_in_p ) ) <NEWLINE> <NL> address = nip_temp . index ( min ( nip_temp ) ) <NEWLINE> print ( not_in_p [ address ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> a = a + i <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> P = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> C = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> MAX_C = 2 * 10 ** 5 <NEWLINE> C = [ - 1 ] + C <NEWLINE> D = [ - 1 ] * ( MAX_C + 1 ) <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i + 1 ] == C [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = D [ C [ i + 1 ] ] <NEWLINE> if j != - 1 : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] + dp [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] <NEWLINE> <DEDENT> <DEDENT> dp [ i + 1 ] %= P <NEWLINE> D [ C [ i + 1 ] ] = i + 1 <NEWLINE> <NL> <DEDENT> ans = dp [ N ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> values = [ ] <NEWLINE> scores = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> values . append ( tmp [ 0 ] ) <NEWLINE> scores . append ( tmp [ 1 : ] ) <NEWLINE> <DEDENT> scores = np . array ( scores ) <NEWLINE> values = np . array ( values ) <NEWLINE> <NL> def df ( arg , score , tmp , args ) : <NEWLINE> <INDENT> tmps = [ ] <NEWLINE> if arg == N : <NEWLINE> <INDENT> if len ( np . where ( score >= X ) [ 0 ] ) == M : <NEWLINE> <INDENT> return tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> check = df ( arg + 1 , score , tmp , args ) <NEWLINE> if check : <NEWLINE> <INDENT> if type ( check ) == list : <NEWLINE> <INDENT> tmps . extend ( check ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmps . append ( check ) <NEWLINE> <DEDENT> <DEDENT> check = df ( arg + 1 , score + scores [ arg ] , tmp + values [ arg ] , args + [ arg ] ) <NEWLINE> if check : <NEWLINE> <INDENT> if type ( check ) == list : <NEWLINE> <INDENT> tmps . extend ( check ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmps . append ( check ) <NEWLINE> <DEDENT> <DEDENT> if tmps == [ ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return tmps <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = df ( 0 , np . zeros ( M ) , 0 , [ ] ) <NEWLINE> if tmp != 0 : <NEWLINE> <INDENT> print ( min ( tmp ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> sc = - 1 <NEWLINE> sf = - 1 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> sc = i <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> sf = i <NEWLINE> <NL> <DEDENT> <DEDENT> if ( sc == - 1 ) or ( sf == - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sc < sf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 10 ** 4 <NEWLINE> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> for h in range ( 1 , 101 ) : <NEWLINE> <INDENT> tmp = h ** 2 + j ** 2 + k ** 2 + h * j + j * k + k * h <NEWLINE> if tmp <= 10000 : <NEWLINE> <INDENT> a [ tmp - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = [ - 1 for i in range ( n ) ] <NEWLINE> e = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> e [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> def dfs ( cur , par , di ) : <NEWLINE> <INDENT> d [ cur ] = di <NEWLINE> for i in e [ cur ] : <NEWLINE> <INDENT> if d [ i [ 0 ] ] == - 1 : <NEWLINE> <INDENT> if i == par : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i [ 0 ] , cur , di + i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( k - 1 , - 1 , 0 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( d [ x - 1 ] + d [ y - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( float , input ( ) . split ( ) ) <NEWLINE> s1 = ( a - c ) * ( a - c ) <NEWLINE> s2 = ( b - d ) * ( b - d ) <NEWLINE> print ( <STRING> % math . sqrt ( s1 + s2 ) ) <NEWLINE> <NL>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> b = [ ] <NEWLINE> su = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> su += a [ - i ] <NEWLINE> b . append ( su ) <NEWLINE> <DEDENT> for j in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> s += a [ - j ] * b [ j - 2 ] <NEWLINE> s %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
c = { } <NEWLINE> for _ in range ( int ( input ( ) ) ) : s = input ( ) ; c [ s ] = c . get ( s , 0 ) + 1 <NEWLINE> m = max ( c . values ( ) ) <NEWLINE> print ( * sorted ( k for k in c if c [ k ] == m ) ) <NEWLINE>
S = input ( ) <NEWLINE> P = 2019 <NEWLINE> ans = 0 <NEWLINE> <NL> count = [ 0 ] * P <NEWLINE> count [ 0 ] = 1 <NEWLINE> u = 0 <NEWLINE> for i , s in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> u = ( int ( s ) * pow ( 10 , i , P ) + u ) % P <NEWLINE> ans += count [ u ] <NEWLINE> count [ u ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> n = int ( input ( ) ) + 1 <NEWLINE> a = int ( 0 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> b = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n ) : <NEWLINE> <INDENT> a = a + math . gcd ( b , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> build , story , room , people = [ ] , [ ] , [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> date = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> build . append ( date [ 0 ] ) <NEWLINE> story . append ( date [ 1 ] ) <NEWLINE> room . append ( date [ 2 ] ) <NEWLINE> people . append ( date [ 3 ] ) <NEWLINE> <DEDENT> build1 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> build2 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> build3 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> build4 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( i ) <NEWLINE> if ( build [ m ] == 1 ) : <NEWLINE> <INDENT> build1 [ story [ m ] - 1 ] [ room [ m ] - 1 ] = build1 [ story [ m ] - 1 ] [ room [ m ] - 1 ] + people [ m ] <NEWLINE> <DEDENT> elif ( build [ m ] == 2 ) : <NEWLINE> <INDENT> build2 [ story [ m ] - 1 ] [ room [ m ] - 1 ] = build2 [ story [ m ] - 1 ] [ room [ m ] - 1 ] + people [ m ] <NEWLINE> <DEDENT> elif ( build [ m ] == 3 ) : <NEWLINE> <INDENT> build3 [ story [ m ] - 1 ] [ room [ m ] - 1 ] = build3 [ story [ m ] - 1 ] [ room [ m ] - 1 ] + people [ m ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> build4 [ story [ m ] - 1 ] [ room [ m ] - 1 ] = build4 [ story [ m ] - 1 ] [ room [ m ] - 1 ] + people [ m ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( lambda x : str ( x ) , build1 [ i ] ) ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( lambda x : str ( x ) , build2 [ i ] ) ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( lambda x : str ( x ) , build3 [ i ] ) ) ) ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( list ( map ( lambda x : str ( x ) , build4 [ i ] ) ) ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= l [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <NL>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> elif i == j or j == k or i == k : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> ri = [ ] <NEWLINE> num = 0 <NEWLINE> <NL> <NL> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> li . append ( L ) <NEWLINE> ri . append ( R ) <NEWLINE> <DEDENT> L = max ( li ) <NEWLINE> R = min ( ri ) <NEWLINE> num = R - L + 1 <NEWLINE> if num < 0 : <NEWLINE> <INDENT> num = 0 <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE> <NL>
h , w , m = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> bo = [ ] <NEWLINE> hb = [ 0 ] * h <NEWLINE> wb = [ 0 ] * w <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> hb [ a - 1 ] += 1 <NEWLINE> wb [ b - 1 ] += 1 <NEWLINE> <COMMENT> <NL> bo . append ( [ a , b ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> mwb = [ ] <NEWLINE> mhb = [ ] <NEWLINE> <COMMENT> <NL> hmax = max ( hb ) <NEWLINE> wmax = max ( wb ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if hb [ i ] == hmax : <NEWLINE> <INDENT> mhb . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if wb [ i ] == wmax : <NEWLINE> <INDENT> mwb . append ( i ) <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> <COMMENT> <NL> for h , w in bo : <NEWLINE> <COMMENT> <NL> <INDENT> if ( hb [ h - 1 ] == hmax and wb [ w - 1 ] == wmax ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> out = hmax + wmax <NEWLINE> <COMMENT> <NL> if c == len ( mwb ) * len ( mhb ) : <NEWLINE> <INDENT> out -= 1 <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( accumulate ( a ) ) <NEWLINE> b = list ( accumulate ( b ) ) <NEWLINE> ans = 0 <NEWLINE> num_b = m <NEWLINE> for num_a in range ( n + 1 ) : <NEWLINE> <INDENT> sum_a = a [ num_a ] <NEWLINE> if sum_a > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while sum_a + b [ num_b ] > k : <NEWLINE> <INDENT> num_b -= 1 <NEWLINE> <DEDENT> ans = max ( num_a + num_b , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sub = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j * 2 - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> sub += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - sub ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> rui = [ 0 ] * ( n + 1 ) <NEWLINE> rui [ 1 ] = 1 <NEWLINE> p = 998244353 <NEWLINE> lr = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> lr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for l , r in lr : <NEWLINE> <INDENT> dp [ i ] += rui [ max ( i - l , 0 ) ] - rui [ max ( i - r - 1 , 0 ) ] <NEWLINE> dp [ i ] %= p <NEWLINE> <DEDENT> rui [ i ] = rui [ i - 1 ] + dp [ i ] <NEWLINE> rui [ i ] %= p <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> import heapq as hp <NEWLINE> <NL> WHITE , GRAY , BLACK = 0 , 1 , 2 <NEWLINE> D_MAX = int ( 5e10 + 1 ) <NEWLINE> <NL> <NL> def generate_adj_matrix ( v_info ) : <NEWLINE> <INDENT> for each in v_info : <NEWLINE> <INDENT> v_index , v_adj_length , * v_adj_list = map ( int , each ) <NEWLINE> <COMMENT> <NL> for pair in zip ( v_adj_list [ : : 2 ] , v_adj_list [ 1 : : 2 ] ) : <NEWLINE> <INDENT> init_adj_matrix [ v_index ] [ pair [ 0 ] ] = pair [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return init_adj_matrix <NEWLINE> <NL> <NL> <DEDENT> def dijkstra_path ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> path_list [ init_vertex_index ] = 0 <NEWLINE> path_heap = [ ] <NEWLINE> <COMMENT> <NL> hp . heappush ( path_heap , ( 0 , init_vertex_index ) ) <NEWLINE> while len ( path_heap ) >= 1 : <NEWLINE> <INDENT> current_vertex_index = hp . heappop ( path_heap ) [ 1 ] <NEWLINE> <NL> color [ current_vertex_index ] = BLACK <NEWLINE> <NL> current_vertex_index_info = adj_table [ current_vertex_index ] <NEWLINE> for adj_vertex_index in current_vertex_index_info . keys ( ) : <NEWLINE> <INDENT> current_adj_weight = current_vertex_index_info . get ( adj_vertex_index ) <NEWLINE> if color [ adj_vertex_index ] is not BLACK : <NEWLINE> <COMMENT> <NL> <INDENT> alt_path = path_list [ current_vertex_index ] + current_adj_weight <NEWLINE> if alt_path < path_list [ adj_vertex_index ] : <NEWLINE> <COMMENT> <NL> <INDENT> path_list [ adj_vertex_index ] = alt_path <NEWLINE> <COMMENT> <NL> hp . heappush ( path_heap , ( alt_path , adj_vertex_index ) ) <NEWLINE> parent_list [ adj_vertex_index ] = current_vertex_index <NEWLINE> color [ adj_vertex_index ] = GRAY <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return path_list <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices_num = int ( _input [ 0 ] ) <NEWLINE> init_vertices_table = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <COMMENT> <NL> <NL> parent_list , path_list = [ - 1 ] * vertices_num , [ D_MAX ] * vertices_num <NEWLINE> color = [ WHITE ] * vertices_num <NEWLINE> init_adj_matrix = tuple ( dict ( ) for _ in range ( vertices_num ) ) <NEWLINE> init_vertex_index = 0 <NEWLINE> <NL> adj_table = generate_adj_matrix ( init_vertices_table ) <NEWLINE> ans = dijkstra_path ( ) <NEWLINE> for i , v in enumerate ( ans ) : <NEWLINE> <INDENT> print ( i , v ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> ans += min ( a , k ) <NEWLINE> ans -= max ( 0 , k - a - b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> c1 = range ( 1 , n + 1 ) <NEWLINE> c2 = itertools . combinations ( range ( 1 , n + 1 ) , 2 ) <NEWLINE> c3 = itertools . combinations ( range ( 1 , n + 1 ) , 3 ) <NEWLINE> <NL> t1 = sum ( list ( c1 ) ) <NEWLINE> t2 = sum ( list ( map ( lambda x : math . gcd ( x [ 0 ] , x [ 1 ] ) , c2 ) ) ) * 6 <NEWLINE> t3 = sum ( list ( map ( lambda x : math . gcd ( x [ 0 ] , math . gcd ( x [ 1 ] , x [ 2 ] ) ) , c3 ) ) ) * 6 <NEWLINE> <NL> print ( sum ( [ t1 , t2 , t3 ] ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from itertools import accumulate <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> return N , K , A <NEWLINE> <NL> <NL> <DEDENT> def sign ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 if x > 0 else - 1 <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , K , A , p = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> A . sort ( key = lambda a : - abs ( a ) ) <NEWLINE> s = 1 <COMMENT> <NEWLINE> v = 1 <COMMENT> <NEWLINE> idx_minus = - 1 <NEWLINE> idx_not_minus = - 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> _s = sign ( A [ i ] ) <NEWLINE> s *= _s <NEWLINE> v *= A [ i ] <NEWLINE> v %= p <NEWLINE> if _s >= 0 : <NEWLINE> <INDENT> idx_not_minus = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx_minus = i <NEWLINE> <DEDENT> <DEDENT> if s >= 0 or N == K : <NEWLINE> <INDENT> return v <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> a1 = A [ idx_minus ] <NEWLINE> b1 = max ( A [ K : ] ) <NEWLINE> <COMMENT> <NL> a2 = A [ idx_not_minus ] <NEWLINE> b2 = min ( A [ K : ] ) <NEWLINE> <NL> use_1 , use_2 = True , True <NEWLINE> if not ( idx_minus >= 0 and b1 >= 0 ) : <NEWLINE> <INDENT> use_1 = False <NEWLINE> <DEDENT> if not ( idx_not_minus >= 0 and b2 < 0 ) : <NEWLINE> <INDENT> use_2 = False <NEWLINE> <NL> <DEDENT> if use_1 and use_2 : <NEWLINE> <INDENT> if b1 * a2 >= b2 * a1 : <NEWLINE> <INDENT> use_1 = True <NEWLINE> use_2 = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> use_1 = False <NEWLINE> use_2 = True <NEWLINE> <DEDENT> <DEDENT> if use_1 : <NEWLINE> <INDENT> v *= pow ( a1 , p - 2 , p ) <NEWLINE> v %= p <NEWLINE> v *= b1 <NEWLINE> v %= p <NEWLINE> <DEDENT> elif use_2 : <NEWLINE> <INDENT> v *= pow ( a2 , p - 2 , p ) <NEWLINE> v %= p <NEWLINE> v *= b2 <NEWLINE> v %= p <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> A . sort ( key = lambda a : abs ( a ) ) <NEWLINE> s = 1 <NEWLINE> v = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> _s = sign ( A [ i ] ) <NEWLINE> s *= _s <NEWLINE> v *= A [ i ] <NEWLINE> v %= p <NEWLINE> <DEDENT> <DEDENT> return v <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ss = sorted ( s ) <NEWLINE> c = len ( s ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ss [ i - 1 ] == ss [ i ] : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = n // i <NEWLINE> ret += i * x * ( x + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def gacha ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> string = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> string . append ( s ) <NEWLINE> <DEDENT> result = list ( set ( string ) ) <NEWLINE> print ( len ( result ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> gacha ( ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> bb = b // x <NEWLINE> aa = a // x <NEWLINE> ans = bb - aa <NEWLINE> if a % x == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dic = [ 0 ] * ( k + 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> dic [ i ] = pow ( k // i , n , MOD ) <NEWLINE> <NL> <DEDENT> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i * 2 , k + 1 , i ) : <NEWLINE> <INDENT> dic [ i ] -= dic [ j ] <NEWLINE> dic [ i ] %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += dic [ i ] * i <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> in_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> in_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> matrices = [ [ <STRING> for _ in range ( n ) ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> inp = in_list [ i ] <NEWLINE> u = inp [ 0 ] <NEWLINE> k = inp [ 1 ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> m = inp [ j + 2 ] <NEWLINE> matrices [ i ] [ m - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( matrices [ i ] ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input = stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif H > 301 or W > 301 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> row = <STRING> * W <NEWLINE> print ( row ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> for ai in a : <NEWLINE> <INDENT> ans *= ai <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def alf ( st ) : <NEWLINE> <INDENT> if st == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 3 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 4 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 5 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 6 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 7 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 8 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 9 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 10 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 11 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 12 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 13 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 14 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 15 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 16 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 17 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 18 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 19 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 20 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 21 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 22 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 23 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 24 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if st == 25 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def cc ( ) : <NEWLINE> <INDENT> N , = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ 0 for i in range ( 100 ) ] <NEWLINE> NN = N <NEWLINE> count = 1 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if NN > 26 ** i : <NEWLINE> <INDENT> NN = NN - 26 ** i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = i <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> NN -= 1 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> li [ count ] = NN % 26 <NEWLINE> count += 1 <NEWLINE> NN //= 26 <NEWLINE> if NN < 26 : <NEWLINE> <INDENT> li [ count ] = NN % 26 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> re = [ alf ( i ) for i in li [ : l ] ] <NEWLINE> re . reverse ( ) <NEWLINE> print ( <STRING> . join ( re ) ) <NEWLINE> <NL> <DEDENT> cc ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> NN = [ - 1 ] * N <NEWLINE> NN [ 0 ] = 0 <NEWLINE> <NL> i = 0 <NEWLINE> num = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> num += 1 <NEWLINE> i = A [ i ] - 1 <NEWLINE> if NN [ i ] != - 1 : <NEWLINE> <INDENT> n1 = NN [ i ] <NEWLINE> break <NEWLINE> <DEDENT> NN [ i ] = num <NEWLINE> <NL> <DEDENT> n_ = num - n1 <NEWLINE> <NL> if K > n1 : <NEWLINE> <INDENT> K -= n1 <NEWLINE> t = NN . index ( n1 + K % n_ ) + 1 <NEWLINE> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = NN . index ( K ) + 1 <NEWLINE> print ( t ) <NEWLINE> <DEDENT>
def count ( list ) : <NEWLINE> <INDENT> dict = { } <NEWLINE> for i in range ( len ( list ) ) : <NEWLINE> <INDENT> dict [ list [ i ] ] = dict . get ( list [ i ] , 0 ) + 1 <NEWLINE> <DEDENT> return dict <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = count ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i , x in dic . items ( ) : <NEWLINE> <INDENT> differ = x - i <NEWLINE> if differ > 0 : <NEWLINE> <INDENT> ans += differ <NEWLINE> <DEDENT> elif differ < 0 : <NEWLINE> <INDENT> ans += x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> def dfs ( now_p , visited , comb_p , p_num ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( visited ) == p_num : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for tmp_p in comb_p : <NEWLINE> <INDENT> if tmp_p [ 0 ] == now_p and tmp_p [ 1 ] not in visited : <NEWLINE> <COMMENT> <NL> <INDENT> tmp_visited = visited [ : ] <NEWLINE> tmp_visited . append ( tmp_p [ 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> next_p = tmp_p [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> tmp_comb = comb_p [ : ] <NEWLINE> tmp_comb . remove ( tmp_p ) <NEWLINE> <COMMENT> <NL> tmp_p_r = [ tmp_p [ 1 ] , tmp_p [ 0 ] ] <NEWLINE> tmp_comb . remove ( tmp_p_r ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans += dfs ( next_p , tmp_visited , tmp_comb , p_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a_b = [ ] <NEWLINE> tmp = [ ] <NEWLINE> tmp_r = [ ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp_r = [ tmp [ 1 ] , tmp [ 0 ] ] <NEWLINE> a_b . append ( tmp ) <NEWLINE> a_b . append ( tmp_r ) <NEWLINE> <NL> <DEDENT> visited = [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> pass_num = dfs ( 1 , visited , a_b , N ) <NEWLINE> print ( pass_num ) <NEWLINE>
import bisect as bs <NEWLINE> N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> f = lambda X , x : bs . bisect_right ( X , x ) - bs . bisect_left ( X , x ) <NEWLINE> cnt = sorted ( [ f ( A , a ) for a in set ( A ) ] , reverse = True ) <NEWLINE> vrt = len ( cnt ) <NEWLINE> print ( sum ( cnt [ K : ] ) if vrt > K else 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + a [ i ] <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result += a [ i ] * ( s [ n ] - s [ i + 1 ] ) % MOD <NEWLINE> <DEDENT> print ( result % MOD ) <NEWLINE> <NL>
<COMMENT> <NL> from __future__ import division <NEWLINE> from math import sqrt <NEWLINE> <NL> <NL> def mean ( list_ ) : <NEWLINE> <INDENT> return sum ( list_ ) / len ( list_ ) <NEWLINE> <NL> <NL> <DEDENT> def std ( list_ ) : <NEWLINE> <INDENT> m = mean ( list_ ) <NEWLINE> return sqrt ( sum ( [ ( x - m ) ** 2 for x in list_ ] ) / len ( list_ ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> while n : <NEWLINE> <INDENT> scores = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print std ( scores ) <NEWLINE> n = input ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> <NL> a = int ( x ** ( 1 / 5 ) ) <NEWLINE> b = int ( abs ( x - a ** 5 ) ** ( 1 / 5 ) ) <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if a ** 5 - b ** 5 != x and a ** 5 - ( - b ) ** 5 != x : <NEWLINE> <INDENT> if a ** 5 - x > ( a + 1 ) ** 5 - x : <NEWLINE> <INDENT> a += i <NEWLINE> b = int ( abs ( x - a ** 5 ) ** ( 1 / 5 ) ) <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> elif a ** 5 - ( - b ) ** 5 == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b = int ( abs ( x - a ** 5 ) ** ( 1 / 5 ) ) <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> elif a ** 5 - ( - b ) ** 5 == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> keihin = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> try : <NEWLINE> <INDENT> keihin [ S ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> keihin [ S ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( keihin ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> if hc == 0 or hc == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> a [ A ] = True <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> if not a [ 1 ] : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> if n > 1 : <NEWLINE> <INDENT> if not a [ 2 ] : <NEWLINE> <INDENT> dp [ 2 ] = dp [ 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if not a [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> if not a [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> if a [ i ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> list . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> list [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> print ( list [ i ] ) <NEWLINE> <DEDENT>
n , k , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ns_points = [ k ] * n <NEWLINE> ns_corrects = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ns_corrects [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for j in range ( len ( ns_points ) ) : <NEWLINE> <INDENT> if ns_points [ j ] - ( q - ns_corrects [ j ] ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> sum += i * ( N - i + 1 ) + 1 <NEWLINE> <DEDENT> print ( sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> import sys , math , itertools , collections , bisect <NEWLINE> input = lambda : sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> inf = float ( <STRING> ) ; mod = 10 ** 9 + 7 <NEWLINE> mans = inf ; ans = 0 ; count = 0 ; pro = 1 <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> A = list ( itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> for comb in A : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , b , c , d in E : <NEWLINE> <INDENT> a -= 1 ; b -= 1 <NEWLINE> if comb [ b ] - comb [ a ] == c : <NEWLINE> <INDENT> tmp += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 998244353 <NEWLINE> <NL> s = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . append ( ( l , r ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 1 <NEWLINE> totals = [ 0 ] * n <NEWLINE> totals [ 0 ] = 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> thisTotal = 0 <NEWLINE> for l , r in s : <NEWLINE> <INDENT> indL = i - l <NEWLINE> if indL >= 0 : <NEWLINE> <INDENT> indR = max ( 0 , i - r ) <NEWLINE> <NL> thisTotal += totals [ indL ] - totals [ indR - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> dp [ i ] = ( thisTotal % m ) <NEWLINE> totals [ i ] = ( totals [ i - 1 ] + thisTotal ) % m <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import heapq as hp <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> <COMMENT> <NL> <NL> allowed_commands = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> heap_array = [ ] <NEWLINE> for each in _input : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if each . startswith ( <STRING> ) : <NEWLINE> <INDENT> hp . heappush ( heap_array , - 1 * int ( each [ 7 : ] ) ) <NEWLINE> <DEDENT> elif each . startswith ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 * hp . heappop ( heap_array ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> A = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def score ( A ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for ( ai , bi , ci , di ) in zip ( a , b , c , d ) : <NEWLINE> <INDENT> if A [ bi - 1 ] - A [ ai - 1 ] == ci : <NEWLINE> <INDENT> sum += di <NEWLINE> <DEDENT> <DEDENT> return sum <NEWLINE> <DEDENT> def fbs ( A ) : <NEWLINE> <INDENT> if len ( A ) == n : <NEWLINE> <INDENT> return score ( A ) <NEWLINE> <DEDENT> if len ( A ) > 0 : <NEWLINE> <INDENT> pre_last = A [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pre_last = 0 <NEWLINE> <DEDENT> res = 0 <NEWLINE> for v in range ( pre_last , m ) : <NEWLINE> <INDENT> A . append ( v ) <NEWLINE> res = max ( res , fbs ( A ) ) <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> print ( fbs ( A ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ i - 1 for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> ss = set ( [ ] ) <NEWLINE> point = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if point in ss : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ss . add ( point ) <NEWLINE> point = P [ point ] <NEWLINE> <DEDENT> S = [ 0 ] <NEWLINE> points = 0 <NEWLINE> for i in range ( len ( ss ) - 1 ) : <NEWLINE> <INDENT> points = P [ points ] <NEWLINE> S . append ( points ) <NEWLINE> <DEDENT> loop = S [ S . index ( point ) : ] <NEWLINE> ll = len ( S ) <NEWLINE> l = len ( loop ) <NEWLINE> if ll > M : <NEWLINE> <INDENT> print ( S [ M ] + 1 ) <NEWLINE> <DEDENT> elif ll == M : <NEWLINE> <INDENT> print ( point + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( M - ll ) % l ] + 1 ) <NEWLINE> <DEDENT>
def cal_puddle ( puddle ) : <NEWLINE> <INDENT> depth = 0 <NEWLINE> score = 0 <NEWLINE> for s in puddle : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> score += depth + 0.5 <NEWLINE> depth += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> depth -= 1 <NEWLINE> score += depth + 0.5 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> score += depth <NEWLINE> <NL> <DEDENT> if depth == 0 : <NEWLINE> <INDENT> return int ( score ) <NEWLINE> <DEDENT> <DEDENT> return int ( score ) <NEWLINE> <NL> <DEDENT> def get_puddles ( diagram ) : <NEWLINE> <INDENT> hight = 0 <NEWLINE> top_list = [ ] <NEWLINE> in_puddle = True <NEWLINE> for index , s in enumerate ( diagram + <STRING> ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> in_puddle = True <NEWLINE> hight += 1 <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if in_puddle : <NEWLINE> <INDENT> in_puddle = False <NEWLINE> top_list . append ( [ hight , index ] ) <NEWLINE> <DEDENT> hight -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> puddles = [ ] <NEWLINE> prev_hight = 0 <NEWLINE> hight_list = [ h for h , i in top_list ] <NEWLINE> i = 0 <NEWLINE> while i < len ( top_list ) - 1 : <NEWLINE> <INDENT> cur_top = top_list [ i ] <NEWLINE> next_tops = list ( filter ( lambda top : cur_top [ 0 ] <= top [ 0 ] , top_list [ i + 1 : ] ) ) <NEWLINE> <COMMENT> <NL> if next_tops : <NEWLINE> <INDENT> next_top = next_tops [ 0 ] <NEWLINE> puddles . append ( ( cur_top [ 1 ] , next_top [ 1 ] ) ) <NEWLINE> i = top_list . index ( next_top ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur_top [ 0 ] -= 1 <NEWLINE> cur_top [ 1 ] += diagram [ cur_top [ 1 ] + 1 : ] . index ( <STRING> ) + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return puddles <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> diagram = input ( ) <NEWLINE> result = [ ] <NEWLINE> for s , e in get_puddles ( diagram ) : <NEWLINE> <INDENT> result . append ( cal_puddle ( diagram [ s : e ] ) ) <NEWLINE> <DEDENT> print ( sum ( result ) ) <NEWLINE> print ( str ( len ( result ) ) + <STRING> . join ( [ <STRING> + str ( i ) for i in result ] ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
w = int ( input ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 20 <NEWLINE> acc = - INF <NEWLINE> left = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> a = alst [ i ] <NEWLINE> if a == 0 : <NEWLINE> <INDENT> acc = INF <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> acc -= 1 <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> acc = min ( acc - 1 , - a ) <NEWLINE> <DEDENT> left . append ( acc ) <NEWLINE> <NL> <DEDENT> acc = - INF <NEWLINE> right = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> a = alst [ w - i - 1 ] <NEWLINE> if a == 0 : <NEWLINE> <INDENT> acc = INF <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> acc -= 1 <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> acc = min ( acc - 1 , - a ) <NEWLINE> <DEDENT> right . append ( acc ) <NEWLINE> <DEDENT> right . reverse ( ) <NEWLINE> <NL> print ( sum ( [ max ( 0 , min ( alst [ i ] , max ( left [ i ] , right [ i ] ) ) ) for i in range ( w ) ] ) ) <NEWLINE> <NL>
N = int ( input ( ) ) + 1 <NEWLINE> <NL> Answer = 0 <NEWLINE> <NL> def getGCD ( a , b , c ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> d = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 6 <NEWLINE> <NL> <DEDENT> surplus = a % c <NEWLINE> while surplus != 0 : <NEWLINE> <INDENT> a = int ( c ) <NEWLINE> c = int ( surplus ) <NEWLINE> surplus = a % c <NEWLINE> <DEDENT> surplus = b % c <NEWLINE> while surplus != 0 : <NEWLINE> <INDENT> b = int ( c ) <NEWLINE> c = int ( surplus ) <NEWLINE> surplus = b % c <NEWLINE> <DEDENT> return c * d <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> for k in range ( j , N ) : <NEWLINE> <INDENT> Answer += getGCD ( k , j , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Answer ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 9 + 7 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> T = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> T . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> ls = len ( S ) <NEWLINE> lt = len ( T ) <NEWLINE> ok = False <NEWLINE> <NL> if ls > 0 : <NEWLINE> <INDENT> if N == K : <NEWLINE> <INDENT> ok = lt % 2 == 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ok = K % 2 == 0 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> if not ok : <NEWLINE> <INDENT> A = sorted ( A , key = lambda x : abs ( x ) ) <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> S = sorted ( S ) <NEWLINE> T = sorted ( T , reverse = True ) <NEWLINE> if K % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> ans *= S . pop ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> p = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while len ( S ) >= 2 : <NEWLINE> <INDENT> x = S . pop ( ) <NEWLINE> y = S . pop ( ) <NEWLINE> p . append ( x * y ) <NEWLINE> <DEDENT> while len ( T ) >= 2 : <NEWLINE> <INDENT> x = T . pop ( ) <NEWLINE> y = T . pop ( ) <NEWLINE> p . append ( x * y ) <NEWLINE> <DEDENT> p = sorted ( p , reverse = True ) <NEWLINE> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans *= p [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> print ( ans % MOD ) <NEWLINE>
def primes ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> like = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> if ( is_prime [ i ] == False ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( is_prime [ int ( ( i + 1 ) / 2 ) ] == True ) : <NEWLINE> <INDENT> like [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return like <NEWLINE> <COMMENT> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> table = primes ( 10 ** 5 + 10 ) <NEWLINE> accum = [ 0 ] <NEWLINE> for i in range ( 1 , 10 ** 5 + 5 ) : <NEWLINE> <INDENT> if ( table [ i ] == True ) : <NEWLINE> <INDENT> accum . append ( accum [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> accum . append ( accum [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( accum [ r ] - accum [ l - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import heapify , heappop <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> SS = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss = S [ i ] <NEWLINE> SS . add ( ss ) <NEWLINE> for j in range ( i + 1 , min ( n , i + k ) ) : <NEWLINE> <INDENT> ss += S [ j ] <NEWLINE> SS . add ( ss ) <NEWLINE> <NL> <DEDENT> <DEDENT> SS = list ( SS ) <NEWLINE> heapify ( SS ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> res = heappop ( SS ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , W , M = NMI ( ) <NEWLINE> <NL> BOMB_HW = [ NLI ( ) for _ in range ( M ) ] <NEWLINE> <NL> bomb_h , bomb_w = zip ( * BOMB_HW ) <NEWLINE> <NL> dd = defaultdict ( bool ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> dd [ str ( bomb_h [ m ] ) + <STRING> + str ( bomb_w [ m ] ) ] = True <NEWLINE> <NL> <DEDENT> c_h = collections . Counter ( bomb_h ) <NEWLINE> c_w = collections . Counter ( bomb_w ) <NEWLINE> <NL> bomb_most_h = c_h . most_common ( ) [ 0 ] <NEWLINE> bomb_most_w = c_w . most_common ( ) [ 0 ] <NEWLINE> <NL> bh_destroy = bomb_most_h [ 1 ] <NEWLINE> bw_destroy = bomb_most_w [ 1 ] <NEWLINE> <NL> candidate_h = [ i [ 0 ] for i in c_h . items ( ) if i [ 1 ] == bh_destroy ] <NEWLINE> candidate_w = [ i [ 0 ] for i in c_w . items ( ) if i [ 1 ] == bw_destroy ] <NEWLINE> <NL> ans = bh_destroy + bw_destroy <NEWLINE> <NL> <NL> for bh in candidate_h : <NEWLINE> <INDENT> for bw in candidate_w : <NEWLINE> <INDENT> if not ( dd [ str ( bh ) + <STRING> + str ( bw ) ] ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 1000000000 + 7 <NEWLINE> <NL> z = 0 <NEWLINE> <NL> zz = ( ( N - K + 1 ) + N ) * K // 2 - ( 0 + ( K - 1 ) ) * K // 2 + 1 <NEWLINE> zz = zz % mod <NEWLINE> <NL> for x in range ( K + 1 , N + 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> z = ( z + zz ) % mod <NEWLINE> zz += ( N - x + 1 ) - ( x - 1 ) <NEWLINE> zz = zz % mod <NEWLINE> <COMMENT> <NL> <DEDENT> print ( z ) <NEWLINE> <NL>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> qn = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> S = <STRING> + S <NEWLINE> cnt = [ ] <NEWLINE> cnt . append ( 0 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( S [ i - 1 : i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> cnt . append ( cnt [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt . append ( cnt [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for q in qn : <NEWLINE> <INDENT> ans = cnt [ q [ 1 ] ] - cnt [ q [ 0 ] - 1 ] <NEWLINE> if S [ q [ 0 ] - 1 : q [ 0 ] + 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> to = [ False ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ a - 1 ] . append ( b - 1 ) <NEWLINE> to [ b - 1 ] = True <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> if lis [ v ] >= 0 : <NEWLINE> <INDENT> return lis [ v ] <NEWLINE> <DEDENT> if len ( edge [ v ] ) == 0 : <NEWLINE> <INDENT> lis [ v ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for u in edge [ v ] : <NEWLINE> <INDENT> ans = max ( ans , dfs ( u ) ) <NEWLINE> <DEDENT> lis [ v ] = ans + 1 <NEWLINE> return ans + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> lis = [ - 1 ] * N <NEWLINE> for r in range ( N ) : <NEWLINE> <INDENT> if to [ r ] == False : <NEWLINE> <INDENT> ans = max ( ans , dfs ( r ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from builtins import int , map , list , print , len <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = i ** 5 <NEWLINE> t . append ( x ) <NEWLINE> if x > 10 ** 12 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> d = { } <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> d [ t [ i ] - t [ j ] ] = [ i , j ] <NEWLINE> d [ t [ i ] + t [ j ] ] = [ i , - j ] <NEWLINE> d [ - t [ i ] - t [ j ] ] = [ - i , j ] <NEWLINE> d [ - t [ i ] + t [ j ] ] = [ - i , - j ] <NEWLINE> <DEDENT> <DEDENT> print ( d [ X ] [ 0 ] , d [ X ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( tmp [ 0 ] ) <NEWLINE> b . append ( tmp [ 1 ] ) <NEWLINE> <NL> <DEDENT> atta = [ 1 ] * n <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if height [ a [ j ] - 1 ] == height [ b [ j ] - 1 ] : <NEWLINE> <INDENT> atta [ a [ j ] - 1 ] = 0 <NEWLINE> atta [ b [ j ] - 1 ] = 0 <NEWLINE> <DEDENT> elif height [ a [ j ] - 1 ] < height [ b [ j ] - 1 ] : <NEWLINE> <INDENT> atta [ a [ j ] - 1 ] = 0 <NEWLINE> <DEDENT> elif height [ a [ j ] - 1 ] > height [ b [ j ] - 1 ] : <NEWLINE> <INDENT> atta [ b [ j ] - 1 ] = 0 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( atta . count ( 1 ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( N , B - 1 ) <NEWLINE> <NL> Ans = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <COMMENT> <NL> print ( Ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LRs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> <NL> dp = np . zeros ( N + 2 , dtype = int ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> dp [ 2 ] = - 1 <NEWLINE> <NL> atai = 0 <NEWLINE> for i in range ( 1 , N + 2 ) : <NEWLINE> <INDENT> atai += dp [ i ] <NEWLINE> for LR in LRs : <NEWLINE> <INDENT> if ( i + LR [ 0 ] <= N ) : <NEWLINE> <INDENT> dp [ i + LR [ 0 ] ] = ( dp [ i + LR [ 0 ] ] + atai ) % 998244353 <NEWLINE> <DEDENT> if ( i + LR [ 1 ] <= N ) : <NEWLINE> <INDENT> dp [ i + LR [ 1 ] + 1 ] = ( dp [ i + LR [ 1 ] + 1 ] - atai ) % 998244353 <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ruisekiwa = [ 0 ] <NEWLINE> <NL> for hoge in dp : <NEWLINE> <INDENT> ruisekiwa . append ( ruisekiwa [ - 1 ] + hoge ) <NEWLINE> <DEDENT> print ( ruisekiwa [ N + 1 ] % 998244353 ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> dct = defaultdict ( int ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> n = nums . pop ( ) <NEWLINE> dct [ n ] += 1 <NEWLINE> res += n <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if B in dct : <NEWLINE> <INDENT> n = dct . pop ( B ) <NEWLINE> res += ( C - B ) * n <NEWLINE> if C in dct : <NEWLINE> <INDENT> dct [ C ] += n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dct [ C ] = n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 998244353 <NEWLINE> dd = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <NEWLINE> ddn = [ ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , w , d = LI ( ) <NEWLINE> if n == 0 and w == 0 and d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ LI ( ) for _ in range ( n ) ] <NEWLINE> r = [ ( w , d ) ] <NEWLINE> for p , s in a : <NEWLINE> <INDENT> ww , dd = r . pop ( p - 1 ) <NEWLINE> u = ww + dd <NEWLINE> s %= u <NEWLINE> tr = [ ] <NEWLINE> if s < ww : <NEWLINE> <INDENT> tr . append ( ( s , dd ) ) <NEWLINE> tr . append ( ( ww - s , dd ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= ww <NEWLINE> tr . append ( ( ww , s ) ) <NEWLINE> tr . append ( ( ww , dd - s ) ) <NEWLINE> <DEDENT> r . extend ( sorted ( tr , key = lambda x : x [ 0 ] * x [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> rr . append ( <STRING> . join ( map ( lambda x : str ( x [ 0 ] * x [ 1 ] ) , sorted ( r , key = lambda x : x [ 0 ] * x [ 1 ] ) ) ) ) <NEWLINE> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> from collections import defaultdict <NEWLINE> l , r = s [ : n ] , s [ - 1 : - n - 1 : - 1 ] <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> a = { j for j in range ( n ) if ( i >> j ) % 2 } <NEWLINE> d [ ( <STRING> . join ( l [ p ] for p in sorted ( list ( a ) ) ) , <STRING> . join ( l [ o ] for o in range ( n ) if o not in a ) ) ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> a = { j for j in range ( n ) if ( i >> j ) % 2 } <NEWLINE> ans += d [ ( <STRING> . join ( r [ p ] for p in sorted ( list ( a ) ) ) , <STRING> . join ( r [ o ] for o in range ( n ) if o not in a ) ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n_entradas = int ( input ( ) ) <NEWLINE> contador = 0 <NEWLINE> vetor = [ ] <NEWLINE> while ( contador < n_entradas ) : <NEWLINE> <INDENT> situacao = str ( input ( ) ) <NEWLINE> vetor . append ( situacao ) <NEWLINE> contador = contador + 1 <NEWLINE> <DEDENT> print ( <STRING> , vetor . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , vetor . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , vetor . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , vetor . count ( <STRING> ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = abs ( abs ( y ) - abs ( x ) ) <NEWLINE> <NL> if ( x > 0 and y <= 0 ) or ( x >= 0 and y < 0 ) or ( x < 0 and y > 0 ) : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> d += 2 <NEWLINE> <NL> <DEDENT> print ( d ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif t < abs ( a - b ) / abs ( v - w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <STRING> <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - x - y <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = AB [ i ] <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> st = [ ] <NEWLINE> leftn = 0 <NEWLINE> <NL> def pushv ( s , x ) : <NEWLINE> <INDENT> tmp = s . pop ( ) <NEWLINE> tmpsum = 0 <NEWLINE> while tmp [ 0 ] != <STRING> : <NEWLINE> <INDENT> tmpsum += tmp [ 1 ] <NEWLINE> tmp = s . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmpsum += x - tmp [ 1 ] <NEWLINE> s . append ( ( <STRING> , tmpsum ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ x ] == <STRING> : <NEWLINE> <INDENT> st . append ( ( <STRING> , x ) ) <NEWLINE> leftn += 1 <NEWLINE> <DEDENT> elif s [ x ] == <STRING> : <NEWLINE> <INDENT> if leftn != 0 : <NEWLINE> <INDENT> pushv ( st , x ) <NEWLINE> leftn -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> st = [ x [ 1 ] for x in st if x [ 0 ] == <STRING> ] <NEWLINE> <NL> if len ( st ) != 0 : <NEWLINE> <INDENT> print ( sum ( st ) ) <NEWLINE> print ( len ( st ) , <STRING> . join ( [ str ( x ) for x in st ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def ChangeState ( Is_normal ) : <NEWLINE> <INDENT> if Is_normal == True : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Is_normal = True <NEWLINE> <NL> h = <STRING> <NEWLINE> t = [ ] <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> if len ( q ) == 1 : <NEWLINE> <INDENT> Is_normal = ChangeState ( Is_normal ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if q [ 2 ] == <STRING> : <NEWLINE> <INDENT> if Is_normal == True : <NEWLINE> <INDENT> h = h + q [ 4 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S + q [ 4 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Is_normal == True : <NEWLINE> <INDENT> S = S + q [ 4 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = h + q [ 4 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> h = h [ : : - 1 ] <NEWLINE> S = h + S <NEWLINE> if Is_normal == False : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> from itertools import groupby , accumulate <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = na ( ) <NEWLINE> s = ns ( ) <NEWLINE> a = list ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <DEDENT> gr = groupby ( s ) <NEWLINE> for key , group in gr : <NEWLINE> <INDENT> a . append ( len ( list ( group ) ) ) <NEWLINE> <DEDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> <DEDENT> acum = list ( accumulate ( a ) ) <NEWLINE> m = len ( acum ) <NEWLINE> l = 2 * k + 1 <NEWLINE> if m == 1 : <NEWLINE> <INDENT> print ( acum [ 0 ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> if l > m : <NEWLINE> <INDENT> print ( acum [ - 1 ] ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> ans = acum [ l - 1 ] <NEWLINE> for i in range ( 0 , m - l + 1 , 2 ) : <NEWLINE> <INDENT> ans = max ( ans , acum [ i + l - 1 ] - acum [ i - 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = input ( ) <NEWLINE> print ( <STRING> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list . sort ( ) <NEWLINE> a_max = a_list [ n - 1 ] <NEWLINE> temp_max = [ 1 , 0 ] <NEWLINE> bunbo = 1 <NEWLINE> bunshi = 1 <NEWLINE> center = int ( ( a_max + 1 ) / 2 ) <NEWLINE> a_set = set ( a_list ) <NEWLINE> diff_min = a_max <NEWLINE> ans = 0 <NEWLINE> for a in a_set : <NEWLINE> <INDENT> diff = abs ( a - center ) <NEWLINE> if diff_min > diff : <NEWLINE> <INDENT> diff_min = diff <NEWLINE> ans = a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a_max , ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = set ( input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> for ans in range ( N , 100000 ) : <NEWLINE> <INDENT> if all ( d not in D for d in str ( ans ) ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> raise AssertionError ( <STRING> ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> if S == 1 or S == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif S == 3 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 for _ in range ( S ) ] <NEWLINE> dp [ 0 ] = dp [ 1 ] = 0 <NEWLINE> dp [ 2 ] = dp [ 3 ] = 1 <NEWLINE> <NL> for i in range ( 3 , S ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 3 ] + dp [ i - 1 ] ) % mod <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT>
count = input ( ) <NEWLINE> Ss = [ ] <NEWLINE> Hs = [ ] <NEWLINE> Cs = [ ] <NEWLINE> Ds = [ ] <NEWLINE> for i in range ( int ( count ) ) : <NEWLINE> <INDENT> mark , num = input ( ) . split ( ) <NEWLINE> if mark is <STRING> : <NEWLINE> <INDENT> Ss . append ( num ) <NEWLINE> <DEDENT> elif mark is <STRING> : <NEWLINE> <INDENT> Hs . append ( num ) <NEWLINE> <DEDENT> elif mark is <STRING> : <NEWLINE> <INDENT> Cs . append ( num ) <NEWLINE> <DEDENT> elif mark is <STRING> : <NEWLINE> <INDENT> Ds . append ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not ( str ( i ) in Ss ) : <NEWLINE> <INDENT> print ( <STRING> . format ( str ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not ( str ( i ) in Hs ) : <NEWLINE> <INDENT> print ( <STRING> . format ( str ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not ( str ( i ) in Cs ) : <NEWLINE> <INDENT> print ( <STRING> . format ( str ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not ( str ( i ) in Ds ) : <NEWLINE> <INDENT> print ( <STRING> . format ( str ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S == T [ 0 : len ( S ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> min = 1000 <NEWLINE> pre_i = 0 <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if min > abs ( x - i ) : <NEWLINE> <INDENT> min = abs ( x - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pre_i = i <NEWLINE> <NL> <DEDENT> print ( pre_i ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 0 <NEWLINE> sum = 0 <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> sum += p [ i ] <NEWLINE> <DEDENT> max = sum <NEWLINE> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> sum += p [ k - 1 + i ] - p [ i - 1 ] <NEWLINE> if sum > max : <NEWLINE> <INDENT> max = sum <NEWLINE> <DEDENT> <DEDENT> ans = ( max + k ) * 0.5 <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , s = int ( input ( ) ) , input ( ) <NEWLINE> r , g , b = s . count ( <STRING> ) , s . count ( <STRING> ) , s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> v = { <STRING> , <STRING> , <STRING> } <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( n // 2 + 1 ) : <NEWLINE> <INDENT> if i + j + j < n : <NEWLINE> <INDENT> if v == { s [ i ] , s [ i + j ] , s [ i + j + j ] } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * 1000005 <NEWLINE> for x in a : <NEWLINE> <INDENT> if cnt [ x ] != 0 : <NEWLINE> <INDENT> cnt [ x ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x , 1000005 , x ) : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if cnt [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> B = [ 0 ] * n <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in B : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d = max ( a [ i + 1 ] - a [ i ] , d ) <NEWLINE> <DEDENT> d = max ( k + a [ 0 ] - a [ n - 1 ] , d ) <NEWLINE> print ( k - d ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> paths = [ set ( ) for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> paths [ a ] . add ( b ) <NEWLINE> paths [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> rooms = [ - 1 ] * N <NEWLINE> rooms [ 0 ] = 0 <NEWLINE> marks = [ - 1 ] * ( N - 1 ) <NEWLINE> key_rooms = [ [ 0 ] ] <NEWLINE> for step in range ( 1 , N ) : <NEWLINE> <INDENT> next_key_rooms = set ( ) <NEWLINE> for key_room in key_rooms [ - 1 ] : <NEWLINE> <INDENT> for else_room in paths [ key_room ] : <NEWLINE> <INDENT> if rooms [ else_room ] == - 1 : <NEWLINE> <INDENT> rooms [ else_room ] = step <NEWLINE> next_key_rooms . add ( else_room ) <NEWLINE> marks [ else_room - 1 ] = key_room <NEWLINE> <DEDENT> <DEDENT> <DEDENT> key_rooms . append ( next_key_rooms ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in marks : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> V = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> V . append ( [ int ( input ( ) ) ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> B . append ( [ 0 ] ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> B [ i ] [ 0 ] += A [ i ] [ j ] * V [ j ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( B [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= d : <NEWLINE> <INDENT> print ( d * 1 ) <NEWLINE> <DEDENT> elif a < d : <NEWLINE> <INDENT> if d - ( a + b ) <= 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif d - ( a + b + c ) <= 0 : <NEWLINE> <INDENT> print ( a + ( d - a - b ) * ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
def pow_mod ( n , k , m ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if k & 1 : <NEWLINE> <INDENT> return ( pow_mod ( n , k - 1 , m ) * n % m ) % m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( pow_mod ( n , k // 2 , m ) ** 2 ) % m <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> aaa . sort ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if aaa [ i ] != aaa [ i + 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( pow_mod ( 2 , ( n // 2 ) , mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> if aaa [ i ] != aaa [ i + 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( pow_mod ( 2 , ( ( n - 1 ) // 2 ) , mod ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> import queue <NEWLINE> from collections import deque , defaultdict <NEWLINE> import heapq <NEWLINE> from sys import stdin , setrecursionlimit <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ipt = stdin . readline <NEWLINE> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , s = map ( int , ipt ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in ipt ( ) . split ( ) ] <NEWLINE> mod = 998244353 <NEWLINE> two = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> two [ i + 1 ] = two [ i ] * 2 % mod <NEWLINE> <DEDENT> dp = np . zeros ( 3010 , dtype = int ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> ndp = dp * 2 <NEWLINE> ndp [ ai : ] += dp [ : - ai ] <NEWLINE> ndp %= mod <NEWLINE> dp = ndp <NEWLINE> <DEDENT> print ( dp [ s ] ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def checkRGB ( a , b , c ) : <NEWLINE> <INDENT> if a == b or b == c or c == a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if N < 4 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sum1 = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> sum2 = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> left = S [ i ] <NEWLINE> for j in range ( i + 1 , ( N + i ) // 2 + ( N + i ) % 2 ) : <NEWLINE> <INDENT> center = S [ j ] <NEWLINE> right = S [ 2 * j - i ] <NEWLINE> if checkRGB ( left , center , right ) : <NEWLINE> <INDENT> sum2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum1 - sum2 ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m , l = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ [ 0 for _ in range ( l ) ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( a ) for a in input ( ) . split ( <STRING> ) ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( a ) for a in input ( ) . split ( <STRING> ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> s += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> C [ i ] [ j ] = s <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( a ) for a in C [ x ] ] ) ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> <NL> def abc170c_forbidden_list ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> return <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> idx = bisect . bisect_left ( p , x - i ) <NEWLINE> if idx >= n or p [ idx ] != x - i : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> return <NEWLINE> <DEDENT> idx = bisect . bisect_left ( p , x + i ) <NEWLINE> if idx >= n or p [ idx ] != x + i : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> abc170c_forbidden_list ( ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> r = c . count ( <STRING> ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> rs = c [ : r ] <NEWLINE> rsw = rs . count ( <STRING> ) <NEWLINE> a = rsw <NEWLINE> <NL> w = list ( reversed ( c ) ) . index ( <STRING> ) <NEWLINE> w = ( N - 1 ) - w <NEWLINE> ws = c [ : w ] <NEWLINE> b = ws . count ( <STRING> ) <NEWLINE> print ( min ( a , b ) ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> if len ( n ) < 3 : <NEWLINE> <INDENT> print ( 1000 - int ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value = n [ - 3 ] + n [ - 2 ] + n [ - 1 ] <NEWLINE> <COMMENT> <NL> value_int = int ( value ) <NEWLINE> if value == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - value_int ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> N , M , P = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M == P : break <NEWLINE> divSum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> temp = int ( input ( ) ) <NEWLINE> divSum += temp * 100 <NEWLINE> if i == M - 1 : <NEWLINE> <INDENT> numWin = temp <NEWLINE> <DEDENT> <DEDENT> divSum = int ( divSum * ( 100 - P ) / 100 ) <NEWLINE> if numWin != 0 : <NEWLINE> <INDENT> dividents = math . floor ( divSum / numWin ) <NEWLINE> <DEDENT> else : dividents = 0 <NEWLINE> print ( dividents ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> r = [ ] <NEWLINE> l = [ ] <NEWLINE> <NL> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> r . append ( i + j ) <NEWLINE> l . append ( i - j ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> b = Counter ( r ) <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += b . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for _ in range ( n ) ] <NEWLINE> adj = [ - 1 for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> root [ r - 1 ] . append ( c - 1 ) <NEWLINE> root [ c - 1 ] . append ( r - 1 ) <NEWLINE> <NL> <DEDENT> explor = deque ( ) <NEWLINE> explor . append ( 0 ) <NEWLINE> <NL> while explor : <NEWLINE> <INDENT> tmp = explor . popleft ( ) <NEWLINE> for i in root [ tmp ] : <NEWLINE> <INDENT> if adj [ i ] == - 1 : <NEWLINE> <INDENT> adj [ i ] = tmp <NEWLINE> explor . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in adj [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def h1 ( key ) : <NEWLINE> <INDENT> return key % M <NEWLINE> <NL> <DEDENT> def h2 ( key ) : <NEWLINE> <INDENT> return 1 + key % ( M - 1 ) <NEWLINE> <NL> <DEDENT> def H ( key , i ) : <NEWLINE> <INDENT> return ( h1 ( key ) + i * h2 ( key ) ) % M <NEWLINE> <NL> <DEDENT> def my_insert ( dic , key ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> j = H ( key , i ) <NEWLINE> if dic [ j ] is None : <NEWLINE> <INDENT> dic [ j ] = key <NEWLINE> return j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def my_search ( dic , key ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> j = H ( key , i ) <NEWLINE> if dic [ j ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif dic [ j ] is None or i >= M : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def str2int ( s ) : <NEWLINE> <INDENT> res = s <NEWLINE> <NL> res = res . replace ( <STRING> , <STRING> ) <NEWLINE> res = res . replace ( <STRING> , <STRING> ) <NEWLINE> res = res . replace ( <STRING> , <STRING> ) <NEWLINE> res = res . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> return int ( res ) <NEWLINE> <NL> <DEDENT> M = 1000003 <NEWLINE> dic = [ None ] * M <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> for k in range ( n ) : <NEWLINE> <INDENT> cmd , s = sys . stdin . readline ( ) . split ( ) <NEWLINE> <NL> if cmd == <STRING> : <NEWLINE> <INDENT> my_insert ( dic , str2int ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if my_search ( dic , str2int ( s ) ) else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> index = list ( range ( 1 , N + 1 ) ) <NEWLINE> <NL> R = [ index [ i ] - A [ i ] for i in range ( N ) ] <NEWLINE> L = [ index [ j ] + A [ j ] for j in range ( N ) ] <NEWLINE> <NL> R_dict = collections . Counter ( R ) <NEWLINE> L_dict = collections . Counter ( L ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in R_dict . keys ( ) & L_dict . keys ( ) : <NEWLINE> <INDENT> ans += R_dict [ i ] * L_dict [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( x // 3600 , x // 60 % 60 , x % 60 , sep = <STRING> ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> f = [ True ] * N <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if H [ A [ j ] - 1 ] <= H [ B [ j ] - 1 ] : <NEWLINE> <INDENT> f [ A [ j ] - 1 ] = False <NEWLINE> <DEDENT> if H [ B [ j ] - 1 ] <= H [ A [ j ] - 1 ] : <NEWLINE> <INDENT> f [ B [ j ] - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> for i in f : <NEWLINE> <INDENT> if i : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L0 = 2 <NEWLINE> L1 = 1 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( N - 1 ) : <NEWLINE> <INDENT> L = L0 + L1 <NEWLINE> L0 = L1 <NEWLINE> L1 = L <NEWLINE> <DEDENT> print ( L ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , X , Y = map ( int , readline ( ) . split ( ) ) <NEWLINE> X -= 1 <NEWLINE> Y -= 1 <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> val = min ( abs ( i - j ) , abs ( i - X ) + 1 + abs ( j - Y ) , abs ( i - Y ) + 1 + abs ( j - X ) ) <NEWLINE> ans [ val ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> from collections import Counter <NEWLINE> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> * A , = zip ( * [ iter ( A ) ] * 2 ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def modpow ( a , n , mod ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> ret = ret * a % mod <NEWLINE> <DEDENT> a = a * a % mod <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> col = [ ] <NEWLINE> row = [ ] <NEWLINE> zero = 0 <NEWLINE> for a , b in A : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> col . append ( ( 1 , 0 ) ) <NEWLINE> continue <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> row . append ( ( 1 , 0 ) ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> <NL> <DEDENT> if a < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <NL> <DEDENT> if b > 0 : <NEWLINE> <INDENT> col . append ( ( a , b ) ) <NEWLINE> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> row . append ( ( - b , a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> C = Counter ( col ) <NEWLINE> D = Counter ( row ) <NEWLINE> S = set ( col ) | set ( row ) <NEWLINE> <NL> ans = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in C : <NEWLINE> <INDENT> if s in D : <NEWLINE> <INDENT> mul = modpow ( 2 , C [ s ] , mod ) + modpow ( 2 , D [ s ] , mod ) - 1 <NEWLINE> mul %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul = modpow ( 2 , C [ s ] , mod ) <NEWLINE> <DEDENT> <DEDENT> elif s in D : <NEWLINE> <INDENT> mul = modpow ( 2 , D [ s ] , mod ) <NEWLINE> <NL> <DEDENT> ans *= mul <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> ans -= 1 <NEWLINE> ans += zero <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> MOD = 2019 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> dp = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> ex = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> dp [ i + 1 ] = ( int ( S [ - 1 - i ] ) * ex + dp [ i ] ) % MOD <NEWLINE> ex *= 10 <NEWLINE> ex %= MOD <NEWLINE> <DEDENT> d = defaultdict ( int ) <NEWLINE> for i in range ( len ( S ) + 1 ) : <NEWLINE> <INDENT> d [ dp [ i ] ] += 1 <NEWLINE> <DEDENT> output = 0 <NEWLINE> for i in d . keys ( ) : <NEWLINE> <INDENT> output += ( d [ i ] * ( d [ i ] - 1 ) // 2 ) <NEWLINE> <DEDENT> print ( output ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if m - 2 * n >= 0 : <NEWLINE> <INDENT> m -= 2 * n <NEWLINE> ans = n <NEWLINE> n = 0 <NEWLINE> <NL> if ( m - 2 * n ) % 4 == 0 : <NEWLINE> <INDENT> tmp = ( m - 2 * n ) // 4 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( m - 2 * n ) // 4 + 1 <NEWLINE> <NL> <DEDENT> ans += ( m - 2 * tmp ) // 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = m // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , idx , degree , children = None ) : <NEWLINE> <INDENT> self . id = idx <NEWLINE> self . parent = - 1 <COMMENT> <NEWLINE> self . depth = 0 <COMMENT> <NEWLINE> self . type = None <COMMENT> <NEWLINE> self . children = children <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> data = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( n ) ] <NEWLINE> node_list = [ None for i in range ( n ) ] <NEWLINE> <NL> for data_row in data : <NEWLINE> <INDENT> idx , degree , * children = data_row <NEWLINE> node = Node ( idx , degree , children ) <NEWLINE> node_list [ idx ] = node <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for node in node_list : <NEWLINE> <INDENT> i = node . id <NEWLINE> if node . children : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> for child in node . children : <NEWLINE> <INDENT> node_list [ child ] . parent = i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i , node in enumerate ( node_list ) : <NEWLINE> <INDENT> depth = 0 <NEWLINE> parent = node . parent <NEWLINE> <COMMENT> <NL> if parent == - 1 : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <DEDENT> while parent != - 1 : <NEWLINE> <INDENT> parent = node_list [ parent ] . parent <NEWLINE> depth += 1 <NEWLINE> <DEDENT> node . depth = depth <NEWLINE> <NL> <DEDENT> for node in node_list : <NEWLINE> <INDENT> print ( <STRING> . format ( node . id , node . parent , node . depth , node . type , node . children ) ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> sa = x // d <NEWLINE> ans = x <NEWLINE> pbk , mbk = 0 , 0 <NEWLINE> bk1 , bk2 , bk3 = 1 , 1 , 1 <NEWLINE> mansbk , pansbk = 0 , 0 <NEWLINE> if sa >= k : <NEWLINE> <INDENT> ans = x - d * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x - d * sa <NEWLINE> k = k - sa <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> mansbk = abs ( ans - d ) <NEWLINE> pansbk = abs ( ans + d ) <NEWLINE> if mansbk != pansbk : <NEWLINE> <INDENT> ans = min ( mansbk , pansbk ) <NEWLINE> if bk3 != 1 : <NEWLINE> <INDENT> bk1 = min ( mansbk , pansbk ) <NEWLINE> bk2 = max ( mansbk , pansbk ) <NEWLINE> ans = mbk if ( k - i ) % 2 == 0 else bk1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bk3 = max ( mansbk , pansbk ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 if ( k - i ) % 2 == 0 else d <NEWLINE> break <NEWLINE> <DEDENT> pbk = max ( mansbk , pansbk ) <NEWLINE> mbk = min ( mansbk , pansbk ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import time <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> SegTree = [ 0 for i in range ( 4 * N ) ] <NEWLINE> <NL> def modify ( i , left , right , value , pos = - 1 ) : <NEWLINE> <INDENT> global SegTree <NEWLINE> if left == right : <NEWLINE> <INDENT> if pos != - 1 : <NEWLINE> <INDENT> SegTree [ i ] = value <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> SegTree [ i ] = 2147483647 <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if pos == - 1 or pos <= mid : <NEWLINE> <INDENT> modify ( i * 2 , left , mid , value , pos ) <NEWLINE> <DEDENT> if pos == - 1 or pos > mid : <NEWLINE> <INDENT> modify ( i * 2 + 1 , mid + 1 , right , value , pos ) <NEWLINE> <NL> <DEDENT> SegTree [ i ] = min ( SegTree [ i * 2 ] , SegTree [ i * 2 + 1 ] ) <NEWLINE> <NL> <DEDENT> def query_min ( i , L , R , left , right ) : <NEWLINE> <INDENT> if right < L or R < left : <NEWLINE> <INDENT> return 2147483647 <NEWLINE> <DEDENT> if left <= L and R <= right : <NEWLINE> <INDENT> return SegTree [ i ] <NEWLINE> <DEDENT> mid = int ( ( L + R ) / 2 ) <NEWLINE> return min ( query_min ( 2 * i , L , mid , left , right ) , <NEWLINE> <INDENT> query_min ( 2 * i + 1 , mid + 1 , R , left , right ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> modify ( i = 1 , left = 0 , right = N - 1 , value = 0 , pos = - 1 ) <COMMENT> <NEWLINE> <NL> for querys in range ( Q ) : <NEWLINE> <INDENT> t , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> modify ( i = 1 , left = 0 , right = N - 1 , pos = a , value = b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( query_min ( i = 1 , L = 0 , R = N - 1 , left = a , right = b ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] ; b = [ 0 ] ; ans = 0 ; j = m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> current = 0 <NEWLINE> a = [ 0 ] * 2019 <NEWLINE> a [ 0 ] = 1 <NEWLINE> digit = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> current += int ( i ) * digit <NEWLINE> digit *= 10 <NEWLINE> digit %= 2019 <NEWLINE> current %= 2019 <NEWLINE> a [ current ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> total = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if i + ( 2 * j ) >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i ] != s [ i + 2 * j ] : <NEWLINE> <INDENT> total += - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mini = float ( <STRING> ) <NEWLINE> <NL> cumsum = list ( itertools . accumulate ( A ) ) <NEWLINE> A . reverse ( ) <NEWLINE> rev = list ( itertools . accumulate ( A ) ) <NEWLINE> rev . reverse ( ) <NEWLINE> cumsum . pop ( ) <NEWLINE> rev . pop ( 0 ) <NEWLINE> <NL> for i , j in zip ( cumsum , rev ) : <NEWLINE> <INDENT> if abs ( i - j ) < mini : <NEWLINE> <INDENT> mini = abs ( i - j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mini ) <NEWLINE>
class tree : <NEWLINE> <INDENT> def __init__ ( self , name , parent ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . parent = parent <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> trees = { str ( i ) : tree ( str ( i ) , <STRING> ) for i in range ( n ) } <NEWLINE> child = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = [ i for i in input ( ) . split ( ) ] <NEWLINE> p = s [ 0 ] <NEWLINE> child [ p ] = s [ 2 : ] <NEWLINE> s_t = s [ 2 : ] <NEWLINE> for j in range ( len ( s_t ) ) : <NEWLINE> <INDENT> trees [ s_t [ j ] ] = tree ( s_t [ j ] , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getDepth ( u ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> while trees [ u ] . parent != <STRING> : <NEWLINE> <INDENT> u = trees [ u ] . parent <NEWLINE> d += 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def getChildren ( u ) : <NEWLINE> <INDENT> c = [ ] <NEWLINE> for i in trees . values ( ) : <NEWLINE> <INDENT> if i . parent == u : <NEWLINE> <INDENT> c . append ( i . name ) <NEWLINE> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <NL> <INDENT> par = trees [ str ( i ) ] . parent <NEWLINE> dep = getDepth ( str ( i ) ) <NEWLINE> ch = [ int ( i ) for i in child [ str ( i ) ] ] <NEWLINE> <NL> if par == <STRING> : sit = <STRING> <NEWLINE> elif len ( ch ) != 0 : sit = <STRING> <NEWLINE> else : sit = <STRING> <NEWLINE> <NL> print ( <STRING> . format ( i , par , dep , sit , ch ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def euler ( a ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> res = a <NEWLINE> <COMMENT> <NL> while i * i <= a : <NEWLINE> <INDENT> if a % i == 0 : <NEWLINE> <INDENT> res = res - res // i <NEWLINE> while a % i == 0 : <NEWLINE> <INDENT> a //= i <NEWLINE> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if a != 1 : <NEWLINE> <INDENT> res = res - res // a <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> <NL> <NL> print ( euler ( x ) ) <NEWLINE>
m = [ ] <NEWLINE> <NL> def walk ( i , j ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> stack . append ( ( i , j ) ) <NEWLINE> while stack : <NEWLINE> <INDENT> p = stack . pop ( ) <NEWLINE> pi = p [ 0 ] <NEWLINE> pj = p [ 1 ] <NEWLINE> m [ pi ] [ pj ] = 0 <NEWLINE> for k in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for l in range ( - 1 , 2 ) : <NEWLINE> <INDENT> a = pi + k <NEWLINE> b = pj + l <NEWLINE> if a < 0 or b < 0 or a >= len ( m ) or b >= len ( m [ a ] ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif m [ a ] [ b ] == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 : break <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> m . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( m ) ) : <NEWLINE> <INDENT> for j in range ( len ( m [ i ] ) ) : <NEWLINE> <INDENT> if m [ i ] [ j ] == 1 : <NEWLINE> <INDENT> walk ( i , j ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> m = [ ] <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 5 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def calc_counts ( n , edges ) : <NEWLINE> <INDENT> counts = [ 0 ] * n <NEWLINE> seen = [ False ] * n <NEWLINE> dfs ( 0 , edges , seen , counts ) <NEWLINE> return counts <NEWLINE> <NL> <NL> <DEDENT> def dfs ( node , edges , seen , counts ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> seen [ node ] = True <NEWLINE> for to in edges [ node ] : <NEWLINE> <INDENT> if seen [ to ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count += dfs ( to , edges , seen , counts ) <NEWLINE> <DEDENT> counts [ node ] = count <NEWLINE> return count <NEWLINE> <NL> <NL> <DEDENT> def calc_blank ( node , counts : list , edges , all , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> n = len ( counts ) <NEWLINE> paths = edges [ node ] <NEWLINE> if len ( paths ) <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> base = counts [ node ] <NEWLINE> result = all - 1 <NEWLINE> for v in paths : <NEWLINE> <INDENT> count = counts [ v ] <NEWLINE> if count > base : <NEWLINE> <INDENT> count = n - base <NEWLINE> <DEDENT> result -= pow ( 2 , count , mod ) - 1 <NEWLINE> result %= mod <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> counts = calc_counts ( n , edges ) <NEWLINE> all = pow ( 2 , n - 1 , mod ) <NEWLINE> blanks = 0 <NEWLINE> for node in range ( n ) : <NEWLINE> <INDENT> blank = calc_blank ( node , counts , edges , all ) <NEWLINE> blanks += blank <NEWLINE> blanks %= mod <NEWLINE> <NL> <DEDENT> inv_denominator = pow ( pow ( 2 , n , mod ) , mod - 2 , mod ) <NEWLINE> ans = blanks * inv_denominator % mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> src = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> es = [ [ ] for i in range ( n ) ] <NEWLINE> for x , y in src : <NEWLINE> <INDENT> x , y = x - 1 , y - 1 <NEWLINE> es [ x ] . append ( y ) <NEWLINE> es [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> INF = float ( <STRING> ) <NEWLINE> ds = [ INF ] * n <NEWLINE> ans = [ - 1 ] * ( n ) <NEWLINE> <NL> def dijkstra ( start , dists ) : <NEWLINE> <INDENT> dists [ start ] = 0 <NEWLINE> hq = [ ( 0 , start ) ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> while hq : <NEWLINE> <INDENT> dist , v = heapq . heappop ( hq ) <NEWLINE> for to in es [ v ] : <NEWLINE> <INDENT> if dist + 1 >= dists [ to ] : continue <NEWLINE> dists [ to ] = dist + 1 <NEWLINE> ans [ to ] = v + 1 <NEWLINE> heapq . heappush ( hq , ( dist + 1 , to ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dijkstra ( 0 , ds ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> ans = A [ 0 ] <NEWLINE> isOver = False <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans_size = int ( math . log10 ( ans ) + 1 ) <NEWLINE> if ans_size >= 19 and ans - ( 10 ** 18 ) >= 1 : <NEWLINE> <INDENT> isOver = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if isOver : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( make_divisors ( x ) ) ) : <NEWLINE> <INDENT> for j in range ( 130 ) : <NEWLINE> <INDENT> if j ** 5 - ( j - make_divisors ( x ) [ i ] ) ** 5 == x : <NEWLINE> <INDENT> print ( j , j - make_divisors ( x ) [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( h ) ] <NEWLINE> SW = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> SH = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( w - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> cnt += S [ i ] [ j ] <NEWLINE> SW [ i ] [ j ] = cnt <NEWLINE> <DEDENT> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( h - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> cnt += S [ i ] [ j ] <NEWLINE> SH [ i ] [ j ] = cnt <NEWLINE> <DEDENT> <DEDENT> memo = { } <NEWLINE> def dfs ( x , y ) : <NEWLINE> <INDENT> if ( x , y ) in memo : <NEWLINE> <INDENT> return memo [ x , y ] <NEWLINE> <DEDENT> if x == w or y == h : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if ( x + y ) % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> res = max ( dfs ( x + 1 , y ) - SH [ y ] [ x ] , dfs ( x , y + 1 ) + SW [ y ] [ x ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> res = min ( dfs ( x + 1 , y ) - SH [ y ] [ x ] , dfs ( x , y + 1 ) + SW [ y ] [ x ] ) <NEWLINE> <DEDENT> memo [ x , y ] = res <NEWLINE> return res <NEWLINE> <DEDENT> print ( abs ( dfs ( 0 , 0 ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A2 = list ( map ( lambda x : x ** 2 , A ) ) <NEWLINE> <NL> sumA = sum ( A ) <NEWLINE> sumA2 = sum ( A2 ) <NEWLINE> <NL> ans = ( ( ( sumA ** 2 ) - sumA2 ) // 2 ) % 1000000007 <NEWLINE> <NL> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> S = str ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> <COMMENT> <NL> smod = [ 0 ] <NEWLINE> tmod = 0 <NEWLINE> keta = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> temp = tmod + int ( S [ ( N - 1 ) - i ] ) * keta <NEWLINE> <COMMENT> <NL> tmod = temp % 2019 <NEWLINE> smod . append ( tmod ) <NEWLINE> keta = keta * 10 % 2019 <NEWLINE> <NL> <NL> <DEDENT> cmod = Counter ( smod ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in cmod . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> n = N - 1 <NEWLINE> res = n * ( n + 1 ) // 2 <NEWLINE> print ( res ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( pi * r ** 2 , 2 * pi * r ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> d = n // 2 - 1 <NEWLINE> c = 0 <NEWLINE> i = 1 <NEWLINE> while ( d > 0 ) : <NEWLINE> <INDENT> print ( i , i + d ) <NEWLINE> d -= 2 <NEWLINE> i += 1 <NEWLINE> c += 1 <NEWLINE> if ( c == m ) : exit ( ) <NEWLINE> <DEDENT> d = n // 2 - 2 <NEWLINE> i = n // 2 + 1 <NEWLINE> while ( d > 0 ) : <NEWLINE> <INDENT> print ( i , i + d ) <NEWLINE> d -= 2 <NEWLINE> i += 1 <NEWLINE> c += 1 <NEWLINE> if ( c == m ) : exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( i + 1 , n - i ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> power = power * i % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( power ) <NEWLINE>
n , s = open ( 0 ) <NEWLINE> r , g , b = map ( s . count , <STRING> ) <NEWLINE> e = enumerate <NEWLINE> print ( r * g * b - sum ( f != g != s [ i + j ] != f for i , f in e ( s ) for j , g in e ( s [ i : - 1 : 2 ] ) ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] <= A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> vl = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , input ( ) . split ( ) ) <NEWLINE> vl [ r - 1 ] [ c - 1 ] = v <NEWLINE> <DEDENT> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> dp = np . zeros ( ( R + 1 , C + 1 , 4 ) , np . int64 ) <NEWLINE> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j - 1 ] [ k ] , dp [ i - 1 ] [ j ] [ 3 ] ) <NEWLINE> <DEDENT> for k in range ( 3 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j ] [ k - 1 ] + vl [ i - 1 ] [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ R ] [ C ] [ 3 ] <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = numbers [ n - 1 ] <NEWLINE> i = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if numbers [ j ] <= x : <NEWLINE> <INDENT> numbers [ i ] , numbers [ j ] = numbers [ j ] , numbers [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> [ print ( numbers [ j ] if j != i - 1 else <STRING> + str ( numbers [ j ] ) + <STRING> , end = <STRING> if j != n - 1 else <STRING> ) for j in range ( n ) ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for i in g [ n ] : <NEWLINE> <INDENT> if H [ n - 1 ] <= H [ i - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def isCLKWISE ( ph ) : <NEWLINE> <INDENT> a = [ ph [ - 1 ] [ 0 ] - ph [ - 3 ] [ 0 ] , ph [ - 1 ] [ 1 ] - ph [ - 3 ] [ 1 ] ] <NEWLINE> b = [ ph [ - 2 ] [ 0 ] - ph [ - 3 ] [ 0 ] , ph [ - 2 ] [ 1 ] - ph [ - 3 ] [ 1 ] ] <NEWLINE> crs = a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] <NEWLINE> if crs < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def ConvexHullScan ( P ) : <NEWLINE> <INDENT> P = sorted ( P ) <NEWLINE> phU = [ P [ 0 ] , P [ 1 ] ] <NEWLINE> for p in P [ 2 : ] : <NEWLINE> <INDENT> phU . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phU ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del phU [ - 2 ] <NEWLINE> if len ( phU ) == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> phL = [ P [ - 1 ] , P [ - 2 ] ] <NEWLINE> for p in P [ - 3 : : - 1 ] : <NEWLINE> <INDENT> phL . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phL ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del phL [ - 2 ] <NEWLINE> if len ( phL ) == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ph = phU + phL [ 1 : - 1 ] <NEWLINE> return ph <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> P += [ [ int ( x ) for x in input ( ) . split ( ) ] ] <NEWLINE> <NL> <DEDENT> Q = ConvexHullScan ( P ) <NEWLINE> Q . reverse ( ) <NEWLINE> print ( len ( Q ) ) <NEWLINE> idx = min ( [ [ x [ 1 ] [ 1 ] , x [ 1 ] [ 0 ] , x [ 0 ] ] for x in enumerate ( Q ) ] ) [ 2 ] <NEWLINE> R = Q [ idx : ] + Q [ : idx ] <NEWLINE> for r in R : <NEWLINE> <INDENT> print ( r [ 0 ] , r [ 1 ] ) <NEWLINE> <DEDENT>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> gcd_sum = [ 0 ] * 201 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd_sum [ i ] += gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> q = gcd ( a , b ) <NEWLINE> ans += gcd_sum [ q ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = N % K <NEWLINE> m = min ( m , abs ( K - m ) ) <NEWLINE> print ( m ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> zero = 0 <NEWLINE> d = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> <COMMENT> <NL> if b < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> if b == 0 and a == - 1 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <NL> <DEDENT> if a > 0 : <NEWLINE> <INDENT> if ( a , b ) in d : <NEWLINE> <INDENT> d [ ( a , b ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( a , b ) ] = [ 1 , 0 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( b , - a ) in d : <NEWLINE> <INDENT> d [ ( b , - a ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( b , - a ) ] = [ 0 , 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> for ( a , b ) , ( k , l ) in d . items ( ) : <NEWLINE> <INDENT> ans *= ( pow ( 2 , k , MOD ) - 1 ) + ( pow ( 2 , l , MOD ) - 1 ) + 1 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans += zero <NEWLINE> ans -= 1 <NEWLINE> print ( ans % MOD ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def f2 ( n ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> if i * i == n : <NEWLINE> <INDENT> e -= 1 <NEWLINE> <DEDENT> elif n % i == 0 : <NEWLINE> <INDENT> e -= 1 <NEWLINE> <DEDENT> e += n // i <NEWLINE> d += e <NEWLINE> <NL> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> print ( f2 ( int ( input ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> K2 = K <NEWLINE> <COMMENT> <NL> if X >= 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> h = min ( K , int ( a * X / D ) ) <NEWLINE> K = K - h <NEWLINE> X = X - a * D * h <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> flg = 0 <NEWLINE> minx = abs ( X ) <NEWLINE> Xnow = X <NEWLINE> Xprepre = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> Xprepre = Xpre <NEWLINE> <DEDENT> Xpre = Xnow <COMMENT> <NEWLINE> X1 = Xnow - D <NEWLINE> X2 = Xnow + D <NEWLINE> if abs ( X1 ) < abs ( X2 ) : <NEWLINE> <INDENT> Xnow = X1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Xnow = X2 <NEWLINE> <COMMENT> <NL> <DEDENT> if Xprepre == Xnow : <NEWLINE> <INDENT> flg = 1 <NEWLINE> if ( K - i + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( Xnow ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( Xpre ) ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> print ( abs ( Xnow ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import copy <NEWLINE> def py ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def pn ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> def iin ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> return x <NEWLINE> <NL> <DEDENT> neko = 0 <NEWLINE> nya = 0 <NEWLINE> nuko = 0 <NEWLINE> <NL> a = [ ] <NEWLINE> n = iin ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( iin ( ) ) <NEWLINE> if neko < a [ i ] : <NEWLINE> <INDENT> neko = a [ i ] <NEWLINE> <DEDENT> <DEDENT> b = copy . copy ( a ) <NEWLINE> a . remove ( neko ) <NEWLINE> nya = max ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] == neko : <NEWLINE> <INDENT> print ( nya ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( neko ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> sum = sum ( a ) <NEWLINE> <NL> count = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if count [ b ] != 0 : <NEWLINE> <INDENT> sum += ( c - b ) * count [ b ] <NEWLINE> count [ c ] += count [ b ] <NEWLINE> count [ b ] = 0 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
import re <NEWLINE> pattern = re . compile ( <STRING> ) <NEWLINE> S = input ( ) <NEWLINE> print ( len ( max ( re . findall ( pattern , S ) , key = len , default = <STRING> ) ) ) <NEWLINE>
class Tree : <NEWLINE> <INDENT> nodes = [ ] <NEWLINE> def __init__ ( self , root = None ) : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT> def insert ( self , label , children = [ ] ) : <NEWLINE> <INDENT> if children != [ ] : <NEWLINE> <INDENT> for i in children : <NEWLINE> <INDENT> self . nodes [ label ] . children . append ( self . nodes [ i ] ) <NEWLINE> self . nodes [ i ] . parent = self . nodes [ label ] <NEWLINE> self . nodes [ i ] . type_ = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def depth ( self , node ) : <NEWLINE> <INDENT> if node . children == [ ] : <NEWLINE> <INDENT> node . type_ = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in node . children : <NEWLINE> <INDENT> i . depth = node . depth + 1 <NEWLINE> self . depth ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , label , children = [ ] ) : <NEWLINE> <INDENT> self . label = label <NEWLINE> self . type_ = <STRING> <NEWLINE> self . depth = 0 <NEWLINE> self . parent = - 1 <NEWLINE> self . children = [ ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tree . nodes . append ( Node ( i ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> children = [ ] <NEWLINE> label , num , * children = map ( int , input ( ) . split ( ) ) <NEWLINE> tree . insert ( label , children ) <NEWLINE> <DEDENT> for i in tree . nodes : <NEWLINE> <INDENT> if i . parent == - 1 : <NEWLINE> <INDENT> tree . depth ( i ) <NEWLINE> None <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> tree . nodes [ 0 ] . type_ = <STRING> <NEWLINE> <DEDENT> for i in tree . nodes : <NEWLINE> <INDENT> print ( <STRING> . format ( i . label , i . parent if i . parent == - 1 else i . parent . label , i . depth , i . type_ ) , end = <STRING> ) <NEWLINE> print ( [ i . label for i in i . children ] ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> <NL> class Combination : <NEWLINE> <INDENT> def __init__ ( self , n , mod ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . mod = mod <NEWLINE> <NL> self . f = self . _get_f ( ) <NEWLINE> self . fi = self . _get_fi ( ) <NEWLINE> <NL> <DEDENT> def __call__ ( self , k ) : <NEWLINE> <INDENT> if not 0 <= k <= self . n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = self . f [ self . n ] <NEWLINE> deninv = ( self . fi [ k ] * self . fi [ self . n - k ] ) % self . mod <NEWLINE> return ( num * deninv ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def _get_f ( self ) : <NEWLINE> <INDENT> f = 1 <NEWLINE> lf = [ 1 ] <NEWLINE> <NL> for i in range ( 1 , self . n + 1 ) : <NEWLINE> <INDENT> f = ( f * i ) % self . mod <NEWLINE> lf . append ( f ) <NEWLINE> <NL> <DEDENT> return lf <NEWLINE> <NL> <DEDENT> def _get_fi ( self ) : <NEWLINE> <INDENT> ii = 1 <NEWLINE> lii = [ 0 , 1 ] <COMMENT> <NEWLINE> fi = 1 <NEWLINE> lfi = [ 1 , 1 ] <NEWLINE> <NL> for i in range ( 2 , self . n + 1 ) : <NEWLINE> <INDENT> ii = ( - lii [ self . mod % i ] * ( self . mod // i ) ) % self . mod <NEWLINE> lii . append ( ii ) <NEWLINE> <NL> fi = ( fi * ii ) % self . mod <NEWLINE> lfi . append ( fi ) <NEWLINE> <NL> <DEDENT> return lfi <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> c = Combination ( n - 1 , MOD ) <NEWLINE> <NL> <NL> def n_pattern ( i ) : <NEWLINE> <INDENT> result = m <NEWLINE> result *= c ( i ) <NEWLINE> result %= MOD <NEWLINE> result *= pow ( m - 1 , n - i - 1 , MOD ) <NEWLINE> result %= MOD <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> answer = sum ( n_pattern ( i ) for i in range ( k + 1 ) ) % MOD <NEWLINE> print ( answer ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> r = 1 <NEWLINE> if 0 in t : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for tt in t : <NEWLINE> <INDENT> r *= tt <NEWLINE> if r > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> result += math . gcd ( num , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from collections import deque <NEWLINE> <NL> s = deque ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> qq = [ list ( input ( ) . split ( ) ) for i in range ( q ) ] <NEWLINE> <NL> <NL> rl = 1 <NEWLINE> rlrl = 1 <NEWLINE> fleft = deque ( ) <NEWLINE> fright = deque ( ) <NEWLINE> <NL> for i in qq : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> rl *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i [ 1 ] == <STRING> : <NEWLINE> <INDENT> if rl == 1 : <NEWLINE> <INDENT> fleft . appendleft ( i [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fright . append ( i [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if rl == 1 : <NEWLINE> <INDENT> fright . append ( i [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fleft . appendleft ( i [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> fleft . reverse ( ) <NEWLINE> <NL> s . extendleft ( fleft ) <NEWLINE> s . extend ( fright ) <NEWLINE> <NL> if rl == - 1 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> index = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) <NEWLINE> num = int ( line ) <NEWLINE> if ( num == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> index += 1 <NEWLINE> result += <STRING> + str ( index ) + <STRING> + str ( num ) + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> print ( result . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> func ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print ( * A ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> fac = 0 <NEWLINE> start = min ( b , n ) <NEWLINE> if b <= n : <NEWLINE> <INDENT> fac = start - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fac = start <NEWLINE> <DEDENT> ans = a * fac // b - a * ( fac // b ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r ** 2 , 2 * math . pi * r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 <NEWLINE> C = [ ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> b ^= a <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> C . append ( a ^ b ) <NEWLINE> <NL> <DEDENT> print ( * C ) <NEWLINE>
from itertools import product <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> ans = n - 1 <NEWLINE> for a in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> b = n // a <NEWLINE> ans = min ( ans , b + a - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> import itertools <NEWLINE> import copy <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> table . append ( s ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> mask_h = format ( i , <STRING> . format ( H ) ) <NEWLINE> for j in range ( 2 ** W ) : <NEWLINE> <INDENT> mask_w = format ( j , <STRING> . format ( W ) ) <NEWLINE> black = 0 <NEWLINE> for di in range ( H ) : <NEWLINE> <INDENT> for dj in range ( W ) : <NEWLINE> <INDENT> if mask_h [ di ] == <STRING> and mask_w [ dj ] == <STRING> and table [ di ] [ dj ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if black == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 0 , N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> k = input ( ) . split ( ) <NEWLINE> a = int ( k [ 0 ] ) <NEWLINE> b = int ( k [ 1 ] ) <NEWLINE> c = int ( k [ 2 ] ) <NEWLINE> if a == - 1 and ( b == - 1 and c == - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a < 0 or b < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b < 50 : <NEWLINE> <INDENT> if c >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a + b < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> set = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> set . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> st = [ ] <NEWLINE> pt = [ ] <NEWLINE> ch = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> st . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> pt . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for j in st : <NEWLINE> <INDENT> for k in pt : <NEWLINE> <INDENT> d = abs ( j [ 0 ] - k [ 0 ] ) + abs ( j [ 1 ] - k [ 1 ] ) <NEWLINE> ch . append ( d ) <NEWLINE> <DEDENT> print ( ch . index ( min ( ch ) ) + 1 ) <NEWLINE> ch = [ ] <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> V = [ 0 ] * 10000 <NEWLINE> <NL> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> for l in range ( 1 , 100 ) : <NEWLINE> <INDENT> if j ** 2 + k ** 2 + l ** 2 + j * k + k * l + j * l < 10001 : <NEWLINE> <INDENT> V [ j ** 2 + k ** 2 + l ** 2 + j * k + k * l + j * l - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> print ( V [ i ] ) <NEWLINE> <DEDENT>
Books , Cost , X = None , None , None <NEWLINE> DP = { } <NEWLINE> <NL> def getUnderstanding ( prev , curr ) : <NEWLINE> <INDENT> global Books <NEWLINE> L = [ ] <NEWLINE> for i in range ( len ( prev ) ) : <NEWLINE> <INDENT> L . append ( prev [ i ] + Books [ curr ] [ i ] ) <NEWLINE> <DEDENT> return L <NEWLINE> <DEDENT> def isUnderstandingReached ( prev ) : <NEWLINE> <INDENT> global X <NEWLINE> for u in prev : <NEWLINE> <INDENT> if u < X : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def F ( curr , prev ) : <NEWLINE> <INDENT> global Books , Cost , X , DP <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if isUnderstandingReached ( prev ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if curr == len ( Books ) : <NEWLINE> <INDENT> return float ( <STRING> ) <NEWLINE> <DEDENT> DP [ ( curr , tuple ( prev ) ) ] = min ( Cost [ curr ] + F ( curr + 1 , getUnderstanding ( prev , curr ) ) , F ( curr + 1 , prev ) ) <NEWLINE> return DP [ ( curr , tuple ( prev ) ) ] <NEWLINE> <NL> <DEDENT> N , M , X = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> Books = [ ] <NEWLINE> Cost = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> Books . append ( L [ 1 : ] ) <NEWLINE> Cost . append ( L [ 0 ] ) <NEWLINE> <DEDENT> res = F ( 0 , [ 0 ] * len ( Books [ 0 ] ) ) <NEWLINE> if res == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> b = gcd ( i , k ) <NEWLINE> for m in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( b , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class Node : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . id = x <NEWLINE> self . k = y <NEWLINE> self . children = [ ] <NEWLINE> self . type = <STRING> <NEWLINE> self . depth = 20 <NEWLINE> self . parent = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def findRoot ( tree ) : <NEWLINE> <INDENT> for x in tree : <NEWLINE> <INDENT> for y in x . children : <NEWLINE> <INDENT> tree [ int ( y ) ] . parent = x . id <NEWLINE> if tree [ int ( y ) ] . k == 0 : <NEWLINE> <INDENT> tree [ int ( y ) ] . type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ int ( y ) ] . type = <STRING> <NEWLINE> <DEDENT> <STRING> <NEWLINE> <DEDENT> <DEDENT> for i , x in enumerate ( tree ) : <NEWLINE> <INDENT> if x . type == <STRING> : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def setd ( tree , node , d ) : <NEWLINE> <INDENT> node . depth = d <NEWLINE> if node . k == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for tmp in node . children : <NEWLINE> <INDENT> setd ( tree , tree [ int ( tmp ) ] , d + 1 ) <NEWLINE> <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = ( int ) ( input ( ) ) <NEWLINE> tree = [ None ] * n <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> a = Node ( tmp [ 0 ] , ( int ) ( tmp [ 1 ] ) ) <NEWLINE> a . children = tmp [ 2 : ] <NEWLINE> a . type = <STRING> <NEWLINE> tree [ int ( a . id ) ] = a <NEWLINE> <DEDENT> ri = findRoot ( tree ) <NEWLINE> setd ( tree , tree [ ri ] , 0 ) <NEWLINE> <NL> for tmp in tree : <NEWLINE> <INDENT> print ( <STRING> . format ( tmp . id , tmp . parent , tmp . depth , tmp . type , list ( map ( int , tmp . children ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import itertools <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> S = input ( ) . rstrip ( <STRING> ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> print ( 2 * min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : break <NEWLINE> dp = [ 0 for _ in range ( n ) ] <NEWLINE> dp [ 0 ] = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = int ( input ( ) ) <NEWLINE> dp [ i ] = max ( dp [ i - 1 ] + v , v ) <NEWLINE> <DEDENT> print ( max ( dp ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> a_sum = sum ( A ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a_sum -= A [ i ] <NEWLINE> answer += a_sum * A [ i ] <NEWLINE> <DEDENT> print ( str ( answer % mod ) ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> import itertools <NEWLINE> import time <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = ( input ( ) ) <NEWLINE> <COMMENT> <NL> r_index_lis , g_index_lis , b_index_lis = [ ] , [ ] , [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> r_index_lis . append ( i ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> g_index_lis . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_index_lis . append ( i ) <NEWLINE> <DEDENT> <DEDENT> count = len ( r_index_lis ) * len ( g_index_lis ) * len ( b_index_lis ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> z = [ ] <NEWLINE> w = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z . append ( x + y ) <NEWLINE> w . append ( x - y ) <NEWLINE> <DEDENT> print ( max ( max ( z ) - min ( z ) , max ( w ) - min ( w ) ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> <DEDENT> print ( f ( min ( N , B - 1 ) ) ) <NEWLINE>
<COMMENT> <NL> import sys , pprint , math <NEWLINE> from fractions import Fraction <NEWLINE> from collections import defaultdict <NEWLINE> <NL> MOD = 1000000007 <NEWLINE> N = int ( input ( ) ) <NEWLINE> params = [ ] <NEWLINE> hatemasks = [ ] <NEWLINE> tilts = defaultdict ( lambda : [ 0 , 0 ] ) <NEWLINE> zerozero = 0 <NEWLINE> zerodiv = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ( ai , bi ) = map ( int , input ( ) . split ( ) ) <NEWLINE> if ai == 0 and bi == 0 : <NEWLINE> <INDENT> zerozero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if ( ai < 0 ) or ( ai == 0 and bi < 0 ) : <NEWLINE> <INDENT> ai *= - 1 <NEWLINE> bi *= - 1 <NEWLINE> <DEDENT> g = math . gcd ( ai , bi ) <NEWLINE> ai = ai // g <NEWLINE> bi = bi // g <NEWLINE> if bi > 0 : <NEWLINE> <INDENT> tilts [ ( ai , bi ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tilts [ ( - bi , ai ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( tilts , file = sys . stderr ) <NEWLINE> <NL> <COMMENT> <NL> ans = 1 <NEWLINE> for ( v1 , v2 ) in tilts . values ( ) : <NEWLINE> <INDENT> ans *= 1 + pow ( 2 , v1 , MOD ) - 1 + pow ( 2 , v2 , MOD ) - 1 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans = ( ans + zerozero - 1 ) % MOD <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> if ans not in a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if i == ans : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> def bfs ( h1 , w1 , dp ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> queue = deque ( ) <NEWLINE> queue_warp = deque ( ) <NEWLINE> queue . append ( [ h1 , w1 ] ) <NEWLINE> now = 0 <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> h1 , w1 = queue . popleft ( ) <NEWLINE> fl_up = False <NEWLINE> fl_left = False <NEWLINE> fl_down = False <NEWLINE> fl_right = False <NEWLINE> <NL> if h1 > 0 : <NEWLINE> <INDENT> if dp [ h1 - 1 ] [ w1 ] == - 1 or dp [ h1 - 1 ] [ w1 ] == - 2 : <NEWLINE> <INDENT> if m [ h1 - 1 ] [ w1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h1 - 1 ] [ w1 ] = now <NEWLINE> queue . append ( [ h1 - 1 , w1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ h1 - 1 ] [ w1 ] = - 3 <NEWLINE> <DEDENT> <DEDENT> if dp [ h1 - 1 ] [ w1 ] == - 3 : <NEWLINE> <INDENT> fl_up = True <NEWLINE> if h1 > 1 : <NEWLINE> <INDENT> if dp [ h1 - 2 ] [ w1 ] == - 1 : <NEWLINE> <INDENT> if m [ h1 - 2 ] [ w1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h1 - 2 ] [ w1 ] = - 2 <NEWLINE> queue_warp . append ( [ h1 - 2 , w1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ h1 - 2 ] [ w1 ] = - 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if w1 > 0 : <NEWLINE> <INDENT> if dp [ h1 ] [ w1 - 1 ] == - 1 or dp [ h1 ] [ w1 - 1 ] == - 2 : <NEWLINE> <INDENT> if m [ h1 ] [ w1 - 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h1 ] [ w1 - 1 ] = now <NEWLINE> queue . append ( [ h1 , w1 - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ h1 ] [ w1 - 1 ] = - 3 <NEWLINE> <DEDENT> <DEDENT> if dp [ h1 ] [ w1 - 1 ] == - 3 : <NEWLINE> <INDENT> fl_left = True <NEWLINE> if w1 > 1 : <NEWLINE> <INDENT> if dp [ h1 ] [ w1 - 2 ] == - 1 : <NEWLINE> <INDENT> if m [ h1 ] [ w1 - 2 ] == <STRING> : <NEWLINE> <INDENT> dp [ h1 ] [ w1 - 2 ] = - 2 <NEWLINE> queue_warp . append ( [ h1 , w1 - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ h1 ] [ w1 - 2 ] = - 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if h1 < h - 1 : <NEWLINE> <INDENT> if dp [ h1 + 1 ] [ w1 ] == - 1 or dp [ h1 + 1 ] [ w1 ] == - 2 : <NEWLINE> <INDENT> if m [ h1 + 1 ] [ w1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h1 + 1 ] [ w1 ] = now <NEWLINE> queue . append ( [ h1 + 1 , w1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ h1 + 1 ] [ w1 ] = - 3 <NEWLINE> <DEDENT> <DEDENT> if dp [ h1 + 1 ] [ w1 ] == - 3 : <NEWLINE> <INDENT> fl_down = True <NEWLINE> if h1 < h - 2 : <NEWLINE> <INDENT> if dp [ h1 + 2 ] [ w1 ] == - 1 : <NEWLINE> <INDENT> if m [ h1 + 2 ] [ w1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h1 + 2 ] [ w1 ] = - 2 <NEWLINE> queue_warp . append ( [ h1 + 2 , w1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ h1 + 2 ] [ w1 ] = - 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if w1 < w - 1 : <NEWLINE> <INDENT> if dp [ h1 ] [ w1 + 1 ] == - 1 or dp [ h1 ] [ w1 + 1 ] == - 2 : <NEWLINE> <INDENT> if m [ h1 ] [ w1 + 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h1 ] [ w1 + 1 ] = now <NEWLINE> queue . append ( [ h1 , w1 + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ h1 ] [ w1 + 1 ] = - 3 <NEWLINE> <DEDENT> <DEDENT> if dp [ h1 ] [ w1 + 1 ] == - 3 : <NEWLINE> <INDENT> fl_right = True <NEWLINE> if w1 < w - 2 : <NEWLINE> <INDENT> if dp [ h1 ] [ w1 + 2 ] == - 1 : <NEWLINE> <INDENT> if m [ h1 ] [ w1 + 2 ] == <STRING> : <NEWLINE> <INDENT> dp [ h1 ] [ w1 + 2 ] = - 2 <NEWLINE> queue_warp . append ( [ h1 , w1 + 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ h1 ] [ w1 + 2 ] = - 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if fl_up and fl_left : <NEWLINE> <INDENT> for i in range ( max ( 0 , h1 - 2 ) , h1 ) : <NEWLINE> <INDENT> for j in range ( max ( 0 , w1 - 2 ) , w1 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> if m [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j ] = - 2 <NEWLINE> queue_warp . append ( [ i , j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = - 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if fl_left and fl_down : <NEWLINE> <INDENT> for i in range ( h1 + 1 , min ( h , h1 + 3 ) ) : <NEWLINE> <INDENT> for j in range ( max ( 0 , w1 - 2 ) , w1 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> if m [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j ] = - 2 <NEWLINE> queue_warp . append ( [ i , j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = - 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if fl_down and fl_right : <NEWLINE> <INDENT> for i in range ( h1 + 1 , min ( h , h1 + 3 ) ) : <NEWLINE> <INDENT> for j in range ( w1 + 1 , min ( w , w1 + 3 ) ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> if m [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j ] = - 2 <NEWLINE> queue_warp . append ( [ i , j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = - 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if fl_right and fl_up : <NEWLINE> <INDENT> for i in range ( max ( 0 , h1 - 2 ) , h1 ) : <NEWLINE> <INDENT> for j in range ( w1 + 1 , min ( w , w1 + 3 ) ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> if m [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j ] = - 2 <NEWLINE> queue_warp . append ( [ i , j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = - 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if not queue : <NEWLINE> <INDENT> now += 1 <NEWLINE> while queue_warp : <NEWLINE> <INDENT> h1 , w1 = queue_warp . popleft ( ) <NEWLINE> if dp [ h1 ] [ w1 ] == - 2 : <NEWLINE> <INDENT> dp [ h1 ] [ w1 ] = now <NEWLINE> queue . append ( [ h1 , w1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if dp [ dh - 1 ] [ dw - 1 ] >= 0 : <NEWLINE> <INDENT> return dp [ dh - 1 ] [ dw - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return dp [ dh - 1 ] [ dw - 1 ] <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = [ [ ] for i in range ( h ) ] <NEWLINE> dp = [ [ - 1 ] * w for i in range ( h ) ] <NEWLINE> dp [ ch - 1 ] [ cw - 1 ] = 0 <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> m [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> ans = bfs ( ch - 1 , cw - 1 , dp ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> l . append ( [ x , i ] ) <NEWLINE> <DEDENT> l . sort ( reverse = True ) <NEWLINE> cnt = 1 <NEWLINE> dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for i , j in l : <NEWLINE> <INDENT> for x in range ( cnt + 1 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> dp [ x ] [ cnt - x ] = dp [ x ] [ cnt - x - 1 ] + i * ( n - 1 - ( cnt - x - 1 ) - j ) <NEWLINE> <DEDENT> elif x == cnt : <NEWLINE> <INDENT> dp [ x ] [ cnt - x ] = dp [ x - 1 ] [ cnt - x ] + i * ( j - x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x ] [ cnt - x ] = max ( dp [ x - 1 ] [ cnt - x ] + i * ( j - x + 1 ) , dp [ x ] [ cnt - x - 1 ] + i * ( n - 1 - ( cnt - x - 1 ) - j ) ) <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , dp [ i ] [ n - i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 ) : <NEWLINE> <INDENT> for k in range ( j , N + 1 ) : <NEWLINE> <INDENT> if i == j and j == k and k == i : <NEWLINE> <INDENT> sum += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> elif i != j and j != k and k != i : <NEWLINE> <INDENT> sum += 6 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += 3 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum = min ( sum * 2 , sum + k ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self ) : <COMMENT> <NEWLINE> <INDENT> self . eyeIndex = 1 <COMMENT> <NEWLINE> self . eyeIndex_E = 3 <COMMENT> <NEWLINE> self . eyeIndex_W = 4 <COMMENT> <NEWLINE> self . eyeIndex_N = 5 <COMMENT> <NEWLINE> self . eyeIndex_S = 2 <COMMENT> <NEWLINE> self . eye = 0 <NEWLINE> self . eye_S = 0 <NEWLINE> self . eye_E = 0 <NEWLINE> self . eye_W = 0 <NEWLINE> self . eye_N = 0 <NEWLINE> self . eye_B = 0 <NEWLINE> self . eyes = [ ] <NEWLINE> <NL> <DEDENT> def convEyesIndexToEyes ( self ) : <NEWLINE> <INDENT> self . eye = self . eyes [ self . eyeIndex ] <NEWLINE> self . eye_S = self . eyes [ self . eyeIndex_S ] <NEWLINE> self . eye_E = self . eyes [ self . eyeIndex_E ] <NEWLINE> self . eye_N = self . eyes [ self . eyeIndex_N ] <NEWLINE> self . eye_W = self . eyes [ self . eyeIndex_W ] <NEWLINE> self . eye_B = self . eyes [ 7 - self . eyeIndex ] <NEWLINE> <NL> <DEDENT> def shakeDice ( self , in_command ) : <NEWLINE> <INDENT> pre_eyeIndex = self . eyeIndex <NEWLINE> if in_command == <STRING> : <NEWLINE> <INDENT> self . eyeIndex = self . eyeIndex_W <NEWLINE> self . eyeIndex_E = pre_eyeIndex <NEWLINE> self . eyeIndex_W = 7 - self . eyeIndex_E <NEWLINE> <NL> <DEDENT> elif in_command == <STRING> : <NEWLINE> <INDENT> self . eyeIndex = self . eyeIndex_E <NEWLINE> self . eyeIndex_W = pre_eyeIndex <NEWLINE> self . eyeIndex_E = 7 - self . eyeIndex_W <NEWLINE> <NL> <DEDENT> elif in_command == <STRING> : <NEWLINE> <INDENT> self . eyeIndex = self . eyeIndex_S <NEWLINE> self . eyeIndex_N = pre_eyeIndex <NEWLINE> self . eyeIndex_S = 7 - self . eyeIndex_N <NEWLINE> <NL> <DEDENT> elif in_command == <STRING> : <NEWLINE> <INDENT> self . eyeIndex = self . eyeIndex_N <NEWLINE> self . eyeIndex_S = pre_eyeIndex <NEWLINE> self . eyeIndex_N = 7 - self . eyeIndex_S <NEWLINE> <NL> <DEDENT> self . convEyesIndexToEyes ( ) <NEWLINE> <NL> <NL> <DEDENT> def rotateDice ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> pre_E = self . eyeIndex_E <NEWLINE> pre_S = self . eyeIndex_S <NEWLINE> pre_W = self . eyeIndex_W <NEWLINE> pre_N = self . eyeIndex_N <NEWLINE> <NL> self . eyeIndex_E = pre_N <NEWLINE> self . eyeIndex_S = pre_E <NEWLINE> self . eyeIndex_W = pre_S <NEWLINE> self . eyeIndex_N = pre_W <NEWLINE> <NL> self . convEyesIndexToEyes ( ) <NEWLINE> <NL> <DEDENT> def getEye ( self ) : <NEWLINE> <INDENT> return self . eye <NEWLINE> <NL> <DEDENT> def getEye_S ( self ) : <NEWLINE> <INDENT> return self . eye_S <NEWLINE> <NL> <DEDENT> def getEye_E ( self ) : <NEWLINE> <INDENT> return self . eye_E <NEWLINE> <NL> <DEDENT> def getEye_N ( self ) : <NEWLINE> <INDENT> return self . eye_N <NEWLINE> <NL> <DEDENT> def getEye_W ( self ) : <NEWLINE> <INDENT> return self . eye_W <NEWLINE> <NL> <DEDENT> def getEye_B ( self ) : <NEWLINE> <INDENT> return self . eye_B <NEWLINE> <NL> <DEDENT> def setEyes ( self , eyes ) : <COMMENT> <NEWLINE> <INDENT> eyes = <STRING> + eyes <NEWLINE> self . eyes = list ( map ( int , eyes . split ( <STRING> ) ) ) <NEWLINE> self . convEyesIndexToEyes ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> dice_1 = Dice ( ) <NEWLINE> dice_1 . setEyes ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> dice_2 = Dice ( ) <NEWLINE> dice_2 . setEyes ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> <NL> shake_direction = <STRING> <NEWLINE> judge = <STRING> <NEWLINE> <NL> shake_cnt = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if dice_2 . getEye ( ) == dice_1 . getEye ( ) and dice_2 . getEye_B ( ) == dice_1 . getEye_B ( ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> dice_2 . shakeDice ( shake_direction ) <NEWLINE> shake_cnt = shake_cnt + 1 <NEWLINE> <NL> if shake_cnt >= 8 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if shake_cnt >= 4 : <NEWLINE> <INDENT> shake_direction = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> rotate_cnt = 0 <NEWLINE> if judge != <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if dice_1 . getEye ( ) == dice_2 . getEye ( ) and dice_1 . getEye_E ( ) == dice_2 . getEye_E ( ) and dice_1 . getEye_S ( ) == dice_2 . getEye_S ( ) and dice_1 . getEye_W ( ) == dice_2 . getEye_W ( ) and dice_1 . getEye_N ( ) == dice_2 . getEye_N ( ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> dice_2 . rotateDice ( ) <NEWLINE> rotate_cnt = rotate_cnt + 1 <NEWLINE> <NL> if rotate_cnt >= 5 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if judge != <STRING> : <NEWLINE> <INDENT> dice_1 . shakeDice ( shake_direction ) <NEWLINE> dice_1 . shakeDice ( shake_direction ) <NEWLINE> <NL> dice_2 . shakeDice ( shake_direction ) <NEWLINE> dice_2 . shakeDice ( shake_direction ) <NEWLINE> <NL> <NL> if dice_1 . getEye ( ) == dice_2 . getEye ( ) : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( judge ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> total = n * ( n - 1 ) // 2 <NEWLINE> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R = [ X for X , x in enumerate ( S ) if x == <STRING> ] <NEWLINE> G = [ Y for Y , y in enumerate ( S ) if y == <STRING> ] <NEWLINE> B = [ Z for Z , z in enumerate ( S ) if z == <STRING> ] <NEWLINE> <NL> mae = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( mae - cnt ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) <NEWLINE> <INDENT> for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> maxSize = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> maxSize = max ( maxSize , uf . size ( j ) ) <NEWLINE> <DEDENT> print ( maxSize ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> ci = L [ i ] <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> cij = ci + L [ j ] <NEWLINE> c += bisect . bisect_left ( L , cij , j + 1 , n ) - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <COMMENT> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = set ( ) <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . add ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . add ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> A . sort ( ) <NEWLINE> A = A [ : : - 1 ] <NEWLINE> <NL> <NL> p0 = make_divisors ( A [ 0 ] ) <NEWLINE> p1 = make_divisors ( A [ - 1 ] ) <NEWLINE> P = p0 | p1 <NEWLINE> <NL> for p in sorted ( P ) [ : : - 1 ] : <NEWLINE> <INDENT> c = np . count_nonzero ( A % p == 0 ) <NEWLINE> if c == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> q = np . gcd . reduce ( A ) <NEWLINE> if p > q : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from builtins import abs <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ i ] - h [ j ] ) for j in range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
x = input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> s = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : s += 1 <NEWLINE> else : <NEWLINE> <INDENT> if s > 0 : <NEWLINE> <INDENT> s -= 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( x ) - cnt * 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W , D = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> M = [ 0 ] * H <NEWLINE> C = { } <NEWLINE> revM = { } <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> M [ h ] = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> for i , w in enumerate ( M [ h ] ) : <NEWLINE> <INDENT> revM [ w ] = ( h , i ) <NEWLINE> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> HW = H * W <NEWLINE> ans = [ 0 ] * ( HW + 1 ) <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> cur = i <NEWLINE> while cur + D <= HW : <NEWLINE> <INDENT> ans [ cur + D ] += ans [ cur ] + abs ( revM [ cur ] [ 0 ] - revM [ cur + D ] [ 0 ] ) + abs ( revM [ cur ] [ 1 ] - revM [ cur + D ] [ 1 ] ) <NEWLINE> cur += D <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> l , r = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> print ( ans [ r ] - ans [ l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( len ( s ) - abs ( s . count ( <STRING> ) - s . count ( <STRING> ) ) ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> dp = [ 0 ] * 2019 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> total = 0 <NEWLINE> a = 1 <NEWLINE> <NL> for i in list ( s ) : <NEWLINE> <INDENT> total += int ( i ) * a <NEWLINE> total %= 2019 <NEWLINE> dp [ total ] += 1 <NEWLINE> a *= 10 <NEWLINE> a %= 2019 <NEWLINE> <DEDENT> count = 0 <NEWLINE> <NL> for i in range ( 2019 ) : <NEWLINE> <INDENT> count += dp [ i ] * ( dp [ i ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> array = [ ] <NEWLINE> replace = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> replace [ i ] += 1 <NEWLINE> <DEDENT> sum_s = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> m , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> replace [ n ] += replace [ m ] <NEWLINE> <NL> diff = n * replace [ m ] - replace [ m ] * m <NEWLINE> sum_s += diff <NEWLINE> replace [ m ] = 0 <NEWLINE> print ( sum_s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> D = { } <NEWLINE> ma = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> ma += i <NEWLINE> if i not in D : <NEWLINE> <INDENT> D [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for b , c in B : <NEWLINE> <INDENT> if b in D : <NEWLINE> <INDENT> f = D [ b ] <NEWLINE> if c in D : <NEWLINE> <INDENT> t = D [ c ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> <NL> <DEDENT> D [ c ] = f + t <NEWLINE> D [ b ] = 0 <NEWLINE> ma += ( c - b ) * f <NEWLINE> <DEDENT> print ( ma ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <COMMENT> <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> SUMA = sum ( A ) <COMMENT> <NEWLINE> MOD = 10 ** 9 + 7 <COMMENT> <NEWLINE> C = [ 0 ] * ( N - 1 ) <COMMENT> <NEWLINE> for i in range ( N - 1 ) : <COMMENT> <NEWLINE> <INDENT> SUMA -= A [ i ] <NEWLINE> C [ i ] = SUMA <NEWLINE> <DEDENT> ans = 0 <COMMENT> <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * C [ i ] <NEWLINE> ans %= MOD <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <COMMENT> <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> value = 1 <NEWLINE> <NL> A = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> if value * a > 10 ** 18 : <NEWLINE> <INDENT> value = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value *= a <NEWLINE> <DEDENT> <DEDENT> print ( value ) <NEWLINE> <DEDENT>
def printAns ( A ) : <NEWLINE> <INDENT> n = len ( A ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> print ( str ( A [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( str ( A [ n - 1 ] ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . extend ( list ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> k = max ( A ) <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> C . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> B . append ( 0 ) <NEWLINE> <NL> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> C [ A [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in reversed ( range ( n + 1 ) ) : <NEWLINE> <INDENT> B [ C [ A [ j ] ] ] = A [ j ] <NEWLINE> C [ A [ j ] ] -= 1 <NEWLINE> <NL> <DEDENT> printAns ( B ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> <NL> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s [ List [ i ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - sum ( s ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> x = 7 % k <NEWLINE> i = 1 <NEWLINE> set = set ( ) <NEWLINE> is_there = False <NEWLINE> <NL> while not is_there : <NEWLINE> <INDENT> set . add ( x ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> x = ( x * 10 + 7 ) % k <NEWLINE> if x in set : <NEWLINE> <INDENT> is_there = True <NEWLINE> <DEDENT> set . add ( x ) <NEWLINE> i += 1 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def Main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if A . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> Main ( ) <NEWLINE>
def main ( n ) : <NEWLINE> <NL> <INDENT> prime = [ ] <NEWLINE> if n < 2 : <NEWLINE> <INDENT> prime . append ( ( 1 , 0 ) ) <NEWLINE> <DEDENT> for p in range ( 2 , int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if p * p > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while n % p == 0 : <NEWLINE> <INDENT> n //= p <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> prime . append ( ( p , cnt ) ) <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> prime . append ( ( n , 1 ) ) <NEWLINE> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> pf = main ( n ) <NEWLINE> <NL> ans = 0 <NEWLINE> for p , f in pf : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while f >= cnt : <NEWLINE> <INDENT> f -= cnt <NEWLINE> ans += 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> r = N <NEWLINE> l = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l = max ( l , L [ i ] [ 0 ] ) <NEWLINE> r = min ( r , L [ i ] [ 1 ] ) <NEWLINE> <DEDENT> if r - l + 1 < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r - l + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_A = [ A [ 0 ] ] <NEWLINE> sum_B = [ B [ 0 ] ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum_A . append ( sum_A [ i ] + A [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m - 1 ) : <NEWLINE> <INDENT> sum_B . append ( sum_B [ i ] + B [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> R = [ ] <NEWLINE> <NL> b = m - 1 <NEWLINE> flag = False <NEWLINE> while b > - 1 : <NEWLINE> <INDENT> if sum_B [ b ] <= k : <NEWLINE> <INDENT> R . append ( b + 1 ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> R . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = sum_A [ i ] <NEWLINE> <NL> flag = False <NEWLINE> while b > - 1 : <NEWLINE> <INDENT> if sum_B [ b ] <= k - a : <NEWLINE> <INDENT> R . append ( i + 1 + b + 1 ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> if 0 <= k - a : <NEWLINE> <INDENT> R . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( R ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> Q = deque ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x = Q . popleft ( ) <NEWLINE> if x % 10 != 0 : <NEWLINE> <INDENT> y = 10 * x + x % 10 - 1 <NEWLINE> Q . append ( y ) <NEWLINE> <NL> <DEDENT> y = 10 * x + x % 10 <NEWLINE> Q . append ( y ) <NEWLINE> <NL> if x % 10 != 9 : <NEWLINE> <INDENT> y = 10 * x + x % 10 + 1 <NEWLINE> Q . append ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = Q . popleft ( ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> graph [ A - 1 ] . append ( B - 1 ) <NEWLINE> graph [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> def bfs ( start ) : <NEWLINE> <INDENT> dist = [ INF ] * N <NEWLINE> dist [ start ] = 0 <NEWLINE> seen = [ 0 ] * N <NEWLINE> shirube = [ None ] * N <NEWLINE> shirube [ 0 ] = <STRING> <NEWLINE> q = deque ( [ start ] ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> dv = dist [ v ] <NEWLINE> for next_room in graph [ v ] : <NEWLINE> <INDENT> if seen [ next_room ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dv + 1 < dist [ next_room ] : <NEWLINE> <INDENT> dist [ next_room ] = dv + 1 <NEWLINE> shirube [ next_room ] = v + 1 <NEWLINE> <DEDENT> seen [ next_room ] = 1 <NEWLINE> q . append ( next_room ) <NEWLINE> <DEDENT> <DEDENT> if all ( shirube ) : <NEWLINE> <INDENT> for x in shirube : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> bfs ( 0 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = 1 <NEWLINE> if k <= n : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> p = a [ p - 1 ] <NEWLINE> <DEDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> t = [ - 1 ] * n <NEWLINE> t [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p = a [ p - 1 ] <NEWLINE> if t [ p - 1 ] != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t [ p - 1 ] = i <NEWLINE> <NL> <DEDENT> d = i - t [ p - 1 ] <NEWLINE> k -= i <NEWLINE> k %= d <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> p = a [ p - 1 ] <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
def cal ( N ) : <NEWLINE> <INDENT> num = ( N ** 0.5 ) // 1 <NEWLINE> num = int ( num ) <NEWLINE> for i in range ( num , 0 , - 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> k = int ( N / i ) <NEWLINE> x = len ( str ( k ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> print ( cal ( int ( input ( ) ) ) ) <NEWLINE>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ns = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ms = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nss = [ 0 ] <NEWLINE> for i , v in enumerate ( ns ) : <NEWLINE> <INDENT> nss . append ( nss [ i ] + ns [ i ] ) <NEWLINE> <NL> <DEDENT> mss = [ 0 ] <NEWLINE> for i , v in enumerate ( ms ) : <NEWLINE> <INDENT> mss . append ( mss [ i ] + ms [ i ] ) <NEWLINE> <NL> <DEDENT> mx = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if nss [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while mss [ j ] > k - nss [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> mx = max ( mx , i + j ) <NEWLINE> <NL> <DEDENT> print ( mx ) <NEWLINE>
from copy import copy <NEWLINE> import numpy as np <NEWLINE> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = np . zeros ( S + 100 , np . int64 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> buf = copy ( dp ) <NEWLINE> dp = 2 * dp <NEWLINE> dp [ A [ i ] : ] += buf [ : - A [ i ] ] <NEWLINE> dp %= 998244353 <NEWLINE> <DEDENT> print ( dp [ S ] % 998244353 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = { } <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] in ans : <COMMENT> <NEWLINE> <INDENT> ans [ A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ A [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i in ans : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> . format ( ans [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( 0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( 0 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin , stdout <NEWLINE> from time import perf_counter <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> print ( ( ( b // x ) - ( ( a - 1 ) // x ) ) ) <NEWLINE>
import math <NEWLINE> def hoge ( a ) : <NEWLINE> <INDENT> return a * a <NEWLINE> <DEDENT> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( hoge ( math . fabs ( x1 - x2 ) ) + hoge ( math . fabs ( y1 - y2 ) ) ) ) <NEWLINE>
<NL> N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> H_ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> edge , rst = [ [ ] for i in range ( N ) ] , 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> is_peak = True <NEWLINE> for j in edge [ i ] : <NEWLINE> <INDENT> if H_ls [ i ] <= H_ls [ j ] : <NEWLINE> <INDENT> is_peak = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_peak : <NEWLINE> <INDENT> rst += 1 <NEWLINE> <DEDENT> <DEDENT> print ( rst ) <NEWLINE>
flg = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bucket = [ 0 ] * 10000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> bucket [ l [ i ] ] += 1 <NEWLINE> if flg < l [ i ] : <NEWLINE> <INDENT> flg = l [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( flg ) : <NEWLINE> <INDENT> for j in range ( bucket [ i ] ) : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( bucket [ flg ] - 1 ) : <NEWLINE> <INDENT> print ( flg , end = <STRING> ) <NEWLINE> <DEDENT> print ( flg ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum = [ 0 , A [ 0 ] ] <NEWLINE> B_sum = [ 0 , B [ 0 ] ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> A_sum . append ( A_sum [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( 1 , M ) : <NEWLINE> <INDENT> B_sum . append ( B_sum [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> b_read = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( b_read , M + 1 ) : <NEWLINE> <INDENT> if A_sum [ i ] + B_sum [ j ] <= K : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> b_read = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> tf = True <NEWLINE> zero = False <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if lis [ k ] == 0 : <NEWLINE> <INDENT> zero = True <NEWLINE> <DEDENT> <DEDENT> if not zero : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a *= lis [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> tf = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tf : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> B = [ ( i , j ) for i , a in enumerate ( A ) for j , b in enumerate ( a ) if b == <STRING> ] <NEWLINE> dxy = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> stack = deque ( B ) <NEWLINE> colored = len ( B ) <NEWLINE> tot = h * w <NEWLINE> count = 0 <NEWLINE> while colored < tot : <NEWLINE> <INDENT> next = deque ( [ ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> y , x = stack . popleft ( ) <NEWLINE> for dx , dy in dxy : <NEWLINE> <INDENT> X = x + dx <NEWLINE> Y = y + dy <NEWLINE> if X < 0 or X >= w or Y < 0 or Y >= h : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ Y ] [ X ] == <STRING> : <NEWLINE> <INDENT> next . append ( ( Y , X ) ) <NEWLINE> A [ Y ] [ X ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> stack = next <NEWLINE> count += 1 <NEWLINE> colored += len ( next ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def dfs ( G , v ) : <NEWLINE> <INDENT> seen [ v ] = True <NEWLINE> <NL> for nv in G [ v ] : <NEWLINE> <INDENT> if seen [ nv ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ nv ] += point [ v ] <NEWLINE> dfs ( G , nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x , y = x - 1 , y - 1 <NEWLINE> G [ x ] . append ( y ) <NEWLINE> G [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> seen = [ False for _ in range ( n ) ] <NEWLINE> root = 0 <NEWLINE> point = [ 0 for _ in range ( n ) ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> dfs ( G , root ) <NEWLINE> print ( * point ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = [ ] <NEWLINE> z = 0 <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> K . append ( k ) <NEWLINE> <DEDENT> T = set ( K ) <NEWLINE> y = len ( T ) <NEWLINE> print ( y ) <NEWLINE>
while input ( ) != <STRING> : <NEWLINE> <INDENT> l = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> m = sum ( l ) / len ( l ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> s += ( l [ i ] - m ) ** 2 <NEWLINE> <DEDENT> print ( <STRING> % ( ( s / len ( l ) ) ** .5 ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road . append ( R ) <NEWLINE> <NL> <DEDENT> other = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> other . append ( [ 0 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> other [ road [ i ] [ 0 ] - 1 ] . append ( height [ road [ i ] [ 1 ] - 1 ] ) <NEWLINE> other [ road [ i ] [ 1 ] - 1 ] . append ( height [ road [ i ] [ 0 ] - 1 ] ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if height [ i ] > max ( other [ i ] ) : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> length = [ - 1 ] * n <NEWLINE> path = [ - 1 , [ ] ] <NEWLINE> route = [ ] <NEWLINE> <NL> <NL> def func ( now , depth ) : <NEWLINE> <INDENT> global path , length , a , route <NEWLINE> route . append ( now ) <NEWLINE> if length [ now ] == - 1 : <NEWLINE> <INDENT> length [ now ] = depth <NEWLINE> func ( a [ now ] - 1 , depth + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path = [ length [ now ] , route [ length [ now ] : depth ] ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> func ( 0 , 0 ) <NEWLINE> <NL> if ( k < path [ 0 ] ) : <NEWLINE> <INDENT> print ( route [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = k - path [ 0 ] <NEWLINE> tmp %= len ( path [ 1 ] ) <NEWLINE> print ( path [ 1 ] [ tmp ] + 1 ) <NEWLINE> <DEDENT>
def B ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> B ( ) <NEWLINE>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , i , <STRING> , x , sep = <STRING> ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT>
from time import time <NEWLINE> <NL> start = time ( ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> scores = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( D ) ] <NEWLINE> t = [ ] <NEWLINE> for i in scores : <NEWLINE> <INDENT> t . append ( i . index ( max ( i ) ) + 1 ) <NEWLINE> <DEDENT> DC = [ 0 ] * 26 <NEWLINE> <NL> def calcScore ( t ) : <NEWLINE> <INDENT> score = [ ] <NEWLINE> S = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> S += scores [ d - 1 ] [ t [ d - 1 ] - 1 ] <NEWLINE> last [ t [ d - 1 ] - 1 ] = d <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> S -= C [ i ] * ( d - last [ i ] ) <NEWLINE> DC [ i ] += ( d - last [ i ] ) <NEWLINE> <DEDENT> score . append ( S ) <NEWLINE> <DEDENT> return score [ - 1 ] <NEWLINE> <NL> <DEDENT> ts = calcScore ( t ) <NEWLINE> i = 0 <NEWLINE> j = 1 <NEWLINE> while time ( ) - start < 1.95 : <NEWLINE> <INDENT> d , q = i , j <NEWLINE> temp = [ t [ i ] if d - 1 != i else q for i in range ( D ) ] <NEWLINE> j += 1 <NEWLINE> if calcScore ( temp ) > ts : <NEWLINE> <INDENT> t = temp <NEWLINE> i += 1 <NEWLINE> j = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , t ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ i // 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> from collections import deque , Counter , defaultdict <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> import itertools <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> inf = 10 ** 18 <NEWLINE> MOD = 1000000007 <NEWLINE> ri = lambda : int ( input ( ) ) <NEWLINE> rs = lambda : input ( ) . strip ( ) <NEWLINE> rl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = ri ( ) <NEWLINE> dp = [ 1 ] * max ( 4 , ( s + 1 ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> dp [ 3 ] = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 4 , s + 1 ) : <COMMENT> <NEWLINE> <INDENT> dp [ i ] = dp [ i - 3 ] + dp [ i - 1 ] <NEWLINE> <NL> <DEDENT> print ( dp [ s ] % MOD ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x = [ [ int ( i ) for i in input ( ) ] for j in range ( 8 ) ] <NEWLINE> count = 0 <NEWLINE> num = [ ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> if x [ i ] . count ( 1 ) != 0 : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif count == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif count == 2 : <NEWLINE> <INDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> if x [ num [ 0 ] ] [ j ] == 1 : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> if x [ num [ 0 ] + 1 ] [ j ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x [ num [ 0 ] + 1 ] [ j - 1 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x [ num [ 0 ] + 1 ] [ j ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> if x [ num [ 0 ] ] [ j ] == 1 : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x [ num [ 0 ] + 1 ] [ j - 1 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = A - B <NEWLINE> if abs ( ans ) > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif K % 2 == 1 : <NEWLINE> <INDENT> ans *= - 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = 1 <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> if A [ k ] == 0 : <NEWLINE> <INDENT> p = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if p == 0 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> p *= A [ i ] <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> p = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
import random <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> print ( random . randint ( 1 , 26 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> self . dist = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x , self . dist [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . find ( self . parents [ x ] ) <NEWLINE> self . parents [ x ] = tmp [ 0 ] <NEWLINE> self . dist [ x ] += tmp [ 1 ] <NEWLINE> return self . parents [ x ] , self . dist [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y , d ) : <NEWLINE> <INDENT> rx , _ = self . find ( x ) <NEWLINE> ry , _ = self . find ( y ) <NEWLINE> diff = self . dist [ y ] - self . dist [ x ] - d <NEWLINE> if rx == ry : <NEWLINE> <INDENT> if diff != 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if diff < 0 : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> diff = - diff <NEWLINE> <DEDENT> self . parents [ ry ] = min ( self . parents [ ry ] , self . parents [ rx ] - diff ) <NEWLINE> self . parents [ rx ] = ry <NEWLINE> self . dist [ rx ] = diff <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * lrd = map ( int , read ( ) . split ( ) ) <NEWLINE> v = Unionfind ( n ) <NEWLINE> for l , r , d in zip ( * [ iter ( lrd ) ] * 3 ) : <NEWLINE> <INDENT> if v . union ( l - 1 , r - 1 , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> Kstr = str ( K ) <NEWLINE> <NL> if Kstr [ - 1 ] in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 7 == 0 : <NEWLINE> <INDENT> L = ( 9 * K ) / 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <DEDENT> S = 10 <NEWLINE> for i in range ( 1 , 100000000000 ) : <NEWLINE> <INDENT> S = S % L <NEWLINE> if S == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> S = S * 10 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> while k : <NEWLINE> <INDENT> if not a < b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> k -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif not b < c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> k -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> all_num = sum ( A ) <NEWLINE> for i in range ( N , 1 , - 1 ) : <NEWLINE> <INDENT> all_num -= A [ i - 1 ] <NEWLINE> ans += A [ i - 1 ] * all_num <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N % K == 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( N % K - K ) >= N % K : <NEWLINE> <INDENT> answer = N % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = abs ( N % K - K ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> r = [ ] <NEWLINE> nx = 0 <NEWLINE> sr = set ( [ ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r . append ( nx ) <NEWLINE> sr . add ( nx ) <NEWLINE> if k < i : <NEWLINE> <INDENT> print ( r [ k ] + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> tnx = a [ nx ] <NEWLINE> if tnx in sr : <NEWLINE> <INDENT> m = r . index ( a [ nx ] ) <NEWLINE> d = i - m + 1 <NEWLINE> k = k - m <NEWLINE> k = k % d <NEWLINE> print ( r [ k + m ] + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> nx = tnx <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_A = [ 0 ] <NEWLINE> sum_B = [ 0 ] <NEWLINE> for a in range ( len ( A ) ) : <NEWLINE> <INDENT> sum_A . append ( sum_A [ a ] + A [ a ] ) <NEWLINE> <NL> <DEDENT> for b in range ( len ( B ) ) : <NEWLINE> <INDENT> sum_B . append ( sum_B [ b ] + B [ b ] ) <NEWLINE> <NL> <DEDENT> len_A = len ( sum_A ) <NEWLINE> j = len ( sum_B ) - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len_A ) : <NEWLINE> <INDENT> a = sum_A [ i ] <NEWLINE> while True : <NEWLINE> <INDENT> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a + sum_B [ j ] <= K : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> if j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l = [ ] <NEWLINE> for mark in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> l . append ( mark + <STRING> + str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> l . remove ( input ( ) ) <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def probC ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_tail = sum ( A ) <NEWLINE> <NL> total = 0 <NEWLINE> for idx , i in enumerate ( A ) : <NEWLINE> <INDENT> sum_tail -= A [ idx ] <NEWLINE> if idx + 1 == len ( A ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total += i * sum_tail <NEWLINE> <DEDENT> print ( total % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> probC ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ns = len ( S ) <NEWLINE> nt = len ( T ) <NEWLINE> ans = [ ] <NEWLINE> i = 0 <NEWLINE> while i + nt <= ns : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < nt : <NEWLINE> <INDENT> if S [ i + j ] == <STRING> or S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if j == nt : <NEWLINE> <INDENT> A = S [ : i ] + T + S [ i + nt : ] <NEWLINE> A = A . replace ( <STRING> , <STRING> ) <NEWLINE> ans . append ( A ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if ans : <NEWLINE> <INDENT> print ( sorted ( ans ) [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> h_sum = [ 0 ] * H <NEWLINE> w_sum = [ 0 ] * W <NEWLINE> point_list = set ( ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> point_list . add ( ( h - 1 , w - 1 ) ) <NEWLINE> h_sum [ h - 1 ] += 1 <NEWLINE> w_sum [ w - 1 ] += 1 <NEWLINE> <NL> <DEDENT> h_max = max ( h_sum ) <NEWLINE> w_max = max ( w_sum ) <NEWLINE> <NL> h_argmax = set ( ) <NEWLINE> w_argmax = set ( ) <NEWLINE> <NL> for i , h in enumerate ( h_sum ) : <NEWLINE> <INDENT> if h == h_max : <NEWLINE> <INDENT> h_argmax . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , w in enumerate ( w_sum ) : <NEWLINE> <INDENT> if w == w_max : <NEWLINE> <INDENT> w_argmax . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = h_max + w_max <NEWLINE> <NL> for h in h_argmax : <NEWLINE> <INDENT> for w in w_argmax : <NEWLINE> <INDENT> if ( h , w ) not in point_list : <NEWLINE> <COMMENT> <NL> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
S = input ( ) <NEWLINE> if ( S [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> S = S + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S + <STRING> <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
S = list ( map ( str , input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> num = [ - 1 ] * ( len ( S ) + 1 ) <NEWLINE> index0 = list ( ) <NEWLINE> than = 0 <COMMENT> <NEWLINE> <COMMENT> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> if ( than == 0 ) : <NEWLINE> <INDENT> num [ i ] = 0 <NEWLINE> index0 . append ( i ) <NEWLINE> <DEDENT> than = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> than = 0 <NEWLINE> <DEDENT> <DEDENT> if ( S [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> num [ - 1 ] = 0 <NEWLINE> index0 . append ( len ( S ) + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> if ( index0 [ 0 ] == 0 ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> num [ i ] = num [ i - 1 ] + 1 <NEWLINE> if ( i >= len ( S ) ) : break <NEWLINE> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> index0 . pop ( 0 ) <NEWLINE> <DEDENT> if ( len ( index0 ) > 0 ) : <NEWLINE> <INDENT> if ( index0 [ - 1 ] == len ( S ) + 1 ) : <NEWLINE> <INDENT> i = len ( S ) - 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> num [ i ] = num [ i + 1 ] + 1 <NEWLINE> i -= 1 <NEWLINE> if ( i < 0 ) : break <NEWLINE> if ( S [ i ] == <STRING> ) : break <NEWLINE> <DEDENT> index0 . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> while ( len ( index0 ) > 0 ) : <NEWLINE> <INDENT> for i in reversed ( range ( 0 , index0 [ 0 ] ) ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num [ i ] = max ( num [ i ] , num [ i + 1 ] + 1 ) <NEWLINE> <DEDENT> for i in range ( index0 [ 0 ] + 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> num [ i ] = max ( num [ i ] , num [ i - 1 ] + 1 ) <NEWLINE> if ( i >= len ( S ) ) : break <NEWLINE> if ( S [ i ] == <STRING> ) : break <NEWLINE> <DEDENT> index0 . pop ( 0 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> ans += num [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = sum ( a ) <NEWLINE> count = 0 <NEWLINE> for i , v in enumerate ( a ) : <NEWLINE> <INDENT> sum_a -= v <NEWLINE> count += v * sum_a <NEWLINE> <NL> <DEDENT> print ( count % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> import time <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> town_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> queue = { } <NEWLINE> <NL> start = - 1 <NEWLINE> count = 1 <NEWLINE> <NL> now_town = 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if town_list [ now_town - 1 ] in queue : <NEWLINE> <INDENT> start = town_list [ now_town - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> queue [ town_list [ now_town - 1 ] ] = count <NEWLINE> now_town = town_list [ now_town - 1 ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> if start == - 1 : <NEWLINE> <INDENT> print ( now_town ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> roop = len ( queue ) - ( queue [ start ] - 1 ) <NEWLINE> before_len = queue [ start ] <NEWLINE> <NL> print ( list ( queue . keys ( ) ) [ ( K - before_len ) % roop + before_len - 1 ] ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n in [ 2 , 3 , 5 , 7 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif 0 in [ n % 2 , n % 3 , n % 5 , n % 7 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check_max = math . ceil ( math . sqrt ( n ) ) <NEWLINE> for i in range ( 2 , check_max + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> primes = set ( [ ] ) <NEWLINE> length = int ( input ( ) ) <NEWLINE> for _ in range ( 0 , length ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if is_prime ( n ) : <NEWLINE> <INDENT> primes . add ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( primes ) ) <NEWLINE> return 0 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = r * g * b <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> si = s [ i ] <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> sj = s [ j ] <NEWLINE> nk = 2 * j - i <NEWLINE> if not nk < n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> snk = s [ nk ] <NEWLINE> if { si , sj , snk } == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( count ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] >= k : <NEWLINE> <INDENT> ans = n - i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <COMMENT> <NEWLINE> <INDENT> import sys <NEWLINE> from collections import defaultdict <NEWLINE> dic = defaultdict ( int ) <NEWLINE> <NL> input = sys . stdin . readline <COMMENT> <NEWLINE> <NL> s = str ( input ( ) . rstrip ( ) ) <NEWLINE> m = 0 <NEWLINE> <NL> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> m_1 = pow ( 10 , i - 1 , 2019 ) <NEWLINE> m_add = ( int ( s [ - i ] ) * m_1 ) % 2019 <NEWLINE> m = ( m_add + m ) % 2019 <NEWLINE> dic [ m ] += 1 <NEWLINE> <NL> <DEDENT> ans1 = 0 <NEWLINE> <NL> for x in dic . values ( ) : <NEWLINE> <INDENT> if x > 1 : <NEWLINE> <INDENT> ans1 += x * ( x - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> ans2 = dic [ 0 ] <NEWLINE> <NL> print ( ans1 + ans2 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import networkx as nx <NEWLINE> import sys <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edge ( a , b ) <NEWLINE> <NL> <DEDENT> largest_cc = max ( nx . connected_components ( G ) , key = len ) <NEWLINE> print ( len ( largest_cc ) ) <NEWLINE>
import heapq <NEWLINE> import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( a [ 0 ] ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> mean_a = sum ( a ) / k <NEWLINE> q = [ ] <NEWLINE> for aa in a : <NEWLINE> <INDENT> d = max ( math . floor ( aa / mean_a ) , 1 ) <NEWLINE> q . append ( ( - aa / d , d ) ) <NEWLINE> k -= ( d - 1 ) <NEWLINE> <DEDENT> heapq . heapify ( q ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> aa , n = heapq . heappop ( q ) <NEWLINE> heapq . heappush ( q , ( aa * n / ( n + 1 ) , n + 1 ) ) <NEWLINE> <NL> <DEDENT> ans , _ = heapq . heappop ( q ) <NEWLINE> print ( math . ceil ( - ans ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> import bisect <NEWLINE> X , N = I ( ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = l ( ) <NEWLINE> A = [ i for i in range ( - 1 , 102 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p [ i ] in A : <NEWLINE> <INDENT> A . remove ( p [ i ] ) <NEWLINE> <DEDENT> <DEDENT> i = bisect . bisect_left ( A , X ) <NEWLINE> if abs ( A [ i - 1 ] - X ) > abs ( A [ i ] - X ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) ; s = input ( ) ; c = s . count ; print ( c ( <STRING> ) * c ( <STRING> ) * c ( <STRING> ) - sum ( len ( set ( s [ i : j + 1 : ( j - i ) // 2 ] ) ) > 2 for i in range ( n - 2 ) for j in range ( i + 2 , n , 2 ) ) ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> a , b , x = I ( ) <NEWLINE> <NL> if ( a ** 2 * b ) <= 2 * x : <NEWLINE> <INDENT> c = 2 * ( a ** 2 * b - x ) / a ** 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ( a * b ** 2 ) / ( 2 * x ) <NEWLINE> <NL> <DEDENT> print ( math . degrees ( math . atan ( c ) ) ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> BC . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> temp = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> temp += [ BC [ i ] [ 1 ] ] * BC [ i ] [ 0 ] <NEWLINE> if len ( temp ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> A += temp <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( A [ : N ] ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> As = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> As = sorted ( As , reverse = True ) <NEWLINE> rest = M <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> if rest == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = As [ 0 ] <NEWLINE> b = d // 2 - d // 4 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = As [ i ] <NEWLINE> check = 0 <NEWLINE> if a - a // 2 < b : <NEWLINE> <INDENT> if rest > i : <NEWLINE> <INDENT> ad = [ x // 2 for x in As [ : i ] ] <NEWLINE> As = As [ i : ] <NEWLINE> As . extend ( ad ) <NEWLINE> rest -= i <NEWLINE> check += 1 <NEWLINE> As = sorted ( As , reverse = True ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ad = [ x // 2 for x in As [ : rest ] ] <NEWLINE> As = As [ rest : ] <NEWLINE> As . extend ( ad ) <NEWLINE> check += 1 <NEWLINE> rest = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> if check == 0 : <NEWLINE> <INDENT> if rest > N : <NEWLINE> <INDENT> As = [ x // 2 for x in As ] <NEWLINE> rest -= N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ad = [ x // 2 for x in As [ : rest ] ] <NEWLINE> As = As [ rest : ] <NEWLINE> As . extend ( ad ) <NEWLINE> rest = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( As ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> dic [ chr ( i + 97 ) ] = [ ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> dic [ s [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> dic [ chr ( i + 97 ) ] . append ( float ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> from bisect import bisect_left <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y , z = input ( ) . split ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> y = int ( y ) - 1 <NEWLINE> p = bisect_left ( dic [ s [ y ] ] , y ) <NEWLINE> dic [ s [ y ] ] . pop ( p ) <NEWLINE> dic [ z ] . insert ( bisect_left ( dic [ z ] , y ) , y ) <NEWLINE> s [ y ] = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 0 <NEWLINE> y , z = int ( y ) - 1 , int ( z ) - 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> p = dic [ chr ( i + 97 ) ] [ bisect_left ( dic [ chr ( i + 97 ) ] , y ) ] <NEWLINE> if p <= z : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT> <DEDENT>
<NL> k = int ( input ( ) ) <NEWLINE> <NL> from math import gcd <NEWLINE> s6 = 0 <NEWLINE> for i in range ( 2 , k - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k ) : <NEWLINE> <INDENT> for jj in range ( j + 1 , k + 1 ) : <NEWLINE> <INDENT> s6 += gcd ( gcd ( i , j ) , jj ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s3 = 0 <NEWLINE> for i in range ( 2 , k ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k + 1 ) : <NEWLINE> <INDENT> s3 += gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> s1 = int ( ( k + 1 ) * k / 2 ) <NEWLINE> <NL> <NL> print ( s1 + s3 * 6 + s6 * 6 + ( k - 1 ) * 6 + ( k - 2 ) * ( k - 1 ) * 3 ) <NEWLINE>
x , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = min ( x % k , k - x % k ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> n = input ( ) . split ( ) <NEWLINE> x = float ( n [ 2 ] ) - float ( n [ 0 ] ) <NEWLINE> y = float ( n [ 3 ] ) - float ( n [ 1 ] ) <NEWLINE> <NL> print ( math . sqrt ( x ** 2 + y ** 2 ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A , reverse = True ) <NEWLINE> <COMMENT> <NL> <NL> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from sys import stdin <NEWLINE> import math <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> readline = stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) ) <NEWLINE> xy = [ tuple ( map ( int , readline ( ) . split ( ) ) ) + ( i , ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> xy . sort ( ) <NEWLINE> <NL> root = int ( math . sqrt ( len ( xy ) ) ) <NEWLINE> <NL> low = [ x for x , y , i in xy [ : : root ] ] <NEWLINE> high = [ x for x , y , i in xy [ root - 1 : : root ] ] + [ float ( <STRING> ) ] <NEWLINE> <NL> xy = [ sorted ( xy [ i : i + root ] , key = itemgetter ( 1 ) ) for i in range ( 0 , len ( xy ) , root ) ] <NEWLINE> xy = [ ( [ y for x , y , i in xyi ] , xyi ) for xyi in xy ] <NEWLINE> for sx , tx , sy , ty in ( map ( int , readline ( ) . split ( ) ) for _ in range ( int ( readline ( ) ) ) ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for i in range ( bisect_left ( high , sx ) , bisect_right ( low , tx ) ) : <NEWLINE> <INDENT> k , v = xy [ i ] <NEWLINE> for i in range ( bisect_left ( k , sy ) , bisect_right ( k , ty ) ) : <NEWLINE> <INDENT> if sx <= v [ i ] [ 0 ] <= tx : <NEWLINE> <INDENT> ret . append ( v [ i ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ret : <NEWLINE> <INDENT> ret . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( str , ret ) ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import defaultdict , Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> n = A [ - 1 ] <NEWLINE> isPrime = [ True ] * ( n + 1 ) <NEWLINE> prep = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if prep == i : <NEWLINE> <INDENT> isPrime [ prep ] = False <NEWLINE> continue <NEWLINE> <DEDENT> if isPrime [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> isPrime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> prep = i <NEWLINE> <NL> <DEDENT> prep = res = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if prep == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if isPrime [ i ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> prep = i <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
first_input = input ( ) . split ( ) <NEWLINE> x = int ( first_input [ 0 ] ) <NEWLINE> n = int ( first_input [ 1 ] ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> second_input = map ( int , input ( ) . split ( ) ) <NEWLINE> p_a = list ( map ( int , second_input ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> second_input = input ( ) <NEWLINE> <NL> <DEDENT> def create_full_array ( minimum , maximum ) : <NEWLINE> <INDENT> full_list = [ ] <NEWLINE> for i in range ( minimum , maximum + 1 ) : <NEWLINE> <INDENT> full_list . append ( int ( i ) ) <NEWLINE> <DEDENT> return full_list <NEWLINE> <NL> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif x > max ( p_a ) + 1 or x < min ( p_a ) : <NEWLINE> <INDENT> ans = x - 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif x == max ( p_a ) + 1 : <NEWLINE> <INDENT> ans = x + 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> full_array = create_full_array ( min ( p_a ) , max ( p_a ) ) <NEWLINE> if x in p_a : <NEWLINE> <INDENT> target_list = list ( set ( p_a ) ^ set ( full_array ) ) <NEWLINE> abs_key = { } <NEWLINE> if len ( target_list ) == 0 : <NEWLINE> <INDENT> if abs ( x - min ( p_a ) ) <= abs ( x - max ( p_a ) ) : <NEWLINE> <INDENT> print ( min ( p_a ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( p_a ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in target_list : <NEWLINE> <INDENT> abs_key [ i ] = abs ( x - i ) <NEWLINE> <DEDENT> minimum = min ( abs_key . values ( ) ) <NEWLINE> t_k = [ ] <NEWLINE> t_v = [ ] <NEWLINE> [ t_k . append ( k ) for k , v in abs_key . items ( ) if v == minimum ] <NEWLINE> print ( min ( t_k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def dfs ( x , s ) : <NEWLINE> <INDENT> used = { s } <NEWLINE> search = deque ( [ s ] ) <NEWLINE> while search : <NEWLINE> <INDENT> ss = search . pop ( ) <NEWLINE> for sss in x [ ss ] : <NEWLINE> <INDENT> if sss in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used . add ( sss ) <NEWLINE> search . append ( sss ) <NEWLINE> <DEDENT> <DEDENT> return used <NEWLINE> <NL> <NL> <DEDENT> def bellmanford ( edges ) : <NEWLINE> <INDENT> coins = [ - float ( <STRING> ) ] * N <NEWLINE> coins [ 0 ] = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> f = True <NEWLINE> for u , v , c in edges : <NEWLINE> <INDENT> if coins [ u ] + c > coins [ v ] : <NEWLINE> <INDENT> coins [ v ] = coins [ u ] + c <NEWLINE> f = False <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> return max ( 0 , coins [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> N , M , P = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC = [ ] <NEWLINE> Adake = [ [ ] for _ in range ( N ) ] <NEWLINE> Bdake = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC . append ( ( A - 1 , B - 1 , C - P ) ) <NEWLINE> Adake [ A - 1 ] . append ( B - 1 ) <NEWLINE> Bdake [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> U = dfs ( Adake , 0 ) & dfs ( Bdake , N - 1 ) <NEWLINE> ABC = [ ( a , b , c ) for ( a , b , c ) in ABC if a in U and b in U ] <NEWLINE> <NL> print ( bellmanford ( ABC ) ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> sum = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> M = max ( A ) <NEWLINE> B = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> B [ a ] += 1 <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> if B [ a ] > 0 : <NEWLINE> <INDENT> i = 2 <NEWLINE> b = a * i <NEWLINE> while b <= M : <NEWLINE> <INDENT> B [ b ] = 0 <NEWLINE> i += 1 <NEWLINE> b = a * i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( M + 1 ) : <NEWLINE> <INDENT> if B [ i ] > 1 : <NEWLINE> <INDENT> B [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( B ) ) <NEWLINE>
from collections import OrderedDict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> N , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connection = { i : set ( ) for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connection [ a ] . add ( b ) <NEWLINE> connection [ b ] . add ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> point = { i : 0 for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> p , x = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> point [ p ] += x <NEWLINE> <NL> <DEDENT> def DFS ( now , prev = - 1 ) : <NEWLINE> <INDENT> for next in connection [ now ] : <NEWLINE> <INDENT> if next == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> DFS ( next , now ) <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( 1 ) <NEWLINE> print ( * point . values ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = 2 * y - x <NEWLINE> b = 2 * x - y <NEWLINE> <NL> fac_l = [ 0 ] * ( int ( ( a + b ) / 3 ) + 1 ) <NEWLINE> inv_l = [ 0 ] * ( int ( ( a + b ) / 3 ) + 1 ) <NEWLINE> finv_l = [ 0 ] * ( int ( ( a + b ) / 3 ) + 1 ) <NEWLINE> <NL> <NL> def com_init ( ) : <NEWLINE> <INDENT> fac_l [ 1 ] = 1 <NEWLINE> inv_l [ 0 ] = 1 <NEWLINE> inv_l [ 1 ] = 1 <NEWLINE> finv_l [ 0 ] = 1 <NEWLINE> finv_l [ 1 ] = 1 <NEWLINE> for i in range ( 2 , a + b + 1 ) : <NEWLINE> <INDENT> fac_l [ i ] = ( fac_l [ i - 1 ] * i ) % MOD <NEWLINE> inv_l [ i ] = MOD - ( inv_l [ MOD % i ] * int ( MOD / i ) ) % MOD <NEWLINE> finv_l [ i ] = ( finv_l [ i - 1 ] * inv_l [ i ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> def ncr ( n , r ) : <NEWLINE> <INDENT> return ( fac_l [ n ] * ( finv_l [ r ] * finv_l [ n - r ] ) % MOD ) % MOD <NEWLINE> <NL> <NL> <DEDENT> if a % 3 != 0 or b % 3 != 0 or a < 0 or b < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( a / 3 ) <NEWLINE> b = int ( b / 3 ) <NEWLINE> <NL> com_init ( ) <NEWLINE> print ( ncr ( a + b , a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> x = p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x >= p [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = p [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mat = np . array ( [ [ False ] * N for i in range ( K ) ] ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> mat [ i ] [ a [ j ] - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> mat = mat . T <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> flg = False <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> if mat [ i ] [ j ] : <NEWLINE> <INDENT> flg = True <NEWLINE> <NL> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xyh = [ ] <NEWLINE> x0 , y0 , h0 = None , None , None <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if h > 0 and x0 is None : <NEWLINE> <INDENT> x0 , y0 , h0 = x , y , h <NEWLINE> <DEDENT> xyh . append ( [ x , y , h ] ) <NEWLINE> <NL> <DEDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> h = h0 + abs ( x0 - cx ) + abs ( y0 - cy ) <NEWLINE> done = True <NEWLINE> for xk , yk , hk in xyh : <NEWLINE> <INDENT> h_ = max ( h - abs ( xk - cx ) - abs ( yk - cy ) , 0 ) <NEWLINE> if h_ != hk : <NEWLINE> <INDENT> done = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if done : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import dataclasses <NEWLINE> n , a , b , c = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> m = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> h = <STRING> <NEWLINE> if sum ( m . values ( ) ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sum ( m . values ( ) ) == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> x , y = input ( ) <NEWLINE> if m [ x ] == 0 and m [ y ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif m [ x ] == 0 : <NEWLINE> <INDENT> m [ x ] += 1 <NEWLINE> m [ y ] -= 1 <NEWLINE> h += x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ x ] -= 1 <NEWLINE> m [ y ] += 1 <NEWLINE> h += y <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> [ print ( i ) for i in h ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> x , y = inp <NEWLINE> if m [ x ] == 0 and m [ y ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> next_inp = input ( ) <NEWLINE> x , y = inp <NEWLINE> if m [ x ] == 0 : <NEWLINE> <INDENT> m [ x ] += 1 <NEWLINE> m [ y ] -= 1 <NEWLINE> h += x <NEWLINE> <DEDENT> elif m [ y ] == 0 : <NEWLINE> <INDENT> m [ x ] -= 1 <NEWLINE> m [ y ] += 1 <NEWLINE> h += y <NEWLINE> <DEDENT> elif m [ x ] == 1 and m [ y ] == 1 : <NEWLINE> <INDENT> if x in next_inp : <NEWLINE> <INDENT> m [ x ] += 1 <NEWLINE> m [ y ] -= 1 <NEWLINE> h += x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ x ] -= 1 <NEWLINE> m [ y ] += 1 <NEWLINE> h += y <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if m [ x ] < m [ y ] : <NEWLINE> <INDENT> m [ x ] += 1 <NEWLINE> m [ y ] -= 1 <NEWLINE> h += x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ x ] -= 1 <NEWLINE> m [ y ] += 1 <NEWLINE> h += y <NEWLINE> <DEDENT> <DEDENT> inp = next_inp <NEWLINE> <DEDENT> x , y = inp <NEWLINE> h += x if m [ x ] == 0 else y <NEWLINE> print ( <STRING> ) <NEWLINE> [ print ( i ) for i in h ] <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> ma = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] < ma : <NEWLINE> <INDENT> count += ma - a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math <NEWLINE> import sys <NEWLINE> from collections import deque <NEWLINE> import heapq <NEWLINE> import copy <NEWLINE> import itertools <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> import bisect <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def i ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> a , b = mi ( ) <NEWLINE> l = [ [ ] for i in range ( a ) ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> x , y = mi ( ) <NEWLINE> l [ x - 1 ] . append ( y - 1 ) <NEWLINE> l [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> lst = [ - 1 ] * a <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> s = q . popleft ( ) <NEWLINE> for j in l [ s ] : <NEWLINE> <INDENT> if lst [ j ] == - 1 : <NEWLINE> <INDENT> lst [ j ] = s <NEWLINE> q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for k in range ( a - 1 ) : <NEWLINE> <INDENT> print ( lst [ k + 1 ] + 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> L . append ( ( ord ( <STRING> ) - ord ( s [ i ] ) + 1 ) ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif k - L [ i ] >= 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> k -= L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> k = k % 26 <NEWLINE> ans = ans [ : - 1 ] + chr ( ord ( ans [ - 1 ] ) + k ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> <NL> m = map ( int , read ( ) . split ( ) ) <NEWLINE> A , B = zip ( * zip ( m , m ) ) <NEWLINE> A = np . array ( A [ : : - 1 ] ) <NEWLINE> B = np . array ( B [ : : - 1 ] ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> acc = B [ i ] - A [ i ] % B [ i ] if A [ i ] % B [ i ] != 0 else 0 <NEWLINE> A [ i : ] += acc <NEWLINE> cnt += acc <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10000000000 <NEWLINE> expList = [ INF ] * 1001 <NEWLINE> def expectationF ( num ) : <NEWLINE> <INDENT> if expList [ num ] == INF : <NEWLINE> <INDENT> exp = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> exp += i / num <NEWLINE> <DEDENT> expList [ num ] = exp <NEWLINE> <DEDENT> return expList [ num ] <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> mid = 0 <NEWLINE> midList = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i >= 1 : <NEWLINE> <INDENT> midList . append ( expectationF ( List [ i ] ) + midList [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> midList . append ( expectationF ( List [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> m = K - 1 <NEWLINE> for j in range ( N - m ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> mid = midList [ j + m ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mid = midList [ j + m ] - midList [ j - 1 ] <NEWLINE> <DEDENT> res = max ( res , mid ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> s = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s -= A [ i ] <NEWLINE> ans += ( A [ i ] * s ) % mod <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
from collections import Counter <NEWLINE> S = input ( ) <NEWLINE> S = S + <STRING> <NEWLINE> mod = 2019 <NEWLINE> p = [ 0 ] * mod <NEWLINE> r = 0 <NEWLINE> d = 1 <NEWLINE> for s in reversed ( S ) : <NEWLINE> <INDENT> t = int ( s ) % mod <NEWLINE> r += t * d <NEWLINE> r %= mod <NEWLINE> d = d * 10 % mod <NEWLINE> p [ r ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( sum ( [ i * ( i - 1 ) // 2 for i in p ] ) ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> Flag = True <NEWLINE> for T in range ( 0 , min ( K , len ( S ) ) ) : <NEWLINE> <INDENT> if S [ T ] != <STRING> : <NEWLINE> <INDENT> Disp = S [ T ] <NEWLINE> Flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Flag : print ( <STRING> ) <NEWLINE> else : print ( Disp ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) [ : : - 1 ] <NEWLINE> <NL> counts = [ 0 ] * 2019 <NEWLINE> counts [ 0 ] = 1 <NEWLINE> res , digit = 0 , 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> res += int ( i ) * digit <NEWLINE> res %= 2019 <NEWLINE> digit *= 10 <NEWLINE> digit %= 2019 <NEWLINE> counts [ res ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in counts : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> Acount = Counter ( A ) <NEWLINE> Adic = dict ( Acount ) <NEWLINE> Akey = set ( Adic . keys ( ) ) <NEWLINE> M = max ( A ) <NEWLINE> L = [ 0 for i in range ( 10 ** 5 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if i + 1 in Akey : <NEWLINE> <INDENT> L [ i ] = Adic [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s += ( i + 1 ) * L [ i ] <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( c - b ) * L [ b - 1 ] <NEWLINE> L [ c - 1 ] += L [ b - 1 ] <NEWLINE> L [ b - 1 ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def popcnt_int ( n ) : <COMMENT> <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def popcnt_bin ( s ) : <COMMENT> <NEWLINE> <INDENT> return s . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def poptimes ( n , cnt = 1 ) : <COMMENT> <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n %= popcnt_int ( n ) <NEWLINE> cnt += 1 <NEWLINE> return poptimes ( n , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> s_int = int ( s , 2 ) <NEWLINE> pc = popcnt_bin ( s ) <NEWLINE> pc_plus = s_int % ( pc + 1 ) <NEWLINE> if pc != 1 : <NEWLINE> <INDENT> pc_minus = s_int % ( pc - 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if pc != 1 : <NEWLINE> <INDENT> tmp = pc_minus - pow ( 2 , n - i - 1 , pc - 1 ) <NEWLINE> print ( poptimes ( tmp % ( pc - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = pc_plus + pow ( 2 , n - i - 1 , pc + 1 ) <NEWLINE> print ( poptimes ( tmp % ( pc + 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import groupby <NEWLINE> from math import ceil <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> block = [ sum ( 1 for _ in it ) for k , it in groupby ( s ) ] <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> block . insert ( 0 , 0 ) <NEWLINE> <NL> <DEDENT> m = len ( block ) <NEWLINE> left , right = 0 , 2 * k <NEWLINE> res = val = sum ( block [ left : right - 1 ] ) <NEWLINE> while right <= m : <NEWLINE> <INDENT> val += block [ right - 1 ] if right == m else block [ right - 1 ] + block [ right ] <NEWLINE> res = max ( res , val ) <NEWLINE> val -= block [ left ] + block [ left + 1 ] <NEWLINE> left += 2 <NEWLINE> right += 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> max_diff = - 20 ** 9 <NEWLINE> minv = 20 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> max_diff = max ( max_diff , r - minv ) <NEWLINE> minv = min ( minv , r ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( max_diff ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> print ( ( <STRING> * w + <STRING> ) * h ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = np . zeros ( n , dtype = int ) <NEWLINE> b = np . zeros ( n , dtype = int ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> a0cen = a [ ( n - 1 ) // 2 ] <NEWLINE> b0cen = b [ ( n - 1 ) // 2 ] <NEWLINE> nn = b0cen - a0cen + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a0cen1 = a [ ( n - 2 ) // 2 ] + a [ n // 2 ] <NEWLINE> b0cen1 = b [ ( n - 2 ) // 2 ] + b [ n // 2 ] <NEWLINE> nn = int ( b0cen1 - a0cen1 + 1 ) <NEWLINE> <NL> <DEDENT> print ( nn ) <NEWLINE>
import heapq <NEWLINE> <NL> <NL> hq = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( hq , - int ( cmd [ 1 ] ) ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( - heapq . heappop ( hq ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( c [ <STRING> . format ( i + 1 ) ] ) <NEWLINE> <DEDENT>
MOD = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ns = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( k ) ] <NEWLINE> <NL> dp = [ 0 for j in range ( n + 1 ) ] <NEWLINE> cum = [ 0 for j in range ( n + 1 ) ] <NEWLINE> dp [ 1 ] = 1 <NEWLINE> cum [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> l , r = ns [ j ] <NEWLINE> if i - l >= 0 : <NEWLINE> <INDENT> dp [ i ] += cum [ i - l ] <NEWLINE> <DEDENT> if i - ( r + 1 ) >= 0 : <NEWLINE> <INDENT> dp [ i ] -= cum [ i - ( r + 1 ) ] <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = ( dp [ i ] % MOD + MOD ) % MOD <NEWLINE> cum [ i ] = ( cum [ i - 1 ] + dp [ i ] ) % MOD <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cycle = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> cycle . append ( - 1 ) <NEWLINE> A [ i ] -= 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> cycle [ 0 ] = count <NEWLINE> town = 0 <NEWLINE> mod = 0 <NEWLINE> while True : <NEWLINE> <INDENT> count += 1 <NEWLINE> K -= 1 <NEWLINE> town = A [ town ] <NEWLINE> if K == 0 : <NEWLINE> <INDENT> mod = 1 <NEWLINE> break <NEWLINE> <DEDENT> if cycle [ town ] == - 1 : <NEWLINE> <INDENT> cycle [ town ] = count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = count - cycle [ town ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> K %= mod <NEWLINE> while K > 0 : <NEWLINE> <INDENT> town = A [ town ] <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> print ( town + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = 1 <NEWLINE> if l . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> v *= l [ i ] <NEWLINE> if v > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( v ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N , S = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> An = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> dp = np . zeros ( ( S + 1 ) , dtype = int ) <NEWLINE> dp [ 0 ] = 2 <NEWLINE> if An [ 0 ] <= S : <NEWLINE> <INDENT> dp [ An [ 0 ] ] = 1 <NEWLINE> <NL> <DEDENT> for n in range ( 1 , N ) : <NEWLINE> <INDENT> dp *= 2 <NEWLINE> dp [ An [ n ] : ] += dp [ : - An [ n ] ] // 2 <NEWLINE> dp %= 998244353 <NEWLINE> <NL> <DEDENT> print ( dp [ S ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> inf = 1 << 30 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N , M , s = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> Adj = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ui , vi , ci = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> Adj [ ui ] . append ( ( vi , ci ) ) <NEWLINE> <NL> <DEDENT> d = dijkstra ( N , Adj , s ) <NEWLINE> <NL> for di in d : <NEWLINE> <INDENT> print ( di if di < inf else <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dijkstra ( N , Adj , s ) : <NEWLINE> <INDENT> d = [ inf ] * N <NEWLINE> d [ s ] = 0 <NEWLINE> pq = [ ( 0 , s ) ] <NEWLINE> fixed = 0 <NEWLINE> <NL> while pq : <NEWLINE> <INDENT> di , v = heappop ( pq ) <NEWLINE> <NL> if di > d [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for u , c in Adj [ v ] : <NEWLINE> <INDENT> if d [ v ] + c < d [ u ] : <NEWLINE> <INDENT> d [ u ] = d [ v ] + c <NEWLINE> heappush ( pq , ( d [ u ] , u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> fixed += 1 <NEWLINE> <NL> if fixed == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> k = d <NEWLINE> <NL> if ( a - k > 0 ) : <NEWLINE> <NL> <INDENT> print ( k ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> k = d - a <NEWLINE> <NL> if ( b - k > 0 ) : <NEWLINE> <NL> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> k = d - a - b <NEWLINE> <NL> print ( a - k ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 in a <NEWLINE> c = 1 <NEWLINE> d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = c * a [ i ] <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> d = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if c <= 1000000000000000000 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> if d == 1 : <NEWLINE> <INDENT> if b == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> for i in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> done = [ - 1 for _ in range ( N ) ] <NEWLINE> done [ 0 ] = 0 <NEWLINE> n = 0 <NEWLINE> now = 0 <NEWLINE> init = 0 <NEWLINE> loop = N <NEWLINE> log = [ 0 ] <NEWLINE> <NL> while n < N : <NEWLINE> <INDENT> log . append ( A [ log [ - 1 ] ] - 1 ) <NEWLINE> n += 1 <NEWLINE> if done [ log [ - 1 ] ] > - 1 : <NEWLINE> <INDENT> init = done [ log [ - 1 ] ] <NEWLINE> loop = n - done [ log [ - 1 ] ] <NEWLINE> break <NEWLINE> <DEDENT> done [ log [ - 1 ] ] = n <NEWLINE> <NL> <DEDENT> if K < init : <NEWLINE> <INDENT> print ( log [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = init + ( K - init ) % loop <NEWLINE> print ( log [ num ] + 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def check ( x ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += a [ i ] // x <NEWLINE> if a [ i ] % x == 0 : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <DEDENT> <DEDENT> if c <= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> mx = max ( a ) <NEWLINE> mn = 0 <NEWLINE> ans = [ mx ] <NEWLINE> while mn <= mx : <NEWLINE> <INDENT> m = ( mx + mn ) // 2 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> if check ( 1 ) : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if check ( m ) : <NEWLINE> <INDENT> mx = m - 1 <NEWLINE> ans . append ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mn = m + 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_list = [ A for A in input ( ) . split ( ) ] <NEWLINE> A_list = list ( map ( int , A_list ) ) <NEWLINE> <COMMENT> <NL> ans = Counter ( A_list ) <NEWLINE> <NL> for n_cycle in range ( N ) : <NEWLINE> <INDENT> n_cycle = n_cycle + 1 <NEWLINE> <COMMENT> <NL> print ( ans [ n_cycle ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dp = [ 1 for i in range ( n + 2 ) ] <NEWLINE> dp [ 0 ] = dp [ 1 ] = dp [ 2 ] = 0 <NEWLINE> modd = 1e9 + 7 <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> for j in range ( 3 , n - i + 1 ) : <NEWLINE> <INDENT> dp [ i + j ] = ( dp [ i + j ] + dp [ i ] ) % modd <NEWLINE> <DEDENT> <DEDENT> print ( int ( dp [ n ] ) ) <NEWLINE>
limit = pow ( 10 , 7 ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> num = <STRING> <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( 1 , limit + 1 ) : <NEWLINE> <INDENT> total = ( total * 10 + 7 ) % K <NEWLINE> if total == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from heapq import heappop , heappush <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> pq = [ ] <COMMENT> <NEWLINE> entry_finder = { } <COMMENT> <NEWLINE> REMOVED = float ( <STRING> ) <COMMENT> <NEWLINE> <NL> def add_team ( score , team ) : <NEWLINE> <INDENT> if team in entry_finder : <NEWLINE> <INDENT> remove_team ( team ) <NEWLINE> <DEDENT> entry = [ - score , team ] <NEWLINE> entry_finder [ team ] = entry <NEWLINE> heappush ( pq , entry ) <NEWLINE> <NL> <DEDENT> def remove_team ( team ) : <NEWLINE> <INDENT> entry = entry_finder . pop ( team ) <NEWLINE> entry [ - 1 ] = REMOVED <NEWLINE> <NL> <DEDENT> def pop_team ( ) : <NEWLINE> <INDENT> while pq : <NEWLINE> <INDENT> score , team = heappop ( pq ) <NEWLINE> if team is not REMOVED : <NEWLINE> <INDENT> del entry_finder [ team ] <NEWLINE> return score , team <NEWLINE> <DEDENT> <DEDENT> raise KeyError ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> N , R , L = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> on_tv = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> scores = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> add_team ( 0 , 1 ) <NEWLINE> <NL> last_time = 0 <NEWLINE> need_pop = True <NEWLINE> top_score = 0 <NEWLINE> <NL> for i in range ( R ) : <NEWLINE> <INDENT> d , t , x = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if need_pop : <NEWLINE> <INDENT> need_pop = False <NEWLINE> top_score , team = pop_team ( ) <NEWLINE> if d != team : <NEWLINE> <INDENT> add_team ( scores [ team ] , team ) <NEWLINE> <NL> <DEDENT> <DEDENT> on_tv [ team ] += ( t - last_time ) <NEWLINE> <NL> scores [ d ] += x <NEWLINE> add_team ( scores [ d ] , d ) <NEWLINE> if x > 0 and scores [ d ] > top_score : <NEWLINE> <INDENT> need_pop = True <NEWLINE> <NL> <DEDENT> last_time = t <NEWLINE> <NL> <DEDENT> t = L <NEWLINE> score , team = pop_team ( ) <NEWLINE> on_tv [ team ] += ( t - last_time ) <NEWLINE> <NL> print ( on_tv . index ( max ( on_tv ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
l = list ( input ( ) ) <NEWLINE> h = [ 0 ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> h . append ( h [ i ] - 1 ) <NEWLINE> <DEDENT> elif l [ i ] == <STRING> : <NEWLINE> <INDENT> h . append ( h [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h . append ( h [ i ] ) <NEWLINE> <DEDENT> <DEDENT> A = 0 <NEWLINE> k = 0 <NEWLINE> L = [ ] <NEWLINE> i = 0 <NEWLINE> if <STRING> . join ( l [ 5 : 65 ] ) + ( <STRING> ) == <STRING> and <STRING> . join ( l [ 1 : 61 ] ) + ( <STRING> ) != <STRING> : <NEWLINE> <INDENT> print ( <STRING> + <STRING> + <STRING> + <STRING> + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> and h [ i ] <= max ( h [ i + 1 : len ( l ) + 2 ] ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> a = h [ i ] <NEWLINE> s += 0.5 <NEWLINE> i += 1 <NEWLINE> while h [ i ] < a : <NEWLINE> <INDENT> s += a - ( h [ i ] + h [ i + 1 ] ) * 0.5 <NEWLINE> i += 1 <NEWLINE> <DEDENT> A += int ( s ) <NEWLINE> k += 1 <NEWLINE> L . append ( int ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE> print ( k , end = <STRING> ) <NEWLINE> if len ( L ) > 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , L ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_list = [ 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> ans_list [ a - 1 ] = 0 <NEWLINE> <DEDENT> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> ans_list [ b - 1 ] = 0 <NEWLINE> <DEDENT> if H [ a - 1 ] == H [ b - 1 ] : <NEWLINE> <INDENT> ans_list [ a - 1 ] = 0 <NEWLINE> ans_list [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans_list ) ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for n in T : <NEWLINE> <INDENT> m = bisect . bisect_right ( S , n ) <NEWLINE> if m > 0 and S [ m - 1 ] == n : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if ( s == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = copy . copy ( a ) <NEWLINE> ans = [ ] <NEWLINE> num = 1 <NEWLINE> count = 0 <NEWLINE> while num != n : <NEWLINE> <INDENT> if max ( a ) < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ num - 1 ] > a [ num ] : <NEWLINE> <INDENT> a2 = copy . copy ( a ) <NEWLINE> a2 . sort ( ) <NEWLINE> temp = a [ num - 1 ] - a [ num ] <NEWLINE> temp2 = bisect . bisect_left ( a2 , temp ) <NEWLINE> if temp2 == n : <NEWLINE> <INDENT> temp2 -= 1 <NEWLINE> <DEDENT> ans . append ( [ a . index ( a2 [ temp2 ] ) + 1 , num + 1 ] ) <NEWLINE> a [ num ] += a2 [ temp2 ] <NEWLINE> count += 1 <NEWLINE> if count == n * 2 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> num += 1 <NEWLINE> if count == n * 2 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans2 = [ ] <NEWLINE> num = n - 2 <NEWLINE> count2 = 0 <NEWLINE> while num != - 1 : <NEWLINE> <INDENT> if min ( b ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ num ] > b [ num + 1 ] : <NEWLINE> <INDENT> b2 = copy . copy ( b ) <NEWLINE> b2 . sort ( ) <NEWLINE> temp = b [ num + 1 ] - b [ num ] <NEWLINE> temp2 = bisect . bisect_right ( b2 , temp ) <NEWLINE> if temp2 == 0 : <NEWLINE> <INDENT> temp2 += 1 <NEWLINE> <DEDENT> ans2 . append ( [ b . index ( b2 [ temp2 - 1 ] ) + 1 , num + 1 ] ) <NEWLINE> b [ num ] += b2 [ temp2 - 1 ] <NEWLINE> count2 += 1 <NEWLINE> if count2 == n * 2 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> num -= 1 <NEWLINE> if count2 == n * 2 + 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( ans ) == 0 and len ( ans2 ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif len ( ans ) == 0 : <NEWLINE> <INDENT> print ( len ( ans2 ) ) <NEWLINE> for i in ans2 : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif len ( ans2 ) == 0 : <NEWLINE> <INDENT> print ( len ( ans ) ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( ans ) > len ( ans2 ) : <NEWLINE> <INDENT> print ( len ( ans2 ) ) <NEWLINE> for i in ans2 : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( ans ) ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
house = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> house [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> house [ b ] [ f ] = <STRING> + <STRING> . join ( map ( str , house [ b ] [ f ] ) ) <NEWLINE> <DEDENT> house [ b ] = <STRING> . join ( map ( str , house [ b ] ) ) + <STRING> <NEWLINE> <DEDENT> border = <STRING> * 20 + <STRING> <NEWLINE> house = border . join ( map ( str , house ) ) <NEWLINE> print ( house . rstrip ( ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> import collections <NEWLINE> listB = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> listC = collections . Counter ( listB ) <NEWLINE> for i in range ( 1 , A + 1 ) : <NEWLINE> <INDENT> print ( listC [ i ] ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> if i != n : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> f = math . gcd ( i , j ) <NEWLINE> ans += f * 6 <NEWLINE> if j != n : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( f , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 1 <NEWLINE> min_P = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if P [ i ] < min_P : <NEWLINE> <INDENT> min_P = P [ i ] <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
def lcs_len ( x , y ) : <NEWLINE> <INDENT> ly = len ( y ) <NEWLINE> tcsl = [ 0 ] * ( ly + 1 ) <NEWLINE> for x_i in x : <NEWLINE> <INDENT> pre_tcsl = list ( tcsl ) <NEWLINE> for j in range ( ly ) : <NEWLINE> <INDENT> if x_i == y [ j ] : <NEWLINE> <INDENT> tcsl [ j ] = pre_tcsl [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif tcsl [ j ] < tcsl [ j - 1 ] : <NEWLINE> <INDENT> tcsl [ j ] = tcsl [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( tcsl [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ax = input ( ) <NEWLINE> ay = input ( ) <NEWLINE> lcs_len ( ax , ay ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> numbers = input ( ) . split ( ) <NEWLINE> zero = <STRING> in numbers <NEWLINE> if zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> num = int ( numbers [ j ] ) <NEWLINE> ans = ans * num <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> d = [ 0 ] * 20002 <NEWLINE> for i in range ( h ) : d [ i ] = min ( d [ i - a ] + b for a , b in c ) <NEWLINE> print ( d [ h - 1 ] ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> g = None <NEWLINE> memo = None <NEWLINE> <NL> <NL> def f ( x ) : <NEWLINE> <INDENT> if memo [ x ] == - 1 : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for y in g [ x ] : <NEWLINE> <INDENT> ret = max ( ret , f ( y ) + 1 ) <NEWLINE> <DEDENT> memo [ x ] = ret <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <NL> <DEDENT> def resolve ( in_ ) : <NEWLINE> <INDENT> global g , memo <NEWLINE> n , m = map ( int , next ( in_ ) . split ( ) ) <NEWLINE> _g = defaultdict ( list ) <NEWLINE> for line in in_ : <NEWLINE> <INDENT> x , y = map ( int , line . split ( ) ) <NEWLINE> _g [ x - 1 ] . append ( y - 1 ) <NEWLINE> <DEDENT> g = _g <NEWLINE> memo = [ - 1 ] * 100000 <NEWLINE> return max ( f ( i ) for i in range ( n ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> ans = resolve ( sys . stdin . buffer ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> Ca = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> pattern = [ ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> lis = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> lis . append ( Ca [ j ] ) <NEWLINE> <DEDENT> <DEDENT> pattern . append ( lis ) <NEWLINE> <NL> <DEDENT> cnt = [ ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> g = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( len ( pattern [ i ] ) ) : <NEWLINE> <INDENT> for k in range ( M + 1 ) : <NEWLINE> <INDENT> g [ k ] += pattern [ i ] [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> if M == 1 and g [ 1 ] < X : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif M > 1 and min ( g [ 1 : M + 1 ] ) < X : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt . append ( g [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( cnt ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( cnt ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if v <= N : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
abcd = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_pro = - float ( <STRING> ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , 3 ) : <NEWLINE> <INDENT> product = abcd [ i ] * abcd [ - j ] <NEWLINE> if max_pro < product : <NEWLINE> <INDENT> max_pro = product <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_pro ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> p = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> p *= a <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if K . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> burst = False <NEWLINE> for k in K : <NEWLINE> <INDENT> ans *= k <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> burst = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if burst : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = np . gcd ( a , b ) <NEWLINE> if d == 1 : <NEWLINE> <INDENT> ans += n <NEWLINE> continue <NEWLINE> <DEDENT> if d == 2 : <NEWLINE> <INDENT> ans += n // 2 * 3 + n % 2 <NEWLINE> continue <NEWLINE> <DEDENT> if d == 3 : <NEWLINE> <INDENT> ans += n // 3 * 5 + n % 3 <NEWLINE> continue <NEWLINE> <DEDENT> if d == 5 : <NEWLINE> <INDENT> ans += n // 5 * 9 + n % 5 <NEWLINE> continue <NEWLINE> <DEDENT> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += np . gcd ( c , d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> def is_ok ( i ) : <NEWLINE> <INDENT> su = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> su += ( a - 1 ) // i <NEWLINE> <DEDENT> if su <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def meguru_bisect ( ng , ok ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> print ( meguru_bisect ( 0 , max ( A ) + 1 ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( <STRING> . join ( sorted ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ma [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( len ( ma ) ) : <NEWLINE> <INDENT> print ( ma [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from itertools import combinations_with_replacement <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> abcd [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cmb = combinations_with_replacement ( [ i for i in range ( 1 , m + 1 ) ] , n ) <NEWLINE> all_array = list ( cmb ) <NEWLINE> <STRING> <NEWLINE> <COMMENT> <NL> ans = 0 <COMMENT> <NEWLINE> for arr in all_array : <NEWLINE> <INDENT> val = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if arr [ abcd [ j ] [ 1 ] - 1 ] - arr [ abcd [ j ] [ 0 ] - 1 ] == abcd [ j ] [ 2 ] : <NEWLINE> <INDENT> val += abcd [ j ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , val ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> mod = 998244353 <NEWLINE> <NL> dp = [ 0 for _ in range ( 2 * N + 1 ) ] <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> cum = [ 0 for _ in range ( 2 * N + 1 ) ] <NEWLINE> cum [ 1 ] = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for l , r in S : <NEWLINE> <INDENT> dp [ i + 1 ] += cum [ i - l + 1 ] - cum [ i - r ] <NEWLINE> dp [ i + 1 ] %= mod <NEWLINE> <DEDENT> cum [ i + 1 ] = cum [ i ] + dp [ i + 1 ] <NEWLINE> cum [ i + 1 ] %= mod <NEWLINE> <DEDENT> print ( dp [ N ] ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> vis = k <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> vis = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vis = a + ( - 1 * ( k - a - b ) ) <NEWLINE> <NL> <DEDENT> print ( vis ) <NEWLINE>
N = input ( ) <NEWLINE> c = input ( ) <NEWLINE> <NL> N = int ( N ) <NEWLINE> <NL> n_r = c . count ( <STRING> ) <NEWLINE> print ( c [ n_r : ] . count ( <STRING> ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import heapq <NEWLINE> <NL> <NL> class PQueue ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . pqueue = [ ] <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> heapq . heappush ( self . pqueue , - x ) <NEWLINE> <NL> <DEDENT> def extractMax ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - heapq . heappop ( self . pqueue ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> pqueue = PQueue ( ) <NEWLINE> result = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if line . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> pqueue . insert ( int ( line . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif line . split ( ) [ 0 ] == <STRING> : <NEWLINE> <INDENT> result . append ( pqueue . extractMax ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( result ) ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> AR = n + 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> def calc_ans ( AR , i ) : <NEWLINE> <INDENT> max = AR * ( AR - 1 ) / 2 - ( AR - i ) * ( AR - i - 1 ) / 2 <NEWLINE> min = i * ( i - 1 ) / 2 <NEWLINE> return max - min + 1 <NEWLINE> <NL> <DEDENT> for i in range ( k , AR + 1 ) : <NEWLINE> <INDENT> ans += calc_ans ( AR , i ) <NEWLINE> <NL> <DEDENT> print ( int ( ans % mod ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( N , k ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> p2 = 0 <NEWLINE> memo = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> p , p2 = p2 , k * ( p2 + 1 ) // ( k - 1 ) - 2 <NEWLINE> while p2 - 1 - p2 // k != p : <NEWLINE> <INDENT> p2 += 1 <NEWLINE> <DEDENT> <DEDENT> return p2 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , k = input ( ) . split ( ) <NEWLINE> print ( main ( int ( N ) , int ( k ) ) ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ( not uf . same ( i , i + 1 ) ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> uf . union ( i + 1 , i ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> n , h = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> maxa = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> maxa = max ( x , maxa ) <NEWLINE> b [ i ] = y <NEWLINE> <DEDENT> b . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] < maxa : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h -= b [ i ] <NEWLINE> ans += 1 <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not h <= 0 : <NEWLINE> <INDENT> ans += math . ceil ( h / maxa ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> P = sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> if <STRING> in P : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in P : <NEWLINE> <INDENT> ans *= int ( a ) <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> counter = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> str_i = str ( i ) <NEWLINE> i_dig = s . find ( str_i ) <NEWLINE> if i_dig == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> str_j = str ( j ) <NEWLINE> j_dig = s . find ( str_j , i_dig + 1 ) <NEWLINE> if j_dig == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> str_k = str ( k ) <NEWLINE> k_dig = s . find ( str_k , j_dig + 1 ) <NEWLINE> if k_dig != - 1 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) ; <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) ; <NEWLINE> <NL> ans = [ 0 ] * n ; <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> key = list ( c . keys ( ) ) ; <NEWLINE> value = list ( c . values ( ) ) ; <NEWLINE> <NL> for i in range ( len ( key ) ) : <NEWLINE> <INDENT> ans [ key [ i ] - 1 ] = value [ i ] ; <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) ; <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> c = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c [ i + 1 - a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cnt += c [ a [ i ] + i + 1 ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def process_command ( dll , commands ) : <NEWLINE> <COMMENT> <NL> <INDENT> for cmd in commands : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> try : <NEWLINE> <INDENT> cmd , num_str = cmd . split ( ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if cmd == <STRING> : <NEWLINE> <INDENT> dll . appendleft ( int ( num_str ) ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> if int ( num_str ) in dll : <COMMENT> <NEWLINE> <INDENT> temp = [ ] <NEWLINE> result = dll . popleft ( ) <NEWLINE> while result != int ( num_str ) : <NEWLINE> <INDENT> temp . append ( result ) <NEWLINE> result = dll . popleft ( ) <NEWLINE> <DEDENT> temp = temp [ : : - 1 ] <NEWLINE> dll . extendleft ( temp ) <NEWLINE> <DEDENT> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> commands = [ ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> commands = [ input ( ) for i in range ( num ) ] <NEWLINE> <NL> <COMMENT> <NL> dll = deque ( ) <NEWLINE> process_command ( dll , commands ) <NEWLINE> <NL> <COMMENT> <NL> print ( <STRING> . format ( <STRING> . join ( map ( str , dll ) ) ) ) <NEWLINE> <DEDENT>
SENTINEL = 1e+9 <NEWLINE> t = 0 <NEWLINE> <NL> <NL> def Merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global t <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L , R = A [ left : left + n1 ] , A [ mid : mid + n2 ] <NEWLINE> L . append ( SENTINEL ) <NEWLINE> R . append ( SENTINEL ) <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def Merge_Sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> Merge_Sort ( A , left , mid ) <NEWLINE> Merge_Sort ( A , mid , right ) <NEWLINE> Merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global t <NEWLINE> input ( ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Merge_Sort ( A , 0 , len ( A ) ) <NEWLINE> print ( * A ) <NEWLINE> print ( t ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> def fac ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : return False <NEWLINE> <NL> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif is_prime ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> P = fac ( n ) <NEWLINE> for p , _ in P : <NEWLINE> <INDENT> c = 1 <NEWLINE> while n % pow ( p , c ) == 0 : <NEWLINE> <INDENT> n /= pow ( p , c ) <NEWLINE> cnt += 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <COMMENT> <NL> c , d = [ ] , [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> c . append ( i ) <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ma = [ ] <NEWLINE> if b in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( c ) - len ( d ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for k in range ( len ( d ) ) : <NEWLINE> <INDENT> if c [ i : len ( d ) + i ] [ k ] != d [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> ma . append ( count ) <NEWLINE> <DEDENT> print ( min ( ma ) ) <NEWLINE> <DEDENT>
X , K , D = [ int ( a ) for a in list ( input ( ) . split ( ) ) ] <NEWLINE> X = abs ( X ) <NEWLINE> q = X // D <NEWLINE> r = X % D <NEWLINE> if q >= K : <NEWLINE> <INDENT> print ( X - D * K ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> rem = K - q <NEWLINE> if rem % 2 == 0 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( D - r ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = input ( ) . split ( ) <NEWLINE> <NL> answer = 1 <NEWLINE> <NL> sort = sorted ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> answer = answer * int ( sort [ i ] ) <NEWLINE> if answer == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> if answer > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = True <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> if p == 0 : <NEWLINE> <INDENT> print ( 2 ** n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ** ( n - 1 ) ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> tmp = [ ] <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp . append ( gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in tmp : <NEWLINE> <INDENT> ans += gcd ( i , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> cnt = 0 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> flg = False <COMMENT> <NEWLINE> if x == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for k in range ( 2 , math . floor ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if not ( x % k ) : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> N = int ( s . split ( ) [ 0 ] ) <NEWLINE> M = int ( s . split ( ) [ 1 ] ) <NEWLINE> <NL> H = input ( ) . split ( ) <NEWLINE> <NL> tenbo = list ( range ( 1 , N + 1 ) ) <NEWLINE> bad_tenbo = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> road = input ( ) . split ( ) <NEWLINE> A = int ( road [ 0 ] ) <NEWLINE> B = int ( road [ 1 ] ) <NEWLINE> HA = int ( H [ A - 1 ] ) <NEWLINE> HB = int ( H [ B - 1 ] ) <NEWLINE> if HA > HB : <NEWLINE> <INDENT> bad_tenbo . append ( B ) <NEWLINE> <DEDENT> elif HA == HB : <NEWLINE> <INDENT> bad_tenbo . append ( A ) <NEWLINE> bad_tenbo . append ( B ) <NEWLINE> <DEDENT> elif HA < HB : <NEWLINE> <INDENT> bad_tenbo . append ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = list ( set ( tenbo ) - set ( bad_tenbo ) ) <NEWLINE> <NL> print ( len ( result ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s = n // i * ( 1 + n // i ) * i / 2 <NEWLINE> ans += s <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> x = 7 % K <COMMENT> <NEWLINE> if K == 1 or K == 7 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> i = 0 <NEWLINE> while i < K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = ( x * 10 + 7 ) % K <NEWLINE> <NL> if x == 7 % K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> flg = 0 <NEWLINE> <NL> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if x % i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in range ( x ) : <NEWLINE> <INDENT> b = a - i <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> ans_a = a <NEWLINE> ans_b = b <NEWLINE> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif a > i and a ** 5 - b ** 5 > x : <NEWLINE> <INDENT> flg = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif flg == - 1 : <NEWLINE> <INDENT> flg = 0 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans_a , ans_b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> counters = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> part_of_s = s [ i : i + len ( t ) ] <NEWLINE> counter = 0 <NEWLINE> for sss , ttt in zip ( part_of_s , t ) : <NEWLINE> <INDENT> if sss != ttt : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> counters . append ( counter ) <NEWLINE> <DEDENT> print ( min ( counters ) ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> for i in range ( - 128 , 128 ) : <NEWLINE> <INDENT> for j in range ( - 128 , 128 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == num : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = <STRING> <NEWLINE> score = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> score += A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N - K ) : <NEWLINE> <INDENT> next_score = score + A [ K + i ] - A [ i ] <NEWLINE> print ( <STRING> if next_score > score else <STRING> ) <NEWLINE> score = next_score <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s [ 1 ] == <STRING> or s [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + s [ 0 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if ans [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif ans [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if i < len ( s ) - 1 : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + s [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if ( ( A_list [ i + K ] - A_list [ i ] ) > 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> N = k ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t = N // i <NEWLINE> count += i * t * ( t + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( count ) ) <NEWLINE>
<COMMENT> <NL> from collections import defaultdict , Counter <NEWLINE> from itertools import product , groupby , count , permutations , combinations <NEWLINE> from math import pi , sqrt <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect , bisect_left , bisect_right <NEWLINE> from string import ascii_lowercase <NEWLINE> from functools import lru_cache <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> YES , Yes , yes , NO , No , no = <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> dy4 , dx4 = [ 0 , 1 , 0 , - 1 ] , [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy8 , dx8 = [ 0 , - 1 , 0 , 1 , 1 , - 1 , - 1 , 1 ] , [ 1 , 0 , - 1 , 0 , 1 , 1 , - 1 , - 1 ] <NEWLINE> <NL> <NL> def inside ( y , x , H , W ) : <NEWLINE> <INDENT> return 0 <= y < H and 0 <= x < W <NEWLINE> <NL> <NL> <DEDENT> def ceil ( a , b ) : <NEWLINE> <INDENT> return ( a + b - 1 ) // b <NEWLINE> <NL> <NL> <DEDENT> def sum_of_arithmetic_progression ( s , d , n ) : <NEWLINE> <INDENT> return n * ( 2 * s + ( n - 1 ) * d ) // 2 <NEWLINE> <NL> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> return a / g * b <NEWLINE> <NL> <NL> <DEDENT> def dfs ( u , p , c , color , tree ) : <NEWLINE> <INDENT> color [ ( u , p ) ] = c <NEWLINE> color [ ( p , u ) ] = c <NEWLINE> <NL> now = 0 <NEWLINE> for v in tree [ u ] : <NEWLINE> <INDENT> if v == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if now == c : <NEWLINE> <INDENT> now += 1 <NEWLINE> <NL> <DEDENT> dfs ( v , u , now , color , tree ) <NEWLINE> now += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> edges = [ ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> tree [ A ] . append ( B ) <NEWLINE> tree [ B ] . append ( A ) <NEWLINE> edges . append ( ( A , B ) ) <NEWLINE> <NL> <DEDENT> color = dict ( ) <NEWLINE> dfs ( 0 , - 1 , - 1 , color , tree ) <NEWLINE> <NL> print ( max ( color . values ( ) ) + 1 ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> print ( color [ e ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> imo = [ ] <NEWLINE> xlmin = 0 <NEWLINE> xlmax = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> imo . append ( [ x - l , x + l - 1 ] ) <NEWLINE> <DEDENT> imo = sorted ( imo , key = lambda x : x [ 1 ] ) <NEWLINE> cnt = 1 <NEWLINE> ls = imo [ 0 ] [ 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if imo [ i ] [ 0 ] <= ls : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ls = imo [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> H = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x = list ( input ( ) . split ( ) ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> S . append ( int ( x [ 1 ] ) ) <NEWLINE> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> H . append ( int ( x [ 1 ] ) ) <NEWLINE> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> C . append ( int ( x [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( int ( x [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> def pr ( list , type ) : <NEWLINE> <INDENT> list . sort ( ) <NEWLINE> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if i not in list : <NEWLINE> <INDENT> print ( <STRING> . format ( type , i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> pr ( S , <STRING> ) <NEWLINE> pr ( H , <STRING> ) <NEWLINE> pr ( C , <STRING> ) <NEWLINE> pr ( D , <STRING> ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> arr = [ 0 ] * 1000 <NEWLINE> for i in p : <NEWLINE> <INDENT> arr [ i ] = 1 <NEWLINE> <NL> <DEDENT> ans1 = 0 <NEWLINE> for i in range ( x , - 1 , - 1 ) : <NEWLINE> <INDENT> if arr [ i ] == 0 : <NEWLINE> <INDENT> ans1 = i <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans2 = 0 <NEWLINE> for i in range ( x , 102 ) : <NEWLINE> <INDENT> if arr [ i ] == 0 : <NEWLINE> <INDENT> ans2 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if abs ( ans1 - x ) <= abs ( x - ans2 ) : <NEWLINE> <INDENT> print ( ans1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT>
def main ( n , a , b ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = a [ ( i - 1 ) % n ] + a [ ( i + 1 ) % n ] <NEWLINE> if m < a [ i ] and b [ i ] < a [ i ] : <NEWLINE> <INDENT> a [ i ] -= b [ i ] <NEWLINE> cnt += a [ i ] // m <NEWLINE> a [ i ] %= m <NEWLINE> a [ i ] += b [ i ] <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : break <NEWLINE> ans += cnt <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( n , a , b ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> inf = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> alst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> alst [ i ] [ i ] = inf <NEWLINE> <NL> <DEDENT> sm = 0 <NEWLINE> token = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if alst [ i ] [ k ] + alst [ k ] [ j ] > alst [ i ] [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif alst [ i ] [ k ] + alst [ k ] [ j ] == alst [ i ] [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> token = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sm += alst [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if token : sm = - 1 <NEWLINE> <NL> print ( sm ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> import itertools <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def gcd ( a , b , c ) : <NEWLINE> <INDENT> return math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) + 1 <NEWLINE> sum = 0 <NEWLINE> <NL> List = [ i for i in range ( 1 , K ) ] <NEWLINE> <NL> for v in itertools . combinations_with_replacement ( List , 3 ) : <NEWLINE> <INDENT> g = gcd ( v [ 0 ] , v [ 1 ] , v [ 2 ] ) <NEWLINE> if v [ 0 ] == v [ 1 ] and v [ 1 ] == v [ 2 ] : <NEWLINE> <INDENT> sum += g <NEWLINE> <DEDENT> elif v [ 0 ] == v [ 1 ] or v [ 0 ] == v [ 2 ] or v [ 1 ] == v [ 2 ] : <NEWLINE> <INDENT> sum += g * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += g * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
pi = 3.1415926535897 <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( pi * r ** 2 , 2 * pi * r ) <NEWLINE> <NL>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif K == 1 or K == 7 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = 7 <NEWLINE> i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if B == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = ( 10 * B + 7 ) % K <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> counter . append ( cnt ) <NEWLINE> print ( max ( counter ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> if i != k and i != j and j != k : <NEWLINE> <INDENT> t = 6 <NEWLINE> <DEDENT> elif ( i == j and i != k ) or ( i != j and j == k ) : <NEWLINE> <INDENT> t = 3 <NEWLINE> <DEDENT> total += gcd ( i , j , k ) * t <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for i in range ( 10001 ) ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> if x * x + y * y + z * z + x * y + x * z + y * z <= 10000 : <NEWLINE> <INDENT> ans [ x * x + y * y + z * z + x * y + x * z + y * z ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def Eratosthenes ( n ) : <NEWLINE> <INDENT> N = [ 1 for i in range ( 0 , n + 1 ) ] <NEWLINE> i = 3 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if N [ i ] : <NEWLINE> <INDENT> j = i * i <NEWLINE> while j <= n : <NEWLINE> <INDENT> N [ j ] = 0 <NEWLINE> j += i * 2 <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <DEDENT> return N <NEWLINE> <NL> <DEDENT> N = Eratosthenes ( 999999 ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> cnt += N [ i ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for _ in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> V , E = map ( int , file_input . readline ( ) . split ( ) ) <NEWLINE> <NL> adj_mat = [ [ 0 ] * V for i in range ( V ) ] <NEWLINE> <NL> for line in file_input : <NEWLINE> <INDENT> u , v , c = map ( int , line . split ( ) ) <NEWLINE> adj_mat [ u ] [ v ] = c <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> import collections <NEWLINE> <NL> <COMMENT> <NL> def bfs ( start , goal , parent ) : <NEWLINE> <INDENT> level = [ V ] * V <NEWLINE> unvisited = [ True ] * V <NEWLINE> queue = collections . deque ( ) <NEWLINE> queue . append ( start ) <NEWLINE> level [ start ] = 0 <NEWLINE> unvisited [ start ] = False <NEWLINE> while queue : <NEWLINE> <INDENT> u = queue . popleft ( ) <NEWLINE> next_level = level [ u ] + 1 <NEWLINE> for v , r_capacity in enumerate ( adj_mat [ u ] ) : <NEWLINE> <INDENT> if ( level [ v ] >= next_level ) and ( r_capacity > 0 ) : <NEWLINE> <INDENT> level [ v ] = next_level <NEWLINE> parent [ v ] . append ( u ) <NEWLINE> if unvisited [ v ] : <NEWLINE> <INDENT> queue . append ( v ) <NEWLINE> unvisited [ v ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return level [ goal ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def dfs ( goal , path , parent , blocking_flow ) : <NEWLINE> <INDENT> v = path [ - 1 ] <NEWLINE> if v == goal : <NEWLINE> <INDENT> aug_path_flow = 10000 <NEWLINE> for x , y in zip ( path [ 1 : ] , path [ : - 1 ] ) : <NEWLINE> <INDENT> aug_path_flow = min ( aug_path_flow , adj_mat [ x ] [ y ] ) <NEWLINE> <DEDENT> for x , y in zip ( path [ 1 : ] , path [ : - 1 ] ) : <NEWLINE> <INDENT> adj_mat [ x ] [ y ] -= aug_path_flow <NEWLINE> adj_mat [ y ] [ x ] += aug_path_flow <NEWLINE> <DEDENT> blocking_flow [ 0 ] += aug_path_flow <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for u in parent [ v ] : <NEWLINE> <INDENT> path . append ( u ) <NEWLINE> dfs ( goal , path , parent , blocking_flow ) <NEWLINE> path . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def dinic ( source , sink ) : <NEWLINE> <INDENT> max_flow = 0 <NEWLINE> parent = [ [ ] for i in range ( V ) ] <NEWLINE> while bfs ( source , sink , parent ) != V : <NEWLINE> <INDENT> blocking_flow = [ 0 ] <NEWLINE> path = [ sink ] <NEWLINE> <COMMENT> <NL> dfs ( source , path , parent , blocking_flow ) <NEWLINE> max_flow += blocking_flow [ 0 ] <NEWLINE> parent = [ [ ] for i in range ( V ) ] <NEWLINE> <DEDENT> return max_flow <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( dinic ( 0 , V - 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> edges , vertices = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ None for _ in range ( edges ) ] <NEWLINE> <NL> nodes = [ [ ] for _ in range ( edges ) ] <NEWLINE> <NL> for i in range ( vertices ) : <NEWLINE> <INDENT> start , end = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes [ end - 1 ] . append ( start - 1 ) <NEWLINE> <NL> <DEDENT> def find ( arr ) : <NEWLINE> <INDENT> if not len ( arr ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for x in arr : <NEWLINE> <INDENT> if dp [ x ] is None : <NEWLINE> <INDENT> dp [ x ] = find ( nodes [ x ] ) <NEWLINE> <DEDENT> <DEDENT> return 1 + max ( dp [ x ] for x in arr ) <NEWLINE> <NL> <DEDENT> for i in range ( edges ) : <NEWLINE> <INDENT> dp [ i ] = find ( nodes [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> if m // 2 >= n : <NEWLINE> <INDENT> cnt += n <NEWLINE> m -= n * 2 <NEWLINE> print ( cnt + m // 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m // 2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> N , S , * A = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> answer = np . zeros ( 3002 ) . astype ( np . int64 ) <NEWLINE> power2 = 1 <NEWLINE> <NL> total = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> total = min ( 3001 , a + total ) <NEWLINE> answer [ a + 1 : total + 1 ] = ( 2 * answer [ a + 1 : total + 1 ] + answer [ 1 : total - a + 1 ] ) % mod <NEWLINE> answer [ a ] = ( 2 * answer [ a ] + power2 ) % mod <NEWLINE> answer [ 1 : a ] = ( 2 * answer [ 1 : a ] ) % mod <NEWLINE> power2 = ( 2 * power2 ) % mod <NEWLINE> <NL> <DEDENT> print ( answer [ S ] ) <NEWLINE>
input ( ) <NEWLINE> print ( <STRING> . join ( reversed ( [ x for x in input ( ) . split ( ) ] ) ) ) <NEWLINE>
import numpy as np <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> bomb = set ( ) <NEWLINE> hh = np . zeros ( H + 1 , dtype = np . int ) <NEWLINE> ww = np . zeros ( W + 1 , dtype = np . int ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb . add ( ( h , w ) ) <NEWLINE> hh [ h ] += 1 <NEWLINE> ww [ w ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> h_max = np . max ( hh ) <NEWLINE> w_max = np . max ( ww ) <NEWLINE> <NL> h_max_ids = list ( ) <NEWLINE> w_max_ids = list ( ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> if hh [ i ] == h_max : <NEWLINE> <INDENT> h_max_ids . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if ww [ j ] == w_max : <NEWLINE> <INDENT> w_max_ids . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in h_max_ids : <NEWLINE> <INDENT> for j in w_max_ids : <NEWLINE> <INDENT> if not ( i , j ) in bomb : <NEWLINE> <INDENT> print ( h_max + w_max ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max - 1 ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> root = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> root . append ( set ( ) ) <NEWLINE> <NL> <DEDENT> for ab in AB : <NEWLINE> <INDENT> root [ ab [ 0 ] - 1 ] . add ( ab [ 1 ] - 1 ) <NEWLINE> root [ ab [ 1 ] - 1 ] . add ( ab [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> sign = [ 0 ] * n <NEWLINE> sign [ 0 ] = - 1 <NEWLINE> list = [ 0 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = list . pop ( 0 ) <NEWLINE> <NL> for next in root [ x ] : <NEWLINE> <INDENT> if sign [ next ] == 0 : <NEWLINE> <INDENT> sign [ next ] = x + 1 <NEWLINE> list . append ( next ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( list ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for p in sign [ 1 : ] : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> <NL> a = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> com = input ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> heappush ( a , - int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - heappop ( a ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> A . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> mul = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if mul == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif mul > 10 ** 18 : <NEWLINE> <INDENT> mul = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul *= A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n >= m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = n - 1 <NEWLINE> sl = sorted ( l ) <NEWLINE> <NL> dsl = [ abs ( sl [ i + 1 ] - sl [ i ] ) for i in range ( m - 1 ) ] <NEWLINE> <NL> dsl = sorted ( dsl ) <NEWLINE> print ( sum ( dsl [ 0 : len ( dsl ) - num ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def Sieve2 ( N , AList , Bools , Max_A ) : <NEWLINE> <INDENT> N_NotDivisible = 0 <NEWLINE> value = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( AList [ i ] > value ) : <NEWLINE> <INDENT> value = AList [ i ] <NEWLINE> if ( Bools [ value ] == True ) : <NEWLINE> <INDENT> N_NotDivisible += 1 <NEWLINE> <NL> <DEDENT> for j in range ( 2 , Max_A // value + 1 , 1 ) : <NEWLINE> <INDENT> Bools [ j * value ] = False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return N_NotDivisible <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> AList_str = input ( ) . strip ( ) . split ( ) <NEWLINE> Max = 0 <NEWLINE> AList = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> AList [ i ] = int ( AList_str [ i ] ) <NEWLINE> Max = max ( AList [ i ] , Max ) <NEWLINE> <DEDENT> Bools = [ False ] * ( Max + 1 ) <NEWLINE> AList . sort ( ) <NEWLINE> Dups = [ ] <NEWLINE> for Num in range ( N ) : <NEWLINE> <INDENT> value = AList [ Num ] <NEWLINE> Bools [ value ] = True <NEWLINE> if ( Num < N - 1 and AList [ Num ] == AList [ Num + 1 ] ) : <NEWLINE> <INDENT> Dups . append ( value ) <NEWLINE> <DEDENT> <DEDENT> for Num in range ( len ( Dups ) ) : <NEWLINE> <INDENT> value = Dups [ Num ] <NEWLINE> Bools [ value ] = False <NEWLINE> <NL> <NL> <DEDENT> N_NotDivisible = Sieve2 ( N , AList , Bools , Max ) <NEWLINE> print ( N_NotDivisible ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in a : s ^= i <NEWLINE> for i in a : print ( s ^ i ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for ai in range ( n ) : <NEWLINE> <INDENT> for bi in range ( ai + 1 , n ) : <NEWLINE> <INDENT> ans += bisect_left ( l , l [ ai ] + l [ bi ] ) - bi - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> a = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a *= A [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_cnt = [ 0 for i in range ( h ) ] <NEWLINE> w_cnt = [ 0 for i in range ( w ) ] <NEWLINE> bomb = set ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> _h , _w = map ( int , input ( ) . split ( ) ) <NEWLINE> h_cnt [ _h - 1 ] += 1 <NEWLINE> w_cnt [ _w - 1 ] += 1 <NEWLINE> bomb . add ( ( ( _h - 1 ) , ( _w - 1 ) ) ) <COMMENT> <NEWLINE> <NL> <DEDENT> h_max = max ( h_cnt ) <NEWLINE> w_max = max ( w_cnt ) <NEWLINE> <NL> max_h = [ ] <NEWLINE> max_w = [ ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> if h_cnt [ i ] == h_max : <NEWLINE> <INDENT> max_h . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if w_cnt [ i ] == w_max : <NEWLINE> <INDENT> max_w . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> flg = True <NEWLINE> <NL> for i in max_h : <NEWLINE> <INDENT> for j in max_w : <NEWLINE> <INDENT> if ( i , j ) not in bomb : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max - 1 if flg else h_max + w_max ) <NEWLINE>
Sum = input ( ) . split ( ) <NEWLINE> cou = 1 <NEWLINE> while len ( Sum ) != 1 : <NEWLINE> <INDENT> cou += 1 <NEWLINE> if Sum [ cou ] == <STRING> : <NEWLINE> <INDENT> del Sum [ cou ] <NEWLINE> Sum . insert ( ( cou - 2 ) , int ( Sum . pop ( cou - 2 ) ) + int ( Sum . pop ( cou - 2 ) ) ) <NEWLINE> cou -= 2 <NEWLINE> <DEDENT> elif Sum [ cou ] == <STRING> : <NEWLINE> <INDENT> del Sum [ cou ] <NEWLINE> Sum . insert ( ( cou - 2 ) , int ( Sum . pop ( cou - 2 ) ) - int ( Sum . pop ( cou - 2 ) ) ) <NEWLINE> cou -= 2 <NEWLINE> <DEDENT> elif Sum [ cou ] == <STRING> : <NEWLINE> <INDENT> del Sum [ cou ] <NEWLINE> Sum . insert ( ( cou - 2 ) , int ( Sum . pop ( cou - 2 ) ) * int ( Sum . pop ( cou - 2 ) ) ) <NEWLINE> cou -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Sum [ 0 ] ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = sum ( a ) <NEWLINE> count = Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b_c = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> for i in b_c : <NEWLINE> <INDENT> s += ( i [ 1 ] - i [ 0 ] ) * count [ i [ 0 ] ] <NEWLINE> count [ i [ 1 ] ] += count [ i [ 0 ] ] <NEWLINE> count [ i [ 0 ] ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> point = k - q <NEWLINE> participant = [ point ] * n <NEWLINE> answer = [ int ( input ( ) ) for _ in range ( q ) ] <NEWLINE> count_a = Counter ( answer ) <NEWLINE> <NL> <NL> for key , value in count_a . items ( ) : <NEWLINE> <INDENT> participant [ key - 1 ] += value <NEWLINE> <NL> <DEDENT> for i in participant : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> eroot_n = int ( pow ( n , 0.5 ) ) <NEWLINE> res = 0 <NEWLINE> for num_a in range ( 1 , eroot_n + 1 ) : <NEWLINE> <INDENT> limit_b = int ( n / num_a ) + 1 <NEWLINE> for num_b in range ( num_a , limit_b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if num_a * num_b >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num_a == num_b : <NEWLINE> <INDENT> res = res + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = res + 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> <NL> INIT_VAL = pow ( 2 , 31 ) - 1 <NEWLINE> <NL> class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . height = math . ceil ( math . log2 ( n ) ) <NEWLINE> self . nodes = [ INIT_VAL for i in range ( pow ( 2 , self . height + 1 ) - 1 ) ] <NEWLINE> self . leaf_start = pow ( 2 , self . height ) - 1 <NEWLINE> <NL> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> pntr = self . leaf_start + i <NEWLINE> self . nodes [ pntr ] = x <NEWLINE> while True : <NEWLINE> <INDENT> pntr = ( pntr - 1 ) // 2 <NEWLINE> if pntr == - 1 : break <NEWLINE> l , r = pntr * 2 + 1 , pntr * 2 + 2 <NEWLINE> self . nodes [ pntr ] = min ( self . nodes [ l ] , self . nodes [ r ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __query ( self , s , t , k , l , r ) : <NEWLINE> <INDENT> if t - s <= 0 : return INIT_VAL <NEWLINE> if r <= s or t <= l : return INIT_VAL <NEWLINE> if l == s and t == r : return self . nodes [ k ] <NEWLINE> else : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if t <= m : <NEWLINE> <INDENT> return self . __query ( s , t , k * 2 + 1 , l , m ) <NEWLINE> <DEDENT> elif m <= s : <NEWLINE> <INDENT> return self . __query ( s , t , k * 2 + 2 , m , r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl = self . __query ( s , m , k * 2 + 1 , l , m ) <NEWLINE> vr = self . __query ( m , t , k * 2 + 2 , m , r ) <NEWLINE> return min ( vl , vr ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def find ( self , s , t ) : <NEWLINE> <INDENT> return self . __query ( s , t + 1 , 0 , 0 , pow ( 2 , self . height ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> st = SegmentTree ( n ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> st . update ( x , y ) <NEWLINE> <DEDENT> elif com == 1 : <NEWLINE> <INDENT> print ( st . find ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> if k > x // d : <NEWLINE> <INDENT> X = x % d <NEWLINE> X -= ( k - x // d ) % 2 * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X = x - k * d <NEWLINE> <NL> <DEDENT> print ( abs ( X ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> L = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> L . append ( cnt ) <NEWLINE> print ( max ( L ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i + 1 ] = ans [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( i - ans [ i ] + ans [ n ] - ans [ i + 1 ] for i in range ( n ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> g = ( N // j ) * ( N // j + 1 ) * j // 2 <NEWLINE> ans += g <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for k in range ( 200 ) : <NEWLINE> <INDENT> temp = X - k <NEWLINE> if temp not in p : <NEWLINE> <INDENT> print ( temp ) <NEWLINE> break <NEWLINE> <DEDENT> semp = X + k <NEWLINE> if semp not in p : <NEWLINE> <INDENT> print ( semp ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A_l = [ ( A , i ) for i , A in enumerate ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> A_l . sort ( reverse = True ) <NEWLINE> <NL> dp = [ ] <NEWLINE> for _ in range ( n + 1 ) : <NEWLINE> <INDENT> dp . append ( [ 0 ] * ( n + 1 ) ) <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> a , i = A_l [ j - 1 ] <NEWLINE> dp [ j ] [ 0 ] = dp [ j - 1 ] [ 0 ] + a * ( n - ( j - 1 ) - ( i + 1 ) ) <NEWLINE> <DEDENT> for k in range ( 1 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> a , i = A_l [ k - 1 ] <NEWLINE> dp [ 0 ] [ k ] = dp [ 0 ] [ k - 1 ] + a * ( ( i + 1 ) - ( 1 + ( k - 1 ) ) ) <NEWLINE> <NL> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n - j + 1 ) : <NEWLINE> <INDENT> a , i = A_l [ j + k - 1 ] <NEWLINE> j_plus = a * ( n - ( j - 1 ) - ( i + 1 ) ) <NEWLINE> k_plus = a * ( ( i + 1 ) - ( 1 + ( k - 1 ) ) ) <NEWLINE> dp [ j ] [ k ] = max ( dp [ j - 1 ] [ k ] + j_plus , dp [ j ] [ k - 1 ] + k_plus ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> for j in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> k = n - j <NEWLINE> result = max ( result , dp [ j ] [ k ] ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Alice = [ ] <NEWLINE> Bob = [ ] <NEWLINE> while len ( an ) > 0 : <NEWLINE> <INDENT> Alice . append ( max ( an ) ) <NEWLINE> del an [ an . index ( max ( an ) ) ] <NEWLINE> if len ( an ) > 0 : <NEWLINE> <INDENT> Bob . append ( max ( an ) ) <NEWLINE> del an [ an . index ( max ( an ) ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> k = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( len ( Alice ) ) : <NEWLINE> <INDENT> k += Alice [ i ] <NEWLINE> <DEDENT> for i in range ( len ( Bob ) ) : <NEWLINE> <INDENT> j += Bob [ i ] <NEWLINE> <NL> <DEDENT> print ( str ( k - j ) ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> cum = 1 <NEWLINE> over = False <NEWLINE> for x in a : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> cum = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if cum == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> cum *= x <NEWLINE> if ( cum > 1e18 ) : <NEWLINE> <INDENT> over = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) if over else print ( cum ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> prev = <STRING> <NEWLINE> curr = <STRING> <NEWLINE> for s in S : <NEWLINE> <INDENT> curr += s <NEWLINE> if prev != curr : <NEWLINE> <INDENT> ans += 1 <NEWLINE> prev = curr <NEWLINE> curr = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> W = [ 1 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] >= H [ b - 1 ] : <NEWLINE> <INDENT> W [ b - 1 ] = 0 <NEWLINE> <DEDENT> if H [ b - 1 ] >= H [ a - 1 ] : <NEWLINE> <INDENT> W [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in W : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial , gcd <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> l , r = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if r - l + 1 >= 5000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = 2019 <NEWLINE> mn = [ ] <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> mn . append ( ( i * j ) % M ) <NEWLINE> <NL> <DEDENT> <DEDENT> mn . sort ( ) <NEWLINE> print ( mn [ 0 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for x in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n <= N : <NEWLINE> <INDENT> ans [ n - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> print ( ans [ n ] ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> youso = [ ] <NEWLINE> for i in range ( - 300 , 1000 ) : <NEWLINE> <INDENT> if not i in p : <NEWLINE> <INDENT> youso += [ i ] <NEWLINE> <DEDENT> <DEDENT> hikaku = [ ] <NEWLINE> for i in youso : <NEWLINE> <INDENT> hikaku += [ ( i , abs ( x - i ) ) ] <NEWLINE> <DEDENT> hikaku1 = sorted ( hikaku , key = lambda x : x [ 1 ] ) <NEWLINE> res = hikaku1 [ 0 ] [ 0 ] <NEWLINE> print ( res ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if <STRING> in s : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def computeGCD ( x , y ) : <NEWLINE> <INDENT> while ( y ) : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> intermediate = computeGCD ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += computeGCD ( c , intermediate ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> r = math . factorial ( int ( input ( ) ) ) <NEWLINE> print ( r % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for l in range ( k + 1 ) : <NEWLINE> <INDENT> for m in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - ( l + m ) <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def read_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_ints ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> x , n = read_ints ( ) <NEWLINE> p = [ ] <NEWLINE> if n > 0 : <NEWLINE> <INDENT> p = list ( read_ints ( ) ) <NEWLINE> <DEDENT> ans = - 1 <NEWLINE> delta = 1000 <NEWLINE> for i in range ( - 1 , 102 ) : <NEWLINE> <INDENT> ok = True <NEWLINE> for j in p : <NEWLINE> <INDENT> if j == i : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> d = abs ( x - i ) <NEWLINE> if d < delta : <NEWLINE> <INDENT> ans = i <NEWLINE> delta = d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
count = 0 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = A [ left : left + n1 ] <NEWLINE> R = A [ mid : mid + n2 ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> numLeft = len ( L ) - 1 <COMMENT> <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if R [ j ] < L [ i ] : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> count += numLeft - i <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( A , 0 , n ) <NEWLINE> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> if N == 3 : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> <DEDENT> elif N > 3 : <NEWLINE> <INDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( os . path . dirname ( __file__ ) + <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <NL> T = [ True ] * A [ - 1 ] <NEWLINE> <COMMENT> <NL> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if T [ a - 1 ] : <NEWLINE> <INDENT> j = 2 * a <NEWLINE> while j <= A [ - 1 ] : <NEWLINE> <INDENT> T [ j - 1 ] = False <NEWLINE> j += a <NEWLINE> <DEDENT> if not i + 1 == len ( A ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> T [ a - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if T [ a - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 1 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 1 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 1 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 9 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 1 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 1 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 1 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 3 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 1 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 1 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 15 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 4 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 9 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 1 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 4 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 39 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 1 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 7 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 1 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 7 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 1 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 21 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 15 , <NEWLINE> 27 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 10 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 3 , <NEWLINE> 51 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 4 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 27 , <NEWLINE> 21 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 57 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 10 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 21 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 1 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 57 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 13 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 21 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 4 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 9 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 51 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 57 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 15 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 7 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 21 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 69 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 1 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 63 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 45 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 75 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 21 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 69 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 3 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 13 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 39 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 75 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 45 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 7 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 66 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 63 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 57 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 81 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 42 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 63 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 16 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 84 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 78 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 75 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 75 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 3 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 15 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 63 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 63 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 75 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 15 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 81 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 27 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 1 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 9 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 72 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 93 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 51 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 72 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 33 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 33 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 75 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 45 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 7 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 33 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 75 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 81 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 75 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 3 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 57 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 90 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 45 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 6 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 3 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 96 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 78 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 45 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 3 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 87 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 3 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 39 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 7 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 69 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 57 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 69 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 39 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 72 , <NEWLINE> 33 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 63 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 90 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 66 , <NEWLINE> 3 , <NEWLINE> 57 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 57 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 3 , <NEWLINE> 54 , <NEWLINE> 27 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 75 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 66 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 3 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 39 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 13 , <NEWLINE> 84 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 54 , <NEWLINE> 39 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 87 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 84 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 21 , <NEWLINE> 78 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 15 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 21 , <NEWLINE> 57 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 3 , <NEWLINE> 75 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 57 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 45 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 81 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 3 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 48 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 75 , <NEWLINE> 30 , <NEWLINE> 63 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 63 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 108 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 63 , <NEWLINE> 27 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 75 , <NEWLINE> 6 , <NEWLINE> 63 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 21 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 108 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 15 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 45 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 1 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 90 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 3 , <NEWLINE> 54 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 105 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 96 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 27 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 57 , <NEWLINE> 12 , <NEWLINE> 57 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 9 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 81 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 84 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 90 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 90 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 39 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 66 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 39 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 21 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 15 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 57 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 81 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 87 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 25 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 69 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 45 , <NEWLINE> 39 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 120 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 3 , <NEWLINE> 84 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 72 , <NEWLINE> 9 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 45 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 6 , <NEWLINE> 12 , <NEWLINE> 99 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 57 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 63 , <NEWLINE> 30 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 102 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 93 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 102 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 45 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 63 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 51 , <NEWLINE> 45 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 69 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 90 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 21 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 57 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 90 , <NEWLINE> 21 , <NEWLINE> 66 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 54 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 63 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 10 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 87 , <NEWLINE> 15 , <NEWLINE> 75 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 6 , <NEWLINE> 51 , <NEWLINE> 39 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 3 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 45 , <NEWLINE> 51 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 45 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 78 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 21 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 81 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 90 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 57 , <NEWLINE> 24 , <NEWLINE> 45 , <NEWLINE> 54 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 27 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 108 , <NEWLINE> 15 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 96 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 69 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 15 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 27 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 51 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 105 , <NEWLINE> 21 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 57 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 57 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 27 , <NEWLINE> 57 , <NEWLINE> 12 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 3 , <NEWLINE> 105 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 45 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 13 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 96 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 81 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 33 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 54 , <NEWLINE> 51 , <NEWLINE> 27 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 87 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 96 , <NEWLINE> 0 , <NEWLINE> 87 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 102 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 66 , <NEWLINE> 21 , <NEWLINE> 90 , <NEWLINE> 3 , <NEWLINE> 78 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 93 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 63 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 24 , <NEWLINE> 69 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 120 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 3 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 84 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 54 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 48 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 99 , <NEWLINE> 24 , <NEWLINE> 102 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 39 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 39 , <NEWLINE> 63 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 6 , <NEWLINE> 69 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 57 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 78 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 111 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 33 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 4 , <NEWLINE> 78 , <NEWLINE> 21 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 21 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 99 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 6 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 78 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 102 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 15 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 3 , <NEWLINE> 105 , <NEWLINE> 51 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 102 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 99 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 39 , <NEWLINE> 27 , <NEWLINE> 102 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 45 , <NEWLINE> 39 , <NEWLINE> 87 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 45 , <NEWLINE> 36 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 78 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 96 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 51 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 57 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 96 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 93 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 69 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 15 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 90 , <NEWLINE> 3 , <NEWLINE> 72 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 54 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 18 , <NEWLINE> 108 , <NEWLINE> 9 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 75 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 66 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 96 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 63 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 39 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 39 , <NEWLINE> 12 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 33 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 90 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 45 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 33 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 51 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 69 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 72 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 96 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 87 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 13 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 84 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 75 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 57 , <NEWLINE> 36 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 96 , <NEWLINE> 24 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 108 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 75 , <NEWLINE> 18 , <NEWLINE> 90 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 114 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 39 , <NEWLINE> 33 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 45 , <NEWLINE> 27 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 90 , <NEWLINE> 9 , <NEWLINE> 60 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 78 , <NEWLINE> 9 , <NEWLINE> 84 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 96 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 93 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 69 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 36 , <NEWLINE> 51 , <NEWLINE> 33 , <NEWLINE> 96 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 117 , <NEWLINE> 36 , <NEWLINE> 54 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 96 , <NEWLINE> 3 , <NEWLINE> 72 , <NEWLINE> 36 , <NEWLINE> 57 , <NEWLINE> 27 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 33 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 63 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 9 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 138 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 57 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 84 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 15 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 48 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 3 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 57 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 9 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 57 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 126 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 96 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 6 , <NEWLINE> 90 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 9 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 69 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 15 , <NEWLINE> 72 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 27 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 57 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 27 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 57 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 90 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 15 , <NEWLINE> 84 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 66 , <NEWLINE> 3 , <NEWLINE> 54 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 108 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 96 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 96 , <NEWLINE> 9 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 75 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 57 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 9 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 10 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 51 , <NEWLINE> 48 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 75 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 42 , <NEWLINE> 108 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 51 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 45 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 3 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 78 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 81 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 108 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 108 , <NEWLINE> 21 , <NEWLINE> 54 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 90 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 69 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 84 , <NEWLINE> 24 , <NEWLINE> 114 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 21 , <NEWLINE> 78 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 51 , <NEWLINE> 99 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 39 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 39 , <NEWLINE> 9 , <NEWLINE> 84 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 72 , <NEWLINE> 48 , <NEWLINE> 39 , <NEWLINE> 42 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 30 , <NEWLINE> 45 , <NEWLINE> 33 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 90 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 27 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 15 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 42 , <NEWLINE> 114 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 3 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 54 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 33 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 96 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 99 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 15 , <NEWLINE> 84 , <NEWLINE> 6 , <NEWLINE> 102 , <NEWLINE> 48 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 51 , <NEWLINE> 27 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 120 , <NEWLINE> 27 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 9 , <NEWLINE> 57 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 45 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 126 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 57 , <NEWLINE> 12 , <NEWLINE> 84 , <NEWLINE> 54 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 63 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 33 , <NEWLINE> 24 , <NEWLINE> 105 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 27 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 3 , <NEWLINE> 75 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 96 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 87 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 69 , <NEWLINE> 12 , <NEWLINE> 57 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 69 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 21 , <NEWLINE> 78 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 102 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 45 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 13 , <NEWLINE> 108 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 102 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 114 , <NEWLINE> 24 , <NEWLINE> 63 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 69 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 54 , <NEWLINE> 117 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 102 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 54 , <NEWLINE> 33 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 75 , <NEWLINE> 24 , <NEWLINE> 84 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 45 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 96 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 12 , <NEWLINE> 36 , <NEWLINE> 78 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 90 , <NEWLINE> 15 , <NEWLINE> 96 , <NEWLINE> 18 , <NEWLINE> 27 , <NEWLINE> 21 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 27 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 108 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 27 , <NEWLINE> 60 , <NEWLINE> 21 , <NEWLINE> 36 , <NEWLINE> 84 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 15 , <NEWLINE> 72 , <NEWLINE> 9 , <NEWLINE> 99 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 57 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 63 , <NEWLINE> 9 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 75 , <NEWLINE> 45 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 84 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 9 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 90 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 3 , <NEWLINE> 84 , <NEWLINE> 21 , <NEWLINE> 84 , <NEWLINE> 33 , <NEWLINE> 66 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 12 , <NEWLINE> 45 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 3 , <NEWLINE> 42 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 54 , <NEWLINE> 54 , <NEWLINE> 21 , <NEWLINE> 66 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 30 , <NEWLINE> 102 , <NEWLINE> 3 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 45 , <NEWLINE> 36 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 36 , <NEWLINE> 96 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 27 , <NEWLINE> 27 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 78 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 114 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 69 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 72 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 42 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 138 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 75 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 57 , <NEWLINE> 60 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 39 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 87 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 87 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 72 , <NEWLINE> 21 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 96 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 39 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 84 , <NEWLINE> 12 , <NEWLINE> 63 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 15 , <NEWLINE> 75 , <NEWLINE> 45 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 84 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 27 , <NEWLINE> 96 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 21 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 33 , <NEWLINE> 36 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 0 , <NEWLINE> 75 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 42 , <NEWLINE> 30 , <NEWLINE> 96 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 6 , <NEWLINE> 123 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 39 , <NEWLINE> 42 , <NEWLINE> 6 , <NEWLINE> 21 , <NEWLINE> 54 , <NEWLINE> 45 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 45 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 21 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 60 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 33 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 90 , <NEWLINE> 30 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 1 , <NEWLINE> 78 , <NEWLINE> 27 , <NEWLINE> 84 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 15 , <NEWLINE> 102 , <NEWLINE> 9 , <NEWLINE> 27 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 57 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 42 , <NEWLINE> 12 , <NEWLINE> 72 , <NEWLINE> 27 , <NEWLINE> 48 , <NEWLINE> 9 , <NEWLINE> 108 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 21 , <NEWLINE> 114 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 63 , <NEWLINE> 9 , <NEWLINE> 51 , <NEWLINE> 66 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 60 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 96 , <NEWLINE> 9 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 93 , <NEWLINE> 24 , <NEWLINE> 72 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 48 , <NEWLINE> 30 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 93 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 81 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 90 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 57 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 78 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 33 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 51 , <NEWLINE> 30 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 3 , <NEWLINE> 78 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 27 , <NEWLINE> 138 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 24 , <NEWLINE> 75 , <NEWLINE> 24 , <NEWLINE> 12 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 12 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 84 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 66 , <NEWLINE> 6 , <NEWLINE> 45 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 114 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 21 , <NEWLINE> 108 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 57 , <NEWLINE> 24 , <NEWLINE> 63 , <NEWLINE> 42 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 81 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 120 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 48 , <NEWLINE> 12 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 48 , <NEWLINE> 48 , <NEWLINE> 33 , <NEWLINE> 6 , <NEWLINE> 102 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 54 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 90 , <NEWLINE> 18 , <NEWLINE> 36 , <NEWLINE> 3 , <NEWLINE> 111 , <NEWLINE> 24 , <NEWLINE> 51 , <NEWLINE> 48 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 45 , <NEWLINE> 36 , <NEWLINE> 54 , <NEWLINE> 48 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 18 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 36 , <NEWLINE> 57 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 120 , <NEWLINE> 0 , <NEWLINE> 63 , <NEWLINE> 42 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 48 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 6 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 81 , <NEWLINE> 18 , <NEWLINE> 72 , <NEWLINE> 33 , <NEWLINE> 54 , <NEWLINE> 9 , <NEWLINE> 72 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 54 , <NEWLINE> 24 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 75 , <NEWLINE> 24 , <NEWLINE> 60 , <NEWLINE> 12 , <NEWLINE> 78 , <NEWLINE> 6 , <NEWLINE> 30 , <NEWLINE> 12 , <NEWLINE> 39 , <NEWLINE> 54 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 72 , <NEWLINE> 6 , <NEWLINE> 78 , <NEWLINE> 12 , <NEWLINE> 54 , <NEWLINE> 39 , <NEWLINE> 30 , <NEWLINE> 15 , <NEWLINE> 48 , <NEWLINE> 6 , <NEWLINE> 57 , <NEWLINE> 48 , <NEWLINE> 18 , <NEWLINE> 24 , <NEWLINE> 90 , <NEWLINE> 0 , <NEWLINE> 90 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 39 , <NEWLINE> 42 , <NEWLINE> 24 , <NEWLINE> 30 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 6 , <NEWLINE> 66 , <NEWLINE> 30 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 42 , <NEWLINE> 39 , <NEWLINE> 33 , <NEWLINE> 90 , <NEWLINE> 24 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> 51 , <NEWLINE> 36 , <NEWLINE> 69 , <NEWLINE> 24 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 42 , <NEWLINE> 18 , <NEWLINE> 87 , <NEWLINE> 33 , <NEWLINE> 51 , <NEWLINE> 18 , <NEWLINE> 42 , <NEWLINE> 9 , <NEWLINE> 126 , <NEWLINE> 9 , <NEWLINE> 84 , <NEWLINE> 36 , <NEWLINE> 66 , <NEWLINE> 18 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 36 , <NEWLINE> 0 , <NEWLINE> 66 , <NEWLINE> 12 , <NEWLINE> 48 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 30 , <NEWLINE> 18 , <NEWLINE> 18 , <NEWLINE> 60 , <NEWLINE> 18 , <NEWLINE> 96 , <NEWLINE> 54 , <NEWLINE> 42 , <NEWLINE> 0 , <NEWLINE> 102 , <NEWLINE> 0 , <NEWLINE> 27 , <NEWLINE> 36 , <NEWLINE> 30 , <NEWLINE> 36 , <NEWLINE> 108 , <NEWLINE> 15 , <NEWLINE> 54 , <NEWLINE> 0 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 60 , <NEWLINE> 24 , <NEWLINE> 66 , <NEWLINE> 0 , <NEWLINE> 30 , <NEWLINE> 0 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 75 , <NEWLINE> 48 , <NEWLINE> 36 , <NEWLINE> 18 , <NEWLINE> 48 , <NEWLINE> 24 , <NEWLINE> 36 , <NEWLINE> 36 , <NEWLINE> 54 , <NEWLINE> 15 , <NEWLINE> 108 , <NEWLINE> 0 , <NEWLINE> 84 , <NEWLINE> 18 , <NEWLINE> ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = input ( ) . split ( ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> c = int ( s [ 2 ] ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if ( a > b ) : <NEWLINE> <INDENT> temp = a <NEWLINE> a = b <NEWLINE> b = temp <NEWLINE> <DEDENT> if ( b > c ) : <NEWLINE> <INDENT> temp = b <NEWLINE> b = c <NEWLINE> c = temp <NEWLINE> <DEDENT> <DEDENT> print ( a , b , c ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> r = float ( sys . stdin . readline ( ) ) <NEWLINE> print ( <STRING> % ( r * r * math . pi , r * 2 * math . pi ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a = [ 0 ] + a <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + a [ i + 1 ] <NEWLINE> <NL> <DEDENT> b = [ 0 ] + b <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b [ i + 1 ] = b [ i ] + b [ i + 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( max ( 0 , ans - i + 1 ) , m + 1 ) : <NEWLINE> <INDENT> if a [ i ] + b [ j ] <= k : <NEWLINE> <INDENT> ans = i + j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ans < 10 ** 18 and i < len ( a ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> dataset = [ 0 ] * 2019 <NEWLINE> dataset [ 0 ] = 1 <NEWLINE> <NL> n = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> n += int ( i ) * d <NEWLINE> a = n % 2019 <NEWLINE> dataset [ a ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in dataset : <NEWLINE> <INDENT> count += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_na = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> class CombMod : <NEWLINE> <NL> <INDENT> def __init__ ( self , N , MOD = 10 ** 9 + 7 ) : <NEWLINE> <NL> <INDENT> N = N + 1 <NEWLINE> inv = [ 0 ] * N <NEWLINE> fact = [ 0 ] * N <NEWLINE> fact_inv = [ 0 ] * N <NEWLINE> <NL> inv [ 0 ] = 0 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for n in range ( 2 , N ) : <NEWLINE> <INDENT> q , r = divmod ( MOD , n ) <NEWLINE> inv [ n ] = inv [ r ] * ( - q ) % MOD <NEWLINE> <NL> <DEDENT> fact [ 0 ] = 1 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> fact [ n ] = n * fact [ n - 1 ] % MOD <NEWLINE> <NL> <DEDENT> fact_inv [ 0 ] = 1 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> fact_inv [ n ] = fact_inv [ n - 1 ] * inv [ n ] % MOD <NEWLINE> <NL> <DEDENT> self . fact = fact <NEWLINE> self . fact_inv = fact_inv <NEWLINE> self . inv = inv <NEWLINE> <NL> <DEDENT> def comb ( self , n , r , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> return self . fact [ n ] * self . fact_inv [ r ] % mod * self . fact_inv [ n - r ] % mod <NEWLINE> <NL> <DEDENT> def perm ( self , n , r , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> return self . fact [ n ] * self . fact_inv [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> N , M = in_nn ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> c = CombMod ( M ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> t = c . comb ( N , i ) <NEWLINE> <NL> t *= ( - 1 ) ** ( i % 2 ) <NEWLINE> t %= mod <NEWLINE> <NL> t *= c . perm ( M , i ) <NEWLINE> t %= mod <NEWLINE> <NL> t *= c . perm ( M - i , N - i ) <NEWLINE> t %= mod <NEWLINE> <NL> t *= c . perm ( M - i , N - i ) <NEWLINE> t %= mod <NEWLINE> <NL> ans += t <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def cmb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <NL> <DEDENT> p = 998244353 <NEWLINE> N = n <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> l2 = m * ( m - 1 ) ** ( n - k - 1 ) <NEWLINE> for _k in range ( k , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> ncr = cmb ( n - 1 , _k , p ) <NEWLINE> ans += ncr * l2 <NEWLINE> ans %= p <NEWLINE> l2 %= p <NEWLINE> l2 *= ( m - 1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import random <NEWLINE> class Dice : <NEWLINE> <INDENT> def __init__ ( self , num_list ) : <NEWLINE> <INDENT> self . top = num_list [ 0 ] <NEWLINE> self . dside = num_list [ 1 ] <NEWLINE> self . rside = num_list [ 2 ] <NEWLINE> self . lside = num_list [ 3 ] <NEWLINE> self . uside = num_list [ 4 ] <NEWLINE> self . bottom = num_list [ 5 ] <NEWLINE> self . dlist = num_list <NEWLINE> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> ( self . top , self . dside , self . bottom , self . uside ) = ( self . dside , <NEWLINE> <INDENT> self . bottom , self . uside , self . top ) <NEWLINE> <DEDENT> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> ( self . top , self . lside , self . bottom , self . rside ) = ( self . lside , <NEWLINE> <INDENT> self . bottom , self . rside , self . top ) <NEWLINE> <DEDENT> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> ( self . top , self . dside , self . bottom , self . uside ) = ( self . uside , <NEWLINE> <INDENT> self . top , self . dside , self . bottom ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> num = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> dice = [ Dice ( num [ i ] ) for i in range ( n ) ] <NEWLINE> for idx1 , i in enumerate ( dice ) : <NEWLINE> <INDENT> for idx2 , j in enumerate ( dice ) : <NEWLINE> <INDENT> if idx2 <= idx1 or len ( set ( i . dlist ) ^ set ( j . dlist ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif len ( set ( num [ 0 ] ) ) < 4 : <NEWLINE> <INDENT> while ( i . top != j . top or i . rside != j . rside <NEWLINE> <INDENT> or i . dside != j . dside ) : <NEWLINE> mode = random . randint ( 0 , 2 ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> j . north ( ) <NEWLINE> elif mode == 1 : <NEWLINE> j . east ( ) <NEWLINE> else : <NEWLINE> j . south ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while ( i . top != j . top or <NEWLINE> <INDENT> ( i . rside != j . rside and i . uside != j . uside ) ) : <NEWLINE> mode = random . randint ( 0 , 2 ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> j . north ( ) <NEWLINE> elif mode == 1 : <NEWLINE> j . east ( ) <NEWLINE> elif mode == 2 : <NEWLINE> j . south ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( i . bottom == j . bottom and i . lside == j . lside <NEWLINE> <INDENT> and i . dside == j . dside ) : <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = 1 <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if abs ( ( y1 - y2 ) * ( x3 - x4 ) - ( y3 - y4 ) * ( x1 - x2 ) ) < 1e-10 else <STRING> ) <NEWLINE> <DEDENT>
n , * aa = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> ca = Counter ( aa ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> have = ca [ i ] <NEWLINE> print ( have ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = sum ( A ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += A [ 0 ] <NEWLINE> A [ 0 ] *= 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <NL> c = [ ] <NEWLINE> def prep_array ( X , Y ) : <NEWLINE> <INDENT> global c <NEWLINE> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> c = [ [ 0 ] * ( len ( Y ) + 2 ) for _ in range ( len ( X ) + 2 ) ] <COMMENT> <NEWLINE> return c <NEWLINE> <NL> <NL> <DEDENT> def check_max ( array ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> max_lcs = 0 <NEWLINE> for row in array : <NEWLINE> <INDENT> temp_max = max ( row ) <NEWLINE> if temp_max > max_lcs : <NEWLINE> <INDENT> max_lcs = temp_max <NEWLINE> <DEDENT> <DEDENT> return max_lcs <NEWLINE> <NL> <NL> <DEDENT> def calc_lcs4 ( X , Y , c ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> X = <STRING> + X <NEWLINE> Y = <STRING> + Y <NEWLINE> m = len ( X ) <NEWLINE> n = len ( Y ) <NEWLINE> max_lcs = 0 <NEWLINE> <NL> pre_row = c [ 0 ] <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> row = c [ i ] <NEWLINE> XX = X [ i ] <NEWLINE> for j , YY in enumerate ( Y ) : <NEWLINE> <INDENT> if XX == YY : <NEWLINE> <INDENT> pr_j1 = pre_row [ j - 1 ] <NEWLINE> row [ j ] = pr_j1 + 1 <NEWLINE> if pr_j1 + 1 > max_lcs : <NEWLINE> <INDENT> max_lcs = pr_j1 + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pr_j = pre_row [ j ] <NEWLINE> r_j1 = row [ j - 1 ] <NEWLINE> if pr_j >= r_j1 : <NEWLINE> <INDENT> row [ j ] = pr_j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row [ j ] = r_j1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> pre_row = row <NEWLINE> <DEDENT> return max_lcs <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for _ in range ( num ) : <NEWLINE> <INDENT> X = input ( ) . strip ( ) <NEWLINE> Y = input ( ) . strip ( ) <NEWLINE> <NL> <COMMENT> <NL> result = calc_lcs4 ( X , Y , prep_array ( X , Y ) ) <NEWLINE> <NL> <COMMENT> <NL> print ( result ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> dic = { } <NEWLINE> for i , a in enumerate ( alist ) : <NEWLINE> <INDENT> if dic . get ( str ( i - a ) ) is not None : <NEWLINE> <INDENT> ans += dic [ str ( i - a ) ] <NEWLINE> <DEDENT> if dic . get ( str ( i + a ) ) is not None : <NEWLINE> <INDENT> dic [ str ( i + a ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ str ( i + a ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> Flag = True <NEWLINE> zero_flag = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> zero_flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> Flag = False <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if zero_flag : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ans <= 10 ** 18 or Flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( S ) >= K and S [ : K ] == <STRING> * K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> print ( S [ 0 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def func ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ( n , m , l ) = [ int ( item ) for item in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> matrix_A = [ [ int ( item ) for item in input ( ) . rstrip ( ) . split ( <STRING> ) ] for i in range ( n ) ] <NEWLINE> matrix_B = [ [ int ( item ) for item in input ( ) . rstrip ( ) . split ( <STRING> ) ] for i in range ( m ) ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return inputError ( ) <NEWLINE> <NL> <DEDENT> matrix_C = [ [ sum ( [ matrix_A [ i ] [ j ] * matrix_B [ j ] [ k ] for j in range ( m ) ] ) for k in range ( l ) ] for i in range ( n ) ] <NEWLINE> result = <STRING> <NEWLINE> <NL> for vector in matrix_C : <NEWLINE> <INDENT> for item in vector : <NEWLINE> <INDENT> result += str ( item ) + <STRING> <NEWLINE> <DEDENT> result = result . rstrip ( ) <NEWLINE> result += <STRING> <NEWLINE> <DEDENT> print ( result . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> def inputError ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> func ( ) <NEWLINE>
from collections import deque <NEWLINE> import re <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> class AC : <NEWLINE> <NL> <INDENT> def __init__ ( self , num , parent , char ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . parent = parent <NEWLINE> self . char = char <NEWLINE> self . d = { } <NEWLINE> self . failure = None <NEWLINE> <NL> <DEDENT> def insert ( self , string , num ) : <NEWLINE> <INDENT> if not string [ 0 ] in self . d : <NEWLINE> <INDENT> self . d [ string [ 0 ] ] = AC ( num , self , string [ 0 ] ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> if not string [ 1 : ] == <STRING> : <NEWLINE> <INDENT> return self . d [ string [ 0 ] ] . insert ( string [ 1 : ] , num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return num <NEWLINE> <NL> <DEDENT> <DEDENT> def setFailure ( self ) : <NEWLINE> <INDENT> tmp = self . parent . failure <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if self . char in tmp . d : <NEWLINE> <INDENT> self . failure = tmp . d [ self . char ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tmp . num == 0 : <NEWLINE> <INDENT> self . failure = tmp <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = tmp . failure <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def setFailureRoot ( self ) : <NEWLINE> <INDENT> self . failure = self <NEWLINE> <NL> <DEDENT> def setFailureFirstLayer ( self ) : <NEWLINE> <INDENT> self . failure = self . parent <NEWLINE> <NL> <DEDENT> def transition ( self , string ) : <NEWLINE> <INDENT> if string == <STRING> : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> elif string [ 0 ] in self . d : <NEWLINE> <INDENT> tmp = self . d [ string [ 0 ] ] <NEWLINE> num = <STRING> . format ( tmp . num ) <NEWLINE> return [ num ] + tmp . transition ( string [ 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . num == 0 : <NEWLINE> <INDENT> num = <STRING> . format ( self . num ) <NEWLINE> return [ num ] + self . transition ( string [ 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . failure . transition ( string ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ input ( ) for _ in range ( H ) ] <NEWLINE> R , C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ input ( ) for _ in range ( R ) ] <NEWLINE> <NL> root = AC ( 0 , None , <STRING> ) <NEWLINE> root . setFailureRoot ( ) <NEWLINE> num = 1 <NEWLINE> for i in B : <NEWLINE> <INDENT> num = root . insert ( i , num ) <NEWLINE> <DEDENT> d = deque ( ) <NEWLINE> for i in root . d . values ( ) : <NEWLINE> <INDENT> i . setFailureFirstLayer ( ) <NEWLINE> for j in i . d . values ( ) : <NEWLINE> <INDENT> d . appendleft ( j ) <NEWLINE> <DEDENT> <DEDENT> while ( len ( d ) > 0 ) : <NEWLINE> <INDENT> tmp = d . pop ( ) <NEWLINE> tmp . setFailure ( ) <NEWLINE> for i in tmp . d . values ( ) : <NEWLINE> <INDENT> d . appendleft ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> trans = [ <STRING> for i in range ( W ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> tmp = root . transition ( i ) <NEWLINE> for j , k in enumerate ( tmp ) : <NEWLINE> <INDENT> trans [ j ] = trans [ j ] + k + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in B : <NEWLINE> <INDENT> ans = ans + root . transition ( i ) [ - 1 ] + <STRING> <NEWLINE> <NL> <DEDENT> ansd = deque ( ) <NEWLINE> for i , j in enumerate ( trans ) : <NEWLINE> <INDENT> obj = re . search ( ans , j ) <NEWLINE> c = 0 <NEWLINE> while ( obj ) : <NEWLINE> <INDENT> s = obj . start ( ) <NEWLINE> if ( i - C + 1 ) < 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> ansd . append ( ( ( c + s ) // 10 , i - C + 1 ) ) <NEWLINE> obj = re . search ( ans , j [ c + s + 10 : ] ) <NEWLINE> c += s + 10 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in sorted ( ansd ) : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bc . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> a_cnt = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a_cnt [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> a_goukei = sum ( a ) <NEWLINE> <NL> for gyou in range ( q ) : <NEWLINE> <INDENT> a_goukei += ( bc [ gyou ] [ 1 ] - bc [ gyou ] [ 0 ] ) * a_cnt [ bc [ gyou ] [ 0 ] ] <NEWLINE> print ( a_goukei ) <NEWLINE> a_cnt [ bc [ gyou ] [ 1 ] ] += a_cnt [ bc [ gyou ] [ 0 ] ] <NEWLINE> a_cnt [ bc [ gyou ] [ 0 ] ] = 0 <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pairs = [ [ ] for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> input_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pairs [ input_list [ 0 ] ] . append ( input_list [ 1 ] ) <NEWLINE> pairs [ input_list [ 1 ] ] . append ( input_list [ 0 ] ) <NEWLINE> <NL> <DEDENT> ans = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> n_ans = 0 <COMMENT> <NEWLINE> done = [ False for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> todo = [ 1 ] <NEWLINE> <NL> while n_ans < N - 1 : <NEWLINE> <INDENT> for n in todo : <NEWLINE> <INDENT> for m in pairs [ n ] : <NEWLINE> <INDENT> if not done [ m ] : <NEWLINE> <INDENT> done [ m ] = True <NEWLINE> ans [ m ] = n <NEWLINE> n_ans += 1 <NEWLINE> todo . append ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> dp = [ True ] * ( A [ - 1 ] + 1 ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if dp [ A [ i ] ] == True : <NEWLINE> <INDENT> for j in range ( A [ i ] , A [ - 1 ] + 1 , A [ i ] ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <DEDENT> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ A [ - 1 ] ] == True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> head = [ ] <NEWLINE> tail = [ ] <NEWLINE> flip = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> flip ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( query [ 1 ] ) - 1 <NEWLINE> c = query [ 2 ] <NEWLINE> if ( f ^ flip ) == 0 : <NEWLINE> <INDENT> head . append ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tail . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flip : <NEWLINE> <INDENT> head , tail = tail , head <NEWLINE> s = s [ : : - 1 ] <NEWLINE> <NL> <DEDENT> head = <STRING> . join ( head ) <NEWLINE> tail = <STRING> . join ( tail ) <NEWLINE> <NL> print ( head [ : : - 1 ] + s + tail ) <NEWLINE>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> def input ( ) -> str : <COMMENT> <NEWLINE> <INDENT> <STRING> <NEWLINE> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def calc ( p1 : list , p2 : list ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( p2 [ 1 ] - p1 [ 1 ] ) + abs ( p2 [ 0 ] - p1 [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> patterns = { <NEWLINE> <INDENT> <STRING> : ( 1 , 1 ) , <NEWLINE> <STRING> : ( - 1 , 1 ) , <NEWLINE> <STRING> : ( - 1 , - 1 ) , <NEWLINE> <STRING> : ( 1 , - 1 ) , <NEWLINE> <DEDENT> } <NEWLINE> <NL> points : dict = { k : None for k in patterns . keys ( ) } <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for k , ( x , y ) in patterns . items ( ) : <NEWLINE> <INDENT> max_p = points [ k ] <NEWLINE> <NL> if max_p : <NEWLINE> <INDENT> max_p_pos = ( max_p [ 0 ] * x ) + ( max_p [ 1 ] * y ) <NEWLINE> p_pos = ( p [ 0 ] * x ) + ( p [ 1 ] * y ) <NEWLINE> if max_p_pos < p_pos : <NEWLINE> <INDENT> points [ k ] = p <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> points [ k ] = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , p1 in enumerate ( points . values ( ) ) : <NEWLINE> <INDENT> for p2 in list ( points . values ( ) ) [ i + 1 : ] : <NEWLINE> <INDENT> ans = max ( ans , calc ( p1 , p2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> <NL> def battle ( h ) : <NEWLINE> <INDENT> if h == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 * battle ( h // 2 ) + 1 <NEWLINE> <DEDENT> <DEDENT> print ( battle ( H ) ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> seq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = [ False ] * n <NEWLINE> path = [ 1 ] <NEWLINE> i = 0 <NEWLINE> v [ 0 ] = True <NEWLINE> while True : <NEWLINE> <INDENT> if v [ seq [ i ] - 1 ] == False : <NEWLINE> <INDENT> v [ seq [ i ] - 1 ] = True <NEWLINE> path . append ( seq [ i ] ) <NEWLINE> i = seq [ i ] - 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> t = seq [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ind = path . index ( t ) <NEWLINE> path2 = path [ ind : ] <NEWLINE> path1 = path [ : ind ] <NEWLINE> x = len ( path1 ) <NEWLINE> if k >= x : <NEWLINE> <INDENT> k -= x <NEWLINE> <COMMENT> <NL> print ( path2 [ ( k % len ( path2 ) ) ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( path1 [ k ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> for i in range ( X , 102 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> min_ = i <NEWLINE> dif_min = i - X <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> for i in range ( X , - 1 , - 1 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> max_ = i <NEWLINE> dif_max = X - i <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> if dif_max <= dif_min : <NEWLINE> <INDENT> print ( max_ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_ ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> a = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> for b in range ( - a + 1 , a ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , int ( b ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> a += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> from numba import njit <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> @ njit <NEWLINE> def imos ( n , A ) : <NEWLINE> <INDENT> B = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> left = max ( 0 , i - A [ i ] ) <NEWLINE> right = min ( n , i + A [ i ] + 1 ) <NEWLINE> B [ left ] += 1 <NEWLINE> B [ right ] -= 1 <NEWLINE> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B [ : - 1 ] <NEWLINE> <NL> <DEDENT> def solve ( n , k , A ) : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> A = imos ( n , A ) <NEWLINE> min_A = min ( A ) <NEWLINE> if min_A == n : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> ANS = solve ( n , k , A ) <NEWLINE> print ( <STRING> . join ( map ( str , ANS ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> start_h , start_w = map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) <NEWLINE> goal_h , goal_w = map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ <STRING> * ( w + 4 ) ] <NEWLINE> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> <NL> ans = [ [ - 1 ] * ( w + 4 ) for _ in range ( h + 4 ) ] <NEWLINE> for i in range ( h + 4 ) : <NEWLINE> <INDENT> for j in range ( w + 4 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans [ start_h ] [ start_w ] = 0 <NEWLINE> <NL> move1 = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> move2 = [ ( - 2 , - 2 ) , ( - 2 , - 1 ) , ( - 2 , 0 ) , ( - 2 , 1 ) , ( - 2 , 2 ) , ( - 1 , - 2 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) , ( - 1 , 2 ) , ( 0 , - 2 ) , ( 0 , - 1 ) , ( 0 , 0 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( 1 , - 2 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 1 , 2 ) , ( 2 , - 2 ) , ( 2 , - 1 ) , ( 2 , 0 ) , ( 2 , 1 ) , ( 2 , 2 ) ] <NEWLINE> <NL> yet = deque ( [ ( start_h , start_w ) ] ) <NEWLINE> done = deque ( ) <NEWLINE> <NL> while yet : <NEWLINE> <INDENT> x1 , y1 = yet . popleft ( ) <NEWLINE> done . append ( ( x1 , y1 ) ) <NEWLINE> for ( p , q ) in move1 : <NEWLINE> <INDENT> v1 , v2 = x1 + p , y1 + q <NEWLINE> if ans [ v1 ] [ v2 ] == - 1 : <COMMENT> <NEWLINE> <INDENT> yet . append ( ( v1 , v2 ) ) <NEWLINE> ans [ v1 ] [ v2 ] = ans [ x1 ] [ y1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( yet ) == 0 : <NEWLINE> <INDENT> while done : <NEWLINE> <INDENT> x2 , y2 = done . popleft ( ) <NEWLINE> for ( p , q ) in move2 : <NEWLINE> <INDENT> i , j = x2 + p , y2 + q <NEWLINE> if ans [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> yet . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ goal_h ] [ goal_w ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > b : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> X , N = LI ( ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> p = LI ( ) <NEWLINE> <NL> p_max = max ( p ) <NEWLINE> p_min = min ( p ) <NEWLINE> <NL> if X < p_min or p_max < X : <NEWLINE> <INDENT> print ( X ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = [ abs ( i - X ) for i in range ( 0 , 102 ) if i not in p ] <NEWLINE> d_min = min ( d ) <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> if abs ( i - X ) == d_min : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <COMMENT> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , gcd ( b , c ) ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ [ <STRING> ] * W for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> grid [ i ] = list ( str ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> d = deque ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d . append ( ( i , j ) ) <NEWLINE> grid [ i ] [ j ] = <STRING> <NEWLINE> tmp = 1 <NEWLINE> while d : <NEWLINE> <INDENT> p , q = d . popleft ( ) <NEWLINE> for x , y in ( ( 0 , 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> nx = p + x <NEWLINE> ny = q + y <NEWLINE> if nx < 0 or nx >= H or ny < 0 or ny >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if grid [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d . append ( ( nx , ny ) ) <NEWLINE> grid [ nx ] [ ny ] = <STRING> <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> if tmp == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> diff = b - a <NEWLINE> if diff % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif diff % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> left = 0 <NEWLINE> right = float ( <STRING> ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> left = max ( left , l ) <NEWLINE> right = min ( right , r ) <NEWLINE> <NL> <DEDENT> print ( max ( 0 , right - left + 1 ) ) <NEWLINE>
MAX = 10 ** 18 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans > MAX : break <NEWLINE> ans *= a [ i ] <NEWLINE> <NL> <DEDENT> if ans > MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
mod = 1000000007 <NEWLINE> from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 100000 ) <NEWLINE> <NL> <NL> def valid ( i , j , n , m ) : <NEWLINE> <INDENT> if 0 <= i < n and 0 <= j < m and good [ i ] [ j ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def solve ( i , j ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] [ j ] <NEWLINE> <DEDENT> if i == n - 1 and j == m - 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> sm = 0 <NEWLINE> if valid ( i + 1 , j , n , m ) : <NEWLINE> <INDENT> sm += solve ( i + 1 , j ) <NEWLINE> <DEDENT> if valid ( i , j + 1 , n , m ) : <NEWLINE> <INDENT> sm += solve ( i , j + 1 ) <NEWLINE> <DEDENT> dp [ i ] [ j ] = sm % mod <NEWLINE> return dp [ i ] [ j ] <NEWLINE> <NL> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> good = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> good [ i ] . append ( True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> good [ i ] . append ( False ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dp = [ [ - 1 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> print ( solve ( 0 , 0 ) ) <NEWLINE>
I = input ( ) . split ( ) <NEWLINE> n = int ( I [ 0 ] ) <NEWLINE> m = int ( I [ 1 ] ) <NEWLINE> l = int ( I [ 2 ] ) <NEWLINE> <NL> a = [ [ 0 for i2 in range ( m ) ] for i1 in range ( n ) ] <NEWLINE> b = [ [ 0 for i2 in range ( l ) ] for i1 in range ( m ) ] <NEWLINE> c = [ [ 0 for i2 in range ( l ) ] for i1 in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A = input ( ) . split ( ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a [ i ] [ j ] = int ( A [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B = input ( ) . split ( ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> b [ i ] [ j ] = int ( B [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> print ( str ( c [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> if j != l - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
from subprocess import * <NEWLINE> call ( ( <STRING> , <STRING> , <STRING> ) ) <NEWLINE> <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> h = n // 3600 <NEWLINE> m = ( n % 3600 ) // 60 <NEWLINE> s = n % 60 <NEWLINE> <NL> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Answer = 1 <NEWLINE> if 0 in Alist : <NEWLINE> <INDENT> Answer = 0 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> Answer *= Alist [ i ] <NEWLINE> if Answer > 10 ** 18 : <NEWLINE> <INDENT> Answer = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( Answer ) <NEWLINE>
def d ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> warps = [ 1 ] <NEWLINE> w = { } <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> city = A [ warps [ - 1 ] - 1 ] <NEWLINE> <COMMENT> <NL> if city in w : <NEWLINE> <INDENT> lsi = warps . index ( city ) <NEWLINE> Kn = ( K - lsi ) % ( len ( warps ) - lsi ) <NEWLINE> print ( warps [ lsi + Kn ] ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> warps . append ( city ) <NEWLINE> w [ city ] = city <NEWLINE> <DEDENT> <DEDENT> print ( warps [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> def dd ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = [ ] <NEWLINE> w = { } <NEWLINE> now = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , v , w , now ) ) <NEWLINE> p = A [ now ] <NEWLINE> now = p - 1 <NEWLINE> if p in w : <NEWLINE> <INDENT> j = v . index ( p ) <NEWLINE> df = i - j <NEWLINE> Kn = ( K - i - 1 ) % df <NEWLINE> p = v [ j + Kn ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v . append ( p ) <NEWLINE> w [ p ] = p <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> d ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> counter = Counter ( A ) <NEWLINE> ans = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count_b = counter [ b ] <NEWLINE> counter [ b ] -= count_b <NEWLINE> counter [ c ] += count_b <NEWLINE> ans = ans - b * count_b + c * count_b <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 20000 ) <NEWLINE> <NL> def search ( table , visited , i , j , c ) : <NEWLINE> <INDENT> visited [ i ] [ j ] = True <NEWLINE> <NL> if table [ i + 1 ] [ j ] == c and visited [ i + 1 ] [ j ] == False : <NEWLINE> <INDENT> search ( table , visited , i + 1 , j , c ) <NEWLINE> <DEDENT> if table [ i - 1 ] [ j ] == c and visited [ i - 1 ] [ j ] == False : <NEWLINE> <INDENT> search ( table , visited , i - 1 , j , c ) <NEWLINE> <DEDENT> if table [ i ] [ j + 1 ] == c and visited [ i ] [ j + 1 ] == False : <NEWLINE> <INDENT> search ( table , visited , i , j + 1 , c ) <NEWLINE> <DEDENT> if table [ i ] [ j - 1 ] == c and visited [ i ] [ j - 1 ] == False : <NEWLINE> <INDENT> search ( table , visited , i , j - 1 , c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> visited = [ [ False for i in range ( W + 2 ) ] for j in range ( H + 2 ) ] <NEWLINE> table = [ [ <STRING> for i in range ( W + 2 ) ] for j in range ( H + 2 ) ] <NEWLINE> <NL> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> table [ i ] [ j ] = s [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if visited [ i ] [ j ] == False : <NEWLINE> <INDENT> ans += 1 <NEWLINE> search ( table , visited , i , j , table [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> if ( X - i ) not in P : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( X + i ) not in P : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> import string <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> a = i_list ( ) <NEWLINE> even = [ ] <NEWLINE> odd = [ ] <NEWLINE> for i , k in enumerate ( a ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> even . append ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> even . reverse ( ) <NEWLINE> even . extend ( odd ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> even . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , even ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] in d : <NEWLINE> <INDENT> d [ A [ i ] ] . append ( i + 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ A [ i ] ] = [ i + 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> print ( len ( d [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> <NL> walk = min ( k , x // d ) <NEWLINE> k -= walk <NEWLINE> x -= walk * d <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - x ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Z = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> Z [ S [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( Z [ i ] ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> from operator import mul <NEWLINE> l = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> result = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> for i in x : <NEWLINE> <INDENT> if result < limit or i == 0 : <NEWLINE> <INDENT> result = result * i <NEWLINE> <DEDENT> <DEDENT> if limit < result : <NEWLINE> <INDENT> result = - 1 <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> <NL> N = 5 <NEWLINE> ARR = [ 2 , 4 , 4 , 0 , 2 ] <NEWLINE> <NL> N = 7 <NEWLINE> ARR = [ 6 , 4 , 0 , 2 , 4 , 0 , 2 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def calculate ( n , arr ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> n = n // 2 <NEWLINE> start = 1 <NEWLINE> finalResult = pow ( 2 , n , 1000000000 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = n // 2 + 1 <NEWLINE> start = 0 <NEWLINE> finalResult = pow ( 2 , ( n - 1 ) , 1000000000 + 7 ) <NEWLINE> <NL> <DEDENT> result = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> index = start + 2 * i <NEWLINE> if index == 0 : <NEWLINE> <INDENT> result . __setitem__ ( 0 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . __setitem__ ( index , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> isOk = True <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if result . get ( arr [ i ] ) == None : <NEWLINE> <INDENT> isOk = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if result . get ( arr [ i ] ) == 0 : <NEWLINE> <INDENT> isOk = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> result . __setitem__ ( arr [ i ] , result . get ( arr [ i ] ) - 1 ) <NEWLINE> <NL> <DEDENT> if isOk == False : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if sum ( result . values ( ) ) == 0 : <NEWLINE> <INDENT> print ( finalResult ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> calculate ( N , ARR ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> c = Counter ( a ) <NEWLINE> ck = set ( Counter ( a ) . keys ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in ck : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> NUM_MAX = 10 ** 6 + 1 <NEWLINE> def solve ( n , a ) : <NEWLINE> <INDENT> c = [ 0 ] * NUM_MAX <NEWLINE> for x in a : <NEWLINE> <INDENT> c [ x ] += 1 <NEWLINE> <DEDENT> t = any ( sum ( c [ i : : i ] ) > 1 for i in range ( 2 , NUM_MAX ) ) <NEWLINE> t += reduce ( gcd , a ) > 1 <NEWLINE> return [ <STRING> , <STRING> , <STRING> ] [ t ] + <STRING> <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( n , a ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from math import gcd <NEWLINE> from functools import reduce <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> return N , A <NEWLINE> <NL> <NL> <DEDENT> def is_pairwise_coprime ( A ) : <NEWLINE> <INDENT> n = max ( A ) <NEWLINE> base = [ False for i in range ( n + 1 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > 1 and base [ a ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> base [ a ] = True <NEWLINE> <NL> <DEDENT> is_prime = [ True for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> include_number = set ( ) <NEWLINE> if base [ i ] : <NEWLINE> <INDENT> include_number . add ( i ) <NEWLINE> <DEDENT> for j in range ( i + i , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> if base [ j ] : <NEWLINE> <INDENT> include_number . add ( j ) <NEWLINE> <DEDENT> <DEDENT> if len ( include_number ) >= 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , A ) : <NEWLINE> <INDENT> if is_pairwise_coprime ( A ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if reduce ( gcd , A ) == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( n , a , b ) : <NEWLINE> <INDENT> delta = [ b [ i ] - a [ i ] for i in range ( n ) ] <NEWLINE> need = list ( x for x in delta if x > 0 ) <NEWLINE> amari = list ( sorted ( ( abs ( x ) for x in delta if x < 0 ) , reverse = True ) ) <NEWLINE> needScore = sum ( need ) <NEWLINE> if needScore > sum ( amari ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> k = 0 <NEWLINE> s = 0 <NEWLINE> while s < needScore : <NEWLINE> <INDENT> s += amari [ k ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> return k + len ( need ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( N , a , b ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , int ( 1e9 ) + 7 ) ) <NEWLINE>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> edges = [ [ ] for i in range ( N ) ] <COMMENT> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ A - 1 ] += [ B - 1 ] <NEWLINE> edges [ B - 1 ] += [ A - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> que = [ 0 ] <COMMENT> <NEWLINE> ans = [ 0 ] + [ - 1 for i in range ( N - 1 ) ] <COMMENT> <NEWLINE> while - 1 in ans : <COMMENT> <NEWLINE> <INDENT> quetmp = que <NEWLINE> que = [ ] <NEWLINE> for node in quetmp : <COMMENT> <NEWLINE> <INDENT> for neighbor in edges [ node ] : <COMMENT> <NEWLINE> <INDENT> if ans [ neighbor ] == - 1 : <COMMENT> <NEWLINE> <INDENT> ans [ neighbor ] = node + 1 <COMMENT> <NEWLINE> que += [ neighbor ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> l = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if ( t == <STRING> ) : <NEWLINE> <INDENT> ac = ac + 1 <NEWLINE> <DEDENT> elif ( t == <STRING> ) : <NEWLINE> <INDENT> wa = wa + 1 <NEWLINE> <DEDENT> elif ( t == <STRING> ) : <NEWLINE> <INDENT> tle = tle + 1 <NEWLINE> <DEDENT> elif ( t == <STRING> ) : <NEWLINE> <INDENT> re = re + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( ac ) ) <NEWLINE> print ( <STRING> + str ( wa ) ) <NEWLINE> print ( <STRING> + str ( tle ) ) <NEWLINE> print ( <STRING> + str ( re ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <STRING> <NEWLINE> <NL> <NL> first = a [ 0 : n : 2 ] <NEWLINE> last = a [ 1 : n : 2 ] <NEWLINE> last = last [ : : - 1 ] <NEWLINE> answer = last + first <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> answer = answer [ : : - 1 ] <NEWLINE> <NL> <DEDENT> print ( * answer , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> <NL> for ss in s : <NEWLINE> <INDENT> if ss == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif ss == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif ss == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ng = 0 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> j = 1 <NEWLINE> while i + 2 * j < n : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i ] != s [ i + 2 * j ] : <NEWLINE> <INDENT> ng += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( r * g * b - ng ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> a = <STRING> <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global c <NEWLINE> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( 10 ** 9 ) <NEWLINE> R . append ( 10 ** 9 ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergesort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergesort ( A , left , mid ) <NEWLINE> mergesort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> mergesort ( s , 0 , n ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( s [ n - 1 ] ) <NEWLINE> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j - i + j <NEWLINE> if k < n and s [ k ] != s [ i ] and s [ k ] != s [ j ] and s [ i ] != s [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
nums = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> flag = 7 <NEWLINE> while flag >= 0 : <NEWLINE> <INDENT> S = [ ] <NEWLINE> total = nums [ 0 ] <NEWLINE> bin_str = format ( flag , <STRING> ) <NEWLINE> for i , bit in enumerate ( bin_str , 1 ) : <NEWLINE> <INDENT> if int ( bit ) : <NEWLINE> <INDENT> total += nums [ i ] <NEWLINE> S . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total -= nums [ i ] <NEWLINE> S . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if total == 7 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> flag -= 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
from sys import exit <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> d , = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> <COMMENT> <NL> <NL> sche = [ 0 for _ in range ( d ) ] <NEWLINE> s_tmp = float ( <STRING> ) * ( - 1 ) <NEWLINE> for off in range ( 0 , 13 ) : <NEWLINE> <INDENT> last = [ 0 for _ in range ( 26 ) ] <NEWLINE> sche = [ 0 for _ in range ( d ) ] <NEWLINE> for day in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> idx = day - 1 <NEWLINE> d_tmp = float ( <STRING> ) * ( - 1 ) <NEWLINE> i_tmp = 0 <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> delta = 0 <NEWLINE> l_tmp = copy . copy ( last ) <NEWLINE> delta += s [ idx ] [ t ] <NEWLINE> l_tmp [ t ] = day <NEWLINE> for l in range ( 26 ) : <NEWLINE> <INDENT> delta -= 0.5 * ( off + 1 ) * c [ l ] * ( ( day - l_tmp [ l ] ) + ( day + off - l_tmp [ l ] ) ) <NEWLINE> <DEDENT> if delta >= d_tmp : <NEWLINE> <INDENT> d_tmp = delta <NEWLINE> i_tmp = t <NEWLINE> <NL> <DEDENT> <DEDENT> sche [ idx ] = i_tmp + 1 <NEWLINE> <COMMENT> <NL> last [ i_tmp ] = day <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> score = 0 <NEWLINE> last = [ 0 for _ in range ( 26 ) ] <NEWLINE> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> idx = i - 1 <NEWLINE> score += s [ idx ] [ sche [ idx ] - 1 ] <NEWLINE> for l in range ( 26 ) : <NEWLINE> <INDENT> score -= c [ l ] * ( i - last [ l ] ) <NEWLINE> <DEDENT> last [ sche [ idx ] - 1 ] = i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if score >= s_tmp : <NEWLINE> <INDENT> s_tmp = score <NEWLINE> sche_tmp = copy . copy ( sche ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in sche_tmp : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import numpy as np <NEWLINE> ( n , m , x ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( line ) <NEWLINE> <NL> <DEDENT> a = np . array ( a ) <NEWLINE> result = np . array ( [ [ 0 ] * ( m + 1 ) ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( ) <NEWLINE> for j in range ( len ( result ) ) : <NEWLINE> <INDENT> l . append ( a [ i ] + result [ j ] ) <NEWLINE> l . append ( result [ j ] ) <NEWLINE> <DEDENT> result = np . array ( l ) <NEWLINE> <NL> <DEDENT> c = list ( ) <NEWLINE> h = [ x ] * m <NEWLINE> for line in result : <NEWLINE> <INDENT> if np . all ( line [ 1 : ] >= h ) : <NEWLINE> <INDENT> c . append ( line [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( c ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( c ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if min ( A ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> position = 1 <NEWLINE> past_path = defaultdict ( lambda : - 1 ) <NEWLINE> loop_pos = - 1 <NEWLINE> <NL> def move ( position ) : <NEWLINE> <INDENT> return A [ position - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if ( past_path [ position ] != - 1 ) : <NEWLINE> <INDENT> loop_pos = past_path [ position ] <NEWLINE> break <NEWLINE> <DEDENT> past_path [ position ] = i - 1 <NEWLINE> position = move ( position ) <NEWLINE> <NL> <DEDENT> new_past_path = defaultdict ( lambda : - 1 ) <NEWLINE> for k , v in past_path . items ( ) : <NEWLINE> <INDENT> if v >= loop_pos : <NEWLINE> <INDENT> new_past_path [ v - loop_pos ] = k <NEWLINE> <NL> <DEDENT> <DEDENT> if loop_pos != - 1 : <NEWLINE> <INDENT> print ( new_past_path [ ( K - loop_pos ) % len ( new_past_path ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( position ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> b = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> ans += A [ ni ] [ mi ] * b [ mi ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
print ( <STRING> , * [ x for x in range ( 3 , int ( input ( ) ) + 1 ) if x % 3 == 0 or <STRING> in str ( x ) ] ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if t in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = len ( t ) <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> k = i <NEWLINE> l = 0 <NEWLINE> while l < len ( t ) and k < len ( s ) : <NEWLINE> <INDENT> if s [ k ] != t [ l ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> k += 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dic [ A [ i ] ] = i + 1 <NEWLINE> <NL> <DEDENT> ans = [ dic [ i + 1 ] for i in range ( n ) ] <NEWLINE> print ( * ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> sum_of_digits = 0 <NEWLINE> <NL> cnts = [ 0 ] * 2019 <NEWLINE> <NL> cnts [ 0 ] = 1 <NEWLINE> <NL> d = 1 <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> sum_of_digits += int ( c ) * d <NEWLINE> sum_of_digits %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> cnts [ sum_of_digits ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for cnt in cnts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> <NL> line = input ( ) <NEWLINE> v , e = list ( map ( int , line . split ( ) ) ) <NEWLINE> edge = { } <NEWLINE> edge [ 0 ] = [ [ 0 , 0 ] ] <NEWLINE> for _ in range ( 0 , e ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> s , t , w = list ( map ( int , line . split ( ) ) ) <NEWLINE> if s not in edge : <NEWLINE> <INDENT> edge [ s ] = [ [ t , w ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge [ s ] += [ [ t , w ] ] <NEWLINE> <DEDENT> if t not in edge : <NEWLINE> <INDENT> edge [ t ] = [ [ s , w ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge [ t ] += [ [ s , w ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( v , edge ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> vtx = set ( [ i for i in range ( 0 , v ) ] ) <NEWLINE> for t , w in edge [ 0 ] : <NEWLINE> <INDENT> heappush ( q , ( w , 0 , t ) ) <NEWLINE> <DEDENT> vn = set ( [ 0 ] ) <NEWLINE> en = [ ] <NEWLINE> cost = 0 <NEWLINE> while len ( vn ) < v : <NEWLINE> <INDENT> w = s = t = 0 <NEWLINE> qq = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> w , s , t = heappop ( q ) <NEWLINE> if s in vn and t not in vn : <NEWLINE> <INDENT> s , t = t , s <NEWLINE> break <NEWLINE> <DEDENT> if s not in vn and t in vn : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> vn . add ( s ) <NEWLINE> en += [ ( s , t ) ] <NEWLINE> cost += w <NEWLINE> for t , w in edge [ s ] : <NEWLINE> <INDENT> heappush ( q , ( w , s , t ) ) <NEWLINE> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> print ( solve ( v , edge ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a_nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> cumulative_sum = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> cumulative_sum += a_nums [ i ] <NEWLINE> <DEDENT> cumulative_list = [ 0 ] * N <NEWLINE> cumulative_list [ K - 1 ] = cumulative_sum <NEWLINE> <NL> <COMMENT> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> cumulative_sum = cumulative_sum - a_nums [ i - K ] <NEWLINE> cumulative_sum = cumulative_sum + a_nums [ i ] <NEWLINE> cumulative_list [ i ] = cumulative_sum <NEWLINE> if cumulative_list [ i ] > cumulative_list [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> monster = { } <NEWLINE> X = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , h = map ( int , input ( ) . split ( ) ) <NEWLINE> monster [ x ] = h <NEWLINE> X . append ( x ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> q = deque ( [ ] ) <NEWLINE> <NL> acc_damage = 0 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = X [ i ] <NEWLINE> h = monster [ x ] <NEWLINE> <NL> while q and q [ 0 ] [ 0 ] < x : <NEWLINE> <INDENT> p , damage = q . popleft ( ) <NEWLINE> acc_damage -= damage <NEWLINE> <NL> <DEDENT> if h - acc_damage <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> cnt = ( h - acc_damage + A - 1 ) // A <NEWLINE> ans += cnt <NEWLINE> acc_damage += cnt * A <NEWLINE> <NL> q . append ( ( x + 2 * D , cnt * A ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> V = <STRING> <NEWLINE> Lavida = [ 1 ] * 26 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> Lavida [ V . index ( S [ i ] ) ] += 1 <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> count *= Lavida [ i ] <NEWLINE> count = count % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ( count - 1 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
from decimal import * <NEWLINE> import math <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = Decimal ( b ) <NEWLINE> <NL> print ( math . floor ( a * b ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> li = np . zeros ( a [ - 1 ] ) <NEWLINE> <NL> u , counts = np . unique ( a , return_counts = True ) <NEWLINE> <NL> for item in a [ : : - 1 ] : <NEWLINE> <INDENT> li [ item - 1 : : item ] = 0 <NEWLINE> li [ item - 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( len ( u ) ) : <NEWLINE> <INDENT> if counts [ i ] >= 2 : <NEWLINE> <INDENT> li [ u [ i ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( li . sum ( ) ) ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if N == K : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if max ( A ) < 0 and K % 2 == 1 : <COMMENT> <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] >= 0 : <NEWLINE> <INDENT> plus . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> plus . sort ( reverse = True ) <COMMENT> <NEWLINE> minus . sort ( ) <COMMENT> <NEWLINE> plus_k = 0 <NEWLINE> minus_k = 0 <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = plus [ 0 ] <NEWLINE> plus_k = 1 <NEWLINE> <NL> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> if plus_k + minus_k == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if plus_k >= len ( plus ) - 1 : <NEWLINE> <INDENT> ans *= minus [ minus_k ] * minus [ minus_k + 1 ] % mod <NEWLINE> ans %= mod <NEWLINE> minus_k += 2 <NEWLINE> continue <NEWLINE> <DEDENT> if minus_k >= len ( minus ) - 1 : <NEWLINE> <INDENT> ans *= plus [ plus_k ] * plus [ plus_k + 1 ] % mod <NEWLINE> ans %= mod <NEWLINE> plus_k += 2 <NEWLINE> continue <NEWLINE> <DEDENT> if plus [ plus_k ] * plus [ plus_k + 1 ] > minus [ minus_k ] * minus [ minus_k + 1 ] : <NEWLINE> <INDENT> ans *= plus [ plus_k ] * plus [ plus_k + 1 ] % mod <NEWLINE> ans %= mod <NEWLINE> plus_k += 2 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= minus [ minus_k ] * minus [ minus_k + 1 ] % mod <NEWLINE> ans %= mod <NEWLINE> minus_k += 2 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> total = sum ( A ) <NEWLINE> <NL> A_dict = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in A_dict : <NEWLINE> <INDENT> A_dict [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_dict [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b = BC [ i ] [ 0 ] <NEWLINE> c = BC [ i ] [ 1 ] <NEWLINE> <NL> if b in A_dict : <NEWLINE> <INDENT> total += ( c - b ) * A_dict [ b ] <NEWLINE> print ( total ) <NEWLINE> <NL> if c in A_dict : <NEWLINE> <INDENT> A_dict [ c ] += A_dict [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_dict [ c ] = A_dict [ b ] <NEWLINE> <DEDENT> A_dict [ b ] = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> class HashTable ( list ) : <NEWLINE> <INDENT> def __init__ ( self , length ) : <NEWLINE> <INDENT> list . __init__ ( self ) <NEWLINE> self . length = length <NEWLINE> self [ : ] = [ None ] * length <NEWLINE> <NL> <DEDENT> def h ( self , key , i ) : <NEWLINE> <INDENT> h1 = key % self . length <NEWLINE> h2 = 1 + ( key % ( self . length - 1 ) ) <NEWLINE> return ( h1 + i * h2 ) % self . length <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h1 = key % self . length <NEWLINE> h2 = 1 + ( key % ( self . length - 1 ) ) <NEWLINE> j = ( h1 + i * h2 ) % self . length <NEWLINE> <COMMENT> <NL> if self [ j ] is None : <NEWLINE> <INDENT> self [ j ] = key <NEWLINE> return j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def search ( self , key ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h1 = key % self . length <NEWLINE> h2 = 1 + ( key % ( self . length - 1 ) ) <NEWLINE> j = ( h1 + i * h2 ) % self . length <NEWLINE> <COMMENT> <NL> if self [ j ] == key : <NEWLINE> <INDENT> return j <NEWLINE> <DEDENT> elif self [ j ] is None or i >= self . length : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getNum ( char ) : <NEWLINE> <INDENT> char2num = str . maketrans ( <STRING> , <STRING> ) <NEWLINE> return int ( char . translate ( char2num ) , 5 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> T = HashTable ( 1046527 ) <NEWLINE> C = [ input ( ) . split ( <STRING> ) for i in range ( n ) ] <NEWLINE> <NL> for command , char in C : <NEWLINE> <INDENT> num = getNum ( char ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> T . insert ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T . search ( num ) is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
a = 0 <NEWLINE> b = 0 <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> s1 , s2 = input ( ) . split ( ) <NEWLINE> s1 = s1 . lower ( ) <NEWLINE> s2 = s2 . lower ( ) <NEWLINE> if s1 < s2 : <NEWLINE> <INDENT> b += 3 <NEWLINE> <DEDENT> elif s1 > s2 : <NEWLINE> <INDENT> a += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE> <NL>
from queue import Queue <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <DEDENT> def bfs ( ) : <NEWLINE> <INDENT> queue = Queue ( ) <NEWLINE> queue . put ( 1 ) <NEWLINE> distance = [ 10 ** 6 ] * ( n + 1 ) <NEWLINE> distance [ 1 ] = 0 <NEWLINE> while not queue . empty ( ) : <NEWLINE> <INDENT> u = queue . get ( ) <NEWLINE> if u == n and distance [ u ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> for a in adj [ u ] : <NEWLINE> <INDENT> if distance [ u ] + 1 <= 2 and distance [ a ] > distance [ u ] + 1 : <NEWLINE> <INDENT> distance [ a ] = distance [ u ] + 1 <NEWLINE> queue . put ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> bfs ( ) <NEWLINE>
n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> def func ( b ) : <NEWLINE> <INDENT> c = k <NEWLINE> for i in a : <NEWLINE> <INDENT> c -= ( i - 1 ) // b <NEWLINE> if c < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> l = 1 <NEWLINE> r = max ( a ) <NEWLINE> while ( r > l ) : <NEWLINE> <INDENT> lr = ( l + r ) // 2 <NEWLINE> if func ( lr ) : <NEWLINE> <INDENT> r = lr <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = lr + 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> bo = 0 <NEWLINE> for a in range ( N + 1 ) : <NEWLINE> <INDENT> for b in range ( N - a + 1 ) : <NEWLINE> <INDENT> if a * 10000 + b * 5000 + ( N - a - b ) * 1000 == X : <NEWLINE> <INDENT> T = [ a , b , N - a - b ] <NEWLINE> bo += 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if bo == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( * T , sep = <STRING> ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> <NL> i = 1 <NEWLINE> result = a [ 0 ] <NEWLINE> flag = False <NEWLINE> if a [ - 1 ] == 0 : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> result = result * a [ i + 1 ] <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> G [ u ] . append ( v ) <NEWLINE> G [ v ] . append ( u ) <NEWLINE> <DEDENT> lis = [ float ( <STRING> ) ] * N <NEWLINE> ans = [ 0 ] * N <NEWLINE> visited = [ False ] * N <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> i = bisect_left ( lis , a [ v ] ) <NEWLINE> tmp = lis [ i ] <NEWLINE> lis [ i ] = a [ v ] <NEWLINE> ans [ v ] = bisect_left ( lis , float ( <STRING> ) ) <NEWLINE> for c in G [ v ] : <NEWLINE> <INDENT> if visited [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( c ) <NEWLINE> <DEDENT> lis [ i ] = tmp <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ True ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A [ a - 1 ] = False <COMMENT> <NEWLINE> <NL> <DEDENT> waru = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> dp [ 0 ] , dp [ 1 ] = 1 , 1 <COMMENT> <NEWLINE> if not A [ 0 ] : <COMMENT> <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if not A [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % waru <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def mapint ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> query = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = mapint ( ) <NEWLINE> query [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> query [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = mapint ( ) <NEWLINE> from collections import deque <NEWLINE> stack = deque ( [ ( K - 1 , 0 , - 1 ) ] ) <NEWLINE> dist = [ 0 ] * N <NEWLINE> while stack : <NEWLINE> <INDENT> now , cnt , per = stack . pop ( ) <NEWLINE> lis = query [ now ] <NEWLINE> dist [ now ] = cnt <NEWLINE> for nx , c in lis : <NEWLINE> <INDENT> if nx == per : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c != 0 : <NEWLINE> <INDENT> stack . append ( ( nx , cnt + c , now ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> x , y = mapint ( ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> t = <STRING> <NEWLINE> <NL> c = 0 <NEWLINE> cm = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ j ] == t [ i ] : <NEWLINE> <INDENT> low = s [ : j ] . count ( t [ i + 1 ] ) <NEWLINE> high = s [ j : ] . count ( t [ i + 2 ] ) <NEWLINE> c += low * high <NEWLINE> low = s [ : j ] . count ( t [ i + 2 ] ) <NEWLINE> high = s [ j : ] . count ( t [ i + 1 ] ) <NEWLINE> c += low * high <NEWLINE> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> if j + k > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ j - k ] != t [ i ] and s [ j + k ] != t [ i ] and s [ j - k ] != s [ j + k ] : <NEWLINE> <INDENT> cm += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c - cm ) <NEWLINE>
x , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> min_num = 100 <NEWLINE> <NL> ls = [ 0 ] * 201 <NEWLINE> for i in range ( 0 , 201 ) : <NEWLINE> <INDENT> ls [ i ] = i <NEWLINE> <NL> <DEDENT> ls_in = [ 0 ] * n <NEWLINE> if n > 0 : <NEWLINE> <INDENT> ls_in = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in ls_in : <NEWLINE> <INDENT> ls . remove ( i ) <NEWLINE> <DEDENT> ls . reverse ( ) <NEWLINE> for i in ls : <NEWLINE> <INDENT> min_num = min ( abs ( x - i ) , min_num ) <NEWLINE> if abs ( x - i ) == min_num : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> def soi ( n ) : <NEWLINE> <INDENT> k = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if pow ( k , 2 ) > n : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> if n % k == 0 : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> k += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def phi ( n ) : <NEWLINE> <INDENT> ans = n <NEWLINE> while True : <NEWLINE> <INDENT> tmp = soi ( n ) <NEWLINE> <COMMENT> <NL> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while n % tmp == 0 : <NEWLINE> <INDENT> n //= tmp <NEWLINE> <DEDENT> ans *= ( 1 - 1 / tmp ) <NEWLINE> <DEDENT> return int ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> n1 = int ( _input [ 0 ] ) <NEWLINE> print ( phi ( n1 ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i % 2 == 1 and j % 2 == 1 ) or ( i % 2 == 0 and j % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> b_index = M <NEWLINE> <NL> for a_index in range ( N + 1 ) : <NEWLINE> <INDENT> left = K - A [ a_index ] <NEWLINE> if left < 0 : continue <NEWLINE> <NL> while left - B [ b_index ] < 0 : <NEWLINE> <INDENT> b_index -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , a_index + b_index ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> sm = sum ( p [ : k ] ) <NEWLINE> print ( sm ) <NEWLINE>
import sys <NEWLINE> <NL> N = input ( ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 1 <NEWLINE> for i in list1 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in list1 : <NEWLINE> <INDENT> answer *= i <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += i + 1 <NEWLINE> ans [ a [ i ] - 1 ] = str ( ans [ a [ i ] - 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
text = input ( ) <NEWLINE> count = int ( input ( ) ) <NEWLINE> <NL> for c in range ( count ) : <NEWLINE> <INDENT> args = input ( ) . split ( ) <NEWLINE> ( a , b ) = [ int ( x ) for x in args [ 1 : 3 ] ] <NEWLINE> <NL> if args [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( text [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif args [ 0 ] == <STRING> : <NEWLINE> <INDENT> text = text [ 0 : a ] + text [ a : b + 1 ] [ : : - 1 ] + text [ b + 1 : ] <NEWLINE> <DEDENT> elif args [ 0 ] == <STRING> : <NEWLINE> <INDENT> text = text [ 0 : a ] + args [ 3 ] + text [ b + 1 : ] <NEWLINE> <DEDENT> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> div , mod = divmod ( N , A + B ) <NEWLINE> print ( div * A + min ( mod , A ) ) <NEWLINE>
s = input ( ) <NEWLINE> tmp , mod , n , ans = 0 , 2019 , len ( s ) , 0 <NEWLINE> dic = { 0 : 1 } <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> tmp = ( tmp + int ( s [ i ] ) * pow ( 10 , n - i - 1 , mod ) ) % mod <NEWLINE> if tmp in dic . keys ( ) : <NEWLINE> <INDENT> dic [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ tmp ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in dic . items ( ) : <NEWLINE> <INDENT> ans += ( i [ 1 ] * ( i [ 1 ] - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from itertools import accumulate , product , permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from heapq import heappop , heappush <NEWLINE> from math import ceil , floor , sqrt , gcd , inf <NEWLINE> from copy import deepcopy <NEWLINE> import numpy as np <NEWLINE> import scipy as sp <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> INF = inf <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> tmp = 0 <NEWLINE> res = 0 <NEWLINE> <NL> cnt = Counter ( prime_factorize ( n ) ) <NEWLINE> for i in cnt . values ( ) : <NEWLINE> <INDENT> res += floor ( ( - 1 + sqrt ( 1 + 8 * i ) ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
s_list = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s_list . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( s_list ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> x = [ 0 ] * 10 ** 5 <NEWLINE> for i in a : <NEWLINE> <INDENT> x [ i - 1 ] += 1 <NEWLINE> <DEDENT> ans = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b = bc [ i ] [ 0 ] <NEWLINE> c = bc [ i ] [ 1 ] <NEWLINE> x [ c - 1 ] += x [ b - 1 ] <NEWLINE> cnt = x [ b - 1 ] <NEWLINE> dif = c - b <NEWLINE> ans += dif * cnt <NEWLINE> x [ b - 1 ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> ans = A [ 0 ] <NEWLINE> if N > 2 : <NEWLINE> <INDENT> p = ( N - 2 ) // 2 <NEWLINE> q = ( N - 2 ) % 2 <NEWLINE> ans += 2 * sum ( A [ 1 : 1 + p ] ) <NEWLINE> if q == 1 : <NEWLINE> <INDENT> ans += A [ 1 + p ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def process ( tab , beginning , end ) : <NEWLINE> <INDENT> total = beginning <NEWLINE> for i in tab : <NEWLINE> <INDENT> if ( i [ 1 ] > total or total + i [ 0 ] < 0 ) : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> total += i [ 0 ] <NEWLINE> <DEDENT> if ( total == end ) : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> return ( <STRING> ) <NEWLINE> <NL> <DEDENT> def parsing ( N ) : <NEWLINE> <INDENT> beginning , ending = 0 , 0 <NEWLINE> clean = 0 <NEWLINE> total = 0 <NEWLINE> tab = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> before , after = 0 , 0 <NEWLINE> for j in s : <NEWLINE> <INDENT> if ( j == <STRING> ) : <NEWLINE> <INDENT> after += 1 <NEWLINE> <DEDENT> elif ( j == <STRING> ) : <NEWLINE> <INDENT> if ( after > 0 ) : <NEWLINE> <INDENT> after -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> before += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( before == 0 and after > 0 ) : <NEWLINE> <INDENT> beginning += after <NEWLINE> <DEDENT> elif ( after == 0 and before > 0 ) : <NEWLINE> <INDENT> ending += before <NEWLINE> <DEDENT> elif ( before > 0 or after > 0 ) : <NEWLINE> <INDENT> tab . append ( ( after - before , before , after ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> clean += 1 <NEWLINE> <DEDENT> total += before - after <NEWLINE> <DEDENT> tab = sorted ( tab ) [ : : - 1 ] <NEWLINE> return tab , total , beginning , ending , clean <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> tab , total , beginning , ending , clean = parsing ( N ) <NEWLINE> if ( total == 0 and N == 1 ) : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> elif ( ( total != 0 ) or ( ( min ( beginning , ending ) == 0 and clean == 0 ) <NEWLINE> <INDENT> or ( max ( beginning , ending ) == 0 and clean == 1 ) ) ) : <NEWLINE> res = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = process ( tab , beginning , ending ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> n , m , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> dp = [ 1 ] + [ - 1 ] * n <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <NL> <DEDENT> def count ( n ) : <NEWLINE> <INDENT> if dp [ n ] != - 1 : <NEWLINE> <INDENT> return dp [ n ] <NEWLINE> <DEDENT> dp [ n ] = ( count ( n - 1 ) + count ( n - 2 ) ) % ( 10 ** 9 + 7 ) <NEWLINE> return dp [ n ] <NEWLINE> <NL> <NL> <DEDENT> print ( count ( n ) ) <NEWLINE>
n , m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if d == 0 : <NEWLINE> <INDENT> ans = ( m - 1 ) / n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( n - d ) * 2 * ( m - 1 ) / ( n * n ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> dp = [ 0 ] * 100 <NEWLINE> dp [ 0 ] = 1000 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> for j in range ( 0 , i ) : <NEWLINE> <INDENT> V = int ( dp [ j ] / A [ j ] ) <NEWLINE> W = dp [ j ] + ( A [ i ] - A [ j ] ) * V <NEWLINE> dp [ i ] = max ( dp [ i ] , W ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> L . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> A = itertools . combinations_with_replacement ( [ q for q in range ( 1 , ( M + 1 ) ) ] , N ) <NEWLINE> count = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for l in L : <NEWLINE> <NL> <INDENT> if a [ l [ 1 ] - 1 ] - a [ l [ 0 ] - 1 ] == l [ 2 ] : <NEWLINE> <INDENT> tmp += l [ 3 ] <NEWLINE> <DEDENT> <DEDENT> count . append ( tmp ) <NEWLINE> <NL> <DEDENT> print ( max ( count ) ) <NEWLINE>
import math <NEWLINE> <NL> <COMMENT> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( abs ( x [ 0 ] - X ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x . sort ( ) <NEWLINE> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if x [ i ] < X and x [ i + 1 ] > X : <NEWLINE> <INDENT> x = x [ : i + 1 ] + [ X ] + x [ i + 1 : ] <NEWLINE> break <NEWLINE> <DEDENT> elif x [ i ] >= X : <NEWLINE> <INDENT> x = [ X ] + x <NEWLINE> break <NEWLINE> <DEDENT> elif x [ i + 1 ] <= X : <NEWLINE> <INDENT> x = x + [ X ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( x ) >= 3 : <NEWLINE> <INDENT> base = math . gcd ( x [ 1 ] - x [ 0 ] , x [ 2 ] - x [ 1 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> diff = x [ i + 1 ] - x [ i ] <NEWLINE> base = math . gcd ( base , diff ) <NEWLINE> <DEDENT> print ( base ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ 1 ] - x [ 0 ] ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> q = n // ( a + b ) <NEWLINE> <NL> ans += q * a <NEWLINE> q = n - ( a + b ) * q <NEWLINE> <NL> if q - a >= 0 : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> if q - a < 0 : <NEWLINE> <INDENT> ans = ans + a + ( q - a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> count += ( n - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 2 == 0 or n % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> flag = 0 <NEWLINE> num = 7 <NEWLINE> mod = 7 % n <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> if mod == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = ( mod * 10 + 7 ) % n <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> V = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( V [ i ] - C [ i ] ) > 0 : <NEWLINE> <INDENT> m = m + V [ i ] - C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ 0 for i in range ( N ) ] <NEWLINE> visited [ 0 ] = 1 <NEWLINE> tour = [ 1 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> goto = A [ tour [ - 1 ] - 1 ] <NEWLINE> tour . append ( goto ) <NEWLINE> if visited [ goto - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visited [ goto - 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> before = 0 <NEWLINE> shuuki = 1 <NEWLINE> for i in range ( len ( tour ) ) : <NEWLINE> <INDENT> if tour [ i ] == tour [ - 1 ] : <NEWLINE> <INDENT> before = i <NEWLINE> shuuki = len ( tour ) - i - 1 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if K < len ( tour ) : <NEWLINE> <INDENT> print ( tour [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= before <NEWLINE> K %= shuuki <NEWLINE> print ( tour [ before + K ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> def is_prime_number ( x ) : <NEWLINE> <INDENT> if x < 2 : return False <NEWLINE> elif x == 2 : return True <NEWLINE> elif x % 2 == 0 : return False <NEWLINE> <NL> sqrt_upper_bound = math . floor ( math . sqrt ( x ) ) + 1 <NEWLINE> for i in range ( 3 , sqrt_upper_bound , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> prime_num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if is_prime_number ( x ) : <NEWLINE> <INDENT> prime_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prime_num ) <NEWLINE> <NL>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> Surpus = [ 0 ] * 2019 <NEWLINE> Surpus [ 0 ] = 1 <NEWLINE> <NL> sum = 0 <NEWLINE> x = 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> sum += int ( i ) * x <NEWLINE> Surpus [ sum % 2019 ] += 1 <NEWLINE> x *= 10 <NEWLINE> x %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in Surpus : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if result <= 10 ** 18 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
x , n = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> if int ( n ) != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <NL> <DEDENT> all_list = [ i for i in range ( 1 , 101 ) ] <NEWLINE> p = reversed ( sorted ( p ) ) <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> all_list . pop ( i - 1 ) <NEWLINE> <NL> <DEDENT> all_list . insert ( 0 , 0 ) <NEWLINE> all_list . insert ( 0 , - 1 ) <NEWLINE> all_list . append ( 101 ) <NEWLINE> <NL> if x in all_list : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> abs_ = 1000 <NEWLINE> for i in all_list : <NEWLINE> <INDENT> if abs ( x - i ) < abs_ : <NEWLINE> <INDENT> abs_ = abs ( x - i ) <NEWLINE> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> A = N % 1000 <NEWLINE> <NL> if 1000 - A != 1000 : <NEWLINE> <INDENT> print ( 1000 - A ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> out = min ( A , K ) <NEWLINE> if A + B < K : <NEWLINE> <INDENT> out -= ( K - A - B ) <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys , math , os , copy <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> if PYDEV == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> code = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } <NEWLINE> <NL> def pocket_pager ( string ) : <NEWLINE> <INDENT> if len ( string ) % 2 == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> res = <STRING> <NEWLINE> for k in range ( len ( string ) // 2 ) : <NEWLINE> <INDENT> i = int ( string [ 2 * k ] ) <NEWLINE> j = int ( string [ 2 * k + 1 ] ) <NEWLINE> if not 1 <= i <= 6 or not 1 <= j <= 5 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> res += code [ j ] [ i - 1 ] <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> print ( pocket_pager ( line . strip ( ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> g [ u ] . append ( v ) <NEWLINE> <DEDENT> mi = set ( range ( n ) ) <NEWLINE> flg = False <NEWLINE> def func ( path ) : <NEWLINE> <INDENT> chk = set ( path ) <NEWLINE> if len ( path ) != 2 : <NEWLINE> <INDENT> for i , v in enumerate ( path ) : <NEWLINE> <INDENT> nvs = [ nv for nv in g [ v ] if nv in chk ] <NEWLINE> if len ( nvs ) == 1 : continue <NEWLINE> for nv in nvs : <NEWLINE> <INDENT> if nv == path [ ( i + 1 ) % len ( path ) ] : continue <NEWLINE> ary = [ nv ] <NEWLINE> for j , vj in enumerate ( path ) : <NEWLINE> <INDENT> if vj == nv : break <NEWLINE> <DEDENT> if i > j : <NEWLINE> <INDENT> ary = path [ j : i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ary = path [ : i + 1 ] + path [ j : ] <NEWLINE> <COMMENT> <NL> <DEDENT> func ( ary ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( path ) ) <NEWLINE> for v in path : <NEWLINE> <INDENT> print ( v + 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> def dfs ( v , seen ) : <NEWLINE> <INDENT> mi . discard ( v ) <NEWLINE> for nv in g [ v ] : <NEWLINE> <INDENT> if seen [ nv ] != - 1 : <COMMENT> <NEWLINE> <INDENT> seen [ nv ] = v <NEWLINE> path = [ v ] <NEWLINE> chk = { v } <NEWLINE> while seen [ v ] not in chk : <NEWLINE> <INDENT> v = seen [ v ] <NEWLINE> path . append ( v ) <NEWLINE> chk . add ( v ) <NEWLINE> <DEDENT> path . reverse ( ) <NEWLINE> func ( path ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seen [ nv ] = v <NEWLINE> dfs ( nv , seen ) <NEWLINE> seen [ nv ] = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while mi : <NEWLINE> <INDENT> v = mi . pop ( ) <NEWLINE> seen = [ - 1 ] * n <NEWLINE> dfs ( v , seen ) <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def li_input ( ) : <NEWLINE> <INDENT> return [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> C = [ input ( ) . split ( ) for _ in range ( N ) ] <NEWLINE> <NL> D = collections . defaultdict ( lambda : 0 ) <NEWLINE> <NL> for c in C : <NEWLINE> <INDENT> command , value = c <NEWLINE> <NL> if command == <STRING> : <NEWLINE> <INDENT> D [ value ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if D [ value ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> denger = [ False ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> denger [ int ( input ( ) ) ] = True <NEWLINE> <NL> <DEDENT> DP = [ 0 ] * ( n + 1 ) <NEWLINE> DP [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not denger [ i + 1 ] : <NEWLINE> <INDENT> DP [ i + 1 ] += DP [ i ] <NEWLINE> <DEDENT> if i + 2 <= n and not denger [ i + 2 ] : <NEWLINE> <INDENT> DP [ i + 2 ] += DP [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( DP [ - 1 ] % 1000000007 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> b = 10 ** 9 + 7 <NEWLINE> sum1 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ( ans + c [ i ] * sum1 ) % b <NEWLINE> sum1 = ( sum1 + c [ i ] ) % b <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> x = L [ i ] - L [ j ] <NEWLINE> maxindex = bisect . bisect_right ( L , x ) <NEWLINE> if j > maxindex : <NEWLINE> <INDENT> ans += j - maxindex <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ints = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( ints ) <NEWLINE> x = [ 0 ] * m <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in ints : <NEWLINE> <INDENT> if x [ i - 1 ] >= 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( m // i ) : <NEWLINE> <NL> <INDENT> x [ i * ( j + 1 ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ints : <NEWLINE> <INDENT> if x [ i - 1 ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = float ( <STRING> ) * - 1 <NEWLINE> ans = max ( ans , a * c ) <NEWLINE> ans = max ( ans , a * d ) <NEWLINE> ans = max ( ans , b * c ) <NEWLINE> ans = max ( ans , b * d ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = A [ 0 ] <NEWLINE> kazu = ( N - 2 ) // 2 <NEWLINE> amari = ( N - 2 ) % 2 <NEWLINE> for i in range ( 1 , kazu + 1 , 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += ( A [ i ] * 2 ) <NEWLINE> <NL> <DEDENT> if amari == 1 : <NEWLINE> <INDENT> ans += A [ i + 1 ] * amari <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def get_ints ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a , b = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = get_ints ( ) <NEWLINE> a . append ( x + y ) <NEWLINE> b . append ( x - y ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> ans = max ( a [ - 1 ] - a [ 0 ] , b [ - 1 ] - b [ 0 ] ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import copy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxH = np . zeros ( N ) <NEWLINE> <NL> for itr in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H [ A - 1 ] == H [ B - 1 ] : <NEWLINE> <INDENT> maxH [ A - 1 ] = copy . copy ( H [ A - 1 ] ) + 1 <NEWLINE> maxH [ B - 1 ] = copy . copy ( H [ A - 1 ] ) + 1 <NEWLINE> <DEDENT> elif H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> if maxH [ A - 1 ] < H [ A - 1 ] : <NEWLINE> <INDENT> maxH [ A - 1 ] = copy . copy ( H [ A - 1 ] ) <NEWLINE> <DEDENT> if maxH [ B - 1 ] < H [ A - 1 ] : <NEWLINE> <INDENT> maxH [ B - 1 ] = copy . copy ( H [ A - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> if maxH [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> maxH [ A - 1 ] = copy . copy ( H [ B - 1 ] ) <NEWLINE> <DEDENT> if maxH [ B - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> maxH [ B - 1 ] = copy . copy ( H [ B - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> result = 0 <NEWLINE> for itr in range ( N ) : <NEWLINE> <INDENT> if H [ itr ] == maxH [ itr ] or maxH [ itr ] == 0 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> row , col = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if row == 0 and col == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( row ) : <NEWLINE> <INDENT> print ( <STRING> * col ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> knap = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> knap . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( ( N + 1 , W + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> for i , ( w , v ) in enumerate ( knap ) : <NEWLINE> <INDENT> dp [ i + 1 ] = np . maximum ( dp [ i + 1 ] , dp [ i ] ) <NEWLINE> dp [ i + 1 ] [ w : ] = np . maximum ( dp [ i ] [ w : ] , dp [ i ] [ : - w ] + v ) <NEWLINE> <NL> <DEDENT> print ( dp [ N ] [ - 1 ] ) <NEWLINE>
