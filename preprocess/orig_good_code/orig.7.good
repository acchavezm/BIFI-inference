import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if c [ i ] : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def has_duplicates2 ( seq ) : <NEWLINE> <INDENT> seen = [ ] <NEWLINE> unique_list = [ x for x in seq if x not in seen and not seen . append ( x ) ] <NEWLINE> return len ( seq ) != len ( unique_list ) <NEWLINE> <NL> <DEDENT> fact = prime_factorize ( N ) <NEWLINE> <COMMENT> <NL> result = 0 <NEWLINE> <NL> if has_duplicates2 ( fact ) : <NEWLINE> <COMMENT> <NL> <INDENT> chofuku = [ x for x in set ( fact ) if fact . count ( x ) > 1 ] <NEWLINE> for i in chofuku : <NEWLINE> <INDENT> flag = True <NEWLINE> n = 1 <NEWLINE> Count = fact . count ( i ) + 1 <NEWLINE> while flag : <NEWLINE> <INDENT> if ( 1 / 2 * n * ( n - 1 ) < Count <= 1 / 2 * n * ( n + 1 ) ) : <NEWLINE> <INDENT> result += n - 1 <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> NOTchofuku = len ( ( list ( set ( fact ) ) ) ) - len ( chofuku ) <NEWLINE> print ( result + NOTchofuku ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( fact ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <COMMENT> <NL> d = defaultdict ( int ) <NEWLINE> <NL> for ix , c in enumerate ( S ) : <NEWLINE> <COMMENT> <NL> <INDENT> d [ c ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = d [ <STRING> ] * d [ <STRING> ] * d [ <STRING> ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ci = S [ i - 1 ] <NEWLINE> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> cj = S [ j - 1 ] <NEWLINE> <NL> if ci == cj : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> k = j + j - i <NEWLINE> if k <= N : <NEWLINE> <INDENT> ck = S [ k - 1 ] <NEWLINE> if ci != ck and cj != ck : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> costlst = [ ] <NEWLINE> scorelst = [ ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> cost , * score = map ( int , input ( ) . split ( ) ) <NEWLINE> costlst . append ( cost ) <NEWLINE> scorelst . append ( score ) <NEWLINE> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> defaultscore = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> cost += costlst [ j ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> defaultscore [ k ] += scorelst [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if all ( [ defaultscore [ p ] >= x for p in range ( m ) ] ) : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans if ans != float ( <STRING> ) else <STRING> ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> numbers = dict ( ) <NEWLINE> <NL> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> numbers . setdefault ( i , i ** 5 ) <NEWLINE> <NL> <DEDENT> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if numbers [ i ] - numbers [ j ] == X : <NEWLINE> <INDENT> output = [ i , j ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( output [ 0 ] , output [ 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ A - 1 ] . append ( B - 1 ) <NEWLINE> G [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> seen = [ 0 for _ in range ( N ) ] <NEWLINE> seen [ 0 ] = 1 <NEWLINE> shirube = [ - 1 for _ in range ( N - 1 ) ] <NEWLINE> <NL> stack = deque ( [ 0 ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> now = stack . popleft ( ) <NEWLINE> for i in G [ now ] : <NEWLINE> <INDENT> if seen [ i ] == 0 : <NEWLINE> <INDENT> seen [ i ] = 1 <NEWLINE> stack . append ( i ) <NEWLINE> shirube [ i - 1 ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if seen [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> print ( shirube [ j ] + 1 ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> if a [ - 1 ] == b [ 0 ] and b [ - 1 ] == c [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def update ( a ) : <NEWLINE> <INDENT> n = len ( a ) <NEWLINE> b = np . zeros_like ( a ) <COMMENT> <NEWLINE> for i , x in enumerate ( a ) : <COMMENT> <NEWLINE> <INDENT> l = max ( 0 , i - x ) <COMMENT> <NEWLINE> r = min ( n - 1 , i + x ) <COMMENT> <NEWLINE> b [ l ] += 1 <COMMENT> <NEWLINE> if r + 1 < n : <COMMENT> <NEWLINE> <INDENT> b [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> b = np . cumsum ( b ) <COMMENT> <NEWLINE> return b <NEWLINE> <NL> <NL> <DEDENT> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> k = min ( k , 41 ) <COMMENT> <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> a = update ( a ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <COMMENT> <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A . sort ( key = lambda x : - abs ( x ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 1 <NEWLINE> if ( max ( A ) <= 0 and k % 2 == 1 ) or n == k : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * A [ n - 1 - i ] % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mi = 0 <NEWLINE> pl = 0 <NEWLINE> flg = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * A [ i ] % mod <NEWLINE> if A [ i ] > 0 : <NEWLINE> <INDENT> pl = A [ i ] <NEWLINE> <DEDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> mi = A [ i ] <NEWLINE> flg *= - 1 <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif flg == - 1 : <NEWLINE> <INDENT> mi2 = None <NEWLINE> pl2 = None <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i ] >= 0 : <NEWLINE> <INDENT> pl2 = A [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i ] <= 0 : <NEWLINE> <INDENT> mi2 = A [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> can = 0 <NEWLINE> if mi != 0 and pl2 is not None and pl != 0 and mi2 is not None : <NEWLINE> <INDENT> if pl2 * pl > mi2 * mi : <NEWLINE> <INDENT> can = pow ( mi , - 1 , mod ) * pl2 % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> can = pow ( pl , - 1 , mod ) * mi2 % mod <NEWLINE> <DEDENT> <DEDENT> elif mi != 0 and pl2 is not None : <NEWLINE> <INDENT> can = pow ( mi , - 1 , mod ) * pl2 % mod <NEWLINE> <DEDENT> elif pl != 0 and mi2 is not None : <NEWLINE> <INDENT> can = pow ( pl , - 1 , mod ) * mi2 % mod <NEWLINE> <DEDENT> ans = ans * can % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ank = an [ : k ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> print ( [ <STRING> , <STRING> ] [ an [ i ] > ank [ 0 ] ] ) <NEWLINE> ank . pop ( 0 ) <NEWLINE> ank . append ( an [ i ] ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( a - b ) < 10 ** 18 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> F = [ ] <NEWLINE> for ch in S : <NEWLINE> <INDENT> if ch == <STRING> : <NEWLINE> <INDENT> if len ( F ) > 0 : <NEWLINE> <INDENT> F . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> F . append ( ch ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( F ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in dic : <NEWLINE> <INDENT> dic [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for key , value in dic . items ( ) : <NEWLINE> <INDENT> ans += key * value <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in dic : <NEWLINE> <INDENT> if c in dic : <NEWLINE> <INDENT> dic [ c ] += dic [ b ] <NEWLINE> ans += dic [ b ] * ( c - b ) <NEWLINE> del dic [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] = dic [ b ] <NEWLINE> ans += dic [ b ] * ( c - b ) <NEWLINE> del dic [ b ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> temp = { } <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> at , bt = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] = at <NEWLINE> temp [ at ] = temp . get ( at , 0 ) + bt <NEWLINE> <DEDENT> a = list ( set ( a ) ) <NEWLINE> a . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt = cnt + temp [ a [ i ] ] <NEWLINE> if cnt >= k : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> def is_prime ( N ) : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 2 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def prime ( N ) : <NEWLINE> <INDENT> prime = [ ] <NEWLINE> is_prime = [ ] <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i * i > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> is_prime . append ( True ) <NEWLINE> <DEDENT> is_prime [ 0 ] = is_prime [ 1 ] = False <COMMENT> <NEWLINE> n = len ( is_prime ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> prime . append ( i ) <NEWLINE> for j in range ( 2 * i , n , i ) : <NEWLINE> <COMMENT> <NL> <INDENT> is_prime [ j ] = False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return prime , n <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if is_prime ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prime_list , n = prime ( N ) <NEWLINE> used = [ ] <NEWLINE> prime_exponentiation = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( prime_list ) ) : <NEWLINE> <INDENT> now = prime_list [ i ] <NEWLINE> j = 1 <NEWLINE> while now ** j <= N : <NEWLINE> <INDENT> prime_exponentiation . append ( now ** j ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> prime_exponentiation . sort ( ) <NEWLINE> for i in range ( len ( prime_exponentiation ) ) : <NEWLINE> <INDENT> now = prime_exponentiation [ i ] <NEWLINE> if N < now : <NEWLINE> <INDENT> j = 0 <NEWLINE> while not is_prime ( N ) : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while N % prime_list [ j ] == 0 : <NEWLINE> <INDENT> N //= prime_list [ j ] <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if N % now == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> used . append ( now ) <NEWLINE> N //= now <NEWLINE> <DEDENT> <DEDENT> if N not in used and N != 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> n = I ( ) <NEWLINE> c = S ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> r = Counter ( list ( c ) ) [ <STRING> ] <NEWLINE> ans = 0 <NEWLINE> for elem in c [ : r ] : <NEWLINE> <INDENT> if elem == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_num = sum ( a ) <NEWLINE> cnt = Counter ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_num += ( c - b ) * cnt [ b ] <NEWLINE> print ( sum_num ) <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> print ( sum ( p [ : K ] ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> x = [ 0 ] * ( 2020 ) <NEWLINE> x [ 3 ] = 1 <NEWLINE> x [ 4 ] = 1 <NEWLINE> x [ 5 ] = 1 <NEWLINE> for i in range ( 6 , S + 1 ) : <NEWLINE> <INDENT> x [ i ] += 1 <NEWLINE> for j in range ( 3 , i - 2 ) : <NEWLINE> <INDENT> x [ i ] += x [ j ] <NEWLINE> x [ i ] %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x [ S ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_dict = { i : a for i , a in enumerate ( A , 1 ) } <NEWLINE> <NL> History = [ 1 ] <NEWLINE> History_set = { 1 } <NEWLINE> now = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now = A_dict [ now ] <NEWLINE> if now not in History_set : <NEWLINE> <INDENT> History . append ( now ) <NEWLINE> History_set . add ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if K < i : <NEWLINE> <INDENT> print ( History [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = History . index ( now ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> loop_num = len ( History [ e : ] ) <NEWLINE> <COMMENT> <NL> num = ( K - e ) % loop_num <NEWLINE> <COMMENT> <NL> print ( History [ e : ] [ num ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , B ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 2 <NEWLINE> b = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c = b + a <NEWLINE> a , b = b , c <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> I = list ( range ( 1 , m + 1 ) ) <NEWLINE> A = list ( map ( list , itertools . combinations_with_replacement ( I , n ) ) ) <NEWLINE> l = len ( A ) <NEWLINE> ans = [ 0 for i in range ( l ) ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if A [ i ] [ b - 1 ] - A [ i ] [ a - 1 ] == c : <NEWLINE> <INDENT> ans [ i ] += d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> m , n = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if not m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ices = [ [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] for _ in range ( n ) ] <NEWLINE> ices . insert ( 0 , [ 0 ] * ( m + 2 ) , ) <NEWLINE> ices . append ( [ 0 ] * ( m + 2 ) ) <NEWLINE> score = [ [ 0 ] * ( m + 2 ) for _ in range ( n + 2 ) ] <NEWLINE> <NL> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if ices [ x ] [ y ] : <NEWLINE> <INDENT> score [ x ] [ y ] += ( ices [ x - 1 ] [ y ] + ices [ x + 1 ] [ y ] + ices [ x ] [ y - 1 ] + ices [ x ] [ y + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def bfs ( x , y , imap , acc ) : <NEWLINE> <INDENT> imap [ x ] [ y ] = 0 <NEWLINE> acc += 1 <NEWLINE> a = b = c = d = 0 <NEWLINE> if imap [ x - 1 ] [ y ] : <NEWLINE> <INDENT> a = bfs ( x - 1 , y , imap , acc ) <NEWLINE> <DEDENT> if imap [ x + 1 ] [ y ] : <NEWLINE> <INDENT> b = bfs ( x + 1 , y , imap , acc ) <NEWLINE> <DEDENT> if imap [ x ] [ y - 1 ] : <NEWLINE> <INDENT> c = bfs ( x , y - 1 , imap , acc ) <NEWLINE> <DEDENT> if imap [ x ] [ y + 1 ] : <NEWLINE> <INDENT> d = bfs ( x , y + 1 , imap , acc ) <NEWLINE> <DEDENT> imap [ x ] [ y ] = 1 <NEWLINE> return max ( acc , a , b , c , d ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if score [ x ] [ y ] in [ 1 , 2 ] and ices [ x ] [ y ] : <NEWLINE> <INDENT> a = bfs ( x , y , ices , 0 ) <NEWLINE> if ans < a : <NEWLINE> <INDENT> ans = a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dis = abs ( A - B ) <NEWLINE> step = abs ( W - V ) <NEWLINE> print ( <STRING> if dis <= step * T else <STRING> ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) . rstrip ( ) [ : : - 1 ] for i in range ( N ) ] <NEWLINE> S . sort ( key = len ) <NEWLINE> P = 2 ** 61 - 1 <NEWLINE> <NL> from collections import defaultdict <NEWLINE> D = defaultdict ( lambda : [ 0 ] * 26 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> l = ord ( s [ - 1 ] ) - ord ( <STRING> ) <NEWLINE> a = 0 <NEWLINE> tmp = [ 0 ] * 26 <NEWLINE> for c in s [ : - 1 ] : <NEWLINE> <INDENT> i = ord ( c ) - ord ( <STRING> ) <NEWLINE> if a in D : <NEWLINE> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> tmp [ j ] += D [ a ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ans += tmp [ i ] <NEWLINE> tmp [ i ] = 0 <NEWLINE> a = ( a * 27 + i + 1 ) % P <NEWLINE> <DEDENT> ans += tmp [ l ] <NEWLINE> D [ a ] [ l ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
D = int ( input ( ) ) <COMMENT> <NEWLINE> c = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> s = [ 0 ] + [ [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <COMMENT> <NEWLINE> <NL> t = [ 0 ] + [ int ( input ( ) ) for _ in range ( D ) ] <NEWLINE> <NL> M = int ( input ( ) ) <NEWLINE> dq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> <NL> held = [ [ 0 ] for _ in range ( 27 ) ] <NEWLINE> def culc_value ( t ) : <NEWLINE> <INDENT> last = [ 0 ] * 27 <NEWLINE> value = 0 <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> type = t [ d ] <NEWLINE> held [ type ] . append ( d ) <NEWLINE> value += s [ d ] [ type ] <NEWLINE> last [ type ] = d <NEWLINE> for i in range ( 1 , 27 ) : <NEWLINE> <INDENT> value -= c [ i ] * ( d - last [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 27 ) : <NEWLINE> <INDENT> held [ i ] . append ( D + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> return value <NEWLINE> <NL> <NL> <DEDENT> v_lastday = [ ] <NEWLINE> value = culc_value ( t ) <NEWLINE> <NL> for d , q in dq : <NEWLINE> <INDENT> value += - s [ d ] [ t [ d ] ] + s [ d ] [ q ] <NEWLINE> <NL> <COMMENT> <NL> ind = held [ t [ d ] ] . index ( d ) <NEWLINE> r = held [ t [ d ] ] [ ind + 1 ] <NEWLINE> l = held [ t [ d ] ] [ ind - 1 ] <NEWLINE> x = r - l <NEWLINE> value -= ( ( x + 1 ) * x // 2 ) * c [ t [ d ] ] <NEWLINE> y = d - l <NEWLINE> z = r - d <NEWLINE> value += ( ( ( y + 1 ) * y // 2 ) + ( z + 1 ) * z // 2 ) * c [ t [ d ] ] <NEWLINE> <NL> del held [ t [ d ] ] [ ind ] <NEWLINE> t [ d ] = q <NEWLINE> held [ q ] . append ( d ) <NEWLINE> held [ q ] = sorted ( held [ q ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> ind = held [ q ] . index ( d ) <NEWLINE> r = held [ q ] [ ind + 1 ] <NEWLINE> l = held [ q ] [ ind - 1 ] <NEWLINE> x = r - l <NEWLINE> value += ( ( x + 1 ) * x // 2 ) * c [ q ] <NEWLINE> y = d - l <NEWLINE> z = r - d <NEWLINE> value -= ( ( ( y + 1 ) * y // 2 ) + ( z + 1 ) * z // 2 ) * c [ q ] <NEWLINE> <NL> v_lastday . append ( value ) <NEWLINE> <NL> <DEDENT> for ans in v_lastday : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> acc = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acc *= a [ i ] <NEWLINE> if acc > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( acc ) <NEWLINE>
import statistics <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_i = [ A [ i ] - i - 1 for i in range ( N ) ] <NEWLINE> b = statistics . median_high ( A_i ) <NEWLINE> print ( sum ( abs ( a - b ) for a in A_i ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> cost_abl = [ ] <NEWLINE> cost_lis = [ ] <NEWLINE> abl_lis = [ ] <NEWLINE> for i in range ( 1 << n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> abl_sum = [ 0 ] * m <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for j in range ( len ( a ) ) : <NEWLINE> <INDENT> mask = 1 << j <NEWLINE> if i & mask : <NEWLINE> <INDENT> cost += a [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> abl_sum [ k ] += a [ j ] [ k + 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> cost_lis . append ( cost ) <NEWLINE> abl_lis . append ( abl_sum ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> cost_new_lis = [ ] <NEWLINE> for i in range ( len ( abl_lis ) ) : <NEWLINE> <INDENT> if min ( abl_lis [ i ] ) >= x : <NEWLINE> <INDENT> cost_new_lis . append ( cost_lis [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if cost_new_lis == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( cost_new_lis ) ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> array = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> array_2 = [ 0 ] <NEWLINE> <NL> for a in array : <NEWLINE> <INDENT> array_2 . append ( array_2 [ - 1 ] + a ) <NEWLINE> <NL> <DEDENT> output = 0 <NEWLINE> for i in range ( len ( array ) - 1 ) : <NEWLINE> <INDENT> output += array [ i ] * ( array_2 [ - 1 ] - array_2 [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( output % mod ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N > 0 : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> d [ a ] = 1 <NEWLINE> <DEDENT> for i in range ( 0 , 100 ) : <NEWLINE> <INDENT> x = X - i <NEWLINE> y = X + i <NEWLINE> if d [ x ] == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> if d [ y ] == 0 : <NEWLINE> <INDENT> print ( y ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = N * ( N - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , min ( b , a + k - 1 ) + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( max ( b - k + 1 , a + k ) , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> w = int ( input ( ) ) <NEWLINE> ans = [ i + 1 for i in range ( w ) ] <NEWLINE> loop = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> for _ in range ( loop ) : <NEWLINE> <INDENT> left , right = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ans [ left - 1 ] , ans [ right - 1 ] = ans [ right - 1 ] , ans [ left - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
M = 2019 <NEWLINE> a = i = 0 <NEWLINE> d = [ 1 ] + [ 0 ] * M <NEWLINE> p = 1 <NEWLINE> for j in input ( ) [ : : - 1 ] : <NEWLINE> <INDENT> i = ( i + int ( j ) * p ) % M <NEWLINE> a += d [ i ] <NEWLINE> d [ i ] += 1 <NEWLINE> p = p * 10 % M <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> _ = int ( input ( ) ) <NEWLINE> a = LI ( ) <NEWLINE> ans = 1 <NEWLINE> mod = pow ( 10 , 18 ) <NEWLINE> <NL> def main ( ans ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > mod : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> * ( W - 2 ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> count += N - 1 <NEWLINE> continue <NEWLINE> <DEDENT> if N % i == 0 : <NEWLINE> <INDENT> count += N / i - 1 <NEWLINE> <DEDENT> elif N % i >= 1 : <NEWLINE> <INDENT> count += math . floor ( N / i ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( count ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> ans = As [ 0 ] <NEWLINE> N -= 2 <NEWLINE> <NL> p = N // 2 <NEWLINE> ans += sum ( As [ 1 : 1 + p ] ) * 2 <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> ans += As [ 1 + p ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> N , K , * XYC = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> board = np . zeros ( ( 4 * K + 1 , 4 * K + 1 ) , dtype = np . uint16 ) <NEWLINE> for x , y , c in zip ( XYC [ : : 3 ] , XYC [ 1 : : 3 ] , XYC [ 2 : : 3 ] ) : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> x += K <NEWLINE> <DEDENT> x = x % ( 2 * K ) <NEWLINE> y = y % ( 2 * K ) <NEWLINE> board [ x , y ] += 1 <NEWLINE> board [ ( x + K ) % ( 2 * K ) , ( y + K ) % ( 2 * K ) ] += 1 <NEWLINE> <DEDENT> board [ 1 + 2 * K : , 1 + 2 * K : ] = board [ : 2 * K , : 2 * K ] <NEWLINE> board [ 1 : 1 + 2 * K , 1 + 2 * K : ] = board [ 1 + 2 * K : , 1 + 2 * K : ] <NEWLINE> board [ 1 + 2 * K : , 1 : 1 + 2 * K ] = board [ 1 + 2 * K : , 1 + 2 * K : ] <NEWLINE> board [ 1 : 1 + 2 * K , 1 : 1 + 2 * K ] = board [ 1 + 2 * K : , 1 + 2 * K : ] <NEWLINE> board [ 0 , : ] = 0 <NEWLINE> board [ : , 0 ] = 0 <NEWLINE> for j in range ( 1 , 1 + 4 * K ) : <NEWLINE> <INDENT> board [ : , j ] += board [ : , j - 1 ] <NEWLINE> <DEDENT> for j in range ( 1 , 1 + 4 * K ) : <NEWLINE> <INDENT> board [ j , : ] += board [ j - 1 , : ] <NEWLINE> <DEDENT> ans = np . max ( board [ K : 3 * K , K : 3 * K ] + board [ : 2 * K , : 2 * K ] - <NEWLINE> <INDENT> board [ : 2 * K , K : 3 * K ] - board [ K : 3 * K , : 2 * K ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ K + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = k - a <NEWLINE> e = d - b <NEWLINE> f = k - ( a + b ) <NEWLINE> if d <= 0 : <NEWLINE> <INDENT> print ( 1 * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + f * ( - 1 ) ) <NEWLINE> <DEDENT>
import networkx as nx <NEWLINE> from networkx . utils . union_find import UnionFind <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : print ( 1 ) ; exit ( ) <NEWLINE> a = [ [ i for i in input ( ) . split ( ) ] for _ in range ( m ) ] <NEWLINE> g = nx . Graph ( ) <NEWLINE> uf = UnionFind ( ) <NEWLINE> for x in a : <NEWLINE> <INDENT> uf . union ( x [ 0 ] , x [ 1 ] ) <NEWLINE> <DEDENT> print ( len ( max ( uf . to_sets ( ) , key = len ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> exist = False <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if d [ i + j ] [ 0 ] != d [ i + j ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> exist = True <NEWLINE> <DEDENT> <DEDENT> if exist : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def counta ( x , k , d ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = abs ( x ) <NEWLINE> if d < 2 * x : <NEWLINE> <INDENT> ans = x // d <NEWLINE> <COMMENT> <NL> if ans > k : <NEWLINE> <INDENT> print ( abs ( x - k * d ) ) <NEWLINE> return <NEWLINE> <DEDENT> k = k - ans <NEWLINE> x = x - ans * d <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - d ) ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - d ) ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> counta ( x , k , d ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> cnt = Counter ( s ) <NEWLINE> <NL> rn = cnt [ <STRING> ] <NEWLINE> gn = cnt [ <STRING> ] <NEWLINE> bn = n - rn - gn <NEWLINE> <NL> ans = bn * gn * rn <NEWLINE> if n > 2 : <NEWLINE> <NL> <INDENT> for x in range ( n - 2 ) : <NEWLINE> <NL> <INDENT> y = ( n - 1 - x ) // 2 <NEWLINE> for i in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> if ( not s [ x ] == s [ x + i ] ) & ( not s [ x ] == s [ x + i + i ] ) & ( not s [ x + i ] == s [ x + i + i ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > p : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> cache = [ 1 , <NEWLINE> 9 , <NEWLINE> 30 , <NEWLINE> 76 , <NEWLINE> 141 , <NEWLINE> 267 , <NEWLINE> 400 , <NEWLINE> 624 , <NEWLINE> 885 , <NEWLINE> 1249 , <NEWLINE> 1590 , <NEWLINE> 2208 , <NEWLINE> 2689 , <NEWLINE> 3411 , <NEWLINE> 4248 , <NEWLINE> 5248 , <NEWLINE> 6081 , <NEWLINE> 7485 , <NEWLINE> 8530 , <NEWLINE> 10248 , <NEWLINE> 11889 , <NEWLINE> 13687 , <NEWLINE> 15228 , <NEWLINE> 17988 , <NEWLINE> 20053 , <NEWLINE> 22569 , <NEWLINE> 25242 , <NEWLINE> 28588 , <NEWLINE> 31053 , <NEWLINE> 35463 , <NEWLINE> 38284 , <NEWLINE> 42540 , <NEWLINE> 46581 , <NEWLINE> 50893 , <NEWLINE> 55362 , <NEWLINE> 61824 , <NEWLINE> 65857 , <NEWLINE> 71247 , <NEWLINE> 76884 , <NEWLINE> 84388 , <NEWLINE> 89349 , <NEWLINE> 97881 , <NEWLINE> 103342 , <NEWLINE> 111528 , <NEWLINE> 120141 , <NEWLINE> 128047 , <NEWLINE> 134580 , <NEWLINE> 146316 , <NEWLINE> 154177 , <NEWLINE> 164817 , <NEWLINE> 174438 , <NEWLINE> 185836 , <NEWLINE> 194157 , <NEWLINE> 207927 , <NEWLINE> 218812 , <NEWLINE> 233268 , <NEWLINE> 245277 , <NEWLINE> 257857 , <NEWLINE> 268182 , <NEWLINE> 288216 , <NEWLINE> 299257 , <NEWLINE> 313635 , <NEWLINE> 330204 , <NEWLINE> 347836 , <NEWLINE> 362973 , <NEWLINE> 383709 , <NEWLINE> 397042 , <NEWLINE> 416448 , <NEWLINE> 434025 , <NEWLINE> 456967 , <NEWLINE> 471948 , <NEWLINE> 499740 , <NEWLINE> 515581 , <NEWLINE> 536073 , <NEWLINE> 559758 , <NEWLINE> 583960 , <NEWLINE> 604833 , <NEWLINE> 633651 , <NEWLINE> 652216 , <NEWLINE> 683712 , <NEWLINE> 709065 , <NEWLINE> 734233 , <NEWLINE> 754734 , <NEWLINE> 793188 , <NEWLINE> 818917 , <NEWLINE> 846603 , <NEWLINE> 874512 , <NEWLINE> 909496 , <NEWLINE> 933081 , <NEWLINE> 977145 , <NEWLINE> 1006126 , <NEWLINE> 1041504 , <NEWLINE> 1073385 , <NEWLINE> 1106467 , <NEWLINE> 1138536 , <NEWLINE> 1187112 , <NEWLINE> 1215145 , <NEWLINE> 1255101 , <NEWLINE> 1295142 , <NEWLINE> 1342852 , <NEWLINE> 1373253 , <NEWLINE> 1422195 , <NEWLINE> 1453816 , <NEWLINE> 1502376 , <NEWLINE> 1553361 , <NEWLINE> 1595437 , <NEWLINE> 1629570 , <NEWLINE> 1691292 , <NEWLINE> 1726717 , <NEWLINE> 1782111 , <NEWLINE> 1827492 , <NEWLINE> 1887772 , <NEWLINE> 1925853 , <NEWLINE> 1986837 , <NEWLINE> 2033674 , <NEWLINE> 2089776 , <NEWLINE> 2145333 , <NEWLINE> 2197483 , <NEWLINE> 2246640 , <NEWLINE> 2332104 , <NEWLINE> 2379085 , <NEWLINE> 2434833 , <NEWLINE> 2490534 , <NEWLINE> 2554600 , <NEWLINE> 2609625 , <NEWLINE> 2693919 , <NEWLINE> 2742052 , <NEWLINE> 2813988 , <NEWLINE> 2875245 , <NEWLINE> 2952085 , <NEWLINE> 3003306 , <NEWLINE> 3096024 , <NEWLINE> 3157249 , <NEWLINE> 3224511 , <NEWLINE> 3306240 , <NEWLINE> 3388576 , <NEWLINE> 3444609 , <NEWLINE> 3533637 , <NEWLINE> 3591322 , <NEWLINE> 3693924 , <NEWLINE> 3767085 , <NEWLINE> 3842623 , <NEWLINE> 3912324 , <NEWLINE> 4027884 , <NEWLINE> 4102093 , <NEWLINE> 4181949 , <NEWLINE> 4270422 , <NEWLINE> 4361548 , <NEWLINE> 4427853 , <NEWLINE> 4548003 , <NEWLINE> 4616104 , <NEWLINE> 4718640 , <NEWLINE> 4812789 , <NEWLINE> 4918561 , <NEWLINE> 5003286 , <NEWLINE> 5131848 , <NEWLINE> 5205481 , <NEWLINE> 5299011 , <NEWLINE> 5392008 , <NEWLINE> 5521384 , <NEWLINE> 5610705 , <NEWLINE> 5739009 , <NEWLINE> 5818390 , <NEWLINE> 5930196 , <NEWLINE> 6052893 , <NEWLINE> 6156139 , <NEWLINE> 6239472 , <NEWLINE> 6402720 , <NEWLINE> 6493681 , <NEWLINE> 6623853 , <NEWLINE> 6741078 , <NEWLINE> 6864016 , <NEWLINE> 6953457 , <NEWLINE> 7094451 , <NEWLINE> 7215016 , <NEWLINE> 7359936 , <NEWLINE> 7475145 , <NEWLINE> 7593865 , <NEWLINE> 7689630 , <NEWLINE> 7886244 , <NEWLINE> 7984165 , <NEWLINE> 8130747 , <NEWLINE> 8253888 , <NEWLINE> 8403448 , <NEWLINE> 8523897 , <NEWLINE> 8684853 , <NEWLINE> 8802826 , <NEWLINE> 8949612 , <NEWLINE> 9105537 , <NEWLINE> 9267595 , <NEWLINE> 9376656 , <NEWLINE> 9574704 , <NEWLINE> 9686065 , <NEWLINE> 9827097 , <NEWLINE> 9997134 , <NEWLINE> 10174780 , <NEWLINE> 10290813 , <NEWLINE> 10493367 , <NEWLINE> 10611772 , <NEWLINE> 10813692 , <NEWLINE> 10962213 ] <NEWLINE> <NL> print ( cache [ K - 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> left = 0 <NEWLINE> right = max ( a_l ) <NEWLINE> <NL> <NL> def cut ( len ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a_l [ i ] % len == 0 : <NEWLINE> <INDENT> ret += a_l [ i ] // len - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += a_l [ i ] // len <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> while ( right - left ) > 1 : <NEWLINE> <INDENT> _q = ( left + right ) // 2 <NEWLINE> _ret = cut ( _q ) <NEWLINE> if k >= _ret : <NEWLINE> <INDENT> right = _q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = _q <NEWLINE> <NL> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> D = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for p in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for q in range ( - 1 , 2 ) : <NEWLINE> <INDENT> aa = a + p <NEWLINE> bb = b + q <NEWLINE> if 2 <= aa <= h - 1 and 2 <= bb <= w - 1 : <NEWLINE> <INDENT> aabb = str ( aa ) + <STRING> + str ( bb ) <NEWLINE> if aabb in D : <NEWLINE> <INDENT> D [ aabb ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ aabb ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = [ 0 ] * 10 <NEWLINE> V = list ( D . values ( ) ) <NEWLINE> for v in V : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> ans [ 0 ] = ( h - 2 ) * ( w - 2 ) - sum ( ans ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = defaultdict ( int ) <NEWLINE> r = defaultdict ( int ) <NEWLINE> for i , ai in enumerate ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> l [ i - ai ] += 1 <NEWLINE> r [ i + ai ] += 1 <NEWLINE> <DEDENT> print ( sum ( l [ i ] * r [ i ] for i in range ( 1 , n - 1 ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> for h in range ( j + 1 , N + 1 ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> s += 6 * gcd ( a , h ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for p in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if p == q : <NEWLINE> <INDENT> s += p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 3 * gcd ( p , q ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , len ( A ) ) : <NEWLINE> <INDENT> if A [ i - K ] < A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> f = 1 <NEWLINE> prod = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> f = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod if f else - 1 ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( math . pi * r * r , 2 * math . pi * r ) <NEWLINE>
X = input ( ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( X [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> sum = sum * A [ n ] <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> breaked = True <NEWLINE> for b in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == n : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> breaked = False <NEWLINE> <DEDENT> if breaked : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> a , b , c , d = [ ] , [ ] , [ ] , [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a . append ( abcd [ i ] [ 0 ] ) <NEWLINE> b . append ( abcd [ i ] [ 1 ] ) <NEWLINE> c . append ( abcd [ i ] [ 2 ] ) <NEWLINE> d . append ( abcd [ i ] [ 3 ] ) <NEWLINE> <NL> <DEDENT> def score ( A ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for ai , bi , ci , di in zip ( a , b , c , d ) : <NEWLINE> <INDENT> if A [ bi ] - A [ ai ] == ci : <NEWLINE> <INDENT> tmp += di <NEWLINE> <DEDENT> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> def dfs ( A ) : <NEWLINE> <INDENT> if len ( A ) == n + 1 : <NEWLINE> <INDENT> return score ( A ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( A [ - 1 ] , m ) : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> ans = max ( ans , dfs ( A ) ) <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( dfs ( [ 0 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> buka = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> buka [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> print ( buka [ k ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> task_name = ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> a = deque ( ) <NEWLINE> <NL> for task in map ( lambda x : [ x ] if x in task_name else x . split ( ) , sys . stdin . readlines ( ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( task ) == 1 : <NEWLINE> <INDENT> if task [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if task [ 0 ] == <STRING> : <NEWLINE> <INDENT> a . appendleft ( task [ 1 ] ) <NEWLINE> <DEDENT> elif task [ 1 ] in a : <NEWLINE> <INDENT> a . remove ( task [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * a ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ [ <STRING> ] * ( w + 2 ) ] + [ list ( <STRING> + input ( ) + <STRING> ) for i in range ( h ) ] + [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> a = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> <NL> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> a [ i - 1 ] [ j - 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = [ s [ i - 1 ] [ j - 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j + 1 ] , s [ i ] [ j - 1 ] , s [ i ] [ j + 1 ] , s [ i + 1 ] [ j - 1 ] , s [ i + 1 ] [ j ] , s [ i + 1 ] [ j + 1 ] ] <NEWLINE> c = b . count ( <STRING> ) <NEWLINE> <NL> a [ i - 1 ] [ j - 1 ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> a [ i ] = [ str ( x ) for x in a [ i ] ] <NEWLINE> print ( <STRING> . join ( a [ i ] ) ) <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> x . append ( X ) <NEWLINE> x . sort ( ) <NEWLINE> <NL> d = [ ] <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d . append ( x [ n ] - x [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> x = max ( a , b ) <NEWLINE> y = min ( a , b ) <NEWLINE> tmp = x % y <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( d ) <= 1 : <NEWLINE> <INDENT> print ( d [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = d [ 0 ] <NEWLINE> for i in range ( 1 , len ( d ) ) : <NEWLINE> <INDENT> D = gcd ( D , d [ i ] ) <NEWLINE> <DEDENT> print ( D ) <NEWLINE> <DEDENT>
if sum ( [ int ( s ) for s in list ( input ( ) . split ( ) ) ] ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> tree [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dist = [ - 1 ] * N <NEWLINE> def dfs ( v , total_cost ) : <NEWLINE> <COMMENT> <NL> <INDENT> dist [ v ] = total_cost <NEWLINE> for v_next , cost in tree [ v ] : <NEWLINE> <INDENT> if dist [ v_next ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> dfs ( v_next , total_cost + cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( K - 1 , 0 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( dist [ x - 1 ] + dist [ y - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> flag = False <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> r = 0 <NEWLINE> l = N - 1 <NEWLINE> while r < l : <NEWLINE> <INDENT> if C [ r ] == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if C [ l ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l -= 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l -= 1 <NEWLINE> if r == l : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> r += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> <NL> l = [ 0 ] * 100001 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ c ] += l [ b ] <NEWLINE> ans += l [ b ] * ( c - b ) <NEWLINE> l [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> map_lis = [ input ( ) for i in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> def prob ( x , y , h , w ) : <NEWLINE> <INDENT> if 0 <= x < h and 0 <= y < w : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def count ( x , y , lis ) : <NEWLINE> <INDENT> if not lis [ x ] [ y ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def maze ( x , y , lis ) : <NEWLINE> <INDENT> if lis [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> count_lis = np . zeros ( ( H , W ) ) <NEWLINE> num_lis = [ [ ] for i in range ( 1000 ) ] <NEWLINE> if maze ( i , j , map_lis ) : <NEWLINE> <INDENT> count_lis [ i ] [ j ] = 1 <NEWLINE> num_lis [ 0 ] . append ( [ i , j ] ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> for l in num_lis [ k ] : <NEWLINE> <INDENT> if prob ( l [ 0 ] - 1 , l [ 1 ] , H , W ) and count ( l [ 0 ] - 1 , l [ 1 ] , count_lis ) and maze ( l [ 0 ] - 1 , l [ 1 ] , map_lis ) : <NEWLINE> <INDENT> num_lis [ k + 1 ] . append ( [ l [ 0 ] - 1 , l [ 1 ] ] ) <NEWLINE> count_lis [ l [ 0 ] - 1 ] [ l [ 1 ] ] = 1 <NEWLINE> <DEDENT> if prob ( l [ 0 ] , l [ 1 ] - 1 , H , W ) and count ( l [ 0 ] , l [ 1 ] - 1 , count_lis ) and maze ( l [ 0 ] , l [ 1 ] - 1 , map_lis ) : <NEWLINE> <INDENT> num_lis [ k + 1 ] . append ( [ l [ 0 ] , l [ 1 ] - 1 ] ) <NEWLINE> count_lis [ l [ 0 ] ] [ l [ 1 ] - 1 ] = 1 <NEWLINE> <DEDENT> if prob ( l [ 0 ] + 1 , l [ 1 ] , H , W ) and count ( l [ 0 ] + 1 , l [ 1 ] , count_lis ) and maze ( l [ 0 ] + 1 , l [ 1 ] , map_lis ) : <NEWLINE> <INDENT> num_lis [ k + 1 ] . append ( [ l [ 0 ] + 1 , l [ 1 ] ] ) <NEWLINE> count_lis [ l [ 0 ] + 1 ] [ l [ 1 ] ] = 1 <NEWLINE> <DEDENT> if prob ( l [ 0 ] , l [ 1 ] + 1 , H , W ) and count ( l [ 0 ] , l [ 1 ] + 1 , count_lis ) and maze ( l [ 0 ] , l [ 1 ] + 1 , map_lis ) : <NEWLINE> <INDENT> num_lis [ k + 1 ] . append ( [ l [ 0 ] , l [ 1 ] + 1 ] ) <NEWLINE> count_lis [ l [ 0 ] ] [ l [ 1 ] + 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> new_ans = 0 <NEWLINE> for m in num_lis [ 1 : ] : <NEWLINE> <INDENT> if m != [ ] : <NEWLINE> <INDENT> new_ans += 1 <NEWLINE> <DEDENT> if m == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , new_ans ) <NEWLINE> k += 1 <NEWLINE> if num_lis [ k ] == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> border = 10 ** 18 <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > border : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import string <NEWLINE> <NL> cs = string . ascii_lowercase <NEWLINE> def factor ( n ) : <NEWLINE> <INDENT> b = 26 <NEWLINE> ds = [ n % b ] <NEWLINE> n //= b <NEWLINE> while n : <NEWLINE> <INDENT> d = n % b <NEWLINE> ds . append ( d ) <NEWLINE> n //= b <NEWLINE> <DEDENT> return ds <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> lst = [ sum ( 26 ** i for i in range ( p + 1 ) ) - 1 for p in range ( 1 , 12 ) ] <NEWLINE> lst = [ 0 ] + lst <NEWLINE> for i in range ( 1 , len ( lst ) ) : <NEWLINE> <INDENT> if n <= lst [ i ] : <NEWLINE> <INDENT> pos = n - lst [ i - 1 ] - 1 <NEWLINE> fp = factor ( pos ) <NEWLINE> while len ( fp ) < i : <NEWLINE> <INDENT> fp . append ( 0 ) <NEWLINE> <DEDENT> fp . reverse ( ) <NEWLINE> <NL> print ( <STRING> . join ( cs [ d ] for d in fp ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> seq = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 10 ** 9 + 7 <NEWLINE> s = sum ( seq ) <NEWLINE> res = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s -= seq [ i ] <NEWLINE> res += ( seq [ i ] * s ) % a <NEWLINE> <DEDENT> print ( res % a ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * n <NEWLINE> A = [ [ 0 ] * m for i in range ( n ) ] <NEWLINE> <NL> mlist = [ 0 ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> books = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] = books [ 0 ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> A [ i ] [ j ] = books [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> mincost = sys . maxsize <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> sumlist = [ 0 ] * m <NEWLINE> currentcost = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) % 2 ) == 1 : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> sumlist [ k ] += A [ j ] [ k ] <NEWLINE> <DEDENT> currentcost += C [ j ] <NEWLINE> <DEDENT> <DEDENT> if min ( sumlist ) >= x : <NEWLINE> <INDENT> if currentcost < mincost : <NEWLINE> <INDENT> mincost = currentcost <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if mincost == sys . maxsize : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mincost ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> c = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> adj = [ [ ] for _ in range ( W * H ) ] <NEWLINE> dx = [ 1 , - 1 , 0 , 0 ] <NEWLINE> dy = [ 0 , 0 , 1 , - 1 ] <NEWLINE> INF = 10 ** 12 <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if c [ i ] [ j ] == <STRING> : continue <NEWLINE> for k in range ( 4 ) : <NEWLINE> <INDENT> y = i + dy [ k ] <NEWLINE> x = j + dx [ k ] <NEWLINE> if 0 <= y < H and 0 <= x < W and c [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> adj [ W * i + j ] . append ( W * y + x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> queue = deque ( [ W * x1 + y1 ] ) <NEWLINE> visit = [ INF ] * ( W * H ) <NEWLINE> visit [ W * x1 + y1 ] = 0 <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> for u in adj [ now ] : <NEWLINE> <COMMENT> <NL> <INDENT> count = 0 <NEWLINE> direct = u - now <NEWLINE> fromC = now <NEWLINE> toC = u <NEWLINE> while count < K and toC in adj [ fromC ] and visit [ now ] < visit [ toC ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> if visit [ toC ] == INF : <NEWLINE> <INDENT> queue . append ( toC ) <NEWLINE> visit [ toC ] = visit [ now ] + 1 <NEWLINE> <DEDENT> fromC = toC <NEWLINE> toC += direct <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( visit [ W * x2 + y2 ] ) if visit [ W * x2 + y2 ] < INF else print ( - 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def area ( a , b ) : <NEWLINE> <INDENT> c = a * b <NEWLINE> return c <NEWLINE> <NL> <DEDENT> def perimeter_of_the_rectangle ( a , b ) : <NEWLINE> <INDENT> c = ( a + b ) * 2 <NEWLINE> return c <NEWLINE> <NL> <DEDENT> def Rectangle ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = area ( a , b ) <NEWLINE> d = perimeter_of_the_rectangle ( a , b ) <NEWLINE> print ( <STRING> . format ( c , d ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Rectangle ( ) <NEWLINE> <NL> <DEDENT>
from operator import itemgetter <NEWLINE> from itertools import * <NEWLINE> from bisect import * <NEWLINE> from collections import * <NEWLINE> from heapq import * <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def LLI1 ( rows_number ) : return [ LI1 ( ) for _ in range ( rows_number ) ] <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> def MI1 ( ) : return map ( int1 , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> dij = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> <NL> def SCC ( to , ot ) : <NEWLINE> <INDENT> n = len ( to ) <NEWLINE> <NL> def dfs ( u ) : <NEWLINE> <INDENT> for v in to [ u ] : <NEWLINE> <INDENT> if com [ v ] : continue <NEWLINE> com [ v ] = 1 <NEWLINE> dfs ( v ) <NEWLINE> <DEDENT> top . append ( u ) <NEWLINE> <NL> <DEDENT> top = [ ] <NEWLINE> com = [ 0 ] * n <NEWLINE> for u in range ( n ) : <NEWLINE> <INDENT> if com [ u ] : continue <NEWLINE> com [ u ] = 1 <NEWLINE> dfs ( u ) <NEWLINE> <NL> <DEDENT> def rdfs ( u , k ) : <NEWLINE> <INDENT> for v in ot [ u ] : <NEWLINE> <INDENT> if com [ v ] != - 1 : continue <NEWLINE> com [ v ] = k <NEWLINE> rdfs ( v , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> com = [ - 1 ] * n <NEWLINE> k = 0 <NEWLINE> for u in top [ : : - 1 ] : <NEWLINE> <INDENT> if com [ u ] != - 1 : continue <NEWLINE> com [ u ] = k <NEWLINE> rdfs ( u , k ) <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> return k , com <NEWLINE> <NL> <DEDENT> class TwoSat : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> self . to = [ [ ] for _ in range ( n * 2 ) ] <NEWLINE> self . ot = [ [ ] for _ in range ( n * 2 ) ] <NEWLINE> self . vals = [ ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def add_edge ( self , u , u_val , v , v_val ) : <NEWLINE> <INDENT> self . to [ u * 2 + u_val ] . append ( v * 2 + v_val ) <NEWLINE> self . ot [ v * 2 + v_val ] . append ( u * 2 + u_val ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def satisfy ( self ) : <NEWLINE> <INDENT> k , com = SCC ( self . to , self . ot ) <NEWLINE> for u in range ( self . n ) : <NEWLINE> <INDENT> if com [ u * 2 ] == com [ u * 2 + 1 ] : return False <NEWLINE> self . vals . append ( com [ u * 2 ] < com [ u * 2 + 1 ] ) <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> n , d = MI ( ) <NEWLINE> xy = LLI ( n ) <NEWLINE> ts = TwoSat ( n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 = xy [ i ] <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> x2 , y2 = xy [ j ] <NEWLINE> if abs ( x1 - x2 ) < d : <NEWLINE> <INDENT> ts . add_edge ( i , 0 , j , 1 ) <NEWLINE> ts . add_edge ( j , 0 , i , 1 ) <NEWLINE> <DEDENT> if abs ( x1 - y2 ) < d : <NEWLINE> <INDENT> ts . add_edge ( i , 0 , j , 0 ) <NEWLINE> ts . add_edge ( j , 1 , i , 1 ) <NEWLINE> <DEDENT> if abs ( y1 - x2 ) < d : <NEWLINE> <INDENT> ts . add_edge ( i , 1 , j , 1 ) <NEWLINE> ts . add_edge ( j , 0 , i , 0 ) <NEWLINE> <DEDENT> if abs ( y1 - y2 ) < d : <NEWLINE> <INDENT> ts . add_edge ( i , 1 , j , 0 ) <NEWLINE> ts . add_edge ( j , 1 , i , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ts . satisfy ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for j , xyi in zip ( ts . vals , xy ) : print ( xyi [ j ] ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> data = sorted ( list ( set ( a ) ) ) <NEWLINE> max_ = max ( a ) + 1 <NEWLINE> prime_bool = [ True ] * max_ <NEWLINE> prime_bool [ 0 ] = False <NEWLINE> <NL> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> p = data [ i ] <NEWLINE> if prime_bool [ p ] : <NEWLINE> <COMMENT> <NL> <INDENT> k = 2 <NEWLINE> while k * p < max_ : <NEWLINE> <INDENT> prime_bool [ k * p ] = False <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( prime_bool ) ) : <NEWLINE> <INDENT> if prime_bool [ i ] : <NEWLINE> <INDENT> if c [ i ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <COMMENT> <NL>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> key = nums [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and nums [ j ] > key : <NEWLINE> <INDENT> nums [ j + 1 ] = nums [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> nums [ j + 1 ] = key <NEWLINE> print ( <STRING> . join ( map ( str , nums ) ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <NL> r = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( ) <NEWLINE> r . append ( a ) <NEWLINE> <DEDENT> a = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( - 1 ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x = 0 ; y = 0 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> r [ x ] . append ( y ) <NEWLINE> r [ y ] . append ( x ) <NEWLINE> <NL> <NL> <DEDENT> a [ 0 ] = 0 <NEWLINE> now = [ 0 ] <NEWLINE> while len ( now ) != 0 : <NEWLINE> <INDENT> nex = list ( ) <NEWLINE> for i in now : <NEWLINE> <INDENT> for j in r [ i ] : <NEWLINE> <INDENT> if a [ j ] == - 1 : <NEWLINE> <INDENT> a [ j ] = i <NEWLINE> nex . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> now = nex <NEWLINE> <NL> <NL> <DEDENT> if - 1 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for item in a [ 1 : ] : <NEWLINE> <INDENT> print ( item + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from heapq import * <NEWLINE> H = [ ] <NEWLINE> O = [ ] <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e [ 0 ] : heappush ( H , - int ( e [ 7 : ] ) ) <NEWLINE> elif <STRING> == e [ 2 ] : O += [ - heappop ( H ) ] <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , O ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> roads = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> roads [ a ] . append ( b ) <NEWLINE> roads [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in roads [ i ] : <NEWLINE> <INDENT> if h [ i ] <= h [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import copy <NEWLINE> import itertools <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = ns ( ) <NEWLINE> p = na1 ( ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = ns ( ) <NEWLINE> uf . union ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i , pi in enumerate ( p ) : <NEWLINE> <INDENT> if uf . same ( i , pi ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> RGB = [ [ ] , [ ] , [ ] ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> RGB [ 0 ] . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> RGB [ 1 ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RGB [ 2 ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> total = len ( RGB [ 0 ] ) * len ( RGB [ 1 ] ) * len ( RGB [ 2 ] ) <NEWLINE> RGB . sort ( key = lambda x : len ( x ) ) <NEWLINE> len_B = len ( RGB [ 2 ] ) <NEWLINE> max_B = max ( RGB [ 2 ] ) <NEWLINE> min_B = min ( RGB [ 2 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> bool_B = [ False for i in range ( n ) ] <NEWLINE> for i in RGB [ 2 ] : <NEWLINE> <INDENT> bool_B [ i ] = True <NEWLINE> <NL> <DEDENT> for rg in itertools . product ( RGB [ 0 ] , RGB [ 1 ] ) : <NEWLINE> <INDENT> r = rg [ 0 ] <NEWLINE> g = rg [ 1 ] <NEWLINE> dif = abs ( r - g ) <NEWLINE> <NL> up = max ( r , g ) + dif <NEWLINE> down = min ( r , g ) - dif <NEWLINE> <NL> if max_B >= up : <NEWLINE> <INDENT> if bool_B [ up ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> if min_B <= down and max_B >= down : <NEWLINE> <INDENT> if bool_B [ down ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> if dif % 2 == 0 : <NEWLINE> <INDENT> center = ( r + g ) // 2 <NEWLINE> if min_B <= center and max_B >= center : <NEWLINE> <INDENT> if bool_B [ center ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> v = [ A [ : ] ] <NEWLINE> now = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> tmp = v [ - 1 ] <NEWLINE> v . append ( [ tmp [ x ] for x in tmp ] ) <NEWLINE> if K >> i & 1 : <NEWLINE> <INDENT> now = v [ i ] [ now ] <NEWLINE> <DEDENT> <DEDENT> print ( now + 1 ) <NEWLINE>
def funct ( a ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> if ( 0 in a ) : return 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> c *= a [ i ] <NEWLINE> if ( c > 10 ** 18 ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return c <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( funct ( a ) ) <NEWLINE>
<NL> import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> D = defaultdict ( int ) <NEWLINE> <NL> AM = A [ - 1 ] <NEWLINE> dp = [ True ] * ( AM ) <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> if dp [ x - 1 ] : <NEWLINE> <INDENT> temp = 2 * x <NEWLINE> while temp <= AM : <NEWLINE> <INDENT> dp [ temp - 1 ] = False <NEWLINE> temp += x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x in A : <NEWLINE> <INDENT> if dp [ x - 1 ] : <NEWLINE> <INDENT> D [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( [ i for i in D if D [ i ] == 1 ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> R = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 40 <NEWLINE> S = [ - INF ] * N <NEWLINE> S [ 0 ] = 0 <NEWLINE> <NL> def score ( fst , s , C ) : <NEWLINE> <INDENT> for nx , p in R [ fst ] : <NEWLINE> <INDENT> if S [ nx ] >= s + p or S [ nx ] >= INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S [ nx ] = s + p <NEWLINE> if nx in C : <NEWLINE> <INDENT> S [ nx ] = INF <NEWLINE> <DEDENT> C [ nx ] = C . get ( nx , 0 ) + 1 <NEWLINE> score ( nx , S [ nx ] , C ) <NEWLINE> C [ nx ] -= 1 <NEWLINE> if C [ nx ] == 0 : <NEWLINE> <INDENT> del C [ nx ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> score ( 0 , 0 , { 0 : 1 } ) <NEWLINE> <NL> if S [ - 1 ] < INF : <NEWLINE> <INDENT> ans = S [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import sys <NEWLINE> def p ( * _a ) : <NEWLINE> <INDENT> return <NEWLINE> _s = <STRING> . join ( map ( str , _a ) ) <NEWLINE> <COMMENT> <NL> sys . stderr . write ( _s + <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> from itertools import accumulate <NEWLINE> C = list ( accumulate ( A ) ) <NEWLINE> D = list ( accumulate ( B ) ) <NEWLINE> <NL> p ( * C ) <NEWLINE> p ( * D ) <NEWLINE> <NL> ans = 0 <NEWLINE> d = len ( D ) - 1 <NEWLINE> for c in range ( len ( C ) ) : <NEWLINE> <INDENT> if C [ c ] > K : break <NEWLINE> while True : <NEWLINE> <INDENT> if C [ c ] + D [ d ] <= K : break <NEWLINE> d -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , c + d ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def solve0 ( N , AS ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if AS [ i ] * AS [ j ] % 1000000000_000000000 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def solve1 ( N , AS ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> P2 = [ ] <NEWLINE> P5 = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p2 = 0 <NEWLINE> p5 = 0 <NEWLINE> x = AS [ i ] <NEWLINE> while x % 2 == 0 : <NEWLINE> <INDENT> p2 += 1 <NEWLINE> x //= 2 <NEWLINE> <DEDENT> while x % 5 == 0 : <NEWLINE> <INDENT> p5 += 1 <NEWLINE> x //= 5 <NEWLINE> <DEDENT> P2 . append ( p2 ) <NEWLINE> P5 . append ( p5 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if P2 [ i ] + P2 [ j ] > 17 and P5 [ i ] + P5 [ j ] > 17 : <NEWLINE> <COMMENT> <NL> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , AS ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> ret = 0 <NEWLINE> P2 = [ ] <NEWLINE> P5 = [ ] <NEWLINE> P = np . zeros ( ( 20 , 20 ) , dtype = np . int ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p2 = 0 <NEWLINE> p5 = 0 <NEWLINE> x = AS [ i ] <NEWLINE> while x % 2 == 0 : <NEWLINE> <INDENT> p2 += 1 <NEWLINE> x //= 2 <NEWLINE> <DEDENT> while x % 5 == 0 : <NEWLINE> <INDENT> p5 += 1 <NEWLINE> x //= 5 <NEWLINE> <DEDENT> if p2 > 18 : <NEWLINE> <INDENT> p2 = 18 <NEWLINE> <DEDENT> P2 . append ( p2 ) <NEWLINE> P5 . append ( p5 ) <NEWLINE> P [ p2 , p5 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 19 , 0 , - 1 ) : <NEWLINE> <INDENT> P [ i - 1 ] += P [ i ] <NEWLINE> <DEDENT> for i in range ( 19 , 0 , - 1 ) : <NEWLINE> <INDENT> P [ : , i - 1 ] += P [ : , i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ret += P [ 18 - P2 [ i ] , 18 - P5 [ i ] ] <NEWLINE> <DEDENT> ret -= P [ 9 , 9 ] <NEWLINE> ret //= 2 <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> AS = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) . strip ( ) <NEWLINE> try : <NEWLINE> <INDENT> v = int ( s ) * 1000000000 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> s1 , s2 = s . split ( <STRING> ) <NEWLINE> s2 = s2 + <STRING> * ( 9 - len ( s2 ) ) <NEWLINE> v = int ( s1 ) * 1000000000 + int ( s2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> AS . append ( v ) <NEWLINE> <DEDENT> print ( solve ( N , AS ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> T1 = <STRING> <NEWLINE> TEST_T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> TEST_T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> TEST_T3 = <STRING> <NEWLINE> <NL> T4 = <STRING> <NEWLINE> TEST_T4 = <STRING> <NEWLINE> <NL> T5 = <STRING> <NEWLINE> TEST_T5 = <STRING> <NEWLINE> <NL> T6 = <STRING> <NEWLINE> TEST_T6 = <STRING> <NEWLINE> <NL> T7 = <STRING> <NEWLINE> TEST_T7 = <STRING> <NEWLINE> <NL> T8 = <STRING> <NEWLINE> TEST_T8 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> g = globals ( ) <NEWLINE> for k in sorted ( g ) : <NEWLINE> <INDENT> if k . startswith ( <STRING> ) : <NEWLINE> <INDENT> doctest . run_docstring_examples ( g [ k ] , g , name = k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> g = globals ( ) <NEWLINE> g [ <STRING> ] = lambda : bytes ( f . readline ( ) , <STRING> ) <NEWLINE> g [ <STRING> ] = lambda : bytes ( f . read ( ) , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
M = 1000 <NEWLINE> DM = M * 2 + 1 <NEWLINE> <NL> def count ( n ) : <NEWLINE> <INDENT> global M <NEWLINE> res = n + 1 <NEWLINE> if n > M : <NEWLINE> <INDENT> res -= ( n - M ) * 2 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a in range ( min ( DM , n ) , - 1 , - 1 ) : <NEWLINE> <INDENT> b = n - a <NEWLINE> if b > DM : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += count ( a ) * count ( b ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l = input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nm = int ( l ) <NEWLINE> print ( solve ( nm ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> S_list = np . zeros ( N ) <NEWLINE> <COMMENT> <NL> e_list = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> n = 0 <NEWLINE> for k in range ( len ( s ) ) : <NEWLINE> <INDENT> n = n + ( e_list . index ( s [ k ] ) + 1 ) * ( 100 ** k ) <NEWLINE> <DEDENT> S_list [ i ] = n <NEWLINE> <DEDENT> print ( len ( np . unique ( S_list ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> w = c . count ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - w ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> prime_list = [ ] <NEWLINE> <COMMENT> <NL> search_list = list ( range ( 2 , n + 1 ) ) <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if search_list [ 0 ] > math . sqrt ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> prime_list . extend ( search_list ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> head_num = search_list [ 0 ] <NEWLINE> prime_list . append ( head_num ) <NEWLINE> <COMMENT> <NL> search_list . pop ( 0 ) <NEWLINE> <COMMENT> <NL> search_list = [ num for num in search_list if num % head_num != 0 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for x in prime_list : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> nl = 1 <NEWLINE> while ( x ** nl <= n ) : <NEWLINE> <INDENT> tmp += n // ( x ** nl ) <NEWLINE> nl += 1 <NEWLINE> <DEDENT> ans *= tmp + 1 <NEWLINE> <DEDENT> if ans >= 10 ** 9 + 7 : <NEWLINE> <INDENT> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int1 , readline ( ) . split ( ) ) <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <DEDENT> ans = [ None ] * ( N ) <NEWLINE> <NL> visited = [ False ] * N <NEWLINE> visited [ 0 ] = True <NEWLINE> <NL> que = deque ( [ 0 ] ) <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> acc = que . popleft ( ) <NEWLINE> for connected in graph [ acc ] : <NEWLINE> <INDENT> if visited [ connected ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ans [ connected ] = acc + 1 <NEWLINE> visited [ connected ] = True <NEWLINE> que . append ( connected ) <NEWLINE> <NL> <DEDENT> <DEDENT> if sum ( visited ) == len ( visited ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for sign in ans [ 1 : ] : <NEWLINE> <INDENT> print ( sign ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from operator import itemgetter <NEWLINE> from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> cnt = 0 <NEWLINE> left_list = [ i + a for i , a in enumerate ( A , 1 ) ] <NEWLINE> right_list = [ i - a for i , a in enumerate ( A , 1 ) ] <NEWLINE> right_dict = defaultdict ( set ) <NEWLINE> for i , right in enumerate ( right_list , 1 ) : <NEWLINE> <INDENT> right_dict [ right ] . add ( i ) <NEWLINE> <DEDENT> for i , left in enumerate ( left_list , 1 ) : <NEWLINE> <INDENT> pair_num = len ( right_dict [ left ] ) <NEWLINE> cnt += pair_num <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> MOD = 1000000007 <NEWLINE> N = int ( readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> d_S = defaultdict ( int ) <NEWLINE> d_T = defaultdict ( int ) <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y % x , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> zeros = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if A == 0 and B == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif A == 0 : <NEWLINE> <INDENT> d_S [ ( 1 , 0 ) ] += 0 <NEWLINE> d_T [ ( 0 , - 1 ) ] += 1 <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> d_S [ ( 1 , 0 ) ] += 1 <NEWLINE> d_T [ ( 0 , - 1 ) ] += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( A , B ) <NEWLINE> A //= g <NEWLINE> B //= g <NEWLINE> <COMMENT> <NL> if A < 0 and B < 0 : <NEWLINE> <INDENT> A *= - 1 <NEWLINE> B *= - 1 <NEWLINE> <DEDENT> if A * B > 0 : <NEWLINE> <INDENT> d_S [ ( A , B ) ] += 1 <NEWLINE> d_T [ ( B , - A ) ] += 0 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> d_S [ ( - A , B ) ] += 0 <NEWLINE> d_T [ ( B , A ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for ( si , sj ) , s_cnt in d_S . items ( ) : <NEWLINE> <INDENT> t_cnt = d_T [ ( sj , - 1 * si ) ] <NEWLINE> tmp = 0 <NEWLINE> tmp += pow ( 2 , s_cnt , MOD ) - 1 <NEWLINE> tmp += pow ( 2 , t_cnt , MOD ) - 1 <NEWLINE> tmp += 1 <NEWLINE> ans = ( ans * tmp ) % MOD <NEWLINE> <NL> <DEDENT> ans -= 1 <NEWLINE> ans += zeros <NEWLINE> <NL> print ( ans % MOD ) <NEWLINE>
import sys , math <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> a = float ( input ( ) ) <NEWLINE> print ( a ** 2 * math . pi , a * 2 * math . pi ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
t = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] <NEWLINE> case1 = [ ( 0 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <NEWLINE> case2 = [ ( 1 , - 1 ) , ( 1 , 1 ) , ( - 1 , 1 ) , ( - 1 , - 1 ) ] <NEWLINE> case3 = [ ( 0 , - 2 ) , ( 2 , 0 ) , ( 0 , 2 ) , ( - 2 , 0 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for c in [ case1 , case2 , case3 ] [ : s ] : <NEWLINE> <INDENT> for _x , _y in c : <NEWLINE> <INDENT> if y + _y < 0 or x + _x < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> t [ y + _y ] [ x + _x ] += 1 <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( 1 for l in t for v in l if not v ) ) <NEWLINE> print ( max ( v for l in t for v in l ) ) <NEWLINE>
from math import factorial <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> print ( factorial ( N ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> T = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 1 ] * ( M + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp_prev = dp [ : ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if S [ i ] == T [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] = ( dp_prev [ j + 1 ] + dp [ j ] ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ j + 1 ] = ( dp_prev [ j + 1 ] + dp [ j ] - dp_prev [ j ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ M ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> num = float ( input ( ) ) <NEWLINE> <NL> print ( str ( num ** 2 * math . pi ) + <STRING> + str ( 2 * num * math . pi ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> a , b = a - 1 , b - 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> dist = [ INF ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> back = [ - 1 ] * n <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for to in G [ v ] : <NEWLINE> <INDENT> if dist [ v ] + 1 >= dist [ to ] : continue <NEWLINE> dist [ to ] = dist [ v ] <NEWLINE> back [ to ] = v + 1 <NEWLINE> q . append ( to ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * back [ 1 : ] , sep = <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> city = 0 <NEWLINE> if K <= N : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> city = A [ city ] - 1 <NEWLINE> <DEDENT> print ( city + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited = [ - 1 ] * N <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> if visited [ city ] != - 1 : <NEWLINE> <INDENT> roop_start = visited [ city ] <NEWLINE> cycle_num = k - roop_start <NEWLINE> break <NEWLINE> <DEDENT> visited [ city ] = k <NEWLINE> city = A [ city ] - 1 <NEWLINE> <DEDENT> K = ( K - roop_start ) % cycle_num + roop_start <NEWLINE> city = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> city = A [ city ] - 1 <NEWLINE> <DEDENT> print ( city + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> z = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d1 , d2 = [ int ( d ) for d in input ( ) . split ( <STRING> ) ] <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> z . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> zc = [ ] <NEWLINE> now = 2 <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( z ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> now = z [ i ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif now == z [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif now == 1 and z [ i ] == 0 : <NEWLINE> <INDENT> zc . append ( c ) <NEWLINE> c = 1 <NEWLINE> now = z [ i ] <NEWLINE> <DEDENT> elif now == 0 and z [ i ] == 1 : <NEWLINE> <INDENT> c = 1 <NEWLINE> now = z [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if now == 1 : <NEWLINE> <INDENT> zc . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if len ( zc ) > 0 and max ( zc ) >= 3 else print ( <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> hw_set = set ( ) <NEWLINE> for bomb in hw : <NEWLINE> <INDENT> hw_set . add ( ( bomb [ 0 ] , bomb [ 1 ] ) ) <NEWLINE> <DEDENT> h_value = [ 0 ] * ( H + 1 ) <NEWLINE> w_value = [ 0 ] * ( W + 1 ) <NEWLINE> <COMMENT> <NL> <NL> for coordinate in hw : <NEWLINE> <INDENT> h_value [ coordinate [ 0 ] ] += 1 <NEWLINE> w_value [ coordinate [ 1 ] ] += 1 <NEWLINE> <NL> <NL> <DEDENT> h_max = max ( h_value ) <NEWLINE> w_max = max ( w_value ) <NEWLINE> <NL> h_max_ind = list ( ) <NEWLINE> w_max_ind = list ( ) <NEWLINE> h_max_ind_num = 0 <NEWLINE> w_max_ind_num = 0 <NEWLINE> <NL> for i in range ( H + 1 ) : <NEWLINE> <INDENT> if h_value [ i ] == h_max : <NEWLINE> <INDENT> h_max_ind . append ( i ) <NEWLINE> h_max_ind_num += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( W + 1 ) : <NEWLINE> <INDENT> if w_value [ i ] == w_max : <NEWLINE> <INDENT> w_max_ind . append ( i ) <NEWLINE> w_max_ind_num += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> if ( h_max_ind_num * w_max_ind_num ) > M : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for h in h_max_ind : <NEWLINE> <INDENT> for w in w_max_ind : <NEWLINE> <INDENT> if not ( h , w ) in hw_set : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( h_max + w_max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h_max + w_max - 1 ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> pl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lst = [ i for i in range ( - 101 , 200 ) ] <NEWLINE> <NL> anslst = [ ] <NEWLINE> for n in lst : <NEWLINE> <INDENT> if not n in pl : <NEWLINE> <INDENT> anslst . append ( n ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> an = 1000 <NEWLINE> idx = 0 <NEWLINE> for i in range ( len ( anslst ) ) : <NEWLINE> <INDENT> tmp = abs ( X - anslst [ i ] ) <NEWLINE> if tmp < an : <NEWLINE> <INDENT> an = tmp <NEWLINE> idx = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = anslst [ idx ] <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def popcount ( m ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> while m : <NEWLINE> <INDENT> if m & 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> m //= 2 <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def f ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while m : <NEWLINE> <COMMENT> <NL> <INDENT> m = m % popcount ( m ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> x = ns ( ) <NEWLINE> pop0 = x . count ( <STRING> ) + 1 <NEWLINE> pop1 = x . count ( <STRING> ) - 1 <NEWLINE> y0 = 0 ; y1 = 0 <NEWLINE> for i , xi in enumerate ( x ) : <NEWLINE> <INDENT> r = n - i - 1 <NEWLINE> if xi == <STRING> : <NEWLINE> <INDENT> y0 += pow ( 2 , r , pop0 ) <NEWLINE> y0 %= pop0 <NEWLINE> if pop1 != 0 : <NEWLINE> <INDENT> y1 += pow ( 2 , r , pop1 ) <NEWLINE> y1 %= pop1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i , xi in enumerate ( x ) : <NEWLINE> <INDENT> r = n - i - 1 <NEWLINE> if xi == <STRING> : <NEWLINE> <INDENT> m = ( y0 + pow ( 2 , r , pop0 ) ) % pop0 <NEWLINE> print ( f ( m ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if pop1 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> m = ( y1 - pow ( 2 , r , pop1 ) ) % pop1 <NEWLINE> print ( f ( m ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 0 <NEWLINE> step = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if max > i : <NEWLINE> <INDENT> step += max - i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( step ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = len ( str ( N ) ) <NEWLINE> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = min ( ans , max ( len ( str ( i ) ) , len ( str ( N // i ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from collections import Counter <NEWLINE> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> amari = [ 0 ] * n <NEWLINE> ketaamari = 1 <NEWLINE> t = 0 <NEWLINE> for i1 in range ( n ) : <NEWLINE> <INDENT> t = ( t + ketaamari * int ( s [ - i1 - 1 ] ) ) % 2019 <NEWLINE> amari [ - i1 - 1 ] = t <NEWLINE> ketaamari = ( ketaamari * 10 ) % 2019 <NEWLINE> <DEDENT> amari . append ( 0 ) <NEWLINE> ac = Counter ( amari ) <NEWLINE> r = 0 <NEWLINE> for v in ac . values ( ) : <NEWLINE> <INDENT> r += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <NL> <INDENT> __top = 0 <NEWLINE> __front = 1 <NEWLINE> __right = 2 <NEWLINE> __left = 3 <NEWLINE> __back = 4 <NEWLINE> __bottom = 5 <NEWLINE> <NL> def __init__ ( self , a , b , c , d , e , f ) : <NEWLINE> <INDENT> self . __dice = [ a , b , c , d , e , f ] <NEWLINE> <NL> <DEDENT> def S ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __back ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __right ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __left ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __bottom ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __front ] <NEWLINE> <NL> <DEDENT> def E ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __left ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __front ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __bottom ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __back ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __right ] <NEWLINE> <NL> <DEDENT> def W ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __right ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __front ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __bottom ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __back ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __left ] <NEWLINE> <NL> <DEDENT> def N ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __front ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __bottom ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __right ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __left ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __back ] <NEWLINE> <NL> <DEDENT> def turn ( self ) : <NEWLINE> <INDENT> dice_before = self . __dice [ : ] <NEWLINE> self . __dice [ Dice . __top ] = dice_before [ Dice . __top ] <NEWLINE> self . __dice [ Dice . __front ] = dice_before [ Dice . __right ] <NEWLINE> self . __dice [ Dice . __right ] = dice_before [ Dice . __back ] <NEWLINE> self . __dice [ Dice . __left ] = dice_before [ Dice . __front ] <NEWLINE> self . __dice [ Dice . __back ] = dice_before [ Dice . __left ] <NEWLINE> self . __dice [ Dice . __bottom ] = dice_before [ Dice . __bottom ] <NEWLINE> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return ( self . __dice [ Dice . __top ] ) <NEWLINE> <NL> <DEDENT> def front ( self ) : <NEWLINE> <INDENT> return ( self . __dice [ Dice . __front ] ) <NEWLINE> <NL> <DEDENT> def right ( self ) : <NEWLINE> <INDENT> return ( self . __dice [ Dice . __right ] ) <NEWLINE> <NL> <DEDENT> def left ( self ) : <NEWLINE> <INDENT> return ( self . __dice [ Dice . __left ] ) <NEWLINE> <NL> <DEDENT> def back ( self ) : <NEWLINE> <INDENT> return ( self . __dice [ Dice . __back ] ) <NEWLINE> <NL> <DEDENT> def bottom ( self ) : <NEWLINE> <INDENT> return ( self . __dice [ Dice . __bottom ] ) <NEWLINE> <NL> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( <STRING> , self . __dice [ Dice . __top ] ) <NEWLINE> print ( <STRING> , self . __dice [ Dice . __front ] ) <NEWLINE> print ( <STRING> , self . __dice [ Dice . __right ] ) <NEWLINE> print ( <STRING> , self . __dice [ Dice . __left ] ) <NEWLINE> print ( <STRING> , self . __dice [ Dice . __back ] ) <NEWLINE> print ( <STRING> , self . __dice [ Dice . __bottom ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def S ( dice , top ) : <NEWLINE> <INDENT> for t in range ( 4 ) : <NEWLINE> <INDENT> if dice . top ( ) == top : <NEWLINE> <INDENT> return dice <NEWLINE> <DEDENT> dice . S ( ) <NEWLINE> <DEDENT> return dice <NEWLINE> <NL> <DEDENT> def turn ( dice , front ) : <NEWLINE> <INDENT> for t in range ( 4 ) : <NEWLINE> <INDENT> if dice . front ( ) == front : <NEWLINE> <INDENT> return dice <NEWLINE> <DEDENT> dice . turn ( ) <NEWLINE> <DEDENT> return dice <NEWLINE> <NL> <DEDENT> a , b , c , d , e , f = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> dice = Dice ( a , b , c , d , e , f ) <NEWLINE> top , front = input ( ) . split ( ) <NEWLINE> <NL> for to in range ( 2 ) : <NEWLINE> <INDENT> dice = S ( dice , top ) <NEWLINE> <COMMENT> <NL> if dice . top ( ) == top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice . turn ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for fr in range ( 4 ) : <NEWLINE> <INDENT> dice = turn ( dice , front ) <NEWLINE> if dice . front ( ) == front : <NEWLINE> <INDENT> print ( dice . right ( ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> xys = set ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> <NL> z = [ ] <NEWLINE> w = [ ] <NEWLINE> <NL> for xy in xys : <NEWLINE> <INDENT> z . append ( xy [ 0 ] + xy [ 1 ] ) <NEWLINE> w . append ( xy [ 0 ] - xy [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( max ( abs ( max ( z ) - min ( z ) ) , abs ( max ( w ) - min ( w ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> li [ a [ i ] - 1 ] = li [ a [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( li [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = [ 0 ] * n <NEWLINE> for x in a : <NEWLINE> <INDENT> result [ x - 1 ] += 1 <NEWLINE> <DEDENT> for v in result : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
<NL> import math <NEWLINE> <NL> a , b , c , d = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> e = 6 * d <NEWLINE> f = 30 * c + 0.5 * d <NEWLINE> <NL> if e < f : <NEWLINE> <INDENT> kakudo = f - e <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kakudo = e - f <NEWLINE> <NL> <DEDENT> if kakudo > 180 : <NEWLINE> <INDENT> kakudo = 360 - kakudo <NEWLINE> <NL> <DEDENT> a2 = a * a <NEWLINE> b2 = b * b <NEWLINE> i = math . cos ( math . radians ( kakudo ) ) <NEWLINE> j = 2 * a * b * i <NEWLINE> print ( math . sqrt ( a2 + b2 - j ) ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <NL> class RSQ : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . sz = 1 <NEWLINE> self . inf = ( 1 << 31 ) - 1 <NEWLINE> while self . sz <= n : self . sz = self . sz << 1 <NEWLINE> self . dat = [ 0 ] * ( 2 * self . sz - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , idx , x ) : <NEWLINE> <INDENT> idx += self . sz - 1 <NEWLINE> self . dat [ idx ] += x <NEWLINE> while idx > 0 : <NEWLINE> <INDENT> idx = ( idx - 1 ) >> 1 <NEWLINE> self . dat [ idx ] += x <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , a , b ) : <NEWLINE> <INDENT> return self . query_help ( a , b , 0 , 0 , self . sz ) <NEWLINE> <NL> <DEDENT> def query_help ( self , a , b , k , l , r ) : <NEWLINE> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif a <= l and r <= b : <NEWLINE> <INDENT> return self . dat [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . query_help ( a , b , 2 * k + 1 , l , ( l + r ) >> 1 ) + self . query_help ( a , b , 2 * k + 2 , ( l + r ) >> 1 , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> n , q = line . split ( ) <NEWLINE> n , q = int ( n ) , int ( q ) <NEWLINE> rmq = RSQ ( n ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> op , a , b = line . split ( ) <NEWLINE> op , a , b = int ( op ) , int ( a ) , int ( b ) <NEWLINE> if op == 0 : <NEWLINE> <INDENT> rmq . update ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( str ( rmq . query ( a , b + 1 ) ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> total = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total [ i + 1 ] = total [ i ] + A [ i ] <NEWLINE> <NL> <DEDENT> total_rev = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total_rev [ i ] = total [ N ] - total [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] * total_rev [ i + 1 ] ) % m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) % 9 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( len ( set ( S ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> n = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 1 <NEWLINE> n . sort ( ) <NEWLINE> for i in n : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> d = [ s [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> d . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( s [ i ] ) <NEWLINE> <DEDENT> <DEDENT> q = <STRING> . join ( d ) <NEWLINE> cou = 0 <NEWLINE> cou_a = 0 <NEWLINE> l = len ( q ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if q [ i ] == <STRING> : <NEWLINE> <INDENT> cou_a += 1 <NEWLINE> <DEDENT> elif q [ i ] == <STRING> : <NEWLINE> <INDENT> cou += cou_a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cou_a = 0 <NEWLINE> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> L = <STRING> . join ( [ str ( i ) for i in X ] ) <NEWLINE> print ( L ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return len ( lower_divisors + upper_divisors [ : : - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> if make_divisors ( i ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mod_value = [ - 1 for i in range ( 2 * m ) ] <COMMENT> <NEWLINE> mod_check = [ False for i in range ( m ) ] <COMMENT> <NEWLINE> value = x <NEWLINE> i = 0 <NEWLINE> head = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> if not mod_check [ value ] : <NEWLINE> <INDENT> mod_value [ i ] = value <NEWLINE> mod_check [ value ] = True <NEWLINE> i += 1 <NEWLINE> value = ( value ** 2 ) % m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> head = mod_value . index ( value ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i == n : <NEWLINE> <INDENT> print ( sum ( mod_value [ : n ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> block_size = i - head <NEWLINE> block_num = ( n - head ) // block_size <NEWLINE> print ( sum ( mod_value [ : head ] ) + sum ( mod_value [ head : i ] ) * block_num + sum ( mod_value [ head : head + ( n - head ) % block_size ] ) ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> while i != 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( x ) + <STRING> + str ( i ) ) <NEWLINE> x += 1 <NEWLINE> i = int ( input ( ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * 10010 <NEWLINE> <NL> <COMMENT> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> if x * x + y * y + z * z + x * y + y * z + z * x > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a [ x * x + y * y + z * z + x * y + y * z + z * x ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> R = [ ] <NEWLINE> r = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> R . append ( r ) <NEWLINE> r = 0 <NEWLINE> <DEDENT> R . append ( r ) <NEWLINE> <NL> <DEDENT> print ( max ( R ) ) <NEWLINE>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 100 : <NEWLINE> <INDENT> N += 1 <NEWLINE> <NL> <DEDENT> print ( N * 100 ** D ) <NEWLINE>
class dice_2 : <NEWLINE> <INDENT> def __init__ ( self , label ) : <NEWLINE> <INDENT> self . spots = label <NEWLINE> <NL> <DEDENT> def result ( self , top , front ) : <NEWLINE> <INDENT> if self . spots . index ( top ) + 1 == 1 : <NEWLINE> <INDENT> self . order = [ 2 , 3 , 5 , 4 , 2 ] <NEWLINE> <DEDENT> elif self . spots . index ( top ) + 1 == 2 : <NEWLINE> <INDENT> self . order = [ 6 , 3 , 1 , 4 , 6 ] <NEWLINE> <DEDENT> elif self . spots . index ( top ) + 1 == 3 : <NEWLINE> <INDENT> self . order = [ 2 , 6 , 5 , 1 , 2 ] <NEWLINE> <DEDENT> elif self . spots . index ( top ) + 1 == 4 : <NEWLINE> <INDENT> self . order = [ 2 , 1 , 5 , 6 , 2 ] <NEWLINE> <DEDENT> elif self . spots . index ( top ) + 1 == 5 : <NEWLINE> <INDENT> self . order = [ 1 , 3 , 6 , 4 , 1 ] <NEWLINE> <DEDENT> elif self . spots . index ( top ) + 1 == 6 : <NEWLINE> <INDENT> self . order = [ 2 , 4 , 5 , 3 , 2 ] <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if self . order [ i ] == self . spots . index ( front ) + 1 : <NEWLINE> <INDENT> self . right = self . order [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def output ( self ) : <NEWLINE> <INDENT> print ( self . spots [ self . right - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> label = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice = dice_2 ( label ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> top , front = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> dice . result ( top , front ) <NEWLINE> dice . output ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> MAX = 998244353 <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> cmb = 1 <NEWLINE> for ik in range ( k + 1 ) : <NEWLINE> <INDENT> ncp = m * pow ( m - 1 , n - ik - 1 , MAX ) <NEWLINE> ncp %= MAX <NEWLINE> <NL> if ik == 0 : <NEWLINE> <INDENT> cmb = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cmb *= ( ( n - ik ) * pow ( ik , MAX - 2 , MAX ) ) <NEWLINE> <DEDENT> cmb %= MAX <NEWLINE> <NL> cnt += ncp * cmb <NEWLINE> cnt %= MAX <NEWLINE> <NL> <DEDENT> print ( cnt % MAX ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
MOD = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> acc = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> <NL> dp [ 1 ] = 1 <NEWLINE> acc [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for lr in LR : <NEWLINE> <INDENT> l = lr [ 0 ] <NEWLINE> r = lr [ 1 ] <NEWLINE> <NL> dp [ i ] += ( acc [ max ( 0 , i - l ) ] - acc [ max ( 0 , i - r - 1 ) ] + MOD ) <NEWLINE> dp [ i ] %= MOD <NEWLINE> <DEDENT> acc [ i ] = ( acc [ i - 1 ] + dp [ i ] ) % MOD <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif x + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rate = [ 0 ] * 8 <NEWLINE> cnt = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> r = x // 400 <NEWLINE> if r > 7 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif not rate [ r ] : <NEWLINE> <INDENT> rate [ r ] = 1 <NEWLINE> <DEDENT> <DEDENT> s = sum ( rate ) <NEWLINE> mins = s <NEWLINE> if cnt > 0 : <NEWLINE> <INDENT> mins += 1 <NEWLINE> if s > 0 : <NEWLINE> <INDENT> mins -= 1 <NEWLINE> <DEDENT> <DEDENT> maxs = s + cnt <NEWLINE> print ( mins , maxs ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> ab = [ 0 for _ in range ( 2001 ) ] <NEWLINE> for a in range ( 1001 ) : <NEWLINE> <INDENT> for b in range ( 1001 ) : <NEWLINE> <INDENT> ab [ a + b ] += 1 <NEWLINE> <DEDENT> <DEDENT> for l in sys . stdin : <NEWLINE> <INDENT> n = int ( l [ : - 1 ] ) <NEWLINE> ans = sum ( ab [ i ] * ab [ n - i ] for i in range ( 2001 ) if 0 <= n - i <= 2000 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> As = [ A - 1 for A in As ] <NEWLINE> Vs = [ False ] * N <NEWLINE> p = 0 <NEWLINE> Rs = [ p ] <NEWLINE> Vs [ p ] = True <NEWLINE> for i in range ( N + 3 ) : <NEWLINE> <INDENT> n = As [ p ] <NEWLINE> Rs . append ( n ) <NEWLINE> if Vs [ n ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = n <NEWLINE> Vs [ p ] = True <NEWLINE> <DEDENT> p0 = Rs . index ( Rs [ - 1 ] ) <NEWLINE> <COMMENT> <NL> if K <= p0 : <NEWLINE> <INDENT> r = Rs [ K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = Rs [ p0 + ( K - p0 ) % ( len ( Rs ) - p0 - 1 ) ] <NEWLINE> <DEDENT> print ( r + 1 ) <NEWLINE>
times = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 0 <NEWLINE> sum_numbers = sum ( numbers ) <NEWLINE> calc = [ ] <NEWLINE> <NL> for i in range ( times - 1 ) : <NEWLINE> <INDENT> sum_numbers -= numbers [ i ] <NEWLINE> calc . append ( sum_numbers ) <NEWLINE> <NL> <DEDENT> for i in range ( times - 1 ) : <NEWLINE> <INDENT> calc [ i ] *= numbers [ i ] <NEWLINE> <NL> <DEDENT> print ( sum ( calc ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b == 1 : print ( 0 ) <NEWLINE> elif a == b : print ( 1 ) <NEWLINE> else : <NEWLINE> <INDENT> if ( b - 1 ) % ( a - 1 ) > 0 : print ( ( b - 1 ) // ( a - 1 ) + 1 ) <NEWLINE> else : print ( ( b - 1 ) // ( a - 1 ) ) <NEWLINE> <DEDENT>
n = 999999 <NEWLINE> c = [ 1 for i in range ( n ) ] <NEWLINE> c [ 0 ] = 0 <NEWLINE> i = 2 <NEWLINE> while i ** 2 <= n : <NEWLINE> <INDENT> j = i * 2 <NEWLINE> while j <= n : <NEWLINE> <INDENT> c [ j - 1 ] = 0 <NEWLINE> j += i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( sum ( c [ : n ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> <NL> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in aaa : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * aaa [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cA = collections . Counter ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> if len ( cA ) > K : <NEWLINE> <INDENT> _ , counts = zip ( * cA . most_common ( ) [ : : - 1 ] ) <NEWLINE> ans = sum ( counts [ : len ( cA ) - K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> MOD = 998244353 <NEWLINE> N , S = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> U = 3010 <NEWLINE> f = np . zeros ( U , np . int64 ) <NEWLINE> f [ 0 ] = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ff = 2 * f <NEWLINE> ff [ a : ] += f [ : - a ] <NEWLINE> ff %= MOD <NEWLINE> f = ff <NEWLINE> <DEDENT> ans = f [ S ] <NEWLINE> print ( ans % MOD ) <NEWLINE>
ans = 0 <NEWLINE> K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - x - y and S - x - y <= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> c = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> L = [ ] <NEWLINE> s = 0 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> if ans [ t ] == 1 : <NEWLINE> <INDENT> n = len ( L ) - L . index ( t ) <NEWLINE> temp = ( k - c ) % n <NEWLINE> t = L [ L . index ( t ) : ] [ temp ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ t ] = 1 <NEWLINE> L . append ( t ) <NEWLINE> t = A [ t ] - 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t + 1 ) <NEWLINE>
N = 10 ** 5 <NEWLINE> prt = [ 0 ] * ( N + 1 ) <NEWLINE> left = [ - 1 ] + [ 0 ] * N <NEWLINE> right = [ - 1 ] + [ 0 ] * N <NEWLINE> sz = [ 0 ] + [ 1 ] * N <NEWLINE> key = [ 0 ] * ( N + 1 ) <NEWLINE> val = [ 0 ] * ( N + 1 ) <NEWLINE> rev = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> def update ( i , l , r ) : <NEWLINE> <COMMENT> <NL> <INDENT> sz [ i ] = 1 + sz [ l ] + sz [ r ] <NEWLINE> val [ i ] = key [ i ] + val [ l ] + val [ r ] <NEWLINE> <NL> <DEDENT> def swap ( i ) : <NEWLINE> <INDENT> if i : <NEWLINE> <INDENT> left [ i ] , right [ i ] = right [ i ] , left [ i ] <NEWLINE> rev [ i ] ^= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def prop ( i ) : <NEWLINE> <INDENT> swap ( left [ i ] ) <NEWLINE> swap ( right [ i ] ) <NEWLINE> rev [ i ] = 0 <NEWLINE> return 1 <NEWLINE> <NL> <DEDENT> def splay ( i ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = prt [ i ] <NEWLINE> rev [ i ] and prop ( i ) <NEWLINE> <NL> li = left [ i ] ; ri = right [ i ] <NEWLINE> while x and not left [ x ] != i != right [ x ] : <NEWLINE> <INDENT> y = prt [ x ] <NEWLINE> if not y or left [ y ] != x != right [ y ] : <NEWLINE> <INDENT> if rev [ x ] and prop ( x ) : <NEWLINE> <INDENT> li , ri = ri , li <NEWLINE> swap ( li ) ; swap ( ri ) <NEWLINE> <NL> <DEDENT> if left [ x ] == i : <NEWLINE> <INDENT> left [ x ] = ri <NEWLINE> prt [ ri ] = x <NEWLINE> update ( x , ri , right [ x ] ) <NEWLINE> ri = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right [ x ] = li <NEWLINE> prt [ li ] = x <NEWLINE> update ( x , left [ x ] , li ) <NEWLINE> li = x <NEWLINE> <DEDENT> x = y <NEWLINE> break <NEWLINE> <NL> <DEDENT> rev [ y ] and prop ( y ) <NEWLINE> if rev [ x ] and prop ( x ) : <NEWLINE> <INDENT> li , ri = ri , li <NEWLINE> swap ( li ) ; swap ( ri ) <NEWLINE> <NL> <DEDENT> z = prt [ y ] <NEWLINE> if left [ y ] == x : <NEWLINE> <INDENT> if left [ x ] == i : <NEWLINE> <INDENT> v = left [ y ] = right [ x ] <NEWLINE> prt [ v ] = y <NEWLINE> update ( y , v , right [ y ] ) <NEWLINE> <NL> left [ x ] = ri ; right [ x ] = y <NEWLINE> prt [ ri ] = x <NEWLINE> update ( x , ri , y ) <NEWLINE> <NL> prt [ y ] = ri = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left [ y ] = ri <NEWLINE> prt [ ri ] = y <NEWLINE> update ( y , ri , right [ y ] ) <NEWLINE> <NL> right [ x ] = li <NEWLINE> prt [ li ] = x <NEWLINE> update ( x , left [ x ] , li ) <NEWLINE> <NL> li = x ; ri = y <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if right [ x ] == i : <NEWLINE> <INDENT> v = right [ y ] = left [ x ] <NEWLINE> prt [ v ] = y <NEWLINE> update ( y , left [ y ] , v ) <NEWLINE> <NL> left [ x ] = y ; right [ x ] = li <NEWLINE> prt [ li ] = x <NEWLINE> update ( x , y , li ) <NEWLINE> <NL> prt [ y ] = li = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right [ y ] = li <NEWLINE> prt [ li ] = y <NEWLINE> update ( y , left [ y ] , li ) <NEWLINE> <NL> left [ x ] = ri <NEWLINE> prt [ ri ] = x <NEWLINE> update ( x , ri , right [ x ] ) <NEWLINE> <NL> li = y ; ri = x <NEWLINE> <NL> <DEDENT> <DEDENT> x = z <NEWLINE> if left [ z ] == y : <NEWLINE> <INDENT> left [ z ] = i <NEWLINE> update ( z , i , right [ z ] ) <NEWLINE> <DEDENT> elif right [ z ] == y : <NEWLINE> <INDENT> right [ z ] = i <NEWLINE> update ( z , left [ z ] , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> update ( i , li , ri ) <NEWLINE> left [ i ] = li ; right [ i ] = ri <NEWLINE> prt [ li ] = prt [ ri ] = i <NEWLINE> prt [ i ] = x <NEWLINE> <NL> rev [ i ] = prt [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> def expose ( i ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> cur = i <NEWLINE> while cur : <NEWLINE> <INDENT> splay ( cur ) <NEWLINE> right [ cur ] = p <NEWLINE> update ( cur , left [ cur ] , p ) <NEWLINE> p = cur <NEWLINE> cur = prt [ cur ] <NEWLINE> <DEDENT> splay ( i ) <NEWLINE> return i <NEWLINE> <NL> <DEDENT> def cut ( i ) : <NEWLINE> <INDENT> expose ( i ) <NEWLINE> p = left [ i ] <NEWLINE> left [ i ] = prt [ p ] = 0 <NEWLINE> return p <NEWLINE> <NL> <DEDENT> def link ( i , p ) : <NEWLINE> <INDENT> expose ( i ) <NEWLINE> expose ( p ) <NEWLINE> prt [ i ] = p <NEWLINE> right [ p ] = i <NEWLINE> <NL> <DEDENT> def evert ( i ) : <NEWLINE> <INDENT> expose ( i ) <NEWLINE> swap ( i ) <NEWLINE> rev [ i ] and prop ( i ) <NEWLINE> <NL> <DEDENT> def query ( v ) : <NEWLINE> <INDENT> r = expose ( v + 1 ) <NEWLINE> return val [ r ] <NEWLINE> <NL> <DEDENT> def query_add ( v , w ) : <NEWLINE> <INDENT> key [ v + 1 ] += w <NEWLINE> expose ( v + 1 ) <NEWLINE> <NL> <NL> <DEDENT> readline = open ( 0 ) . readline <NEWLINE> writelines = open ( 1 , <STRING> ) . writelines <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k , * C = map ( int , readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if k : <NEWLINE> <INDENT> expose ( i + 1 ) <NEWLINE> for c in C : <NEWLINE> <INDENT> expose ( c + 1 ) <NEWLINE> prt [ c + 1 ] = i + 1 <NEWLINE> <DEDENT> right [ i + 1 ] = C [ 0 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( readline ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> t , * args = map ( int , readline ( ) . split ( ) ) <NEWLINE> if t : <NEWLINE> <INDENT> ans . append ( <STRING> % query ( args [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> query_add ( * args ) <NEWLINE> <DEDENT> <DEDENT> writelines ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> if n <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a = s [ i + 1 : ] . count ( <STRING> ) <NEWLINE> b = s [ i + 1 : ] . count ( <STRING> ) <NEWLINE> result += a * b <NEWLINE> for j in range ( 1 , ( n + 1 - i ) // 2 ) : <NEWLINE> <INDENT> if ( s [ i + j ] == <STRING> and s [ i + 2 * j ] == <STRING> ) or ( s [ i + j ] == <STRING> and s [ i + 2 * j ] == <STRING> ) : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> a = s [ i + 1 : ] . count ( <STRING> ) <NEWLINE> b = s [ i + 1 : ] . count ( <STRING> ) <NEWLINE> result += a * b <NEWLINE> for j in range ( 1 , ( n + 1 - i ) // 2 ) : <NEWLINE> <INDENT> if ( s [ i + j ] == <STRING> and s [ i + 2 * j ] == <STRING> ) or ( s [ i + j ] == <STRING> and s [ i + 2 * j ] == <STRING> ) : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> a = s [ i + 1 : ] . count ( <STRING> ) <NEWLINE> b = s [ i + 1 : ] . count ( <STRING> ) <NEWLINE> result += a * b <NEWLINE> for j in range ( 1 , ( n + 1 - i ) // 2 ) : <NEWLINE> <INDENT> if ( s [ i + j ] == <STRING> and s [ i + 2 * j ] == <STRING> ) or ( s [ i + j ] == <STRING> and s [ i + 2 * j ] == <STRING> ) : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( ( list ( map ( int , input ( ) . split ( ) ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> @ njit <NEWLINE> def imos ( A ) : <NEWLINE> <INDENT> B = np . zeros ( N , dtype = np . int64 ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> a = max ( 0 , i - x ) <NEWLINE> b = min ( i + x , N - 1 ) <NEWLINE> B [ a ] += 1 <NEWLINE> if b + 1 <= N - 1 : <NEWLINE> <INDENT> B [ b + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> if i >= 50 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = imos ( A ) <NEWLINE> <DEDENT> print ( * A ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> xy = [ list ( map ( Decimal , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> cnt = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> xi = xy [ i ] [ 0 ] <NEWLINE> yi = xy [ i ] [ 1 ] <NEWLINE> <NL> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> xj = xy [ j ] [ 0 ] <NEWLINE> yj = xy [ j ] [ 1 ] <NEWLINE> <NL> x_dif = xi - xj <NEWLINE> y_dif = yi - yj <NEWLINE> if x_dif < 0 : <NEWLINE> <INDENT> x_dif = - x_dif <NEWLINE> y_dif = - y_dif <NEWLINE> <DEDENT> elif x_dif == 0 : <NEWLINE> <INDENT> y_dif = abs ( y_dif ) <NEWLINE> <NL> <DEDENT> if ( x_dif , y_dif ) in cnt . keys ( ) : <NEWLINE> <INDENT> cnt [ x_dif , y_dif ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ x_dif , y_dif ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : print ( N - max ( cnt . values ( ) ) ) <NEWLINE>
X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ X + 1 ] <NEWLINE> <DEDENT> def f ( p ) : <NEWLINE> <INDENT> global X <NEWLINE> return p - X <NEWLINE> <NL> <DEDENT> p2 = list ( map ( f , p ) ) <NEWLINE> <NL> p3 = list ( map ( abs , p2 ) ) <NEWLINE> <NL> OK = 2 <NEWLINE> j = 0 <NEWLINE> <NL> <NL> if min ( p3 ) == 0 : <NEWLINE> <INDENT> while ( OK == 2 ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> OK = p3 . count ( min ( p3 ) + j ) <NEWLINE> <DEDENT> if OK == 1 : <NEWLINE> <INDENT> print ( X - p2 [ p3 . index ( min ( p3 ) + j ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X - j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> def init ( G , robots , fs , p ) : <NEWLINE> <INDENT> q = p <NEWLINE> while q < len ( robots ) and robots [ q ] [ 0 ] < robots [ p ] [ 0 ] + robots [ p ] [ 1 ] : <NEWLINE> <INDENT> if fs [ q ] : <NEWLINE> <INDENT> G [ p ] . append ( q ) <NEWLINE> fs [ q ] = False <NEWLINE> q = init ( G , robots , fs , q ) - 1 <NEWLINE> <DEDENT> q += 1 <NEWLINE> <DEDENT> return q <NEWLINE> <NL> <DEDENT> def calc ( G , p , fs ) : <NEWLINE> <INDENT> fs [ p ] = False <NEWLINE> if len ( G [ p ] ) == 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> tmp = 1 <NEWLINE> for v in G [ p ] : <NEWLINE> <INDENT> tmp *= calc ( G , v , fs ) <NEWLINE> tmp %= MOD <NEWLINE> <DEDENT> tmp += 1 <NEWLINE> return tmp <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> robots = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> robots . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> fs = [ True ] * n <NEWLINE> q = 0 <NEWLINE> while q < n : <NEWLINE> <INDENT> if fs [ q ] : <NEWLINE> <INDENT> fs [ q ] = False <NEWLINE> init ( G , robots , fs , q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q += 1 <NEWLINE> <DEDENT> <DEDENT> fs = [ True ] * n <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if fs [ i ] : <NEWLINE> <INDENT> ans *= calc ( G , i , fs ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> r , g , b = 0 , 0 , 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = set ( a ) <NEWLINE> a . sort ( ) <NEWLINE> if len ( a ) != len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> s = collections . Counter ( S ) <NEWLINE> s_key = s . keys ( ) <NEWLINE> print ( len ( s_key ) ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mn = min ( n , m ) <NEWLINE> P = [ ] <NEWLINE> sum_p = 0 <NEWLINE> X = [ - 1 ] * m <NEWLINE> for i in range ( mn ) : <NEWLINE> <INDENT> if X [ x ] > - 1 : <NEWLINE> <INDENT> cyc_len = len ( P ) - X [ x ] <NEWLINE> remain = P [ X [ x ] ] <NEWLINE> cyc = ( sum_p - remain ) * ( ( n - X [ x ] ) // cyc_len ) <NEWLINE> remain += P [ X [ x ] + ( n - X [ x ] ) % cyc_len ] - P [ X [ x ] ] <NEWLINE> print ( cyc + remain ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P . append ( sum_p ) <NEWLINE> sum_p += x <NEWLINE> X [ x ] = i <NEWLINE> x = x * x % m <NEWLINE> <DEDENT> print ( sum_p ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> f = a / b <NEWLINE> print ( int ( a / b ) , a % b , <STRING> . format ( a / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dict = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> str = input ( ) <NEWLINE> if str [ 0 ] == <STRING> : <NEWLINE> <INDENT> dict . update ( { str [ 7 : ] : 1 } ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if str [ 5 : ] in dict : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( ( b1 [ : , : ] , i8 , i8 , i8 , i8 ) , cache = True ) <NEWLINE> def main ( wall , Sx , Sy , Tx , Ty ) : <NEWLINE> <INDENT> INF = 1 << 30 <NEWLINE> H , W = wall . shape <NEWLINE> S = Sx * W + Sy <NEWLINE> T = Tx * W + Ty <NEWLINE> dist = np . full ( H * W , INF , np . int64 ) <NEWLINE> deq = np . empty ( 2 * H * W + 100 , np . int64 ) <NEWLINE> dist [ S ] = 0 <NEWLINE> deq [ H * W ] , l , r = S , H * W , H * W + 1 <NEWLINE> while l < r : <NEWLINE> <INDENT> v , l = deq [ l ] , l + 1 <NEWLINE> vx , vy = divmod ( v , W ) <NEWLINE> <COMMENT> <NL> for dx , dy in ( ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> wx , wy = vx + dx , vy + dy <NEWLINE> if not ( 0 <= wx < H ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not ( 0 <= wy < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if wall [ wx , wy ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = wx * W + wy <NEWLINE> if dist [ w ] <= dist [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w ] = dist [ v ] <NEWLINE> deq [ l - 1 ] , l = w , l - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for dx in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for dy in range ( - 2 , 3 ) : <NEWLINE> <INDENT> wx , wy = vx + dx , vy + dy <NEWLINE> if not ( 0 <= wx < H ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not ( 0 <= wy < W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if wall [ wx , wy ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = wx * W + wy <NEWLINE> if dist [ w ] <= dist [ v ] + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w ] = dist [ v ] + 1 <NEWLINE> deq [ r ] , r = w , r + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = dist [ T ] <NEWLINE> if ans == INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> H , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> Sx , Sy = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> Tx , Ty = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> wall = np . frombuffer ( read ( ) , <STRING> ) . reshape ( H , - 1 ) [ : , : W ] == <STRING> <NEWLINE> <NL> print ( main ( wall , Sx , Sy , Tx , Ty ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> border = 10 ** 18 <NEWLINE> <NL> if 0 in A_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_list . sort ( reverse = True ) <NEWLINE> pro = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pro *= A_list [ i ] <NEWLINE> if pro > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( pro ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> x = abs ( A [ 0 ] - B [ 0 ] ) <NEWLINE> v = A [ 1 ] - B [ 1 ] <NEWLINE> <NL> if v * T >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans_lis = [ ] <NEWLINE> s_length = len ( s ) <NEWLINE> lis = [ [ ] for i in range ( 26 ) ] <NEWLINE> <NL> for i in range ( s_length ) : <NEWLINE> <INDENT> lis [ ord ( s [ i ] ) - ord ( <STRING> ) ] . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> while k <= K : <NEWLINE> <INDENT> for j in lis [ i ] : <NEWLINE> <INDENT> ans_lis . append ( s [ j : j + k ] ) <NEWLINE> <DEDENT> k += 1 <NEWLINE> ans_lis = sorted ( list ( set ( ans_lis ) ) ) <NEWLINE> <DEDENT> if len ( ans_lis ) >= K : <NEWLINE> <INDENT> print ( ans_lis [ K - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
I = input ( ) <NEWLINE> <NL> for i in range ( len ( I ) ) : <NEWLINE> <INDENT> if <STRING> <= I [ i ] <= <STRING> : <NEWLINE> <INDENT> print ( I [ i ] . upper ( ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> if <STRING> <= I [ i ] <= <STRING> : <NEWLINE> <INDENT> print ( I [ i ] . lower ( ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( I [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> miti = [ [ 0 ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> miti [ a ] . append ( h [ b ] ) <NEWLINE> miti [ b ] . append ( h [ a ] ) <NEWLINE> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > max ( miti [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . insert ( 0 , 0 ) <NEWLINE> A . append ( 0 ) <NEWLINE> _A = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> _A . append ( abs ( A [ i ] - A [ i - 1 ] ) ) <NEWLINE> <DEDENT> _A . append ( abs ( 0 - A [ N ] ) ) <NEWLINE> S = sum ( _A ) <NEWLINE> <NL> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> allS = S <NEWLINE> allS -= ( _A [ i ] + _A [ i + 1 ] - abs ( A [ i + 2 ] - A [ i ] ) ) <NEWLINE> print ( allS ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> List . sort ( ) <NEWLINE> K = List [ N - 1 ] + 1 <NEWLINE> Flag = [ 1 ] * K <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if Flag [ List [ i ] ] == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> for j in range ( List [ i ] , K , List [ i ] ) : <NEWLINE> <INDENT> Flag [ j ] = 0 <NEWLINE> <DEDENT> if i != N - 1 and List [ i ] == List [ i + 1 ] : <NEWLINE> <INDENT> res += - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> from collections import Counter <NEWLINE> a_count = Counter ( a ) <NEWLINE> sum = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in a_count : <NEWLINE> <INDENT> sum += ( c - b ) * a_count [ b ] <NEWLINE> a_count [ c ] += a_count [ b ] <NEWLINE> a_count . pop ( b ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT>
R = int ( input ( ) ) <NEWLINE> if R < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif R < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , val = None , prev = None , next = None ) : <NEWLINE> <INDENT> self . val = val <NEWLINE> self . prev = prev <NEWLINE> self . next = next <NEWLINE> <NL> <DEDENT> <DEDENT> class DoublyLinkedList ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . start = Node ( val = <STRING> , prev = None , next = None ) <NEWLINE> self . end = Node ( val = <STRING> , prev = self . start , next = None ) <NEWLINE> self . start . next = self . end <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> new_node = Node ( val = x , prev = self . end . prev , next = self . end ) <NEWLINE> self . end . prev . next = new_node <NEWLINE> self . end . prev = new_node <NEWLINE> <NL> <DEDENT> def dump ( self ) : <NEWLINE> <INDENT> node_list = [ ] <NEWLINE> crnode = self . start . next <NEWLINE> while crnode != self . end : <NEWLINE> <INDENT> node_list . append ( crnode . val ) <NEWLINE> crnode = crnode . next <NEWLINE> <DEDENT> print ( <STRING> . join ( list ( map ( str , node_list ) ) ) ) <NEWLINE> <NL> <DEDENT> def extend ( self , dll ) : <NEWLINE> <INDENT> self . end . prev . next = dll . start . next <NEWLINE> dll . start . next . prev = self . end . prev <NEWLINE> self . end = dll . end <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> splice = [ DoublyLinkedList ( ) for i in range ( n ) ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> op , * val = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if op == 0 : <NEWLINE> <INDENT> splice [ val [ 0 ] ] . insert ( val [ 1 ] ) <NEWLINE> <DEDENT> elif op == 1 : <NEWLINE> <INDENT> splice [ val [ 0 ] ] . dump ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> splice [ val [ 1 ] ] . extend ( splice [ val [ 0 ] ] ) <NEWLINE> splice [ val [ 0 ] ] = DoublyLinkedList ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> sum_n = [ 0 ] * n <NEWLINE> sum_n [ 0 ] = l [ 0 ] <NEWLINE> sumall = sum ( l ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sum_n [ i ] = sum_n [ i - 1 ] + l [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += ( ( l [ i ] * ( sumall - sum_n [ i ] ) ) % 1000000007 ) <NEWLINE> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> <NL> x = 7 % k <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> x = ( 10 * x + 7 ) % k <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> ret = 1 <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> ret *= ai <NEWLINE> if ret > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
S = input ( ) <NEWLINE> i_list = list ( S ) <NEWLINE> i_list = [ int ( i ) for i in i_list ] <NEWLINE> <NL> if i_list [ 0 ] == i_list [ 1 ] or i_list [ 1 ] == i_list [ 2 ] or i_list [ 2 ] == i_list [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> def calc_sum ( c ) : <NEWLINE> <INDENT> sum_val = 0 <NEWLINE> for key , val in c . items ( ) : <NEWLINE> <INDENT> sum_val += key * val <NEWLINE> <DEDENT> return sum_val <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> actions = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> actions . append ( { <STRING> : B , <STRING> : C } ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( arr ) <NEWLINE> sum_val = calc_sum ( c ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B = actions [ i ] [ <STRING> ] <NEWLINE> C = actions [ i ] [ <STRING> ] <NEWLINE> if B in c : <NEWLINE> <INDENT> c [ C ] += c [ B ] <NEWLINE> sum_val += c [ B ] * C - c [ B ] * B <NEWLINE> c . pop ( B ) <NEWLINE> <NL> <DEDENT> print ( sum_val ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> def solve ( n , m , a , b ) : <NEWLINE> <INDENT> parents = list ( range ( n + 1 ) ) <NEWLINE> def root ( x ) : <NEWLINE> <INDENT> if parents [ x ] != x : <NEWLINE> <INDENT> parents [ x ] = root ( parents [ x ] ) <NEWLINE> <DEDENT> return parents [ x ] <NEWLINE> <DEDENT> for u , v in zip ( a , b ) : <NEWLINE> <INDENT> u = root ( u ) <NEWLINE> v = root ( v ) <NEWLINE> if u > v : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> if u != v : <NEWLINE> <INDENT> parents [ v ] = u <NEWLINE> <DEDENT> <DEDENT> return max ( Counter ( map ( root , parents ) ) . values ( ) ) <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m > 0 : <NEWLINE> <INDENT> a , b = zip ( * [ map ( int , input ( ) . split ( ) ) for i in range ( m ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = [ ] , [ ] <NEWLINE> <DEDENT> print ( solve ( n , m , a , b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> goukei = 0 <NEWLINE> <NL> sumA = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> sumA = sumA - a <NEWLINE> goukei = goukei + sumA * a <NEWLINE> <NL> <DEDENT> k = 10 ** 9 + 7 <NEWLINE> print ( goukei % k ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = max ( L ) <NEWLINE> b = a <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b >= abs ( L [ i ] - a / 2 ) and L [ i ] != a : <NEWLINE> <INDENT> b = abs ( L [ i ] - a / 2 ) <NEWLINE> c = L [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( a , c ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> def f ( d , now , L ) : <NEWLINE> <INDENT> L . append ( now ) <NEWLINE> <NL> if d == 10 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for j in range ( - 1 , 2 ) : <NEWLINE> <INDENT> v = now % 10 + j <NEWLINE> if 0 <= v <= 9 : <NEWLINE> <INDENT> f ( d + 1 , now * 10 + v , L ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for l in range ( 1 , 10 ) : <NEWLINE> <INDENT> f ( 1 , l , L ) <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> print ( L [ k - 1 ] ) <NEWLINE> <NL>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> class Tree : <NEWLINE> <INDENT> def __init__ ( self , ID , l = None , r = None , p = - 1 ) : <NEWLINE> <INDENT> self . ID = ID <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> self . p = p <NEWLINE> <NL> <DEDENT> def makeTree ( self ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> T . append ( Tree ( i ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def preParse ( tree ) : <NEWLINE> <INDENT> if tree == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ID = tree . ID <NEWLINE> global preList <NEWLINE> preList . append ( ID ) <NEWLINE> preParse ( tree . l ) <NEWLINE> preParse ( tree . r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inParse ( tree ) : <NEWLINE> <INDENT> if tree == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ID = tree . ID <NEWLINE> global inList <NEWLINE> inParse ( tree . l ) <NEWLINE> inList . append ( ID ) <NEWLINE> inParse ( tree . r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def posParse ( tree ) : <NEWLINE> <INDENT> if tree == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ID = tree . ID <NEWLINE> global posList <NEWLINE> posParse ( tree . l ) <NEWLINE> posParse ( tree . r ) <NEWLINE> posList . append ( ID ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> trees = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> Tree . makeTree ( Tree ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ID , l , r = trees [ i ] <NEWLINE> tree = T [ ID ] <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> T [ l ] . p = tree <NEWLINE> tree . l = T [ l ] <NEWLINE> <DEDENT> if r != - 1 : <NEWLINE> <INDENT> T [ r ] . p = tree <NEWLINE> tree . r = T [ r ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if T [ i ] . p == - 1 : <NEWLINE> <INDENT> parent = T [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> preList = [ ] <NEWLINE> inList = [ ] <NEWLINE> posList = [ ] <NEWLINE> preParse ( parent ) <NEWLINE> inParse ( parent ) <NEWLINE> posParse ( parent ) <NEWLINE> <NL> def convert ( List , order ) : <NEWLINE> <INDENT> a = <STRING> + <STRING> . join ( [ str ( num ) for num in List ] ) <NEWLINE> print ( <STRING> . format ( order ) ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT> convert ( preList , <STRING> ) <NEWLINE> convert ( inList , <STRING> ) <NEWLINE> convert ( posList , <STRING> ) <NEWLINE> <NL>
N , M , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> mod = 998244353 <NEWLINE> ans = 0 <NEWLINE> fac = [ 0 ] * ( N + 1 ) <NEWLINE> inv = [ 0 ] * ( N + 1 ) <NEWLINE> finv = [ 0 ] * ( N + 1 ) <NEWLINE> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <DEDENT> def COM ( n , k ) : <NEWLINE> <INDENT> return fac [ n ] * ( finv [ k ] * finv [ n - k ] % mod ) % mod <NEWLINE> <DEDENT> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans += M * pow ( M - 1 , N - 1 - i , mod ) * COM ( N - 1 , i ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> dp = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> dp [ i - 1 ] = - 1 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> if dp [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif dp [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if dp [ 1 ] >= 0 and dp [ 0 ] >= 0 : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 2 <NEWLINE> <DEDENT> elif dp [ 1 ] == - 1 and dp [ 0 ] >= 0 : <NEWLINE> <INDENT> dp [ 0 ] = 1 <NEWLINE> <DEDENT> elif dp [ 1 ] >= 0 and dp [ 0 ] == - 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for j in range ( 2 , n ) : <NEWLINE> <INDENT> if dp [ j ] >= 0 : <NEWLINE> <INDENT> if dp [ j - 1 ] >= 0 and dp [ j - 2 ] >= 0 : <NEWLINE> <INDENT> dp [ j ] = dp [ j - 1 ] + dp [ j - 2 ] <NEWLINE> <DEDENT> elif dp [ j - 1 ] == - 1 and dp [ j - 2 ] >= 0 : <NEWLINE> <INDENT> dp [ j ] = dp [ j - 2 ] <NEWLINE> <DEDENT> elif dp [ j - 1 ] >= 0 and dp [ j - 2 ] == - 1 : <NEWLINE> <INDENT> dp [ j ] = dp [ j - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> trans = { } <NEWLINE> for x in range ( 1 , 27 ) : <NEWLINE> <INDENT> trans [ x ] = chr ( x + 96 ) <NEWLINE> <NL> <DEDENT> while n != 0 : <NEWLINE> <INDENT> if n % 26 == 0 : <NEWLINE> <INDENT> ans = <STRING> + ans <NEWLINE> n = n // 26 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = trans [ n % 26 ] + ans <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , ( n - i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + j * 2 ] and s [ i + j * 2 ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ 1 ] ] + [ [ x - 1 , x + 1 ] for x in range ( 1 , N - 1 ) ] + [ [ N - 2 ] ] <NEWLINE> G [ X - 1 ] . append ( Y - 1 ) <NEWLINE> G [ Y - 1 ] . append ( X - 1 ) <NEWLINE> <NL> dist = [ [ - 1 ] * N for _ in [ 0 ] * N ] <NEWLINE> for s in range ( N ) : <NEWLINE> <INDENT> q = deque ( [ s ] ) <NEWLINE> dist [ s ] [ s ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for nv in G [ v ] : <NEWLINE> <INDENT> if dist [ s ] [ nv ] == - 1 : <NEWLINE> <INDENT> dist [ s ] [ nv ] = dist [ s ] [ v ] + 1 <NEWLINE> q . append ( nv ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> res [ dist [ i ] [ j ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for d in range ( 1 , N ) : <NEWLINE> <INDENT> print ( res [ d ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d . sort ( ) <NEWLINE> print ( d [ int ( N / 2 ) ] - d [ int ( N / 2 ) - 1 ] ) <NEWLINE>
ans = 0 <NEWLINE> answer = [ ] <NEWLINE> S = input ( ) <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer . append ( ans ) <NEWLINE> ans = 0 <NEWLINE> <DEDENT> <DEDENT> answer . append ( ans ) <NEWLINE> print ( max ( answer ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> overflow = False <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> while i < len ( A ) and res <= 10 ** 18 : <NEWLINE> <INDENT> res *= A [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> is_divisible = np . zeros ( 10 ** 6 + 1 , dtype = np . int64 ) <NEWLINE> <NL> <NL> def update ( num ) : <NEWLINE> <INDENT> nums = np . arange ( num , 10 ** 6 + 1 , num ) <NEWLINE> is_divisible [ nums ] = True <NEWLINE> <NL> <DEDENT> counter = Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> for a , count in counter . items ( ) : <NEWLINE> <INDENT> if count == 1 and not is_divisible [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> update ( a ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if ( X > K * D ) : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> elif ( X >= D ) : <NEWLINE> <INDENT> m = X % D <NEWLINE> q = X // D <NEWLINE> K = K - q <NEWLINE> if ( K == 0 ) : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> elif ( K % 2 == 1 ) : <NEWLINE> <INDENT> print ( abs ( m - D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( K % 2 == 1 ) : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> d = j - i <NEWLINE> k = j + d <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if { S [ i ] , S [ j ] , S [ k ] } == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( 10 ** 5 + 10 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> chk = [ - 1 ] * n <NEWLINE> <NL> def dfs ( s , cnt ) : <NEWLINE> <INDENT> for u in g [ s ] : <NEWLINE> <INDENT> if chk [ u ] > - 1 : continue ; <NEWLINE> chk [ u ] = cnt <NEWLINE> dfs ( u , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if chk [ i ] == - 1 : <NEWLINE> <INDENT> chk [ i ] = cnt <NEWLINE> dfs ( i , cnt ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( chk ) ) <NEWLINE>
def factorial_mod ( n , mod ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ret *= i <NEWLINE> ret %= mod <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> def comb_mod ( n , r , mod ) : <NEWLINE> <INDENT> if r > n or r < 0 : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fact_n = factorial_mod ( n , mod ) <NEWLINE> fact_r = factorial_mod ( r , mod ) <NEWLINE> fact_nr = factorial_mod ( n - r , mod ) <NEWLINE> ret = fact_n * pow ( fact_r , mod - 2 , mod ) * pow ( fact_nr , mod - 2 , mod ) % mod <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> print ( comb_mod ( n - k + 1 , i , m ) * comb_mod ( k - 1 , i - 1 , m ) % m ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> <NL> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n // i == n % i : <NEWLINE> <INDENT> s . add ( i ) <NEWLINE> <DEDENT> x = ( n - i ) // i <NEWLINE> if x and n // x == n % x : <NEWLINE> <INDENT> s . add ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( list ( s ) ) ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> notices = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> notices . append ( tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> buildings = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> for b , f , r , v in notices : <NEWLINE> <INDENT> buildings [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> separator = <STRING> <NEWLINE> for index , building in enumerate ( buildings ) : <NEWLINE> <INDENT> for floor in building : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , floor ) ) ) <NEWLINE> <DEDENT> if index != len ( buildings ) - 1 : <NEWLINE> <INDENT> print ( separator ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> import fileinput <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> number = int ( input ( ) ) <NEWLINE> for line in fileinput . input ( ) : <NEWLINE> <INDENT> tokens = list ( map ( int , line . strip ( ) . split ( ) ) ) <NEWLINE> <NL> tokens . reverse ( ) <NEWLINE> <NL> for i in range ( number ) : <NEWLINE> <INDENT> if ( i == number - 1 ) : <NEWLINE> <INDENT> print ( <STRING> % ( tokens [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( tokens [ i ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S [ 0 ] != T [ 0 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> lcm = N * M // math . gcd ( N , M ) <NEWLINE> <COMMENT> <NL> tekito = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> tekito . append ( i * ( lcm // N ) + 1 ) <NEWLINE> <DEDENT> tekitu = [ ] <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> tekitu . append ( i * ( lcm // M ) + 1 ) <NEWLINE> <NL> <DEDENT> gattai = set ( tekito ) & set ( tekitu ) <NEWLINE> for k in gattai : <NEWLINE> <INDENT> i1 = ( k - 1 ) // ( lcm // N ) <NEWLINE> i2 = ( k - 1 ) // ( lcm // M ) <NEWLINE> if S [ i1 ] != T [ i2 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> if <STRING> in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= int ( a [ i ] ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE>
a , b = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> while a != 0 and b != 0 : <NEWLINE> <INDENT> cow = <STRING> <NEWLINE> for i in range ( 1 , b ) : <NEWLINE> <INDENT> cow += <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( cow ) ) <NEWLINE> for i in range ( 1 , a - 1 ) : <NEWLINE> <INDENT> row = <STRING> <NEWLINE> for j in range ( 1 , b - 1 ) : <NEWLINE> <INDENT> row += <STRING> <NEWLINE> <DEDENT> row += <STRING> <NEWLINE> print ( <STRING> . format ( row ) ) <NEWLINE> <DEDENT> cow = <STRING> <NEWLINE> for i in range ( 1 , b ) : <NEWLINE> <INDENT> cow += <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( cow ) ) <NEWLINE> print ( ) <NEWLINE> a , b = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> List_S = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( len ( set ( List_S ) ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> r [ i ] += r [ i - 1 ] + ( p [ i - 1 ] + 1 ) / 2 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for j in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , r [ j + k ] - r [ j ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if ( j - i ) + j < n : <NEWLINE> <INDENT> k = ( j - i ) + j <NEWLINE> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq , math <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , A ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> max_a = heapq . heappop ( a ) <NEWLINE> heapq . heappush ( a , math . ceil ( max_a / 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sss = 0 <NEWLINE> pss = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> pss += al [ i - 1 ] <NEWLINE> sss += al [ i ] * pss <NEWLINE> <DEDENT> print ( sss % 1000000007 ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( r ) ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> r_total = sum ( a [ i ] ) <NEWLINE> a [ i ] . append ( r_total ) <NEWLINE> <NL> <DEDENT> c_total = [ ] <NEWLINE> <NL> for j in range ( c + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( r ) : <NEWLINE> <INDENT> s += a [ k ] [ j ] <NEWLINE> <DEDENT> c_total . append ( s ) <NEWLINE> <NL> <DEDENT> a . append ( c_total ) <NEWLINE> <NL> for z in range ( r + 1 ) : <NEWLINE> <INDENT> for w in range ( c + 1 ) : <NEWLINE> <INDENT> print ( a [ z ] [ w ] , end = <STRING> ) <NEWLINE> if w != c : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> r = len ( s ) <NEWLINE> <NL> if r == 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> ans . add ( s [ i : i + j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( list ( ans ) ) [ k - 1 ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> L = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> com = input ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> C = com . split ( ) <NEWLINE> L . appendleft ( int ( C [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if com [ 6 ] == <STRING> : <NEWLINE> <INDENT> L . popleft ( ) <NEWLINE> <DEDENT> elif com [ 6 ] == <STRING> : <NEWLINE> <INDENT> L . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = com . split ( ) <NEWLINE> x = int ( C [ 1 ] ) <NEWLINE> try : <NEWLINE> <INDENT> L . remove ( x ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * L ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> F = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> move = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> seen = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def dfs ( sy , sx ) : <NEWLINE> <INDENT> seen [ sy ] [ sx ] = 1 <NEWLINE> b , w = 1 , 0 <NEWLINE> <NL> for dy , dx in move : <NEWLINE> <INDENT> ny = sy + dy <NEWLINE> nx = sx + dx <NEWLINE> if 0 <= ny < H and 0 <= nx < W and F [ ny ] [ nx ] != F [ sy ] [ sx ] and not seen [ ny ] [ nx ] : <NEWLINE> <INDENT> p = dfs ( ny , nx ) <NEWLINE> b += p [ 1 ] <COMMENT> <NEWLINE> w += p [ 0 ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return ( b , w ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if not seen [ i ] [ j ] : <NEWLINE> <INDENT> b , w = dfs ( i , j ) <NEWLINE> count += b * w <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> str_a = input ( ) . split ( ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( len ( str_a ) ) : <NEWLINE> <INDENT> a . append ( int ( str_a [ i ] ) ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> c += a [ - i ] <NEWLINE> total += c * a [ - ( i + 1 ) ] <NEWLINE> <NL> <DEDENT> print ( total % ( 1000000007 ) ) <NEWLINE>
<COMMENT> <NL> <NL> def string_two_numbers_spliter ( ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> return a , b <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b = string_two_numbers_spliter ( ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if ( s [ - 1 : ] == <STRING> ) : <NEWLINE> <INDENT> s1 = s + <STRING> <NEWLINE> print ( s1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 = s + <STRING> <NEWLINE> print ( s2 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> cons = 0 <NEWLINE> ans = [ 0 ] * ( len ( s ) ) <NEWLINE> left = 0 <NEWLINE> right = 0 <NEWLINE> check1 = True <NEWLINE> check2 = False <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if check1 == True and s [ i ] == <STRING> : <NEWLINE> <INDENT> cons = i <NEWLINE> check1 = False <NEWLINE> check2 = True <NEWLINE> <DEDENT> if check2 == True and ( s [ i ] == <STRING> or i == len ( s ) - 1 ) : <NEWLINE> <INDENT> right = i - 1 <NEWLINE> if i == len ( s ) - 1 : <NEWLINE> <INDENT> right += 1 <NEWLINE> <DEDENT> dum = s [ left : right + 1 ] <NEWLINE> dum_index = dum . index ( <STRING> ) <NEWLINE> dum_len = len ( dum ) <NEWLINE> div , mod = divmod ( dum_len , 2 ) <NEWLINE> if dum_index % 2 == 0 : <NEWLINE> <INDENT> ans [ cons ] = div + mod <NEWLINE> ans [ cons - 1 ] = div <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ cons ] = div <NEWLINE> ans [ cons - 1 ] = div + mod <NEWLINE> <NL> <DEDENT> check1 = True <NEWLINE> check2 = False <NEWLINE> left = right + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
midScore = [ 0 ] * 50 <NEWLINE> finScore = [ 0 ] * 50 <NEWLINE> reScore = [ 0 ] * 50 <NEWLINE> personNum = 0 <NEWLINE> while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> midScore [ personNum ] = m <NEWLINE> finScore [ personNum ] = f <NEWLINE> reScore [ personNum ] = r <NEWLINE> personNum += 1 <NEWLINE> if m is f is r is - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for person in range ( personNum ) : <NEWLINE> <INDENT> totalScore = midScore [ person ] + finScore [ person ] <NEWLINE> if midScore [ person ] is finScore [ person ] is reScore [ person ] is - 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif midScore [ person ] == - 1 or finScore [ person ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 80 <= totalScore : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= totalScore < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= totalScore < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= totalScore < 50 : <NEWLINE> <INDENT> if 50 <= reScore [ person ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif totalScore < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] ; b = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> a . append ( c ) <NEWLINE> b [ c - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> if k - ( q - i ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ i + a for i , a in enumerate ( s ) ] <NEWLINE> R = [ i - a for i , a in enumerate ( s ) ] <NEWLINE> t = collections . Counter ( L ) <NEWLINE> u = collections . Counter ( R ) <NEWLINE> ans = 0 <NEWLINE> for i in t . keys ( ) : <NEWLINE> <INDENT> ans += t [ i ] * u [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import connected_components <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data = [ 1 for i in range ( m ) ] <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> _a , _b = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( _a - 1 ) <NEWLINE> b . append ( _b - 1 ) <NEWLINE> <NL> <DEDENT> csr = csr_matrix ( ( data , ( a , b ) ) , ( n , n ) ) <NEWLINE> <NL> print ( connected_components ( csr , return_labels = False ) - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> m = max ( A ) <NEWLINE> C = [ 0 for a in range ( m + 1 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> s = 0 <NEWLINE> for a in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> s = max ( s , sum ( C [ a : : a ] ) ) <NEWLINE> <DEDENT> if s < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s < n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> h = int ( a ) <NEWLINE> w = int ( b ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = n // i <NEWLINE> ans += i * a * ( a + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> K = int ( input ( ) ) <NEWLINE> s3 = 0 <NEWLINE> s2 = 0 <NEWLINE> s1 = 0 <NEWLINE> s0 = 0 <NEWLINE> for a in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K ) : <NEWLINE> <INDENT> d = np . gcd ( a , b ) <NEWLINE> for c in range ( b + 1 , K + 1 ) : <NEWLINE> <INDENT> s0 += np . gcd ( c , d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for c in range ( a + 1 , K + 1 ) : <NEWLINE> <INDENT> s1 += np . gcd ( a , c ) <NEWLINE> <DEDENT> <DEDENT> for a in range ( 1 , K ) : <NEWLINE> <INDENT> for b in range ( a + 1 , K + 1 ) : <NEWLINE> <INDENT> s3 += np . gcd ( a , b ) <NEWLINE> <DEDENT> <DEDENT> for k in range ( K + 1 ) : <NEWLINE> <INDENT> s2 += k <NEWLINE> <DEDENT> print ( s0 * 6 + s1 * 3 + s3 * 3 + s2 ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> bs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sb = [ 0 ] * n <NEWLINE> for i in bs : <NEWLINE> <INDENT> sb [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in sb : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> total = sum ( A ) <NEWLINE> dict = { } <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] not in dict : <NEWLINE> <INDENT> dict [ A [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if BC [ i ] [ 0 ] not in dict : <NEWLINE> <INDENT> dict [ BC [ i ] [ 0 ] ] = 0 <NEWLINE> <DEDENT> if BC [ i ] [ 1 ] not in dict : <NEWLINE> <INDENT> dict [ BC [ i ] [ 1 ] ] = 0 <NEWLINE> <DEDENT> if dict [ BC [ i ] [ 0 ] ] > 0 : <NEWLINE> <INDENT> num = ( BC [ i ] [ 1 ] - BC [ i ] [ 0 ] ) * ( dict [ BC [ i ] [ 0 ] ] ) <NEWLINE> total += num <NEWLINE> <DEDENT> print ( total ) <NEWLINE> dict [ BC [ i ] [ 1 ] ] += dict [ BC [ i ] [ 0 ] ] <NEWLINE> dict [ BC [ i ] [ 0 ] ] = 0 <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> friend = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> friend [ s ] . append ( t ) <NEWLINE> friend [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> group = [ - 1 for i in range ( n ) ] <NEWLINE> for u in range ( n ) : <NEWLINE> <INDENT> if group [ u ] == - 1 : <NEWLINE> <INDENT> group [ u ] = u <NEWLINE> q = [ u ] <NEWLINE> while q : <NEWLINE> <INDENT> u1 = q . pop ( ) <NEWLINE> for u2 in friend [ u1 ] : <NEWLINE> <INDENT> if group [ u2 ] == - 1 : <NEWLINE> <INDENT> group [ u2 ] = u <NEWLINE> q . append ( u2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if group [ s ] == group [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> reslst = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> reslst [ lst1 [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( reslst [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , int ( math . sqrt ( a ) ) , 1 ) : <NEWLINE> <INDENT> if a % i == 0 and not i == 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while a % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a = a / i <NEWLINE> <DEDENT> ans += ( math . sqrt ( 2 * cnt + 0.25 ) - 0.5 ) // 1 <NEWLINE> <DEDENT> <DEDENT> if not a == 1 : <NEWLINE> <INDENT> print ( int ( ans + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ans ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> s = list ( set ( ( list ( itertools . chain . from_iterable ( A ) ) ) ) ) <NEWLINE> print ( N - len ( s ) ) <NEWLINE>
def main ( ) -> None : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_tuple = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a_tuple : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> boader = 10 ** 18 <NEWLINE> answer = 1 <NEWLINE> for a in a_tuple : <NEWLINE> <INDENT> answer *= a <NEWLINE> if answer > boader : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> for y in x : <NEWLINE> <INDENT> for z in y : <NEWLINE> <INDENT> print ( <STRING> % z , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i < 4 - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> nlist = [ ] <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> nlist . append ( math . gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> import collections <NEWLINE> <NL> c = collections . Counter ( nlist ) <NEWLINE> ck = list ( c . keys ( ) ) <NEWLINE> cv = list ( c . values ( ) ) <NEWLINE> <NL> cn = len ( ck ) <NEWLINE> <NL> for i in range ( cn ) : <NEWLINE> <INDENT> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res += math . gcd ( c , ck [ i ] ) * cv [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a = np . array ( read ( ) . split ( ) , np . int32 ) [ 1 : ] <NEWLINE> count = np . zeros ( 10 ** 6 + 1 , np . int32 ) <NEWLINE> for ae in a : <NEWLINE> <INDENT> if count [ ae ] <= 1 : <NEWLINE> <INDENT> count [ : : ae ] += 1 <NEWLINE> <DEDENT> <DEDENT> r = 0 <NEWLINE> for ae in a : <NEWLINE> <INDENT> r += count [ ae ] == 1 <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> l = [ 0 ] * n <NEWLINE> <COMMENT> <NL> if k <= 200000 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> p = A [ p - 1 ] <NEWLINE> l [ p - 1 ] += 1 <NEWLINE> <DEDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 200001 ) : <NEWLINE> <INDENT> p = A [ p - 1 ] <COMMENT> <NEWLINE> l [ p - 1 ] += 1 <NEWLINE> <COMMENT> <NL> if l [ p - 1 ] == 2 : <NEWLINE> <INDENT> x = i <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> d = 1 <NEWLINE> for j in range ( 200001 ) : <NEWLINE> <INDENT> d = A [ d - 1 ] <COMMENT> <NEWLINE> if d == p : <NEWLINE> <INDENT> y = j <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> z = ( k - x - 1 ) % ( x - y ) <COMMENT> <NEWLINE> <COMMENT> <NL> for i in range ( z ) : <NEWLINE> <INDENT> p = A [ p - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d = [ 0 ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> d [ a - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> score = 0 <NEWLINE> for a in d : <NEWLINE> <INDENT> score += a * ( a - 1 ) // 2 <NEWLINE> <COMMENT> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( score - d [ a - 1 ] + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <NL> sys . setrecursionlimit ( 3 * 10 ** 5 ) <NEWLINE> <NL> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , color ) : <NEWLINE> <INDENT> self . color = int ( color ) - 1 <NEWLINE> self . children = [ ] <NEWLINE> <NL> <DEDENT> def add_child ( self , node ) : <NEWLINE> <INDENT> self . children . append ( node ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def prepare_nodes ( n ) : <NEWLINE> <INDENT> nodes = tuple ( map ( Node , input ( ) . split ( ) ) ) <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> nodes [ a ] . add_child ( nodes [ b ] ) <NEWLINE> nodes [ b ] . add_child ( nodes [ a ] ) <NEWLINE> <NL> <DEDENT> return nodes <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nodes = Node . prepare_nodes ( n ) <NEWLINE> <NL> dp = [ 0 for _ in range ( n ) ] <NEWLINE> ans_list = [ n * ( n + 1 ) // 2 for _ in range ( n ) ] <NEWLINE> <NL> def update_ans ( s , color ) : <NEWLINE> <INDENT> ans_list [ color ] -= ( s + dp [ color ] ) * ( s + dp [ color ] + 1 ) // 2 <NEWLINE> <NL> <DEDENT> def dfs ( s , node , parent ) : <NEWLINE> <INDENT> color = node . color <NEWLINE> pre_s = s + dp [ color ] <NEWLINE> for child in node . children : <NEWLINE> <INDENT> if child == parent : continue <NEWLINE> <NL> dp [ color ] = - s <NEWLINE> s = dfs ( s , child , node ) <NEWLINE> update_ans ( s , color ) <NEWLINE> <NL> <DEDENT> s += 1 <NEWLINE> dp [ color ] = pre_s - s <NEWLINE> <NL> return s <NEWLINE> <NL> <DEDENT> s = dfs ( 0 , nodes [ 0 ] , Node ( - 1 ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> update_ans ( s , i ) <NEWLINE> print ( ans_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> if count == 3 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans *= A [ - i ] <NEWLINE> <DEDENT> print ( ans if ans <= 10 ** 18 else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> judge = 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> judge = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if judge != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> num = int ( input ( ) ) <NEWLINE> arr = input ( ) . split ( ) <NEWLINE> arr = sorted ( [ int ( i ) for i in arr ] ) <NEWLINE> <NL> lis1 = [ 0 ] * ( arr [ - 1 ] + 1 ) <NEWLINE> <NL> for num in arr : <NEWLINE> <INDENT> for j in range ( 0 , len ( lis1 ) , num ) : <NEWLINE> <INDENT> lis1 [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for num in arr : <NEWLINE> <INDENT> if lis1 [ num ] == 1 : cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N = list ( input ( ) ) <NEWLINE> s = set ( N ) <NEWLINE> ans = <STRING> . join ( sorted ( s ) ) <NEWLINE> all = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> if ans == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if ans [ i ] != all [ i ] : <NEWLINE> <INDENT> print ( all [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif i == len ( ans ) - 1 : <NEWLINE> <INDENT> print ( all [ len ( ans ) ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> lst . append ( x ) <NEWLINE> <DEDENT> print ( len ( set ( lst ) ) ) <NEWLINE>
import math <NEWLINE> <NL> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> v . sort ( reverse = True ) <NEWLINE> total = 0 <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> for i in range ( A ) : <NEWLINE> <INDENT> total = total + v [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total / A ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> min = v [ A - 1 ] <NEWLINE> number = v . count ( min ) <NEWLINE> <NL> if ( v . index ( min ) == 0 ) : <NEWLINE> <INDENT> for i in range ( A , number + 1 ) : <NEWLINE> <INDENT> if ( i > B ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = combinations_count ( number , i ) + count <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( combinations_count ( number , A - v . index ( min ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> factors = [ ] <NEWLINE> i = 2 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n < i * i : <NEWLINE> <INDENT> factors . append ( n ) <NEWLINE> break <NEWLINE> <DEDENT> while n % i == 0 : <NEWLINE> <INDENT> factors . append ( i ) <NEWLINE> n //= i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in Counter ( factors ) . values ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while cnt >= i : <NEWLINE> <INDENT> cnt -= i <NEWLINE> i += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> def readString ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) <NEWLINE> <NL> <DEDENT> def readInteger ( ) : <NEWLINE> <INDENT> return int ( readString ( ) ) <NEWLINE> <NL> <DEDENT> def readStringSet ( n ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . split ( <STRING> ) [ : n ] <NEWLINE> <NL> <DEDENT> def readIntegerSet ( n ) : <NEWLINE> <INDENT> return list ( map ( int , readStringSet ( n ) ) ) <NEWLINE> <NL> <DEDENT> def readIntegerMatrix ( n , m ) : <NEWLINE> <INDENT> return reduce ( lambda acc , _ : acc + [ readIntegerSet ( m ) ] , range ( 0 , n ) , [ ] ) <NEWLINE> <NL> <DEDENT> def main ( N ) : <NEWLINE> <INDENT> maxi = int ( math . sqrt ( N ) ) <NEWLINE> result = dict ( ) <NEWLINE> for x in range ( 1 , maxi + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , maxi + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , maxi + 1 ) : <NEWLINE> <INDENT> n = pow ( x , 2 ) + pow ( y , 2 ) + pow ( z , 2 ) + x * y + y * z + z * x <NEWLINE> if n not in result . keys ( ) : <NEWLINE> <INDENT> result [ n ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if n in result . keys ( ) : <NEWLINE> <INDENT> print ( result [ n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _N = readInteger ( ) <NEWLINE> <NL> main ( _N ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> def s2nn ( s ) : return [ int ( c ) for c in s . split ( <STRING> ) ] <NEWLINE> def ss2nn ( ss ) : return [ int ( s ) for s in list ( ss ) ] <NEWLINE> def ss2nnn ( ss ) : return [ s2nn ( s ) for s in list ( ss ) ] <NEWLINE> def i2s ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def i2n ( ) : return int ( i2s ( ) ) <NEWLINE> def i2nn ( ) : return s2nn ( i2s ( ) ) <NEWLINE> def ii2ss ( n ) : return [ i2s ( ) for _ in range ( n ) ] <NEWLINE> def ii2nn ( n ) : return ss2nn ( ii2ss ( n ) ) <NEWLINE> def ii2nnn ( n ) : return ss2nnn ( ii2ss ( n ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , K , D = i2nn ( ) <NEWLINE> absX = abs ( X ) <NEWLINE> if absX >= K * D : <NEWLINE> <INDENT> print ( abs ( absX - K * D ) ) <NEWLINE> return <NEWLINE> <DEDENT> a , c = divmod ( absX , D ) <NEWLINE> b = K - a <NEWLINE> if b % 2 : <NEWLINE> <INDENT> print ( abs ( c - D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( c ) ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
from bisect import bisect as list_bisect <NEWLINE> max2 = lambda x , y : x if x > y else y <NEWLINE> min2 = lambda x , y : x if x < y else y <NEWLINE> <NL> def bisect ( ng , ok , judge , eps = 1 ) : <NEWLINE> <INDENT> while abs ( ng - ok ) > eps : <NEWLINE> <INDENT> m = ( ng + ok ) // 2 <NEWLINE> if judge ( m ) : <NEWLINE> <INDENT> ok = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = m <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> N , M , V , P = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = N - P <NEWLINE> def judge ( i ) : <NEWLINE> <INDENT> if i >= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> a = A [ i ] <NEWLINE> if a + M < A [ k ] : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> r = 0 <NEWLINE> for v in A [ i + 1 : k + 1 ] : <NEWLINE> <INDENT> r += a + M - v <NEWLINE> <DEDENT> return r >= ( V - P - i ) * M <NEWLINE> <NL> <DEDENT> i = bisect ( - 1 , N - 1 , judge ) <NEWLINE> print ( N - i ) <NEWLINE>
import math <NEWLINE> <NL> kosuu = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> hoge = 1 <NEWLINE> <NL> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for num in arr : <NEWLINE> <INDENT> hoge = hoge * num <NEWLINE> if hoge > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> kosuu = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if kosuu > 0 : <NEWLINE> <INDENT> print ( hoge ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> S = [ 0 ] * ( N + 1 ) <COMMENT> <NEWLINE> s = 0 <NEWLINE> CONST = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S [ i + 1 ] = S [ i ] + A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s += A [ i ] * ( ( S [ N ] - S [ i + 1 ] ) % CONST ) <NEWLINE> s %= CONST <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( b - a [ i ] ) <NEWLINE> b = b - a [ i ] <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> r = [ 0 ] * 101 <NEWLINE> for _ in [ 0 ] * n : r [ int ( input ( ) ) ] += 1 <NEWLINE> a = 0 <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if i * 2 > s : a += ( r [ i ] ** 2 - r [ i ] ) // 2 <NEWLINE> a += r [ i ] * sum ( r [ j ] for j in range ( max ( i + 1 , s + 1 - i ) , 101 ) ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt_h = [ 0 ] * h <NEWLINE> cnt_w = [ 0 ] * w <NEWLINE> dic = defaultdict ( int ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> h_m , w_m = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt_h [ h_m - 1 ] += 1 <NEWLINE> cnt_w [ w_m - 1 ] += 1 <NEWLINE> dic [ ( h_m - 1 , w_m - 1 ) ] += 1 <NEWLINE> <NL> <DEDENT> max_h = max ( cnt_h ) <NEWLINE> max_w = max ( cnt_w ) <NEWLINE> <NL> mh = [ ] <NEWLINE> mw = [ ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> if max_h == cnt_h [ i ] : <NEWLINE> <INDENT> mh . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if max_w == cnt_w [ i ] : <NEWLINE> <INDENT> mw . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in mh : <NEWLINE> <INDENT> for j in mw : <NEWLINE> <INDENT> if dic [ ( i , j ) ] == 0 : <NEWLINE> <INDENT> print ( max_h + max_w ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_h + max_w - 1 ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> A = [ int ( i ) for i in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> max_value = A . pop ( 0 ) <NEWLINE> diff = deque ( [ max_value ] ) <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = ans + diff . popleft ( ) <NEWLINE> diff . append ( i ) <NEWLINE> diff . append ( i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += n // i * ( i + n // i * i ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> ans = dp [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> begin = 0 <NEWLINE> end = a [ 0 ] - 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> end = a [ i ] - 1 <NEWLINE> ans *= dp [ end - begin ] <NEWLINE> <NL> if ( i + 1 < m and a [ i + 1 ] == a [ i ] + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> begin = end + 2 <NEWLINE> <NL> <DEDENT> <DEDENT> ans *= dp [ n - a [ m - 1 ] - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ball = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if n // 2 < i : <NEWLINE> <INDENT> ball [ i ] = a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( sum ( ball [ i : : ( i + 1 ) ] ) - a [ i ] ) % 2 == 0 : <NEWLINE> <INDENT> ball [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ball [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> num = [ str ( i + 1 ) for i , x in enumerate ( ball ) if x == 1 ] <NEWLINE> <NL> if len ( num ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( num ) ) <NEWLINE> num = <STRING> . join ( num ) <NEWLINE> print ( num ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> a . popleft ( ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , v = c . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> a . appendleft ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a . remove ( v ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <NL>
<COMMENT> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <NL> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> length = len ( T ) <NEWLINE> slen = len ( S ) <NEWLINE> mincnt = 10000 <NEWLINE> for i in range ( slen - length + 1 ) : <NEWLINE> <INDENT> tmp = S [ i : i + length ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> if tmp [ i ] != T [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt < mincnt : <NEWLINE> <INDENT> mincnt = cnt <NEWLINE> <DEDENT> <DEDENT> print ( mincnt ) <NEWLINE>
import math <NEWLINE> <NL> w = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> m = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> w += math . gcd ( m , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( w ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( x // 3600 , <STRING> , ( x % 3600 ) // 60 , <STRING> , ( x % 3600 ) % 60 , sep = <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m = ( int ( s ) for s in input ( ) . split ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> sections = sorted ( ( [ int ( s ) for s in input ( ) . split ( ) ] for i in range ( n ) ) , <NEWLINE> <INDENT> key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> <DEDENT> for i , ( d , p ) in enumerate ( sections ) : <NEWLINE> <INDENT> m -= d <NEWLINE> if m <= 0 : <NEWLINE> <INDENT> print ( sum ( s [ 0 ] * s [ 1 ] for s in sections [ i + 1 : ] ) - p * m ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def num_divisors_table ( N ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> u = i <NEWLINE> t = i * ( N // i ) <NEWLINE> n = N // i <NEWLINE> ans += ( u + t ) * n // 2 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( num_divisors_table ( N ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> check = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if check > P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> check = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> sum1 = 1 <NEWLINE> <NL> if <STRING> in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> sum1 = sum1 * int ( b [ i ] ) <NEWLINE> if sum1 > 10 ** 18 : <NEWLINE> <INDENT> sum1 = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n - sum ( a ) < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( n - sum ( a ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> tmp = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for bangou in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if tmp < len ( a ) : <NEWLINE> <INDENT> while a [ tmp ] == bangou : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp += 1 <NEWLINE> if tmp == len ( a ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> def binarysearch ( x , l ) : <NEWLINE> <INDENT> mi = 0 <NEWLINE> ma = len ( l ) - 1 <NEWLINE> <NL> while mi < ma : <NEWLINE> <INDENT> tmp = ( mi + ma ) // 2 <NEWLINE> <NL> if l [ tmp ] == x : <NEWLINE> <INDENT> return tmp <NEWLINE> <DEDENT> elif l [ tmp ] < x : <NEWLINE> <INDENT> mi = tmp + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ma = tmp - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if mi == ma : <NEWLINE> <INDENT> if x == l [ mi ] : <NEWLINE> <INDENT> return mi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x == l [ mi ] : <NEWLINE> <INDENT> return mi <NEWLINE> <DEDENT> elif x == l [ ma ] : <NEWLINE> <INDENT> return ma <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for x in t : <NEWLINE> <INDENT> if binarysearch ( x , s ) != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , 12 ) : <NEWLINE> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> n -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> a = n % 26 <NEWLINE> ans . append ( chr ( 97 + a ) ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <DEDENT> <DEDENT> print ( * ans [ : : - 1 ] , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> num = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def print_array ( ) : <NEWLINE> <INDENT> for i in range ( num ) : <NEWLINE> <INDENT> if i != num - 1 : <NEWLINE> <INDENT> print ( array [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( array [ i ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( num ) : <NEWLINE> <INDENT> insert = array [ i ] <NEWLINE> j = 0 <NEWLINE> while array [ j ] < insert : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> for k in range ( i , j , - 1 ) : <NEWLINE> <INDENT> array [ k ] = array [ k - 1 ] <NEWLINE> <DEDENT> array [ j ] = insert <NEWLINE> print_array ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> G [ u ] . append ( v ) <NEWLINE> G [ v ] . append ( u ) <NEWLINE> <NL> <NL> <DEDENT> root = 0 <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> check = [ False ] * N <NEWLINE> check [ root ] = True <NEWLINE> <NL> memo = [ None ] * N <NEWLINE> <NL> INF = 10 ** 10 <NEWLINE> dp = [ INF ] * N <NEWLINE> <NL> def dfs ( x ) : <NEWLINE> <INDENT> tmp = bisect_left ( dp , A [ x ] ) <NEWLINE> memo [ x ] = ( tmp , dp [ tmp ] ) <NEWLINE> dp [ tmp ] = A [ x ] <NEWLINE> ans [ x ] = bisect_left ( dp , INF ) <NEWLINE> for next_ in G [ x ] : <NEWLINE> <INDENT> if check [ next_ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> check [ next_ ] = True <NEWLINE> dfs ( next_ ) <NEWLINE> <DEDENT> j , a = memo [ x ] <NEWLINE> dp [ j ] = a <NEWLINE> <NL> <DEDENT> dfs ( root ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> X = str ( input ( ) ) <NEWLINE> F = [ 0 ] * N <NEWLINE> <NL> def calc_f ( n : int ) -> int : <NEWLINE> <INDENT> global F <NEWLINE> x = n <NEWLINE> res = 0 <NEWLINE> while 0 < x : <NEWLINE> <INDENT> if F [ x ] != 0 : <NEWLINE> <INDENT> res += F [ x ] <NEWLINE> break <NEWLINE> <DEDENT> pop = bin ( n ) . count ( <STRING> ) <NEWLINE> x %= pop <NEWLINE> res += 1 <NEWLINE> <DEDENT> F [ n ] = res <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> calc_f ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> pop_ini = X . count ( <STRING> ) <NEWLINE> pp = pop_ini + 1 <COMMENT> <NEWLINE> pm = pop_ini - 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> ap = [ 0 ] * N <COMMENT> <NEWLINE> am = [ 0 ] * N <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ap [ i ] = pow ( 2 , N - 1 - i , pp ) <NEWLINE> if 0 < pm : <NEWLINE> <INDENT> am [ i ] = pow ( 2 , N - 1 - i , pm ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> fp = 0 <COMMENT> <NEWLINE> fm = 0 <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> fp = ( fp + ap [ i ] ) % pp <NEWLINE> if 0 < pm : <NEWLINE> <INDENT> fm = ( fm + am [ i ] ) % pm <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if 0 < pm : <NEWLINE> <INDENT> v = ( fm + pm - am [ i ] ) % pm <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> v = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> v = ( fp + ap [ i ] ) % pp <NEWLINE> <DEDENT> if 0 < v : <NEWLINE> <INDENT> ans += F [ v ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> count += isprime ( x ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> def isprime ( x : int ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for y in range ( 3 , int ( x ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<NL> from collections import deque <NEWLINE> <NL> <NL> def bfs ( u ) : <NEWLINE> <INDENT> queue = deque ( [ u ] ) <NEWLINE> d = [ None ] * N <COMMENT> <NEWLINE> d [ u ] = 0 <COMMENT> <NEWLINE> ans = [ 0 ] * N <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in g [ v ] : <NEWLINE> <NL> <INDENT> if d [ i ] is None : <NEWLINE> <INDENT> d [ i ] = d [ v ] + 1 <NEWLINE> queue . append ( i ) <NEWLINE> ans [ i ] = v + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = bfs ( 0 ) <NEWLINE> if 0 in ans [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in ans [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = None <NEWLINE> if B <= N : <NEWLINE> <INDENT> l = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = N <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <STRING> <NEWLINE> <NL> print ( ( ( A * l ) // B ) - A * ( l // B ) ) <NEWLINE> <NL> <NL> <NL> <STRING> <NEWLINE>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> m = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> _ , a = sys . stdin . readline ( ) . split ( ) <NEWLINE> m . append ( int ( a ) ) <NEWLINE> <NL> <DEDENT> c = [ [ - 1 for _ in range ( n ) ] for _ in range ( n ) ] <NEWLINE> <NL> def val ( a , b ) : <NEWLINE> <INDENT> if a == b : return 0 <NEWLINE> if c [ a ] [ b ] > 0 : return c [ a ] [ b ] <NEWLINE> c [ a ] [ b ] = val ( a + 1 , b ) + m [ a - 1 ] * m [ a ] * m [ b ] <NEWLINE> for k in range ( a + 1 , b ) : <NEWLINE> <INDENT> v = val ( a , k ) + val ( k + 1 , b ) + m [ a - 1 ] * m [ k ] * m [ b ] <NEWLINE> if c [ a ] [ b ] > v : c [ a ] [ b ] = v <NEWLINE> <DEDENT> return c [ a ] [ b ] <NEWLINE> <NL> <DEDENT> print ( val ( 0 , n - 1 ) ) <NEWLINE>
row_num = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for row in range ( row_num ) : <NEWLINE> <INDENT> nums . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> min_diff = nums [ 0 ] <NEWLINE> max_diff = nums [ 1 ] - nums [ 0 ] <NEWLINE> for i in range ( 1 , len ( nums ) ) : <NEWLINE> <INDENT> if max_diff < nums [ i ] - min_diff : <NEWLINE> <INDENT> max_diff = nums [ i ] - min_diff <NEWLINE> <DEDENT> if min_diff > nums [ i ] : <NEWLINE> <INDENT> min_diff = nums [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_diff ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = { } <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> am , bm = map ( int , input ( ) . split ( ) ) <NEWLINE> if am not in graph : <NEWLINE> <INDENT> graph [ am ] = [ bm ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> graph [ am ] . append ( bm ) <NEWLINE> <DEDENT> if bm not in graph : <NEWLINE> <INDENT> graph [ bm ] = [ am ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> graph [ bm ] . append ( am ) <NEWLINE> <DEDENT> <DEDENT> signs = { 1 : 0 } <NEWLINE> current = [ 1 ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in graph [ current [ i ] ] : <NEWLINE> <INDENT> if j not in signs : <NEWLINE> <INDENT> signs [ j ] = current [ i ] <NEWLINE> current . append ( j ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> if flag == 0 and i == len ( current ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if i == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( signs [ x ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def func1 ( x , y , z , a ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> z . append ( a ) <NEWLINE> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def func2 ( x , y ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def func3 ( x , y , z , a ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> for j in y : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k <= N - 1 and i < j : <NEWLINE> <INDENT> l += func2 ( z [ k ] , a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r , g , b , rgb , equal = 0 , 0 , 0 , 0 , 0 <NEWLINE> r0 , g0 , b0 = [ ] , [ ] , [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> r += func1 ( S [ i ] , <STRING> , r0 , i ) <NEWLINE> g += func1 ( S [ i ] , <STRING> , g0 , i ) <NEWLINE> b += func1 ( S [ i ] , <STRING> , b0 , i ) <NEWLINE> <NL> <DEDENT> rgb = r * g * b <NEWLINE> <NL> <COMMENT> <NL> equal += func3 ( r0 , g0 , S , <STRING> ) <NEWLINE> <COMMENT> <NL> equal += func3 ( r0 , b0 , S , <STRING> ) <NEWLINE> <COMMENT> <NL> equal += func3 ( g0 , r0 , S , <STRING> ) <NEWLINE> <COMMENT> <NL> equal += func3 ( g0 , b0 , S , <STRING> ) <NEWLINE> <COMMENT> <NL> equal += func3 ( b0 , r0 , S , <STRING> ) <NEWLINE> <COMMENT> <NL> equal += func3 ( b0 , g0 , S , <STRING> ) <NEWLINE> <NL> print ( rgb - equal ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 > n : <NEWLINE> <INDENT> ans = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = b - 1 <NEWLINE> <DEDENT> print ( a * ans // b - a * ( ans // b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def calc ( m , res ) : <NEWLINE> <INDENT> q , mod = divmod ( m , 26 ) <NEWLINE> if ( mod == 0 ) : <NEWLINE> <INDENT> q = q - 1 <NEWLINE> mod = 26 <NEWLINE> res = chr ( ord ( <STRING> ) + ( mod - 1 ) ) + res <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = chr ( ord ( <STRING> ) + ( mod - 1 ) ) + res <NEWLINE> <DEDENT> if ( q > 0 ) : <NEWLINE> <INDENT> calc ( q , res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> calc ( n , <STRING> ) <NEWLINE>
from heapq import heappop as hpop <NEWLINE> from heapq import heappush as hpush <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if not n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cost_edges = [ [ ] for _ in range ( m ) ] <NEWLINE> time_edges = [ [ ] for _ in range ( m ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> a , b , c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> cost_edges [ a - 1 ] . append ( ( c , b - 1 ) ) <NEWLINE> cost_edges [ b - 1 ] . append ( ( c , a - 1 ) ) <NEWLINE> time_edges [ a - 1 ] . append ( ( t , b - 1 ) ) <NEWLINE> time_edges [ b - 1 ] . append ( ( t , a - 1 ) ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> start , goal , r = map ( int , input ( ) . split ( ) ) <NEWLINE> start -= 1 <NEWLINE> goal -= 1 <NEWLINE> <NL> if r : <NEWLINE> <INDENT> edges = time_edges <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edges = cost_edges <NEWLINE> <NL> <DEDENT> que = [ ( 0 , start ) ] <NEWLINE> visited = [ False for _ in range ( m ) ] <NEWLINE> <NL> while que : <NEWLINE> <INDENT> score , station = hpop ( que ) <NEWLINE> visited [ station ] = True <NEWLINE> <NL> if station == goal : <NEWLINE> <INDENT> print ( score ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> for c , to_station in edges [ station ] : <NEWLINE> <INDENT> if not visited [ to_station ] : <NEWLINE> <INDENT> hpush ( que , ( score + c , to_station ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , K , * p = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ : K ] ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> exist = [ False ] * 201 <NEWLINE> for p in P : <NEWLINE> <INDENT> exist [ p ] = True <NEWLINE> <DEDENT> resid = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if not exist [ X - resid ] : <NEWLINE> <INDENT> print ( X - resid ) <NEWLINE> return None <NEWLINE> <DEDENT> if not exist [ X + resid ] : <NEWLINE> <INDENT> print ( X + resid ) <NEWLINE> return None <NEWLINE> <DEDENT> resid += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
<NL> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> npdata = np . arange ( 10 ** 5 + 1 ) <NEWLINE> <NL> kosuu = np . zeros ( 10 ** 5 + 1 ) <NEWLINE> kosuumoto = kosuu <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> kosuu [ a ] += 1 <NEWLINE> <DEDENT> SUM = sum ( A ) <NEWLINE> <NL> BC_list = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> bc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BC_list . append ( bc ) <NEWLINE> <DEDENT> S = SUM <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b = BC_list [ i ] [ 0 ] <NEWLINE> c = BC_list [ i ] [ 1 ] <NEWLINE> minus = b * kosuu [ b ] <NEWLINE> plus = c * kosuu [ b ] <NEWLINE> kosuu [ c ] = kosuu [ c ] + kosuu [ b ] <NEWLINE> kosuu [ b ] = 0 <NEWLINE> S = S - minus + plus <NEWLINE> print ( int ( S ) ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> cnt [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> print ( cnt [ k ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import heapq , bisect <NEWLINE> s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> L = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( n + 1 , i + 6 ) ) : <NEWLINE> <INDENT> L . add ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> L = list ( L ) <NEWLINE> L . sort ( ) <NEWLINE> print ( L [ K - 1 ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> loop = int ( n ** .5 ) + 1 <NEWLINE> <NL> def f ( i , j , k ) : <NEWLINE> <INDENT> return i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , loop + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , loop + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , loop + 1 ) : <NEWLINE> <INDENT> res = int ( f ( i , j , k ) ) <NEWLINE> if res <= n : <NEWLINE> <INDENT> ans [ res ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i_plus_Ai = [ 0 for i in range ( N ) ] <NEWLINE> dict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> i_plus_Ai [ i ] = i + As [ i ] <NEWLINE> tmp = i - As [ i ] <NEWLINE> if tmp not in dict : <NEWLINE> <INDENT> dict [ tmp ] = [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ tmp ] . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i_plus_Ai [ i ] in dict : <NEWLINE> <INDENT> kouho = dict [ i_plus_Ai [ i ] ] <NEWLINE> for j in range ( len ( kouho ) ) : <NEWLINE> <INDENT> if kouho [ j ] > i : <NEWLINE> <INDENT> count += len ( kouho ) - j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
NUM = 1000 <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> flg = False <NEWLINE> <NL> for i in reversed ( range ( NUM ) ) : <NEWLINE> <INDENT> for j in range ( - 1 * NUM , NUM ) : <NEWLINE> <INDENT> res = ( i ** 5 ) - ( j ** 5 ) <NEWLINE> if res == X : <NEWLINE> <INDENT> ans_A = i <NEWLINE> ans_B = j <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans_A , ans_B ) <NEWLINE>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import numpy as np <NEWLINE> <NL> def solve_1bit ( N , rps , cps , rv , cv ) : <NEWLINE> <INDENT> res = np . full ( ( N , N ) , 2 , dtype = np . uint64 ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> res [ 0 , 0 ] = rv [ 0 ] <NEWLINE> return res <NEWLINE> <DEDENT> r_all = np . array ( [ False , False ] ) <NEWLINE> for i , ( ps , v ) in enumerate ( zip ( rps , rv ) ) : <NEWLINE> <INDENT> if ps ^ v == 1 : <NEWLINE> <INDENT> res [ i , : ] = v <NEWLINE> r_all [ v ] = True <NEWLINE> <DEDENT> <DEDENT> c_all = np . array ( [ False , False ] ) <NEWLINE> for i , ( ps , v ) in enumerate ( zip ( cps , cv ) ) : <NEWLINE> <INDENT> if ps ^ v == 1 : <NEWLINE> <INDENT> res [ : , i ] = v <NEWLINE> c_all [ v ] = True <NEWLINE> <DEDENT> <DEDENT> if ( r_all [ 0 ] and c_all [ 1 ] ) or ( r_all [ 1 ] and c_all [ 0 ] ) : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> if r_all [ 0 ] and c_all [ 0 ] : <NEWLINE> <INDENT> return np . where ( res == 2 , np . uint64 ( 1 ) , res ) <NEWLINE> <DEDENT> if r_all [ 1 ] and c_all [ 1 ] : <NEWLINE> <INDENT> return np . where ( res == 2 , np . uint64 ( 0 ) , res ) <NEWLINE> <DEDENT> if np . all ( r_all ) : <NEWLINE> <INDENT> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> if res [ y , x ] == 2 : <NEWLINE> <INDENT> res [ y , x ] = rv [ y ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> if np . all ( c_all ) : <NEWLINE> <INDENT> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> if res [ y , x ] == 2 : <NEWLINE> <INDENT> res [ y , x ] = cv [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> if r_all [ 0 ] : <NEWLINE> <INDENT> if ( cv == 0 ) . any ( ) : <NEWLINE> <INDENT> x = ( cv == 0 ) . nonzero ( ) [ 0 ] [ 0 ] <NEWLINE> res [ : , x ] = 0 <NEWLINE> return np . where ( res == 2 , np . uint64 ( 1 ) , res ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> for y in range ( N ) : <NEWLINE> <INDENT> v = rv [ y ] <NEWLINE> if v == 0 and res [ y , 0 ] == 2 : <NEWLINE> <INDENT> res [ y , x ] = 0 <NEWLINE> x = ( x + 1 ) % N <NEWLINE> <DEDENT> <DEDENT> return np . where ( res == 2 , np . uint64 ( 1 ) , res ) <NEWLINE> <DEDENT> if r_all [ 1 ] : <NEWLINE> <INDENT> if ( cv == 1 ) . any ( ) : <NEWLINE> <INDENT> x = ( cv == 1 ) . nonzero ( ) [ 0 ] [ 0 ] <NEWLINE> res [ : , x ] = 1 <NEWLINE> return np . where ( res == 2 , np . uint64 ( 0 ) , res ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> for y in range ( N ) : <NEWLINE> <INDENT> v = rv [ y ] <NEWLINE> if v == 1 and res [ y , 0 ] == 2 : <NEWLINE> <INDENT> res [ y , x ] = 1 <NEWLINE> x = ( x + 1 ) % N <NEWLINE> <DEDENT> <DEDENT> return np . where ( res == 2 , np . uint64 ( 0 ) , res ) <NEWLINE> <DEDENT> if c_all [ 0 ] : <NEWLINE> <INDENT> if ( rv == 0 ) . any ( ) : <NEWLINE> <INDENT> y = ( rv == 0 ) . nonzero ( ) [ 0 ] [ 0 ] <NEWLINE> res [ y , : ] = 0 <NEWLINE> return np . where ( res == 2 , np . uint64 ( 1 ) , res ) <NEWLINE> <DEDENT> y = 0 <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> v = cv [ x ] <NEWLINE> if v == 0 and res [ 0 , x ] == 2 : <NEWLINE> <INDENT> res [ y , x ] = 0 <NEWLINE> y = ( y + 1 ) % N <NEWLINE> <DEDENT> <DEDENT> return np . where ( res == 2 , np . uint64 ( 1 ) , res ) <NEWLINE> <DEDENT> if c_all [ 1 ] : <NEWLINE> <INDENT> if ( rv == 1 ) . any ( ) : <NEWLINE> <INDENT> y = ( rv == 1 ) . nonzero ( ) [ 0 ] [ 0 ] <NEWLINE> res [ y , : ] = 1 <NEWLINE> return np . where ( res == 2 , np . uint64 ( 0 ) , res ) <NEWLINE> <DEDENT> y = 0 <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> v = cv [ x ] <NEWLINE> if v == 1 and res [ 0 , x ] == 2 : <NEWLINE> <INDENT> res [ y , x ] = 1 <NEWLINE> y = ( y + 1 ) % N <NEWLINE> <DEDENT> <DEDENT> return np . where ( res == 2 , np . uint64 ( 0 ) , res ) <NEWLINE> <DEDENT> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> res [ y , x ] = ( y ^ x ) & 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def solve ( N , row_prod_sum , col_prod_sum , row_val , col_val ) : <NEWLINE> <INDENT> res = np . zeros ( ( N , N ) , dtype = np . uint64 ) <NEWLINE> for i in range ( 64 ) : <NEWLINE> <INDENT> rps = row_prod_sum <NEWLINE> cps = col_prod_sum <NEWLINE> rv = row_val >> i & 1 <NEWLINE> cv = col_val >> i & 1 <NEWLINE> r = solve_1bit ( N , rps , cps , rv , cv ) <NEWLINE> res |= r << i <NEWLINE> <COMMENT> <NL> <DEDENT> prod = res [ 0 ] . copy ( ) <NEWLINE> sum_ = res [ 0 ] . copy ( ) <NEWLINE> for y in range ( 1 , N ) : <NEWLINE> <INDENT> prod &= res [ y ] <NEWLINE> sum_ |= res [ y ] <NEWLINE> <COMMENT> <NL> <DEDENT> if ( prod [ col_prod_sum == 0 ] != col_val [ col_prod_sum == 0 ] ) . any ( ) : <NEWLINE> <INDENT> return 0 , np . array ( [ [ - 1 ] ] , dtype = np . int64 ) <NEWLINE> <DEDENT> if ( sum_ [ col_prod_sum == 1 ] != col_val [ col_prod_sum == 1 ] ) . any ( ) : <NEWLINE> <INDENT> return 0 , np . array ( [ [ - 1 ] ] , dtype = np . int64 ) <NEWLINE> <DEDENT> prod = res [ : , 0 ] . copy ( ) <NEWLINE> sum_ = res [ : , 0 ] . copy ( ) <NEWLINE> for x in range ( 1 , N ) : <NEWLINE> <INDENT> prod &= res [ : , x ] <NEWLINE> sum_ |= res [ : , x ] <NEWLINE> <COMMENT> <NL> <DEDENT> if ( prod [ row_prod_sum == 0 ] != row_val [ row_prod_sum == 0 ] ) . any ( ) : <NEWLINE> <INDENT> return 0 , np . array ( [ [ - 1 ] ] , dtype = np . int64 ) <NEWLINE> <DEDENT> if ( sum_ [ row_prod_sum == 1 ] != row_val [ row_prod_sum == 1 ] ) . any ( ) : <NEWLINE> <INDENT> return 0 , np . array ( [ [ - 1 ] ] , dtype = np . int64 ) <NEWLINE> <DEDENT> return 1 , res <NEWLINE> <NL> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ solve_1bit , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> row_prod_sum = np . array ( input ( ) . split ( ) , dtype = np . uint64 ) <NEWLINE> col_prod_sum = np . array ( input ( ) . split ( ) , dtype = np . uint64 ) <NEWLINE> row_val = np . array ( input ( ) . split ( ) , dtype = np . uint64 ) <NEWLINE> col_val = np . array ( input ( ) . split ( ) , dtype = np . uint64 ) <NEWLINE> t , ans = solve ( N , row_prod_sum , col_prod_sum , row_val , col_val ) <NEWLINE> if t : <NEWLINE> <INDENT> for lst in ans . tolist ( ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , lst ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> lis = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = int ( input ( ) ) <NEWLINE> a . insert ( bisect . bisect_left ( a , inp ) , inp ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> bef = a [ 0 ] <NEWLINE> co = 0 <NEWLINE> for i in a [ 1 : ] : <NEWLINE> <INDENT> if i != bef : <NEWLINE> <INDENT> ans += ( co + 1 ) % 2 <NEWLINE> co = 0 <NEWLINE> bef = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> co += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ( co + 1 ) % 2 <NEWLINE> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , A : <STRING> ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> m = pow ( 10 , 18 ) <NEWLINE> if 0 in A : return 0 <NEWLINE> for n in A : <NEWLINE> <INDENT> p = p * n <NEWLINE> if p > m : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> A = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> print ( solve ( N , A ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n_lis = [ 0 ] * 102 <NEWLINE> for p in P : <NEWLINE> <INDENT> n_lis [ p ] += 1 <NEWLINE> <DEDENT> dis = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if n_lis [ x - dis ] == 0 : <NEWLINE> <INDENT> print ( x - dis ) <NEWLINE> break <NEWLINE> <DEDENT> elif n_lis [ x + dis ] == 0 : <NEWLINE> <INDENT> print ( x + dis ) <NEWLINE> break <NEWLINE> <DEDENT> dis += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> record = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> record [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b1 in range ( 4 ) : <NEWLINE> <INDENT> for f in record [ b1 ] : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( [ str ( x ) for x in f ] ) ) <NEWLINE> <DEDENT> if b1 != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> from bisect import bisect_left <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> ab = l [ i ] + l [ j ] <NEWLINE> idx = bisect_left ( l , ab ) <NEWLINE> ans += max ( 0 , idx - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumA = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sumA . append ( sumA [ - 1 ] + A [ i ] ) <NEWLINE> <DEDENT> sumB = [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> sumB . append ( sumB [ - 1 ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> k = K - sumA [ i ] <NEWLINE> if k < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l = bisect . bisect_right ( sumB , k ) - 1 <NEWLINE> ans = max ( ans , i + l ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def calcurate ( x ) : <NEWLINE> <INDENT> for a in range ( 1000 ) : <NEWLINE> <INDENT> a5 = a ** 5 <NEWLINE> for b in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> b5 = b ** 5 <NEWLINE> if a5 - b5 == X : <NEWLINE> <INDENT> return a , b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> A , B = calcurate ( X ) <NEWLINE> print ( A , B ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> <NL> @ jit <NEWLINE> def main ( n ) : <NEWLINE> <INDENT> dp = np . zeros ( n + 1 , np . int64 ) <NEWLINE> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> dp *= np . arange ( n + 1 ) <NEWLINE> return dp . sum ( ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( main ( n ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return n * solve ( n - 1 ) <NEWLINE> <NL> <DEDENT> if n <= 1 : <NEWLINE> <INDENT> n_ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_ans = solve ( n ) // ( solve ( n - 2 ) * 2 ) <NEWLINE> <DEDENT> if m <= 1 : <NEWLINE> <INDENT> m_ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m_ans = solve ( m ) // ( solve ( m - 2 ) * 2 ) <NEWLINE> <DEDENT> ans = n_ans + m_ans <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pos = - 1 <NEWLINE> seen = [ False ] * n <NEWLINE> last = [ - 1 ] * n <NEWLINE> hist = [ ] <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> while ( seen [ i ] == False ) : <NEWLINE> <INDENT> seen [ i ] = True <NEWLINE> last [ i ] = cnt <NEWLINE> cnt += 1 <NEWLINE> hist . append ( i ) <NEWLINE> ne = a [ i ] - 1 <NEWLINE> i = ne <NEWLINE> if ( seen [ i ] == True ) : <NEWLINE> <INDENT> pos = i <NEWLINE> <NL> <DEDENT> <DEDENT> cycle = hist [ last [ pos ] : ] <NEWLINE> preCircle = last [ pos ] <NEWLINE> <NL> if ( k <= preCircle ) : <NEWLINE> <INDENT> print ( hist [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= preCircle <NEWLINE> ans = k % len ( cycle ) <NEWLINE> print ( cycle [ ans ] + 1 ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> y = math . gcd ( l , x ) <NEWLINE> a . append ( y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ a [ i ] - ( i + 1 ) for i in range ( n ) ] <NEWLINE> <NL> b . sort ( ) <NEWLINE> <NL> m1 = b [ n // 2 ] <NEWLINE> s1 = sum ( [ abs ( b [ i ] - m1 ) for i in range ( n ) ] ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> m1 = b [ n // 2 ] <NEWLINE> s1 = sum ( [ abs ( b [ i ] - m1 ) for i in range ( n ) ] ) <NEWLINE> print ( s1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m1 = b [ n // 2 - 1 ] <NEWLINE> m2 = b [ n // 2 ] <NEWLINE> if ( m1 + m2 ) % 2 == 0 : <NEWLINE> <INDENT> l1 = ( m1 + m2 ) // 2 <NEWLINE> s1 = sum ( [ abs ( b [ i ] - l1 ) for i in range ( n ) ] ) <NEWLINE> print ( s1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 = ( m1 + m2 ) // 2 <NEWLINE> l2 = l1 + 1 <NEWLINE> s1 = sum ( [ abs ( b [ i ] - l1 ) for i in range ( n ) ] ) <NEWLINE> s2 = sum ( [ abs ( b [ i ] - l2 ) for i in range ( n ) ] ) <NEWLINE> <NL> print ( min ( s1 , s2 ) ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from collections import deque , defaultdict <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> ref = defaultdict ( list ) <NEWLINE> q = deque ( [ ] ) <NEWLINE> visited = set ( ) <NEWLINE> inf = 10 ** 10 <NEWLINE> dist = [ - inf ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> ref [ ( a , b ) ] = k <NEWLINE> <NL> <NL> <DEDENT> def dfs ( u ) : <NEWLINE> <INDENT> q . append ( u ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> visited . add ( v ) <NEWLINE> for x in g [ v ] : <NEWLINE> <INDENT> if x not in visited : <NEWLINE> <INDENT> if ref [ ( v , x ) ] != [ ] : <NEWLINE> <INDENT> y = ref . get ( ( v , x ) ) <NEWLINE> if dist [ x ] == - inf : <NEWLINE> <INDENT> dist [ x ] = dist [ v ] + y <NEWLINE> <DEDENT> elif dist [ x ] != dist [ v ] + y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> y = ref . get ( ( x , v ) ) <NEWLINE> if dist [ x ] == - inf : <NEWLINE> <INDENT> dist [ x ] = dist [ v ] - y <NEWLINE> <DEDENT> elif dist [ v ] != dist [ x ] + y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> q . append ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in visited : <NEWLINE> <INDENT> dist [ i ] = 1 <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_dp = [ 0 ] * ( N + 1 ) <NEWLINE> B_dp = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> A_dp [ i ] += A [ i - 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> A_dp [ i ] += A_dp [ i - 1 ] + A [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> B_dp [ j ] += B [ j - 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> B_dp [ j ] += B_dp [ j - 1 ] + B [ j - 1 ] <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A_dp [ i ] > K : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while A_dp [ i ] + B_dp [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> cnt = max ( cnt , i + j ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> N , M , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> array_x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> array_y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if not ( 1 <= N <= 100 and 1 <= M <= 100 ) : sys . exit ( ) <NEWLINE> if not ( - 100 <= X <= 100 and - 100 <= Y <= 100 ) : sys . exit ( ) <NEWLINE> for I in array_x : <NEWLINE> <INDENT> if not ( - 100 <= I <= 100 and array_x . count ( I ) == 1 and I != X ) : sys . exit ( ) <NEWLINE> <DEDENT> for J in array_y : <NEWLINE> <INDENT> if not ( - 100 <= J <= 100 and array_y . count ( J ) == 1 and J != Y ) : sys . exit ( ) <NEWLINE> <NL> <DEDENT> for I in range ( X + 1 , Y + 1 ) : <NEWLINE> <INDENT> if I > max ( array_x ) and I <= min ( array_y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from math import ceil as C , floor as F <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce as R <NEWLINE> <NL> ALP = <STRING> <NEWLINE> alp = <STRING> <NEWLINE> def _X ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> def _S ( ss ) : return tuple ( ss ) if len ( ss ) > 1 else ss [ 0 ] <NEWLINE> def S ( ) : return _S ( _X ( ) ) <NEWLINE> def _Ss ( ss ) : return list ( ss ) if isinstance ( ss , tuple ) else [ ss ] <NEWLINE> def Ss ( ) : return _Ss ( S ( ) ) <NEWLINE> def _I ( ss ) : return tuple ( [ int ( s ) for s in ss ] ) if isinstance ( ss , tuple ) else int ( ss ) <NEWLINE> def I ( ) : return _I ( S ( ) ) <NEWLINE> def _Is ( ss ) : return list ( ss ) if isinstance ( ss , tuple ) else [ ss ] <NEWLINE> def Is ( ) : return _Is ( I ( ) ) <NEWLINE> <NL> N , K = I ( ) <NEWLINE> xs = sorted ( Is ( ) ) <NEWLINE> print ( np . sum ( xs [ : K ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 ] * m for i in range ( n ) ] <NEWLINE> b = [ 0 ] * m <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b [ j ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] += a [ i ] [ j ] * b [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in c : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ceil = lambda x , y : ( x + y - 1 ) // y <NEWLINE> input_list = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> def bfs ( s , n , node , c ) : <NEWLINE> <NL> <INDENT> side_num_arr = list ( map ( lambda x : len ( x ) , node ) ) <NEWLINE> l = max ( side_num_arr ) <NEWLINE> <COMMENT> <NL> queue = [ - 1 for _ in range ( n ) ] <NEWLINE> now = 0 <NEWLINE> queue [ now ] = s <NEWLINE> ans = [ - 1 for _ in range ( n ) ] <NEWLINE> ans [ 0 ] = [ 0 ] <NEWLINE> last_ind = 1 <NEWLINE> while last_ind < n : <NEWLINE> <NL> <INDENT> if now >= n : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> c [ queue [ now ] ] = True <NEWLINE> if side_num_arr [ queue [ now ] ] <= 0 : <NEWLINE> <INDENT> now += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for i in node [ queue [ now ] ] : <NEWLINE> <INDENT> edge = i [ 0 ] <NEWLINE> <NL> ind = i [ 1 ] <NEWLINE> if side_num_arr [ edge ] <= 0 or c [ edge ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> side_num_arr [ edge ] -= 1 <NEWLINE> side_num_arr [ queue [ now ] ] -= 1 <NEWLINE> queue [ last_ind ] = edge <NEWLINE> last_ind += 1 <NEWLINE> c [ edge ] = True <NEWLINE> <NL> ans [ edge ] = queue [ now ] <NEWLINE> <DEDENT> now += 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> n , m = input_list ( ) <NEWLINE> node = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = input_list ( ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> node [ u ] . append ( [ v , i ] ) <NEWLINE> node [ v ] . append ( [ u , i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> c = [ - 1 for _ in range ( n ) ] <NEWLINE> c [ 0 ] = 0 <NEWLINE> ans = bfs ( 0 , n , node , c ) <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for each in ans [ 1 : ] : <NEWLINE> <INDENT> print ( each + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
pi = 3.14159265359 <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif p == 1 or n >= 60 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( int ( p ** ( 1 / n ) ) + 2 ) [ : : - 1 ] : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if a <= N : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> H = [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> AB = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( M ) ] <NEWLINE> <NL> max_h = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for A , B in AB : <NEWLINE> <INDENT> max_h [ A - 1 ] = max ( max_h [ A - 1 ] , H [ B - 1 ] ) <NEWLINE> max_h [ B - 1 ] = max ( max_h [ B - 1 ] , H [ A - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( H [ i ] > max_h [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from scipy . special import comb <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> d = dict ( ) <NEWLINE> for x in a : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( x ) ) <NEWLINE> if s not in d . keys ( ) : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ comb ( i , 2 , exact = True ) for i in d . values ( ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for t in s : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> b = N - r - g <NEWLINE> cnt = r * g * b <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> j = 1 <NEWLINE> while 0 <= i - j and i + j <= N - 1 : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i - j ] != s [ i + j ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> a_acm = list ( accumulate ( a [ : : - 1 ] ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * a_acm [ n - 2 - i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> _3K = 3 * K <NEWLINE> _2K = 2 * K <NEWLINE> G = np . zeros ( ( _2K , _3K ) , dtype = <STRING> ) <COMMENT> <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , c = input ( ) . split ( ) <NEWLINE> x , y = int ( x ) , int ( y ) <NEWLINE> <COMMENT> <NL> if c == <STRING> : <NEWLINE> <INDENT> x = x % _2K <NEWLINE> y = y % _2K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( x + K ) % _2K <NEWLINE> y = y % _2K <NEWLINE> <COMMENT> <NL> <DEDENT> if ( y >= K ) and ( x >= K ) : <NEWLINE> <INDENT> x -= K <NEWLINE> y -= K <NEWLINE> <DEDENT> if ( y >= K ) and ( x < K ) : <NEWLINE> <INDENT> x += K <NEWLINE> y -= K <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> G [ y , x ] += 1 <NEWLINE> G [ y + K , x + K ] += 1 <NEWLINE> G [ y + K , x ] -= 1 <NEWLINE> G [ y , x + K ] -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> G = G . cumsum ( axis = 1 ) . cumsum ( axis = 0 ) <NEWLINE> <COMMENT> <NL> G = G [ : K , : _2K ] + G [ K : _2K , K : _3K ] + np . concatenate ( ( G [ : K , _2K : _3K ] , G [ K : _2K , : K ] ) , axis = 1 ) <NEWLINE> ans = G . max ( ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> pl = [ ] <NEWLINE> sb = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> pl . append ( i + int ( a [ i ] ) + 1 ) <NEWLINE> if i - int ( a [ i ] ) > 0 : <NEWLINE> <INDENT> sb . append ( i - int ( a [ i ] ) + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if len ( sb ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> isb = [ int ( i ) for i in sb ] <NEWLINE> ipl = [ int ( i ) for i in pl ] <NEWLINE> ssb = sorted ( isb ) <NEWLINE> t = min ( ssb ) <NEWLINE> <COMMENT> <NL> tl = [ 0 ] * 2000000 <NEWLINE> for i in ssb : <NEWLINE> <INDENT> if int ( i ) - 1 < len ( tl ) : <NEWLINE> <INDENT> tl [ int ( i ) - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in pl : <NEWLINE> <INDENT> if int ( i ) - 1 < len ( tl ) : <NEWLINE> <INDENT> cnt += tl [ int ( i ) - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> answer = 0 <NEWLINE> R = np . zeros ( N , int ) <NEWLINE> G = np . zeros ( N , int ) <NEWLINE> B = np . zeros ( N , int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R [ i ] = 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G [ i ] = 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> B [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> R = np . cumsum ( R ) <NEWLINE> G = np . cumsum ( G ) <NEWLINE> B = np . cumsum ( B ) <NEWLINE> RR = R [ - 1 ] <NEWLINE> GG = G [ - 1 ] <NEWLINE> BB = B [ - 1 ] <NEWLINE> <NL> if N > 3 : <NEWLINE> <INDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a = G [ i ] <NEWLINE> b = BB - B [ i ] <NEWLINE> c = B [ i ] <NEWLINE> d = GG - G [ i ] <NEWLINE> answer += a * b + c * d <NEWLINE> for j in range ( 1 , min ( i + 1 , N - i ) ) : <NEWLINE> <INDENT> if S [ i - j ] != <STRING> and S [ i + j ] != <STRING> and S [ i - j ] != S [ i + j ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> a = B [ i ] <NEWLINE> b = RR - R [ i ] <NEWLINE> c = R [ i ] <NEWLINE> d = BB - B [ i ] <NEWLINE> answer += a * b + c * d <NEWLINE> for j in range ( 1 , min ( i + 1 , N - i ) ) : <NEWLINE> <INDENT> if S [ i - j ] != <STRING> and S [ i + j ] != <STRING> and S [ i - j ] != S [ i + j ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> a = R [ i ] <NEWLINE> b = GG - G [ i ] <NEWLINE> c = G [ i ] <NEWLINE> d = RR - R [ i ] <NEWLINE> answer += a * b + c * d <NEWLINE> for j in range ( 1 , min ( i + 1 , N - i ) ) : <NEWLINE> <INDENT> if S [ i - j ] != <STRING> and S [ i + j ] != <STRING> and S [ i - j ] != S [ i + j ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N , C = map ( int , input ( ) . split ( ) ) <NEWLINE> tv = [ [ 0 ] * C for _ in range ( 100000 ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s , t , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( s - 1 , t ) : tv [ i ] [ c - 1 ] = 1 <NEWLINE> <DEDENT> print ( max ( [ sum ( tv [ i ] ) for i in range ( 100000 ) ] ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> <NL> @ jit ( <STRING> ) <NEWLINE> def myfunc ( n , k , A ) : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> l = np . zeros ( ( n + 1 , ) , dtype = np . int64 ) <NEWLINE> for i , a in enumerate ( A [ : - 1 ] ) : <NEWLINE> <INDENT> l [ max ( 0 , i - a ) ] += 1 <NEWLINE> l [ min ( n , i + a + 1 ) ] -= 1 <NEWLINE> <DEDENT> A = np . cumsum ( l ) <NEWLINE> if np . all ( A [ : - 1 ] == n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> A = np . append ( A , 0 ) <NEWLINE> print ( * myfunc ( n , k , A ) [ : - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> sw = 0 <NEWLINE> import collections <NEWLINE> c = collections . Counter ( a ) <NEWLINE> if c [ 0 ] != 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> i = 0 <NEWLINE> j = len ( s ) - 1 <NEWLINE> ans = 0 <NEWLINE> while i < j : <NEWLINE> <INDENT> while s [ i ] == s [ j ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> j -= 1 <NEWLINE> if i > j : break <NEWLINE> <DEDENT> if i > j : break <NEWLINE> while s [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> ans += 1 <NEWLINE> if i > j : break <NEWLINE> <DEDENT> if i > j : break <NEWLINE> while s [ j ] == <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> ans += 1 <NEWLINE> if i > j : break <NEWLINE> <DEDENT> if i > j : break <NEWLINE> if s [ i ] != s [ j ] : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> j -= 1 <NEWLINE> if i > j : break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> p = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( p , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = list ( input ( ) ) <NEWLINE> a += b <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b = list ( input ( ) ) <NEWLINE> c += b <NEWLINE> <COMMENT> <NL> <DEDENT> f = False <NEWLINE> for i in range ( N * N ) : <NEWLINE> <INDENT> if f == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N * N - i < M * M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if M > 1 and i // N == N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> flag = True <NEWLINE> <COMMENT> <NL> if c [ 0 ] == a [ i ] : <NEWLINE> <INDENT> if N - ( ( i ) % N ) < M : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num = i <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> for k in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> if c [ count ] == a [ num ] : <NEWLINE> <NL> <INDENT> num += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> elif c [ count ] != a [ num ] : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> num += N - M <NEWLINE> if flag == False : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> if j == M - 1 : <NEWLINE> <INDENT> f = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if f == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> j = M <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while K - a [ i ] < b [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for a in range ( 1001 ) : <NEWLINE> <INDENT> for b in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> ans = [ a , b ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> MMM = map ( int , input ( ) . split ( ) ) <NEWLINE> MM = list ( MMM ) <NEWLINE> mini = 2020202020 <NEWLINE> list1 = [ ] <NEWLINE> total = 0 <NEWLINE> for i in MM : <NEWLINE> <INDENT> total += i <NEWLINE> list1 . append ( total ) <NEWLINE> <DEDENT> for i in list1 : <NEWLINE> <INDENT> x = abs ( total - 2 * i ) <NEWLINE> if mini > x : <NEWLINE> <INDENT> mini = x <NEWLINE> <DEDENT> <DEDENT> print ( mini ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> def diffs ( n ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for k in range ( 1 , n ) : <NEWLINE> <INDENT> for l in range ( k + 1 , n ) : <NEWLINE> <INDENT> total += math . gcd ( n , math . gcd ( k , l ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> for k in range ( 1 , n ) : <NEWLINE> <INDENT> total += math . gcd ( n , k ) * 6 <NEWLINE> <DEDENT> total += n <NEWLINE> return total <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum += diffs ( i ) <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> index = 0 <NEWLINE> minL = [ ] <NEWLINE> moneyL = [ ] <NEWLINE> while index < n : <NEWLINE> <INDENT> inputN = int ( input ( ) ) <NEWLINE> moneyL . append ( inputN ) <NEWLINE> if index == 0 : <NEWLINE> <INDENT> minL . append ( inputN ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if minL [ index - 1 ] < inputN : <NEWLINE> <INDENT> minL . append ( minL [ index - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minL . append ( inputN ) <NEWLINE> <DEDENT> <DEDENT> index += 1 <NEWLINE> <NL> <DEDENT> index2 = 1 <NEWLINE> maxProfit = - 10 ** 9 <NEWLINE> while index2 < len ( moneyL ) : <NEWLINE> <INDENT> if moneyL [ index2 ] - minL [ index2 - 1 ] > maxProfit : <NEWLINE> <INDENT> maxProfit = moneyL [ index2 ] - minL [ index2 - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> index2 += 1 <NEWLINE> <NL> <DEDENT> print ( maxProfit ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> t = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> t = t * a [ i ] <NEWLINE> if t > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( r * r * math . pi , 2 * r * math . pi ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> num_A = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> first = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> num_A [ a ] += 1 <NEWLINE> first += a <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> first += c * num_A [ b ] <NEWLINE> first -= b * num_A [ b ] <NEWLINE> num_A [ c ] += num_A [ b ] <NEWLINE> num_A [ b ] = 0 <NEWLINE> print ( first ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> L = [ 0 ] * ( 10 ** 5 ) <NEWLINE> S = sum ( A ) <NEWLINE> for i in A : L [ i - 1 ] += 1 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) ; B -= 1 ; C -= 1 <NEWLINE> S += ( ( C + 1 ) - ( B + 1 ) ) * L [ B ] <NEWLINE> L [ C ] += L [ B ] ; L [ B ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
lst = input ( ) . split ( ) <NEWLINE> A = int ( lst [ 0 ] ) <NEWLINE> B = int ( lst [ 1 ] ) <NEWLINE> K = int ( lst [ 2 ] ) <NEWLINE> <NL> if ( B - A + 1 ) <= 2 * K : <NEWLINE> <INDENT> for n in list ( range ( A , B + 1 ) ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for n in list ( range ( A , A + K ) ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> for n in list ( range ( B - K + 1 , B + 1 ) ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> X , Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( X + Y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( ( 2 * X - Y ) // 3 ) <NEWLINE> m = int ( ( 2 * Y - X ) // 3 ) <NEWLINE> <NL> if n < 0 or m < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> c *= n - i <NEWLINE> c %= MOD <NEWLINE> <DEDENT> d = 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d *= i <NEWLINE> d %= MOD <NEWLINE> <DEDENT> return ( c * pow ( d , MOD - 2 , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> result = comb ( n + m , n ) <NEWLINE> print ( result ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = n <NEWLINE> if n >= b - 1 : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <NL> <DEDENT> ans = ( a * ( x % b ) ) // b <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ 0 ] * n <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> res [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , 1000000007 ) ) <NEWLINE>
s = [ int ( i ) for i in list ( input ( ) ) ] <NEWLINE> <NL> print ( 2 * min ( s . count ( 1 ) , s . count ( 0 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sm = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sm += i * ( n // i ) * ( n // i + 1 ) // 2 <NEWLINE> <DEDENT> print ( sm ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> and s [ i + 2 ] == <STRING> : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> prime = 0 <NEWLINE> <NL> def is_prime ( q ) : <NEWLINE> <INDENT> if q == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if q < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return pow ( 2 , q - 1 , q ) == 1 <NEWLINE> <NL> <NL> <DEDENT> prime = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if is_prime ( m ) : <NEWLINE> <INDENT> prime += 1 <NEWLINE> <DEDENT> <DEDENT> print ( prime ) <NEWLINE>
def euclidean_alg ( x , y ) : <NEWLINE> <INDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> XY = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = max ( XY ) <NEWLINE> y = min ( XY ) <NEWLINE> <NL> print ( euclidean_alg ( x , y ) ) <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for num in a : <NEWLINE> <INDENT> total *= num <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
from collections import Counter <NEWLINE> S = list ( reversed ( input ( ) ) ) <NEWLINE> l = len ( S ) <NEWLINE> N = 0 <NEWLINE> counts = Counter ( [ ( N : = N + ( pow ( 10 , i , 2019 ) * int ( S [ i ] ) ) % 2019 ) % 2019 for i in range ( l ) ] + [ 0 ] ) <NEWLINE> print ( sum ( n * ( n - 1 ) // 2 for n in counts . values ( ) ) ) <NEWLINE>
from math import sqrt <NEWLINE> q3 = sqrt ( 3 ) <NEWLINE> fmt = <STRING> <NEWLINE> def koch ( x0 , y0 , x1 , y1 , c ) : <NEWLINE> <INDENT> if c == n : <NEWLINE> <INDENT> return ( fmt % ( x0 , y0 ) , ) <NEWLINE> <DEDENT> xp = ( x0 * 2 + x1 ) / 3 <NEWLINE> yp = ( y0 * 2 + y1 ) / 3 <NEWLINE> <NL> xq = ( x0 + x1 * 2 ) / 3 <NEWLINE> yq = ( y0 + y1 * 2 ) / 3 <NEWLINE> <NL> dx = ( x1 - x0 ) / 6 <NEWLINE> dy = ( y1 - y0 ) / 6 <NEWLINE> <NL> xr = xp + ( dx - dy * q3 ) <NEWLINE> yr = yp + ( dx * q3 + dy ) <NEWLINE> <NL> return koch ( x0 , y0 , xp , yp , c + 1 ) + koch ( xp , yp , xr , yr , c + 1 ) + koch ( xr , yr , xq , yq , c + 1 ) + koch ( xq , yq , x1 , y1 , c + 1 ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( * koch ( 0 , 0 , 100 , 0 , 0 ) + ( fmt % ( 100 , 0 ) , ) , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> n , k = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> score = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( i + 1 ) > k : <NEWLINE> <COMMENT> <NL> <INDENT> if arr [ i ] > arr [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <NEWLINE> ddn = [ ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , k = LI ( ) <NEWLINE> d = LI_ ( ) <NEWLINE> v = [ LI_ ( ) for _ in range ( n ) ] <NEWLINE> dd = collections . defaultdict ( lambda : None ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> dd [ d [ i ] ] = i <NEWLINE> <DEDENT> vv = [ ] <NEWLINE> for c in d : <NEWLINE> <INDENT> vv . append ( [ dd [ v [ c ] [ i ] ] for i in range ( k ) ] ) <NEWLINE> <DEDENT> vvv = [ [ vv [ i ] [ j ] for i in range ( m ) ] for j in range ( k ) ] <NEWLINE> u = set ( ) <NEWLINE> m2 = 2 ** m <NEWLINE> u . add ( m2 - 1 ) <NEWLINE> q = [ ( m2 - 1 , 1 ) ] <NEWLINE> ii = [ 2 ** _ for _ in range ( m ) ] <NEWLINE> <COMMENT> <NL> while q : <NEWLINE> <INDENT> qd , qk = q . pop ( 0 ) <NEWLINE> <COMMENT> <NL> qdi = [ di for di in range ( m ) if qd & ii [ di ] ] <NEWLINE> for vi in range ( k ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> vvi = vvv [ vi ] <NEWLINE> for di in qdi : <NEWLINE> <INDENT> if not vvi [ di ] is None : <NEWLINE> <INDENT> t |= ii [ vvi [ di ] ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if t in u : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if t == 0 : <NEWLINE> <INDENT> return qk <NEWLINE> <DEDENT> u . add ( t ) <NEWLINE> q . append ( ( t , qk + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if A [ i + k ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> import math <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> value = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( value , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <COMMENT> <NL>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> A = [ ] <NEWLINE> <NL> while ( N != 0 ) : <NEWLINE> <INDENT> c , d = divmod ( N - 1 , 26 ) <NEWLINE> A . append ( chr ( d + 97 ) ) <NEWLINE> <COMMENT> <NL> N = c <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> A . reverse ( ) <NEWLINE> print ( <STRING> . join ( A ) ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> t = 0 <NEWLINE> for x in lst : <NEWLINE> <INDENT> s += x <NEWLINE> t += ( x ** 2 ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> w = ( s ** 2 - t ) % ( 10 ** 9 + 7 ) <NEWLINE> if w % 2 == 0 : <NEWLINE> <INDENT> print ( w // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( w + 10 ** 9 + 7 ) // 2 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = [ - 1 for j in range ( N ) ] <NEWLINE> X [ 0 ] = 0 <NEWLINE> Y = [ 0 ] <NEWLINE> i = 0 <NEWLINE> Num = 0 <NEWLINE> MM = 0 <NEWLINE> for k in range ( 1 , N ) : <NEWLINE> <INDENT> i = A [ i ] - 1 <NEWLINE> if k == K : <NEWLINE> <INDENT> MM = 1 <NEWLINE> P = i <NEWLINE> break <NEWLINE> <DEDENT> elif X [ i ] != - 1 : <NEWLINE> <INDENT> Num = X [ i ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ i ] = k <NEWLINE> Y . append ( i ) <NEWLINE> <DEDENT> <DEDENT> Y = Y [ Num : ] <NEWLINE> B = ( K - Num ) % len ( Y ) <NEWLINE> if MM == 1 : <NEWLINE> <INDENT> print ( P + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Y [ B ] + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> from numba import njit <NEWLINE> @ njit ( cache = True ) <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> for _ in range ( K ) : <NEWLINE> <INDENT> B = np . zeros ( N , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = max ( 0 , i - A [ i ] ) <NEWLINE> r = min ( N - 1 , i + A [ i ] ) <NEWLINE> B [ l ] += 1 <NEWLINE> if N > r + 1 : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> A = np . cumsum ( B ) <NEWLINE> if np . all ( A == N ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> A = solve ( N , K , A ) <NEWLINE> print ( * A ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> m = { } <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i , v in enumerate ( a ) : <NEWLINE> <INDENT> p = i + v <NEWLINE> <NL> if not p in m : <NEWLINE> <INDENT> m [ p ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i , v in enumerate ( a ) : <NEWLINE> <INDENT> p = i - v <NEWLINE> <NL> if p in m : <NEWLINE> <INDENT> count += m [ p ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( set ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> ans += a [ i ] - a [ i - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] and n != 1 : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> for i in range ( 2 , N * 2 + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> primes = factorization ( M ) <NEWLINE> <COMMENT> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <NL> for p , cnt in primes : <NEWLINE> <INDENT> tmp = cmb ( N + cnt - 1 , N - 1 , mod ) <NEWLINE> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> g = [ 0 ] * n <NEWLINE> cb = 0 <NEWLINE> cg = 0 <NEWLINE> cr = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cr += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> cg += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cb += 1 <NEWLINE> <DEDENT> r [ i ] = cr <NEWLINE> g [ i ] = cg <NEWLINE> b [ i ] = cb <NEWLINE> <NL> <DEDENT> fr = [ 0 ] * n <NEWLINE> fb = [ 0 ] * n <NEWLINE> fg = [ 0 ] * n <NEWLINE> cb = 0 <NEWLINE> cg = 0 <NEWLINE> cr = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cr += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> cg += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cb += 1 <NEWLINE> <DEDENT> fr [ i ] = cr <NEWLINE> fg [ i ] = cg <NEWLINE> fb [ i ] = cb <NEWLINE> <NL> <DEDENT> p = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> p += fg [ i - 1 ] * r [ i + 1 ] + fr [ i - 1 ] * g [ i + 1 ] <NEWLINE> j = i - 1 <NEWLINE> k = i + 1 <NEWLINE> while ( j > - 1 and k < n ) : <NEWLINE> <INDENT> if ( s [ j ] == <STRING> and s [ k ] == <STRING> or s [ j ] == <STRING> and s [ k ] == <STRING> ) : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> j -= 1 <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> p += fb [ i - 1 ] * r [ i + 1 ] + fr [ i - 1 ] * b [ i + 1 ] <NEWLINE> j = i - 1 <NEWLINE> k = i + 1 <NEWLINE> while ( j > - 1 and k < n ) : <NEWLINE> <INDENT> if ( s [ j ] == <STRING> and s [ k ] == <STRING> or s [ j ] == <STRING> and s [ k ] == <STRING> ) : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> j -= 1 <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> p += fb [ i - 1 ] * g [ i + 1 ] + fg [ i - 1 ] * b [ i + 1 ] <NEWLINE> j = i - 1 <NEWLINE> k = i + 1 <NEWLINE> while ( j > - 1 and k < n ) : <NEWLINE> <INDENT> if ( s [ j ] == <STRING> and s [ k ] == <STRING> or s [ j ] == <STRING> and s [ k ] == <STRING> ) : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> j -= 1 <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n , m = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> M = [ set ( ) for j in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> M [ u ] . add ( v ) <NEWLINE> M [ v ] . add ( u ) <NEWLINE> <NL> <DEDENT> color = [ 0 ] * n <NEWLINE> def dfs ( u , c ) : <COMMENT> <NEWLINE> <INDENT> color [ u ] = c <NEWLINE> for v in M [ u ] : <NEWLINE> <INDENT> if color [ v ] == 0 : <NEWLINE> <INDENT> dfs ( v , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> c = 1 <NEWLINE> for u in range ( n ) : <NEWLINE> <INDENT> if color [ u ] == 0 : <NEWLINE> <INDENT> dfs ( u , c ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> l = int ( input ( ) ) <NEWLINE> for _ in range ( l ) : <NEWLINE> <INDENT> p , q = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> if color [ p ] == color [ q ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> r1 = a <NEWLINE> r2 = c <NEWLINE> while r1 > 0 and r2 > 0 : <NEWLINE> <INDENT> r2 -= b <NEWLINE> r1 -= d <NEWLINE> <DEDENT> if r2 <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ 0 ] <NEWLINE> tmp = 0 <NEWLINE> <NL> tf = [ - 1 for i in range ( n ) ] <NEWLINE> tf [ 0 ] = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = a [ tmp ] - 1 <NEWLINE> if tf [ tmp ] != - 1 : <NEWLINE> <INDENT> start = tmp <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( tmp ) <NEWLINE> tf [ tmp ] = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> lenret = i + 1 <NEWLINE> stridx = tf [ start ] <NEWLINE> <NL> cycle = lenret - stridx <NEWLINE> <NL> if stridx >= k : <NEWLINE> <INDENT> print ( res [ k ] + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - stridx <NEWLINE> <NL> tmp = k % cycle <NEWLINE> <NL> print ( res [ stridx + tmp ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= a [ i + 1 ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def comb ( n , m , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> numerator = 1 <NEWLINE> denominator = 1 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> numerator = numerator * ( n - i + 1 ) % mod <NEWLINE> denominator = denominator * i % mod <NEWLINE> <DEDENT> d_inv = pow ( denominator , mod - 2 , mod ) <NEWLINE> return numerator * d_inv % mod <NEWLINE> <NL> <DEDENT> cmb_n_a = comb ( n , a ) <NEWLINE> cmb_n_b = comb ( n , b ) <NEWLINE> <NL> print ( ( pow ( 2 , n , mod ) - 1 - cmb_n_a - cmb_n_b ) % mod ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m , q = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> tmp = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> tmp . append ( [ a , b , c , d ] ) <NEWLINE> <NL> <DEDENT> t = list ( itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <NL> score = 0 <NEWLINE> for _t in t : <NEWLINE> <INDENT> _s = 0 <NEWLINE> for a , b , c , d in tmp : <NEWLINE> <INDENT> if c == _t [ b - 1 ] - _t [ a - 1 ] : <NEWLINE> <INDENT> _s += d <NEWLINE> <DEDENT> <DEDENT> score = max ( _s , score ) <NEWLINE> <DEDENT> print ( score ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import heapq <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( lambda x : - int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <COMMENT> <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> value_min = heapq . heappop ( A ) <NEWLINE> heapq . heappush ( A , ( - 1 ) * ( - value_min // 2 ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( - sum ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> x = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] * x <NEWLINE> x += a [ i ] % m <NEWLINE> ans %= m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> pi = 3.14159265358979 <NEWLINE> <NL> l = 2 * pi * r <NEWLINE> s = pi * r ** 2 <NEWLINE> <NL> print ( <STRING> . format ( s , l ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> print ( <STRING> if A [ i ] < A [ i + K ] else <STRING> ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L , R = A [ left : left + n1 ] , A [ mid : mid + n2 ] <NEWLINE> <NL> L . append ( 2000000000 ) <NEWLINE> R . append ( 2000000000 ) <NEWLINE> <NL> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> global count <NEWLINE> count += 1 <NEWLINE> <COMMENT> <NL> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <COMMENT> <NL> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> input_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> mergeSort ( input_list , 0 , n ) <NEWLINE> <NL> print ( * input_list ) <NEWLINE> print ( count ) <NEWLINE> <NL> <NL>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> print ( a * n // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * ( b - 1 ) // b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> import sys <NEWLINE> S = set ( sys . stdin . readlines ( ) ) <NEWLINE> <NL> <NL> <NL> print ( len ( S ) ) <NEWLINE>
from collections import Counter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import groupby <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bbb = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> idx_a = { } <NEWLINE> cnt_a = { } <NEWLINE> i = 0 <NEWLINE> for a , itr in groupby ( aaa ) : <NEWLINE> <INDENT> cnt = len ( list ( itr ) ) <NEWLINE> idx_a [ a ] = i <NEWLINE> cnt_a [ a ] = cnt <NEWLINE> i += cnt <NEWLINE> <NL> <DEDENT> cnt_b = Counter ( bbb ) <NEWLINE> hq_both = [ ] <NEWLINE> hq_free = [ ] <NEWLINE> for a , ca in cnt_a . items ( ) : <NEWLINE> <INDENT> if a in cnt_b : <NEWLINE> <INDENT> hq_both . append ( ( - ( ca + cnt_b [ a ] ) , a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hq_free . append ( a ) <NEWLINE> <DEDENT> <DEDENT> heapify ( hq_both ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ans = [ - 1 ] * n <NEWLINE> remaining = n <NEWLINE> <NL> while hq_both : <NEWLINE> <INDENT> cab , a1 = heappop ( hq_both ) <NEWLINE> cab = - cab <NEWLINE> assert cab == cnt_a [ a1 ] + cnt_b [ a1 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> if cab > remaining : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cb = cnt_b [ a1 ] <NEWLINE> while cb : <NEWLINE> <INDENT> if hq_both : <NEWLINE> <INDENT> _ , a2 = heappop ( hq_both ) <NEWLINE> pop_from_que = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a2 = hq_free . pop ( ) <NEWLINE> pop_from_que = False <NEWLINE> <DEDENT> ca = cnt_a [ a2 ] <NEWLINE> <COMMENT> <NL> if ca <= cb : <NEWLINE> <INDENT> l = idx_a [ a2 ] <NEWLINE> ans [ l : l + ca ] = [ a1 ] * ca <NEWLINE> remaining -= ca <NEWLINE> idx_a [ a2 ] += ca <NEWLINE> cnt_a [ a2 ] -= ca <NEWLINE> cnt_b [ a1 ] -= ca <NEWLINE> cb -= ca <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = idx_a [ a2 ] <NEWLINE> ans [ l : l + cb ] = [ a1 ] * cb <NEWLINE> remaining -= cb <NEWLINE> idx_a [ a2 ] += cb <NEWLINE> cnt_a [ a2 ] -= cb <NEWLINE> cnt_b [ a1 ] -= cb <NEWLINE> cb = 0 <NEWLINE> if pop_from_que : <NEWLINE> <INDENT> heappush ( hq_both , ( - ( cnt_a [ a2 ] + cnt_b [ a2 ] ) , a2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hq_free . append ( a2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> hq_free . append ( a1 ) <NEWLINE> <NL> <DEDENT> for b , cb in cnt_b . items ( ) : <NEWLINE> <INDENT> if cb == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while cb : <NEWLINE> <INDENT> a = hq_free . pop ( ) <NEWLINE> ca = cnt_a [ a ] <NEWLINE> if ca <= cb : <NEWLINE> <INDENT> l = idx_a [ a ] <NEWLINE> ans [ l : l + ca ] = [ b ] * ca <NEWLINE> cb -= ca <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = idx_a [ a ] <NEWLINE> ans [ l : l + cb ] = [ b ] * cb <NEWLINE> idx_a [ a ] += cb <NEWLINE> cnt_a [ a ] -= cb <NEWLINE> cb = 0 <NEWLINE> hq_free . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_cnt = [ 0 for i in range ( h ) ] <NEWLINE> w_cnt = [ 0 for i in range ( w ) ] <NEWLINE> bomb = set ( ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> _h , _w = map ( int , input ( ) . split ( ) ) <NEWLINE> h_cnt [ _h - 1 ] += 1 <NEWLINE> w_cnt [ _w - 1 ] += 1 <NEWLINE> bomb . add ( ( ( _h - 1 ) , ( _w - 1 ) ) ) <NEWLINE> <NL> <DEDENT> h_max = max ( h_cnt ) <NEWLINE> w_max = max ( w_cnt ) <NEWLINE> <NL> max_h = [ ] <NEWLINE> max_w = [ ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> if h_cnt [ i ] == h_max : <NEWLINE> <INDENT> max_h . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if w_cnt [ j ] == w_max : <NEWLINE> <INDENT> max_w . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = True <NEWLINE> <NL> for i in max_h : <NEWLINE> <INDENT> for j in max_w : <NEWLINE> <INDENT> if ( i , j ) not in bomb : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max - 1 if flag else h_max + w_max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = j - i + j <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import queue <NEWLINE> <NL> n , quantum = map ( int , input ( ) . split ( ) ) <NEWLINE> q = queue . Queue ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> q . put ( [ name , int ( time ) ] ) <NEWLINE> <NL> <DEDENT> spend_time = 0 <NEWLINE> while q . qsize ( ) > 0 : <NEWLINE> <INDENT> name , time = q . get ( ) <NEWLINE> tmp = min ( quantum , time ) <NEWLINE> spend_time += tmp <NEWLINE> time -= tmp <NEWLINE> if time == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( name , spend_time ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . put ( [ name , time ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t = N // i <NEWLINE> count += i * t * ( t + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( count ) ) <NEWLINE>
from collections import Counter as C <NEWLINE> n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ int ( input ( ) ) for i in range ( q ) ] <NEWLINE> <COMMENT> <NL> d = C ( a ) <NEWLINE> len = len ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if k - ( len - d [ i ] ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> if k - len ( a ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> S = v ( ) <NEWLINE> T = v ( ) <NEWLINE> len_s = len ( S ) <NEWLINE> len_t = len ( T ) <NEWLINE> check = False <NEWLINE> ans = [ ] <NEWLINE> <NL> if len_s < len_t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len_s ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt >= len_t : <NEWLINE> <INDENT> aaa = S . replace ( <STRING> , <STRING> ) <NEWLINE> ans . append ( aaa [ : i - len_t + 1 ] + T + aaa [ i + 1 : ] ) <NEWLINE> <DEDENT> <DEDENT> elif S [ i ] in T : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> place = T . index ( S [ i ] ) <NEWLINE> if len_s < len_t + i - place : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( i - place , len_t + i - place ) : <NEWLINE> <INDENT> if T [ j - ( i - place ) ] == S [ j ] or S [ j ] == <STRING> : <NEWLINE> <INDENT> check = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> aaa = S . replace ( <STRING> , <STRING> ) <NEWLINE> ans . append ( aaa [ : i - place ] + T + aaa [ len_t + i - place : ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> ans . sort ( ) <NEWLINE> print ( ans [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> nf = lambda : float ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nb = lambda : list ( map ( float , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> X , N = na ( ) <NEWLINE> p = na ( ) <NEWLINE> kouho = [ ] <NEWLINE> for i in range ( - 100 , 200 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> kouho . append ( ( abs ( X - i ) , i ) ) <NEWLINE> <DEDENT> print ( min ( kouho ) [ 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> DP = { } <NEWLINE> mod = 998244353 <NEWLINE> product = { } <NEWLINE> N = 1000001 <NEWLINE> <NL> <COMMENT> <NL> factorialNumInverse = [ None ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> naturalNumInverse = [ None ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> fact = [ None ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> def InverseofNumber ( p ) : <NEWLINE> <INDENT> naturalNumInverse [ 0 ] = naturalNumInverse [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 , 1 ) : <NEWLINE> <INDENT> naturalNumInverse [ i ] = ( naturalNumInverse [ p % i ] * <NEWLINE> <INDENT> ( p - int ( p / i ) ) % p ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def InverseofFactorial ( p ) : <NEWLINE> <INDENT> factorialNumInverse [ 0 ] = factorialNumInverse [ 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , N + 1 , 1 ) : <NEWLINE> <INDENT> factorialNumInverse [ i ] = ( naturalNumInverse [ i ] * <NEWLINE> <INDENT> factorialNumInverse [ i - 1 ] ) % p <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def factorial ( p ) : <NEWLINE> <INDENT> fact [ 0 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> fact [ i ] = ( fact [ i - 1 ] * i ) % p <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def Binomial ( N , R , p ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> ans = ( ( fact [ N ] * factorialNumInverse [ R ] ) % p * <NEWLINE> <INDENT> factorialNumInverse [ N - R ] ) % p <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def getproduct ( M , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> global mod , product <NEWLINE> fact = 1000 <NEWLINE> if n - 1 in product : <NEWLINE> <INDENT> product [ n ] = ( M * product [ n - 1 ] ) % mod <NEWLINE> return ( M * product [ n - 1 ] ) % mod <NEWLINE> <DEDENT> if n < fact : <NEWLINE> <INDENT> return ( M ** n ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Q = int ( n / fact ) <NEWLINE> R = n % fact <NEWLINE> prev = 1 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> prev = ( prev * ( ( M ** fact ) % mod ) ) % mod <NEWLINE> <DEDENT> prev = prev * ( ( M ** R ) % mod ) <NEWLINE> product [ n ] = prev % mod <NEWLINE> return prev % mod <NEWLINE> <DEDENT> <DEDENT> def ncr ( n , r , p ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num = den = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> num = ( num * ( n - i ) ) % p <NEWLINE> den = ( den * ( i + 1 ) ) % p <NEWLINE> <DEDENT> return ( num * pow ( den , <NEWLINE> <INDENT> p - 2 , p ) ) % p <NEWLINE> <NL> <DEDENT> <DEDENT> def G ( N , M , K ) : <NEWLINE> <INDENT> global mod <NEWLINE> res = 0 <NEWLINE> for k in range ( K , - 1 , - 1 ) : <NEWLINE> <INDENT> res = ( res + ( ( Binomial ( N - 1 , k , mod ) ) % mod * ( M * getproduct ( M - 1 , N - k - 1 ) ) % mod ) % mod ) % mod <NEWLINE> <DEDENT> return res % mod <NEWLINE> <NL> <DEDENT> def F ( curr , N , M , K ) : <NEWLINE> <INDENT> global DP <NEWLINE> if ( curr , K ) in DP : <NEWLINE> <INDENT> return DP [ ( curr , K ) ] <NEWLINE> <DEDENT> if curr == N : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if curr == 0 : <NEWLINE> <INDENT> return M * F ( curr + 1 , N , M , K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> if K > 0 : <NEWLINE> <INDENT> a = F ( curr + 1 , N , M , K - 1 ) <NEWLINE> <DEDENT> b = ( M - 1 ) * F ( curr + 1 , N , M , K ) <NEWLINE> DP [ ( curr , K ) ] = a + b <NEWLINE> return a + b <NEWLINE> <DEDENT> <DEDENT> N , M , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> InverseofNumber ( mod ) <NEWLINE> InverseofFactorial ( mod ) <NEWLINE> factorial ( mod ) <NEWLINE> <COMMENT> <NL> print ( G ( N , M , K ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 10 ** 9 + 3 <NEWLINE> if y >= x : <NEWLINE> <INDENT> ans = min ( ans , abs ( y - x ) ) <NEWLINE> <DEDENT> if - y >= x : <NEWLINE> <INDENT> ans = min ( ans , abs ( - y - x ) + 1 ) <NEWLINE> <DEDENT> if y >= - x : <NEWLINE> <INDENT> ans = min ( ans , abs ( y + x ) + 1 ) <NEWLINE> <DEDENT> if - y >= - x : <NEWLINE> <INDENT> ans = min ( ans , abs ( - y + x ) + 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def solve ( A , N ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> C = [ 0 ] * 60 <NEWLINE> for a in A : <NEWLINE> <INDENT> for i in range ( 60 ) : <NEWLINE> <INDENT> if a >> i & 1 : <NEWLINE> <INDENT> C [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , c in enumerate ( C ) : <NEWLINE> <INDENT> ans += ( 1 << i ) % mod * c % mod * ( N - c ) % mod <NEWLINE> <DEDENT> return ans % mod <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> numba_config = [ <NEWLINE> <INDENT> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> print ( solve ( A , N ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> o = 0 <NEWLINE> nn = n - 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> o += nn // i <NEWLINE> <DEDENT> print ( o ) <NEWLINE>
import itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> ans = 10 ** 9 <NEWLINE> possible = False <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in itertools . combinations ( c , i ) : <NEWLINE> <INDENT> rikaido = [ 0 ] * m <NEWLINE> kingaku = 0 <NEWLINE> for k in j : <NEWLINE> <INDENT> kingaku += k [ 0 ] <NEWLINE> for num , val in enumerate ( k [ 1 : ] ) : <NEWLINE> <INDENT> rikaido [ num ] += val <NEWLINE> <NL> <DEDENT> <DEDENT> if min ( rikaido ) >= x : <NEWLINE> <INDENT> ans = min ( ans , kingaku ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) if ans == 10 ** 9 else print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def abc172c_tsundoku ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * ( n + 1 ) <NEWLINE> B = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] + a [ i - 1 ] <NEWLINE> if A [ i ] > k : <NEWLINE> <INDENT> n = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> B [ i ] = B [ i - 1 ] + b [ i - 1 ] <NEWLINE> if B [ i ] > k : <NEWLINE> <INDENT> m = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> j = max ( ans - i , 0 ) <NEWLINE> if j > m or A [ i ] + B [ j ] > k : continue <NEWLINE> while j <= m : <NEWLINE> <INDENT> if A [ i ] + B [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> j = min ( m , j ) <NEWLINE> ans = max ( i + j , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> abc172c_tsundoku ( ) <NEWLINE>
def count_j ( arg_ls , th , b_idx , e_idx ) : <NEWLINE> <INDENT> if b_idx - 1 == e_idx : return 0 <NEWLINE> if b_idx == e_idx : return int ( arg_ls [ b_idx ] > th ) <NEWLINE> cent_idx = ( e_idx + 1 - b_idx ) // 2 + b_idx <NEWLINE> cent_j = arg_ls [ cent_idx ] <NEWLINE> if cent_j > th : <NEWLINE> <INDENT> return count_j ( arg_ls , th , b_idx , cent_idx - 1 ) + ( e_idx + 1 - cent_idx ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return count_j ( arg_ls , th , cent_idx , e_idx ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> inp_ls = input ( ) . split ( <STRING> ) <NEWLINE> a_ls = [ int ( e ) for e in inp_ls [ : n ] ] <NEWLINE> <NL> i_dic = { } <NEWLINE> for i , a in enumerate ( a_ls ) : <NEWLINE> <INDENT> val = - a + ( i + 1 ) <NEWLINE> if val not in i_dic : i_dic [ val ] = [ ] <NEWLINE> i_dic [ val ] . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( len ( a_ls ) ) : <NEWLINE> <INDENT> val = a_ls [ i ] + ( i + 1 ) <NEWLINE> cand_ls = i_dic . get ( val , [ ] ) <NEWLINE> result = count_j ( cand_ls , ( i + 1 ) , 0 , len ( cand_ls ) - 1 ) <NEWLINE> cnt += result <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> week = input ( ) <NEWLINE> if week == <STRING> : <NEWLINE> <INDENT> result = 1 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 2 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 3 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 4 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 5 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 6 <NEWLINE> <DEDENT> elif week == <STRING> : <NEWLINE> <INDENT> result = 7 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <NL> p = 0 <NEWLINE> <NL> if n >= k : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> p = a [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> lst = [ - 1 ] * n <NEWLINE> lst [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p = a [ p ] <NEWLINE> if lst [ p ] == - 1 : <NEWLINE> <INDENT> lst [ p ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = i - lst [ p ] <NEWLINE> k -= lst [ p ] <NEWLINE> extra = k % loop <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( extra ) : <NEWLINE> <INDENT> p = a [ p ] <NEWLINE> <DEDENT> print ( p + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> ac = 0 <NEWLINE> p = 0 <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) - 1 <NEWLINE> <NL> if ans [ a ] != - 1 and b == <STRING> : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <DEDENT> if ans [ a ] != - 1 and b == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> p += ans [ a ] <NEWLINE> ans [ a ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac , p ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> s = [ ] <NEWLINE> g = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if 1 == L [ i ] [ 0 ] : <NEWLINE> <INDENT> s . append ( L [ i ] [ 1 ] ) <NEWLINE> <DEDENT> if 1 == L [ i ] [ 1 ] : <NEWLINE> <INDENT> s . append ( L [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if N == L [ i ] [ 0 ] : <NEWLINE> <INDENT> g . append ( L [ i ] [ 1 ] ) <NEWLINE> <DEDENT> if N == L [ i ] [ 1 ] : <NEWLINE> <INDENT> g . append ( L [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if set ( g ) & set ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> D = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S += ( C - B ) * D [ B ] <NEWLINE> print ( S ) <NEWLINE> <NL> D [ C ] += D [ B ] <NEWLINE> D [ B ] = 0 <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> rests = [ 0 ] <NEWLINE> n = 0 <NEWLINE> a = 0 <NEWLINE> m = 1 <NEWLINE> c = defaultdict ( int ) <NEWLINE> c [ 0 ] += 1 <NEWLINE> for i in list ( s ) [ : : - 1 ] : <NEWLINE> <INDENT> n = n + int ( i ) * m <NEWLINE> <NL> c [ n % 2019 ] += 1 <NEWLINE> m = m * 10 % 2019 <NEWLINE> <NL> <DEDENT> for v in c . values ( ) : <NEWLINE> <INDENT> a += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <NL> <NL> <NL> <NL>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> str_list = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> str_list . append ( s [ i : i + j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> str_list = sorted ( list ( set ( str_list ) ) ) <NEWLINE> <COMMENT> <NL> ans = str_list [ K - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prefix_A = [ 0 ] * ( N + 1 ) <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> prefix_A [ i ] = prefix_A [ i - 1 ] + a <NEWLINE> <DEDENT> prefix_B = [ 0 ] * ( M + 1 ) <NEWLINE> for j , b in enumerate ( B , 1 ) : <NEWLINE> <INDENT> prefix_B [ j ] = prefix_B [ j - 1 ] + b <NEWLINE> <NL> <NL> <DEDENT> res = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> cur = prefix_A [ i ] <NEWLINE> if cur == K : <NEWLINE> <INDENT> res = max ( i , res ) <NEWLINE> <DEDENT> elif cur < K : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = M + 1 <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if cur + prefix_B [ mid ] <= K : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> res = max ( res , i + left ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += i * n * ( n + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = str ( input ( ) ) <NEWLINE> ans , m , div = 0 , 0 , [ ] <NEWLINE> for i , j in enumerate ( reversed ( n ) ) : <NEWLINE> <INDENT> m = ( m + int ( j ) * pow ( 10 , i , 2019 ) ) % 2019 <NEWLINE> div . append ( m ) <NEWLINE> <DEDENT> div . append ( 0 ) <NEWLINE> c = collections . Counter ( div ) <NEWLINE> values , counts = zip ( * c . most_common ( ) ) <NEWLINE> for i in range ( 0 , len ( counts ) ) : <NEWLINE> <INDENT> ans += counts [ i ] * ( counts [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
i = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if ( a == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i ) + <STRING> + a ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> prev = [ ] <NEWLINE> next = 0 <NEWLINE> count = 0 <NEWLINE> while ( count < N ) : <NEWLINE> <INDENT> next = int ( A [ next ] ) - 1 <NEWLINE> count += 1 <NEWLINE> if ( next == 1 ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> if i == j == k : <NEWLINE> <INDENT> ans += x <NEWLINE> <DEDENT> elif i != j != k : <NEWLINE> <INDENT> ans += x * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += x * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> card = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> v = card [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and card [ j ] > v : <NEWLINE> <INDENT> card [ j + 1 ] = card [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> card [ j + 1 ] = v <NEWLINE> <COMMENT> <NL> card_str = <STRING> <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> card_str += str ( card [ k ] ) <NEWLINE> card_str += <STRING> <NEWLINE> <NL> <DEDENT> print ( card_str [ : - 1 ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> MODE = 1 <NEWLINE> <NL> <COMMENT> <NL> DIMENSION = 0 <NEWLINE> <NL> <COMMENT> <NL> INT_TYPE = 1 <NEWLINE> <NL> if not ( MODE ) : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> s = f . read ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = sys . stdin . read ( ) <NEWLINE> <NL> <DEDENT> if DIMENSION == 0 : <NEWLINE> <INDENT> if INT_TYPE == 1 : <NEWLINE> <INDENT> s = int ( s ) <NEWLINE> <DEDENT> <DEDENT> elif DIMENSION == 1 : <NEWLINE> <INDENT> if INT_TYPE == 0 : <NEWLINE> <INDENT> s = s . split ( ) <NEWLINE> <DEDENT> elif INT_TYPE == 1 : <NEWLINE> <INDENT> s = [ int ( x ) for x in s . split ( ) ] <NEWLINE> <DEDENT> <DEDENT> elif DIMENSION == 2 : <NEWLINE> <INDENT> if INT_TYPE == 0 : <NEWLINE> <INDENT> s = [ x . split ( ) for x in s . splitlines ( ) ] <NEWLINE> <DEDENT> elif INT_TYPE == 1 : <NEWLINE> <INDENT> s = [ [ int ( y ) for y in x . split ( ) ] for x in s . splitlines ( ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> if s == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> F = factorization ( s ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( len ( F ) ) : <NEWLINE> <INDENT> num = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> F [ i ] [ 1 ] -= num <NEWLINE> if F [ i ] [ 1 ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> m = map ( int , read ( ) . split ( ) ) <NEWLINE> for a , b in zip ( m , m ) : <NEWLINE> <INDENT> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> par = [ 0 ] * ( N + 1 ) <NEWLINE> visited = [ 0 ] * ( N + 1 ) <NEWLINE> root = 1 <NEWLINE> visited [ root ] = 1 <NEWLINE> q = deque ( [ root ] ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for w in G [ v ] : <NEWLINE> <INDENT> if visited [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ w ] = 1 <NEWLINE> par [ w ] = v <NEWLINE> q . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * par [ 2 : ] , sep = <STRING> ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> if j == str ( <STRING> ) : <NEWLINE> <INDENT> b += str ( <STRING> ) <NEWLINE> <DEDENT> elif j == str ( <STRING> ) : <NEWLINE> <INDENT> b += str ( <STRING> ) <NEWLINE> <DEDENT> elif j == str ( <STRING> ) : <NEWLINE> <INDENT> if not b : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del b [ len ( b ) - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
s = input ( ) . strip ( ) <NEWLINE> t = input ( ) . strip ( ) <NEWLINE> <NL> if t in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 10001 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> cnt = i <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ cnt ] != t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> ans = min ( count , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> ans = 0 <NEWLINE> <NL> tmp = pow ( 26 , K , MOD ) <NEWLINE> ans = tmp <NEWLINE> waru = pow ( 26 , - 1 , MOD ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = ( tmp * 25 * waru ) % MOD <NEWLINE> tmp = ( tmp * ( l - 1 + i ) * pow ( i , - 1 , MOD ) ) % MOD <NEWLINE> ans = ( ans + tmp ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
row = [ True ] * 8 <NEWLINE> col = [ True ] * 8 <NEWLINE> dpos = [ True ] * 15 <NEWLINE> dneg = [ True ] * 15 <NEWLINE> <NL> <NL> board = [ [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] for i in range ( 8 ) ] <NEWLINE> <NL> import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> k = int ( file_input . readline ( ) ) <NEWLINE> <NL> for line in file_input : <NEWLINE> <INDENT> r , c = map ( int , line . split ( ) ) <NEWLINE> row [ r ] = <STRING> <NEWLINE> col [ c ] = <STRING> <NEWLINE> dpos [ r + c ] = False <NEWLINE> dneg [ r + ( 7 - c ) ] = False <NEWLINE> board [ r ] [ c ] = <STRING> <NEWLINE> <NL> <DEDENT> def dfs ( i = 0 ) : <NEWLINE> <INDENT> if i == 8 : <NEWLINE> <INDENT> for line in board : <NEWLINE> <INDENT> print ( * line , sep = <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> if row [ i ] == <STRING> : <NEWLINE> <INDENT> dfs ( i + 1 ) <NEWLINE> <DEDENT> elif row [ i ] : <NEWLINE> <INDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> if col [ j ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif col [ j ] and dpos [ i + j ] and dneg [ i + ( 7 - j ) ] : <NEWLINE> <INDENT> row [ i ] = False <NEWLINE> col [ j ] = False <NEWLINE> dpos [ i + j ] = False <NEWLINE> dneg [ i + ( 7 - j ) ] = False <NEWLINE> board [ i ] [ j ] = <STRING> <NEWLINE> dfs ( i + 1 ) <NEWLINE> row [ i ] = True <NEWLINE> col [ j ] = True <NEWLINE> dpos [ i + j ] = True <NEWLINE> dneg [ i + ( 7 - j ) ] = True <NEWLINE> board [ i ] [ j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dfs ( ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> def gcd ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> l = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> h = itertools . combinations_with_replacement ( l , 3 ) <NEWLINE> <NL> result = 0 <NEWLINE> for v in h : <NEWLINE> <INDENT> ans = gcd ( v ) <NEWLINE> i , j , k = zip ( v ) <NEWLINE> if ( i == j ) & ( i == k ) : <NEWLINE> <INDENT> result += ans <NEWLINE> <DEDENT> elif ( ( i == j ) & ( i != k ) ) | ( ( i == k ) & ( i != j ) ) | ( ( j == k ) & ( j != i ) ) : <NEWLINE> <INDENT> result += ( ans * 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += ( ans * 6 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s < 10 ** 9 : <NEWLINE> <NL> <INDENT> if k > 0 : <NEWLINE> <INDENT> aa = [ s ] * k + [ s + 1 ] * ( n - k ) <NEWLINE> <DEDENT> elif k == 0 : <NEWLINE> <INDENT> aa = [ s + 1 ] * n <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> aa = [ s ] * k + [ 1 ] * ( n - k ) <NEWLINE> <NL> <DEDENT> print ( * aa ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : a , b = b , a % b <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a // gcd ( a , b ) * b <NEWLINE> <NL> <DEDENT> input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> b = lcm ( b , i ) <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if <STRING> in x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( int ( eval ( x . replace ( <STRING> , <STRING> ) ) ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> mapping = [ 0 ] * 100001 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> base = sum ( a ) <NEWLINE> for aaa in a : <NEWLINE> <INDENT> mapping [ aaa ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> offset = c - b <NEWLINE> kazu = mapping [ b ] <NEWLINE> base = base + kazu * offset <NEWLINE> mapping [ b ] = 0 <NEWLINE> mapping [ c ] += kazu <NEWLINE> <NL> print ( base ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> m = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x = m [ 2 ] - m [ 0 ] <NEWLINE> y = m [ 3 ] - m [ 1 ] <NEWLINE> print ( math . sqrt ( float ( x * x + y * y ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> R = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <NL> <DEDENT> print ( max ( min ( R ) - max ( L ) + 1 , 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> kake_A = A [ i ] <NEWLINE> kake_B = A [ i + K ] <NEWLINE> if kake_A >= kake_B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def factorize ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) ; exit ( ) <NEWLINE> <NL> <DEDENT> f = factorize ( N ) <NEWLINE> ans = 0 <NEWLINE> for p , i in f : <NEWLINE> <INDENT> j = 0 <NEWLINE> while i > j : <NEWLINE> <INDENT> j += 1 <NEWLINE> i -= j <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( w == 0 ) and ( h == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> num_h = [ 0 ] * ( h + 1 ) <NEWLINE> num_w = [ 0 ] * ( w + 1 ) <NEWLINE> bomb_set = set ( ) <NEWLINE> for hi , wi in bomb : <NEWLINE> <INDENT> num_h [ hi ] += 1 <NEWLINE> num_w [ wi ] += 1 <NEWLINE> bomb_set . add ( ( hi , wi ) ) <NEWLINE> <NL> <DEDENT> max_h = max ( num_h ) <NEWLINE> max_w = max ( num_w ) <NEWLINE> max_hs = [ k for k , v in enumerate ( num_h ) if v == max_h ] <NEWLINE> max_ws = [ k for k , v in enumerate ( num_w ) if v == max_w ] <NEWLINE> <NL> result = max_h + max_w <NEWLINE> for i in max_hs : <NEWLINE> <INDENT> for j in max_ws : <NEWLINE> <INDENT> if ( i , j ) not in bomb_set : <NEWLINE> <INDENT> print ( result ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> <NL> for ab in AB : <NEWLINE> <INDENT> uf . union ( ab [ 0 ] - 1 , ab [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if uf . size ( i ) > ans : <NEWLINE> <INDENT> ans = uf . size ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( a ** 2 for a in A ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> ans = int ( ( sum ( A ) ** 2 ) // 2 ) <NEWLINE> ans %= m <NEWLINE> ans -= int ( sum ( B ) // 2 ) <NEWLINE> ans %= m <NEWLINE> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> count = S <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> count -= i <NEWLINE> ans += count * i <NEWLINE> if ans > 10 ** 9 + 7 : <NEWLINE> <INDENT> ans %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> if 10000 * ( n - i - j ) + 5000 * j + 1000 * i == y : <NEWLINE> <INDENT> print ( n - i - j , j , i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
N , K = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ K + i ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
T = input ( ) <NEWLINE> hatena_count = T . count ( <STRING> ) <NEWLINE> <NL> pattern = <STRING> <NEWLINE> for i in range ( hatena_count ) : <NEWLINE> <INDENT> pattern += <STRING> <NEWLINE> <NL> <DEDENT> max_exponent = T <NEWLINE> for i in range ( hatena_count ) : <NEWLINE> <INDENT> max_exponent = max_exponent . replace ( <STRING> , pattern [ i ] , 1 ) <NEWLINE> <NL> <DEDENT> print ( max_exponent ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ 0 ] * 5000 <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> S_count = Counter ( S ) <NEWLINE> r = S_count [ <STRING> ] <NEWLINE> g = S_count [ <STRING> ] <NEWLINE> b = S_count [ <STRING> ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> if i + 2 * j >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ i + j ] and S [ i + j ] != S [ i + 2 * j ] and S [ i ] != S [ i + 2 * j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] * ( n ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ l [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counts = [ 0 ] * ( 10 ** 6 + 5 ) <NEWLINE> for AA in A : <NEWLINE> <INDENT> counts [ AA ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 10 ** 6 + 5 ) : <NEWLINE> <INDENT> if counts [ i ] > 0 : <NEWLINE> <INDENT> for j in range ( i + i , 10 ** 6 + 5 , i ) : <NEWLINE> <INDENT> counts [ j ] = - 1 <NEWLINE> <DEDENT> <DEDENT> if counts [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from bisect import bisect_right , bisect_left <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = [ i + 1 - A [ i ] for i in range ( N ) ] <NEWLINE> idx = sorted ( range ( N ) , key = lambda k : T [ k ] ) <NEWLINE> T . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> target = A [ i ] + i + 1 <NEWLINE> left = bisect_left ( T , target ) <NEWLINE> if left > N - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if T [ left ] != target : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = bisect_right ( T , target ) <NEWLINE> ans += right - left <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> if K > A : <NEWLINE> <INDENT> sum += A <NEWLINE> K -= A <NEWLINE> if K > B : <NEWLINE> <INDENT> K -= B <NEWLINE> sum -= K <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sum += K <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> S = input ( ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> N = len ( S ) <NEWLINE> MOD = 2019 <NEWLINE> D = defaultdict ( int ) <NEWLINE> res = 0 <NEWLINE> p = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = res + int ( S [ i ] ) * p <NEWLINE> tmp %= MOD <NEWLINE> D [ tmp ] += 1 <NEWLINE> <NL> res = tmp <NEWLINE> p *= 10 <NEWLINE> p %= 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k , v in zip ( D . keys ( ) , D . values ( ) ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans += v <NEWLINE> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> elif v >= 2 : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_li . sort ( ) <NEWLINE> b_li . sort ( ) <NEWLINE> c_li . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in b_li : <NEWLINE> <INDENT> s = bisect . bisect_right ( c_li , i ) <NEWLINE> s_num = n - s <NEWLINE> <NL> t = bisect . bisect_left ( a_li , i ) <NEWLINE> t_num = t <NEWLINE> <NL> ans += s_num * t_num <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( S ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if B <= N : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <NL> <DEDENT> print ( int ( ( A * x ) / B ) - A * int ( x / B ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> field = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> inf = 1e7 <NEWLINE> <NL> dist = [ [ inf ] * w for _ in range ( h ) ] <NEWLINE> dist [ xs ] [ ys ] = 0 <NEWLINE> que = deque ( [ ( xs , ys ) ] ) <NEWLINE> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> while que : <NEWLINE> <INDENT> x , y = que . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx , ny = x , y <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> nx += dx [ i ] <NEWLINE> ny += dy [ i ] <NEWLINE> if nx < 0 or nx >= h or ny < 0 or ny >= w : break <NEWLINE> if field [ nx ] [ ny ] == <STRING> or dist [ nx ] [ ny ] <= dist [ x ] [ y ] : break <NEWLINE> if dist [ nx ] [ ny ] > dist [ x ] [ y ] + 1 : <NEWLINE> <INDENT> dist [ nx ] [ ny ] = dist [ x ] [ y ] + 1 <NEWLINE> que . append ( ( nx , ny ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if dist [ xg ] [ yg ] == inf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ xg ] [ yg ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = A [ 0 ] <NEWLINE> root_set = set ( [ now ] ) <NEWLINE> root_array = [ now ] <NEWLINE> if k <= n : <NEWLINE> <INDENT> for i in range ( k - 1 ) : <NEWLINE> <INDENT> now = A [ now - 1 ] <NEWLINE> root_set . add ( now ) <NEWLINE> root_array . append ( now ) <NEWLINE> <DEDENT> print ( root_array [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> now = A [ now - 1 ] <NEWLINE> if not now in root_set : <NEWLINE> <INDENT> root_set . add ( now ) <NEWLINE> root_array . append ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = root_array . index ( now ) <NEWLINE> f = root_array [ : index ] <NEWLINE> loop = root_array [ index : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> len_f = len ( f ) <NEWLINE> len_loop = len ( loop ) <NEWLINE> print ( loop [ ( k - len_f ) % len_loop - 1 ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> num = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> before = bc [ i ] [ 0 ] <NEWLINE> after = bc [ i ] [ 1 ] <NEWLINE> ans += num [ before ] * ( after - before ) <NEWLINE> num [ after ] += num [ before ] <NEWLINE> num [ before ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> r = [ 0 ] * int ( input ( ) ) <NEWLINE> print ( len ( { input ( ) for _ in r } ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> ii = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import collections <NEWLINE> <NL> c = collections . Counter ( ii ) <NEWLINE> k = list ( c . keys ( ) ) <NEWLINE> <NL> for a in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> print ( c [ a ] ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> max_A = max ( A ) <NEWLINE> count = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> <DEDENT> is_OK = { a : True for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> i = 2 <NEWLINE> if not is_OK [ a ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while a * i < max_A + 1 : <NEWLINE> <INDENT> is_OK [ a * i ] = False <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if count [ a ] == 1 and is_OK [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( 1 , min ( A , B ) + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( list [ len ( list ) - K ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> dic = Counter ( a ) <NEWLINE> S = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> ( b , c ) = l [ i ] <NEWLINE> num = dic [ b ] <NEWLINE> S -= b * num <NEWLINE> dic [ b ] = 0 <NEWLINE> if dic [ c ] == 0 : <NEWLINE> <INDENT> dic [ c ] = num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ c ] += num <NEWLINE> <DEDENT> S += c * num <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> appendix_1 = <STRING> <NEWLINE> appendix_2 = <STRING> <NEWLINE> reverse = 0 <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> q = list ( input ( ) . split ( ) ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> reverse += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if q [ 1 ] == <STRING> and reverse % 2 == 0 : <NEWLINE> <INDENT> appendix_1 += q [ 2 ] <NEWLINE> <DEDENT> elif q [ 1 ] == <STRING> and reverse % 2 == 1 : <NEWLINE> <INDENT> appendix_2 += q [ 2 ] <NEWLINE> <DEDENT> if q [ 1 ] == <STRING> and reverse % 2 == 0 : <NEWLINE> <INDENT> appendix_2 += q [ 2 ] <NEWLINE> <DEDENT> elif q [ 1 ] == <STRING> and reverse % 2 == 1 : <NEWLINE> <INDENT> appendix_1 += q [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if reverse % 2 == 0 : <NEWLINE> <INDENT> print ( appendix_1 [ : : - 1 ] + S + appendix_2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( appendix_2 [ : : - 1 ] + S [ : : - 1 ] + appendix_1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> A , B = sorted ( a , reverse = True ) [ 0 : 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == A : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> <DEDENT>
a1 , b0 , cn1 , d = map ( int , input ( ) . split ( ) ) <NEWLINE> Output = 0 <NEWLINE> <NL> if a1 < d : <NEWLINE> <INDENT> Output = a1 <NEWLINE> if a1 + b0 < d : <NEWLINE> <INDENT> c = d - a1 - b0 <NEWLINE> Output = Output - c <NEWLINE> <DEDENT> elif a1 + b0 >= d : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif a1 >= d : <NEWLINE> <INDENT> Output = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( Output ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> <NL> def search ( moji ) : <NEWLINE> <INDENT> num = len ( moji ) <NEWLINE> setsn = set ( [ ] ) <NEWLINE> for i in range ( len ( s ) - num + 1 ) : <NEWLINE> <INDENT> if s [ i : i + num ] == moji : <NEWLINE> <INDENT> str_ = s [ i : i + num + 1 ] <NEWLINE> if len ( str_ ) == num + 1 : <NEWLINE> <INDENT> setsn . add ( str_ ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sorted_setsn = sorted ( setsn , reverse = True ) <NEWLINE> <NL> return sorted_setsn <NEWLINE> <NL> <NL> <DEDENT> s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> sets1 = set ( [ ] ) <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> sets1 . add ( s [ i ] ) <NEWLINE> <NL> <DEDENT> sorted_sets1 = sorted ( sets1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> dq = deque ( sorted_sets1 ) <NEWLINE> <NL> while ( len ( dq ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> moji = dq . popleft ( ) <NEWLINE> k -= 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( moji ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sorted_setsn = search ( moji ) <NEWLINE> <NL> <COMMENT> <NL> dq . extendleft ( sorted_setsn ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> s1 = <STRING> * w <NEWLINE> s2 = <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print ( s1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ None for _ in range ( M ) ] <NEWLINE> B = [ None for _ in range ( M ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> C = [ None for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if H [ A [ i ] - 1 ] < H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> C [ A [ i ] - 1 ] = <STRING> <NEWLINE> <DEDENT> elif H [ A [ i ] - 1 ] > H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> C [ B [ i ] - 1 ] = <STRING> <NEWLINE> <DEDENT> elif H [ A [ i ] - 1 ] == H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> C [ A [ i ] - 1 ] = <STRING> <NEWLINE> C [ B [ i ] - 1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> c = collections . Counter ( C ) <NEWLINE> cook = c [ <STRING> ] <NEWLINE> ans = N - cook <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a [ 0 ] == a [ 1 ] ) : <NEWLINE> <INDENT> D . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> tf = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if D [ i ] == D [ i + 1 ] == D [ i + 2 ] == 1 : <NEWLINE> <INDENT> tf = 1 <NEWLINE> <DEDENT> <DEDENT> if tf == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> name = [ ] <NEWLINE> time = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = [ i for i in input ( ) . split ( ) ] <NEWLINE> y = int ( y ) <NEWLINE> name . append ( x ) <NEWLINE> time . append ( y ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> time = deque ( time ) <NEWLINE> name = deque ( name ) <NEWLINE> <NL> count = 0 <NEWLINE> time_out = [ ] <NEWLINE> name_out = [ ] <NEWLINE> <NL> while len ( time ) > 0 : <NEWLINE> <INDENT> a = time . popleft ( ) <NEWLINE> b = name . popleft ( ) <NEWLINE> if a > q : <NEWLINE> <INDENT> a -= q <NEWLINE> time . append ( a ) <NEWLINE> name . append ( b ) <NEWLINE> count += q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += a <NEWLINE> time_out . append ( count ) <NEWLINE> name_out . append ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , j in zip ( name_out , time_out ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <NL> <DEDENT>
<NL> import os <NEWLINE> import sys <NEWLINE> from io import BytesIO , IOBase <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> ans = 0 <NEWLINE> k = max ( arr ) <NEWLINE> d = [ 0 ] * ( k + 1 ) <NEWLINE> if arr [ 0 ] == 1 : <NEWLINE> <INDENT> if n > 1 and arr [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d [ arr [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = arr [ i ] <NEWLINE> if d [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( x , k + 1 , x ) : <NEWLINE> <INDENT> d [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> BUFSIZE = 8192 <NEWLINE> <NL> <NL> class FastIO ( IOBase ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> <NL> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _fd = file . fileno ( ) <NEWLINE> self . buffer = BytesIO ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> not in file . mode <NEWLINE> self . write = self . buffer . write if self . writable else None <NEWLINE> <NL> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines = 0 <NEWLINE> return self . buffer . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . newlines = b . count ( <STRING> ) + ( not b ) <NEWLINE> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return self . buffer . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . buffer . getvalue ( ) ) <NEWLINE> self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def write ( * args , end = <STRING> ) : <NEWLINE> <INDENT> for x in args [ : - 1 ] : <NEWLINE> <INDENT> sys . stdout . write ( str ( x ) + <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( str ( args [ - 1 ] ) ) <NEWLINE> sys . stdout . write ( end ) <NEWLINE> <NL> <NL> <DEDENT> def r_array ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <DEDENT> def r_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> tmp_gcd = math . gcd ( i , j ) <NEWLINE> tmp_gcd = math . gcd ( tmp_gcd , k ) <NEWLINE> if i == j == k : <NEWLINE> <INDENT> ans += tmp_gcd <NEWLINE> <DEDENT> elif i == j or i == k or j == k : <NEWLINE> <INDENT> ans += tmp_gcd * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += tmp_gcd * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Adic = { } <NEWLINE> for i in A : <NEWLINE> <INDENT> if Adic . get ( i ) == None : <NEWLINE> <INDENT> Adic [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Adic [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> ope = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> ope . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> A = np . array ( A ) <NEWLINE> <NL> sum = 0 <NEWLINE> for key , value in Adic . items ( ) : <NEWLINE> <INDENT> sum += key * value <NEWLINE> <DEDENT> for b , c in ope : <NEWLINE> <INDENT> if Adic . get ( b ) != None : <NEWLINE> <INDENT> if Adic . get ( c ) == None : Adic [ c ] = 0 <NEWLINE> sum = sum - b * Adic [ b ] + c * Adic [ b ] <NEWLINE> Adic [ c ] += Adic . pop ( b ) <NEWLINE> print ( sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
import copy <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( D ) : <NEWLINE> <INDENT> s_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . append ( s_i ) <NEWLINE> <NL> <DEDENT> def next_satisfy ( d , c , s , next_t , last , pre_satisfy ) : <NEWLINE> <INDENT> ans = pre_satisfy + s [ d ] [ next_t ] <NEWLINE> last_d = copy . deepcopy ( last [ - 1 ] ) <NEWLINE> last_d [ next_t ] = d <NEWLINE> last . append ( last_d ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> ans -= c [ i ] * ( d - last [ d ] [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> t = [ ] <NEWLINE> last = [ [ - 1 for _ in range ( 26 ) ] ] <NEWLINE> last_i = [ - 1 for _ in range ( 26 ) ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> max_satisfy = - 10 ** 10 <NEWLINE> next_t = - 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> satisfy_i = next_satisfy ( d , c , s , i , last , 0 ) <NEWLINE> if max_satisfy < satisfy_i : <NEWLINE> <INDENT> max_satisfy = satisfy_i <NEWLINE> next_t = i <NEWLINE> <DEDENT> <DEDENT> last_i [ next_t ] = d <NEWLINE> last . append ( copy . deepcopy ( last_i ) ) <NEWLINE> t . append ( next_t + 1 ) <NEWLINE> <NL> <DEDENT> for t_i in t : <NEWLINE> <INDENT> print ( t_i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> mx = float ( <STRING> ) * ( - 1 ) <NEWLINE> mn = x [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if mx < ( x [ i ] - mn ) : <NEWLINE> <INDENT> mx = x [ i ] - mn <NEWLINE> <DEDENT> if mn > x [ i ] : <NEWLINE> <INDENT> mn = x [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( mx ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> fi = [ - 1 ] * ( n + 1 ) <NEWLINE> fi [ 1 ] = 0 <NEWLINE> a = 0 <NEWLINE> aa = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if fi [ ls [ a ] ] == - 1 : <NEWLINE> <INDENT> fi [ ls [ a ] ] = i + 1 <NEWLINE> aa = a <NEWLINE> a = ls [ a ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = fi [ ls [ a ] ] <NEWLINE> t = ( k - ind ) % ( max ( fi ) + 1 - ind ) <NEWLINE> t += ind <NEWLINE> print ( fi . index ( t ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ls [ aa ] ) <NEWLINE> <DEDENT>
strings = input ( ) <NEWLINE> <NL> for i in strings : <NEWLINE> <INDENT> if <STRING> <= i <= <STRING> : <NEWLINE> <INDENT> print ( i . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> elif <STRING> <= i <= <STRING> : <NEWLINE> <INDENT> print ( i . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from collections import Counter , deque <NEWLINE> from collections import defaultdict <NEWLINE> from itertools import combinations , permutations , accumulate , groupby , product <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from math import floor , ceil , pi <NEWLINE> from operator import itemgetter <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI2 ( ) : return [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> def MXI ( ) : return [ [ LI ( ) ] for i in range ( n ) ] <NEWLINE> def SI ( ) : return input ( ) . rstrip ( ) <NEWLINE> def printns ( x ) : print ( <STRING> . join ( x ) ) <NEWLINE> def printni ( x ) : print ( <STRING> . join ( list ( map ( str , x ) ) ) ) <NEWLINE> inf = 10 ** 17 <NEWLINE> <COMMENT> <NL> mod = 998244353 <NEWLINE> x = 220000 <NEWLINE> fact = [ 0 for i in range ( x ) ] <NEWLINE> invfact = [ 0 for i in range ( x ) ] <NEWLINE> fact [ 0 ] = 1 <NEWLINE> <NL> def cmod ( n , k , mod ) : <NEWLINE> <INDENT> if n < 0 or n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return ( fact [ n ] * invfact [ n - k ] * invfact [ k ] ) % mod <NEWLINE> <DEDENT> for i in range ( 1 , x ) : <NEWLINE> <INDENT> fact [ i ] = ( fact [ i - 1 ] * i ) % mod <NEWLINE> <COMMENT> <NL> <DEDENT> invfact [ - 1 ] = pow ( fact [ - 1 ] , mod - 2 , mod ) <NEWLINE> <COMMENT> <NL> for j in range ( x - 1 , 0 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> invfact [ j - 1 ] = ( invfact [ j ] * ( j ) ) % mod <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> n , m , k = MI ( ) <NEWLINE> beki = [ 0 for i in range ( n ) ] <NEWLINE> beki [ 0 ] = m % mod <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> beki [ i + 1 ] = ( beki [ i ] * ( m - 1 ) ) % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> j = n - i - 1 <NEWLINE> ans += ( beki [ j ] * cmod ( n - 1 , i , mod ) ) % mod <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
l = input ( ) <NEWLINE> ls = l . split ( <STRING> ) <NEWLINE> X = int ( ls [ 0 ] ) <NEWLINE> N = int ( ls [ 1 ] ) <NEWLINE> lstr = input ( ) <NEWLINE> lst = lstr . split ( <STRING> ) <NEWLINE> fl = [ ] <NEWLINE> if ( N != 0 ) : <NEWLINE> <INDENT> for a in lst : <NEWLINE> <INDENT> fl . append ( int ( a ) ) <NEWLINE> <DEDENT> <DEDENT> for a in range ( 101 ) : <NEWLINE> <INDENT> if ( X - a not in fl ) : <NEWLINE> <INDENT> print ( X - a ) <NEWLINE> break <NEWLINE> <DEDENT> if ( X + a not in fl ) : <NEWLINE> <INDENT> print ( X + a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> wlst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> connect = [ [ None ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> connect [ i ] [ j ] = abs ( wlst [ i ] - wlst [ j ] ) <= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> max_lst = [ [ False ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> max_lst [ 0 ] [ i ] = True <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * n for _ in range ( n + 1 ) ] <NEWLINE> <NL> def check ( length , left ) : <NEWLINE> <INDENT> ret = dp [ length - 1 ] [ left ] <NEWLINE> for k in range ( length - 1 , 0 , - 2 ) : <NEWLINE> <INDENT> if not max_lst [ length - k - 1 ] [ left + k ] : continue <NEWLINE> if connect [ left + k - 1 ] [ left + length - 1 ] : <NEWLINE> <INDENT> temp = length - k + 1 + dp [ k - 1 ] [ left ] <NEWLINE> if ret < temp : <NEWLINE> <INDENT> ret = temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> for length in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for left in range ( n - length + 1 ) : <NEWLINE> <INDENT> dp [ length ] [ left ] = check ( length , left ) <NEWLINE> if dp [ length ] [ left ] == length : <NEWLINE> <INDENT> max_lst [ length ] [ left ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> nm = input ( ) <NEWLINE> nm = nm . split ( ) <NEWLINE> n = int ( nm [ 0 ] ) <NEWLINE> m = int ( nm [ 1 ] ) <NEWLINE> <NL> h = input ( ) <NEWLINE> h = h . split ( ) <NEWLINE> h = list ( map ( int , h ) ) <NEWLINE> <NL> AB = [ ] <NEWLINE> ma = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ab = input ( ) <NEWLINE> ab = ab . split ( ) <NEWLINE> ab = list ( map ( int , ab ) ) <NEWLINE> ma [ ab [ 0 ] - 1 ] = max ( ma [ ab [ 0 ] - 1 ] , h [ ab [ 1 ] - 1 ] ) <NEWLINE> ma [ ab [ 1 ] - 1 ] = max ( ma [ ab [ 1 ] - 1 ] , h [ ab [ 0 ] - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > ma [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ float ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = sorted ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( b , a [ i ] ) <NEWLINE> y = bisect . bisect_right ( b , a [ i ] ) <NEWLINE> print ( x * 2 + y - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in alist : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in alist : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> Fr = [ set ( ) for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . union ( A , B ) <NEWLINE> Fr [ A ] . add ( B ) <NEWLINE> Fr [ B ] . add ( A ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( uf . size ( i ) - len ( Fr [ i ] ) - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> C , D = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> if uf . same ( C , D ) : <NEWLINE> <INDENT> ans [ C ] -= 1 <NEWLINE> ans [ D ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE>
import itertools <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> temp = 0 <NEWLINE> total = sum ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> temp += i * ( total - i ) <NEWLINE> <DEDENT> temp //= 2 <NEWLINE> print ( temp % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , s = input ( ) . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> d [ s ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
def dev ( y , x ) : <NEWLINE> <INDENT> if y < x : <NEWLINE> <INDENT> return 2 * ( x - y ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 2 * ( y - x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( y ) for y in input ( ) . split ( ) ] <NEWLINE> q = [ dev ( y , x ) for y in p ] <NEWLINE> q . sort ( ) <NEWLINE> r = 0 <NEWLINE> while r < len ( q ) : <NEWLINE> <INDENT> if q [ r ] != r : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r += 1 <NEWLINE> <DEDENT> if r % 2 == 0 : <NEWLINE> <INDENT> print ( x + r // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - ( r + 1 ) // 2 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> red_map = np . array ( [ input ( ) . split ( ) for i in range ( H ) ] , dtype = <STRING> ) <NEWLINE> blue_map = np . array ( [ input ( ) . split ( ) for i in range ( H ) ] , dtype = <STRING> ) <NEWLINE> sub_map = abs ( red_map - blue_map ) <NEWLINE> dp = [ [ 2020 ] * W for i in range ( H ) ] <NEWLINE> max_deviation = 2 ** ( 80 * ( H + W ) ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if not i and not j : <NEWLINE> <INDENT> dp [ i ] [ j ] = ( max_deviation << sub_map [ i ] [ j ] | max_deviation >> sub_map [ i ] [ j ] ) <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] |= ( dp [ i - 1 ] [ j ] << sub_map [ i ] [ j ] | dp [ i - 1 ] [ j ] >> sub_map [ i ] [ j ] ) <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] |= ( dp [ i ] [ j - 1 ] << sub_map [ i ] [ j ] | dp [ i ] [ j - 1 ] >> sub_map [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> pre_ans = dp [ H - 1 ] [ W - 1 ] >> 80 * ( H + W ) <NEWLINE> pre_ans_bit = format ( pre_ans & - pre_ans , <STRING> ) <NEWLINE> ans = len ( pre_ans_bit ) - 1 <NEWLINE> print ( ans ) <NEWLINE>
from heapq import heappop , heappush <NEWLINE> <NL> <NL> class WeightedEdge : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , a , b , weight ) : <NEWLINE> <INDENT> self . a = a <NEWLINE> self . b = b <NEWLINE> self . weight = weight <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> % ( self . a , self . b , self . weight ) <NEWLINE> <NL> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . a < other . b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class EdgeWeightedGraph : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . __adj = [ [ ] for _ in range ( V + 1 ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , a , b , weight ) : <NEWLINE> <INDENT> self . __adj [ a ] . append ( WeightedEdge ( a , b , weight ) ) <NEWLINE> self . __adj [ b ] . append ( WeightedEdge ( b , a , weight ) ) <NEWLINE> <NL> <DEDENT> def adj ( self , a ) : <NEWLINE> <INDENT> return self . __adj [ a ] <NEWLINE> <NL> <DEDENT> def num_nodes ( self ) : <NEWLINE> <INDENT> return len ( self . __adj ) - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Dijkstra : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , graph , s , t ) : <NEWLINE> <INDENT> self . dist_to = [ float ( <STRING> ) for _ in range ( graph . num_nodes ( ) + 1 ) ] <NEWLINE> self . dist_to [ s ] = 0 <NEWLINE> pq = [ ] <NEWLINE> heappush ( pq , ( 0 , s ) ) <NEWLINE> while pq : <NEWLINE> <INDENT> w , a = heappop ( pq ) <NEWLINE> if a == t : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . dist_to [ a ] < w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for edge in graph . adj ( a ) : <NEWLINE> <INDENT> if self . dist_to [ edge . b ] > self . dist_to [ a ] + edge . weight : <NEWLINE> <INDENT> self . dist_to [ edge . b ] = self . dist_to [ a ] + edge . weight <NEWLINE> heappush ( pq , ( self . dist_to [ edge . b ] , edge . b ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> g_cost = EdgeWeightedGraph ( m ) <NEWLINE> g_time = EdgeWeightedGraph ( m ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b , cost , time = map ( int , input ( ) . split ( ) ) <NEWLINE> g_cost . add_edge ( a , b , cost ) <NEWLINE> g_time . add_edge ( a , b , time ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> p , q , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> fw_cost = Dijkstra ( g_cost , p , q ) <NEWLINE> ans = fw_cost . dist_to [ q ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fw_time = Dijkstra ( g_time , p , q ) <NEWLINE> ans = fw_time . dist_to [ q ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while N > i : <NEWLINE> <INDENT> if p [ i ] - 1 == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> np_a = np . array ( a , dtype = int ) <NEWLINE> <NL> ans = np . zeros ( n , dtype = int ) <NEWLINE> <NL> all = np_a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> all = all ^ np_a [ i ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans [ i ] = all ^ np_a [ i ] <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K * 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= A <NEWLINE> if B >= K : <NEWLINE> <INDENT> print ( A * 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= B <NEWLINE> print ( A * 1 + K * ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> root = [ - 1 ] * n <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if root [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ x ] = find ( root [ x ] ) <NEWLINE> return root [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> root [ x ] += root [ y ] <NEWLINE> root [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> return - root [ x ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = [ 1 ] * ( a [ n - 1 ] + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i >= 1 and a [ i ] == a [ i - 1 ] : <NEWLINE> <INDENT> ans [ a [ i ] ] = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> j = 2 <NEWLINE> while j * a [ i ] <= a [ n - 1 ] : <NEWLINE> <INDENT> ans [ j * a [ i ] ] = 0 <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum += ans [ a [ i ] ] <NEWLINE> <NL> <NL> <DEDENT> print ( sum ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> person = int ( input ( ) ) <NEWLINE> lst [ person - 1 ] += 1 <NEWLINE> <DEDENT> for p in range ( n ) : <NEWLINE> <INDENT> temp = k - q + lst [ p ] <NEWLINE> if temp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
num_list = input ( ) . split ( ) <NEWLINE> a = int ( num_list [ 0 ] ) <NEWLINE> b = int ( num_list [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> dp = np . array ( [ 0 for _ in range ( max ( a ) + 1 ) ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> if ( dp [ ai ] >= 2 ) : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> j = 1 <NEWLINE> while ( ai * j <= a [ - 1 ] ) : <NEWLINE> <INDENT> dp [ ai * j ] += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( dp [ ai ] == 1 for ai in a ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = a [ 0 ] <NEWLINE> idx = 0 <NEWLINE> gabbege = a [ idx ] <NEWLINE> length = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if length < k : <NEWLINE> <INDENT> length += 1 <NEWLINE> now += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if now < now - gabbege + a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> now = now - gabbege + a [ i ] <NEWLINE> idx += 1 <NEWLINE> gabbege = a [ idx ] <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
A , B , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> max_val = 0 <NEWLINE> j = min ( B - 1 , N ) <NEWLINE> x = ( A * j ) // B - A * ( j // B ) <NEWLINE> print ( x ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lim = math . pow ( 10 , 18 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> x = r [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x * r [ i ] <NEWLINE> <NL> <DEDENT> if x > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if x > 1000000000000000000 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> <NL> <DEDENT> if 0 in r : <NEWLINE> <INDENT> x = 0 <NEWLINE> <NL> <DEDENT> print ( math . floor ( x ) ) <NEWLINE>
l = input ( ) . split ( ) <NEWLINE> n1 = int ( l [ 0 ] ) <NEWLINE> n0 = int ( l [ 1 ] ) <NEWLINE> n = int ( l [ 2 ] ) <NEWLINE> k = int ( l [ 3 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if k >= n1 : <NEWLINE> <INDENT> ans += n1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans += k <NEWLINE> <NL> <DEDENT> k -= n1 <NEWLINE> <NL> k -= n0 <NEWLINE> <NL> if k > 0 : <NEWLINE> <INDENT> ans -= k <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ i == <STRING> for i in list ( input ( ) ) ] <NEWLINE> i = 0 <NEWLINE> cnt = 0 <NEWLINE> l = [ 0 ] * n <NEWLINE> r = [ 0 ] * n <NEWLINE> while i < n : <NEWLINE> <INDENT> if s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> for j in range ( i , c + i + 1 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> l [ j ] = cnt <NEWLINE> <DEDENT> <DEDENT> i += c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] = cnt <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> i = n - 1 <NEWLINE> cnt = 0 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> if s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> for j in range ( i , i - 1 - c , - 1 ) : <NEWLINE> <INDENT> if j >= 0 : <NEWLINE> <INDENT> r [ j ] = cnt <NEWLINE> <DEDENT> <DEDENT> i -= c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ i ] = cnt <NEWLINE> i -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> r . append ( 0 ) <NEWLINE> if r [ 1 ] < k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if not s [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if l [ i - 1 ] + r [ i + 1 ] < k : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> if l [ n - 2 ] < k : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : d . append ( i ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * d ) <NEWLINE>
def min ( a , b , c ) : <NEWLINE> <INDENT> if a < b and a < c : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> elif b < c : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return c <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calc ( x ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = x . index ( <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> a = 300 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> b = x . index ( <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> b = 300 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> c = x . index ( <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> c = 300 <NEWLINE> <NL> <DEDENT> ind = min ( a , b , c ) <NEWLINE> <NL> if ind == 300 : <NEWLINE> <INDENT> return x [ 0 ] <NEWLINE> <NL> <DEDENT> if x [ ind ] == <STRING> : <NEWLINE> <INDENT> x . insert ( ind - 2 , int ( x [ ind - 2 ] ) + int ( x [ ind - 1 ] ) ) <NEWLINE> <DEDENT> elif x [ ind ] == <STRING> : <NEWLINE> <INDENT> x . insert ( ind - 2 , int ( x [ ind - 2 ] ) - int ( x [ ind - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . insert ( ind - 2 , int ( x [ ind - 2 ] ) * int ( x [ ind - 1 ] ) ) <NEWLINE> <DEDENT> x . pop ( ind - 1 ) <NEWLINE> x . pop ( ind - 1 ) <NEWLINE> x . pop ( ind - 1 ) <NEWLINE> return calc ( x ) <NEWLINE> <NL> <NL> <DEDENT> operas = input ( ) . split ( <STRING> ) <NEWLINE> print ( calc ( operas ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = A [ i ] - i - 1 <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> import bisect <NEWLINE> z = bisect . bisect_left ( A , 0 ) <NEWLINE> ans = sum ( A [ z : ] ) - sum ( A [ : z ] ) <NEWLINE> if z > N - z : <NEWLINE> <INDENT> p = 0 <NEWLINE> while z > N - z : <NEWLINE> <INDENT> b = A [ z - 1 ] <NEWLINE> ans += ( N - 2 * z ) * ( p - b ) <NEWLINE> p = b <NEWLINE> z = bisect . bisect_left ( A , b ) <NEWLINE> <DEDENT> <DEDENT> elif N > 2 * bisect . bisect_right ( A , 0 ) : <NEWLINE> <INDENT> z = bisect . bisect_right ( A , 0 ) <NEWLINE> p = 0 <NEWLINE> while N - z > z : <NEWLINE> <INDENT> b = A [ z ] <NEWLINE> ans += ( 2 * z - N ) * ( b - p ) <NEWLINE> p = b <NEWLINE> z = bisect . bisect_right ( A , b ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ( r , g , b ) = ( 0 , 0 , 0 ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> a = r * g * b <NEWLINE> t = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if 2 * j - i <= n - 1 and s [ i ] != s [ j ] and s [ j ] != s [ 2 * j - i ] and s [ 2 * j - i ] != s [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a - t ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> DEBUG = False <NEWLINE> if DEBUG : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = sys . stdin <NEWLINE> <COMMENT> <NL> <DEDENT> def cnt_func ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while num : <NEWLINE> <INDENT> num %= bin ( num ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt + 1 <NEWLINE> <DEDENT> n = int ( f . readline ( ) . strip ( ) ) <NEWLINE> s = f . readline ( ) . strip ( ) <NEWLINE> input_val = int ( s , 2 ) <NEWLINE> input_one_count = s . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> zero_first = input_val % ( input_one_count + 1 ) <NEWLINE> one_first = input_val % ( input_one_count - 1 ) if input_one_count > 1 else 0 <NEWLINE> ans = 0 <NEWLINE> for idx , emt in enumerate ( s ) : <NEWLINE> <INDENT> p = n - idx - 1 <NEWLINE> if emt == <STRING> : <COMMENT> <NEWLINE> <INDENT> ans = cnt_func ( ( zero_first + ( pow ( 2 , p , input_one_count + 1 ) ) ) % ( input_one_count + 1 ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if input_one_count > 1 : <NEWLINE> <INDENT> ans = cnt_func ( ( one_first - ( pow ( 2 , p , input_one_count - 1 ) ) ) % ( input_one_count - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> f . close ( ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE>
<NL> n , y = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> _10000 , _5000 , _1000 = 0 , 0 , 0 <NEWLINE> <NL> exist = False <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <NL> <COMMENT> <NL> <NL> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <INDENT> if ( i * 10000 ) + ( j * 5000 ) + ( ( n - i - j ) * 1000 ) == y : <NEWLINE> <COMMENT> <NL> <INDENT> _10000 , _5000 , _1000 = i , j , n - i - j <NEWLINE> exist = True <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if exist == True : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if exist == True : <NEWLINE> <INDENT> print ( <STRING> . format ( _10000 , _5000 , _1000 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pro = 1 <NEWLINE> List . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pro *= List [ i ] <NEWLINE> if pro > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( pro ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in List : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in List : <NEWLINE> <INDENT> a = a * i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not a > 10 ** 18 and not 0 in List : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
from queue import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> R , W = <STRING> , <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> counter = dict ( ) <NEWLINE> for c in C : <NEWLINE> <INDENT> counter [ c ] = counter . get ( c , 0 ) + 1 <NEWLINE> <DEDENT> r = counter . get ( R , 0 ) <NEWLINE> <NL> _counter = dict ( ) <NEWLINE> for c in C [ r : ] : <NEWLINE> <INDENT> _counter [ c ] = _counter . get ( c , 0 ) + 1 <NEWLINE> <DEDENT> _r = _counter . get ( R , 0 ) <NEWLINE> <NL> ans = _r <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> p = 998244353 <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> <NL> def cmb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> for k in range ( K + 1 ) : <NEWLINE> <INDENT> c = cmb ( N - 1 , k , p ) <NEWLINE> m = M % p <NEWLINE> n = pow ( M - 1 , N - k - 1 , p ) <NEWLINE> result = ( result + c * m * n ) % p <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> <NL> for a in al : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> ans [ a - 1 ] += 1 <NEWLINE> ans [ a + 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> fileoperation = 0 <NEWLINE> if ( fileoperation ) : <NEWLINE> <INDENT> orig_stdout = sys . stdout <NEWLINE> orig_stdin = sys . stdin <NEWLINE> inputfile = open ( <STRING> , <STRING> ) <NEWLINE> outputfile = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = inputfile <NEWLINE> sys . stdout = outputfile <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mod = 1000000007 <NEWLINE> <NL> <COMMENT> <NL> def nospace ( l ) : <NEWLINE> <INDENT> ans = <STRING> . join ( str ( i ) for i in l ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> t = 1 <NEWLINE> for tt in range ( t ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , sys . stdin . readline ( ) . split ( <STRING> ) ) ) <NEWLINE> ams = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for x in a : <NEWLINE> <INDENT> ams *= x <NEWLINE> if ams > 1000000000000000000 : <NEWLINE> <INDENT> ams = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ams ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if ( fileoperation ) : <NEWLINE> <INDENT> sys . stdout = orig_stdout <NEWLINE> sys . stdin = orig_stdin <NEWLINE> inputfile . close ( ) <NEWLINE> outputfile . close ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> min_num = - sys . maxsize - 1 <NEWLINE> <COMMENT> <NL> max_diff = - sys . maxsize - 1 <NEWLINE> for idx_i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> Rt = int ( input ( ) ) <NEWLINE> if ( not idx_i ) : <NEWLINE> <INDENT> min_num = Rt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = Rt - min_num <NEWLINE> if ( tmp > max_diff ) : <NEWLINE> <INDENT> max_diff = tmp <NEWLINE> <DEDENT> if ( Rt < min_num ) : <NEWLINE> <INDENT> min_num = Rt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_diff ) <NEWLINE> <NL>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 and not 0 in a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> anscheck = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> anscheck = True <NEWLINE> <DEDENT> print ( ans if anscheck else - 1 ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def xor ( x , y ) : <NEWLINE> <INDENT> return x ^ y <NEWLINE> <NL> <DEDENT> N = i ( ) <NEWLINE> A = l ( ) <NEWLINE> ans = [ ] <NEWLINE> S = xor ( A [ 0 ] , A [ 1 ] ) <NEWLINE> <NL> for i in range ( len ( A ) - 2 ) : <NEWLINE> <INDENT> S = xor ( S , A [ i + 2 ] ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans . append ( str ( xor ( S , i ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> def pow25 ( x ) : <NEWLINE> <INDENT> f2 = f5 = 0 <NEWLINE> while x % 2 == 0 : <NEWLINE> <INDENT> x //= 2 <NEWLINE> f2 += 1 <NEWLINE> <DEDENT> while x % 5 == 0 : <NEWLINE> <INDENT> x //= 5 <NEWLINE> f5 += 1 <NEWLINE> <DEDENT> return f2 , f5 <NEWLINE> <NL> <DEDENT> pow25_dic = defaultdict ( int ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> seisu , shosu = a . split ( <STRING> ) <NEWLINE> seisu = int ( seisu ) <NEWLINE> shosu = int ( shosu . ljust ( 9 , <STRING> ) ) <NEWLINE> bunshi = 10 ** 9 * seisu + shosu <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bunshi = 10 ** 9 * int ( a ) <NEWLINE> <NL> <DEDENT> pow25_dic [ pow25 ( bunshi ) ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> pow25_key_list = [ ] <NEWLINE> for key in pow25_dic : <NEWLINE> <INDENT> pow25_key_list . append ( key ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( len ( pow25_key_list ) ) : <NEWLINE> <INDENT> f2 , f5 = pow25_key_list [ i ] <NEWLINE> value = pow25_dic [ ( f2 , f5 ) ] <NEWLINE> if f2 >= 9 and f5 >= 9 : <NEWLINE> <INDENT> answer += value * ( value - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for j in range ( i + 1 , len ( pow25_key_list ) ) : <NEWLINE> <INDENT> f2_2 , f5_2 = pow25_key_list [ j ] <NEWLINE> if f2 + f2_2 >= 18 and f5 + f5_2 >= 18 : <NEWLINE> <INDENT> value2 = pow25_dic [ ( f2_2 , f5_2 ) ] <NEWLINE> answer += value * value2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> return N , K , A <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> d = np . empty ( N + 1 , dtype = np . int32 ) <NEWLINE> <NL> for k in range ( K ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> l = max ( 0 , i - A [ i ] ) <NEWLINE> r = min ( N , i + 1 + A [ i ] ) <NEWLINE> d [ l ] += 1 <NEWLINE> d [ r ] -= 1 <NEWLINE> <NL> <DEDENT> terminate = True <NEWLINE> v = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v += d [ i ] <NEWLINE> A [ i ] = v <NEWLINE> if terminate and A [ i ] < N : <NEWLINE> <INDENT> terminate = False <NEWLINE> <DEDENT> <DEDENT> if terminate : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> print ( * outputs ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> l , r = 0 , 10 ** 9 + 2 <NEWLINE> <NL> while r - l > 1 : <NEWLINE> <INDENT> key = ( r + l ) // 2 <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count += ( a [ i ] - 1 ) // key <NEWLINE> <DEDENT> if count <= k : <NEWLINE> <INDENT> r = key <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = key <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ind = i + 1 <NEWLINE> ret = <STRING> + str ( ind ) + <STRING> + str ( xs [ ind - 1 ] ) <NEWLINE> if ind != 1 : <NEWLINE> <INDENT> parent = ind // 2 - 1 <NEWLINE> ret += <STRING> + str ( xs [ parent ] ) <NEWLINE> <DEDENT> if n > 2 * i + 1 : <NEWLINE> <INDENT> ret += <STRING> + str ( xs [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> if n > 2 * i + 2 : <NEWLINE> <INDENT> ret += <STRING> + str ( xs [ 2 * i + 2 ] ) <NEWLINE> <DEDENT> ret += <STRING> <NEWLINE> print ( ret ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] + a [ 1 ] == a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> k = n // i <NEWLINE> ans += i * ( k * ( k + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> b_now = 1 <NEWLINE> loop = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b_now = a [ b_now - 1 ] <NEWLINE> ans += 1 <NEWLINE> if b_now == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> costs = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> costs [ p - 1 ] += x <NEWLINE> <DEDENT> visited = [ 0 ] * n <NEWLINE> <NL> def dfs ( idx ) : <NEWLINE> <INDENT> visited [ idx ] = 1 <NEWLINE> for i in g [ idx ] : <NEWLINE> <INDENT> if visited [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> costs [ i ] += costs [ idx ] <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * costs ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> <NL> sign = <STRING> <NEWLINE> <NL> for i in range ( 2 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( 2 ) : <COMMENT> <NEWLINE> <INDENT> for k in range ( 2 ) : <COMMENT> <NEWLINE> <INDENT> if eval ( a [ 0 ] + sign [ i ] + a [ 1 ] + sign [ j ] + a [ 2 ] + sign [ k ] + a [ 3 ] ) == 7 : <NEWLINE> <INDENT> print ( str ( a [ 0 ] + sign [ i ] + a [ 1 ] + sign [ j ] + a [ 2 ] + sign [ k ] + a [ 3 ] ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> mod = 998244353 <NEWLINE> fact = [ 1 ] <NEWLINE> fact_inv = [ 1 ] <NEWLINE> for i in range ( 2 * 10 ** 5 + 2 ) : <NEWLINE> <INDENT> new_fact = fact [ - 1 ] * ( i + 1 ) % mod <NEWLINE> fact . append ( new_fact ) <NEWLINE> fact_inv . append ( pow ( new_fact , mod - 2 , mod ) ) <NEWLINE> <DEDENT> def mod_comb_k ( n , k , mod ) : <NEWLINE> <INDENT> return fact [ n ] * fact_inv [ k ] % mod * fact_inv [ n - k ] % mod <NEWLINE> <DEDENT> def power_func ( a , n , p ) : <NEWLINE> <INDENT> bi = str ( format ( n , <STRING> ) ) <COMMENT> <NEWLINE> res = 1 <NEWLINE> for i in range ( len ( bi ) ) : <NEWLINE> <INDENT> res = ( res * res ) % p <NEWLINE> if bi [ i ] == <STRING> : <NEWLINE> <INDENT> res = ( res * a ) % p <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> X = mod_comb_k ( N - 1 , i , mod ) <NEWLINE> Z = power_func ( M - 1 , N - ( i + 1 ) , mod ) <NEWLINE> <COMMENT> <NL> ans += X * M * Z % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> marks = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if marks [ i ] < marks [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> List = list ( S ) <NEWLINE> flag = True <NEWLINE> mid = <STRING> <NEWLINE> res = 0 <NEWLINE> n = List . count ( <STRING> ) <NEWLINE> k = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if List [ i ] == <STRING> : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> s = input ( ) <NEWLINE> p = 2019 <NEWLINE> ans = 0 <NEWLINE> l = [ 0 for i in range ( p ) ] <NEWLINE> l [ 0 ] = 1 <NEWLINE> z = 0 <NEWLINE> ten = 1 <NEWLINE> tmp = 0 <NEWLINE> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> i = int ( i ) <NEWLINE> tmp = ( tmp + i * ten ) % p <NEWLINE> ten = ( ten * 10 ) % 2019 <NEWLINE> l [ tmp ] += 1 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> A += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> L = [ - 10 ** 6 ] <NEWLINE> R = [ - 10 ** 6 ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> L . append ( i + A [ i ] ) <NEWLINE> R . append ( i - A [ i ] ) <NEWLINE> <DEDENT> c = collections . Counter ( L ) <NEWLINE> <NL> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt += c . get ( R [ j ] , 0 ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> t = n - 1 <NEWLINE> while t >= 0 : <NEWLINE> <INDENT> if s [ t ] == <STRING> : <NEWLINE> <INDENT> if t < 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ t - 1 ] == <STRING> and s [ t - 2 ] == <STRING> and s [ t - 3 ] == <STRING> and s [ t - 4 ] == <STRING> and s [ t - 5 ] == <STRING> : <NEWLINE> <INDENT> t -= 6 <NEWLINE> <DEDENT> elif t < 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ t - 1 ] == <STRING> and s [ t - 2 ] == <STRING> and s [ t - 3 ] == <STRING> and s [ t - 4 ] == <STRING> and s [ t - 5 ] == <STRING> and s [ t - 6 ] == <STRING> : <NEWLINE> <INDENT> t -= 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif s [ t ] == <STRING> : <NEWLINE> <INDENT> if t < 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ t - 1 ] == <STRING> and s [ t - 2 ] == <STRING> and s [ t - 3 ] == <STRING> and s [ t - 4 ] == <STRING> : <NEWLINE> <INDENT> t -= 5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif s [ t ] == <STRING> : <NEWLINE> <INDENT> if t < 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s [ t - 1 ] == <STRING> and s [ t - 2 ] == <STRING> and s [ t - 3 ] == <STRING> and s [ t - 4 ] == <STRING> : <NEWLINE> <INDENT> t -= 5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import heapq <NEWLINE> import collections <NEWLINE> <NL> class HeapQueue : <NEWLINE> <NL> <INDENT> def __init__ ( self , xs , mode ) : <NEWLINE> <INDENT> if mode == <STRING> : self . xs = [ + x for x in xs ] <NEWLINE> elif mode == <STRING> : self . xs = [ - x for x in xs ] <NEWLINE> else : raise NotImplementedError ( <STRING> ) <NEWLINE> heapq . heapify ( xs ) <NEWLINE> self . mode = mode <NEWLINE> <NL> <DEDENT> def __len__ ( self ) : <NEWLINE> <INDENT> return len ( self . xs ) <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> if self . mode == <STRING> : return heapq . heappop ( self . xs ) <NEWLINE> elif self . mode == <STRING> : return heapq . heappop ( self . xs ) * ( - 1 ) <NEWLINE> <NL> <DEDENT> def push ( self , x ) : <NEWLINE> <INDENT> if self . mode == <STRING> : return heapq . heappush ( self . xs , x ) <NEWLINE> elif self . mode == <STRING> : return heapq . heappush ( self . xs , - x ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> N , K = tuple ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> As = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> D = int ( 1E9 + 7 ) <NEWLINE> r = 1 <NEWLINE> <NL> if N == K : <NEWLINE> <NL> <INDENT> for a in As : <NEWLINE> <INDENT> r = ( r * a ) % D <NEWLINE> <NL> <DEDENT> <DEDENT> elif all ( a >= 0 for a in As ) : <NEWLINE> <NL> <INDENT> As = sorted ( As , reverse = True ) <NEWLINE> for a in As [ : K ] : <NEWLINE> <INDENT> r = ( r * a ) % D <NEWLINE> <NL> <DEDENT> <DEDENT> elif K % 2 == 1 and all ( a < 0 for a in As ) : <NEWLINE> <NL> <INDENT> As = sorted ( As , reverse = True ) <NEWLINE> for a in As [ : K ] : <NEWLINE> <INDENT> r = ( r * a ) % D <NEWLINE> <NL> <DEDENT> <DEDENT> elif K % 2 == 0 and all ( a < 0 for a in As ) : <NEWLINE> <NL> <INDENT> As = sorted ( As ) <NEWLINE> for a in As [ : K ] : <NEWLINE> <INDENT> r = ( r * a ) % D <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <NL> <INDENT> As = sorted ( As , key = lambda a : abs ( a ) , reverse = True ) <NEWLINE> <NL> used = As [ : K ] <NEWLINE> rest = As [ K : ] <NEWLINE> num_negative_sign = sum ( [ 1 if x < 0 else 0 for x in used ] ) <NEWLINE> <NL> if num_negative_sign % 2 != 0 : <NEWLINE> <NL> <INDENT> used_min_pos = None <NEWLINE> used_min_neg = None <NEWLINE> for k in range ( K - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if used_min_pos is None and used [ k ] >= 0 : used_min_pos = k <NEWLINE> elif used_min_neg is None and used [ k ] < 0 : used_min_neg = k <NEWLINE> if used_min_pos and used_min_neg : break <NEWLINE> <NL> <DEDENT> rest_min_pos = None <NEWLINE> rest_min_neg = None <NEWLINE> for k in range ( N - K ) : <NEWLINE> <INDENT> if rest_min_pos is None and rest [ k ] >= 0 : rest_min_pos = k <NEWLINE> elif rest_min_neg is None and rest [ k ] < 0 : rest_min_neg = k <NEWLINE> if rest_min_pos and rest_min_neg : break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if used_min_pos is None or rest_min_neg is None : <NEWLINE> <INDENT> used [ used_min_neg ] = rest [ rest_min_pos ] <NEWLINE> <DEDENT> elif used_min_neg is None or rest_min_pos is None : <NEWLINE> <INDENT> used [ used_min_pos ] = rest [ rest_min_neg ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v1 = abs ( used [ used_min_pos ] * rest [ rest_min_pos ] ) <NEWLINE> v2 = abs ( used [ used_min_neg ] * rest [ rest_min_neg ] ) <NEWLINE> if v1 > v2 : <NEWLINE> <INDENT> used [ used_min_neg ] = rest [ rest_min_pos ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used [ used_min_pos ] = rest [ rest_min_neg ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in used : <NEWLINE> <INDENT> r = ( r * a ) % D <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL>
import queue <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> maze [ a - 1 ] . append ( b - 1 ) <NEWLINE> maze [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 for _ in range ( n ) ] <NEWLINE> ans [ 0 ] = 0 <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> start = q . get ( ) <NEWLINE> for end in maze [ start ] : <NEWLINE> <INDENT> if ans [ end ] == - 1 : <NEWLINE> <INDENT> q . put ( end ) <NEWLINE> ans [ end ] = start <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in ans [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> from math import ceil <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> c = Counter ( s ) <NEWLINE> res = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + ceil ( ( n - i ) / 2 ) ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if len ( { s [ i ] , s [ j ] , s [ k ] } ) == 3 : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if 1000000000000000000 < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = sorted ( d ) <NEWLINE> chuou1 = d [ N // 2 - 1 ] <NEWLINE> chuou2 = d [ ( N // 2 ) ] <NEWLINE> if ( chuou2 - chuou1 < 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( chuou2 - chuou1 ) ) <NEWLINE> <DEDENT>
data = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> tele = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> telepo = [ int ( i ) for i in tele ] <NEWLINE> <NL> max = int ( data [ 1 ] ) <NEWLINE> limit = max <NEWLINE> times = 0 <NEWLINE> pos = 1 <NEWLINE> experience = [ 1 ] <NEWLINE> check = { 1 } <NEWLINE> before = 0 <NEWLINE> while max > 0 : <NEWLINE> <INDENT> pos = telepo [ pos - 1 ] <NEWLINE> max -= 1 <NEWLINE> times += 1 <NEWLINE> before = len ( check ) <NEWLINE> check . add ( pos ) <NEWLINE> if before == len ( check ) : <NEWLINE> <INDENT> length = len ( experience ) - experience . index ( pos ) <NEWLINE> max = max % length <NEWLINE> if max == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while max > 0 : <NEWLINE> <INDENT> pos = telepo [ pos - 1 ] <NEWLINE> max -= 1 <NEWLINE> times += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> break <NEWLINE> <DEDENT> experience . append ( pos ) <NEWLINE> <DEDENT> print ( pos ) <NEWLINE>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> return n , x <NEWLINE> <NL> <DEDENT> poptbl = [ 0 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> def popcount ( x ) : <NEWLINE> <INDENT> global poptbl <NEWLINE> if poptbl [ x ] != 0 : <NEWLINE> <INDENT> return poptbl [ x ] <NEWLINE> <NL> <DEDENT> poptbl [ x ] = bin ( x ) . count ( <STRING> ) <NEWLINE> return poptbl [ x ] <NEWLINE> <NL> <DEDENT> ftbl = [ 0 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> global ftbl <NEWLINE> <NL> if ftbl [ x ] != 0 : <NEWLINE> <INDENT> return ftbl [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = f ( x % popcount ( x ) ) + 1 <NEWLINE> <COMMENT> <NL> ftbl [ x ] = ans <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> m = x . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> xint = int ( x , 2 ) <NEWLINE> <COMMENT> <NL> if m != 1 : <NEWLINE> <INDENT> xmodm1 = xint % ( m - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xmodm1 = 1 <NEWLINE> <DEDENT> xmodp1 = xint % ( m + 1 ) <NEWLINE> pow2mod1 = [ 0 ] * n <NEWLINE> pow2mod2 = [ 0 ] * n <NEWLINE> pow2mod1 [ 0 ] = 1 <NEWLINE> pow2mod2 [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if m != 1 : <NEWLINE> <INDENT> pow2mod1 [ i ] = pow2mod1 [ i - 1 ] * 2 % ( m - 1 ) <NEWLINE> <DEDENT> pow2mod2 [ i ] = pow2mod2 [ i - 1 ] * 2 % ( m + 1 ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> a = 0 <NEWLINE> ans . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xx = ( xmodm1 + ( m - 1 ) - pow2mod1 [ n - i - 1 ] ) % ( m - 1 ) <NEWLINE> <COMMENT> <NL> a = f ( xx ) + 1 <NEWLINE> ans . append ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> xx = ( xmodp1 + pow2mod2 [ n - i - 1 ] ) % ( m + 1 ) <NEWLINE> <COMMENT> <NL> a = f ( xx ) + 1 <NEWLINE> ans . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( a ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> ans = main ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> ans += i * ( n + 1 ) * n / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> lis = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> ni = i <NEWLINE> cnti = 0 <NEWLINE> while ni != 0 : <NEWLINE> <INDENT> if ni % 2 == 1 : <NEWLINE> <INDENT> cnti += 1 <NEWLINE> <DEDENT> ni = ni // 2 <NEWLINE> <DEDENT> lis . append ( lis [ i % cnti ] + 1 ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cpls = cnt + 1 <NEWLINE> cmns = cnt - 1 <NEWLINE> <NL> cplis = [ 1 ] <NEWLINE> if cpls != 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> cplis . append ( ( cplis [ i ] * 2 ) % cpls ) <NEWLINE> <DEDENT> <DEDENT> cmlis = [ 1 ] <NEWLINE> if cmns != 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> cmlis . append ( ( cmlis [ i ] * 2 ) % cmns ) <NEWLINE> <NL> <DEDENT> <DEDENT> cpsum = 0 <NEWLINE> cmsum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> cpsum = ( cpsum + cplis [ n - 1 - i ] ) % cpls <NEWLINE> if cmns != 0 : <NEWLINE> <INDENT> cmsum = ( cmsum + cmlis [ n - 1 - i ] ) % cmns <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> Xi = ( cpsum + cplis [ n - 1 - i ] ) % cpls <NEWLINE> print ( lis [ Xi ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cmns == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Xi = ( cmsum - cmlis [ n - 1 - i ] ) % cmns <NEWLINE> print ( lis [ Xi ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> nana = 7 <NEWLINE> kou = 1 <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> if nana % K == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nana = ( nana * 10 + 7 ) % K <NEWLINE> kou += 1 <NEWLINE> <DEDENT> print ( kou ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K / 7 <NEWLINE> b = 10 <NEWLINE> while True : <NEWLINE> <INDENT> b = b % L <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> b = b * 10 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> b = 10 <NEWLINE> while True : <NEWLINE> <INDENT> b = b % L <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> b = b * 10 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
from bisect import bisect_right <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> if set ( list ( t ) ) != ( set ( list ( s ) ) & set ( list ( t ) ) ) : ans = - 1 <NEWLINE> else : <NEWLINE> <INDENT> dct = { } <NEWLINE> <NL> for i , ss in enumerate ( s ) : <NEWLINE> <INDENT> if ss in dct : <NEWLINE> <INDENT> dct [ ss ] . append ( i ) <NEWLINE> <DEDENT> else : dct [ ss ] = [ i ] <NEWLINE> <DEDENT> idx = - 1 <NEWLINE> ans = 0 <NEWLINE> for tt in t : <NEWLINE> <INDENT> m = bisect_right ( dct [ tt ] , idx ) <NEWLINE> if m == len ( dct [ tt ] ) : <NEWLINE> <INDENT> idx = dct [ tt ] [ 0 ] <NEWLINE> ans += n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = dct [ tt ] [ m ] <NEWLINE> <DEDENT> <DEDENT> ans += idx + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ak = np . cumsum ( a , dtype = np . int64 ) <NEWLINE> bk = np . cumsum ( b , dtype = np . int64 ) <NEWLINE> ak = ak [ ak <= k ] <NEWLINE> bk = bk [ bk <= k ] <NEWLINE> lak = len ( ak ) <NEWLINE> lbk = len ( bk ) <NEWLINE> <NL> an = lak <NEWLINE> j = 0 <NEWLINE> for i in range ( lak - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> while bk [ j ] + ak [ i ] <= k : <NEWLINE> <INDENT> an = max ( an , i + j + 2 ) <NEWLINE> j += 1 <NEWLINE> if j >= lbk : <NEWLINE> <INDENT> j -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> an = max ( an , lbk ) <NEWLINE> <NL> print ( an ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for j in range ( m ) ] <NEWLINE> num = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> num [ k ] [ i ] += a [ k ] [ j ] * b [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , num [ i ] ) ) ) <NEWLINE> <NL> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 for i in range ( M + 1 ) ] <NEWLINE> b = [ X ] <NEWLINE> a [ X - 1 ] = 1 <NEWLINE> <NL> for i in range ( min ( N - 1 , M ) ) : <NEWLINE> <INDENT> X = X ** 2 % M <NEWLINE> a [ X - 1 ] += 1 <NEWLINE> b . append ( X ) <NEWLINE> if a [ X - 1 ] > 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( b ) == N : <NEWLINE> <INDENT> print ( sum ( b ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ls = b . index ( b [ - 1 ] ) <NEWLINE> bloop = b [ ls : - 1 ] <NEWLINE> ans = 0 <NEWLINE> if ls > 0 : <NEWLINE> <INDENT> for i in range ( ls ) : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> <DEDENT> <DEDENT> loop = ( N - ls ) // len ( bloop ) <NEWLINE> ans += sum ( bloop ) * loop <NEWLINE> if ( N - ls ) % len ( bloop ) != 0 : <NEWLINE> <INDENT> for i in range ( ( N - ls ) % len ( bloop ) ) : <NEWLINE> <INDENT> ans += bloop [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> truefalse = [ True ] * 101 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> truefalse [ p [ i ] - 1 ] = False <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if truefalse [ x - a - 1 ] : <NEWLINE> <INDENT> print ( x - a ) <NEWLINE> break <NEWLINE> <DEDENT> elif truefalse [ x + a - 1 ] : <NEWLINE> <INDENT> print ( x + a ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> for B in range ( 1 , ( N - 1 ) // A + 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> d = [ - 1 for _ in range ( N ) ] <NEWLINE> d [ 0 ] = 0 <NEWLINE> ans = [ 0 ] * N <NEWLINE> while q : <NEWLINE> <INDENT> p = q . popleft ( ) <NEWLINE> for node in G [ p ] : <NEWLINE> <INDENT> if d [ node ] == - 1 : <NEWLINE> <INDENT> d [ node ] = d [ p ] + 1 <NEWLINE> q . append ( node ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if d [ node ] + 1 == d [ p ] : <NEWLINE> <INDENT> ans [ p ] = node + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> b = set ( a ) <NEWLINE> print ( len ( b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if x [ i ] == y [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif ans >= 3 : <NEWLINE> <INDENT> flag = True <NEWLINE> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans >= 3 or flag == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def check3 ( m ) : <NEWLINE> <INDENT> m = str ( m ) <NEWLINE> if <STRING> in m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> <NL> <NL> while i <= n : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 or x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> isThree = check3 ( x ) <NEWLINE> if isThree : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = [ True ] * n <NEWLINE> dst = [ 1 ] <NEWLINE> twn = 0 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> if flg [ twn ] : <NEWLINE> <INDENT> dst . append ( a [ twn ] ) <NEWLINE> flg [ twn ] = False <NEWLINE> twn = a [ twn ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = dst . index ( a [ twn ] ) <NEWLINE> ld = len ( dst [ : index ] ) <NEWLINE> cyc = len ( dst [ index : ] ) <NEWLINE> print ( dst [ ( ld - 1 ) + ( k + 1 - ld ) % cyc ] if ( k + 1 - ld ) % cyc != 0 else dst [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( dst [ - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> i = 0 <NEWLINE> ans = [ ] <NEWLINE> while i <= len ( s ) - len ( t ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( cnt ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <DEDENT> qv = int ( input ( ) ) <NEWLINE> Q = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( qv ) ] <NEWLINE> <NL> color = [ 0 ] * ( n + 1 ) <NEWLINE> used = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> for v , d , c in Q [ : : - 1 ] : <NEWLINE> <INDENT> if used [ v ] > d : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> q = deque ( [ [ v , d ] ] ) <NEWLINE> while q : <NEWLINE> <INDENT> now , dis = q . popleft ( ) <NEWLINE> if dis < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if color [ now ] == 0 : <NEWLINE> <INDENT> color [ now ] = c <NEWLINE> <DEDENT> for nex in e [ now ] : <NEWLINE> <INDENT> if used [ nex ] < dis - 1 : <NEWLINE> <INDENT> used [ nex ] = dis - 1 <NEWLINE> q . append ( [ nex , dis - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in color [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from heapq import heapify , heappush , heappop <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 1_000_000_007 <NEWLINE> <NL> B = [ a for a in A if a > 0 ] <NEWLINE> C = [ a for a in A if a <= 0 ] <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> if N == K : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> elif len ( B ) == 0 and K % 2 == 1 : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans *= C [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> ans *= B [ - 1 ] <NEWLINE> B . pop ( ) <NEWLINE> K -= 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> k = 0 <NEWLINE> while k < K : <NEWLINE> <COMMENT> <NL> <INDENT> flag = 0 <COMMENT> <NEWLINE> if len ( B ) >= 2 and len ( C ) >= 2 and B [ - 1 ] * B [ - 2 ] < C [ - 1 ] * C [ - 2 ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> elif len ( B ) <= 1 and len ( C ) >= 2 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> elif len ( B ) == 1 and len ( C ) == 1 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <NL> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> ans *= B [ - 1 ] * B [ - 2 ] <NEWLINE> ans %= MOD <NEWLINE> B . pop ( ) <NEWLINE> B . pop ( ) <NEWLINE> <NL> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> ans *= C [ - 1 ] * C [ - 2 ] <NEWLINE> ans %= MOD <NEWLINE> C . pop ( ) <NEWLINE> C . pop ( ) <NEWLINE> <NL> <DEDENT> elif flag == 2 : <NEWLINE> <INDENT> ans *= C [ - 1 ] * B [ - 1 ] <NEWLINE> ans %= MOD <NEWLINE> B . pop ( ) <NEWLINE> C . pop ( ) <NEWLINE> <NL> <DEDENT> k += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> while n != 0 : <NEWLINE> <INDENT> d = [ ] <NEWLINE> p = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d_i , p_i = map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( d_i ) <NEWLINE> p . append ( ( p_i , i ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> hazard = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> hazard += d [ i ] * p [ i ] [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> p . sort ( key = lambda x : - x [ 0 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> rest = d [ p [ i ] [ 1 ] ] <NEWLINE> if m < rest : <NEWLINE> <INDENT> hazard -= m * p [ i ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m -= rest <NEWLINE> hazard -= rest * p [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( hazard ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> amount = sum ( A ) <NEWLINE> calc = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> amount = amount - A [ i ] <NEWLINE> calc . append ( amount ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> calc [ i ] *= A [ i ] <NEWLINE> <NL> <DEDENT> print ( sum ( calc ) % mod ) <NEWLINE>
from collections import deque <NEWLINE> def mergeSort ( A , left , right ) : <NEWLINE> <NL> <INDENT> middle = ( left + right ) // 2 <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mergeSort ( A , left , middle ) <NEWLINE> mergeSort ( A , middle , right ) <NEWLINE> merge ( A , left , right , middle ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( A , left , right , middle ) : <NEWLINE> <INDENT> global count <NEWLINE> <NL> L = deque ( A [ left : middle ] ) <NEWLINE> R = deque ( A [ middle : right ] ) <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> for i in range ( left , right ) : <NEWLINE> <NL> <INDENT> if L [ 0 ] < R [ 0 ] : <NEWLINE> <INDENT> A [ i ] = L . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = R . popleft ( ) <NEWLINE> count += len ( L ) - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( A , 0 , len ( A ) ) <NEWLINE> print ( count ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xy = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for h in itertools . combinations ( range ( 0 , n ) , i ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> y = 0 <NEWLINE> for j in h : <NEWLINE> <INDENT> x += v [ j ] <NEWLINE> y += c [ j ] <NEWLINE> <DEDENT> if xy < x - y : <NEWLINE> <INDENT> xy = x - y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( xy ) <NEWLINE>
mod = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> left = [ ] <NEWLINE> right = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> left . append ( l ) <NEWLINE> right . append ( r ) <NEWLINE> <DEDENT> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> dp [ i ] += dp [ max ( 0 , i - left [ j ] ) ] - dp [ max ( 0 , i - right [ j ] - 1 ) ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i ] ) % mod <NEWLINE> <DEDENT> print ( ( dp [ n ] - dp [ n - 1 ] ) % mod ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> import math <NEWLINE> a = r * r * math . pi <NEWLINE> b = r * 2 * math . pi <NEWLINE> print ( <STRING> % ( a , b ) ) <NEWLINE>
<NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ne = 0 <NEWLINE> his = [ None for i in range ( n ) ] <NEWLINE> l = False <NEWLINE> for i in range ( min ( n , k ) ) : <NEWLINE> <INDENT> if his [ ne ] != None : <NEWLINE> <INDENT> back = his [ ne ] <NEWLINE> loop = i - back <NEWLINE> l = True <NEWLINE> break <NEWLINE> <DEDENT> his [ ne ] = i <NEWLINE> <COMMENT> <NL> ne = a [ ne ] - 1 <NEWLINE> <NL> <DEDENT> if l : <NEWLINE> <INDENT> ansidx = ( k - back ) % loop + back <NEWLINE> ans = his . index ( ansidx ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ne + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ss = sum ( a ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ss = ss - a [ i ] <NEWLINE> s += a [ i ] * ss <NEWLINE> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
from scipy . special import comb <NEWLINE> <NL> <NL> s = int ( input ( ) ) <NEWLINE> <NL> if s < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> count = 0 <NEWLINE> total = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s = s - 3 <NEWLINE> count += 1 <NEWLINE> <NL> if s >= 0 : <NEWLINE> <INDENT> total += comb ( s + count - 1 , count - 1 , exact = True ) <NEWLINE> total = total % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( total ) ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> bad = set ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( H [ A - 1 ] <= H [ B - 1 ] ) and ( A - 1 not in bad ) : <NEWLINE> <INDENT> bad . add ( A - 1 ) <NEWLINE> <DEDENT> if ( H [ A - 1 ] >= H [ B - 1 ] ) and ( B - 1 not in bad ) : <NEWLINE> <INDENT> bad . add ( B - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - len ( bad ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> T = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counter = Counter ( S ) <NEWLINE> cnt = 0 <NEWLINE> for i in T : <NEWLINE> <INDENT> cnt += any ( [ counter [ i ] ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for j in range ( n - 2 ) : <NEWLINE> <INDENT> sj = s [ j ] <NEWLINE> for i in range ( 1 , ( n - j ) // 2 + 1 ) : <NEWLINE> <INDENT> if n <= j + 2 * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sd = s [ j + i ] <NEWLINE> sd2 = s [ j + 2 * i ] <NEWLINE> if ( sj != sd ) and ( sj != sd2 ) and ( sd != sd2 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif ans < 10 ** 18 : <NEWLINE> <INDENT> ans *= a <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> r = [ [ ] for i in range ( n ) ] <NEWLINE> start = [ 0 , 0 ] <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> r [ a - 1 ] . append ( b - 1 ) <NEWLINE> r [ b - 1 ] . append ( a - 1 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> from collections import deque <NEWLINE> d = [ 0 for i in range ( n ) ] <NEWLINE> visited = [ False for i in range ( n ) ] <NEWLINE> flg = True <NEWLINE> queue = deque ( [ 0 ] ) <NEWLINE> dd = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> visited [ now ] = True <NEWLINE> <COMMENT> <NL> for i in r [ now ] : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> queue . append ( i ) <NEWLINE> visited [ i ] = True <NEWLINE> d [ i ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( d [ i ] + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> a = [ 0 ] * 1000005 <NEWLINE> A_max = A [ - 1 ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> for j in range ( 1 , A_max // i + 1 ) : <NEWLINE> <INDENT> a [ i * j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if a == [ 0 , 1 ] : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif a == [ 0 , 2 ] : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> if a == [ 1 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> subt = [ 0 ] * ( n ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> subt [ 0 ] = 2 <NEWLINE> <DEDENT> elif a [ 0 ] == 1 : <NEWLINE> <INDENT> subt [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if a [ i + 1 ] > subt [ i ] - 1 : <NEWLINE> <INDENT> if i < n - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif a [ i + 1 ] > subt [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> subt [ i + 1 ] = ( subt [ i ] - a [ i + 1 ] ) * 2 <NEWLINE> <DEDENT> <DEDENT> if a [ n ] > subt [ - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a [ n ] > subt [ - 2 ] : <NEWLINE> <INDENT> subt [ - 1 ] = a [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> subt [ - 1 ] = a [ n ] <NEWLINE> for j in range ( 2 , n ) : <NEWLINE> <INDENT> if ( subt [ - j ] - a [ - j ] ) * 2 < subt [ 1 - j ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( subt [ - j ] - a [ - j ] ) <= subt [ 1 - j ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> subt [ - j ] = subt [ 1 - j ] + a [ - j ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( subt ) + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
from collections import deque <NEWLINE> s = deque ( list ( input ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> isR = - 1 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> line = list ( input ( ) . split ( ) ) <NEWLINE> t = int ( line [ 0 ] ) <NEWLINE> if t == 1 : <NEWLINE> <INDENT> isR *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = int ( line [ 1 ] ) <NEWLINE> if isR + f == 0 or isR + f == 3 : <NEWLINE> <INDENT> s . appendleft ( line [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( line [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> if i == q - 1 and isR == 1 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
RC = input ( ) . split ( ) <NEWLINE> r = int ( RC [ 0 ] ) <NEWLINE> c = int ( RC [ 1 ] ) <NEWLINE> A_c_sum = [ ] <NEWLINE> final_sum = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> A_c_sum . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> A_r = input ( ) . split ( ) <NEWLINE> A_r_sum = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> A_c_sum [ j ] += int ( A_r [ j ] ) <NEWLINE> print ( A_r [ j ] + <STRING> , end = <STRING> ) <NEWLINE> A_r_sum += int ( A_r [ j ] ) <NEWLINE> <DEDENT> print ( A_r_sum ) <NEWLINE> final_sum += A_r_sum <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , A_c_sum ) ) + <STRING> , end = <STRING> ) <NEWLINE> print ( final_sum ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def solve ( H , W , Ch , Cw , Dh , Dw , maze ) : <NEWLINE> <COMMENT> <NL> <INDENT> walled_maze = [ <STRING> . format ( row ) for row in maze ] <NEWLINE> walled_maze . insert ( 0 , <STRING> . format ( <STRING> * W ) ) <NEWLINE> walled_maze . insert ( 0 , <STRING> . format ( <STRING> * W ) ) <NEWLINE> walled_maze . append ( <STRING> . format ( <STRING> * W ) ) <NEWLINE> walled_maze . append ( <STRING> . format ( <STRING> * W ) ) <NEWLINE> <NL> INF = 10 ** 12 <NEWLINE> path = [ [ INF ] * ( W + 4 ) for _ in range ( H + 4 ) ] <NEWLINE> walk = [ ( 0 , 1 ) , ( 0 , - 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) ] <NEWLINE> warp = [ ( i , j ) for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) if ( i , j ) not in [ ( 0 , 0 ) ] + walk ] <NEWLINE> <NL> yet = deque ( ) <NEWLINE> yet . append ( ( Ch + 2 , Cw + 2 , 0 ) ) <COMMENT> <NEWLINE> path [ Ch + 2 ] [ Cw + 2 ] = 0 <NEWLINE> done = deque ( ) <NEWLINE> <NL> while yet : <NEWLINE> <INDENT> y , x , s = yet . popleft ( ) <NEWLINE> done . append ( ( y , x , s ) ) <NEWLINE> for dy , dx in walk : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if walled_maze [ ny ] [ nx ] == <STRING> and path [ ny ] [ nx ] > s : <NEWLINE> <INDENT> path [ ny ] [ nx ] = s <NEWLINE> yet . append ( ( ny , nx , s ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( yet ) == 0 : <NEWLINE> <INDENT> while done : <NEWLINE> <INDENT> y , x , s = done . popleft ( ) <NEWLINE> for dy , dx in warp : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if walled_maze [ ny ] [ nx ] == <STRING> and path [ ny ] [ nx ] > s + 1 : <NEWLINE> <INDENT> path [ ny ] [ nx ] = s + 1 <NEWLINE> yet . append ( ( ny , nx , s + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = path [ Dh + 2 ] [ Dw + 2 ] if path [ Dh + 2 ] [ Dw + 2 ] < INF else - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> Ch , Cw = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> Dh , Dw = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> maze = [ input ( ) for _ in range ( H ) ] <NEWLINE> solve ( H , W , Ch , Cw , Dh , Dw , maze ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> str = input ( ) <NEWLINE> lst = str . split ( ) <NEWLINE> a = int ( lst [ 0 ] ) <NEWLINE> b = int ( lst [ 1 ] ) <NEWLINE> c = int ( lst [ 2 ] ) <NEWLINE> if b > c : <NEWLINE> <INDENT> print ( int ( a * c / b ) - int ( c / b ) * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = int ( c / b ) <NEWLINE> if d > 100 : <NEWLINE> <INDENT> d = 100 <NEWLINE> <DEDENT> lst = np . zeros ( d ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> k = b * ( i + 1 ) - 1 <NEWLINE> lst [ i ] = int ( a * k / b ) - int ( k / b ) * a <NEWLINE> <DEDENT> print ( int ( np . max ( lst ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> t = 0 <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x *= A [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> t = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <NL> <DEDENT>
def list_add ( li1 , li2 ) : <NEWLINE> <INDENT> return list ( map ( sum , zip ( li1 , li2 ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( price , knowledge , depth ) : <NEWLINE> <INDENT> if ( min ( knowledge ) >= X ) : <NEWLINE> <INDENT> ansList . append ( price ) <NEWLINE> <DEDENT> if depth == N : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> dfs ( price , knowledge , depth + 1 ) <NEWLINE> dfs ( price + priceList [ depth ] , <NEWLINE> <INDENT> list_add ( KnowList [ depth ] , knowledge ) , depth + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M , X = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> KnowList = [ [ ] for i in range ( N ) ] <NEWLINE> priceList = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> priceList [ i ] = tmp [ 0 ] <NEWLINE> KnowList [ i ] = tmp [ 1 : ] <NEWLINE> <DEDENT> price = 0 <NEWLINE> ansList = [ ] <NEWLINE> knowledge = [ 0 ] * M <NEWLINE> dfs ( price , knowledge , 0 ) <NEWLINE> if ( len ( ansList ) == 0 ) : <NEWLINE> <INDENT> ansList . append ( - 1 ) <NEWLINE> <DEDENT> print ( min ( ansList ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> plus = [ 0 ] * N <NEWLINE> <COMMENT> <NL> minus = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> plus [ i ] = i + 1 + A [ i ] <NEWLINE> minus [ i ] = i + 1 - A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> plus = dict ( collections . Counter ( plus ) ) <NEWLINE> minus = dict ( collections . Counter ( minus ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in plus . keys ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i in minus : <NEWLINE> <COMMENT> <NL> <INDENT> ans += plus [ i ] * minus [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> def inpl ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> if C [ - 2 ] % 2 == 0 : <NEWLINE> <INDENT> ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] <NEWLINE> print ( len ( ans ) ) <NEWLINE> if len ( ans ) : <NEWLINE> <INDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif C [ - 1 ] > 0 : <NEWLINE> <INDENT> ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] + [ A . index ( - 1 ) + 1 ] <NEWLINE> print ( len ( ans ) ) <NEWLINE> if len ( ans ) : <NEWLINE> <INDENT> print ( * sorted ( ans ) , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d = N - A [ : : - 1 ] . index ( - 2 ) <NEWLINE> ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] <NEWLINE> del ans [ ans . index ( d ) ] <NEWLINE> print ( len ( ans ) ) <NEWLINE> if len ( ans ) : <NEWLINE> <INDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n , m , l = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> nm = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> ml = [ [ 0 for i in range ( l ) ] for j in range ( m ) ] <NEWLINE> nl = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> nm [ i ] = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> nm [ i ] [ j ] = int ( nm [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ml [ i ] = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> ml [ i ] [ j ] = int ( ml [ i ] [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> nl [ i ] [ j ] += nm [ i ] [ k ] * ml [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> print ( nl [ i ] [ j ] , end = <STRING> if j != l - 1 else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> x = 0 <NEWLINE> for l in lst : <NEWLINE> <INDENT> x ^= l <NEWLINE> <DEDENT> out = <STRING> <NEWLINE> for l in lst : <NEWLINE> <INDENT> out += <STRING> + str ( x ^ l ) <NEWLINE> <DEDENT> print ( out [ 1 : ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> BIG = 10 ** 9 + 7 <NEWLINE> <NL> def sumpp ( n , a ) : <NEWLINE> <INDENT> acc = 0 <NEWLINE> tmp = 0 <NEWLINE> sumv = sum ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp += a [ i ] <NEWLINE> acc += a [ i ] * ( sumv - tmp ) <NEWLINE> <DEDENT> return acc % BIG <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sumpp ( n , a ) ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> check = [ ] <NEWLINE> check2 = [ ] <NEWLINE> for i in range ( 1 , 33 ) : <NEWLINE> <INDENT> for s in range ( 2 , 11 ) : <NEWLINE> <INDENT> check . append ( pow ( i , s ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in check : <NEWLINE> <INDENT> if i <= X : <NEWLINE> <INDENT> check2 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( check2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if al . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in al : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> class Node ( object ) : <NEWLINE> <INDENT> def __init__ ( self , p , l , r ) : <NEWLINE> <INDENT> self . p = p <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> <NL> <DEDENT> <DEDENT> nodes = [ Node ( None , None , None ) for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> id , left , right = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes [ id ] . l = left <NEWLINE> nodes [ id ] . r = right <NEWLINE> if left != - 1 : <NEWLINE> <INDENT> nodes [ left ] . p = i <NEWLINE> <DEDENT> if right != - 1 : <NEWLINE> <INDENT> nodes [ right ] . p = i <NEWLINE> <NL> <DEDENT> <DEDENT> def pre ( node , path ) : <NEWLINE> <INDENT> path . append ( node ) <NEWLINE> if nodes [ node ] . l != - 1 : <NEWLINE> <INDENT> pre ( nodes [ node ] . l , path ) <NEWLINE> <DEDENT> if nodes [ node ] . r != - 1 : <NEWLINE> <INDENT> pre ( nodes [ node ] . r , path ) <NEWLINE> <NL> <DEDENT> <DEDENT> def ino ( node , path ) : <NEWLINE> <INDENT> if nodes [ node ] . l != - 1 : <NEWLINE> <INDENT> ino ( nodes [ node ] . l , path ) <NEWLINE> <DEDENT> path . append ( node ) <NEWLINE> if nodes [ node ] . r != - 1 : <NEWLINE> <INDENT> ino ( nodes [ node ] . r , path ) <NEWLINE> <NL> <DEDENT> <DEDENT> def post ( node , path ) : <NEWLINE> <INDENT> if nodes [ node ] . l != - 1 : <NEWLINE> <INDENT> post ( nodes [ node ] . l , path ) <NEWLINE> <DEDENT> if nodes [ node ] . r != - 1 : <NEWLINE> <INDENT> post ( nodes [ node ] . r , path ) <NEWLINE> <DEDENT> path . append ( node ) <NEWLINE> <NL> <DEDENT> for ind , n in enumerate ( nodes ) : <NEWLINE> <INDENT> if n . p == None : <NEWLINE> <INDENT> root = ind <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> l = [ ] <NEWLINE> pre ( root , l ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , l ) ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> l = [ ] <NEWLINE> ino ( root , l ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , l ) ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> l = [ ] <NEWLINE> post ( root , l ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , l ) ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a + b >= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = sorted ( a , reverse = True ) <NEWLINE> <NL> <NL> ans = 1 <NEWLINE> <NL> if min ( b ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= b [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
cnt = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( min ( li ) , max ( li ) , sum ( li ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> prd = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> prd *= a [ i ] <NEWLINE> if prd > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( prd ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> import math , sys , heapq <NEWLINE> from itertools import permutations , combinations <NEWLINE> from collections import defaultdict , deque , OrderedDict <NEWLINE> from os import path <NEWLINE> import bisect as bi <NEWLINE> def yes ( ) : print ( <STRING> ) <NEWLINE> def no ( ) : print ( <STRING> ) <NEWLINE> if ( path . exists ( <STRING> ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) ; sys . stdout = open ( <STRING> , <STRING> ) ; <NEWLINE> def I ( ) : return ( int ( input ( ) ) ) <NEWLINE> def In ( ) : return ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> def I ( ) : return ( int ( stdin . readline ( ) ) ) <NEWLINE> def In ( ) : return ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def dict ( a ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for x in a : <NEWLINE> <INDENT> if d . get ( x , - 1 ) != - 1 : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def find_gt ( a , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i = bi . bisect_right ( a , x ) <NEWLINE> if i != len ( a ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n , k = In ( ) <NEWLINE> l = list ( In ( ) ) <NEWLINE> ans = [ ] <NEWLINE> t = 1 <NEWLINE> last = 1 <NEWLINE> for x in range ( k , n ) : <NEWLINE> <INDENT> if l [ x - k ] >= l [ x ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> M = 998244353 <NEWLINE> P = 1000000007 <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> for _ in range ( 1 ) : main ( ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> res = len ( t ) <NEWLINE> num = 0 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ j ] != s [ i + j ] : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> res = min ( res , num ) <NEWLINE> num = 0 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import numpy as np <NEWLINE> <NL> import heapq <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> od = 998244353 <NEWLINE> n , k , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n_c_i = [ 1 ] <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> n_c_i . append ( ( n_c_i [ - 1 ] * ( n - i ) * pow ( i , od - 2 , od ) ) % od ) <NEWLINE> <COMMENT> <NL> <DEDENT> pow_k = pow ( k - 1 , n - 1 , od ) <NEWLINE> inv_k = pow ( k - 1 , od - 2 , od ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( x + 1 ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> p_k = ( k * pow ( k - 1 , n - i - 1 , od ) ) % od <NEWLINE> <COMMENT> <NL> ans += ( n_c_i [ i ] * p_k ) % od <NEWLINE> ans %= od <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> print ( <STRING> , c , <STRING> ) <NEWLINE>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fromleft = list ( accumulate ( a , math . gcd ) ) <NEWLINE> fromright = list ( accumulate ( a [ : : - 1 ] , math . gcd ) ) [ : : - 1 ] <NEWLINE> <NL> gcd = [ ] <NEWLINE> <NL> gcd . append ( fromright [ 1 ] ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> gcd . append ( math . gcd ( fromleft [ i - 1 ] , fromright [ i + 1 ] ) ) <NEWLINE> <DEDENT> gcd . append ( fromleft [ n - 2 ] ) <NEWLINE> <NL> print ( max ( gcd ) ) <NEWLINE>
W = int ( input ( ) ) <NEWLINE> <NL> w3 = [ ] <NEWLINE> <NL> while W > 0 : <NEWLINE> <INDENT> w3 . append ( W % 3 ) <NEWLINE> W = W // 3 <NEWLINE> <DEDENT> w3 . append ( 0 ) <NEWLINE> <NL> for i in range ( len ( w3 ) - 1 ) : <NEWLINE> <INDENT> if w3 [ i ] > 1 : <NEWLINE> <INDENT> w3 [ i ] = w3 [ i ] - 3 <NEWLINE> w3 [ i + 1 ] = w3 [ i + 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> w3 . reverse ( ) <NEWLINE> <NL> if w3 [ 0 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif w3 [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( w3 ) ) : <NEWLINE> <INDENT> if w3 [ i ] == 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif w3 [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif w3 [ i ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = { } <NEWLINE> R = { } <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l = ( i + 1 ) - A [ i ] <NEWLINE> r = A [ i ] + i + 1 <NEWLINE> if ( l in R . keys ( ) ) : <NEWLINE> <INDENT> res += len ( R [ l ] ) <NEWLINE> <DEDENT> if ( r in R . keys ( ) ) : <NEWLINE> <INDENT> R [ r ] . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ r ] = [ i + 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import copy <NEWLINE> T = list ( input ( ) ) <NEWLINE> P = [ 0 ] * ( len ( T ) + 10 ) <NEWLINE> P [ 0 ] = 0 <NEWLINE> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> P [ i + 1 ] = P [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> P [ i + 1 ] = P [ i ] + 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> P [ i + 1 ] += P [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P [ i + 1 ] = P [ i ] + 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> P [ i + 1 ] = P [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> adj = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> q = deque ( ) <NEWLINE> <NL> dist = [ - 1 ] * n <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> q . append ( 0 ) <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for to in adj [ now ] : <NEWLINE> <INDENT> if dist [ to ] != - 1 : continue <NEWLINE> dist [ to ] = dist [ now ] + 1 <NEWLINE> q . append ( to ) <NEWLINE> ans [ to ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for h in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> l = gcd ( h , i ) <NEWLINE> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( l , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> div = [ ] <NEWLINE> for x in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> if c % x == 0 : <NEWLINE> <INDENT> div . append ( x ) <NEWLINE> <DEDENT> <DEDENT> r = [ ] <NEWLINE> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> r . append ( x ) <NEWLINE> <DEDENT> answer = 0 <NEWLINE> for x in div : <NEWLINE> <INDENT> for y in r : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> p = [ 0 ] + list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = np . zeros ( ( 3100 , 3100 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> dp [ 1 , 0 ] = 1 - p [ 1 ] <NEWLINE> dp [ 1 , 1 ] = p [ 1 ] <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] = np . roll ( dp [ i - 1 ] , 1 ) * p [ i ] + dp [ i - 1 ] * ( 1 - p [ i ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for k in range ( - ( - N // 2 ) , N + 1 ) : <NEWLINE> <INDENT> ans += dp [ N , k ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
class BinarySearchTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> node = self . Node ( x ) <NEWLINE> if self . root is None : <NEWLINE> <INDENT> self . root = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> here = self . root <NEWLINE> <COMMENT> <NL> temp = None <NEWLINE> while here is not None : <NEWLINE> <INDENT> temp = here <NEWLINE> if x < here . node : <NEWLINE> <INDENT> here = here . left <NEWLINE> <DEDENT> elif x > here . node : <NEWLINE> <INDENT> here = here . right <NEWLINE> <DEDENT> <DEDENT> if x < temp . node : <NEWLINE> <INDENT> temp . left = node <NEWLINE> <DEDENT> elif x > temp . node : <NEWLINE> <INDENT> temp . right = node <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def inorder ( self , answer , address = <STRING> ) : <NEWLINE> <INDENT> if address is <STRING> : <NEWLINE> <INDENT> address = self . root <NEWLINE> <DEDENT> elif address is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . inorder ( answer , address . left ) <NEWLINE> answer . append ( address . node ) <NEWLINE> self . inorder ( answer , address . right ) <NEWLINE> <NL> <DEDENT> def preorder ( self , answer , address = <STRING> ) : <NEWLINE> <INDENT> if address is <STRING> : <NEWLINE> <INDENT> address = self . root <NEWLINE> <DEDENT> elif address is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> answer . append ( address . node ) <NEWLINE> self . preorder ( answer , address . left ) <NEWLINE> self . preorder ( answer , address . right ) <NEWLINE> <NL> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . node = x <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> query = int ( input ( ) ) <NEWLINE> bt = BinarySearchTree ( ) <NEWLINE> for _ in range ( query ) : <NEWLINE> <INDENT> command = input ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> bt . insert ( int ( command . split ( <STRING> ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ ] <NEWLINE> bt . inorder ( a ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * a ) <NEWLINE> a = [ ] <NEWLINE> bt . preorder ( a ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = an . count ( 0 ) <NEWLINE> if x >= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= an [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if K == 1 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> factorial = [ 1 for i in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i == 1 : factorial [ i ] = 1 <NEWLINE> else : factorial [ i ] = factorial [ i - 1 ] * i % mod <NEWLINE> <NL> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> return factorial [ n ] * pow ( factorial [ n - k ] * factorial [ k ] , - 1 , mod ) <NEWLINE> <NL> <DEDENT> A1 = sorted ( A ) <NEWLINE> A2 = A1 [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans += ( A2 [ i ] - A1 [ i ] ) * comb ( N - i - 1 , K - 1 ) <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> ans_over = 0 <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> ans_over = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans_over == 1 : <NEWLINE> <INDENT> if ans != 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <COMMENT> <NL> def kenzan ( P , w , n , k ) : <NEWLINE> <COMMENT> <NL> <INDENT> t = 1 <COMMENT> <NEWLINE> s = 0 <COMMENT> <NEWLINE> st = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = s + w [ i ] <NEWLINE> <COMMENT> <NL> if x > P : <COMMENT> <NEWLINE> <INDENT> t += 1 <NEWLINE> st += s <NEWLINE> s = w [ i ] <NEWLINE> <COMMENT> <NL> if t > k : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> return st <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> istr = sys . stdin . read ( ) <NEWLINE> wi = list ( map ( int , istr . splitlines ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> P = 0 <NEWLINE> total = 0 <NEWLINE> min = 100000 <NEWLINE> for w in wi : <NEWLINE> <INDENT> if P < w : <NEWLINE> <INDENT> P = w <NEWLINE> <DEDENT> if min > w : <NEWLINE> <INDENT> min = w <NEWLINE> <DEDENT> total += w <NEWLINE> <DEDENT> na = int ( total / n ) <COMMENT> <NEWLINE> if total % n > 0 : <NEWLINE> <INDENT> na += 1 <NEWLINE> <DEDENT> ka = int ( total / k ) <COMMENT> <NEWLINE> if total % k > 0 : <NEWLINE> <INDENT> ka += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if P < na : <NEWLINE> <INDENT> P = na <NEWLINE> <DEDENT> if P < ka : <NEWLINE> <INDENT> P = ka <NEWLINE> <DEDENT> z = 0 <NEWLINE> while P <= total : <NEWLINE> <INDENT> st = kenzan ( P , wi , n , k ) <NEWLINE> <COMMENT> <NL> if st == 0 : <NEWLINE> <INDENT> a = P - z <NEWLINE> b = P <NEWLINE> break <NEWLINE> <DEDENT> z = int ( ( total - st ) / k ) <NEWLINE> if z < 1 : <NEWLINE> <INDENT> z = 1 <NEWLINE> <DEDENT> P += z <NEWLINE> <NL> <DEDENT> while b - a > 0 : <NEWLINE> <INDENT> x = int ( ( b - a ) / 2 ) <NEWLINE> if x < 1 : <NEWLINE> <INDENT> a = b <NEWLINE> <DEDENT> P = x + a <NEWLINE> st = kenzan ( P , wi , n , k ) <NEWLINE> <COMMENT> <NL> if st == 0 : <NEWLINE> <INDENT> b = P <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = P <NEWLINE> <NL> <DEDENT> <DEDENT> print ( P ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> input_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> max_num = 10 ** 18 <NEWLINE> <NL> sum_num = 1 <NEWLINE> if 0 in input_list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in input_list : <NEWLINE> <INDENT> sum_num *= i <NEWLINE> if sum_num > max_num : <NEWLINE> <INDENT> sum_num = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum_num ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( n ) <NEWLINE> if k + 1 <= n : <NEWLINE> <INDENT> max = k + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = n <NEWLINE> <NL> <DEDENT> for i in range ( 1 , max ) : <NEWLINE> <INDENT> dp [ i ] = abs ( h [ 0 ] - h [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> li = [ abs ( h [ i ] - h [ ik ] ) + dp [ ik ] for ik in range ( i - 1 , i - k - 1 , - 1 ) ] <NEWLINE> dp [ i ] = min ( li ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> a = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> b = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 0 , N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ K + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( a [ 0 ] // ( 2 ** m ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> while m > 0 : <NEWLINE> <INDENT> m -= 1 <NEWLINE> i = heapq . heappop ( a ) * ( - 1 ) <NEWLINE> i //= 2 <NEWLINE> heapq . heappush ( a , i * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> if k <= a : <NEWLINE> <INDENT> count = 1 * k <NEWLINE> <DEDENT> elif a < k and k <= ( a + b ) : <NEWLINE> <INDENT> count = 1 * a <NEWLINE> <DEDENT> elif ( a + b ) < k and k <= ( a + b + c ) : <NEWLINE> <INDENT> count = 1 * a + ( - 1 ) * ( k - a - b ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( H ) : <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if X > 0 : <NEWLINE> <INDENT> if X - D * K > 0 : <NEWLINE> <INDENT> print ( X - D * K ) <NEWLINE> <DEDENT> elif ( X // D - K ) % 2 == 0 : <NEWLINE> <INDENT> print ( min ( abs ( X - ( X // D ) * D ) , abs ( X - ( ( X // D ) + 2 ) * D ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( X - ( ( X // D ) - 1 ) * D ) , abs ( X - ( ( X // D ) + 1 ) * D ) ) ) <NEWLINE> <DEDENT> <DEDENT> elif X == 0 : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if X + D * K < 0 : <NEWLINE> <INDENT> print ( abs ( X + D * K ) ) <NEWLINE> <DEDENT> elif ( ( - X ) // D - K ) % 2 == 0 : <NEWLINE> <INDENT> print ( min ( abs ( X + ( ( - X ) // D ) * D ) , abs ( X + ( ( ( - X ) // D ) + 2 ) * D ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( X + ( ( ( - X ) // D ) - 1 ) * D ) , abs ( X + ( ( ( - X ) // D ) + 1 ) * D ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> i = str ( input ( ) ) <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> t = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> t += 1 <NEWLINE> print ( <STRING> + str ( t ) + <STRING> + i ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 3 ] == S [ 2 ] and S [ 5 ] == S [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> field = <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> field += input ( ) <NEWLINE> <NL> <DEDENT> def bfs ( start ) : <NEWLINE> <INDENT> dist = [ 0 ] * ( H * W ) <NEWLINE> q = deque ( [ start ] ) <NEWLINE> while q : <NEWLINE> <INDENT> p = q . popleft ( ) <NEWLINE> c = dist [ p ] + 1 <NEWLINE> if p - W != start and p - W >= 0 and field [ p - W ] == <STRING> and dist [ p - W ] == 0 : <NEWLINE> <INDENT> dist [ p - W ] = c <NEWLINE> q . append ( p - W ) <NEWLINE> <DEDENT> if p + W != start and p + W < H * W and field [ p + W ] == <STRING> and dist [ p + W ] == 0 : <NEWLINE> <INDENT> dist [ p + W ] = c <NEWLINE> q . append ( p + W ) <NEWLINE> <DEDENT> if p - 1 != start and p - 1 >= 0 and field [ p - 1 ] == <STRING> and dist [ p - 1 ] == 0 and p % W != 0 : <NEWLINE> <INDENT> dist [ p - 1 ] = c <NEWLINE> q . append ( p - 1 ) <NEWLINE> <DEDENT> if p + 1 != start and p + 1 < H * W and field [ p + 1 ] == <STRING> and dist [ p + 1 ] == 0 and p % W != W - 1 : <NEWLINE> <INDENT> dist [ p + 1 ] = c <NEWLINE> q . append ( p + 1 ) <NEWLINE> <DEDENT> <DEDENT> return dist [ p ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for s in range ( H * W ) : <NEWLINE> <INDENT> if field [ s ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , bfs ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( i , j ) <NEWLINE> if j == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( i , math . gcd ( j , k ) ) * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( A ) <NEWLINE> num = [ 0 ] * 100001 <NEWLINE> for i in A : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( C - B ) * num [ B ] <NEWLINE> num [ C ] += num [ B ] <NEWLINE> num [ B ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a = s . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = s . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> c = s . find ( str ( k ) , b + 1 ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = gcd ( x , y ) <NEWLINE> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , z ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> thres = 10 ** 18 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans = i * ans <NEWLINE> if ans > thres : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> maxcount = [ 0 ] * N <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ( H [ i ] >= H [ i + 1 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> maxcount [ i ] = count <NEWLINE> <NL> <DEDENT> print ( max ( maxcount ) ) <NEWLINE>
num = 7 <NEWLINE> k = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> <COMMENT> <NL> while ( True ) : <NEWLINE> <INDENT> if ( ( num % k ) == 0 ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> if ( count > k ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> num = ( num * 10 + 7 ) % k <NEWLINE> count += 1 <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> p_buy = R [ 0 ] <NEWLINE> p_sale = R [ 1 ] <NEWLINE> buy = R [ 1 ] <NEWLINE> sale = None <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if p_sale < R [ i ] : <NEWLINE> <INDENT> p_sale = R [ i ] <NEWLINE> <DEDENT> if buy > R [ i ] : <NEWLINE> <INDENT> if sale is None : <NEWLINE> <INDENT> sale = R [ i ] <NEWLINE> <DEDENT> if p_sale - p_buy < sale - buy : <NEWLINE> <INDENT> p_sale , p_buy = sale , buy <NEWLINE> <DEDENT> sale , buy = None , R [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sale is None or sale < R [ i ] : <NEWLINE> <INDENT> sale = R [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> p_gain = p_sale - p_buy <NEWLINE> print ( p_gain if sale is None else max ( p_gain , sale - buy ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in m : <NEWLINE> <INDENT> a [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
T = list ( input ( ) ) <NEWLINE> <NL> if len ( T ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> if T [ 1 ] == <STRING> : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ 0 ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( T ) - 1 ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> and ( T [ i + 1 ] == <STRING> or T [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if T [ - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE> <NL>
k_num , s_num = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in range ( k_num + 1 ) : <NEWLINE> <INDENT> l = s_num - x <NEWLINE> for y in range ( k_num + 1 ) : <NEWLINE> <INDENT> z = l - y <NEWLINE> if 0 <= z <= k_num : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mul = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> mul = mul + l [ i ] <NEWLINE> <DEDENT> z = mul <NEWLINE> j = 0 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> z = z - l [ j ] <NEWLINE> z = z + l [ i ] <NEWLINE> if z > mul : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> mul = z <NEWLINE> <DEDENT>
_counts = [ 0 for i in range ( 100001 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> _counts [ a [ i ] ] += 1 <NEWLINE> <DEDENT> _sum = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> _sum += ( c - b ) * _counts [ b ] <NEWLINE> print ( _sum ) <NEWLINE> _counts [ c ] += _counts [ b ] <NEWLINE> _counts [ b ] = 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> M = max ( a ) <NEWLINE> cands = [ 0 ] * M <NEWLINE> <NL> ans = 0 <NEWLINE> for num in a : <NEWLINE> <INDENT> if cands [ num - 1 ] >= 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i in range ( num , M + 1 , num ) : <NEWLINE> <INDENT> cands [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for num in a : <NEWLINE> <INDENT> if cands [ num - 1 ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> final = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> final *= i <NEWLINE> if final > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if final > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( final ) <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n = k ( ) - 1 <NEWLINE> i = 1 <NEWLINE> s = 26 <NEWLINE> <NL> while n >= s : <NEWLINE> <INDENT> n -= s <NEWLINE> s *= 26 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> lst = [ ] <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> lst . append ( n % 26 ) <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> for j in lst [ : : - 1 ] : <NEWLINE> <INDENT> print ( chr ( j + ord ( <STRING> ) ) , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 0 <COMMENT> <NEWLINE> a_time = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_time = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> a_num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += a_time [ i ] <NEWLINE> a_num += 1 <NEWLINE> if sum > K : <NEWLINE> <INDENT> sum -= a_time [ i ] <NEWLINE> a_num -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i = a_num <NEWLINE> j = 0 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> while sum < K and j < M : <NEWLINE> <INDENT> sum += b_time [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> if sum > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> sum -= b_time [ j ] <NEWLINE> <DEDENT> if result < i + j : <NEWLINE> <INDENT> result = i + j <NEWLINE> <DEDENT> i -= 1 <NEWLINE> sum -= a_time [ i ] <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> p = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( p , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r_H = list ( reversed ( H ) ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if r_H [ i + 1 ] - r_H [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if r_H [ i + 1 ] - r_H [ i ] == 1 : <NEWLINE> <INDENT> r_H [ i + 1 ] = r_H [ i + 1 ] - 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> _ = input ( ) <NEWLINE> N = sorted ( [ int ( v ) for v in input ( ) . split ( ) ] ) <NEWLINE> s = 1 <NEWLINE> for n in N : <NEWLINE> <INDENT> s *= n <NEWLINE> if s == 0 or s > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s if s <= 10 ** 18 else - 1 ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> original_pop_count = x . count ( <STRING> ) <NEWLINE> one_pop_count = original_pop_count - 1 <NEWLINE> zero_pop_count = original_pop_count + 1 <NEWLINE> <NL> one_mod = 0 <NEWLINE> zero_mod = 0 <NEWLINE> for b in x : <NEWLINE> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> one_mod = ( one_mod * 2 + int ( b ) ) % one_pop_count <NEWLINE> <DEDENT> zero_mod = ( zero_mod * 2 + int ( b ) ) % zero_pop_count <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> f = [ 0 ] * 220000 <NEWLINE> pop_count = [ 0 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> pop_count [ i ] = pop_count [ i // 2 ] + i % 2 <NEWLINE> f [ i ] = f [ i % pop_count [ i ] ] + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> one_pow2 = [ 1 ] * 220000 <NEWLINE> zero_pow2 = [ 1 ] * 220000 <NEWLINE> for i in range ( 1 , 220000 ) : <NEWLINE> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> one_pow2 [ i ] = one_pow2 [ i - 1 ] * 2 % one_pop_count <NEWLINE> <DEDENT> zero_pow2 [ i ] = zero_pow2 [ i - 1 ] * 2 % zero_pop_count <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> if one_pop_count != 0 : <NEWLINE> <INDENT> nxt = one_mod <NEWLINE> nxt -= one_pow2 [ i ] <NEWLINE> nxt %= one_pop_count <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if x [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> nxt = zero_mod <NEWLINE> nxt += zero_pow2 [ i ] <NEWLINE> nxt %= zero_pop_count <NEWLINE> print ( f [ nxt ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> k = N - i - j <NEWLINE> if 1000 * i + j * 5000 + k * 10000 == Y and i + j + k == N and k >= 0 : <NEWLINE> <INDENT> print ( k , j , i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in reversed ( range ( m + 1 ) ) : <NEWLINE> <INDENT> if a [ i ] + b [ j ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> m = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 12 ) : <NEWLINE> <INDENT> if n <= pow ( 26 , i ) : <NEWLINE> <INDENT> d = i <NEWLINE> break <NEWLINE> <DEDENT> n = n - pow ( 26 , i ) <NEWLINE> <DEDENT> d = d - 1 <NEWLINE> n = n - 1 <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> tmp = divmod ( n , pow ( 26 , d - i ) ) <NEWLINE> ans = ans + chr ( 97 + tmp [ 0 ] ) <NEWLINE> n = tmp [ 1 ] <NEWLINE> <DEDENT> print ( ans + chr ( 97 + n ) ) <NEWLINE>
import itertools as itl <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cmb = list ( itl . combinations ( A , i + 1 ) ) <NEWLINE> for j in cmb : <NEWLINE> <INDENT> S . append ( sum ( j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for m in M : <NEWLINE> <INDENT> flg = False <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == m : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ca_list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ca_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> l = [ True , False ] <NEWLINE> <NL> <COMMENT> <NL> <NL> value_list = [ ] <NEWLINE> for is_buy_list in itertools . product ( l , repeat = n ) : <NEWLINE> <INDENT> sum_l = np . array ( [ 0 ] * ( m + 1 ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if is_buy_list [ i ] : <NEWLINE> <INDENT> sum_l += np . array ( ca_list [ i ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if min ( sum_l [ 1 : ] ) >= x : <NEWLINE> <COMMENT> <NL> <INDENT> value_list . append ( sum_l [ 0 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if len ( value_list ) > 0 : <NEWLINE> <INDENT> print ( min ( value_list ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> z . sort ( ) <NEWLINE> a = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if z [ 1 ] == z [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = z [ 1 ] - z [ 0 ] <NEWLINE> if z [ 0 ] % a == 0 : <NEWLINE> <INDENT> z [ 1 ] = z [ 0 ] <NEWLINE> z [ 0 ] = a <NEWLINE> z . sort ( ) <NEWLINE> break <NEWLINE> <DEDENT> z [ 1 ] = z [ 0 ] <NEWLINE> z [ 0 ] = a <NEWLINE> z . sort ( ) <NEWLINE> <NL> <DEDENT> print ( z [ 0 ] ) <NEWLINE>
N , M = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> hito = [ 0 for i in range ( N ) ] <NEWLINE> edge = [ set ( ) for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> edge [ a - 1 ] . add ( b - 1 ) <NEWLINE> edge [ b - 1 ] . add ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( start ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> reach = set ( ) <NEWLINE> reach . add ( start ) <NEWLINE> hito [ start ] = 1 <NEWLINE> while reach : <NEWLINE> <INDENT> _from = reach . pop ( ) <NEWLINE> for _to in edge [ _from ] : <NEWLINE> <INDENT> if not ( _to in reach ) and hito [ _to ] == 0 : <NEWLINE> <INDENT> reach . add ( _to ) <NEWLINE> count += 1 <NEWLINE> hito [ _to ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( count ) <NEWLINE> <NL> <NL> <DEDENT> ans = set ( ) <NEWLINE> for h in range ( N ) : <NEWLINE> <INDENT> if hito [ h ] == 0 : <NEWLINE> <INDENT> ans . add ( dfs ( h ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> a = 1000 <NEWLINE> c = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if l [ i ] > l [ i + 1 ] : <NEWLINE> <INDENT> a += c * l [ i ] <NEWLINE> c = 0 <NEWLINE> <DEDENT> if l [ i ] < l [ i + 1 ] : <NEWLINE> <INDENT> while a >= l [ i ] : <NEWLINE> <INDENT> t = a // l [ i ] <NEWLINE> a -= t * l [ i ] <NEWLINE> c += t <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a + c * l [ n - 1 ] ) <NEWLINE>
class Checker : <NEWLINE> <INDENT> d = { <NEWLINE> <INDENT> 1 : { 2 : ( 3 , 4 , 5 , 6 ) , 3 : ( 5 , 2 , 4 , 6 ) , 4 : ( 2 , 5 , 3 , 6 ) , 5 : ( 4 , 3 , 2 , 6 ) } , <NEWLINE> 2 : { 1 : ( 4 , 3 , 6 , 5 ) , 3 : ( 1 , 6 , 4 , 5 ) , 4 : ( 6 , 1 , 3 , 5 ) , 6 : ( 3 , 4 , 1 , 5 ) } , <NEWLINE> 3 : { 1 : ( 2 , 5 , 6 , 4 ) , 2 : ( 6 , 1 , 5 , 4 ) , 5 : ( 1 , 6 , 2 , 4 ) , 6 : ( 5 , 2 , 1 , 4 ) } , <NEWLINE> 4 : { 1 : ( 5 , 2 , 6 , 3 ) , 2 : ( 1 , 6 , 5 , 3 ) , 5 : ( 6 , 1 , 2 , 3 ) , 6 : ( 2 , 5 , 1 , 3 ) } , <NEWLINE> 5 : { 1 : ( 3 , 4 , 6 , 2 ) , 3 : ( 6 , 1 , 4 , 2 ) , 4 : ( 1 , 6 , 3 , 2 ) , 6 : ( 4 , 3 , 1 , 2 ) } , <NEWLINE> 6 : { 2 : ( 4 , 3 , 5 , 1 ) , 3 : ( 2 , 5 , 4 , 1 ) , 4 : ( 5 , 2 , 3 , 1 ) , 5 : ( 3 , 4 , 2 , 1 ) } <NEWLINE> } <NEWLINE> <NL> <DEDENT> def __init__ ( self , s ) : <NEWLINE> <INDENT> l = s . split ( ) <NEWLINE> self . tbl = { } <NEWLINE> for c , i in zip ( l , range ( 1 , 7 ) ) : <NEWLINE> <INDENT> if c in self . tbl : <NEWLINE> <INDENT> self . tbl [ c ] . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . tbl [ c ] = [ i ] <NEWLINE> <DEDENT> <DEDENT> self . pip = dict ( zip ( range ( 1 , 7 ) , l ) ) <NEWLINE> <NL> <DEDENT> def __call__ ( self , s ) : <NEWLINE> <INDENT> l = s . split ( ) <NEWLINE> <NL> if not ( l [ 0 ] in self . tbl ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if not ( l [ 1 ] in self . tbl ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i0 in self . tbl [ l [ 0 ] ] : <NEWLINE> <INDENT> for i1 in self . tbl [ l [ 1 ] ] : <NEWLINE> <INDENT> if i1 in self . d [ i0 ] : <NEWLINE> <INDENT> for i , j in zip ( self . d [ i0 ] [ i1 ] , range ( 2 , 6 ) ) : <NEWLINE> <INDENT> if self . pip [ i ] != l [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def g ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) - 1 <NEWLINE> c = Checker ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> yield c ( input ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if any ( g ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> z = True <NEWLINE> j = 0 <NEWLINE> <NL> if 1 not in a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> if a [ k ] == count + 1 : <NEWLINE> <INDENT> j = k <NEWLINE> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - count ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> if a < c : <NEWLINE> <INDENT> x = a <NEWLINE> if b < c : <NEWLINE> <INDENT> y = b <NEWLINE> z = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = c <NEWLINE> z = b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = c <NEWLINE> y = a <NEWLINE> z = b <NEWLINE> <DEDENT> <DEDENT> elif a < c : <NEWLINE> <INDENT> x = b <NEWLINE> y = a <NEWLINE> z = c <NEWLINE> <DEDENT> elif b < c : <NEWLINE> <INDENT> x = b <NEWLINE> y = c <NEWLINE> z = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = c <NEWLINE> y = b <NEWLINE> z = a <NEWLINE> <NL> <DEDENT> print ( x , y , z ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> <NL> mod = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> @ lru_cache <NEWLINE> def gcd1_tuples ( k ) : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> tmp = pow ( k , N , mod ) <NEWLINE> for j in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> tmp -= gcd1_tuples ( k // j ) <NEWLINE> tmp %= mod <NEWLINE> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s += gcd1_tuples ( K // i ) * i <NEWLINE> s %= mod <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE> <NL> <NL>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( pow ( 10 , 6 ) + 1 ) <NEWLINE> ans [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , pow ( 10 , 6 ) ) : <NEWLINE> <INDENT> ans [ i ] = ( ans [ i - 1 ] * 10 + 7 ) % K <NEWLINE> if ans [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( accumulate ( a ) ) <NEWLINE> x = 10 ** 10 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x = min ( x , abs ( l [ i ] * 2 - l [ - 1 ] ) ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n > 2 and m > 2 : <NEWLINE> <INDENT> ans = ( n - 2 ) * ( m - 2 ) <NEWLINE> <DEDENT> elif n == 2 or m == 2 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif n == 1 and m == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> ans = m - 2 <NEWLINE> <DEDENT> elif m == 1 : <NEWLINE> <INDENT> ans = n - 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import copy <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> total = copy . copy ( t ) <NEWLINE> total [ a - 1 ] = b <NEWLINE> print ( sum ( total ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> route = [ [ ] for i in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> route [ a - 1 ] . append ( b ) <NEWLINE> <NL> <DEDENT> for i in route [ 0 ] : <NEWLINE> <INDENT> if len ( route ) != 1 : <NEWLINE> <INDENT> for j in route [ i - 1 ] : <NEWLINE> <INDENT> if j == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> q = [ sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * ( N - i + 1 ) <NEWLINE> <DEDENT> for qi in q : <NEWLINE> <INDENT> u , v = qi [ 0 ] , qi [ 1 ] <NEWLINE> ans -= u * ( N - v + 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> num_count = [ False ] * 10 <NEWLINE> for i in range ( len ( S ) - 2 ) : <NEWLINE> <INDENT> s_i = int ( S [ i ] ) <NEWLINE> if num_count [ s_i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_count [ s_i ] = True <NEWLINE> num_count_2 = [ False ] * 10 <NEWLINE> for j in range ( i + 1 , len ( S ) - 1 ) : <NEWLINE> <INDENT> s_j = int ( S [ j ] ) <NEWLINE> if num_count_2 [ s_j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_count_2 [ s_j ] = True <NEWLINE> num_count_3 = [ False ] * 10 <NEWLINE> for k in range ( j + 1 , len ( S ) ) : <NEWLINE> <INDENT> s_k = int ( S [ k ] ) <NEWLINE> if num_count_3 [ s_k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_count_3 [ s_k ] = True <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from itertools import accumulate <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> prime_counter = defaultdict ( int ) <COMMENT> <NEWLINE> acc = tuple ( accumulate ( range ( 1 , 42 ) ) ) <COMMENT> <NEWLINE> <NL> def facs ( n ) : <NEWLINE> <INDENT> yield 2 <NEWLINE> for x in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> yield x <NEWLINE> <NL> <DEDENT> <DEDENT> for fac in facs ( n ) : <NEWLINE> <INDENT> while n % fac == 0 : <NEWLINE> <INDENT> n //= fac <NEWLINE> prime_counter [ fac ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> prime_counter [ n ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in prime_counter . values ( ) : <NEWLINE> <INDENT> for i , x in enumerate ( acc ) : <NEWLINE> <INDENT> if c < x : <NEWLINE> <INDENT> tmp = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans += tmp <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ i + A [ i ] , 0 ] ) <NEWLINE> C . append ( [ i - A [ i ] , 1 ] ) <NEWLINE> <DEDENT> C . sort ( ) <NEWLINE> now = C [ 0 ] [ 0 ] <NEWLINE> c0 = 0 <NEWLINE> c1 = 0 <NEWLINE> ans = 0 <NEWLINE> for c in C : <NEWLINE> <INDENT> if now == c [ 0 ] : <NEWLINE> <INDENT> if c [ 1 ] == 0 : <NEWLINE> <INDENT> c0 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += c0 * c1 <NEWLINE> c0 = 0 <NEWLINE> c1 = 0 <NEWLINE> if c [ 1 ] == 0 : <NEWLINE> <INDENT> c0 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> <DEDENT> now = c [ 0 ] <NEWLINE> <DEDENT> <DEDENT> ans += c0 * c1 <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> <NL> a = [ 0 ] * 2019 <NEWLINE> a [ 0 ] = 1 <NEWLINE> count = 0 <NEWLINE> val = 1 <NEWLINE> current = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> current = ( current + val * int ( c ) ) % 2019 <NEWLINE> count += a [ current % 2019 ] <NEWLINE> a [ current % 2019 ] += 1 <NEWLINE> val = val * 10 % 2019 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> n , q = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> processes = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = sys . stdin . readline ( ) . split ( ) <NEWLINE> processes += [ [ name , int ( time ) ] ] <NEWLINE> <NL> <DEDENT> progress = 0 <NEWLINE> <NL> while len ( processes ) : <NEWLINE> <INDENT> new_processes = [ ] <NEWLINE> for target in processes : <NEWLINE> <INDENT> if target [ 1 ] > q : <NEWLINE> <INDENT> target [ 1 ] -= q <NEWLINE> progress += q <NEWLINE> new_processes += [ target ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> progress += target [ 1 ] <NEWLINE> print ( target [ 0 ] , progress ) <NEWLINE> <DEDENT> <DEDENT> processes = new_processes <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> S = s [ i : i + len ( t ) ] <NEWLINE> cnt = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ j ] == S [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( cnt ) <NEWLINE> <NL> <DEDENT> a = ans . index ( max ( ans ) ) <NEWLINE> b = s [ a : a + len ( t ) ] <NEWLINE> count = 0 <NEWLINE> for k in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ k ] != b [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> s = input ( ) [ : : - 1 ] <NEWLINE> T = [ 0 ] * ( len ( s ) + 1 ) <NEWLINE> digit = 1 <NEWLINE> <NL> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> T [ i ] = ( T [ i - 1 ] + digit * int ( s [ i - 1 ] ) ) <NEWLINE> T [ i ] = T [ i ] % 2019 <NEWLINE> digit = digit * 10 <NEWLINE> digit = digit % 2019 <NEWLINE> <NL> <DEDENT> S = Counter ( T ) <NEWLINE> ans = 0 <NEWLINE> for i in S . values ( ) : <NEWLINE> <INDENT> ans += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = - 100 <NEWLINE> a = [ 0 ] * 300 <NEWLINE> for p in P : <NEWLINE> <INDENT> a [ 100 + p - 1 ] = 1 <NEWLINE> <NL> <DEDENT> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if a [ 100 + x - 1 - d ] == 0 : <NEWLINE> <INDENT> t = x - d <NEWLINE> break <NEWLINE> <DEDENT> elif a [ 100 + x - 1 + d ] == 0 : <NEWLINE> <INDENT> t = x + d <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> S = sys . stdin . readlines ( ) <NEWLINE> A = [ 0 ] * 26 <NEWLINE> B = [ 0 ] * D <NEWLINE> k = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if C [ i ] != 0 : <NEWLINE> <INDENT> k += C [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if i < 25 : <NEWLINE> <INDENT> A [ i ] = int ( C [ i ] / k * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = D - sum ( A [ : 25 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 25 ) : <NEWLINE> <INDENT> for j in range ( A [ i ] ) : <NEWLINE> <INDENT> B [ D // A [ i ] * j ] = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> if B [ i ] == 0 : <NEWLINE> <INDENT> B [ i ] = 26 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> import math <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> k = INT ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> <NL> def A ( value , sum ) : <NEWLINE> <INDENT> if value == 0 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( math . gcd ( value , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> A ( value - 1 , sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> A ( k , 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a [ A [ i ] - 1 ] = a [ A [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxh = [ ] <NEWLINE> for height in h : <NEWLINE> <INDENT> maxh . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> maxh [ a ] = max ( maxh [ a ] , h [ b ] ) <NEWLINE> maxh [ b ] = max ( maxh [ b ] , h [ a ] ) <NEWLINE> <DEDENT> g = 0 <NEWLINE> for height , maxheight in zip ( h , maxh ) : <NEWLINE> <INDENT> if height > maxheight : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> I = [ 0 ] * N <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> I [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( I [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> cs = { c : 0 for c in list ( <STRING> ) } <NEWLINE> for c in list ( sys . stdin . read ( ) ) : <NEWLINE> <INDENT> c = c . lower ( ) <NEWLINE> if c in cs . keys ( ) : <NEWLINE> <INDENT> cs [ c ] = cs [ c ] + 1 <NEWLINE> <DEDENT> <DEDENT> for ( c , cnt ) in sorted ( list ( cs . items ( ) ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( c , cnt ) ) <NEWLINE> <DEDENT>
q = int ( input ( ) ) <NEWLINE> n = 10 ** 5 <NEWLINE> nums = [ False ] * 2 + [ True ] * ( n - 2 ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if nums [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , n , i ) : <NEWLINE> <INDENT> nums [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> pre = 0 <NEWLINE> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if nums [ i ] and nums [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> ans [ i ] += pre + 1 <NEWLINE> pre = ans [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = pre <NEWLINE> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans [ r ] - ans [ max ( l - 2 , 1 ) ] ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> counter = 0 <NEWLINE> <NL> if S == T : <NEWLINE> <INDENT> print ( counter ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if T [ i ] != S [ i ] : <NEWLINE> <INDENT> counter += 1 <NEWLINE> if S == T : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( s ) - 1 for s in input ( ) . split ( ) ] <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] != ( i - result ) : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if result == N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> def solve ( data ) : <NEWLINE> <INDENT> result = data . replace ( <STRING> , <STRING> ) <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> for _ in range ( num ) : <NEWLINE> <INDENT> data = input ( ) <NEWLINE> result = solve ( data ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n = 1000000 <NEWLINE> p = [ 1 ] * ( n + 1 ) <NEWLINE> p [ 0 ] , p [ 1 ] = 0 , 0 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p = [ i for i in range ( n + 1 ) if p [ i ] == 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = - n <NEWLINE> if n == 0 : break <NEWLINE> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> a , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += bisect . bisect_left ( p , a + m + 1 ) - bisect . bisect_left ( p , a - m ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a = s . find ( str ( i ) ) <NEWLINE> if a == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> b = s . find ( str ( j ) , a + 1 ) <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if s . find ( str ( k ) , b + 1 ) != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> q = deque ( [ ] ) <NEWLINE> <NL> edge = [ set ( [ ] ) for _ in range ( n + 1 ) ] <NEWLINE> mark = [ - 1 for _ in range ( n + 1 ) ] <NEWLINE> used = [ False for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ a ] . add ( b ) <NEWLINE> edge [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> q . append ( 1 ) <NEWLINE> mark [ 1 ] = 1 <NEWLINE> used [ 1 ] = True <NEWLINE> while ( len ( q ) > 0 ) : <NEWLINE> <INDENT> vi = q . popleft ( ) <NEWLINE> ei = edge [ vi ] <NEWLINE> for eij in ei : <NEWLINE> <INDENT> if ( used [ eij ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mark [ eij ] = vi <NEWLINE> used [ eij ] = True <NEWLINE> q . append ( eij ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , len ( mark ) ) : <NEWLINE> <INDENT> print ( mark [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for n in range ( 1 , int ( N / 2 ) + 1 ) : <NEWLINE> <INDENT> if 2 * n + 1 > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , int ( N ** ( 1 / 2 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , int ( N ** ( 1 / 2 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , int ( N ** ( 1 / 2 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if 2 * n + 1 == ( 2 * i + 1 ) * ( 2 * j + 1 ) * ( 2 * k + 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += [ input ( ) ] <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> num , mini , maxi = map ( int , input ( ) . split ( ) ) <NEWLINE> if num == 0 : break <NEWLINE> scores = [ int ( input ( ) ) for i in range ( num ) ] <NEWLINE> gap = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( mini , maxi + 1 ) : <NEWLINE> <INDENT> gap = scores [ i - 1 ] - scores [ i ] if scores [ i - 1 ] - scores [ i ] >= gap else gap <NEWLINE> ans = i if scores [ i - 1 ] - scores [ i ] >= gap else ans <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N - 1 ) ] <NEWLINE> E = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in edges : <NEWLINE> <INDENT> E [ a ] . append ( b ) <NEWLINE> E [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> depth = [ [ - 1 , - 1 ] for _ in range ( N + 1 ) ] <NEWLINE> depth [ v ] [ 0 ] = 0 <NEWLINE> depth [ u ] [ 1 ] = 0 <NEWLINE> <NL> def dfs1 ( E , v ) : <NEWLINE> <INDENT> vv = E [ v ] <NEWLINE> for vvv in vv : <NEWLINE> <INDENT> if depth [ vvv ] [ 0 ] == - 1 : <NEWLINE> <INDENT> depth [ vvv ] [ 0 ] = depth [ v ] [ 0 ] + 1 <NEWLINE> dfs1 ( E , vvv ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs2 ( E , v ) : <NEWLINE> <INDENT> vv = E [ v ] <NEWLINE> for vvv in vv : <NEWLINE> <INDENT> if depth [ vvv ] [ 1 ] == - 1 : <NEWLINE> <INDENT> depth [ vvv ] [ 1 ] = depth [ v ] [ 1 ] + 1 <NEWLINE> dfs2 ( E , vvv ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs1 ( E , v ) <NEWLINE> dfs2 ( E , u ) <NEWLINE> depth = sorted ( depth , reverse = True ) <NEWLINE> idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if depth [ idx ] [ 0 ] - depth [ idx ] [ 1 ] >= 1 : <NEWLINE> <INDENT> print ( depth [ idx ] [ 0 ] - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx += 1 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> product = 1 <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> product *= A [ i ] <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if product <= 10 ** 18 and A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> cnt = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> S . append ( temp ) <NEWLINE> <NL> <DEDENT> S = set ( S ) <NEWLINE> print ( len ( S ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans *= A [ i + 1 ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
l = input ( ) . split ( ) <NEWLINE> a = int ( l [ 0 ] ) <NEWLINE> b = int ( l [ 1 ] ) <NEWLINE> c = int ( l [ 2 ] ) <NEWLINE> d = int ( l [ 3 ] ) <NEWLINE> r = [ ] <NEWLINE> r . append ( a * c ) <NEWLINE> r . append ( a * d ) <NEWLINE> r . append ( b * c ) <NEWLINE> r . append ( b * d ) <NEWLINE> print ( max ( r ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AN = [ 0 ] * 100002 <COMMENT> <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> AN [ a ] += 1 <NEWLINE> AN [ a + 1 ] += 1 <NEWLINE> AN [ a + 2 ] += 1 <NEWLINE> <DEDENT> print ( max ( AN ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> SUM = 0 <NEWLINE> A = [ ] <NEWLINE> O = [ ] <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> i = int ( i ) <NEWLINE> SUM ^= i <NEWLINE> A . append ( i ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> O . append ( SUM ^ a ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in O ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def calcTime ( x , n = 0 ) : <NEWLINE> <INDENT> if n * ( n + 1 ) // 2 >= x : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return calcTime ( x , n + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> x = int ( input ( ) ) <NEWLINE> print ( calcTime ( x ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> r = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> r [ a - 1 ] . append ( b - 1 ) <NEWLINE> r [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> p = [ - 1 ] * N <NEWLINE> q = [ 0 ] <NEWLINE> while q : <NEWLINE> <INDENT> i = q . pop ( 0 ) <NEWLINE> for j in r [ i ] : <NEWLINE> <INDENT> if p [ j ] == - 1 : <NEWLINE> <INDENT> p [ j ] = i <NEWLINE> q . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( p [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 1 <NEWLINE> if 0 in num : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> sum *= num [ i ] <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> prime_numbers = [ 2 , 3 , 5 , 7 ] <NEWLINE> <NL> def prime_numbers_under ( num ) : <NEWLINE> <INDENT> global prime_numbers <NEWLINE> <NL> prime_number_max = max ( prime_numbers ) <NEWLINE> if prime_number_max > num : <NEWLINE> <INDENT> return prime_numbers <NEWLINE> <NL> <DEDENT> for i in range ( prime_number_max + 1 , num + 1 ) : <NEWLINE> <INDENT> check_max = math . floor ( math . sqrt ( i ) ) <NEWLINE> for j in prime_numbers : <NEWLINE> <INDENT> if j <= check_max : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> prime_numbers . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return prime_numbers <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> amount = 0 <NEWLINE> <NL> length = int ( input ( ) ) <NEWLINE> for _ in range ( 0 , length ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> check_max = math . floor ( math . sqrt ( i ) ) <NEWLINE> for j in prime_numbers_under ( check_max ) : <NEWLINE> <INDENT> if j <= check_max : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> amount += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( amount ) <NEWLINE> return 0 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n [ 1 : ] == <STRING> * ( len ( n ) - 1 ) : <NEWLINE> <INDENT> print ( int ( n [ 0 ] ) + 9 * ( len ( n ) - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n [ 0 ] ) + 9 * ( len ( n ) - 1 ) - 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N , 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> class peak ( ) : <NEWLINE> <INDENT> def __init__ ( self , loc , elevation ) : <NEWLINE> <INDENT> self . loc = loc <NEWLINE> self . elevation = elevation <NEWLINE> self . next_high = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def peak_append ( peak_list , loc , elevation ) : <NEWLINE> <INDENT> p = peak ( loc , elevation ) <NEWLINE> peak_list . append ( p ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def peak_set_next_high ( peak_list ) : <NEWLINE> <INDENT> next_high = peak_list [ - 1 ] <COMMENT> <NEWLINE> for i in range ( len ( peak_list ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> peak_list [ i ] . next_high = next_high <NEWLINE> if peak_list [ i ] . elevation >= next_high . elevation : <NEWLINE> <INDENT> next_high = peak_list [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def find_flood ( elev_list , peak_list ) : <NEWLINE> <INDENT> peak_p = peak_list . pop ( 0 ) <NEWLINE> next_high = peak_p . next_high <NEWLINE> if not next_high : <NEWLINE> <INDENT> return None , None <NEWLINE> <DEDENT> q_elev = next_high . elevation <NEWLINE> p_elev = peak_p . elevation <NEWLINE> <NL> if p_elev > q_elev : <NEWLINE> <INDENT> q_offset = next_high . loc <NEWLINE> p_offset = peak_p . loc <NEWLINE> while p_offset < len ( elev_list ) : <NEWLINE> <INDENT> if elev_list [ p_offset ] == elev_list [ q_offset ] : <NEWLINE> <INDENT> return p_offset , q_offset <NEWLINE> <DEDENT> p_offset += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None , None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p_offset = peak_p . loc <NEWLINE> q_offset = elev_list . index ( p_elev , p_offset + 1 ) <NEWLINE> return p_offset , q_offset <NEWLINE> <DEDENT> raise <STRING> <NEWLINE> <NL> <NL> <DEDENT> def calc_area ( p , q , elev_list ) : <NEWLINE> <INDENT> elev_0 = elev_list [ p ] <NEWLINE> area = 0 <NEWLINE> <NL> prev_elev = 0 <NEWLINE> for x in range ( p , q + 1 ) : <NEWLINE> <INDENT> elev = elev_list [ x ] - elev_0 <NEWLINE> area += elev <NEWLINE> <NL> <DEDENT> return ( abs ( area ) ) <NEWLINE> <NL> <NL> <DEDENT> def adjust_peak_list ( q , peak_list ) : <NEWLINE> <INDENT> while peak_list : <NEWLINE> <INDENT> if peak_list [ 0 ] . loc >= q : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> peak_list . pop ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> s = list ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> flood_area = list ( ) <NEWLINE> peak_list = list ( ) <NEWLINE> <NL> ascending = True <NEWLINE> elevation = 0 <NEWLINE> elev_list = list ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> elev_list . append ( elevation ) <NEWLINE> <NL> if s [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> ascending = True <NEWLINE> elevation += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> if ascending : <NEWLINE> <INDENT> peak_append ( peak_list , i , elevation ) <NEWLINE> <DEDENT> ascending = False <NEWLINE> elevation -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elev_list . append ( elevation ) <NEWLINE> <NL> if ascending : <NEWLINE> <INDENT> peak_append ( peak_list , len ( s ) , elevation ) <NEWLINE> <NL> <DEDENT> peak_set_next_high ( peak_list ) <NEWLINE> <NL> while peak_list : <NEWLINE> <INDENT> p , q = find_flood ( elev_list , peak_list ) <NEWLINE> if p == None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flood_area . append ( calc_area ( p , q , elev_list ) ) <NEWLINE> adjust_peak_list ( q , peak_list ) <NEWLINE> <NL> <DEDENT> print ( sum ( flood_area ) ) <NEWLINE> print ( len ( flood_area ) , end = <STRING> ) <NEWLINE> for i in range ( len ( flood_area ) ) : <NEWLINE> <INDENT> print ( <STRING> , flood_area [ i ] , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> eflg = False <NEWLINE> for a in range ( 200 ) : <NEWLINE> <INDENT> wk_a = a ** 5 <NEWLINE> for b in range ( 200 ) : <NEWLINE> <INDENT> if wk_a - ( b ** 5 ) == x : <NEWLINE> <INDENT> ans1 = a <NEWLINE> ans2 = b <NEWLINE> eflg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> if wk_a - ( - b ** 5 ) == x : <NEWLINE> <INDENT> ans1 = a <NEWLINE> ans2 = - b <NEWLINE> eflg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if eflg == True : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans1 , ans2 ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , B = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> num , x = 0 , m <NEWLINE> <NL> for i in range ( len ( a ) + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ i ] + B [ x ] > k : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> num = max ( num , i + x ) <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE> <NL>
from decimal import Decimal <NEWLINE> N = [ Decimal ( e ) for e in input ( ) . split ( ) ] <NEWLINE> ans = Decimal ( N [ 0 ] ) * Decimal ( N [ 1 ] ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if N % 2 != 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = int ( N / 2 ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + N ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AI = tuple ( i + a for i , a in enumerate ( A ) ) <NEWLINE> AJ = tuple ( i - a for i , a in enumerate ( A ) ) <NEWLINE> <NL> cai = { } <NEWLINE> caj = { } <NEWLINE> vali = set ( ) <NEWLINE> valj = set ( ) <NEWLINE> for ai , aj in zip ( AI , AJ ) : <NEWLINE> <INDENT> if not ai in cai : <NEWLINE> <INDENT> cai [ ai ] = 0 <NEWLINE> <DEDENT> if not aj in caj : <NEWLINE> <INDENT> caj [ aj ] = 0 <NEWLINE> <NL> <DEDENT> cai [ ai ] += 1 <NEWLINE> vali . add ( ai ) <NEWLINE> <NL> caj [ aj ] += 1 <NEWLINE> valj . add ( aj ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for val in vali & valj : <NEWLINE> <INDENT> count += cai [ val ] * caj [ val ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( A : int , B : int , N : int ) : <NEWLINE> <INDENT> if A == 1 : return 0 <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> md = N % B <NEWLINE> x = int ( N - ( md + 1 ) ) <NEWLINE> <DEDENT> return int ( ( A * x ) // B ) - A * int ( x // B ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> A = int ( next ( tokens ) ) <COMMENT> <NEWLINE> B = int ( next ( tokens ) ) <COMMENT> <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> print ( solve ( A , B , N ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> if X == 1 : <NEWLINE> <INDENT> print ( 0 , - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> def solve ( num , X ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> if ( i * 100 ) ** 5 - ( i * 100 - num ) ** 5 >= X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> max_a = 100 * i <NEWLINE> a = max_a - 99 <NEWLINE> while a <= max_a : <NEWLINE> <INDENT> if ( a ) ** 5 - ( a - num ) ** 5 == X : <NEWLINE> <INDENT> return True , a , a - num <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> return False , 0 , 0 <NEWLINE> <NL> <DEDENT> arr = make_divisors ( abs ( X ) ) <NEWLINE> for num in arr : <NEWLINE> <INDENT> if ( num - X ) % 5 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag , a , b = solve ( num , X ) <NEWLINE> if flag : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
k , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if i + j <= s and s <= k + i + j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic_Lg = { } <NEWLINE> dic_Lw = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = i - A [ i ] <NEWLINE> if x in dic_Lg : <NEWLINE> <INDENT> dic_Lg [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_Lg [ x ] = 1 <NEWLINE> <DEDENT> y = i + A [ i ] <NEWLINE> if y in dic_Lw : <NEWLINE> <INDENT> dic_Lw [ y ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_Lw [ y ] = 1 <NEWLINE> <DEDENT> <DEDENT> LP = list ( dic_Lw . keys ( ) ) + list ( dic_Lg . keys ( ) ) <NEWLINE> LP = set ( LP ) <NEWLINE> ret = 0 <NEWLINE> for i in LP : <NEWLINE> <INDENT> if i in dic_Lg and i in dic_Lw : <NEWLINE> <INDENT> ret += dic_Lg [ i ] * dic_Lw [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import * <NEWLINE> n , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; C = Counter ( A ) . items ( ) ; f = 1 ; l = len ( C ) <NEWLINE> if l == 3 : <NEWLINE> <INDENT> x = 0 <NEWLINE> for c in C : x ^= c [ 0 ] <NEWLINE> f = ( len ( set ( c [ 1 ] for c in C ) ) > 1 ) + n % 3 + x > 0 <NEWLINE> <DEDENT> elif l == 2 : f = ( abs ( sum ( c [ 1 ] * ( - 1 ) ** i for i , c in enumerate ( C ) ) ) != n // 3 ) + n % 3 > 0 <NEWLINE> else : f = ( l != 1 ) + A [ 0 ] > 0 <NEWLINE> print ( <STRING> [ f : : 2 ] ) <NEWLINE>
import numpy as np <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = sorted ( p ) <NEWLINE> lista = list ( range ( - 100 , 200 ) ) <NEWLINE> for i in p : <NEWLINE> <INDENT> if i in lista : <NEWLINE> <INDENT> lista . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> def getNearestValue ( list , num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> idx = np . abs ( np . asarray ( list ) - num ) . argmin ( ) <NEWLINE> print ( list [ idx ] ) <NEWLINE> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> getNearestValue ( lista , X ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dataset = [ input ( ) . replace ( <STRING> , <STRING> ) for _ in range ( n ) ] <NEWLINE> print ( * dataset , sep = <STRING> ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ set ( ) for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ A - 1 ] . add ( B - 1 ) <NEWLINE> AB [ B - 1 ] . add ( A - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res = True <NEWLINE> for x in AB [ i ] : <NEWLINE> <INDENT> if H [ i ] <= H [ x ] : <NEWLINE> <INDENT> res = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if res : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> to = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ x - 1 ] . append ( y - 1 ) <NEWLINE> to [ y - 1 ] . append ( x - 1 ) <NEWLINE> <DEDENT> dist = [ None ] * n <NEWLINE> <NL> que = deque ( [ 0 ] ) <NEWLINE> while que : <NEWLINE> <INDENT> v = que . pop ( ) <NEWLINE> for i in to [ v ] : <NEWLINE> <INDENT> if ( dist [ i ] is None ) : <NEWLINE> <INDENT> dist [ i ] = v + 1 <NEWLINE> que . appendleft ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in dist [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> from functools import reduce <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> nums = list ( map ( str , range ( 10 ) ) ) <NEWLINE> for i in nums : <NEWLINE> <INDENT> s1 = S . find ( i ) <NEWLINE> if s1 < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in nums : <NEWLINE> <INDENT> s2 = S . find ( j , s1 + 1 ) <NEWLINE> if s2 < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in nums : <NEWLINE> <INDENT> s3 = S . find ( k , s2 + 1 ) <NEWLINE> if s3 > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> plist . sort ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> sum += plist [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> r = [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . format ( r [ 0 ] * r [ 0 ] * math . pi , r [ 0 ] * 2 * math . pi ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> y = ( a * x ) // b - a * ( x // b ) <NEWLINE> return y <NEWLINE> <DEDENT> print ( f ( min ( b - 1 , n ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> fover = False <NEWLINE> fzero = False <NEWLINE> for A in As : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> fzero = True <NEWLINE> break <NEWLINE> <DEDENT> if not fover : <NEWLINE> <INDENT> ans *= A <NEWLINE> if ans > MAX : <NEWLINE> <INDENT> fover = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if fzero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif fover : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> import random <NEWLINE> import sys <NEWLINE> import heapq <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict , deque , UserString <NEWLINE> from functools import lru_cache , cmp_to_key , reduce <NEWLINE> from itertools import ( chain , combinations , combinations_with_replacement , <NEWLINE> <INDENT> permutations , product ) <NEWLINE> <NL> <DEDENT> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MAX_INT = 2 ** 62 - 1 <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> @ lru_cache ( None ) <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if not b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = ( n + 1 ) * n // 2 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( j , i ) * 6 <NEWLINE> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , gcd ( j , k ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = deque ( a ) <NEWLINE> <NL> tmp = [ ] <NEWLINE> cnt = 0 <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> if len ( tmp ) <= 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not ( v >= tmp [ - 1 ] >= tmp [ - 2 ] >= tmp [ 0 ] or v <= tmp [ - 1 ] <= tmp [ - 2 ] <= tmp [ 0 ] ) : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> tmp . append ( v ) <NEWLINE> <COMMENT> <NL> <DEDENT> if tmp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Q = [ input ( ) . split ( ) for i in range ( Q ) ] <NEWLINE> Forward = [ ] <NEWLINE> Backward = [ ] <NEWLINE> count = 0 <NEWLINE> for i in Q : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( int ( i [ 1 ] ) + count ) % 2 == 1 : <NEWLINE> <INDENT> Forward . append ( i [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Backward . append ( i [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count % 2 == 0 : <NEWLINE> <INDENT> ans = ( <STRING> . join ( Forward ) ) [ : : - 1 ] + S + ( <STRING> . join ( Backward ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( <STRING> . join ( Backward ) [ : : - 1 ] + S [ : : - 1 ] + ( <STRING> . join ( Forward ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> N , M = map ( int , pin ( ) . split ( ) ) <NEWLINE> if N == 3 : <NEWLINE> <INDENT> ans = [ 1 , 0 , 0 ] <NEWLINE> for _ in [ 0 ] * M : <NEWLINE> <INDENT> s , c = map ( int , pin ( ) . split ( ) ) <NEWLINE> if s == 1 and c == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> if s != 1 and ans [ s - 1 ] != 0 and ans [ s - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> ans [ s - 1 ] = c <NEWLINE> <DEDENT> a = <STRING> <NEWLINE> for i in ans : <NEWLINE> <INDENT> a += str ( i ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> return <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> ans = [ 1 , 0 ] <NEWLINE> for _ in [ 0 ] * M : <NEWLINE> <INDENT> s , c = map ( int , pin ( ) . split ( ) ) <NEWLINE> if s == 1 and c == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> if s != 1 and ans [ s - 1 ] != 0 and ans [ s - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> ans [ s - 1 ] = c <NEWLINE> <DEDENT> a = <STRING> <NEWLINE> for i in ans : <NEWLINE> <INDENT> a += str ( i ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if M == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> s , c = map ( int , pin ( ) . split ( ) ) <NEWLINE> ans = c <NEWLINE> <NL> for j in range ( M - 1 ) : <NEWLINE> <INDENT> s , c = map ( int , pin ( ) . split ( ) ) <NEWLINE> if c != ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> <NL> def prime_numbers ( numbers ) : <NEWLINE> <INDENT> return list ( map ( is_prime , numbers ) ) . count ( True ) <NEWLINE> <NL> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if ( n == 2 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif ( n % 2 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 3 <NEWLINE> while i <= math . sqrt ( n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> numbers = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> numbers . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( prime_numbers ( numbers ) ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> graph = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> u , v = A [ i ] <NEWLINE> graph [ u ] . append ( v ) <NEWLINE> graph [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> stack = deque ( [ 1 ] ) <NEWLINE> visited = [ - 1 for i in range ( N + 1 ) ] <NEWLINE> visited2 = [ - 1 for i in range ( N + 1 ) ] <NEWLINE> visited [ 1 ] = 0 <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> x = stack . popleft ( ) <NEWLINE> for i in graph [ x ] : <NEWLINE> <INDENT> if visited [ i ] == - 1 : <NEWLINE> <INDENT> visited [ i ] = visited [ x ] + 1 <NEWLINE> visited2 [ i ] = x <NEWLINE> stack . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * visited2 [ 2 : ] , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> heavy = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> heavy [ x ] += 1 <NEWLINE> <DEDENT> suma = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> suma -= B * heavy [ B ] <NEWLINE> suma += C * heavy [ B ] <NEWLINE> heavy [ C ] += heavy [ B ] <NEWLINE> heavy [ B ] = 0 <NEWLINE> print ( suma ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> tmp = K <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if A < B : <NEWLINE> <INDENT> tmp = i <NEWLINE> break <NEWLINE> <DEDENT> B = B * 2 <NEWLINE> <NL> <DEDENT> if B < C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B < C * ( 2 ** ( K - tmp ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i + 1 > k : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> data = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> data . append ( [ x , l ] ) <NEWLINE> <DEDENT> data = sorted ( data , key = lambda x : x [ 0 ] + x [ 1 ] ) <NEWLINE> ans = 0 <NEWLINE> pre = - ( 10 ** 10 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if data [ i ] [ 0 ] - data [ i ] [ 1 ] >= pre : <NEWLINE> <INDENT> ans += 1 <NEWLINE> pre = data [ i ] [ 0 ] + data [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> SL = list ( S ) <NEWLINE> cnt = 0 <NEWLINE> nr = SL . count ( <STRING> ) <NEWLINE> ng = SL . count ( <STRING> ) <NEWLINE> nb = SL . count ( <STRING> ) <NEWLINE> ans = nr * ng * nb <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for d in range ( N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ - 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if s [ i - 2 ] == <STRING> and s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 998244353 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> LR = [ LI ( ) for _ in range ( K ) ] <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> a = [ 0 ] * ( N + 1 ) <NEWLINE> a [ 0 ] = 1 <NEWLINE> a [ 1 ] = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for l , r in LR : <NEWLINE> <INDENT> left = min ( i + l , N ) <NEWLINE> right = min ( i + r + 1 , N ) <NEWLINE> a [ left ] += dp [ i ] <NEWLINE> a [ right ] -= dp [ i ] <NEWLINE> <DEDENT> dp [ i + 1 ] += dp [ i ] + a [ i + 1 ] <NEWLINE> dp [ i + 1 ] %= MOD <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( dp [ - 2 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ret *= i <NEWLINE> if ret > 10 ** 18 : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> print ( sum ( p [ : K ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> num = 1 <NEWLINE> max_num = 10 ** 18 <NEWLINE> for i in A : <NEWLINE> <INDENT> num *= i <NEWLINE> <NL> if num > max_num : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def next_f ( a ) : <NEWLINE> <INDENT> return a * a % M <NEWLINE> <NL> <DEDENT> visited = [ None ] * M <NEWLINE> sum_at_visit = [ None ] * M <NEWLINE> loop_done = False <NEWLINE> <NL> time = 1 <NEWLINE> ans = 0 <NEWLINE> x = X <NEWLINE> while time <= N : <NEWLINE> <INDENT> if not loop_done and visited [ x ] is not None : <NEWLINE> <COMMENT> <NL> <INDENT> loop_len = time - visited [ x ] <NEWLINE> loop_sum = ans + x - sum_at_visit [ x ] <NEWLINE> loops = ( N - loop_len - time ) // loop_len <NEWLINE> time += loop_len * loops <NEWLINE> ans += loop_sum * loops <NEWLINE> loop_done = True <NEWLINE> <DEDENT> ans += x <NEWLINE> visited [ x ] = time <NEWLINE> sum_at_visit [ x ] = ans <NEWLINE> time += 1 <NEWLINE> x = next_f ( x ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = [ 0 ] * N <NEWLINE> <COMMENT> <NL> d = [ 1 ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> T = A [ d [ - 1 ] - 1 ] <NEWLINE> if n [ T - 1 ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n [ T - 1 ] = 1 <NEWLINE> <DEDENT> d . append ( T ) <NEWLINE> <DEDENT> F = d . index ( T ) <NEWLINE> LOOP_TOWN = d [ F : ] <NEWLINE> q = ( K - F ) % len ( LOOP_TOWN ) <NEWLINE> print ( LOOP_TOWN [ q ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> def fib ( n ) : <NEWLINE> <INDENT> l = list ( ) <NEWLINE> l . append ( 1 ) <NEWLINE> l . append ( 1 ) <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> l . append ( l [ i - 1 ] + l [ i - 2 ] ) <NEWLINE> <NL> <DEDENT> return l [ - 1 ] <NEWLINE> <NL> <DEDENT> print ( fib ( n ) ) <NEWLINE>
import copy <NEWLINE> <NL> <NL> def prepare ( n , MOD ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> f = 1 <NEWLINE> factorials = [ 1 ] <COMMENT> <NEWLINE> for m in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f *= m <NEWLINE> f %= MOD <NEWLINE> factorials . append ( f ) <NEWLINE> <COMMENT> <NL> <DEDENT> inv = pow ( f , MOD - 2 , MOD ) <NEWLINE> <COMMENT> <NL> invs = [ 1 ] * ( n + 1 ) <NEWLINE> invs [ n ] = inv <NEWLINE> for m in range ( n , 1 , - 1 ) : <NEWLINE> <INDENT> inv *= m <NEWLINE> inv %= MOD <NEWLINE> invs [ m - 1 ] = inv <NEWLINE> <NL> <DEDENT> return factorials , invs <NEWLINE> <NL> <DEDENT> def func ( r , c ) : <NEWLINE> <INDENT> return f [ r + 1 + c + 1 ] * i [ r + 1 ] % MOD * i [ c + 1 ] % MOD <NEWLINE> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> f , i = prepare ( 2 * 10 ** 6 + 2 , MOD ) <NEWLINE> <NL> <NL> r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> combi = func ( r2 , c2 ) - func ( r2 , c1 - 1 ) - func ( r1 - 1 , c2 ) + func ( r1 - 1 , c1 - 1 ) <NEWLINE> print ( combi % MOD ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for k in range ( K ) ] <NEWLINE> <NL> dp = ( 3 * N ) * [ 0 ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = - 1 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> for L , R in LR : <NEWLINE> <INDENT> dp [ L + n ] += dp [ n ] <NEWLINE> dp [ n + R + 1 ] -= dp [ n ] <NEWLINE> <DEDENT> dp [ n + 1 ] = ( dp [ n ] + dp [ n + 1 ] ) % 998244353 <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if c * c == a * a + b * b else <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lst . append ( ( p_lst [ i ] + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> tmp_sum = sum ( lst [ : k ] ) <NEWLINE> maximum = tmp_sum <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> tmp_sum -= lst [ i ] <NEWLINE> tmp_sum += lst [ i + k ] <NEWLINE> maximum = max ( maximum , tmp_sum ) <NEWLINE> <NL> <DEDENT> print ( maximum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> L = n // 2 <NEWLINE> res = 0 <NEWLINE> while L : <NEWLINE> <INDENT> res += L // 5 <NEWLINE> L //= 5 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
class uinon_find ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> uf = uinon_find ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 1 <NEWLINE> maxk = 26 <NEWLINE> while 1 : <NEWLINE> <INDENT> if n <= maxk : <NEWLINE> <INDENT> ke = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> maxk = maxk + 26 ** i <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> tar = n <NEWLINE> l = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> a = tar // 26 <NEWLINE> b = tar % 26 <NEWLINE> if b == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b = 26 <NEWLINE> <DEDENT> l . append ( chr ( ord ( <STRING> ) - 1 + b ) ) <NEWLINE> tar = a <NEWLINE> if tar == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( l [ : : - 1 ] ) ) <NEWLINE> <NL> <DEDENT> solve ( readInt ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from functools import lru_cache , reduce <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import chain , combinations , permutations , product <NEWLINE> from typing import List , Dict <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 + 1 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> write = sys . stdout . write <NEWLINE> <NL> <NL> def read_item ( cls = int ) : <NEWLINE> <INDENT> return cls ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_n_item ( cls = int ) -> list : <NEWLINE> <INDENT> return [ cls ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> <DEDENT> def list2d ( row , col , init_val = 0 ) -> List [ list ] : <NEWLINE> <INDENT> return [ [ init_val ] * col for _ in range ( row ) ] <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> INT_MAX = 10 ** 9 <NEWLINE> <COMMENT> <NL> <NL> <NL> N = read_item ( ) <NEWLINE> vals = read_n_item ( ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = read_n_item ( ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> graph [ u ] . append ( v ) <NEWLINE> graph [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> ans [ 0 ] = 1 <NEWLINE> dp = [ vals [ 0 ] ] <NEWLINE> <NL> <NL> def dfs ( cur , pre ) : <NEWLINE> <INDENT> ans [ cur ] = len ( dp ) <NEWLINE> <NL> for nxt in graph [ cur ] : <NEWLINE> <INDENT> if nxt == pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i = bisect_left ( dp , vals [ nxt ] ) <NEWLINE> if i < len ( dp ) : <NEWLINE> <INDENT> temp = dp [ i ] <NEWLINE> dp [ i ] = vals [ nxt ] <NEWLINE> dfs ( nxt , cur ) <NEWLINE> dp [ i ] = temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp . append ( vals [ nxt ] ) <NEWLINE> dfs ( nxt , cur ) <NEWLINE> dp . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sumA = list ( itertools . accumulate ( A ) ) <NEWLINE> sumB = list ( itertools . accumulate ( B ) ) <NEWLINE> j = M - 1 <NEWLINE> while K < sumB [ j ] and j >= 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = j + 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if sumA [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while K < sumA [ i ] + sumB [ j ] and j >= 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j + 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ruto = [ 1 ] <NEWLINE> kako = [ 0 ] * ( n + 1 ) <NEWLINE> kako [ 1 ] = 1 <NEWLINE> saki = a [ 0 ] <NEWLINE> flag = 0 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> if kako [ saki ] == 1 : <NEWLINE> <INDENT> where = ruto . index ( saki ) <NEWLINE> ruto = ruto [ where : ] <NEWLINE> ans = ( k - where ) % len ( ruto ) <NEWLINE> print ( ruto [ ans ] ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ruto . append ( saki ) <NEWLINE> kako [ saki ] = 1 <NEWLINE> saki = a [ saki - 1 ] <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ruto [ - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> action = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> action . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> memo = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> memo . append ( [ - 1 ] * 3 ) <NEWLINE> <NL> <DEDENT> def dp ( i , a ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return action [ 0 ] [ a ] <NEWLINE> <DEDENT> elif memo [ i ] [ a ] != - 1 : <NEWLINE> <INDENT> return memo [ i ] [ a ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] [ a ] = max ( dp ( i - 1 , ( a + 1 ) % 3 ) , dp ( i - 1 , ( a + 2 ) % 3 ) ) + action [ i ] [ a ] <NEWLINE> return memo [ i ] [ a ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( [ dp ( n - 1 , a ) for a in range ( 3 ) ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 5 + 5 ) <NEWLINE> <NL> <NL> def dfs ( _v , _u ) : <NEWLINE> <INDENT> for u in v [ _v ] : <NEWLINE> <INDENT> if u == _u : continue ; <NEWLINE> ans [ u ] += ans [ _v ] <NEWLINE> dfs ( u , _v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> v [ a ] . append ( b ) <NEWLINE> v [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> ans [ p ] += x + 1 <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> v = [ [ ] * n for i in range ( n ) ] <NEWLINE> main ( ) <NEWLINE> <DEDENT>
( n , m , * b ) , a , * q = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> t = [ - 1 ] * n <NEWLINE> def r ( x ) : <NEWLINE> <INDENT> while - 1 < t [ x ] : x = t [ x ] <NEWLINE> return x <NEWLINE> <DEDENT> def u ( x ) : <NEWLINE> <INDENT> x , y = map ( r , x ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if t [ x ] > t [ y ] : x , y = y , x <NEWLINE> t [ x ] += t [ y ] ; t [ y ] = x <NEWLINE> <DEDENT> <DEDENT> [ * map ( u , q ) ] <NEWLINE> i = c = 0 <NEWLINE> k = j = n + ~ m << 1 <NEWLINE> * d , = eval ( <STRING> * n ) <NEWLINE> for v in a : d [ r ( i ) ] += v , ; i += 1 <NEWLINE> for p in d : x , * y = sorted ( p ) + [ 0 ] ; c += x ; b += y [ : - 1 ] ; j -= p > [ ] <NEWLINE> print ( k < 1 and <STRING> or ( k > n ) * <STRING> or c + sum ( sorted ( b ) [ : j ] ) ) <NEWLINE>
import math <NEWLINE> import bisect <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ABs = [ ] <NEWLINE> <NL> count00 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == 0 : <NEWLINE> <INDENT> if B == 0 : <NEWLINE> <INDENT> count00 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ABs . append ( [ 0 , - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> ABs . append ( [ 1 , 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mygcd = math . gcd ( A , B ) <NEWLINE> A , B = A // mygcd , B // mygcd <NEWLINE> if A < 0 : <NEWLINE> <INDENT> ABs . append ( [ - A , - B ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ABs . append ( [ A , B ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N2 = N - count00 <NEWLINE> if N2 == 0 : <NEWLINE> <INDENT> print ( count00 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ABs . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> Bs = [ i [ 1 ] for i in ABs ] <NEWLINE> index0 = bisect . bisect_left ( Bs , 0 ) <NEWLINE> <NL> if ( index0 == 0 ) or ( index0 == N2 ) : <NEWLINE> <INDENT> print ( ( pow ( 2 , N2 , MOD ) + count00 - 1 ) % MOD ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> btm = ABs [ : index0 ] <NEWLINE> top = ABs [ index0 : ] <NEWLINE> <NL> lenbtm = index0 <NEWLINE> lentop = N2 - index0 <NEWLINE> for i in range ( lenbtm ) : <NEWLINE> <INDENT> btm [ i ] = [ - btm [ i ] [ 1 ] , btm [ i ] [ 0 ] ] <NEWLINE> <NL> <DEDENT> btmdict = { } <NEWLINE> topdict = { } <NEWLINE> for i in btm : <NEWLINE> <INDENT> mykey = str ( i [ 0 ] ) + <STRING> + str ( i [ 1 ] ) <NEWLINE> btmdict [ mykey ] = 0 <NEWLINE> topdict [ mykey ] = 0 <NEWLINE> <DEDENT> for j in top : <NEWLINE> <INDENT> mykey = str ( j [ 0 ] ) + <STRING> + str ( j [ 1 ] ) <NEWLINE> btmdict [ mykey ] = 0 <NEWLINE> topdict [ mykey ] = 0 <NEWLINE> <NL> <DEDENT> for i in btm : <NEWLINE> <INDENT> mykey = str ( i [ 0 ] ) + <STRING> + str ( i [ 1 ] ) <NEWLINE> btmdict [ mykey ] += 1 <NEWLINE> <DEDENT> for j in top : <NEWLINE> <INDENT> mykey = str ( j [ 0 ] ) + <STRING> + str ( j [ 1 ] ) <NEWLINE> topdict [ mykey ] += 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in btmdict : <NEWLINE> <INDENT> btmi = btmdict [ i ] <NEWLINE> topi = topdict [ i ] <NEWLINE> if btmi * topi >= 1 : <NEWLINE> <INDENT> ans = ans * ( pow ( 2 , btmi , MOD ) + pow ( 2 , topi , MOD ) - 1 ) % MOD <NEWLINE> <DEDENT> elif btmi == 0 : <NEWLINE> <INDENT> ans = ans * pow ( 2 , topi , MOD ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * pow ( 2 , btmi , MOD ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ( ans + count00 - 1 ) % MOD <NEWLINE> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> ans , j = 0 , M <NEWLINE> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> CS = [ 0 ] <NEWLINE> cur = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if S [ i - 1 ] + S [ i ] == <STRING> : <NEWLINE> <INDENT> cur += 1 <NEWLINE> CS . append ( cur ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> CS . append ( cur ) <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( CS [ r - 1 ] - CS [ l - 1 ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num_list = [ 0 ] * 1000001 <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if num_list [ a [ i ] ] == 0 : <NEWLINE> <INDENT> num_list [ a [ i ] ] += 1 <NEWLINE> for j in range ( 2 , ( 1000000 // a [ i ] ) + 1 ) : <NEWLINE> <INDENT> num_list [ j * a [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif num_list [ a [ i ] ] == 1 : <NEWLINE> <INDENT> num_list [ a [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if num_list [ a [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> K = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> S = A [ i ] - A [ i + 1 ] <NEWLINE> <COMMENT> <NL> A [ i + 1 ] += S <NEWLINE> K += S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( K ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> s_readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , readline ( ) . split ( ) ) ) , np . int32 ) <NEWLINE> <NL> K = min ( N , K ) <NEWLINE> ans = solve ( N , K , A ) . tolist ( ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <NL> <INDENT> for k in range ( K ) : <NEWLINE> <NL> <INDENT> B = np . zeros ( N , np . int32 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = max ( 0 , i - A [ i ] ) <NEWLINE> r = i + A [ i ] + 1 <NEWLINE> B [ l ] += 1 <NEWLINE> if r <= N - 1 : <NEWLINE> <INDENT> B [ r ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s = B [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ i + 1 ] = B [ i + 1 ] + B [ i ] <NEWLINE> s += B [ i + 1 ] <NEWLINE> <NL> <DEDENT> A = B <NEWLINE> <NL> if s == N * N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> <NL> D = [ 0 ] * N <NEWLINE> <NL> def dfs ( x , parent , index ) : <NEWLINE> <INDENT> D [ x ] = C [ index ] <NEWLINE> index += 1 <NEWLINE> for u in edges [ x ] : <NEWLINE> <INDENT> if u != parent : <NEWLINE> <INDENT> index = dfs ( u , x , index ) <NEWLINE> <DEDENT> <DEDENT> return index <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( sum ( C [ 1 : ] ) ) <NEWLINE> print ( * D ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b // x - ( a - 1 ) // x ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> class Bt ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . used = [ False ] * 10 <COMMENT> <NEWLINE> self . answers = [ ] <COMMENT> <NEWLINE> self . Q = deque ( ) <COMMENT> <NEWLINE> <NL> <DEDENT> def solve ( self , num , remain ) : <NEWLINE> <COMMENT> <NL> <INDENT> try : <NEWLINE> <INDENT> min_choice = max ( self . Q ) + 1 <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> min_choice = 0 <NEWLINE> <NL> <DEDENT> if min_choice <= remain < 10 and self . used [ remain ] == False and num == 1 : <NEWLINE> <INDENT> self . Q . append ( remain ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = [ ] <NEWLINE> for i in self . Q : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> if not ans in self . answers : <NEWLINE> <INDENT> self . answers . append ( ans ) <NEWLINE> <DEDENT> self . Q . pop ( ) <NEWLINE> <COMMENT> <NL> return <NEWLINE> <DEDENT> elif num < 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( min_choice , 10 ) : <NEWLINE> <INDENT> if self . used [ i ] == False and ( remain - i ) >= 0 : <NEWLINE> <INDENT> self . used [ i ] = True <NEWLINE> self . Q . append ( i ) <NEWLINE> self . solve ( num - 1 , remain - i ) <NEWLINE> self . used [ i ] = False <NEWLINE> self . Q . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> n , s = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if n == 0 and s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if 0 <= s <= 45 : <NEWLINE> <COMMENT> <NL> <INDENT> a = Bt ( ) <NEWLINE> a . solve ( n , s ) <NEWLINE> <NL> <COMMENT> <NL> print ( len ( a . answers ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> AS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in AS : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> s = 0 <NEWLINE> sum = 1 <NEWLINE> l = len ( AS ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> A = AS [ i ] <NEWLINE> sum = sum * A <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> s = 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = sorted ( la ) <NEWLINE> la = sorted ( la , key = abs , reverse = True ) <NEWLINE> lg = la [ : K ] <NEWLINE> lgp = [ ] <NEWLINE> lgm = [ ] <NEWLINE> lr = la [ K : ] <NEWLINE> lrp = [ ] <NEWLINE> lrm = [ ] <NEWLINE> for a in lg : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> lgp . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lgm . append ( a ) <NEWLINE> <DEDENT> <DEDENT> for a in lr : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> lrp . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lrm . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if len ( lgm ) % 2 == 1 : <NEWLINE> <INDENT> if len ( lrp ) > 0 and len ( lrm ) > 0 : <NEWLINE> <INDENT> if len ( lgp ) > 0 and len ( lgm ) > 0 : <NEWLINE> <INDENT> if lgp [ len ( lgp ) - 1 ] * lrp [ 0 ] > lgm [ len ( lgm ) - 1 ] * lrm [ 0 ] : <NEWLINE> <INDENT> lg . pop ( lg . index ( lgm [ len ( lgm ) - 1 ] ) ) <NEWLINE> lg . append ( lrp [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lg . pop ( lg . index ( lgp [ len ( lgp ) - 1 ] ) ) <NEWLINE> lg . append ( lrm [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( lgp ) > 0 : <NEWLINE> <INDENT> lg . pop ( lg . index ( lgp [ len ( lgp ) - 1 ] ) ) <NEWLINE> lg . append ( lrm [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lg . pop ( lg . index ( lgm [ len ( lgm ) - 1 ] ) ) <NEWLINE> lg . append ( lrp [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif len ( lrp ) > 0 : <NEWLINE> <INDENT> if len ( lgm ) > 0 : <NEWLINE> <INDENT> lg . pop ( lg . index ( lgm [ len ( lgm ) - 1 ] ) ) <NEWLINE> lg . append ( lrp [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lg = la [ N - K : ] <NEWLINE> <DEDENT> <DEDENT> elif len ( lrm ) > 0 : <NEWLINE> <INDENT> if len ( lgp ) > 0 : <NEWLINE> <INDENT> lg . pop ( lg . index ( lgp [ len ( lgp ) - 1 ] ) ) <NEWLINE> lg . append ( lrm [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lg = la [ N - K : ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for a in lg : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
while 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> in s : break <NEWLINE> p = 0 <NEWLINE> e = [ [ ] * 2 for _ in range ( 10 ) ] <NEWLINE> for x in s : <NEWLINE> <INDENT> if x == <STRING> : e [ p ] += [ <STRING> ] <NEWLINE> elif x == <STRING> : p += 1 <NEWLINE> else : e [ p ] += <STRING> * int ( x ) <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a - 1 ] [ b - 1 ] , e [ c - 1 ] [ d - 1 ] = e [ c - 1 ] [ d - 1 ] , e [ a - 1 ] [ b - 1 ] <NEWLINE> for i in range ( p + 1 ) : <NEWLINE> <INDENT> if i : ans += <STRING> <NEWLINE> a = 0 <NEWLINE> for j in e [ i ] : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> if a : ans += str ( a ) <NEWLINE> ans += <STRING> <NEWLINE> a = 0 <NEWLINE> <DEDENT> else : a += 1 <NEWLINE> <DEDENT> if a : ans += str ( a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from itertools import permutations <NEWLINE> <NL> N , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( C ) ] <NEWLINE> <COMMENT> <NL> <NL> colors = [ [ 0 ] * C for i in range ( 3 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j , color in enumerate ( tmp ) : <NEWLINE> <INDENT> num = ( ( i + 1 ) + ( j + 1 ) ) % 3 <NEWLINE> colors [ num ] [ color - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> data = [ [ 0 ] * C for i in range ( 3 ) ] <NEWLINE> <NL> <NL> for i in range ( 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( C ) : <NEWLINE> <INDENT> for k in range ( C ) : <NEWLINE> <INDENT> data [ i ] [ k ] += colors [ i ] [ j ] * D [ j ] [ k ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 10 ** 10 <NEWLINE> for iter_ in permutations ( list ( range ( C ) ) , 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = [ ] <NEWLINE> for i , j in enumerate ( iter_ ) : <NEWLINE> <INDENT> tmp . append ( data [ i ] [ j ] ) <NEWLINE> <DEDENT> ans = min ( ans , sum ( tmp ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import unittest <NEWLINE> <NL> <NL> def solve_small ( n ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for m in range ( 1 , n ) : <NEWLINE> <INDENT> if n // m == n % m : <NEWLINE> <INDENT> total += m <NEWLINE> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> conds = set ( ) <NEWLINE> conds . add ( n - 1 ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> conds . add ( i - 1 ) <NEWLINE> conds . add ( n // i - 1 ) <NEWLINE> <DEDENT> <DEDENT> total = 0 <NEWLINE> for m in list ( conds ) : <NEWLINE> <INDENT> if n // m == n % m : <NEWLINE> <INDENT> total += m <NEWLINE> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> result = solve ( n ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT> class Test ( unittest . TestCase ) : <NEWLINE> <INDENT> def test_solve_1 ( self ) : <NEWLINE> <INDENT> n = 8 <NEWLINE> actual = solve ( n ) <NEWLINE> expected = 10 <NEWLINE> self . assertEqual ( actual , expected ) <NEWLINE> <NL> <DEDENT> def test_solve_2 ( self ) : <NEWLINE> <INDENT> n = 1000000000000 <NEWLINE> actual = solve ( n ) <NEWLINE> expected = 2499686339916 <NEWLINE> self . assertEqual ( actual , expected ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> mod = 2019 <NEWLINE> S = map ( int , reversed ( input ( ) ) ) <NEWLINE> <NL> mods = [ 0 ] <NEWLINE> num = 0 <NEWLINE> digit = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> num += s * digit <NEWLINE> num %= mod <NEWLINE> mods . append ( num ) <NEWLINE> digit = digit * 10 % mod <NEWLINE> <NL> <DEDENT> counter = Counter ( mods ) <NEWLINE> ans = 0 <NEWLINE> for count in counter . values ( ) : <NEWLINE> <INDENT> ans += count * ( count - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
judge = True <NEWLINE> while judge : <NEWLINE> <INDENT> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N [ 0 ] + N [ 1 ] == 0 : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , N [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( 0 , N [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ 100 ** D * i for i in range ( 102 ) if i % 100 != 0 ] [ N - 1 ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if b > a : <NEWLINE> <INDENT> multiplier = 2 ** k <NEWLINE> if c * multiplier > b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while b <= a : <NEWLINE> <INDENT> b *= 2 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> multiplier = 2 ** k <NEWLINE> if c * multiplier > b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> ans = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 1 : <NEWLINE> <INDENT> ans . appendleft ( str ( a [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( str ( a [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = list ( ans ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( * ans [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def divisor ( x ) : <NEWLINE> <INDENT> div = [ ] <NEWLINE> for i in range ( 1 , int ( x ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> div . append ( i ) <NEWLINE> if i != x // i : <NEWLINE> <INDENT> div . append ( x // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sorted ( div ) <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> zt = [ 1 ] <NEWLINE> ans = 0 <NEWLINE> while N > 1 : <NEWLINE> <INDENT> for i in divisor ( N ) : <NEWLINE> <INDENT> if i not in zt : <NEWLINE> <INDENT> if len ( factorization ( i ) ) == 1 : <NEWLINE> <INDENT> z = i <NEWLINE> zt . append ( z ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if z == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N = N // z <NEWLINE> ans += 1 <NEWLINE> z = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = abs ( x ) // d <NEWLINE> <NL> if k < tmp : <NEWLINE> <INDENT> result = abs ( abs ( x ) - d * k ) <NEWLINE> <DEDENT> elif tmp % 2 == k % 2 : <NEWLINE> <INDENT> result = abs ( abs ( x ) - d * tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = result = abs ( abs ( x ) - d * tmp ) <NEWLINE> result = abs ( abs ( a ) - d ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_child = 2 <NEWLINE> max_child = 2 <NEWLINE> <NL> for i in range ( K - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if math . ceil ( min_child / A [ i ] ) > 0 and math . floor ( max_child / A [ i ] ) > 0 and math . floor ( max_child / A [ i ] ) - math . ceil ( min_child / A [ i ] ) >= 0 : <NEWLINE> <INDENT> min_child = math . ceil ( min_child / A [ i ] ) * A [ i ] <NEWLINE> max_child = math . floor ( max_child / A [ i ] ) * A [ i ] + A [ i ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( min_child , max_child ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> result = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> if H [ a - 1 ] <= H [ b - 1 ] : <NEWLINE> <INDENT> result [ a - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for a , b in zip ( B , A ) : <NEWLINE> <INDENT> if H [ a - 1 ] <= H [ b - 1 ] : <NEWLINE> <INDENT> result [ a - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result . count ( 1 ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> X = nl ( ) <NEWLINE> X_s = sorted ( X ) <NEWLINE> mid = X_s [ n // 2 ] <NEWLINE> del_mid = ( X_s [ : n // 2 ] + X_s [ n // 2 + 1 : ] ) [ ( n - 1 ) // 2 ] <NEWLINE> for x in X : <NEWLINE> <INDENT> if x < mid : <NEWLINE> <INDENT> print ( mid ) <NEWLINE> <DEDENT> elif x > mid : <NEWLINE> <INDENT> print ( X_s [ n // 2 - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( del_mid ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
w , h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> b , c , d , e = 0 , w , 0 , h <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> b = max ( b , x ) <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> c = min ( c , x ) <NEWLINE> <DEDENT> elif a == 3 : <NEWLINE> <INDENT> d = max ( d , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = min ( e , y ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( c - b , 0 ) * max ( e - d , 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> pow = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pow *= i + 1 <NEWLINE> pow = pow % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( pow ) <NEWLINE>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> if ( k <= a ) : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> elif ( a < k and k <= a + b ) : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> elif ( a + b < k and k <= a + b + c ) : <NEWLINE> <INDENT> ans = a - ( k - a - b ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Buka_list = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Buka_list . append ( 0 ) <NEWLINE> <NL> <DEDENT> for j in A_list : <NEWLINE> <INDENT> Buka_list [ j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> print ( Buka_list [ k ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> found = 0 <NEWLINE> dt = defaultdict ( int ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> found += dt [ n - A [ n ] ] <NEWLINE> dt [ n + A [ n ] ] += 1 <NEWLINE> <DEDENT> print ( found ) <NEWLINE>
<NL> A = input ( ) . split ( ) <NEWLINE> X = float ( A [ 0 ] ) <NEWLINE> K = int ( A [ 1 ] ) <NEWLINE> D = int ( A [ 2 ] ) <NEWLINE> <NL> if abs ( X ) - K * D > 0 : <NEWLINE> <INDENT> print ( int ( abs ( X ) - K * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K2 = abs ( X ) // D <NEWLINE> if ( K - K2 ) % 2 == 0 : <NEWLINE> <INDENT> print ( int ( abs ( abs ( X ) - D * K2 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( abs ( abs ( abs ( X ) - D * K2 ) - D ) ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> t = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> buy = t [ 0 ] <NEWLINE> val = t [ - 1 ] - buy <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if t [ i ] - buy > val : <NEWLINE> <INDENT> val = t [ i ] - buy <NEWLINE> <DEDENT> if t [ i ] < buy : <NEWLINE> <INDENT> buy = t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( val ) <NEWLINE> <NL>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> def find_square0 ( data ) : <NEWLINE> <INDENT> max_size = 0 <NEWLINE> lmap = [ ] <COMMENT> <NEWLINE> <COMMENT> <NL> for row in data : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> for c in row : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> temp . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> lmap . append ( temp ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for y in range ( 1 , len ( lmap ) ) : <NEWLINE> <INDENT> for x in range ( 1 , len ( lmap [ 0 ] ) ) : <NEWLINE> <INDENT> if lmap [ y ] [ x ] == 1 : <NEWLINE> <INDENT> lmap [ y ] [ x ] = min ( lmap [ y - 1 ] [ x - 1 ] , min ( lmap [ y - 1 ] [ x ] , lmap [ y ] [ x - 1 ] ) ) + 1 <NEWLINE> if lmap [ y ] [ x ] > max_size : <NEWLINE> <INDENT> max_size = lmap [ y ] [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return max_size <NEWLINE> <NL> <NL> <DEDENT> def find_square ( data ) : <NEWLINE> <INDENT> max_size = 0 <NEWLINE> lmap = [ ] <NEWLINE> for row in data : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> for c in row : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> temp . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> lmap . append ( temp ) <NEWLINE> <NL> <DEDENT> prev_row = lmap [ 0 ] <NEWLINE> for curr_row in lmap [ 1 : ] : <NEWLINE> <INDENT> for x in range ( 1 , len ( lmap [ 0 ] ) ) : <NEWLINE> <INDENT> if curr_row [ x ] == 1 : <NEWLINE> <INDENT> if prev_row [ x - 1 ] != 0 and prev_row [ x ] != 0 and curr_row [ x - 1 ] != 0 : <COMMENT> <NEWLINE> <INDENT> curr_row [ x ] = min ( prev_row [ x - 1 ] , min ( prev_row [ x ] , curr_row [ x - 1 ] ) ) + 1 <NEWLINE> if curr_row [ x ] > max_size : <NEWLINE> <INDENT> max_size = curr_row [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> prev_row = curr_row <NEWLINE> <DEDENT> return max_size <NEWLINE> <NL> <NL> <DEDENT> def find_square2 ( data ) : <NEWLINE> <INDENT> max_size = 0 <NEWLINE> lmap = [ ] <COMMENT> <NEWLINE> <COMMENT> <NL> for row in data : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> for c in row : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> temp . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> lmap . append ( temp ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> prev_row = lmap [ 0 ] <NEWLINE> for curr_row in lmap [ 1 : ] : <NEWLINE> <INDENT> for x , t in enumerate ( curr_row [ 1 : ] , start = 1 ) : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> curr_row [ x ] = min ( prev_row [ x - 1 ] , min ( prev_row [ x ] , curr_row [ x - 1 ] ) ) + 1 <NEWLINE> if curr_row [ x ] > max_size : <NEWLINE> <INDENT> max_size = curr_row [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prev_row = curr_row <NEWLINE> <DEDENT> return max_size <NEWLINE> <NL> <NL> <DEDENT> def find_square3 ( data ) : <NEWLINE> <INDENT> from array import array <NEWLINE> max_size = 0 <NEWLINE> lmap = [ array ( <STRING> , [ 0 ] * len ( data [ 0 ] ) ) for _ in range ( len ( data ) ) ] <NEWLINE> <COMMENT> <NL> for y , row in enumerate ( data ) : <NEWLINE> <INDENT> for x , c in enumerate ( row ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> lmap [ y ] [ x ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> prev_row = lmap [ 0 ] <NEWLINE> for curr_row in lmap [ 1 : ] : <NEWLINE> <INDENT> for x , t in enumerate ( curr_row [ 1 : ] , start = 1 ) : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> curr_row [ x ] = min ( prev_row [ x - 1 ] , min ( prev_row [ x ] , curr_row [ x - 1 ] ) ) + 1 <NEWLINE> if curr_row [ x ] > max_size : <NEWLINE> <INDENT> max_size = curr_row [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prev_row = curr_row <NEWLINE> <DEDENT> return max_size <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ input ( ) for _ in range ( n ) ] <NEWLINE> result = find_square3 ( data ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> argList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> check = np . array ( [ 1 ] * argList [ 0 ] ) <NEWLINE> <NL> for n in range ( argList [ 1 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> con = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if heights [ con [ 0 ] - 1 ] <= heights [ con [ 1 ] - 1 ] : <NEWLINE> <INDENT> check [ con [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> if heights [ con [ 0 ] - 1 ] >= heights [ con [ 1 ] - 1 ] : <NEWLINE> <INDENT> check [ con [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( np . sum ( check ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def f ( hito , zahyo ) : <NEWLINE> <INDENT> x [ hito ] = zahyo <NEWLINE> for tsugi in links [ hito ] : <NEWLINE> <INDENT> if x [ tsugi [ 0 ] ] == None : <NEWLINE> <INDENT> f ( tsugi [ 0 ] , zahyo + tsugi [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x [ tsugi [ 0 ] ] != zahyo + tsugi [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> links = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> links [ l ] . append ( [ r , d ] ) <NEWLINE> links [ r ] . append ( [ l , - d ] ) <NEWLINE> <NL> <DEDENT> x = [ None ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if x [ i ] == None : <NEWLINE> <INDENT> f ( i , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
PDList = list ( input ( ) ) <NEWLINE> <NL> <NL> for index , PD in enumerate ( PDList ) : <NEWLINE> <INDENT> if PD != <STRING> : continue <NEWLINE> <NL> if PD == <STRING> and len ( PDList ) == 1 : <NEWLINE> <INDENT> PDList [ index ] = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> if index == 0 : <NEWLINE> <INDENT> if PDList [ index + 1 ] == <STRING> or PDList [ index + 1 ] == <STRING> : PDList [ index ] = <STRING> <NEWLINE> else : PDList [ index ] = <STRING> <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if PD == <STRING> and index == len ( PDList ) - 1 : <NEWLINE> <INDENT> PDList [ index ] = <STRING> <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> if PDList [ index - 1 ] == <STRING> : <NEWLINE> <INDENT> PDList [ index ] = <STRING> <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if PDList [ index + 1 ] == <STRING> : <NEWLINE> <INDENT> PDList [ index ] = <STRING> <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if PDList [ index - 1 ] == <STRING> and PDList [ index + 1 ] == <STRING> : <NEWLINE> <INDENT> PDList [ index ] = <STRING> <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> PDList [ index ] = <STRING> <NEWLINE> continue <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( PDList ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2147483647 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> aa , bb = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ aa - 1 ] . append ( bb - 1 ) <NEWLINE> tree [ bb - 1 ] . append ( aa - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> import bisect <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def lisOnTree ( x , lis ) : <NEWLINE> <INDENT> global ans , tree , a , n <NEWLINE> i = bisect . bisect_left ( lis , a [ x ] ) <NEWLINE> if i == len ( lis ) : <NEWLINE> <INDENT> lis . append ( a [ x ] ) <NEWLINE> flag = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = ( i , lis [ i ] ) <NEWLINE> lis [ i ] = a [ x ] <NEWLINE> <COMMENT> <NL> <DEDENT> ans [ x ] = len ( lis ) <NEWLINE> for item in tree [ x ] : <NEWLINE> <INDENT> if ans [ item ] == 0 : <NEWLINE> <INDENT> lisOnTree ( item , lis ) <NEWLINE> <DEDENT> <DEDENT> if flag == <STRING> : <NEWLINE> <INDENT> lis . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ flag [ 0 ] ] = flag [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> lisOnTree ( 0 , [ ] ) <NEWLINE> <NL> for item in ans : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> x = P [ 0 ] <NEWLINE> <NL> <NL> for i in P : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x >= i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> x = i <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for num in a : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > x : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c [ l [ i ] ] = i + 1 <NEWLINE> <DEDENT> c = sorted ( c . items ( ) ) <NEWLINE> [ print ( s [ 1 ] , end = <STRING> ) for s in c ] <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> count_r = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> count_r += 1 <NEWLINE> <DEDENT> <DEDENT> count_w = n - count_r <NEWLINE> ans = min ( count_r , count_w ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> pattern = <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> l = 0 <NEWLINE> r = n - 1 <NEWLINE> count = 0 <NEWLINE> <COMMENT> <NL> while l < r : <NEWLINE> <INDENT> while c [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> while c [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> if l >= r : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c [ l ] = <STRING> <NEWLINE> c [ r ] = <STRING> <NEWLINE> count += 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> ans = min ( count , ans ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ 0 ] * ( K + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d [ i ] = pow ( K // i , N , mod ) <NEWLINE> <DEDENT> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 2 * i , K + 1 , i ) : <NEWLINE> <INDENT> d [ i ] -= d [ j ] <NEWLINE> d [ i ] %= mod <NEWLINE> <DEDENT> ans += d [ i ] * i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> data = input ( ) . split ( ) <NEWLINE> <NL> data = [ int ( s ) for s in data ] <NEWLINE> <NL> num = 0 <NEWLINE> ans = 0 <NEWLINE> sum = sum ( data ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> num += data [ i ] <NEWLINE> ans += ( sum - num ) * data [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> import time <NEWLINE> import sys <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> start = time . time ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> Asum = [ i + A [ i ] for i in range ( N ) ] <NEWLINE> Adif = [ i - A [ i ] for i in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += d [ Adif [ i ] ] <NEWLINE> d [ Asum [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> now = 26 <NEWLINE> before = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if N <= now : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> before = now <NEWLINE> now += 26 ** i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> M = N - before <NEWLINE> alphabet = <STRING> <NEWLINE> ans = <STRING> <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> dig = int ( ( M - 1 ) // 26 ** ( i - j - 1 ) ) <NEWLINE> <COMMENT> <NL> ans = ans + alphabet [ dig ] <NEWLINE> M -= dig * 26 ** ( i - j - 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> M = [ ] <NEWLINE> sqr_N = math . floor ( math . sqrt ( N ) ) <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( 1 , ( sqr_N + 1 ) ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> <NL> <DEDENT> <DEDENT> a_pair = N // a <NEWLINE> print ( a + a_pair - 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> su = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> tmp = dgcd ( a , b , c ) <NEWLINE> if a == b and b == c : <NEWLINE> <INDENT> tmp *= 1 <NEWLINE> <DEDENT> elif a == b or b == c or a == c : <NEWLINE> <INDENT> tmp *= 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp *= 6 <NEWLINE> <NL> <DEDENT> su += tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( su ) <NEWLINE> <NL> <NL> <DEDENT> def dgcd ( a , b , c ) : <NEWLINE> <INDENT> return gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> array = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( array ) <NEWLINE> A . insert ( 0 , 0 ) <NEWLINE> <NL> visit = 0 <NEWLINE> root = [ ] <NEWLINE> visited = 1 <NEWLINE> once = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if visit & ( 0b1 << visited ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> root . append ( visited ) <NEWLINE> visit |= 0b1 << visited <NEWLINE> once += 1 <NEWLINE> visited = A [ visited ] <NEWLINE> <NL> <DEDENT> roop = root [ root . index ( visited ) : ] <NEWLINE> if K < once : <NEWLINE> <INDENT> print ( root [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> order = K - once <NEWLINE> print ( roop [ order % len ( roop ) ] ) <NEWLINE> <DEDENT>
def default ( ) : <NEWLINE> <INDENT> maxi = 1000000000000000000 <NEWLINE> n = int ( input ( ) ) <NEWLINE> answer = 1 <NEWLINE> temp = input ( ) <NEWLINE> temp = temp . split ( ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> temp [ i ] = int ( temp [ i ] ) <NEWLINE> <DEDENT> temp . sort ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> answer *= temp [ i ] <NEWLINE> if ( answer > maxi ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if ( temp [ i ] == 0 ) : <NEWLINE> <INDENT> flag == 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( flag == 2 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> default ( ) <NEWLINE> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( gcd ( a , b ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = sorted ( X ) <NEWLINE> x = np . median ( X ) <NEWLINE> index = N // 2 <NEWLINE> m1 = Y [ index ] <NEWLINE> m2 = Y [ index - 1 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] < x : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m2 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> if a [ m - 1 ] >= sum ( a ) / ( 4 * m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> N , Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tree = [ [ - 1 , 1 ] for _ in range ( N ) ] <COMMENT> <NEWLINE> <NL> def find ( i ) : <NEWLINE> <INDENT> if tree [ i ] [ 0 ] == - 1 : <NEWLINE> <INDENT> group = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> group = find ( tree [ i ] [ 0 ] ) <NEWLINE> <DEDENT> return group <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> px = find ( x ) <NEWLINE> py = find ( y ) <NEWLINE> <NL> if tree [ px ] [ 1 ] == tree [ py ] [ 1 ] : <COMMENT> <NEWLINE> <INDENT> tree [ py ] [ 0 ] = px <NEWLINE> tree [ px ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tree [ px ] [ 1 ] < tree [ py ] [ 1 ] : <NEWLINE> <INDENT> px , py = py , px <NEWLINE> <DEDENT> tree [ py ] [ 0 ] = px <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> com , x , y = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if com : <COMMENT> <NEWLINE> <INDENT> print ( int ( find ( x ) == find ( y ) ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if not int ( find ( x ) == find ( y ) ) : <NEWLINE> <INDENT> unite ( x , y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = set ( ) <NEWLINE> C = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in B : <NEWLINE> <INDENT> C . add ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . add ( a ) <NEWLINE> <DEDENT> <DEDENT> M = max ( B ) <NEWLINE> bool = [ 1 ] * ( M + 1 ) <NEWLINE> for c in C : <NEWLINE> <INDENT> bool [ c ] = 0 <NEWLINE> <DEDENT> for b in B : <NEWLINE> <INDENT> for i in range ( b * 2 , M + 1 , b ) : <NEWLINE> <INDENT> bool [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if bool [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( lambda x : x * ( - 1 ) , a ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> heapq . heappush ( a , - 1 * ( - heapq . heappop ( a ) // 2 ) ) <NEWLINE> <DEDENT> print ( sum ( a ) * - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if a . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . Counter ( a ) <NEWLINE> all_comb = 0 <NEWLINE> for i in cnt . keys ( ) : <NEWLINE> <INDENT> all_comb += cnt [ i ] * ( cnt [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> comb = all_comb <NEWLINE> comb -= cnt [ a [ i ] ] * ( cnt [ a [ i ] ] - 1 ) // 2 <NEWLINE> comb += ( cnt [ a [ i ] ] - 1 ) * ( cnt [ a [ i ] ] - 2 ) // 2 <NEWLINE> print ( comb ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> H , W , M = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <COMMENT> <NEWLINE> hcnt = [ 0 ] * H <COMMENT> <NEWLINE> wcnt = [ 0 ] * W <COMMENT> <NEWLINE> bomb = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> bh , bw = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> hcnt [ bh - 1 ] += 1 <COMMENT> <NEWLINE> wcnt [ bw - 1 ] += 1 <COMMENT> <NEWLINE> bomb . append ( ( bh - 1 , bw - 1 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> hmax = max ( hcnt ) <COMMENT> <NEWLINE> wmax = max ( wcnt ) <COMMENT> <NEWLINE> <NL> crs = 0 <COMMENT> <NEWLINE> for ( i , j ) in bomb : <NEWLINE> <INDENT> if hcnt [ i ] == hmax and wcnt [ j ] == wmax : <NEWLINE> <INDENT> crs += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if crs == Counter ( hcnt ) [ hmax ] * Counter ( wcnt ) [ wmax ] : <NEWLINE> <INDENT> print ( hmax + wmax - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( hmax + wmax ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) % mod , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> B = A [ 1 : n ] <NEWLINE> B_s = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> B_s += B [ i ] % mod <NEWLINE> <NL> <DEDENT> out = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> out += A [ i ] * B_s <NEWLINE> out %= mod <NEWLINE> B_s -= A [ i + 1 ] <NEWLINE> B_s %= mod <NEWLINE> if B_s < 0 : <NEWLINE> <INDENT> B_s += mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
input ( ) <NEWLINE> data = input ( ) . split ( ) <NEWLINE> data . reverse ( ) <NEWLINE> print ( <STRING> . join ( data ) ) <NEWLINE>
from itertools import accumulate <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for q in range ( Q ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> flg = [ ] <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> tmp_s = S [ n : n + 2 ] <NEWLINE> if tmp_s == <STRING> : <NEWLINE> <INDENT> flg . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> flg2 = [ 0 ] + flg <NEWLINE> flg2 = list ( accumulate ( flg2 ) ) <NEWLINE> <COMMENT> <NL> <NL> for a in A : <NEWLINE> <INDENT> print ( flg2 [ a [ 1 ] - 1 ] - flg2 [ a [ 0 ] - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 10 ** 12 <NEWLINE> for a in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> b = n // a <NEWLINE> <DEDENT> ans = min ( ans , a + b - 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> journey = [ 1 ] <NEWLINE> <NL> for i in range ( 2 * n + 100 ) : <NEWLINE> <INDENT> nxt = a [ journey [ - 1 ] ] <NEWLINE> journey . append ( nxt ) <NEWLINE> <NL> <DEDENT> if k < n + 1 : <NEWLINE> <INDENT> print ( journey [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> loop_end = n <NEWLINE> <NL> loop_start = n - 1 <NEWLINE> <NL> while ( journey [ loop_start ] != journey [ loop_end ] ) : <NEWLINE> <INDENT> loop_start -= 1 <NEWLINE> <NL> <DEDENT> period = loop_end - loop_start <NEWLINE> <NL> k %= period <NEWLINE> while k <= n : <NEWLINE> <INDENT> k += period <NEWLINE> <NL> <DEDENT> print ( journey [ k ] ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def abc168_d ( ) : <NEWLINE> <INDENT> N , _ = map ( int , readline ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for ln in readlines ( ) : <NEWLINE> <INDENT> a , b = map ( int , ln . split ( ) ) <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> label = [ - 1 ] * ( N + 1 ) <NEWLINE> label [ 0 ] = label [ 1 ] = 0 <NEWLINE> <NL> from collections import deque <NEWLINE> que = deque ( [ 1 ] ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> k = que . popleft ( ) <NEWLINE> for x in adj [ k ] : <NEWLINE> <INDENT> if label [ x ] != - 1 : continue <COMMENT> <NEWLINE> label [ x ] = k <COMMENT> <NEWLINE> que . append ( x ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> if - 1 in label : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * label [ 2 : ] , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> abc168_d ( ) <NEWLINE>
n0 = int ( 1e5 ) + 1 <NEWLINE> x = [ 0 ] * n0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a0 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bcs = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> bcs . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for a in a0 : <NEWLINE> <INDENT> x [ a ] += 1 <NEWLINE> <DEDENT> sum0 = sum ( a0 ) <NEWLINE> <NL> for bc in bcs : <NEWLINE> <INDENT> sum0 = sum0 + bc [ 1 ] * x [ bc [ 0 ] ] - bc [ 0 ] * x [ bc [ 0 ] ] <NEWLINE> x [ bc [ 1 ] ] += x [ bc [ 0 ] ] <NEWLINE> x [ bc [ 0 ] ] = 0 <NEWLINE> print ( sum0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 0 <NEWLINE> mini = P [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mini = min ( mini , P [ i ] ) <NEWLINE> if ( mini >= P [ i ] ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a > 0 and b < 0 ) or ( a < 0 and b > 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( ( a + b ) + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def check_road ( start , road_array , mark_array ) : <NEWLINE> <INDENT> search_target = [ ] <NEWLINE> search_target . append ( start ) <NEWLINE> <NL> while len ( search_target ) > 0 : <NEWLINE> <INDENT> target = search_target [ 0 ] <NEWLINE> if len ( road_array [ target ] ) != 0 : <NEWLINE> <INDENT> for road in road_array [ target ] : <NEWLINE> <INDENT> if road is not None and mark_array [ road ] is None and road != 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> mark_array [ road ] = target <NEWLINE> search_target . append ( road ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> del search_target [ 0 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> road_array = [ [ None ] for i in range ( N + 1 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp_a = road_array [ a ] <NEWLINE> tmp_b = road_array [ b ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> tmp_a . append ( b ) <NEWLINE> tmp_b . append ( a ) <NEWLINE> road_array [ a ] = tmp_a <NEWLINE> road_array [ b ] = tmp_b <NEWLINE> <NL> <DEDENT> mark_array = [ None ] * ( N + 1 ) <NEWLINE> check_road ( 1 , road_array , mark_array ) <NEWLINE> mark_array = mark_array [ 2 : ] <NEWLINE> <NL> if None in mark_array : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for mark in mark_array : <NEWLINE> <INDENT> print ( mark ) <NEWLINE> <DEDENT> <DEDENT>
N , K = ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> p = list ( ( int ( a ) + 1 ) / 2 for a in input ( ) . split ( ) ) <NEWLINE> s = [ sum ( p [ : K ] ) ] <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> s . append ( s [ - 1 ] - p [ i ] + p [ i + K ] ) <NEWLINE> <DEDENT> print ( max ( s ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> def IS ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def II ( ) : return int ( IS ( ) ) <NEWLINE> def MII ( ) : return list ( map ( int , IS ( ) . split ( ) ) ) <NEWLINE> def MIIZ ( ) : return list ( map ( lambda x : x - 1 , MII ( ) ) ) <NEWLINE> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> aa = MII ( ) <NEWLINE> t = 1 <NEWLINE> if 0 in aa : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return None <NEWLINE> <DEDENT> for a in aa : <NEWLINE> <INDENT> t *= a <NEWLINE> if t > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return None <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format ( data [ 0 ] , data [ 1 ] , data [ 2 ] ) ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = sys . stdin . readlines ( ) <NEWLINE> ans = collections . Counter ( s ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> rst = [ 0 for j in range ( 2019 ) ] <NEWLINE> rst [ 0 ] = 1 <NEWLINE> x = 0 <NEWLINE> ans = 0 <NEWLINE> drst = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> y = ( int ( s [ n - 1 - i ] ) * drst ) % 2019 <NEWLINE> drst = ( drst * 10 ) % 2019 <NEWLINE> x += y <NEWLINE> if x >= 2019 : <NEWLINE> <INDENT> x %= 2019 <NEWLINE> <COMMENT> <NL> <DEDENT> ans += rst [ x ] <NEWLINE> rst [ x ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> ans [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 0 ) ) <NEWLINE>
mod2019 = [ 0 ] * 2019 <NEWLINE> mod2019 [ 0 ] = 1 <NEWLINE> t = input ( ) <NEWLINE> n = len ( t ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( int ( t [ i ] ) ) <NEWLINE> <DEDENT> x = 1 <NEWLINE> y = 0 <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> y += s [ i ] * x <NEWLINE> mod2019 [ y % 2019 ] += 1 <NEWLINE> x = ( x * 10 ) % 2019 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += mod2019 [ i ] * ( mod2019 [ i ] - 1 ) <NEWLINE> <DEDENT> print ( ans // 2 ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pl = [ ] <NEWLINE> mi = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pl . append ( i + ai [ i ] ) <NEWLINE> mi . append ( i - ai [ i ] ) <NEWLINE> <DEDENT> x = Counter ( pl ) <NEWLINE> y = Counter ( mi ) <NEWLINE> cnt = 0 <NEWLINE> for i in x . keys ( ) : <NEWLINE> <INDENT> cnt += x [ i ] * y [ i ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 == a [ a [ i ] - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import sys <NEWLINE> for i in range ( 300 ) : <NEWLINE> <NL> <INDENT> if X - i not in p : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif X + i not in p : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) [ : : - 1 ] <NEWLINE> N = len ( S ) <NEWLINE> amari = [ 0 for i in range ( 2019 ) ] <NEWLINE> before = int ( S [ 0 ] ) <NEWLINE> amari [ before ] += 1 <NEWLINE> S = S [ 1 : : ] <NEWLINE> keta = 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> i = int ( i ) <NEWLINE> keta = ( keta * 10 ) % 2019 <NEWLINE> x = ( keta * i + before ) % 2019 <NEWLINE> amari [ x ] += 1 <NEWLINE> before = x <NEWLINE> <DEDENT> ans = amari [ 0 ] <NEWLINE> for i in amari : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
line = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for n in range ( line ) : <NEWLINE> <INDENT> nums . append ( int ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> maxd = nums [ 1 ] - nums [ 0 ] <NEWLINE> minv = nums [ 0 ] <NEWLINE> <NL> for j in range ( 1 , line ) : <NEWLINE> <INDENT> maxd = max ( maxd , nums [ j ] - minv ) <NEWLINE> minv = min ( minv , nums [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( maxd ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = [ int ( i ) for i in s ] <NEWLINE> pc = s . count ( <STRING> ) <NEWLINE> <NL> def popcnt ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return f ( x % popcnt ( x ) ) + 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for a in range ( 2 ) : <NEWLINE> <INDENT> npc = pc <NEWLINE> if a == 0 : <NEWLINE> <INDENT> npc += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> npc -= 1 <NEWLINE> <NL> <DEDENT> if npc <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> r0 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r0 = ( r0 * 2 ) % npc <NEWLINE> r0 += x [ i ] <NEWLINE> <NL> <DEDENT> k = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if x [ i ] == a : <NEWLINE> <INDENT> r = r0 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> r = ( r + k ) % npc <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( r - k + npc ) % npc <NEWLINE> <DEDENT> ans [ i ] = f ( r ) + 1 <NEWLINE> <DEDENT> k = ( k * 2 ) % npc <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = INT ( ) <NEWLINE> <NL> memo = [ 0 ] * 50 <NEWLINE> memo [ 0 ] = memo [ 1 ] = 1 <NEWLINE> def rec ( n ) : <NEWLINE> <INDENT> if memo [ n ] : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> memo [ n ] = rec ( n - 1 ) + rec ( n - 2 ) <NEWLINE> return memo [ n ] <NEWLINE> <NL> <DEDENT> print ( rec ( N ) ) <NEWLINE> <NL>
import sys <NEWLINE> S = sys . stdin . read ( ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( S . count ( <STRING> ) + S . count ( <STRING> ) ) ) <NEWLINE> <NL> <NL>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = [ - 1 ] * ( N + 2 ) <NEWLINE> n [ 1 ] = 0 <NEWLINE> i = 0 <COMMENT> <NEWLINE> place_now = 1 <COMMENT> <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> i += 1 <COMMENT> <NEWLINE> place_now = A [ place_now - 1 ] <COMMENT> <NEWLINE> <NL> <NL> if n [ place_now ] != - 1 : <NEWLINE> <INDENT> a = n [ place_now ] <COMMENT> <NEWLINE> loop = i - a <COMMENT> <NEWLINE> break <NEWLINE> <NL> <DEDENT> n [ place_now ] = i <COMMENT> <NEWLINE> <NL> <DEDENT> if a >= K : <NEWLINE> <INDENT> print ( n . index ( K ) ) <NEWLINE> <DEDENT> elif a < K : <NEWLINE> <INDENT> k_remain = ( K - a ) % loop + a <NEWLINE> print ( n . index ( k_remain ) ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( an ) for an in input ( ) . split ( ) ] <NEWLINE> divider = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> total = sum ( a ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> tmp += ai <NEWLINE> ans = ( ans + a [ i ] * ( total - tmp ) ) % divider <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> temp = sorted ( list ( input ( ) ) ) <NEWLINE> s . append ( <STRING> . join ( temp ) ) <NEWLINE> <DEDENT> s_count = Counter ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in s_count : <NEWLINE> <INDENT> ans += ( ( s_count [ i ] ) * ( s_count [ i ] - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> sum += int ( n [ i ] ) ; <NEWLINE> <DEDENT> if ( sum % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for s in map ( lambda l : list ( l . rstrip ( ) ) , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> char_code = ord ( c ) <NEWLINE> if 97 <= char_code <= 122 : <NEWLINE> <INDENT> char_code = char_code + 1 if char_code < 122 else 97 <NEWLINE> s [ i ] = chr ( char_code ) <NEWLINE> <NL> <DEDENT> <DEDENT> _s = <STRING> . join ( s ) <NEWLINE> if <STRING> in _s or <STRING> in _s or <STRING> in _s : <NEWLINE> <INDENT> print ( _s ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , k = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> count += k <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> count += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 2 * a + b - k <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cmdline = input ( ) . split ( ) <NEWLINE> <NL> if cmdline [ 0 ] == <STRING> : <NEWLINE> <INDENT> L . appendleft ( cmdline [ 1 ] ) <NEWLINE> <DEDENT> elif cmdline [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> L . remove ( cmdline [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : pass <NEWLINE> <DEDENT> elif cmdline [ 0 ] == <STRING> : <NEWLINE> <INDENT> L . popleft ( ) <NEWLINE> <DEDENT> elif cmdline [ 0 ] == <STRING> : <NEWLINE> <INDENT> L . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( L ) ) <NEWLINE>
T , S , E , W , N , B = range ( 6 ) <NEWLINE> <NL> class Dice : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . state = list ( range ( 6 ) ) <NEWLINE> <NL> <DEDENT> def __eq__ ( self , dice ) : <NEWLINE> <INDENT> return self . state == dice . state <NEWLINE> <NL> <DEDENT> def __gt__ ( self , dice ) : <NEWLINE> <INDENT> return self . state > dice . state <NEWLINE> <NL> <DEDENT> def copy ( self ) : <NEWLINE> <INDENT> dice = Dice ( ) <NEWLINE> dice . state = [ x for x in self . state ] <NEWLINE> return dice <NEWLINE> <NL> <DEDENT> def _turn ( self , turn ) : <NEWLINE> <INDENT> k = self . state [ turn [ - 1 ] ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> self . state [ turn [ i ] ] , k = k , self . state [ turn [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> def go_south ( self ) : <NEWLINE> <INDENT> turn = [ T , S , B , N ] <NEWLINE> self . _turn ( turn ) <NEWLINE> <NL> <DEDENT> def go_north ( self ) : <NEWLINE> <INDENT> turn = [ N , B , S , T ] <NEWLINE> self . _turn ( turn ) <NEWLINE> <NL> <DEDENT> def go_east ( self ) : <NEWLINE> <INDENT> turn = [ T , E , B , W ] <NEWLINE> self . _turn ( turn ) <NEWLINE> <NL> <DEDENT> def go_west ( self ) : <NEWLINE> <INDENT> turn = [ T , W , B , E ] <NEWLINE> self . _turn ( turn ) <NEWLINE> <NL> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> return self . state [ N ] <NEWLINE> <NL> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> return self . state [ S ] <NEWLINE> <NL> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> return self . state [ E ] <NEWLINE> <NL> <DEDENT> def west ( self ) : <NEWLINE> <INDENT> return self . state [ W ] <NEWLINE> <NL> <DEDENT> def bottom ( self ) : <NEWLINE> <INDENT> return self . state [ B ] <NEWLINE> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return self . state [ T ] <NEWLINE> <NL> <DEDENT> def goto ( self , n ) : <NEWLINE> <INDENT> func = [ self . go_west , self . go_north , self . go_east , self . go_south ] <NEWLINE> func [ n ] ( ) <NEWLINE> <NL> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> d = list ( <STRING> ) <NEWLINE> for x , s in zip ( d , self . state ) : <NEWLINE> <INDENT> print ( x + <STRING> . format ( s ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> import heapq <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> dp = [ [ [ [ INF for _ in range ( 6 ) ] for i in range ( 6 ) ] for j in range ( 10 ) ] for k in range ( 10 ) ] <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cost = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> sy , sx = map ( int , input ( ) . split ( ) ) <NEWLINE> gy , gx = map ( int , input ( ) . split ( ) ) <NEWLINE> q = [ ] <NEWLINE> dice = Dice ( ) <NEWLINE> heapq . heappush ( q , [ 0 , sx , sy , dice ] ) <NEWLINE> dp [ sy ] [ sx ] [ dice . bottom ( ) ] [ dice . east ( ) ] <NEWLINE> <NL> ans = INF + 1 <NEWLINE> while q : <NEWLINE> <INDENT> c , x , y , dice = heapq . heappop ( q ) <NEWLINE> if x == gx and y == gy : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> continue <NEWLINE> <DEDENT> if c >= ans : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> ddx , ddy = dx [ i ] , dy [ i ] <NEWLINE> if x + ddx >= w or x + ddx < 0 or y + ddy >= h or y + ddy < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = dice . copy ( ) <NEWLINE> d . goto ( i ) <NEWLINE> <NL> new_cost = c + ( d . bottom ( ) + 1 ) * cost [ y + ddy ] [ x + ddx ] <NEWLINE> if dp [ y + ddy ] [ x + ddx ] [ d . bottom ( ) ] [ d . east ( ) ] > new_cost : <NEWLINE> <INDENT> dp [ y + ddy ] [ x + ddx ] [ d . bottom ( ) ] [ d . east ( ) ] = new_cost <NEWLINE> heapq . heappush ( q , [ new_cost , x + ddx , y + ddy , d ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> m , n = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> matrix = [ [ 0 for j in range ( n + 1 ) ] for i in range ( m + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> matrix [ i ] [ j ] = tmp [ j ] <NEWLINE> matrix [ i ] [ n ] += tmp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> matrix [ m ] [ j ] += matrix [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m + 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( matrix [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( matrix [ i ] [ n ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> cnt = { } <NEWLINE> kouho = [ ] <NEWLINE> erat = [ True for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] not in cnt : <NEWLINE> <INDENT> cnt [ arr [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ arr [ i ] ] += 1 <NEWLINE> <DEDENT> if erat [ arr [ i ] ] : <NEWLINE> <INDENT> kouho . append ( arr [ i ] ) <NEWLINE> tp = arr [ i ] <NEWLINE> while True : <NEWLINE> <INDENT> erat [ tp ] = False <NEWLINE> tp += arr [ i ] <NEWLINE> if tp > 10 ** 6 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in kouho : <NEWLINE> <INDENT> if cnt [ k ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> left = 4 * a * b <NEWLINE> right = ( c - a - b ) ** 2 <NEWLINE> if ( c - a - b ) < 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if left < right : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( main ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> i = 102 <NEWLINE> for x in range ( 1 , i ) : <NEWLINE> <INDENT> for y in range ( 1 , i ) : <NEWLINE> <INDENT> for z in range ( 1 , i ) : <NEWLINE> <INDENT> total = ( x + y + z ) ** 2 - ( x * y + y * z + x * z ) <NEWLINE> if total <= N : <NEWLINE> <INDENT> ans [ total ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 10 ** 9 <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> t1 = abs ( X [ i ] ) + abs ( X [ i ] - X [ i + k - 1 ] ) <NEWLINE> t2 = abs ( X [ i + k - 1 ] ) + abs ( X [ i ] - X [ i + k - 1 ] ) <NEWLINE> t = min ( t1 , t2 ) <NEWLINE> <NL> ans = min ( ans , t ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> line = list ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> bottom_w = N <NEWLINE> top = 0 <NEWLINE> count = 0 <NEWLINE> while ( bottom_w > top ) : <NEWLINE> <INDENT> for i in reversed ( range ( bottom_w ) ) : <NEWLINE> <INDENT> if ( line [ i ] == <STRING> ) : <NEWLINE> <INDENT> bottom_w = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( line [ - 1 ] == <STRING> and bottom_w == N ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( bottom_w <= top ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( top , N ) : <NEWLINE> <INDENT> if ( i == N - 1 ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( line [ i ] == <STRING> and bottom_w > i ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> count += 1 <NEWLINE> line [ bottom_w ] = <STRING> <NEWLINE> top = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> TF = { a : True for a in A } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if TF [ A [ i ] ] == True : <NEWLINE> <INDENT> if i > 0 and A [ i - 1 ] == A [ i ] : <NEWLINE> <INDENT> TF [ A [ i ] ] = False <NEWLINE> <DEDENT> m = A [ N - 1 ] // A [ i ] <NEWLINE> for j in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> s = A [ i ] * j <NEWLINE> if s in TF : <NEWLINE> <INDENT> TF [ s ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( [ 1 for a in A if TF [ a ] == True ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a - 1 ] . append ( b - 1 ) <NEWLINE> l [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> <NL> p = [ 0 ] * n <NEWLINE> ans = [ 0 ] * n <NEWLINE> d = deque ( ) <NEWLINE> d . append ( 0 ) <NEWLINE> while len ( d ) != 0 : <NEWLINE> <INDENT> now = d . popleft ( ) <NEWLINE> for to in l [ now ] : <NEWLINE> <INDENT> if p [ to ] == 0 : <NEWLINE> <INDENT> p [ to ] = p [ now ] + 1 <NEWLINE> d . append ( to ) <NEWLINE> ans [ to ] = now <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if b > n : <NEWLINE> <INDENT> print ( ( a * n ) // b - a * ( n // b ) ) <NEWLINE> <DEDENT> elif b <= n : <NEWLINE> <INDENT> print ( ( a * ( b - 1 ) ) // b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( input ( ) . rstrip ( ) ) <NEWLINE> <DEDENT> print ( len ( list ( set ( l ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> p . append ( S ) <NEWLINE> <NL> <DEDENT> print ( len ( list ( set ( p ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numbers = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numbers . append ( 0 ) <NEWLINE> <NL> <DEDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> a = List [ j ] <NEWLINE> numbers [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( numbers [ i ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> dp = [ - 1 ] * N <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> idx = bisect . bisect_left ( dp , a ) <NEWLINE> dp [ idx - 1 ] = a <NEWLINE> <DEDENT> print ( len ( dp [ bisect . bisect_left ( dp , 0 ) : ] ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> r = <STRING> <NEWLINE> x = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r = r <NEWLINE> <DEDENT> elif i != <STRING> : <NEWLINE> <INDENT> x = 1 <NEWLINE> r = r + i <NEWLINE> <DEDENT> elif x == 1 and i == <STRING> : <NEWLINE> <INDENT> r = r + i <NEWLINE> <DEDENT> <DEDENT> if len ( r ) == 0 : <NEWLINE> <INDENT> r = <STRING> <NEWLINE> <DEDENT> A = int ( a ) <NEWLINE> B = int ( r ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q = sorted ( p ) <NEWLINE> <NL> print ( sum ( q [ : k ] ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if ( a + d - 1 ) // d >= ( c + b - 1 ) // b else <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> if y == 2 * x or y == 4 * x : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x ) : <NEWLINE> <INDENT> for j in range ( x ) : <NEWLINE> <INDENT> if ( i + j ) == x : <NEWLINE> <INDENT> if ( 2 * i ) + ( 4 * j ) == y : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if count < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def perfect_swap ( ) : <NEWLINE> <INDENT> global n , a , b , cost <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ai , aj = a [ i ] , a [ j ] <NEWLINE> if ai == b [ j ] and aj == b [ i ] : <NEWLINE> <INDENT> a [ i ] , a [ j ] = aj , ai <NEWLINE> cost += ai + aj <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def lowest_swap ( ) : <NEWLINE> <INDENT> global n , a , b , cost <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> bi , tmp_cost , count = b [ i ] , 0 , 0 <NEWLINE> while a [ i ] != bi : <NEWLINE> <INDENT> si = a . index ( bi ) <NEWLINE> bsi = b [ si ] <NEWLINE> sj = a . index ( bsi ) <NEWLINE> a [ si ] , a [ sj ] = bsi , bi <NEWLINE> tmp_cost += bi + bsi <NEWLINE> count += 1 <NEWLINE> <DEDENT> if count : <NEWLINE> <INDENT> if i : <NEWLINE> <INDENT> b0 = b [ 0 ] <NEWLINE> cost += min ( tmp_cost , ( bi + b0 ) * 2 + tmp_cost - ( bi - b0 ) * count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost += tmp_cost <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , a , cost = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , 0 <NEWLINE> b = sorted ( a ) <NEWLINE> perfect_swap ( ) <NEWLINE> lowest_swap ( ) <NEWLINE> print ( cost ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input_methods = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> using_method = 0 <NEWLINE> input_method = input_methods [ using_method ] <NEWLINE> <NL> tin = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lin = lambda : list ( tin ( ) ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> <COMMENT> <NL> <NL> def cc ( al ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for ( c , s , f ) in al : <NEWLINE> <INDENT> if ret <= s : <NEWLINE> <INDENT> ret = s + c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st = ( ( ret + f - 1 ) // f ) * f <NEWLINE> ret = st + c <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> al = [ lin ( ) for _ in range ( n - 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cc ( al [ i : ] ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> isTest = False <NEWLINE> <NL> def pa ( v ) : <NEWLINE> <INDENT> if isTest : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> def input_clipboard ( ) : <NEWLINE> <INDENT> import clipboard <NEWLINE> input_text = clipboard . get ( ) <NEWLINE> input_l = input_text . splitlines ( ) <NEWLINE> for l in input_l : <NEWLINE> <INDENT> yield l <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if sys . platform == <STRING> : <NEWLINE> <INDENT> if input_method == input_methods [ 0 ] : <NEWLINE> <INDENT> ic = input_clipboard ( ) <NEWLINE> input = lambda : ic . __next__ ( ) <NEWLINE> <DEDENT> elif input_method == input_methods [ 1 ] : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> isTest = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ret = main ( ) <NEWLINE> if ret is not None : <NEWLINE> <INDENT> print ( ret ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> class Graph : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> global n <NEWLINE> self . graph = defaultdict ( list ) <NEWLINE> self . parent = [ None for i in range ( 0 , n + 1 ) ] <NEWLINE> <DEDENT> def addEdge ( self , u , v ) : <NEWLINE> <INDENT> self . graph [ u ] . append ( v ) <NEWLINE> <DEDENT> def BFS ( self , s ) : <NEWLINE> <INDENT> visited = [ False ] * ( len ( self . graph ) + 1 ) <NEWLINE> queue = [ ] <NEWLINE> queue . append ( s ) <NEWLINE> while queue : <NEWLINE> <INDENT> s = queue . pop ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> for i in self . graph [ s ] : <NEWLINE> <NL> <INDENT> if visited [ i ] == False : <NEWLINE> <INDENT> self . parent [ i ] = s <NEWLINE> queue . append ( i ) <NEWLINE> visited [ i ] = True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> [ n , m ] = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> g = Graph ( ) <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> [ a , b ] = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> g . addEdge ( a , b ) <NEWLINE> g . addEdge ( b , a ) <NEWLINE> <COMMENT> <NL> <DEDENT> g . BFS ( 1 ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if g . parent [ i ] == None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( g . parent [ i ] ) <NEWLINE> 9 <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = sum ( A ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> d [ a ] = d . get ( a , 0 ) + 1 <NEWLINE> <NL> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if d . get ( b , 0 ) != 0 : <NEWLINE> <NL> <INDENT> temp = d [ b ] <NEWLINE> d [ b ] -= temp <NEWLINE> d [ c ] = d . get ( c , 0 ) + temp <NEWLINE> <NL> sum_a += ( c - b ) * temp <NEWLINE> <DEDENT> print ( sum_a ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> def GCD ( x ) : <NEWLINE> <INDENT> return reduce ( math . gcd , x ) <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> <NL> for x in combinations_with_replacement ( range ( 1 , K + 1 ) , 3 ) : <NEWLINE> <INDENT> if x [ 0 ] == x [ 1 ] == x [ 2 ] : <NEWLINE> <INDENT> s += GCD ( x ) <NEWLINE> <DEDENT> elif x [ 0 ] == x [ 1 ] or x [ 1 ] == x [ 2 ] or x [ 0 ] == x [ 2 ] : <NEWLINE> <INDENT> s += GCD ( x ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += GCD ( x ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> Alist . sort ( ) <NEWLINE> Amax = Alist [ - 1 ] <NEWLINE> dp = [ 1 ] * ( Amax + 1 ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( Alist ) - 1 ) : <NEWLINE> <INDENT> p = Alist [ i ] <NEWLINE> if dp [ p ] == 1 : <NEWLINE> <INDENT> for j in range ( Amax // p + 1 ) : <NEWLINE> <INDENT> dp [ p * j ] = 0 <NEWLINE> <DEDENT> if Alist [ i ] != Alist [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ Amax ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> a = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( num ) <NEWLINE> list ( map ( lambda x : print ( c [ x ] ) , range ( 1 , a + 1 ) ) ) <NEWLINE>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> s += int ( n [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> if s % 9 == 0 else <STRING> ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> board = [ [ i for i in input ( ) ] for _ in range ( h ) ] <NEWLINE> <NL> def check ( i , j ) : <NEWLINE> <INDENT> if ( j - 1 >= 0 ) : <NEWLINE> <INDENT> if ( board [ i ] [ j - 1 ] == <STRING> ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if ( j + 1 < w ) : <NEWLINE> <INDENT> if ( board [ i ] [ j + 1 ] == <STRING> ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if ( i - 1 >= 0 ) : <NEWLINE> <INDENT> if ( board [ i - 1 ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if ( i + 1 < h ) : <NEWLINE> <INDENT> if ( board [ i + 1 ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( board [ i ] [ j ] == <STRING> ) : <NEWLINE> <INDENT> if ( check ( i , j ) ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ca = [ ] <NEWLINE> a = [ ] <NEWLINE> c = [ ] <NEWLINE> ans = 1e9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ca . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c . append ( ca [ i ] [ 0 ] ) <NEWLINE> a . append ( ca [ i ] [ 1 : ] ) <NEWLINE> <DEDENT> for i in range ( 1 << n ) : <NEWLINE> <INDENT> a_sum = [ 0 ] * m <NEWLINE> c_sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 == 1 : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> a_sum [ k ] += a [ j ] [ k ] <NEWLINE> <DEDENT> c_sum += c [ j ] <NEWLINE> <DEDENT> <DEDENT> if min ( a_sum ) >= x and c_sum < ans : <NEWLINE> <INDENT> ans = c_sum <NEWLINE> <DEDENT> <DEDENT> if ans == 1e9 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> s = 0 <NEWLINE> S = sum ( A ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> s += ( A [ i ] * ( S ) ) % mod <NEWLINE> <DEDENT> print ( s % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> c_list = [ 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> c_list . append ( count ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if max ( c_list ) >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sum ( A ) <NEWLINE> a = a ** 2 <NEWLINE> b = 0 <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> b += A [ j ] ** 2 <NEWLINE> <DEDENT> if a - b < 0 : <NEWLINE> <INDENT> c = a - b <NEWLINE> while c <= 0 : <NEWLINE> <INDENT> c += mod <NEWLINE> <NL> <DEDENT> ans = c // 2 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = ( a - b ) // 2 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> count = 0 <NEWLINE> <NL> from bisect import bisect_left as bi <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N - 1 ) : <NEWLINE> <INDENT> right = L [ j ] + L [ k ] <NEWLINE> ite_right = bi ( L , right ) <NEWLINE> count = count + ( ite_right - k - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
import math <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> r = float ( input ( ) ) <NEWLINE> equivalent_of_circle = math . pi * ( r ** 2 ) <NEWLINE> len_of_circle = math . pi * r * 2 <NEWLINE> print ( <STRING> % ( equivalent_of_circle , len_of_circle ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = n % k <NEWLINE> if n >= k : <NEWLINE> <INDENT> ans = min ( tmp , k - tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( n , k - n ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def cnt ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> j = i * n <NEWLINE> c += ( i + j ) * n // 2 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> print ( cnt ( N ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ 0 ] * Q <NEWLINE> C = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] , C [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> import collections <NEWLINE> A = collections . Counter ( a ) <NEWLINE> S = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> S = S + a [ j ] <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if B [ i ] in A : <NEWLINE> <INDENT> f = A . pop ( B [ i ] ) <NEWLINE> if C [ i ] in A : <NEWLINE> <INDENT> g = A [ C [ i ] ] <NEWLINE> h = f + g <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = f <NEWLINE> <DEDENT> A [ C [ i ] ] = h <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> S = S + f * ( C [ i ] - B [ i ] ) <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
f = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> N , M = f ( ) <NEWLINE> q = [ list ( f ( ) ) for _ in [ 0 ] * M ] <NEWLINE> res = - 1 <NEWLINE> A = list ( range ( 10 ** ( N - 1 ) , 10 ** N ) ) <NEWLINE> if N == 1 : A = [ 0 ] + A <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if str ( i ) [ q [ j ] [ 0 ] - 1 ] != str ( q [ j ] [ 1 ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> rowNum , columnNum = map ( int , input ( ) . split ( ) ) <NEWLINE> inMat = [ [ 0 ] * columnNum for i in range ( rowNum ) ] <NEWLINE> inColumnVec = [ [ 0 ] for i in range ( columnNum ) ] <NEWLINE> for row in range ( rowNum ) : <NEWLINE> <INDENT> inMat [ row ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> for column in range ( columnNum ) : <NEWLINE> <INDENT> inColumnVec [ column ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> timesAns = [ [ 0 ] for i in range ( rowNum ) ] <NEWLINE> <NL> <COMMENT> <NL> for row in range ( rowNum ) : <NEWLINE> <INDENT> timesAns [ row ] = 0 <NEWLINE> for column in range ( columnNum ) : <NEWLINE> <INDENT> timesAns [ row ] = timesAns [ row ] + inMat [ row ] [ column ] * inColumnVec [ column ] <NEWLINE> <NL> <DEDENT> <DEDENT> for row in range ( rowNum ) : <NEWLINE> <INDENT> print ( timesAns [ row ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> s = sys . stdin . readline ( ) <NEWLINE> <NL> print ( s . swapcase ( ) , end = <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a > 0 and b > 0 : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> t0 = int ( input ( ) ) <NEWLINE> t1 = int ( input ( ) ) <NEWLINE> tmpmin = t0 <NEWLINE> tmpmax = t1 - t0 <NEWLINE> tmpmin = min ( t0 , t1 ) <NEWLINE> <NL> for _ in range ( 2 , n ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> if t - tmpmin > tmpmax : <NEWLINE> <INDENT> tmpmax = t - tmpmin <NEWLINE> <DEDENT> if t < tmpmin : <NEWLINE> <INDENT> tmpmin = t <NEWLINE> <DEDENT> <DEDENT> print ( tmpmax ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = N + 1 , N + 1 , N + 1 <NEWLINE> dama = 0 <NEWLINE> count = 0 <NEWLINE> <NL> if Y // N == 10000 : <NEWLINE> <INDENT> print ( N , 0 , 0 ) <NEWLINE> <DEDENT> elif Y // N == 5000 : <NEWLINE> <INDENT> print ( 0 , N , 0 ) <NEWLINE> <DEDENT> elif Y // N == 1000 : <NEWLINE> <INDENT> print ( 0 , 0 , N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stop = False <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if stop : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b -= i <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if stop : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c -= i + j <NEWLINE> if i + j + c != N : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dama = 10000 * i + 5000 * j + 1000 * c <NEWLINE> if dama == Y : <NEWLINE> <INDENT> print ( i , j , c ) <NEWLINE> count += 1 <NEWLINE> stop = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> c = N <NEWLINE> <DEDENT> b = N + 1 <NEWLINE> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> X = str ( input ( ) ) <NEWLINE> <NL> number = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> number += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def culc ( x ) : <NEWLINE> <INDENT> bin_x = str ( bin ( x ) [ 2 : ] ) <NEWLINE> one = 0 <NEWLINE> for i in range ( len ( bin_x ) ) : <NEWLINE> <INDENT> if bin_x [ i ] == <STRING> : <NEWLINE> <INDENT> one += 1 <NEWLINE> <DEDENT> <DEDENT> return x % one <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> dp = [ - 1 ] * ( number + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> def rec ( x ) : <NEWLINE> <INDENT> if dp [ x ] >= 0 : <NEWLINE> <INDENT> return dp [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x ] = rec ( culc ( x ) ) + 1 <NEWLINE> return dp [ x ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if number == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> base1 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> base1 = ( base1 + pow ( 2 , n - i - 1 , number + 1 ) ) % ( number + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if number == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = ( base1 + pow ( 2 , n - i - 1 , number + 1 ) ) % ( number + 1 ) <NEWLINE> ans = rec ( temp ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> base2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> base2 = ( base2 + pow ( 2 , n - i - 1 , number - 1 ) ) % ( number - 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> temp = ( base1 + pow ( 2 , n - i - 1 , number + 1 ) ) % ( number + 1 ) <NEWLINE> ans = rec ( temp ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <COMMENT> <NL> <DEDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> temp = ( base2 - pow ( 2 , n - i - 1 , number - 1 ) ) % ( number - 1 ) <NEWLINE> ans = rec ( temp ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> a = 0 <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for r in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and i == r : <COMMENT> <NEWLINE> <INDENT> a += math . gcd ( i , math . gcd ( j , r ) ) <NEWLINE> <DEDENT> elif i == j or j == r : <COMMENT> <NEWLINE> <INDENT> a += math . gcd ( i , math . gcd ( j , r ) ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += math . gcd ( i , math . gcd ( j , r ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( ( n + 1 ) // 2 ) : <NEWLINE> <INDENT> if num [ 2 * i ] % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> price = [ x * ( - 1 ) for x in p ] <NEWLINE> heapq . heapify ( price ) <NEWLINE> while m != 0 : <NEWLINE> <INDENT> max_price = heapq . heappop ( price ) * ( - 1 ) <NEWLINE> heapq . heappush ( price , ( max_price // 2 ) * ( - 1 ) ) <NEWLINE> m -= 1 <NEWLINE> <DEDENT> print ( sum ( price ) * ( - 1 ) ) <NEWLINE>
from operator import add <NEWLINE> from functools import reduce <NEWLINE> <NL> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( r ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> b = [ ] <NEWLINE> <NL> for j in range ( c ) : <NEWLINE> <INDENT> a = [ x [ i ] [ j ] for i in range ( len ( x ) ) ] <NEWLINE> b . append ( reduce ( add , a ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> x . append ( b ) <NEWLINE> <NL> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> y = reduce ( add , x [ i ] ) <NEWLINE> x [ i ] . append ( y ) <NEWLINE> <NL> <NL> <DEDENT> z = [ list ( map ( str , x [ i ] ) ) for i in range ( len ( x ) ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> w = [ <STRING> . join ( z [ i ] ) for i in range ( len ( x ) ) ] <NEWLINE> <NL> [ print ( w [ i ] ) for i in range ( len ( w ) ) ] <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> ans += a [ i ] * s <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> a = na ( ) <NEWLINE> b = na ( ) <NEWLINE> c = na ( ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> <COMMENT> <NL> for bi in b : <NEWLINE> <INDENT> i = bisect_left ( a , bi ) <NEWLINE> j = bisect_right ( c , bi ) <NEWLINE> cnt += i * ( n - j ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> A , B , H , M = LI ( ) <NEWLINE> <NL> pi = math . pi <NEWLINE> h_p = [ A * math . cos ( 2 * pi * ( H * 60 + M ) / 720 ) , A * math . sin ( 2 * pi * ( H * 60 + M ) / 720 ) ] <NEWLINE> m_p = [ B * math . cos ( 2 * pi * M / 60 ) , B * math . sin ( 2 * pi * M / 60 ) ] <NEWLINE> <NL> <COMMENT> <NL> length = ( ( h_p [ 0 ] - m_p [ 0 ] ) ** 2 + ( h_p [ 1 ] - m_p [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> print ( length ) <NEWLINE>
t = input ( ) <NEWLINE> <NL> print ( t . replace ( <STRING> , <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <NEWLINE> cnt = i * n * ( n + 1 ) // 2 <NEWLINE> ans += cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> minnum = min ( a , b ) <NEWLINE> maxnum = max ( a , b ) <NEWLINE> lis = [ ] <NEWLINE> for mi in reversed ( range ( 1 , minnum + 1 ) ) : <NEWLINE> <INDENT> if minnum % mi == 0 and maxnum % mi == 0 : <NEWLINE> <INDENT> lis . append ( mi ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lis [ k - 1 ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> from collections import defaultdict <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> S = list ( ns ( ) ) <NEWLINE> T = list ( ns ( ) ) <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if ( S [ i + j ] != T [ j ] ) : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pre_score = 1 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> after_score = pre_score * a [ i ] / a [ i - k ] <NEWLINE> if after_score > pre_score : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if K * D <= abs ( X ) : <NEWLINE> <INDENT> print ( abs ( X ) - K * D ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> move_num_before = abs ( X ) // D <NEWLINE> move_num_after = move_num_before + 1 <NEWLINE> if ( K - move_num_after ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - move_num_after * D ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( abs ( X ) - move_num_before * D ) <NEWLINE> <NL> <NL>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> S_cnt = sorted ( S . count ( c ) for c in set ( S ) ) <NEWLINE> T_cnt = sorted ( T . count ( c ) for c in set ( T ) ) <NEWLINE> print ( <STRING> ) if S_cnt == T_cnt else print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> sum_ = 0 <NEWLINE> for ni in N : <NEWLINE> <INDENT> sum_ += int ( ni ) <NEWLINE> <NL> <DEDENT> if sum_ % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> K = int ( s ) <NEWLINE> <NL> if ( ( K & 1 == 0 ) or ( s [ - 1 ] == <STRING> ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K / 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> r = 10 <NEWLINE> while True : <NEWLINE> <INDENT> r = r % L <NEWLINE> if r == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> r *= 10 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> * l , = map ( int , input ( ) . split ( ) ) <NEWLINE> seenl = [ 1 ] <NEWLINE> seen = { 1 } <NEWLINE> temp = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> temp = l [ temp - 1 ] <NEWLINE> if temp in seen : <NEWLINE> <INDENT> lenloop = len ( seenl ) - seenl . index ( temp ) <NEWLINE> r = ( k - i - 1 ) % lenloop <NEWLINE> temp = seenl [ seenl . index ( temp ) : ] [ r ] <NEWLINE> break <NEWLINE> <DEDENT> seenl . append ( temp ) <NEWLINE> seen . add ( temp ) <NEWLINE> <DEDENT> print ( temp ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> class MaxFlow : <NEWLINE> <INDENT> class Edge : <NEWLINE> <INDENT> def __init__ ( self , to , cap , rev ) : <NEWLINE> <INDENT> self . to , self . cap , self . rev = to , cap , rev <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self , node_size , inf ) : <NEWLINE> <INDENT> self . _node = node_size <NEWLINE> self . _inf = inf <NEWLINE> self . _level = [ - 1 ] * self . _node <NEWLINE> self . _iter = [ 0 ] * self . _node <NEWLINE> self . _graph = [ [ ] for _ in range ( self . _node ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , from_ , to , cap ) : <NEWLINE> <INDENT> self . _graph [ from_ ] . append ( self . Edge ( to , cap , len ( self . _graph [ to ] ) ) ) <NEWLINE> self . _graph [ to ] . append ( self . Edge ( from_ , 0 , len ( self . _graph [ from_ ] ) - 1 ) ) <NEWLINE> <NL> <DEDENT> def bfs ( self , start ) : <NEWLINE> <INDENT> self . _level = [ - 1 ] * self . _node <NEWLINE> que = deque ( ) <NEWLINE> self . _level [ start ] = 0 <NEWLINE> que . append ( start ) <NEWLINE> while que : <NEWLINE> <INDENT> cur_vertex = que . popleft ( ) <NEWLINE> for e in self . _graph [ cur_vertex ] : <NEWLINE> <INDENT> if e . cap > 0 > self . _level [ e . to ] : <NEWLINE> <INDENT> self . _level [ e . to ] = self . _level [ cur_vertex ] + 1 <NEWLINE> que . append ( e . to ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def dfs ( self , cur_vertex , end_vertex , flow ) : <NEWLINE> <INDENT> if cur_vertex == end_vertex : <NEWLINE> <INDENT> return flow <NEWLINE> <DEDENT> for e in self . _graph [ cur_vertex ] [ self . _iter [ cur_vertex ] : len ( self . _graph [ cur_vertex ] ) ] : <NEWLINE> <INDENT> if e . cap > 0 and self . _level [ cur_vertex ] < self . _level [ e . to ] : <NEWLINE> <INDENT> flowed = self . dfs ( e . to , end_vertex , min ( flow , e . cap ) ) <NEWLINE> if flowed > 0 : <NEWLINE> <INDENT> e . cap -= flowed <NEWLINE> self . _graph [ e . to ] [ e . rev ] . cap += flowed <NEWLINE> return flowed <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def solve ( self , source , sink ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> while True : <NEWLINE> <INDENT> self . bfs ( source ) <NEWLINE> if self . _level [ sink ] < 0 : <NEWLINE> <INDENT> return flow <NEWLINE> <DEDENT> self . _iter = [ 0 ] * self . _node <NEWLINE> while True : <NEWLINE> <INDENT> f = self . dfs ( source , sink , self . _inf ) <NEWLINE> if f == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flow += f <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> mf = MaxFlow ( n , 10 ** 10 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> mf . add_edge ( u , v , c ) <NEWLINE> <DEDENT> print ( mf . solve ( 0 , n - 1 ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> line = input ( ) . split ( ) <NEWLINE> <NL> MAX = 1000000000000000000 <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if not <STRING> in line : <NEWLINE> <INDENT> for l in line : <NEWLINE> <INDENT> if l == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if not ans > MAX : <NEWLINE> <INDENT> ans = int ( l ) * ans <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <NL> <DEDENT> if ans <= MAX : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ ] <NEWLINE> s = [ 0 ] * M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> del a [ 0 ] <NEWLINE> a . sort ( ) <NEWLINE> b . append ( a ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( len ( b [ i ] ) ) : <NEWLINE> <INDENT> s [ b [ i ] [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s . count ( N ) ) <NEWLINE>
alphabeta = <STRING> <NEWLINE> all_str = set ( alphabeta ) <NEWLINE> str = input ( ) <NEWLINE> str = set ( str ) <NEWLINE> <NL> <NL> use = all_str - str <NEWLINE> if use == set ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sorted ( use ) [ 0 ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> count = int ( input ( ) ) <NEWLINE> su_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( su_list ) <NEWLINE> for i in range ( 1 , count + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = set ( ) <NEWLINE> B = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if len ( s ) >= 5 : <NEWLINE> <INDENT> A . add ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . add ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( A ) + len ( B ) ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] != S [ K - 1 ] : <NEWLINE> <INDENT> S = S . replace ( S [ i ] , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> x_sort = sorted ( x ) <NEWLINE> a = x_sort [ 1 : n ] <NEWLINE> a_med = a [ n // 2 - 1 ] <NEWLINE> b = x_sort [ 0 : n - 1 ] <NEWLINE> b_med = b [ n // 2 - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] < a_med : <NEWLINE> <INDENT> ans [ i ] = a_med <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = b_med <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> Sp = [ ] <NEWLINE> Sm = [ ] <NEWLINE> total = 0 <NEWLINE> bm = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = readline ( ) . strip ( ) <NEWLINE> b = 0 <NEWLINE> h = 0 <NEWLINE> for j in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ j ] == <STRING> : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h -= 1 <NEWLINE> <DEDENT> b = min ( b , h ) <NEWLINE> <DEDENT> if h == 0 and b != 0 : <NEWLINE> <INDENT> bm = min ( bm , b ) <NEWLINE> <DEDENT> elif h > 0 : <NEWLINE> <INDENT> Sp . append ( [ b , h ] ) <NEWLINE> <DEDENT> elif h < 0 : <NEWLINE> <INDENT> Sm . append ( [ b - h , - h ] ) <NEWLINE> <DEDENT> total += h <NEWLINE> <DEDENT> Sp . append ( [ bm , 0 ] ) <NEWLINE> if total != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> Sp . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> p = check ( Sp ) <NEWLINE> if p < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> Sm . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> m = check ( Sm ) <NEWLINE> if m < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def check ( S ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if h + S [ i ] [ 0 ] < 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h += S [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> return h <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Pmin = [ 2 * 10 ** 5 for i in range ( N ) ] <NEWLINE> Pmin [ 0 ] = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> Pmin [ i ] = min ( Pmin [ i - 1 ] , P [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if Pmin [ i ] >= P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> n , s = int ( input ( ) ) , input ( ) <NEWLINE> c = Counter ( s ) <NEWLINE> d = list ( c . values ( ) ) <NEWLINE> if len ( d ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = d [ 0 ] * d [ 1 ] * d [ 2 ] <NEWLINE> rgb = { <STRING> , <STRING> , <STRING> } <NEWLINE> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> x = s [ j : : i ] <NEWLINE> for a , b , c in zip ( x , x [ 1 : ] , x [ 2 : ] ) : <NEWLINE> <INDENT> g = { a , b , c } <NEWLINE> if g == rgb : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = set ( [ int ( input ( ) ) for _ in range ( M ) ] ) <NEWLINE> <NL> lis = [ 0 ] * ( N + 1 ) <NEWLINE> lis [ 0 ] = 1 <NEWLINE> <NL> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> lis [ i ] = ( lis [ i - 1 ] + lis [ i - 2 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> if i in A : <NEWLINE> <INDENT> lis [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lis [ N ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nlist = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if nlist [ i ] > nlist [ i + 1 ] : <NEWLINE> <INDENT> count += nlist [ i ] - nlist [ i + 1 ] <NEWLINE> nlist [ i + 1 ] = nlist [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> import io <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> def solve ( n , k , a_lst ) : <NEWLINE> <COMMENT> <NL> <INDENT> a_set = set ( a_lst ) <NEWLINE> ak = len ( a_set ) <NEWLINE> diff = ak - k <NEWLINE> if diff < 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a_lst . sort ( ) <NEWLINE> tmp = a_lst [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> cnt_lst = [ ] <NEWLINE> for i in range ( len ( a_lst ) ) : <NEWLINE> <INDENT> if tmp != a_lst [ i ] : <NEWLINE> <INDENT> tmp = a_lst [ i ] <NEWLINE> cnt_lst . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> cnt_lst . append ( cnt ) <NEWLINE> cnt_lst . sort ( ) <NEWLINE> return sum ( cnt_lst [ 0 : diff ] ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = str ( solve ( n , k , a_lst ) ) <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> _DEB = 0 <COMMENT> <NEWLINE> <NL> _INPUT = <STRING> <NEWLINE> _EXPECTED = <STRING> <NEWLINE> <NL> def logd ( str ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if _DEB : print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if _DEB : <NEWLINE> <INDENT> sys . stdin = io . StringIO ( _INPUT ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> ans = main ( ) <NEWLINE> <NL> if _DEB : <NEWLINE> <INDENT> print ( ) <NEWLINE> if _EXPECTED . strip ( ) == ans . strip ( ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxA = max ( A ) <NEWLINE> ans = 0 <NEWLINE> flag = [ 0 ] * ( maxA + 1 ) <NEWLINE> <NL> <COMMENT> <NL> for a in A : <NEWLINE> <INDENT> for ax in range ( a , maxA + 1 , a ) : <NEWLINE> <INDENT> flag [ ax ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for a in set ( A ) : <NEWLINE> <INDENT> if flag [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( float ( B ) * 1000 ) <NEWLINE> ans = A * B <NEWLINE> <NL> print ( int ( A * B ) // 1000 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 or ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ [ 0 ] * 2 for i in range ( n ) ] <NEWLINE> dk = [ [ 0 ] * 2 for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> dp [ 0 ] [ 0 ] = 1000 <NEWLINE> dk [ 0 ] [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> dp [ 0 ] [ 1 ] = 1000 % a [ 0 ] <NEWLINE> dk [ 0 ] [ 1 ] = 1000 // a [ 0 ] <NEWLINE> <NL> for k in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ k ] [ 0 ] = max ( dp [ k - 1 ] [ 0 ] , dp [ k - 1 ] [ 1 ] + dk [ k - 1 ] [ 1 ] * a [ k ] ) <NEWLINE> dk [ k ] [ 0 ] = 0 <NEWLINE> <NL> dpk1 = dp [ k - 1 ] [ 0 ] % a [ k ] <NEWLINE> dkk1 = dp [ k - 1 ] [ 0 ] // a [ k ] <NEWLINE> v1 = dk [ k - 1 ] [ 1 ] * a [ k ] + dp [ k - 1 ] [ 1 ] <NEWLINE> v2 = dkk1 * a [ k ] + dpk1 <NEWLINE> <COMMENT> <NL> if v2 > v1 : <NEWLINE> <INDENT> dk [ k ] [ 1 ] = dkk1 <NEWLINE> dp [ k ] [ 1 ] = dpk1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ k ] [ 1 ] = dp [ k - 1 ] [ 1 ] <NEWLINE> dk [ k ] [ 1 ] = dk [ k - 1 ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n - 1 ] [ 0 ] ) <NEWLINE>
x = list ( input ( ) ) <NEWLINE> first = 10 * int ( x [ 0 ] ) + int ( x [ 1 ] ) <NEWLINE> second = 10 * int ( x [ 2 ] ) + int ( x [ 3 ] ) <NEWLINE> <NL> <NL> def mc ( num ) : <NEWLINE> <INDENT> if 1 <= num <= 12 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def yc ( num ) : <NEWLINE> <INDENT> if 0 <= num <= 99 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if yc ( first ) : <NEWLINE> <INDENT> if mc ( second ) : <NEWLINE> <INDENT> if yc ( second ) : <NEWLINE> <INDENT> if mc ( first ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif yc ( second ) : <NEWLINE> <INDENT> if mc ( first ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif yc ( second ) : <NEWLINE> <INDENT> if mc ( first ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> competitor_H = { } <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A - 1 not in competitor_H . keys ( ) : <NEWLINE> <INDENT> competitor_H [ A - 1 ] = [ ] <NEWLINE> <DEDENT> competitor_H [ A - 1 ] . append ( H [ B - 1 ] ) <NEWLINE> <NL> if B - 1 not in competitor_H . keys ( ) : <NEWLINE> <INDENT> competitor_H [ B - 1 ] = [ ] <NEWLINE> <DEDENT> competitor_H [ B - 1 ] . append ( H [ A - 1 ] ) <NEWLINE> <NL> <DEDENT> countGood = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i not in competitor_H . keys ( ) : <NEWLINE> <INDENT> countGood += 1 <NEWLINE> <DEDENT> elif H [ i ] > max ( competitor_H [ i ] ) : <NEWLINE> <INDENT> countGood += 1 <NEWLINE> <DEDENT> <DEDENT> print ( countGood ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> <NL> s = 1 <NEWLINE> ten18 = 10 ** 18 <NEWLINE> over = False <NEWLINE> <NL> for b in a : <NEWLINE> <INDENT> if not over : <NEWLINE> <INDENT> s *= b <NEWLINE> <DEDENT> if s > ten18 : <NEWLINE> <COMMENT> <NL> <INDENT> over = True <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> s = 0 <NEWLINE> over = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if over : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> a = x <NEWLINE> b = x <NEWLINE> <NL> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> b = b - 1 <NEWLINE> if b not in p : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif a not in p : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import copy <NEWLINE> S_dash = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> len_S = len ( S_dash ) <NEWLINE> len_T = len ( T ) <NEWLINE> <NL> candidate0 = list ( S_dash ) <NEWLINE> <NL> <NL> ans = <STRING> * 51 <NEWLINE> <NL> if len_S >= len_T : <NEWLINE> <INDENT> for s in range ( len_S ) : <NEWLINE> <INDENT> cha_S = S_dash [ s ] <NEWLINE> if cha_S != <STRING> and cha_S in list ( T ) : <NEWLINE> <INDENT> for t in range ( len_T ) : <NEWLINE> <INDENT> cha_T = T [ t ] <NEWLINE> if cha_S == cha_T and 0 <= s - t < len_S and 0 < s - t + len_T <= len_S : <NEWLINE> <INDENT> S_cut = S_dash [ s - t : s - t + len_T ] <NEWLINE> candidate1 = copy . deepcopy ( candidate0 ) <NEWLINE> for x in range ( len_T ) : <NEWLINE> <INDENT> if S_cut [ x ] == <STRING> : <NEWLINE> <INDENT> candidate1 [ s - t + x ] = T [ x ] <NEWLINE> <DEDENT> elif S_cut [ x ] != T [ x ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> . join ( candidate1 [ s - t : s - t + len_T ] ) == T : <NEWLINE> <INDENT> if ans > <STRING> . join ( candidate1 ) . replace ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> . join ( candidate1 ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for u in range ( len_S - len_T + 1 ) : <NEWLINE> <INDENT> cut_S = S_dash [ u : u + len_T ] <NEWLINE> if cut_S . count ( <STRING> ) == len_T : <NEWLINE> <INDENT> candidate1 = copy . deepcopy ( candidate0 ) <NEWLINE> for t in range ( len_T ) : <NEWLINE> <INDENT> candidate1 [ u + t ] = T [ t ] <NEWLINE> <DEDENT> if ans > <STRING> . join ( candidate1 ) . replace ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> . join ( candidate1 ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == <STRING> * 51 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> elif a < k and b > k - a : <NEWLINE> <INDENT> print ( 0 , ( b - k + a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> def getNearestValue ( list , num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> idx = np . abs ( np . asarray ( list ) - num ) . argmin ( ) <NEWLINE> return list [ idx ] <NEWLINE> <NL> <DEDENT> if M == 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check_set = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_set = set ( [ i for i in range ( - 1 , 102 ) ] ) <NEWLINE> lst = list ( ans_set - check_set ) <NEWLINE> sorted_lst = sorted ( lst ) <NEWLINE> print ( getNearestValue ( sorted_lst , N ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > c : <NEWLINE> <INDENT> print ( math . floor ( ( a * c ) / b ) - a * ( math . floor ( c / b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( ( a * ( b - 1 ) ) / b ) - a * ( math . floor ( ( b - 1 ) / b ) ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ruisekiwa = [ 0 ] * ( len ( a_list ) + 1 ) <NEWLINE> for i in range ( len ( a_list ) ) : <NEWLINE> <INDENT> ruisekiwa [ i + 1 ] = ruisekiwa [ i ] + a_list [ i ] <NEWLINE> <DEDENT> sum_ = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( len ( a_list ) ) : <NEWLINE> <INDENT> sum_ += ( ( a_list [ i ] % mod ) * ( ( ruisekiwa [ - 1 ] % mod ) - ( ruisekiwa [ i + 1 ] % mod ) ) ) % mod <NEWLINE> <DEDENT> print ( sum_ % mod ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> xy = [ LI ( ) for _ in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> interval = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> interval . append ( ( xy [ i ] [ 0 ] - xy [ j ] [ 0 ] , xy [ i ] [ 1 ] - xy [ j ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = collections . Counter ( interval ) <NEWLINE> nocost = max ( cnt . values ( ) ) <NEWLINE> ans = N - nocost <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> def modpow ( a , n ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> r = r * a % MOD <NEWLINE> <DEDENT> a = a * a % MOD <NEWLINE> n = n // 2 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> As . sort ( key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> As_srt = sorted ( As ) <NEWLINE> <NL> if N == K or ( As_srt [ - 1 ] < 0 and K % 2 == 1 ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= As [ N - i - 1 ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> sign = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= As [ i ] <NEWLINE> ans %= MOD <NEWLINE> if As [ i ] < 0 : <NEWLINE> <INDENT> sign *= - 1 <NEWLINE> <DEDENT> <DEDENT> if sign < 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> rm_p = None <NEWLINE> rm_n = None <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if rm_p != None and rm_n != None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if rm_p == None and As [ K - i - 1 ] > 0 : <NEWLINE> <INDENT> rm_p = As [ K - i - 1 ] <NEWLINE> <DEDENT> if rm_n == None and As [ K - i - 1 ] < 0 : <NEWLINE> <INDENT> rm_n = As [ K - i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> apd_zp = None <NEWLINE> apd_n = None <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if apd_zp != None and apd_n != None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if apd_zp == None and As [ K + i ] >= 0 : <NEWLINE> <INDENT> apd_zp = As [ K + i ] <NEWLINE> <DEDENT> if apd_n == None and As [ K + i ] < 0 : <NEWLINE> <INDENT> apd_n = As [ K + i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if rm_n == None or apd_zp == None : <NEWLINE> <INDENT> rm = rm_p <NEWLINE> apd = apd_n <NEWLINE> <DEDENT> elif rm_p == None or apd_n == None : <NEWLINE> <INDENT> rm = rm_n <NEWLINE> apd = apd_zp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( rm_p * apd_zp ) <= abs ( rm_n * apd_n ) : <NEWLINE> <INDENT> rm = rm_p <NEWLINE> apd = apd_n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rm = rm_n <NEWLINE> apd = apd_zp <NEWLINE> <DEDENT> <DEDENT> ans *= apd <NEWLINE> ans %= MOD <NEWLINE> rm_inv = modpow ( rm , MOD - 2 ) <NEWLINE> ans *= rm_inv <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ 0 ] * N <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> li [ B - 1 ] += 1 <NEWLINE> <DEDENT> elif H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> li [ A - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li [ A - 1 ] += 1 <NEWLINE> li [ B - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( li . count ( 0 ) ) <NEWLINE>
from scipy . special import comb <NEWLINE> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> count = Counter ( A ) <NEWLINE> combs = { k : comb ( count [ k ] , 2 ) for k in count . keys ( ) } <NEWLINE> combs_minas_one = { k : comb ( count [ k ] - 1 , 2 ) for k in count . keys ( ) } <NEWLINE> all = sum ( combs . values ( ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans = all - combs [ a ] + combs_minas_one [ a ] <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * ( n ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 1000000007 <NEWLINE> S = sum ( A ) % MOD <NEWLINE> ans = 0 <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> S -= x <NEWLINE> S %= MOD <NEWLINE> ans += S * x <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> <NL> have_number = [ ] <NEWLINE> have_who = [ ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> i = input ( ) . split ( ) <NEWLINE> j = input ( ) . split ( ) <NEWLINE> have_number . append ( i ) <NEWLINE> have_who . append ( j ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> list1 = [ ] <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> list1 . append ( k ) <NEWLINE> <DEDENT> list1 <NEWLINE> <NL> <COMMENT> <NL> t_have_who = sum ( have_who , [ ] ) <NEWLINE> for c in range ( 0 , len ( t_have_who ) ) : <NEWLINE> <INDENT> t_have_who [ c ] = int ( t_have_who [ c ] ) <NEWLINE> <DEDENT> t_have_who <NEWLINE> <NL> <COMMENT> <NL> list1 = set ( list1 ) <NEWLINE> t_have_who = set ( t_have_who ) <NEWLINE> diff = list1 ^ t_have_who <NEWLINE> <NL> print ( len ( diff ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 1 ] <NEWLINE> S = { 1 } <NEWLINE> <NL> def f ( L , S ) : <NEWLINE> <INDENT> last = L [ - 1 ] - 1 <NEWLINE> if A [ last ] not in S : <NEWLINE> <INDENT> L . append ( A [ last ] ) <NEWLINE> S |= { A [ last ] } <NEWLINE> return f ( L , S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return L <NEWLINE> <DEDENT> <DEDENT> P = f ( L , S ) <NEWLINE> a = A [ P [ - 1 ] - 1 ] <NEWLINE> j = P . index ( a ) <NEWLINE> r = len ( P ) <NEWLINE> l = r - j <NEWLINE> <NL> if k + 1 <= j : <NEWLINE> <INDENT> print ( P [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( P [ j + ( k - j ) % l ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> if ( a . count ( 0 ) >= 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> p *= a [ i ] <NEWLINE> if ( p > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ a - 1 ] . append ( b - 1 ) <NEWLINE> path [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> nan = deque ( [ 0 ] ) <NEWLINE> check = [ 1 if i == 0 else - 1 for i in range ( n ) ] <NEWLINE> def bfs ( ) : <NEWLINE> <INDENT> global n , m , path , nan <NEWLINE> l = len ( nan ) <NEWLINE> if not l : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for _ in range ( l ) : <NEWLINE> <INDENT> x = nan . popleft ( ) <NEWLINE> for j in path [ x ] : <NEWLINE> <INDENT> if check [ j ] == - 1 : <NEWLINE> <INDENT> check [ j ] = x <NEWLINE> nan . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> bfs ( ) <NEWLINE> <DEDENT> bfs ( ) <NEWLINE> if any ( [ i == - 1 for i in check ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( check [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
def bubbleSort ( A , N ) : <COMMENT> <NEWLINE> <INDENT> A = list ( map ( int , A . split ( ) ) ) <NEWLINE> flag = 1 <COMMENT> <NEWLINE> count = 0 <COMMENT> <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = A [ j ] <NEWLINE> A [ j ] = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = tmp <NEWLINE> flag = 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( count ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = input ( ) <NEWLINE> bubbleSort ( A , N ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> _A = sorted ( enumerate ( map ( int , input ( ) . split ( ) ) , 1 ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> dp = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> k , Ak = _A [ i - 1 ] <NEWLINE> if ( N - i - k ) < 0 : break <NEWLINE> dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + ( N - i + 1 - k ) * Ak <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> k , Ak = _A [ i - 1 ] <NEWLINE> if ( k - i ) < 0 : break <NEWLINE> dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + ( k - i ) * Ak <NEWLINE> <NL> <DEDENT> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , N - x + 1 ) : <NEWLINE> <INDENT> k , val = _A [ x + y - 1 ] <NEWLINE> dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + abs ( k - x ) * val , <NEWLINE> <INDENT> dp [ x ] [ y - 1 ] + abs ( N - y - k + 1 ) * val ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( max ( dp [ i ] [ N - i ] for i in range ( N + 1 ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ i for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> if a . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result *= a [ i ] <NEWLINE> if result > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mat = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> mat . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> vec = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> vec . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> result = [ ] <NEWLINE> for line in mat : <NEWLINE> <INDENT> c = sum ( [ line [ i ] * vec [ i ] for i in range ( m ) ] ) <NEWLINE> result . append ( c ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , result ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> journey = [ 1 ] <NEWLINE> <NL> for i in range ( 2 * n ) : <NEWLINE> <INDENT> next = l [ journey [ - 1 ] ] <NEWLINE> journey . append ( next ) <NEWLINE> <DEDENT> if k <= n + 1 : <NEWLINE> <INDENT> print ( journey [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> end = n <NEWLINE> start = n - 1 <NEWLINE> <NL> while journey [ start ] != journey [ end ] : <NEWLINE> <INDENT> start -= 1 <NEWLINE> <NL> <DEDENT> period = end - start <NEWLINE> k %= period <NEWLINE> <NL> while k < n : <NEWLINE> <INDENT> k += period <NEWLINE> <NL> <DEDENT> print ( journey [ k ] ) <NEWLINE>
import bisect <NEWLINE> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> L = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> a = L [ n - 1 - i ] <NEWLINE> b = L [ n - 1 - j ] <NEWLINE> <NL> if a - b < b : <NEWLINE> <INDENT> ans += ( n - 1 - j ) - bisect . bisect_left ( L , a - b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> n , m , ss = map ( int , input ( ) . split ( ) ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> links = [ set ( ) for _ in range ( n ) ] <NEWLINE> aaa = [ ] <NEWLINE> for line in lines [ : m ] : <NEWLINE> <INDENT> u , v , a , b = map ( int , line . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> links [ u ] . add ( ( v , a , b ) ) <NEWLINE> links [ v ] . add ( ( u , a , b ) ) <NEWLINE> aaa . append ( a ) <NEWLINE> <NL> <DEDENT> exchanges = [ ] <NEWLINE> for line in lines [ m : ] : <NEWLINE> <INDENT> c , d = map ( int , line . split ( ) ) <NEWLINE> exchanges . append ( ( c , d ) ) <NEWLINE> <NL> <DEDENT> req = sum ( sorted ( aaa , reverse = True ) [ : n - 1 ] ) <NEWLINE> INF = 10 ** 18 <NEWLINE> ans = [ INF ] * n <NEWLINE> ans_silver = [ - 1 ] * n <NEWLINE> <NL> q = [ ( 0 , ss , 0 ) ] <COMMENT> <NEWLINE> visited = set ( ) <NEWLINE> fixed = 0 <NEWLINE> while q : <NEWLINE> <INDENT> t , s , v = heappop ( q ) <NEWLINE> if ( s , v ) in visited or ans_silver [ v ] >= s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited . add ( ( s , v ) ) <NEWLINE> if ans [ v ] == INF : <NEWLINE> <INDENT> ans [ v ] = t <NEWLINE> ans_silver [ v ] = s <NEWLINE> fixed += 1 <NEWLINE> if fixed == n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for u , a , b in links [ v ] : <NEWLINE> <INDENT> if s < a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ns = s - a <NEWLINE> nt = t + b <NEWLINE> if ( ns , u ) in visited or ans_silver [ u ] >= ns : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> heappush ( q , ( nt , ns , u ) ) <NEWLINE> <NL> <DEDENT> c , d = exchanges [ v ] <NEWLINE> ns = s + c <NEWLINE> if ns <= req and ( ns , v ) not in visited : <NEWLINE> <INDENT> heappush ( q , ( t + d , ns , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans [ 1 : ] ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> sum += li [ i ] <NEWLINE> sum %= mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> sum -= li [ i ] <NEWLINE> if sum < 0 : <NEWLINE> <INDENT> sum += mod <NEWLINE> <DEDENT> ans += li [ i ] * sum <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list . sort ( ) <NEWLINE> A_max = A_list [ N - 1 ] <NEWLINE> <NL> is_prime = [ False ] * ( A_max + 1 ) <NEWLINE> <NL> <NL> for i in A_list : <NEWLINE> <INDENT> is_prime [ i ] = True <NEWLINE> <NL> <DEDENT> x = - 1 <NEWLINE> for i in A_list : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif x == i : <NEWLINE> <INDENT> is_prime [ i ] = False <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , A_max + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> x = i <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in A_list : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
v , e , r = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ float ( <STRING> ) ] * v <NEWLINE> d [ r ] = 0 <NEWLINE> edges = [ ] <NEWLINE> <NL> for i in range ( e ) : <NEWLINE> <INDENT> s , t , c = map ( int , input ( ) . split ( ) ) <NEWLINE> edges . append ( [ s , t , c ] ) <NEWLINE> <NL> <DEDENT> for i in range ( v ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for s , v , c in edges : <NEWLINE> <INDENT> if d [ v ] > d [ s ] + c : <NEWLINE> <INDENT> count += 1 <NEWLINE> d [ v ] = d [ s ] + c <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in d : <NEWLINE> <INDENT> if i == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dic [ i ] = arr [ i - 1 ] <NEWLINE> <DEDENT> cycle = [ ] <NEWLINE> visited = [ False ] * ( 10 ** 6 ) <NEWLINE> curr = 1 <NEWLINE> while True : <NEWLINE> <INDENT> cycle . append ( curr ) <NEWLINE> visited [ curr ] = True <NEWLINE> curr = dic [ curr ] <NEWLINE> <COMMENT> <NL> if visited [ curr ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> csize = 0 <NEWLINE> ind = 0 <NEWLINE> for i in range ( len ( cycle ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if cycle [ i ] == curr : <NEWLINE> <INDENT> ind = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> csize += 1 <NEWLINE> <DEDENT> offset = len ( cycle ) - csize - 1 <NEWLINE> <COMMENT> <NL> if k - offset < 0 : <NEWLINE> <INDENT> exit ( print ( cycle [ k ] ) ) <NEWLINE> <DEDENT> k -= offset <NEWLINE> k %= csize + 1 <NEWLINE> print ( cycle [ offset + k ] ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * ( n + 1 ) <NEWLINE> ans [ 0 ] = 0 <NEWLINE> ans [ 1 ] = 0 <NEWLINE> <NL> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> <NL> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if ans [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ i ] = v <NEWLINE> d . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans [ 2 : ] <NEWLINE> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1 * ( 10 ** 3 ) , 10 ** 3 ) : <NEWLINE> <INDENT> for j in range ( - 1 * ( 10 ** 3 ) , 10 ** 3 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = ( a - 1 ) // x <NEWLINE> B = b // x <NEWLINE> <NL> print ( B - A ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = ri ( ) <NEWLINE> a = rl ( ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> t = 0 <NEWLINE> for v in c . values ( ) : <NEWLINE> <INDENT> t += v * ( v - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( t - c [ i ] + 1 ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( x , y ) , z ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> ls = len ( S ) <NEWLINE> odd_list = [ ] <NEWLINE> result = <STRING> <NEWLINE> <NL> while ls > 0 : <NEWLINE> <INDENT> ls -= 1 <NEWLINE> if ls % 2 == 0 : <NEWLINE> <INDENT> odd_list . append ( ls ) <NEWLINE> <DEDENT> <DEDENT> odd_list = sorted ( odd_list ) <NEWLINE> <COMMENT> <NL> <NL> for i in odd_list : <NEWLINE> <INDENT> result = result + S [ i ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( l , m ) <NEWLINE> for n in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd = math . gcd ( tmp , n ) <NEWLINE> ans += gcd <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> d = Counter ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> d . setdefault ( c , 0 ) <NEWLINE> <COMMENT> <NL> d [ c ] = d . get ( c ) + d . get ( b , 0 ) <NEWLINE> <COMMENT> <NL> diff = d . get ( b , 0 ) * ( c - b ) <NEWLINE> d [ b ] = 0 <NEWLINE> ans += diff <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> dp1 = [ 0 ] * ( K + 1 ) <NEWLINE> dp2 = [ 0 ] * ( K + 1 ) <NEWLINE> dp1 [ 0 ] = 1 <NEWLINE> <NL> for x in map ( int , str ( N ) ) : <NEWLINE> <INDENT> for j in range ( K , - 1 , - 1 ) : <NEWLINE> <INDENT> if j > 0 : <NEWLINE> <INDENT> dp2 [ j ] += dp2 [ j - 1 ] * 9 <NEWLINE> if x != 0 : <NEWLINE> <INDENT> dp2 [ j ] += dp1 [ j - 1 ] * ( x - 1 ) + dp1 [ j ] <NEWLINE> dp1 [ j ] = dp1 [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp1 [ j ] = 0 <NEWLINE> dp2 [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp1 [ K ] + dp2 [ K ] ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> flag = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if ( flag == - 1 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> flag = 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( b > 10 ** 18 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> if ( flag == 2 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> INF = 10 ** 9 <NEWLINE> eps = 10 ** - 7 <NEWLINE> <NL> N , A , B = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> h = [ int ( readline ( ) ) for i in range ( N ) ] <NEWLINE> <NL> C = A - B <NEWLINE> ng = 0 <COMMENT> <NEWLINE> ok = INF <COMMENT> <NEWLINE> <NL> def judge ( mid ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for hi in h : <NEWLINE> <INDENT> ans += max ( 0 , ( hi - mid * B + C - 1 ) // C ) <NEWLINE> <DEDENT> if ans <= mid : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if judge ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or str ( i ) . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = min ( x ) <NEWLINE> r = max ( x ) <NEWLINE> cost = [ ] <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> curcost = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> curcost += ( x [ j ] - i ) ** 2 <NEWLINE> <DEDENT> cost . append ( curcost ) <NEWLINE> <DEDENT> print ( min ( cost ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> <COMMENT> <NL> from math import sqrt , floor <NEWLINE> def main ( ) : <NEWLINE> <INDENT> def factorization ( n ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> t = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if t % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while t % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t = t // i <NEWLINE> <DEDENT> l . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if t != 1 : <NEWLINE> <INDENT> l . append ( [ t , 1 ] ) <NEWLINE> <DEDENT> if not l : <NEWLINE> <INDENT> l . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return l <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = factorization ( n ) <NEWLINE> r = 0 <NEWLINE> for pe in p : <NEWLINE> <INDENT> pe1 = pe [ 1 ] <NEWLINE> cnt = 1 <NEWLINE> while pe1 >= cnt : <NEWLINE> <INDENT> pe1 -= cnt <NEWLINE> cnt = cnt + 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
lines = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> num = int ( lines [ 0 ] ) <NEWLINE> <NL> out = 1 <NEWLINE> split = lines [ 1 ] . split ( ) <NEWLINE> if <STRING> in split : <NEWLINE> <INDENT> out = 0 <NEWLINE> <DEDENT> for i in range ( num ) : <NEWLINE> <INDENT> out = int ( split [ i ] ) * out <NEWLINE> if out > 1000000000000000000 : <NEWLINE> <INDENT> out = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> b , c = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> sum_num = sum ( A ) <NEWLINE> counter = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> sum_num -= counter [ b [ i ] ] * b [ i ] <COMMENT> <NEWLINE> sum_num += counter [ b [ i ] ] * c [ i ] <COMMENT> <NEWLINE> counter [ c [ i ] ] += counter [ b [ i ] ] <NEWLINE> counter [ b [ i ] ] = 0 <NEWLINE> print ( sum_num ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> colors = [ 0 ] * 9 <NEWLINE> for a in A : <NEWLINE> <INDENT> idx = a // 400 <NEWLINE> if idx >= 8 : <NEWLINE> <INDENT> idx = 8 <NEWLINE> <DEDENT> colors [ idx ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> if colors [ i ] > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> max_ans = ans <NEWLINE> if colors [ 8 ] > 0 : <NEWLINE> <INDENT> max_ans += colors [ 8 ] <NEWLINE> <NL> <DEDENT> if ans == 0 and max_ans > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans , max_ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> done = False <NEWLINE> mul = 1 <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if mul * arr [ i ] <= int ( 1e18 ) : <NEWLINE> <INDENT> mul *= arr [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> done = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not done : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a + b >= 10 ** 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a >= 10 ** 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b >= 10 ** 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , 1000000007 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> S = 0 <NEWLINE> c = sum ( b ) <NEWLINE> for i in range ( 0 , a ) : <NEWLINE> <INDENT> c = c - b [ i ] <NEWLINE> S = S + b [ i ] * c <NEWLINE> <DEDENT> print ( S % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ex = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for x in range ( 1 , int ( math . ceil ( ( n - i ) / 2 ) ) ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + x ] and s [ i ] != s [ i + 2 * x ] and s [ i + x ] != s [ i + 2 * x ] : <NEWLINE> <INDENT> ex += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) - ex ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> G = [ { } for i in range ( N + 1 ) ] <NEWLINE> colors = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a ] [ b ] = [ i , - 1 ] <NEWLINE> G [ b ] [ a ] = [ i , - 1 ] <NEWLINE> <NL> <DEDENT> def bfs ( s ) : <NEWLINE> <INDENT> seen = [ 0 for i in range ( N + 1 ) ] <NEWLINE> prev = [ 0 for i in range ( N + 1 ) ] <NEWLINE> todo = deque ( [ ] ) <NEWLINE> cmax = 0 <NEWLINE> now = s <NEWLINE> seen [ now ] = 1 <NEWLINE> todo . append ( now ) <NEWLINE> while 1 : <NEWLINE> <INDENT> if len ( todo ) == 0 : break <NEWLINE> a = todo . popleft ( ) <NEWLINE> if len ( G [ a ] ) < 50 : <NEWLINE> <INDENT> if prev [ a ] == 0 : <NEWLINE> <INDENT> a_color = set ( [ ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_color = set ( [ G [ a ] [ prev [ a ] ] [ 1 ] ] ) <NEWLINE> <DEDENT> for b in G [ a ] : <NEWLINE> <INDENT> if seen [ b ] == 0 : <NEWLINE> <INDENT> seen [ b ] = 1 <NEWLINE> todo . append ( b ) <NEWLINE> prev [ b ] = a <NEWLINE> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if c not in a_color : <NEWLINE> <INDENT> a_color . add ( c ) <NEWLINE> colors . append ( ( G [ a ] [ b ] [ 0 ] , c ) ) <NEWLINE> G [ a ] [ b ] [ 1 ] = G [ b ] [ a ] [ 1 ] = c <NEWLINE> if c > cmax : cmax = c <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = list ( range ( 1 , N ) ) <NEWLINE> if prev [ a ] != 0 : <NEWLINE> <INDENT> del temp [ G [ a ] [ prev [ a ] ] [ 1 ] - 1 ] <NEWLINE> <DEDENT> temp = deque ( temp ) <NEWLINE> for i , b in enumerate ( G [ a ] ) : <NEWLINE> <INDENT> if seen [ b ] == 0 : <NEWLINE> <INDENT> seen [ b ] = 1 <NEWLINE> todo . append ( b ) <NEWLINE> prev [ b ] = a <NEWLINE> c = temp . popleft ( ) <NEWLINE> colors . append ( ( G [ a ] [ b ] [ 0 ] , c ) ) <NEWLINE> G [ a ] [ b ] [ 1 ] = G [ b ] [ a ] [ 1 ] = c <NEWLINE> if c > cmax : cmax = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return colors , cmax <NEWLINE> <NL> <DEDENT> colors , cmax = bfs ( 1 ) <NEWLINE> colors = sorted ( colors ) <NEWLINE> <NL> print ( cmax ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( colors [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> score = 0 <NEWLINE> i = 0 <NEWLINE> ans_list = [ ] <NEWLINE> <NL> while score <= n : <NEWLINE> <INDENT> i += 1 <NEWLINE> score += i <NEWLINE> ans_list . append ( i ) <NEWLINE> <NL> <DEDENT> ans_list . remove ( score - n ) <NEWLINE> for k in range ( len ( ans_list ) ) : <NEWLINE> <INDENT> print ( ans_list [ k ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> def solve_fixed ( p ) : <NEWLINE> <INDENT> w_cnt = 0 <NEWLINE> r_cnt = 0 <NEWLINE> <NL> for i in range ( p ) : <NEWLINE> <INDENT> if ( c [ i ] == <STRING> ) : <NEWLINE> <INDENT> w_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( p , n ) : <NEWLINE> <INDENT> if ( c [ j ] == <STRING> ) : <NEWLINE> <INDENT> r_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ( w_cnt , r_cnt ) <NEWLINE> <NL> <DEDENT> ans = 10 ** 9 <NEWLINE> w_cnt , r_cnt = solve_fixed ( 0 ) <NEWLINE> <NL> tmp = max ( w_cnt , r_cnt ) <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> if ( c [ i ] == <STRING> ) : <NEWLINE> <INDENT> w_cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r_cnt -= 1 <NEWLINE> <NL> <DEDENT> tmp = max ( w_cnt , r_cnt ) <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> while a < n : <NEWLINE> <INDENT> a += 1 <NEWLINE> if a == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % a == 0 : <NEWLINE> <INDENT> c += n // a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += n // a <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> m = n // i <NEWLINE> <COMMENT> <NL> ans += m * ( 2 * i + i * ( m - 1 ) ) * 0.5 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> num = lcm_list ( A ) % mod <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += ( num * pow ( a , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_ij = 2018 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> min_ij = min ( min_ij , ( ( i % 2019 ) * ( j % 2019 ) ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( min_ij ) <NEWLINE> <DEDENT>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> b = [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> li = [ i ** 5 for i in range ( 0 , 10000 , 1 ) ] <NEWLINE> for A in li : <NEWLINE> <INDENT> if A - X in li : <COMMENT> <NEWLINE> <INDENT> B = li . index ( A - X ) <NEWLINE> break <NEWLINE> <DEDENT> elif A - X < 0 : <COMMENT> <NEWLINE> <INDENT> if abs ( A - X ) in li : <NEWLINE> <INDENT> B = ( li . index ( ( A - X ) * ( - 1 ) ) ) * ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( li . index ( A ) , B ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> reverse = False <NEWLINE> n_q = int ( input ( ) ) <NEWLINE> for i in range ( n_q ) : <NEWLINE> <INDENT> q = input ( ) . split ( <STRING> ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> reverse = not reverse <NEWLINE> <DEDENT> elif q [ 0 ] == <STRING> : <NEWLINE> <INDENT> f = q [ 1 ] <NEWLINE> c = q [ 2 ] <NEWLINE> if ( f == <STRING> and not reverse ) or ( f == <STRING> and reverse ) : <NEWLINE> <INDENT> T . append ( c ) <NEWLINE> <DEDENT> elif ( f == <STRING> and reverse ) or ( f == <STRING> and not reverse ) : <NEWLINE> <INDENT> S . append ( c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if reverse : <NEWLINE> <INDENT> S . reverse ( ) <NEWLINE> ans = S + T <NEWLINE> <DEDENT> elif not reverse : <NEWLINE> <INDENT> T . reverse ( ) <NEWLINE> ans = T + S <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> pi = math . pi <NEWLINE> <NL> print ( <STRING> % ( r * r * pi , 2 * r * pi ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in nums : <NEWLINE> <INDENT> ans *= n <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= 10 ** 18 : print ( ans ) <NEWLINE> <DEDENT>
<NL> from collections import deque <NEWLINE> <NL> icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> elif icase == 1 : <NEWLINE> <INDENT> h , w = 2 , 3 <NEWLINE> a = [ [ 1 , 2 , 3 ] , [ 0 , 1 , 1 ] ] <NEWLINE> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> h , w = 3 , 2 <NEWLINE> a = [ [ 1 , 0 ] , [ 2 , 1 ] , [ 1 , 0 ] ] <NEWLINE> <DEDENT> elif icase == 3 : <NEWLINE> <INDENT> h , w = 1 , 5 <NEWLINE> a = [ [ 9 , 9 , 9 , 9 , 9 ] ] <NEWLINE> <NL> <NL> <DEDENT> astat = 0 <NEWLINE> im = - 1 <NEWLINE> jm = - 1 <NEWLINE> q = deque ( ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> wst = 0 <NEWLINE> wed = w <NEWLINE> wpt = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wst = w - 1 <NEWLINE> wed = - 1 <NEWLINE> wpt = - 1 <NEWLINE> <DEDENT> for j in range ( wst , wed , wpt ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i ] [ j ] % 2 == 1 and astat == 0 : <NEWLINE> <INDENT> astat = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif a [ i ] [ j ] % 2 == 1 and astat == 1 : <NEWLINE> <INDENT> q . append ( ( im , jm , i , j ) ) <NEWLINE> <COMMENT> <NL> astat = 0 <NEWLINE> <DEDENT> elif a [ i ] [ j ] % 2 == 0 and astat == 0 : <NEWLINE> <INDENT> astat = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> elif a [ i ] [ j ] % 2 == 0 and astat == 1 : <NEWLINE> <INDENT> astat = 1 <NEWLINE> q . append ( ( im , jm , i , j ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> im = i <NEWLINE> jm = j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( q ) ) <NEWLINE> for i in range ( len ( q ) ) : <NEWLINE> <INDENT> yf , xf , yt , xt = q . popleft ( ) <NEWLINE> stra = str ( yf + 1 ) + <STRING> + str ( xf + 1 ) + <STRING> + str ( yt + 1 ) + <STRING> + str ( xt + 1 ) <NEWLINE> print ( stra ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> b = b - 1 <NEWLINE> slist = list ( s ) <NEWLINE> if slist [ b ] == <STRING> : <NEWLINE> <INDENT> slist [ b ] = <STRING> <NEWLINE> <DEDENT> if slist [ b ] == <STRING> : <NEWLINE> <INDENT> slist [ b ] = <STRING> <NEWLINE> <DEDENT> if slist [ b ] == <STRING> : <NEWLINE> <INDENT> slist [ b ] = <STRING> <NEWLINE> <DEDENT> s = <STRING> . join ( slist ) <NEWLINE> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> num = int ( N / j ) <NEWLINE> ans += num * ( num + 1 ) / 2 * j <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> c = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] ) <NEWLINE> <NL> <NL> def s6 ( c , s , last_date , di , i ) : <NEWLINE> <INDENT> score = s [ di - 1 ] [ i ] <NEWLINE> score += 500 * c [ i ] * ( di - last_date [ i ] ) <NEWLINE> return score <NEWLINE> <NL> <NL> <DEDENT> def f6 ( D , c , s ) : <NEWLINE> <INDENT> last_date = np . zeros ( 26 ) <NEWLINE> <NL> t = [ ] <NEWLINE> for di in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> score_list = [ ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> score_list . append ( s6 ( c , s , last_date , di , i ) ) <NEWLINE> <NL> <DEDENT> select_index = score_list . index ( max ( score_list ) ) <NEWLINE> t . append ( select_index ) <NEWLINE> last_date [ select_index ] = di <NEWLINE> <NL> <DEDENT> return t <NEWLINE> <NL> <NL> <DEDENT> for ti in f6 ( D , c , s ) : <NEWLINE> <INDENT> print ( ti + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ng = 0 <NEWLINE> ok = 10 ** 9 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def able ( x ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % x : <NEWLINE> <INDENT> count += A [ i ] // x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += A [ i ] // x - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ng + ( ok - ng ) // 2 <NEWLINE> if able ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> L = [ 0 ] * 2019 <NEWLINE> L [ 0 ] = 1 <NEWLINE> digit = 1 <NEWLINE> x = 0 <NEWLINE> <NL> for i in S [ : : - 1 ] : <NEWLINE> <INDENT> x += digit * int ( i ) <NEWLINE> digit *= 10 <NEWLINE> x %= 2019 <NEWLINE> digit %= 2019 <NEWLINE> L [ x ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in L : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , p <NEWLINE> <NL> <DEDENT> def main ( n , p ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> pmin = p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pmin = min ( p [ i ] , pmin ) <NEWLINE> if pmin >= p [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , p = readinput ( ) <NEWLINE> ans = main ( n , p ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
billdings = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <NL> <NL> def printstate ( billdings ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( len ( billdings ) ) : <NEWLINE> <INDENT> for j in range ( len ( billdings [ 0 ] ) ) : <NEWLINE> <INDENT> for k in range ( len ( billdings [ 0 ] [ 0 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> + str ( billdings [ i ] [ j ] [ k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if i != len ( billdings ) - 1 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , f , r = b - 1 , f - 1 , r - 1 <NEWLINE> billdings [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> printstate ( billdings ) <NEWLINE> <NL>
l = [ [ [ 0 ] * 10 for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for x in range ( 4 ) : <NEWLINE> <INDENT> for y in range ( 3 ) : <NEWLINE> <INDENT> print ( end = <STRING> ) <NEWLINE> print ( * l [ x ] [ y ] ) <NEWLINE> <DEDENT> if x != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ls = list ( S ) <NEWLINE> <NL> nr = len ( [ r for r in S if r == <STRING> ] ) <NEWLINE> nb = len ( [ b for b in S if b == <STRING> ] ) <NEWLINE> ng = len ( [ g for g in S if g == <STRING> ] ) <NEWLINE> <NL> ALL = nr * nb * ng <NEWLINE> count = 0 <NEWLINE> <NL> RGBs = list ( itertools . permutations ( [ <STRING> , <STRING> , <STRING> ] , 3 ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N - i * 2 ) : <NEWLINE> <INDENT> if ( S [ j ] , S [ j + i ] , S [ j + i * 2 ] ) in RGBs : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ALL - count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> val = set ( ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i in val : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val . add ( i ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans . count ( ans [ - 1 ] ) >= 4 : <NEWLINE> <INDENT> print ( ans [ - 1 ] ** 2 ) <NEWLINE> <DEDENT> elif ans . count ( ans [ - 1 ] ) == 3 : <NEWLINE> <INDENT> print ( ans [ - 1 ] * ans [ - 4 ] ) <NEWLINE> <DEDENT> elif ans . count ( ans [ - 1 ] ) == 2 : <NEWLINE> <INDENT> print ( ans [ - 1 ] * ans [ - 3 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ - 1 ] * ans [ - 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> t = [ 0 for i in range ( 100002 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> t [ a - 1 ] += 1 <NEWLINE> t [ b ] -= 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , 100002 ) : <NEWLINE> <INDENT> t [ i ] += t [ i - 1 ] <NEWLINE> if ( t [ i ] >= i ) : <NEWLINE> <INDENT> ans = i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> for m , n in enumerate ( sys . stdin ) : <NEWLINE> <INDENT> if int ( n ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( m + 1 , int ( n ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i [ 0 ] == 0 and i [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i [ 0 ] ) : <NEWLINE> <INDENT> for k in range ( i [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from functools import lru_cache <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> inf = 2 * 10 ** 14 + 1 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def recursion ( cur , need ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if cur >= N : <NEWLINE> <INDENT> if need == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - inf <NEWLINE> <NL> <DEDENT> <DEDENT> rest = N - cur <NEWLINE> if ( rest + 1 ) // 2 < need : <NEWLINE> <INDENT> return - inf <NEWLINE> <NL> <DEDENT> return max ( <NEWLINE> <INDENT> a [ cur ] + recursion ( cur + 2 , need - 1 ) , <NEWLINE> recursion ( cur + 1 , need ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> ans = recursion ( 0 , N // 2 ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = [ i for i in range ( n ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if x == par [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> par [ x ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> f = lambda x : int ( x ) - 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( f , input ( ) . split ( ) ) <NEWLINE> union ( x , y ) <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> find ( j ) <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> c = Counter ( par ) <NEWLINE> cv = c . values ( ) <NEWLINE> print ( max ( cv ) ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> list_gcd = [ [ 0 ] * 202 for _ in range ( 202 ) ] <NEWLINE> <NL> for i in range ( 1 , 201 ) : <NEWLINE> <INDENT> for j in range ( i , 201 ) : <NEWLINE> <INDENT> num = math . gcd ( i , j ) <NEWLINE> list_gcd [ i ] [ j ] = num <NEWLINE> list_gcd [ j ] [ i ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> num = list_gcd [ i ] [ j ] <NEWLINE> ans += list_gcd [ num ] [ l ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
nli = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sum ( nli ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> MaxN = 10 ** 9 <NEWLINE> if S == MaxN : <NEWLINE> <INDENT> A = [ S ] * K + [ 1 ] * ( N - K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = [ S ] * K + [ S + 1 ] * ( N - K ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s , e = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> if s <= 5 : <NEWLINE> <INDENT> if s > e : [ a . append ( i ) for i in range ( s , e - 1 , - 1 ) ] <NEWLINE> else : [ a . append ( i ) for i in range ( s , e + 1 ) ] <NEWLINE> <DEDENT> elif s < e : [ a . append ( i ) for i in range ( s , e + 1 ) ] <NEWLINE> else : <NEWLINE> <INDENT> [ a . append ( i ) for i in range ( s , 10 ) ] <NEWLINE> if e <= 5 : [ a . append ( i ) for i in range ( 5 , e - 1 , - 1 ) ] <NEWLINE> else : <NEWLINE> <INDENT> [ a . append ( i ) for i in range ( 5 , 0 , - 1 ) ] <NEWLINE> [ a . append ( i ) for i in range ( 0 , e + 1 ) ] <NEWLINE> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - ( i + j ) <= K : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> root = list ( range ( n + 1 ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> cnt = [ 1 ] * ( n + 1 ) <NEWLINE> <NL> <NL> def find ( i ) : <NEWLINE> <INDENT> if i == root [ i ] : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> root [ i ] = find ( root [ i ] ) <NEWLINE> return root [ i ] <NEWLINE> <NL> <DEDENT> def union ( u , v ) : <NEWLINE> <INDENT> fu , fv = find ( u ) , find ( v ) <NEWLINE> if fu == fv : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> cnt [ min ( fu , fv ) ] += cnt [ max ( fu , fv ) ] <NEWLINE> root [ max ( fu , fv ) ] = min ( fu , fv ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( u , v ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
import math <NEWLINE> <NL> w = input ( ) <NEWLINE> total = 0 <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> <NL> <NL> i = w . index ( <STRING> ) <NEWLINE> n = w [ 0 : i ] <NEWLINE> d = w [ ( i + 1 ) : ] <NEWLINE> n = int ( n ) <NEWLINE> d = float ( d ) <NEWLINE> <NL> <NL> for x in range ( n ) : <NEWLINE> <INDENT> w = input ( ) <NEWLINE> <NL> i = w . index ( <STRING> ) <NEWLINE> y = w [ 0 : i ] <NEWLINE> x = w [ ( i + 1 ) : ] <NEWLINE> <NL> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> if math . sqrt ( ( x * x ) + ( y * y ) ) <= d : <NEWLINE> <INDENT> total = total + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 <NEWLINE> <NL> if ( N % 2 == 0 ) : <NEWLINE> <INDENT> c = N // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = N // 2 + 1 <NEWLINE> <NL> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> if ( a [ 2 * i ] % 2 != 0 ) : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> rlist = [ ] <NEWLINE> wlist = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> rlist . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wlist . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> if len ( rlist ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( wlist ) ) : <NEWLINE> <INDENT> if wlist [ i ] < rlist [ - cnt - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = 1000000007 <NEWLINE> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> a . append ( N + 1 ) <NEWLINE> <NL> def fibonacci ( x ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> b = 1 <NEWLINE> if x <= 2 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( x - 2 ) : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp + b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> <DEDENT> res = 1 <NEWLINE> prev_a = - 1 <NEWLINE> for cur_a in a : <NEWLINE> <INDENT> if cur_a - prev_a == 1 : <NEWLINE> <INDENT> res = 0 <NEWLINE> break <NEWLINE> <DEDENT> res *= fibonacci ( cur_a - prev_a - 1 ) % mod <NEWLINE> res %= mod <NEWLINE> prev_a = cur_a <NEWLINE> continue <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
root = [ ] <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> root . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> toori = [ 0 ] * ( 2 * 10 ** 5 ) + [ 0 ] * n + [ 0 ] * ( 2 * 10 ** 5 ) <NEWLINE> toori [ 2 * 10 ** 5 ] = 1 <NEWLINE> cum = [ 0 ] * k <NEWLINE> for a , i in enumerate ( root ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( i [ 0 ] , i [ 1 ] + 1 ) : <NEWLINE> <INDENT> s += toori [ 2 * 10 ** 5 + 1 - j ] <NEWLINE> <DEDENT> cum [ a ] = s <NEWLINE> <DEDENT> aaa = sum ( cum ) % 998244353 <NEWLINE> toori [ 2 * 10 ** 5 + 1 ] += aaa <NEWLINE> <NL> <NL> for now in range ( 2 , n ) : <COMMENT> <NEWLINE> <INDENT> hueru = 0 <NEWLINE> for a , i in enumerate ( root ) : <NEWLINE> <INDENT> hueru += ( toori [ 2 * 10 ** 5 + now - i [ 0 ] ] - toori [ 2 * 10 ** 5 + now - 1 - i [ 1 ] ] ) <NEWLINE> <DEDENT> aaa += hueru <NEWLINE> aaa %= 998244353 <NEWLINE> toori [ 2 * 10 ** 5 + now ] += aaa <NEWLINE> toori [ 2 * 10 ** 5 + now ] %= 998244353 <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( toori [ 2 * 10 ** 5 + n - 1 ] % 998244353 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> XYList = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> XY = [ ] <NEWLINE> for j in range ( A ) : <NEWLINE> <INDENT> XY . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> XYList . append ( XY ) <NEWLINE> <DEDENT> maxSum = 0 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> honest = True <NEWLINE> for XY in XYList [ j ] : <NEWLINE> <INDENT> if ( ( i >> ( XY [ 0 ] - 1 ) ) & 1 ) != XY [ 1 ] : <NEWLINE> <INDENT> honest = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if honest : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if maxSum < sum : <NEWLINE> <INDENT> maxSum = sum <NEWLINE> <DEDENT> <DEDENT> print ( maxSum ) <NEWLINE>
from math import * <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> while y != 0 : <NEWLINE> <INDENT> ( x , y ) = ( y , x % y ) <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // gcd ( x , y ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> mod = 1000000000 + 7 <NEWLINE> <NL> k = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> k = lcm ( k , x ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> ans += k // x <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> ans = sum ( A ) <NEWLINE> <NL> <COMMENT> <NL> a_num = [ 0 ] * 10 ** 5 <NEWLINE> for a in A : <NEWLINE> <INDENT> a_num [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for bc in BC : <NEWLINE> <INDENT> change = bc [ 1 ] - bc [ 0 ] <NEWLINE> ans += change * a_num [ bc [ 0 ] - 1 ] <NEWLINE> a_num [ bc [ 1 ] - 1 ] += a_num [ bc [ 0 ] - 1 ] <NEWLINE> a_num [ bc [ 0 ] - 1 ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ha = h [ a - 1 ] <NEWLINE> hb = h [ b - 1 ] <NEWLINE> if ha == hb : <NEWLINE> <INDENT> lis . append ( a ) <NEWLINE> lis . append ( b ) <NEWLINE> <DEDENT> if ha > hb : <NEWLINE> <INDENT> lis . append ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - len ( list ( set ( lis ) ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> le = [ ( x + 1 ) / 2 for x in p ] <NEWLINE> e = sum ( le [ : K ] ) <NEWLINE> ans = e <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> e -= le [ i ] <NEWLINE> e += le [ i + K ] <NEWLINE> ans = max ( ans , e ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) ; <NEWLINE> <NL> <DEDENT> x = A [ 0 ] <NEWLINE> for i in A [ 1 : ] : <NEWLINE> <INDENT> x *= i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) ; <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
xn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( 110 ) : <NEWLINE> <INDENT> d [ str ( i ) ] = 0 <NEWLINE> <DEDENT> for i in range ( 110 ) : <NEWLINE> <INDENT> d [ str ( - i ) ] = 0 <NEWLINE> <NL> <NL> <DEDENT> if xn [ 1 ] != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( xn [ 1 ] ) : <NEWLINE> <INDENT> d [ str ( p [ i ] ) ] = 1 <NEWLINE> <DEDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> if d [ str ( xn [ 0 ] - i ) ] == 0 : <NEWLINE> <INDENT> miflag = 1 <NEWLINE> mi = i <NEWLINE> print ( xn [ 0 ] - mi ) <NEWLINE> break <NEWLINE> <DEDENT> if d [ str ( xn [ 0 ] + i ) ] == 0 : <NEWLINE> <INDENT> maflag = 1 <NEWLINE> ma = i <NEWLINE> print ( xn [ 0 ] + ma ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( xn [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( e ) for e in sys . stdin ] <NEWLINE> cnt = 0 <NEWLINE> G = [ int ( ( 3 ** i - 1 ) / 2 ) for i in range ( 14 , 0 , - 1 ) ] <NEWLINE> G = [ v for v in G if v <= n ] <NEWLINE> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> <DEDENT> for g in G : <NEWLINE> <INDENT> insertionSort ( A , n , g ) <NEWLINE> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ABS = 10 ** 9 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> if i in p : continue <NEWLINE> <NL> temp = abs ( i - x ) <NEWLINE> if ABS > temp : <NEWLINE> <INDENT> ABS = temp <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1000 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> stocks = 0 <NEWLINE> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> stocks = ans // A [ i ] <NEWLINE> ans += ( A [ i + 1 ] - A [ i ] ) * stocks <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> idxs = np . arange ( n ) <NEWLINE> L , R = idxs + a , idxs - a <NEWLINE> <NL> count = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d [ L [ i ] ] += 1 <NEWLINE> count += d [ R [ i + 1 ] ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> S = <STRING> <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> data = line . rstrip ( <STRING> ) . split ( ) <NEWLINE> height = data [ 0 ] <NEWLINE> width = data [ 1 ] <NEWLINE> <COMMENT> <NL> if height == <STRING> and width == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( int ( height ) ) : <NEWLINE> <INDENT> for w in range ( int ( width ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
X = int ( input ( ) ) <NEWLINE> tab = set ( [ 1 ] ) <NEWLINE> for i in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , X + 1 ) : <NEWLINE> <INDENT> if i ** j <= X : <NEWLINE> <INDENT> tab . add ( i ** j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( [ i for i in tab ] ) ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_B_list = [ [ 0 ] * 2 for i in range ( M ) ] <NEWLINE> bad_list = [ ] <NEWLINE> J_list = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A_B_list [ i ] [ 0 ] = A <NEWLINE> A_B_list [ i ] [ 1 ] = B <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> if H_list [ A_B_list [ j ] [ 0 ] - 1 ] > H_list [ A_B_list [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> bad_list . append ( A_B_list [ j ] [ 1 ] ) <NEWLINE> <DEDENT> elif H_list [ A_B_list [ j ] [ 0 ] - 1 ] < H_list [ A_B_list [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> bad_list . append ( A_B_list [ j ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad_list . append ( A_B_list [ j ] [ 0 ] ) <NEWLINE> bad_list . append ( A_B_list [ j ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> J_list = list ( set ( bad_list ) ) <NEWLINE> print ( N - len ( J_list ) ) <NEWLINE>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( map ( lambda x : int ( x ) if x != <STRING> else - 1 , input ( ) ) ) for i in range ( H ) ] <NEWLINE> dd = ( ( - 1 , 0 ) , ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 1 ) ) <NEWLINE> que = [ ] <NEWLINE> D = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> v = S [ i ] [ j ] <NEWLINE> if v == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = sum ( S [ i + dy ] [ j + dx ] == - 1 for dx , dy in dd ) <NEWLINE> if v <= x : <NEWLINE> <INDENT> S [ i ] [ j ] = 0 <NEWLINE> que . append ( ( i , j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ i ] [ j ] -= x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> while que : <NEWLINE> <INDENT> que2 = [ ] <NEWLINE> for y , x in que : <NEWLINE> <INDENT> if S [ y ] [ x ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S [ y ] [ x ] = - 1 <NEWLINE> for dx , dy in dd : <NEWLINE> <INDENT> nx = x + dx ; ny = y + dy <NEWLINE> if S [ ny ] [ nx ] > 0 : <NEWLINE> <INDENT> S [ ny ] [ nx ] -= 1 <NEWLINE> if not S [ ny ] [ nx ] : <NEWLINE> <INDENT> que2 . append ( ( ny , nx ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> que = que2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> MODE = 1 <NEWLINE> <NL> <COMMENT> <NL> DIMENSION = 2 <NEWLINE> <NL> <COMMENT> <NL> INT_TYPE = 1 <NEWLINE> <NL> if not ( MODE ) : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> s = f . read ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = sys . stdin . read ( ) <NEWLINE> <NL> <DEDENT> if DIMENSION == 0 : <NEWLINE> <INDENT> if INT_TYPE == 1 : <NEWLINE> <INDENT> s = int ( s ) <NEWLINE> <DEDENT> <DEDENT> elif DIMENSION == 1 : <NEWLINE> <INDENT> if INT_TYPE == 0 : <NEWLINE> <INDENT> s = s . split ( ) <NEWLINE> <DEDENT> elif INT_TYPE == 1 : <NEWLINE> <INDENT> s = [ int ( x ) for x in s . split ( ) ] <NEWLINE> <DEDENT> <DEDENT> elif DIMENSION == 2 : <NEWLINE> <INDENT> if INT_TYPE == 0 : <NEWLINE> <INDENT> s = [ x . split ( ) for x in s . splitlines ( ) ] <NEWLINE> <DEDENT> elif INT_TYPE == 1 : <NEWLINE> <INDENT> s = [ [ int ( y ) for y in x . split ( ) ] for x in s . splitlines ( ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N = s [ 0 ] [ 0 ] <NEWLINE> A = np . array ( s [ 1 ] ) <NEWLINE> Q = s [ 2 ] [ 0 ] <NEWLINE> BC = np . array ( s [ 3 : ] ) <NEWLINE> B = BC [ : , 0 ] <NEWLINE> C = BC [ : , 1 ] <NEWLINE> <NL> A_sum = np . sum ( A ) <NEWLINE> <NL> D = Counter ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b = B [ i ] <NEWLINE> c = C [ i ] <NEWLINE> A_sum += D [ b ] * ( c - b ) <NEWLINE> print ( A_sum ) <NEWLINE> D [ c ] += D [ b ] <NEWLINE> D [ b ] = 0 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( set ( a ) ) == 1 and a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> import collections <NEWLINE> sa = list ( set ( a ) ) <NEWLINE> sa . sort ( ) <NEWLINE> B = collections . Counter ( a ) <NEWLINE> <NL> if len ( sa ) == 2 and 0 in sa : <NEWLINE> <INDENT> if B [ 0 ] == N // 3 and B [ sa [ 1 ] ] == N * 2 // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( sa ) != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if B [ sa [ 0 ] ] == B [ sa [ 1 ] ] == B [ sa [ 2 ] ] : <NEWLINE> <INDENT> print ( <STRING> if sa [ 0 ] ^ sa [ 1 ] == sa [ 2 ] else <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = 7 <NEWLINE> x = 10000000 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if ( s % k == 0 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> s = ( s % k ) * 10 + 7 <NEWLINE> <DEDENT> if ( s % k != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ m ] > k - A [ i ] : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + m ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
X , K , D = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> count = X // D <NEWLINE> if K < count : <NEWLINE> <INDENT> count = K <NEWLINE> <DEDENT> X = abs ( X ) - D * count <NEWLINE> rest = K - count <NEWLINE> if rest % 2 == 1 : <NEWLINE> <INDENT> X -= D <NEWLINE> <DEDENT> print ( abs ( X ) ) <NEWLINE>
from functools import lru_cache <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 2000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def dp ( i ) : <NEWLINE> <INDENT> if i == 1 or i == 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif i == 3 or i == 4 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( dp ( i - 3 ) + dp ( i - 1 ) ) % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> S = int ( input ( ) ) <NEWLINE> print ( dp ( S ) ) <NEWLINE>
from string import ascii_lowercase <NEWLINE> from bisect import bisect_right , bisect_left <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> len_s = len ( s ) <NEWLINE> s_all = { s : [ ] for s in ascii_lowercase } <NEWLINE> for i in range ( len_s ) : <NEWLINE> <INDENT> s_all [ s [ i ] ] . append ( i + 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if any ( s_all [ tt ] == [ ] for tt in t ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_ind = 1 <NEWLINE> for ss in ascii_lowercase : <NEWLINE> <INDENT> s_all [ ss ] . sort ( ) <NEWLINE> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> next_ind = bisect_left ( s_all [ t [ i ] ] , s_ind ) <NEWLINE> if next_ind == len ( s_all [ t [ i ] ] ) : <NEWLINE> <INDENT> ans += len_s - s_ind + 1 <NEWLINE> ans += s_all [ t [ i ] ] [ 0 ] <NEWLINE> s_ind = s_all [ t [ i ] ] [ 0 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s_all [ t [ i ] ] [ next_ind ] - s_ind + 1 <NEWLINE> s_ind = s_all [ t [ i ] ] [ next_ind ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> way = [ ] <NEWLINE> seen = [ False for _ in [ 0 ] * ( 2 * 10 ** 5 + 1 ) ] <NEWLINE> now = 0 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> if seen [ now ] : <NEWLINE> <INDENT> loop_start = way . index ( now ) <NEWLINE> loop = way [ loop_start : ] <NEWLINE> K -= len ( way [ : loop_start ] ) <NEWLINE> now = loop [ K % len ( loop ) ] <NEWLINE> break <NEWLINE> <DEDENT> way . append ( now ) <NEWLINE> seen [ now ] = True <NEWLINE> now = A [ now ] <NEWLINE> <DEDENT> print ( now + 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> from collections import Counter <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> CNT = Counter ( A + B ) <NEWLINE> num = CNT . most_common ( ) [ 0 ] [ 1 ] <NEWLINE> if num > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> j , pre = 0 , - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] != pre : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> if A [ i ] == B [ i ] : <NEWLINE> <INDENT> while j < N : <NEWLINE> <INDENT> if A [ i ] != B [ j ] and A [ j ] != B [ i ] : <NEWLINE> <INDENT> B [ i ] , B [ j ] = B [ j ] , B [ i ] <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> pre = A [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * B ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> case = 0 <NEWLINE> while True : <NEWLINE> <INDENT> case += 1 <NEWLINE> w_max = int ( input ( ) ) <NEWLINE> if w_max == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> w = [ 0 for i in range ( n ) ] <NEWLINE> v = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> v [ i ] = a <NEWLINE> w [ i ] = b <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for j in range ( w_max + 1 ) ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) [ : : - 1 ] : <NEWLINE> <INDENT> for j in range ( w_max + 1 ) : <NEWLINE> <INDENT> if j < w [ i ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i + 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - w [ i ] ] + v [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> , case , <STRING> , sep = <STRING> ) <NEWLINE> print ( max ( dp [ 0 ] ) ) <NEWLINE> print ( dp [ 0 ] . index ( max ( dp [ 0 ] ) ) ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = 10 ** 10 <NEWLINE> DP = [ INF ] * N <NEWLINE> DP [ 0 ] = 0 <NEWLINE> DP [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> DP [ i ] = min ( DP [ i - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( K , i ) + 1 ) ) <NEWLINE> <DEDENT> print ( DP [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= s [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> x_dis = abs ( x1 - x2 ) <NEWLINE> y_dis = abs ( y1 - y2 ) <NEWLINE> <NL> hypo = math . sqrt ( x_dis ** 2 + y_dis ** 2 ) <NEWLINE> dis = round ( hypo , 8 ) <NEWLINE> <NL> print ( dis ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ 0 for i in range ( 1 , n + 1 ) ] <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if lis [ p - 1 ] != - 1 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> wa += lis [ p - 1 ] <NEWLINE> ac += 1 <NEWLINE> lis [ p - 1 ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ p - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sy , sx , gy , gx = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> maze = [ tuple ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> sy -= 1 <NEWLINE> sx -= 1 <NEWLINE> gy -= 1 <NEWLINE> gx -= 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> dis = [ [ - 1 ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> <NL> dis [ sy ] [ sx ] = 0 <NEWLINE> <NL> <NL> <NL> d = deque ( [ ( sx , sy ) ] ) <NEWLINE> while len ( d ) > 0 : <NEWLINE> <INDENT> ( x , y ) = d . popleft ( ) <NEWLINE> if x == gx and y == gy : <NEWLINE> <INDENT> print ( dis [ gy ] [ gx ] ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> exit ( ) <NEWLINE> <NL> <DEDENT> for ( mx , my ) in ( ( 0 , 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> nx = x + mx * j <NEWLINE> ny = y + my * j <NEWLINE> <COMMENT> <NL> if 0 <= nx < w and 0 <= ny < h : <NEWLINE> <INDENT> if maze [ ny ] [ nx ] == <STRING> and ( dis [ ny ] [ nx ] == - 1 or dis [ ny ] [ nx ] == dis [ y ] [ x ] + 1 ) : <NEWLINE> <INDENT> if dis [ ny ] [ nx ] == - 1 : <NEWLINE> <INDENT> d . append ( ( nx , ny ) ) <NEWLINE> <DEDENT> dis [ ny ] [ nx ] = dis [ y ] [ x ] + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> while i + 2 * t < N : <NEWLINE> <INDENT> if ( S [ i ] != S [ i + t ] and S [ i ] != S [ i + 2 * t ] and S [ i + t ] != S [ i + 2 * t ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> num_of_numbers = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num_of_operation = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> cnt = collections . defaultdict ( int ) <NEWLINE> <COMMENT> <NL> for i in numbers : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = sum ( numbers ) <NEWLINE> <NL> for i in range ( num_of_operation ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if B in cnt : <NEWLINE> <INDENT> tmpB = cnt [ B ] <NEWLINE> tmpC = cnt [ C ] <NEWLINE> ans = ans - ( B * tmpB ) + ( C * tmpB ) <NEWLINE> <NL> cnt [ C ] = tmpC + tmpB <NEWLINE> cnt . pop ( B ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
def abc ( d , down_text , up_text ) : <NEWLINE> <INDENT> d [ down_text ] -= 1 <NEWLINE> d [ up_text ] += 1 <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans_list = [ ] <NEWLINE> dct = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> <NL> abc_list = [ input ( ) for _ in range ( n ) ] <NEWLINE> abc_list . append ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> l_txt = abc_list [ i ] [ 0 ] <NEWLINE> r_txt = abc_list [ i ] [ 1 ] <NEWLINE> <NL> if dct [ l_txt ] < dct [ r_txt ] : <NEWLINE> <INDENT> abc ( dct , r_txt , l_txt ) <NEWLINE> ans_list . append ( l_txt ) <NEWLINE> <NL> <DEDENT> elif dct [ l_txt ] > dct [ r_txt ] : <NEWLINE> <INDENT> abc ( dct , l_txt , r_txt ) <NEWLINE> ans_list . append ( r_txt ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if dct [ l_txt ] == dct [ r_txt ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if l_txt in abc_list [ i + 1 ] : <NEWLINE> <INDENT> abc ( dct , r_txt , l_txt ) <NEWLINE> ans_list . append ( l_txt ) <NEWLINE> <DEDENT> elif r_txt in abc_list [ i + 1 ] : <NEWLINE> <INDENT> abc ( dct , l_txt , r_txt ) <NEWLINE> ans_list . append ( r_txt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans_list , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> f = lambda : [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> n , k = f ( ) <NEWLINE> a = f ( ) <NEWLINE> def ok ( x ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> c += ceil ( i / x ) <NEWLINE> <DEDENT> return c <= n + k <NEWLINE> <DEDENT> l , r = 0 , 10 ** 9 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( l + r ) / 2 <NEWLINE> if ok ( m ) : r = m <NEWLINE> else : l = m <NEWLINE> <DEDENT> t = ceil ( r ) <NEWLINE> print ( t - ok ( t - 1 ) if t > 1 else t ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X_a = abs ( X ) <NEWLINE> if X_a - K * D > D : <NEWLINE> <INDENT> print ( X_a - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= X_a // D <NEWLINE> X_a = X_a % D <NEWLINE> while X_a >= D : <NEWLINE> <INDENT> X_a -= D <NEWLINE> K -= 1 <NEWLINE> <DEDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X_a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X_a - D ) ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( accumulate ( a ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> sum += a [ i ] * ( b [ - 1 ] - b [ i ] ) <NEWLINE> sum %= 10 ** 9 + 7 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
N , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v_list = list ( ) <NEWLINE> w_list = list ( ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> v , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v_list . append ( v ) <NEWLINE> w_list . append ( w ) <NEWLINE> <NL> <DEDENT> sum_v_table = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> item = v_list [ i - 1 ] , w_list [ i - 1 ] <NEWLINE> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if item [ 1 ] > w : <NEWLINE> <INDENT> sum_v_table [ i ] [ w ] = sum_v_table [ i - 1 ] [ w ] <NEWLINE> continue <NEWLINE> <DEDENT> sum_v_table [ i ] [ w ] = max ( sum_v_table [ i - 1 ] [ w ] , sum_v_table [ i - 1 ] [ w - item [ 1 ] ] + item [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_sum_v = sum_v_table [ N ] [ W ] <NEWLINE> <NL> print ( max_sum_v ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> <NL> l = 0 <NEWLINE> r = 2 * 10 ** 9 + 10 ** 6 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> cnt = ( ( A + m - 1 ) // m ) . sum ( ) <NEWLINE> if cnt <= N + K : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def solve ( writer ) : <NEWLINE> <INDENT> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> variables = { <NEWLINE> <INDENT> <STRING> : A , <NEWLINE> <STRING> : B , <NEWLINE> <STRING> : C <NEWLINE> <DEDENT> } <NEWLINE> <NL> queries = ( list ( input ( ) ) for _ in range ( N ) ) <NEWLINE> <NL> buffer = list ( ) <NEWLINE> b = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if not buffer : <NEWLINE> <INDENT> t1 , t2 = next ( queries ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = buffer . pop ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t1 , t2 = list ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> v1 = variables [ t1 ] <NEWLINE> v2 = variables [ t2 ] <NEWLINE> <NL> if v1 == v2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif v1 == v2 == 1 : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> writer . append ( t1 ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> nt1 , nt2 = next ( queries ) <NEWLINE> if len ( { t1 , t2 , nt1 , nt2 } ) == 2 : <NEWLINE> <INDENT> buffer . append ( <STRING> ) <NEWLINE> writer . append ( t1 ) <NEWLINE> writer . append ( t2 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if t1 in { nt1 , nt2 } : <NEWLINE> <INDENT> variables [ t1 ] += 1 <NEWLINE> variables [ t2 ] -= 1 <NEWLINE> writer . append ( t1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> variables [ t1 ] -= 1 <NEWLINE> variables [ t2 ] += 1 <NEWLINE> writer . append ( t2 ) <NEWLINE> <NL> <DEDENT> buffer . append ( <STRING> . join ( [ nt1 , nt2 ] ) ) <NEWLINE> <NL> <DEDENT> elif v1 > v2 : <NEWLINE> <INDENT> variables [ t1 ] -= 1 <NEWLINE> variables [ t2 ] += 1 <NEWLINE> writer . append ( t2 ) <NEWLINE> <DEDENT> elif v2 > v1 : <NEWLINE> <INDENT> variables [ t1 ] += 1 <NEWLINE> variables [ t2 ] -= 1 <NEWLINE> writer . append ( t1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> variables [ t1 ] += 1 <NEWLINE> variables [ t2 ] -= 1 <NEWLINE> writer . append ( t1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> writer = list ( ) <NEWLINE> ok = solve ( writer ) <NEWLINE> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for w in writer : <NEWLINE> <INDENT> print ( w ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nt = [ ] <NEWLINE> <NL> board = [ [ <STRING> for _ in range ( 8 ) ] for _ in range ( 8 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> y , x = map ( int , input ( ) . split ( ) ) <NEWLINE> board [ y ] [ x ] = <STRING> <NEWLINE> nt . append ( y ) <NEWLINE> <NL> <DEDENT> def output ( ) : <NEWLINE> <INDENT> for row in board : <NEWLINE> <INDENT> print ( <STRING> . join ( row ) , sep = None ) <NEWLINE> <NL> <DEDENT> <DEDENT> def check ( x , y ) : <NEWLINE> <INDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> if i == y and j == x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif i == y and board [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif j == x and board [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif abs ( i - y ) == abs ( j - x ) and board [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def dfs ( row ) : <NEWLINE> <INDENT> if row == 8 : <NEWLINE> <INDENT> output ( ) <NEWLINE> return <NEWLINE> <DEDENT> if row in nt : <NEWLINE> <INDENT> dfs ( row + 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> board [ row ] [ i ] = <STRING> <NEWLINE> if not check ( i , row ) : <NEWLINE> <INDENT> board [ row ] [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( row + 1 ) <NEWLINE> board [ row ] [ i ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i_l , j_l = [ 0 ] , [ 0 ] <NEWLINE> <NL> best0 = M <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> i_l . append ( i_l [ i ] + a_l [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> j_l . append ( j_l [ i ] + b_l [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for k in range ( N + 1 ) : <NEWLINE> <INDENT> if i_l [ k ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while i_l [ k ] + j_l [ best0 ] > K : <NEWLINE> <INDENT> best0 -= 1 <NEWLINE> <DEDENT> ans = max ( ans , k + best0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> printout = sys . stdout . write <NEWLINE> sprint = sys . stdout . flush <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def intread ( ) : <NEWLINE> <INDENT> return int ( sysread ( ) ) <NEWLINE> <DEDENT> def mapline ( t = int ) : <NEWLINE> <INDENT> return map ( t , sysread ( ) . split ( ) ) <NEWLINE> <DEDENT> def mapread ( t = int ) : <NEWLINE> <INDENT> return map ( t , read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> H , W = mapline ( ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> A . append ( list ( mapline ( ) ) ) <NEWLINE> <NL> <DEDENT> output = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ j ] % 2 : <NEWLINE> <INDENT> A [ i ] [ j ] -= 1 <NEWLINE> A [ i ] [ j + 1 ] += 1 <NEWLINE> output . append ( ( i , j , i , j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ W - 1 ] % 2 : <NEWLINE> <INDENT> A [ i ] [ W - 1 ] -= 1 <NEWLINE> A [ i + 1 ] [ W - 1 ] += 1 <NEWLINE> output . append ( ( i , W - 1 , i + 1 , W - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( output ) ) <NEWLINE> for i1 , j1 , i2 , j2 in output : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> east = S . count ( <STRING> ) <NEWLINE> west = 0 <NEWLINE> <NL> <NL> res = 1000000 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> east -= 1 <NEWLINE> <DEDENT> res = min ( res , east + west ) <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> west += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> b = ( Y - 2 * X ) / 2 <NEWLINE> a = X - b <NEWLINE> <NL> is_int = ( a . is_integer ( ) and b . is_integer ( ) ) <NEWLINE> is_positive = ( a >= 0 and b >= 0 ) <NEWLINE> if is_int and is_positive and ( a + b ) == X and ( 2 * a + 4 * b ) == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> from heapq import heapify , heappop , heappush , heappushpop <NEWLINE> import math <NEWLINE> import collections <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <NL> <DEDENT> roop = [ 0 ] <NEWLINE> for i in range ( 3 * n ) : <NEWLINE> <INDENT> roop . append ( a [ roop [ i ] ] ) <NEWLINE> <DEDENT> cnt = [ 0 ] * n <NEWLINE> d = [ ] <NEWLINE> for i in range ( len ( roop ) ) : <NEWLINE> <INDENT> cnt [ roop [ i ] ] += 1 <NEWLINE> if cnt [ roop [ i ] ] >= 3 and cnt [ roop [ i ] ] < 4 : <NEWLINE> <INDENT> d . append ( roop [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( roop ) ) : <NEWLINE> <INDENT> if roop [ i ] == d [ 0 ] : <NEWLINE> <INDENT> check = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check == 0 : <NEWLINE> <INDENT> k %= len ( d ) <NEWLINE> print ( d [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k < check + len ( d ) : <NEWLINE> <INDENT> print ( roop [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= check <NEWLINE> k %= len ( d ) <NEWLINE> print ( d [ k ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> num = N // i <NEWLINE> if num == 1 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += num * ( i + num * i ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
class Sort ( ) : <NEWLINE> <INDENT> def __init__ ( self , n , cards ) : <NEWLINE> <INDENT> self . cards = cards <NEWLINE> self . n = n <NEWLINE> <NL> <DEDENT> def bubble_sort ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> flag = 1 <NEWLINE> while flag != 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> rev = list ( range ( 1 , self . n ) ) <NEWLINE> rev . reverse ( ) <NEWLINE> for j in rev : <NEWLINE> <INDENT> if int ( self . cards [ j ] [ 1 ] ) < int ( self . cards [ j - 1 ] [ 1 ] ) : <NEWLINE> <INDENT> self . cards [ j ] , self . cards [ j - 1 ] = self . cards [ j - 1 ] , self . cards [ j ] <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def select_sort ( self ) : <NEWLINE> <INDENT> for i in range ( self . n ) : <NEWLINE> <INDENT> mini = i <NEWLINE> for j in range ( i , self . n ) : <NEWLINE> <INDENT> if int ( self . cards [ j ] [ 1 ] ) < int ( self . cards [ mini ] [ 1 ] ) : <NEWLINE> <INDENT> mini = j <NEWLINE> <DEDENT> <DEDENT> if i != mini : <NEWLINE> <INDENT> self . cards [ i ] , self . cards [ mini ] = self . cards [ mini ] , self . cards [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def check_stable ( self , origin ) : <NEWLINE> <INDENT> check_org = [ [ <STRING> for i in range ( self . n ) ] for k in range ( 9 ) ] <NEWLINE> check_sort = [ [ <STRING> for i in range ( self . n ) ] for k in range ( 9 ) ] <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> check_org [ int ( origin [ i ] [ 1 ] ) - 1 ] [ i ] = origin [ i ] [ 0 ] <NEWLINE> check_sort [ int ( self . cards [ i ] [ 1 ] ) - 1 ] [ i ] = self . cards [ i ] [ 0 ] <NEWLINE> <DEDENT> flag = 0 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> if <STRING> . join ( check_org [ i ] ) != <STRING> . join ( check_sort [ i ] ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_card ( self ) : <NEWLINE> <INDENT> for i in range ( self . n ) : <NEWLINE> <INDENT> if i != self . n - 1 : <NEWLINE> <INDENT> print ( <STRING> % ( self . cards [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( self . cards [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> card = input ( ) . split ( ) <NEWLINE> card2 = card . copy ( ) <NEWLINE> card_origin = card . copy ( ) <NEWLINE> <NL> bubble = Sort ( n , card ) <NEWLINE> bubble . bubble_sort ( ) <NEWLINE> bubble . print_card ( ) <NEWLINE> bubble . check_stable ( card_origin ) <NEWLINE> <NL> select = Sort ( n , card2 ) <NEWLINE> select . select_sort ( ) <NEWLINE> select . print_card ( ) <NEWLINE> select . check_stable ( card_origin ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> <NL> def m ( l ) : <NEWLINE> <INDENT> result = 1 <NEWLINE> for num in l : <NEWLINE> <INDENT> result *= num <NEWLINE> if result == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif result > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> input ( ) <NEWLINE> aList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aList . sort ( ) <NEWLINE> print ( m ( aList ) ) <NEWLINE> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> z = ( s - i - j ) <NEWLINE> if 0 <= z <= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> s = input ( ) <NEWLINE> first = s . find ( <STRING> ) <NEWLINE> <NL> if first == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( first + 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - first <NEWLINE> first += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def shiki ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> anli = [ 0 ] * 10100 <NEWLINE> <NL> <NL> for x in range ( 1 , 150 ) : <NEWLINE> <INDENT> if shiki ( x , 1 , 1 ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if shiki ( x , y , 1 ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <NL> <INDENT> if shiki ( x , y , z ) > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x == y and y == z : <NEWLINE> <INDENT> anli [ shiki ( x , y , z ) ] += 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> anli [ shiki ( x , y , z ) ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> anli [ shiki ( x , y , z ) ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( anli [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> rest = n % ( a + b ) <NEWLINE> n -= rest <NEWLINE> ans = n // ( a + b ) * a <NEWLINE> if rest >= a : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> elif rest < a : <NEWLINE> <INDENT> ans += rest <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> hoge = n // i <NEWLINE> cnt += ( hoge + 1 ) * i * hoge / 2 <NEWLINE> <DEDENT> print ( int ( cnt ) ) <NEWLINE>
import sys <NEWLINE> <NL> d = sys . stdin . readline ( ) <NEWLINE> while d : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , d . split ( ) ) <NEWLINE> inv = 1 / ( a * e - b * d ) <NEWLINE> iA = [ [ e , - b ] , [ - d , a ] ] <NEWLINE> B = [ c , f ] <NEWLINE> sol = list ( ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( 2 ) : <NEWLINE> <INDENT> tmp += inv * iA [ i ] [ j ] * B [ j ] <NEWLINE> <DEDENT> sol . append ( tmp ) <NEWLINE> <DEDENT> print ( <STRING> % ( sol [ 0 ] , sol [ 1 ] ) ) <NEWLINE> <NL> d = sys . stdin . readline ( ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> asum = [ 0 ] <NEWLINE> bsum = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += a [ i ] <NEWLINE> asum . append ( cnt ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt += b [ i ] <NEWLINE> bsum . append ( cnt ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> c = k - asum [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if c < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while c < bsum [ j ] and j > 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> sum_count = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> r_list = set ( ) <NEWLINE> g_list = set ( ) <NEWLINE> b_list = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r_list . add ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g_list . add ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b_list . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for r in r_list : <NEWLINE> <INDENT> for g in g_list : <NEWLINE> <INDENT> L = g - r <NEWLINE> if g + L in b_list : <NEWLINE> <INDENT> sum_count -= 1 <NEWLINE> <DEDENT> if r - L in b_list : <NEWLINE> <INDENT> sum_count -= 1 <NEWLINE> <DEDENT> if L % 2 == 0 and L // 2 + r in b_list : <NEWLINE> <INDENT> sum_count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> <NL> print ( s [ 0 ] + s [ 1 ] + s [ 2 ] ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue , copy , array <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , K = il ( ) <NEWLINE> A = il ( ) <NEWLINE> <NL> for k in range ( K , N ) : <NEWLINE> <INDENT> if A [ k - K ] < A [ k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = 0 <NEWLINE> <NL> tA = [ ] <NEWLINE> l = 2 ** n <NEWLINE> for i in range ( 1 , l ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> bi = <STRING> . format ( i , width = n ) <NEWLINE> bi = bi [ : : - 1 ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if bi [ j ] == <STRING> : <NEWLINE> <INDENT> c += A [ j ] <NEWLINE> <DEDENT> <DEDENT> tA . append ( c ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for mi in M : <NEWLINE> <INDENT> if mi in tA : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> s = tuple ( input ( ) for _ in range ( N ) ) <NEWLINE> d = { } <NEWLINE> d [ <STRING> ] = A <NEWLINE> d [ <STRING> ] = B <NEWLINE> d [ <STRING> ] = C <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> l1 , r1 = s [ i ] <NEWLINE> l2 , r2 = s [ i + 1 ] <NEWLINE> <NL> if d [ <STRING> ] * d [ <STRING> ] * d [ <STRING> ] : <NEWLINE> <INDENT> temp = [ d [ l1 ] , d [ r1 ] ] <NEWLINE> max_val = max ( temp ) <NEWLINE> max_index = temp . index ( max_val ) <NEWLINE> <NL> if max_index == 0 : <NEWLINE> <INDENT> ans . append ( r1 ) <NEWLINE> d [ l1 ] -= 1 <NEWLINE> d [ r1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( l1 ) <NEWLINE> d [ l1 ] += 1 <NEWLINE> d [ r1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if d [ l1 ] * d [ r1 ] : <NEWLINE> <INDENT> if l1 == l2 and r1 == r2 : <NEWLINE> <INDENT> ans . append ( l1 ) <NEWLINE> d [ l1 ] += 1 <NEWLINE> d [ r1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in [ l1 , r1 ] : <NEWLINE> <INDENT> if [ l1 , r1 , l2 , r2 ] . count ( c ) == 1 : <NEWLINE> <INDENT> d [ c ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> d [ c ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = [ d [ l1 ] , d [ r1 ] ] <NEWLINE> max_val = max ( temp ) <NEWLINE> max_index = temp . index ( max_val ) <NEWLINE> <NL> if max_index == 0 : <NEWLINE> <INDENT> ans . append ( r1 ) <NEWLINE> d [ l1 ] -= 1 <NEWLINE> d [ r1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( l1 ) <NEWLINE> d [ l1 ] += 1 <NEWLINE> d [ r1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if any ( [ d [ c ] < 0 for c in <STRING> ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> l1 , r1 = s [ N - 1 ] <NEWLINE> temp = [ d [ l1 ] , d [ r1 ] ] <NEWLINE> max_val = max ( temp ) <NEWLINE> max_index = temp . index ( max_val ) <NEWLINE> <NL> if max_index == 0 : <NEWLINE> <INDENT> ans . append ( r1 ) <NEWLINE> d [ l1 ] -= 1 <NEWLINE> d [ r1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( l1 ) <NEWLINE> d [ l1 ] += 1 <NEWLINE> d [ r1 ] -= 1 <NEWLINE> <NL> <DEDENT> if any ( [ d [ c ] < 0 for c in <STRING> ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import insort <NEWLINE> <NL> t = int ( input ( ) ) <NEWLINE> buf = [ ] <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> is_ok = 0 <NEWLINE> <NL> can = [ ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a = aaa [ i ] <NEWLINE> if s [ i ] == <STRING> : <NEWLINE> <INDENT> for ( b , c ) in can [ : : - 1 ] : <NEWLINE> <INDENT> if a & b : <NEWLINE> <INDENT> a ^= c <NEWLINE> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> b = 1 << ( a . bit_length ( ) - 1 ) <NEWLINE> insort ( can , ( b , a ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for ( b , c ) in can [ : : - 1 ] : <NEWLINE> <INDENT> if a & b : <NEWLINE> <INDENT> a ^= c <NEWLINE> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> is_ok = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> buf . append ( is_ok ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , buf ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> flg = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if A [ - 1 ] != 0 : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def c ( s , n ) : <NEWLINE> <INDENT> s = list ( s ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in alphabets : <NEWLINE> <INDENT> s [ i ] = alphabets [ ( alphabets . index ( s [ i ] ) + n ) % 26 ] <NEWLINE> <DEDENT> <DEDENT> return <STRING> . join ( s ) <NEWLINE> <DEDENT> def is_right ( s ) : <NEWLINE> <INDENT> words = <STRING> . join ( s . split ( <STRING> ) ) . split ( <STRING> ) <NEWLINE> return <STRING> in words or <STRING> in words or <STRING> in words <NEWLINE> <DEDENT> alphabets = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if is_right ( c ( line , i ) ) : <NEWLINE> <INDENT> print ( c ( line , i ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> is_used = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> <NL> di = [ + 1 , 0 , - 1 , 0 ] <NEWLINE> dj = [ 0 , + 1 , 0 , - 1 ] <NEWLINE> <NL> <NL> def dfs ( i , j ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt_w , cnt_b = 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_w , cnt_b = 1 , 0 <NEWLINE> <NL> <DEDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> ni = i + di [ k ] <NEWLINE> nj = j + dj [ k ] <NEWLINE> if ni < 0 or ni >= h or nj < 0 or nj >= w : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if is_used [ ni ] [ nj ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] [ j ] == s [ ni ] [ nj ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> is_used [ ni ] [ nj ] = True <NEWLINE> cw , cb = dfs ( ni , nj ) <NEWLINE> cnt_w += cw <NEWLINE> cnt_b += cb <NEWLINE> <DEDENT> return ( cnt_w , cnt_b ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if not is_used [ i ] [ j ] : <NEWLINE> <INDENT> is_used [ i ] [ j ] = True <NEWLINE> cnt_w , cnt_b = dfs ( i , j ) <NEWLINE> ans += cnt_w * cnt_b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> lines = [ input ( ) . split ( ) for i in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> for d , e in lines : <NEWLINE> <INDENT> if d == e : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D_dict = defaultdict ( int ) <NEWLINE> for d in D : <NEWLINE> <INDENT> D_dict [ d ] += 1 <NEWLINE> <DEDENT> M = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T_dict = defaultdict ( int ) <NEWLINE> for t in T : <NEWLINE> <INDENT> T_dict [ t ] += 1 <NEWLINE> <NL> <DEDENT> for target , t_cnt in T_dict . items ( ) : <NEWLINE> <INDENT> d_cnt = D_dict [ target ] <NEWLINE> if t_cnt > d_cnt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = 0 <NEWLINE> now = 1 <NEWLINE> footprint = [ 1 ] <NEWLINE> past = [ 0 ] * N <NEWLINE> past [ 0 ] = 1 <NEWLINE> <NL> while t < K : <NEWLINE> <INDENT> if past [ A [ now - 1 ] - 1 ] == 0 : <NEWLINE> <INDENT> now = A [ now - 1 ] <NEWLINE> footprint . append ( now ) <NEWLINE> past [ now - 1 ] = 1 <NEWLINE> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = footprint . index ( A [ now - 1 ] ) <NEWLINE> l = t - s + 1 <NEWLINE> e = ( K - s ) % l <NEWLINE> now = footprint [ s + e ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( now ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( cnt ) : <NEWLINE> <INDENT> if c [ j ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( 3 * N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int1 , input ( ) . split ( ) ) <NEWLINE> G [ u * 3 ] . append ( v * 3 + 1 ) <NEWLINE> G [ u * 3 + 1 ] . append ( v * 3 + 2 ) <NEWLINE> G [ u * 3 + 2 ] . append ( v * 3 ) <NEWLINE> <NL> <DEDENT> S , T = map ( int1 , input ( ) . split ( ) ) <NEWLINE> S *= 3 <NEWLINE> T *= 3 <NEWLINE> <NL> <COMMENT> <NL> d = deque ( [ S ] ) <NEWLINE> distance = [ 0 ] * ( 3 * N ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> dist_v = distance [ v ] <NEWLINE> if v == T : <NEWLINE> <INDENT> print ( dist_v // 3 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for x in G [ v ] : <NEWLINE> <INDENT> if not distance [ x ] : <NEWLINE> <INDENT> d . append ( x ) <NEWLINE> distance [ x ] = dist_v + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> sum = sum + math . gcd ( tmp , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h_list [ a - 1 ] <= h_list [ b - 1 ] : <NEWLINE> <INDENT> lst [ a - 1 ] -= 1 <NEWLINE> <DEDENT> if h_list [ a - 1 ] >= h_list [ b - 1 ] : <NEWLINE> <INDENT> lst [ b - 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( lst . count ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for tmp_t in T : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> while ( left < right ) : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if S [ mid ] == tmp_t : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif S [ mid ] > tmp_t : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def gen_d_prim ( n ) : <NEWLINE> <INDENT> D = [ n + 1 if i % 2 else 2 for i in range ( n + 1 ) ] <NEWLINE> D [ 0 ] = D [ 1 ] = 0 <NEWLINE> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if D [ i ] != n + 1 : continue <NEWLINE> for j in range ( i , n + 1 , i ) : D [ j ] = i <NEWLINE> <DEDENT> return D <NEWLINE> <NL> <DEDENT> def gcd_all ( A ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> g = 0 <NEWLINE> for a in A : g = gcd ( g , a ) <NEWLINE> return g <NEWLINE> <NL> <DEDENT> def is_pairwise ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> MAX_A = 10 ** 6 <NEWLINE> D = gen_d_prim ( MAX_A ) <NEWLINE> C = [ 0 ] * ( MAX_A + 1 ) <NEWLINE> all_p = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> p = set ( ) <NEWLINE> while a != 1 : <NEWLINE> <INDENT> if not D [ a ] in p : <NEWLINE> <INDENT> if D [ a ] in all_p : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> all_p . add ( D [ a ] ) <NEWLINE> p . add ( D [ a ] ) <NEWLINE> a //= D [ a ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> if is_pairwise ( ) : return 0 <NEWLINE> if gcd_all ( A ) == 1 : return 1 <NEWLINE> return 2 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> print ( [ <STRING> , <STRING> , <STRING> ] [ solve ( ) ] , <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt , nega , posi = 0 , 0 , [ ] <NEWLINE> for x , y in zip ( a , b ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> nega += y - x <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> posi . append ( x - y ) <NEWLINE> <DEDENT> <DEDENT> if sum ( posi ) - nega < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> posi . sort ( reverse = True ) <NEWLINE> i = 0 <NEWLINE> while nega > 0 : <NEWLINE> <INDENT> nega -= posi [ i ] <NEWLINE> cnt += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> T = T . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> s_list = list ( S ) <NEWLINE> t_list = list ( T ) <NEWLINE> <NL> itti = 0 <NEWLINE> min_count = 10 ** 5 <NEWLINE> for i in range ( len ( s_list ) ) : <NEWLINE> <INDENT> if i + len ( t_list ) > len ( s_list ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> for j in range ( len ( t_list ) ) : <NEWLINE> <INDENT> if not s_list [ i + j ] == t_list [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> min_count = min ( count , min_count ) <NEWLINE> <NL> <DEDENT> print ( min_count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> N_ = ( N - 1 ) // A <NEWLINE> count += N_ <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import functools <NEWLINE> <NL> def multiplication2 ( n , a ) : <NEWLINE> <COMMENT> <NL> <INDENT> acc = 1 <NEWLINE> a_sorted = sorted ( a ) <NEWLINE> if a_sorted [ 0 ] == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> for s in a_sorted : <NEWLINE> <NL> <INDENT> acc = acc * s <NEWLINE> if 10 ** 18 < acc : <NEWLINE> <INDENT> acc = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return acc <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( multiplication2 ( n , a ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> s += int ( n [ i ] ) <NEWLINE> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> import numpy as np <NEWLINE> <NL> A_MAX = 10 ** 6 + 1 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> dp = np . zeros ( shape = A_MAX , dtype = np . int64 ) <NEWLINE> <NL> if A [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif A [ 1 ] > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A . keys ( ) : <NEWLINE> <INDENT> multiples = np . arange ( a , A_MAX , a ) <NEWLINE> np . add . at ( dp , multiples , 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a , count in A . items ( ) : <NEWLINE> <INDENT> if count > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dp [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> s = sum ( a ) <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res += a [ i ] <NEWLINE> s -= a [ i ] <NEWLINE> ans = min ( ans , abs ( s - res ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if ( A [ i ] <= A [ i - K ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import heapq <NEWLINE> <NL> q_a = heapq . heapify ( a ) <NEWLINE> <NL> for m in range ( m ) : <NEWLINE> <INDENT> x = heapq . heappop ( a ) * ( - 1 ) <NEWLINE> heapq . heappush ( a , ( x // 2 ) * ( - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( a ) * ( - 1 ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> cntb = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans = ans + ( ( ( m * pow ( m - 1 , n - 1 - i , mod ) ) % mod ) * cntb ) % mod <NEWLINE> ans = ans % mod <NEWLINE> cntb = ( cntb * ( n - 1 - i ) * pow ( i + 1 , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10001 ) ] <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> v = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if v < 10001 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> process = [ ] <NEWLINE> proc_append = process . append <NEWLINE> hash = [ 0 ] * 100001 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> proc_append ( tuple ( input ( ) . split ( ) ) ) <NEWLINE> process [ i ] = tuple ( map ( int , process [ i ] ) ) <NEWLINE> <NL> <DEDENT> goukei = sum ( A ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> hash [ i ] += 1 <NEWLINE> <NL> <DEDENT> for b , c in process : <NEWLINE> <INDENT> if hash [ b ] != 0 : <NEWLINE> <INDENT> goukei += ( c - b ) * hash [ b ] <NEWLINE> hash [ c ] += hash [ b ] <NEWLINE> hash [ b ] = 0 <NEWLINE> <DEDENT> print ( goukei ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> As = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> d = { } <NEWLINE> for x in As : <NEWLINE> <INDENT> if x in d : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = 1 <NEWLINE> <DEDENT> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> B , C = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> if C in d : <NEWLINE> <INDENT> d [ C ] += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ C ] = B <NEWLINE> <DEDENT> <DEDENT> res = 0 <NEWLINE> rest = N <NEWLINE> d2 = sorted ( [ x for x in d . keys ( ) ] , reverse = True ) <NEWLINE> for m in d2 : <NEWLINE> <INDENT> x = d [ m ] <NEWLINE> if rest < x : <NEWLINE> <INDENT> res += rest * m <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += x * m <NEWLINE> rest -= x <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> var = var2 = 0 <NEWLINE> c = l [ 0 ] <NEWLINE> for i in l [ 1 : ] : <NEWLINE> <INDENT> if c < i : <NEWLINE> <INDENT> var = 1 <NEWLINE> <DEDENT> elif c > i : <NEWLINE> <INDENT> var2 = 1 <NEWLINE> <DEDENT> if var == 1 and var2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> var = var2 = 0 <NEWLINE> <DEDENT> c = i <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> p = p * i <NEWLINE> if p > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = x // d <NEWLINE> <NL> a = x - x // d * d <NEWLINE> b = d - abs ( a ) <NEWLINE> <NL> if x // d % 2 == 0 : <NEWLINE> <INDENT> odd = a <NEWLINE> even = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd = b <NEWLINE> even = a <NEWLINE> <NL> <DEDENT> if abs ( x // d ) > k : <NEWLINE> <INDENT> ans = abs ( abs ( x ) - abs ( d * k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> ans = odd <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = even <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( abs ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> print ( s [ : r ] . count ( <STRING> ) ) <NEWLINE>
strings = input ( ) <NEWLINE> lists = [ ] <NEWLINE> count = 0 <NEWLINE> for i in strings : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> lists . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> lists . append ( count ) <NEWLINE> print ( max ( lists ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> _sum = N * ( 1 + N ) / 2 <NEWLINE> <NL> if N >= 3 : <NEWLINE> <INDENT> _min = 3 <NEWLINE> _max = 3 * ( N // 3 ) <NEWLINE> num = ( _max - _min ) / 3 + 1 <NEWLINE> _sum -= num * ( _min + _max ) / 2 <NEWLINE> <NL> <DEDENT> if N >= 5 : <NEWLINE> <INDENT> _min = 5 <NEWLINE> _max = 5 * ( N // 5 ) <NEWLINE> num = ( _max - _min ) / 5 + 1 <NEWLINE> _sum -= num * ( _min + _max ) / 2 <NEWLINE> <NL> <DEDENT> if N >= 15 : <NEWLINE> <INDENT> _min = 15 <NEWLINE> _max = 15 * ( N // 15 ) <NEWLINE> num = ( _max - _min ) / 15 + 1 <NEWLINE> _sum += num * ( _min + _max ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( _sum ) ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( x ) // d >= k : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - k * d ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> y = abs ( x ) // d <NEWLINE> a = y + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( k - ( a - 1 ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - ( a - 1 ) * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - a * d ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> before_sum = sum ( a ) - a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> before_sum -= a [ i ] <NEWLINE> <DEDENT> total += a [ i ] * ( before_sum ) <NEWLINE> <NL> <NL> <DEDENT> print ( total % mod ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> aas = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> scores = [ ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if aas [ i ] > aas [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
def ALDS1_5A ( ) : <NEWLINE> <INDENT> n , A , q = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , int ( input ( ) ) <NEWLINE> S = [ False for i in range ( 2001 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> for i in range ( 2001 - a , 0 , - 1 ) : <NEWLINE> <INDENT> if S [ i ] : S [ i + a ] = True <NEWLINE> <DEDENT> S [ a ] = True <NEWLINE> <DEDENT> for mi in input ( ) . split ( ) : <NEWLINE> <INDENT> if S [ int ( mi ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ALDS1_5A ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = 0 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> ans = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> f = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> friends = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> f = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> friends . append ( f ) <NEWLINE> <NL> <DEDENT> friend_map = UnionFind ( n ) <NEWLINE> <NL> for f in friends : <NEWLINE> <INDENT> friend_map . union ( f [ 0 ] - 1 , f [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = friend_map . size ( i ) <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> if x + y <= s : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> INF = 10 ** 18 <NEWLINE> arr = deque ( [ ] ) <NEWLINE> for a in A : <NEWLINE> <INDENT> l , r = - 1 , len ( arr ) <NEWLINE> while ( r - l ) > 1 : <NEWLINE> <INDENT> mid = ( r + l ) // 2 <NEWLINE> if arr [ mid ] < a : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> if l == - 1 : <NEWLINE> <INDENT> arr . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ l ] = a <NEWLINE> <DEDENT> <DEDENT> print ( len ( arr ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = ( int ( input ( ) ) for i in range ( q ) ) <NEWLINE> d = defaultdict ( lambda : k - q ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> d [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for value in d . values ( ) : <NEWLINE> <INDENT> print ( <STRING> if value > 0 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def linerSearch ( S , key ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> S . append ( key ) <NEWLINE> while S [ i ] != key : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if i == len ( S ) - 1 : <NEWLINE> <INDENT> S . pop ( ) <NEWLINE> return False <NEWLINE> <DEDENT> S . pop ( ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> if linerSearch ( S , T [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] / A [ i - K ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> s = sum ( A ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = cnt [ b ] <NEWLINE> if b in cnt : <NEWLINE> <INDENT> cnt [ c ] += cnt [ b ] <NEWLINE> del cnt [ b ] <NEWLINE> <DEDENT> s += ( c - b ) * n <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> total = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <NL> for gap in range ( 1 , N // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( N - 2 * gap ) : <NEWLINE> <INDENT> j = i + gap <NEWLINE> k = j + gap <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ k ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ int ( c ) for c in s ] <NEWLINE> <NL> <NL> if len ( a ) < 4 : <NEWLINE> <INDENT> print ( 1000 - int ( s ) ) <NEWLINE> <DEDENT> elif a [ - 3 ] != 0 : <NEWLINE> <INDENT> print ( ( a [ - 4 ] + 1 ) * 1000 - int ( s ) ) <NEWLINE> <DEDENT> elif int ( s ) % 1000 != 0 : <NEWLINE> <INDENT> print ( ( a [ - 4 ] + 1 ) * 1000 - int ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= n : break <NEWLINE> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def invNum ( d , A ) : <NEWLINE> <INDENT> if d < 0 or len ( A ) < 2 : return 0 <NEWLINE> cnt = 0 <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for ai in A : <NEWLINE> <INDENT> if ai < 2 ** d : <NEWLINE> <INDENT> L . append ( ai ) <NEWLINE> cnt += len ( R ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R . append ( ai - 2 ** d ) <NEWLINE> <DEDENT> <DEDENT> return cnt + invNum ( d - 1 , L ) + invNum ( d - 1 , R ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( invNum ( 29 , list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if not n and not m : break <NEWLINE> <NL> lst = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> lst . append ( 0 ) <NEWLINE> lst = sorted ( lst ) <NEWLINE> lst2 = [ i + j for i in lst for j in lst if i <= j ] <NEWLINE> lst2 = sorted ( lst2 ) <NEWLINE> A = [ ] <NEWLINE> index = len ( lst2 ) - 1 <NEWLINE> for i in lst2 : <NEWLINE> <INDENT> if i + lst2 [ - 1 ] <= m : <NEWLINE> <INDENT> A . append ( i + lst2 [ - 1 ] ) <NEWLINE> <DEDENT> elif i <= m : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if i + lst2 [ index ] <= m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> index -= 1 <NEWLINE> <DEDENT> A . append ( i + lst2 [ index ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max ( A ) ) <NEWLINE> <DEDENT> <DEDENT> solve ( ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def registerDictionaryFromTheNumberOf ( counts ) : <NEWLINE> <INDENT> dictionary = { } <NEWLINE> for i in range ( counts ) : <NEWLINE> <INDENT> key , value = input ( ) . split ( <STRING> ) <NEWLINE> dictionary [ key ] = value <NEWLINE> <DEDENT> return dictionary <NEWLINE> <NL> <DEDENT> def readCharacterBeforeConversionAsManyAs ( counts ) : <NEWLINE> <INDENT> readString = <STRING> <NEWLINE> for i in range ( counts ) : <NEWLINE> <INDENT> readString += input ( ) . rstrip ( ) <NEWLINE> <DEDENT> return readString <NEWLINE> <NL> <DEDENT> def convertCharactersByThe ( dictionary , target ) : <NEWLINE> <INDENT> converted = <STRING> <NEWLINE> for index in range ( len ( list ( target ) ) ) : <NEWLINE> <INDENT> if target [ index ] in dictionary : <NEWLINE> <INDENT> converted += dictionary [ target [ index ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> converted += target [ index ] <NEWLINE> <DEDENT> <DEDENT> return converted <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> dictionaryCounts = int ( input ( ) ) <NEWLINE> if dictionaryCounts == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dictionary = registerDictionaryFromTheNumberOf ( dictionaryCounts ) <NEWLINE> original = readCharacterBeforeConversionAsManyAs ( int ( input ( ) ) ) <NEWLINE> converted = convertCharactersByThe ( dictionary , original ) <NEWLINE> print ( converted ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] * a [ i - 1 ] <NEWLINE> if a [ i ] > 10 ** 18 : <NEWLINE> <INDENT> b += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ n - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> samu = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> samu = samu ^ a [ i ] <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = samu ^ a [ i ] <NEWLINE> c . append ( num ) <NEWLINE> <NL> <DEDENT> print ( * c ) <NEWLINE>
import networkx as nx <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edge ( a , b ) <NEWLINE> <NL> <DEDENT> tmp = list ( nx . connected_components ( G ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in tmp : <NEWLINE> <INDENT> count += len ( i ) <NEWLINE> <NL> <NL> <DEDENT> print ( N - count + len ( tmp ) - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> my_set = set ( ) <NEWLINE> for i in a_list : <NEWLINE> <INDENT> if i in my_set : <NEWLINE> <INDENT> my_set . remove ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> my_set . add ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( my_set ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> R_count = S . count ( <STRING> ) <NEWLINE> G_count = S . count ( <STRING> ) <NEWLINE> B_count = S . count ( <STRING> ) <NEWLINE> <NL> ans = R_count * G_count * B_count <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for d in range ( 1 , N ) : <NEWLINE> <INDENT> if i + 2 * d >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> <NL> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
a = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> x = int ( a [ 0 ] ) <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> <DEDENT> k = int ( a [ 1 ] ) <NEWLINE> d = int ( a [ 2 ] ) <NEWLINE> c = x // d <NEWLINE> <NL> if c >= k : <NEWLINE> <INDENT> x -= d * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= d * c <NEWLINE> if ( k - c ) % 2 == 1 : <NEWLINE> <INDENT> x = ( x - d ) * - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for l in range ( k ) : <NEWLINE> <INDENT> for m in range ( k ) : <NEWLINE> <INDENT> tmp = math . gcd ( l + 1 , m + 1 ) <NEWLINE> for n in range ( k ) : <NEWLINE> <INDENT> gcd = math . gcd ( tmp , n + 1 ) <NEWLINE> sum += gcd <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> f = 0 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> s = s * a <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** ( 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> K += 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> ans += math . gcd ( i , i ) <NEWLINE> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> ans += 6 * math . gcd ( i , j ) <NEWLINE> for k in range ( j + 1 , K ) : <NEWLINE> <INDENT> ans += 6 * math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . r = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . r [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . r [ x ] = self . root ( self . r [ x ] ) <NEWLINE> return self . r [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . r [ x ] > self . r [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . r [ x ] += self . r [ y ] <NEWLINE> self . r [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - 1 * self . r [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( self . r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> UF = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> UF . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , UF . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def solve ( n , aaa ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> h , m = divmod ( sum ( aaa ) , 2 ) <NEWLINE> if m == 1 or h > aaa [ 0 ] : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return aaa [ 0 ] - h <NEWLINE> <NL> <DEDENT> x = 0 <NEWLINE> for a in aaa [ 2 : ] : <NEWLINE> <INDENT> x ^= a <NEWLINE> <DEDENT> a0 , a1 = aaa [ : 2 ] <NEWLINE> s = a0 + a1 <NEWLINE> <NL> if s & 1 != x & 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> p , q = 0 , 0 <NEWLINE> <NL> b = 1 << 40 <NEWLINE> swappable = [ ] <NEWLINE> while b : <NEWLINE> <INDENT> bx = x & b <NEWLINE> if bx == 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if s >= 2 * b : <NEWLINE> <INDENT> if p | b <= a0 : <NEWLINE> <INDENT> p |= b <NEWLINE> q |= b <NEWLINE> s -= 2 * b <NEWLINE> <DEDENT> elif swappable : <NEWLINE> <INDENT> bs = swappable . pop ( ) <NEWLINE> p ^= bs <NEWLINE> q ^= bs <NEWLINE> p |= b <NEWLINE> q |= b <NEWLINE> s -= 2 * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s < b : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> if p | b <= a0 and q | b > a1 : <NEWLINE> <INDENT> p |= b <NEWLINE> swappable . append ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q |= b <NEWLINE> <DEDENT> s -= b <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> b >>= 1 <NEWLINE> <NL> <DEDENT> if p == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> assert s == 0 <NEWLINE> assert p ^ q == x <NEWLINE> assert a0 - p == q - a1 <NEWLINE> return a0 - p <NEWLINE> <NL> <NL> <DEDENT> n , * aaa = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> print ( solve ( n , aaa ) ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> ans += int ( n [ i ] ) <NEWLINE> <DEDENT> if ans % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> <NL> ls = list ( s ) <NEWLINE> lt = list ( t ) <NEWLINE> <NL> ans = 0 <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> rep_cnt = 0 <NEWLINE> for i in range ( j , len ( ls ) ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> if ls [ i ] != lt [ i ] : <NEWLINE> <INDENT> ls [ i ] = lt [ i ] <NEWLINE> rep_cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if rep_cnt > 0 : <NEWLINE> <INDENT> ans += rep_cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = list ( s ) . count ( <STRING> ) <NEWLINE> g = list ( s ) . count ( <STRING> ) <NEWLINE> b = list ( s ) . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if ( k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = 1000 <NEWLINE> kabu = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if A [ i - 1 ] <= A [ i ] : <NEWLINE> <INDENT> kabu = C // A [ i - 1 ] <NEWLINE> C += kabu * ( A [ i ] - A [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( C ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> print ( max ( nums [ 0 ] , nums [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> temp += [ temp [ - 1 ] + nums [ i ] ] <NEWLINE> <DEDENT> <DEDENT> dp = [ [ 0 , 0 , 0 ] for _ in range ( n ) ] <NEWLINE> dp [ 0 ] [ 0 ] = nums [ 0 ] <NEWLINE> dp [ 1 ] [ 0 ] , dp [ 1 ] [ 1 ] , dp [ 1 ] [ 2 ] = nums [ 1 ] , nums [ 0 ] , - float ( <STRING> ) <NEWLINE> dp [ 2 ] [ 0 ] , dp [ 2 ] [ 1 ] , dp [ 2 ] [ 2 ] = nums [ 2 ] , nums [ 1 ] , nums [ 0 ] <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i - 2 ] ) + nums [ i ] <NEWLINE> dp [ i ] [ 1 ] = max ( dp [ i - 3 ] ) + nums [ i - 1 ] <NEWLINE> dp [ i ] [ 2 ] = temp [ i // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i - 2 ] ) + nums [ i ] <NEWLINE> dp [ i ] [ 1 ] = temp [ ( i - 1 ) // 2 ] + nums [ i - 1 ] <NEWLINE> dp [ i ] [ 2 ] = - float ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp [ n - 1 ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( 1 , 201 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( 1 , int ( i ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> s += 1 <NEWLINE> if j != i // j : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> a . append ( s ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 8 and i % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( X ) <NEWLINE> <NL> for A in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ A ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 1 << 31 <NEWLINE> dist = np . array ( [ [ INF for _ in range ( N ) ] for _ in range ( N ) ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dist [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> dist [ a ] [ b ] = c <NEWLINE> dist [ b ] [ a ] = c <NEWLINE> <NL> <DEDENT> dist = floyd_warshall ( dist ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if dist [ i ] [ j ] <= L : <NEWLINE> <INDENT> dist [ i ] [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dist [ i ] [ j ] = INF <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dist = floyd_warshall ( dist ) <NEWLINE> dist [ dist == INF ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> Q = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * Q <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> t -= 1 <NEWLINE> ans [ q ] = int ( dist [ s ] [ t ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> N -= 1 <NEWLINE> S = str ( input ( ) ) <NEWLINE> count = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k > N : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif S [ i ] == S [ j ] or S [ i ] == S [ k ] or S [ j ] == S [ k ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> for a in l : <NEWLINE> <INDENT> if ans * a > 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif ans != - 1 or a == 0 : <NEWLINE> <INDENT> ans *= a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
diagram = input ( ) <NEWLINE> <NL> water_all = 0 <NEWLINE> water = 0 <NEWLINE> ip = 0 <NEWLINE> stack1 = [ ] <NEWLINE> stack2 = [ ] <NEWLINE> <NL> for i , symbol in enumerate ( diagram ) : <NEWLINE> <INDENT> if symbol == <STRING> : <COMMENT> <NEWLINE> <INDENT> stack1 . append ( i ) <NEWLINE> <DEDENT> elif symbol == <STRING> : <NEWLINE> <INDENT> if stack1 != [ ] : <NEWLINE> <INDENT> ip = stack1 . pop ( ) <NEWLINE> water = i - ip <NEWLINE> water_all += water <NEWLINE> <NL> if stack2 != [ ] : <NEWLINE> <INDENT> while stack2 [ - 1 ] [ 0 ] > ip : <NEWLINE> <INDENT> i2 , water2 = stack2 . pop ( ) <NEWLINE> water += water2 <NEWLINE> if stack2 == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> stack2 . append ( [ ip , water ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack2 . append ( [ ip , water ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> s = str ( len ( stack2 ) ) <NEWLINE> waters = [ str ( i [ 1 ] ) for i in stack2 ] <NEWLINE> if len ( waters ) != 0 : <NEWLINE> <INDENT> s += <STRING> + <STRING> . join ( waters ) <NEWLINE> <NL> <DEDENT> print ( water_all ) <NEWLINE> print ( s ) <NEWLINE>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ ni ] ] ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L_i , L_j = [ ] , [ ] <NEWLINE> L_memo = [ 0 ] * N <NEWLINE> cnt = 0 <NEWLINE> for i , j in enumerate ( L ) : <NEWLINE> <INDENT> if i + j < N : <NEWLINE> <INDENT> L_memo [ i + j ] += 1 <NEWLINE> <DEDENT> if i - j > 0 : <NEWLINE> <INDENT> cnt += L_memo [ i - j ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in an : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in an : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ <STRING> ] * ( N - K ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> tmp = A [ K + i ] / A [ i ] <NEWLINE> if 1 < tmp : <NEWLINE> <INDENT> ans [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , math , collections , itertools <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ABC = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC . append ( [ a , b , a + b ] ) <NEWLINE> <NL> <DEDENT> taka = 0 <NEWLINE> aoki = 0 <NEWLINE> ABC . sort ( key = lambda x : x [ 2 ] ) <NEWLINE> while ABC : <NEWLINE> <NL> <INDENT> taka += ABC . pop ( ) [ 0 ] <NEWLINE> if len ( ABC ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> aoki += ABC . pop ( ) [ 1 ] <NEWLINE> <DEDENT> print ( taka - aoki ) <NEWLINE>
def test ( ) : <NEWLINE> <INDENT> from itertools import combinations <NEWLINE> <NL> s = <STRING> <NEWLINE> result = 0 <NEWLINE> for k in range ( 1 , len ( s ) // 2 + 1 ) : <NEWLINE> <INDENT> for idx in combinations ( range ( len ( s ) ) , 2 * k ) : <NEWLINE> <INDENT> success = True <NEWLINE> for ii in range ( k ) : <NEWLINE> <INDENT> if s [ idx [ ii ] ] != s [ idx [ ii + k ] ] : <NEWLINE> <INDENT> success = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if success : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> factorials = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , 40 ) : <NEWLINE> <INDENT> factorials . append ( factorials [ - 1 ] * i ) <NEWLINE> <NL> <DEDENT> patterns = { } <NEWLINE> for i in range ( 2 , 40 ) : <NEWLINE> <INDENT> base = ( 1 << ( i - 1 ) ) - 1 <NEWLINE> gain = base <NEWLINE> chars = i <NEWLINE> if gain > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain not in patterns or chars < patterns [ gain ] [ 0 ] : <NEWLINE> <INDENT> patterns [ gain ] = ( chars , ( i , ) ) <NEWLINE> <DEDENT> if i % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> a = i // 2 <NEWLINE> ncr1 = factorials [ i ] // factorials [ a ] // factorials [ a ] - 1 <NEWLINE> <NL> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> base2 = ( 1 << ( 2 * b - 1 ) ) - 1 <NEWLINE> ncr2 = factorials [ 2 * b ] // factorials [ b ] // factorials [ b ] - 1 <NEWLINE> gain = base + base2 + ncr1 * ncr2 <NEWLINE> chars = i + 2 * b <NEWLINE> if gain > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain not in patterns or chars < patterns [ gain ] [ 0 ] : <NEWLINE> <INDENT> patterns [ gain ] = ( chars , ( a , b ) ) <NEWLINE> <NL> <DEDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> base3 = ( 1 << ( 2 * c - 1 ) ) - 1 <NEWLINE> ncr3 = factorials [ 2 * c ] // factorials [ c ] // factorials [ c ] - 1 <NEWLINE> gain = base + base2 + base3 + ncr1 * ncr2 * ncr3 + ncr1 * ncr2 + ncr2 * ncr3 + ncr3 * ncr1 <NEWLINE> chars = i + 2 * b + 2 * c <NEWLINE> if gain > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain not in patterns or chars < patterns [ gain ] [ 0 ] : <NEWLINE> <INDENT> patterns [ gain ] = ( chars , ( a , b , c ) ) <NEWLINE> <NL> <DEDENT> for d in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> base4 = ( 1 << ( 2 * d - 1 ) ) - 1 <NEWLINE> ncr4 = factorials [ 2 * d ] // factorials [ d ] // factorials [ d ] - 1 <NEWLINE> gain = base + base2 + base3 + base4 + ncr1 * ncr2 * ncr3 * ncr4 <NEWLINE> gain += ncr1 * ncr2 * ncr3 + ncr1 * ncr2 * ncr4 + ncr1 * ncr3 * ncr4 + ncr2 * ncr3 * ncr4 <NEWLINE> gain += ncr1 * ncr2 + ncr1 * ncr3 + ncr1 * ncr4 + ncr2 * ncr3 + ncr2 * ncr4 + ncr3 * ncr4 <NEWLINE> chars = i + 2 * b + 2 * c + 2 * d <NEWLINE> if gain > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain not in patterns or chars < patterns [ gain ] [ 0 ] : <NEWLINE> <INDENT> patterns [ gain ] = ( chars , ( a , b , c , d ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def dfs ( use , i , remaining , total_char ) : <NEWLINE> <INDENT> if remaining == 0 : <NEWLINE> <INDENT> return total_char <= 200 <NEWLINE> <NL> <DEDENT> for j in range ( i , len ( patterns ) ) : <NEWLINE> <INDENT> gain , ( chars , lengths ) = patterns [ j ] <NEWLINE> if total_char + remaining * chars / gain > 200 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if gain > remaining : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> use . append ( lengths ) <NEWLINE> result = dfs ( use , j , remaining - gain , total_char + chars ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> use . pop ( ) <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> patterns = sorted ( patterns . items ( ) , key = lambda item : item [ 0 ] / item [ 1 ] [ 0 ] , reverse = True ) <NEWLINE> <NL> use = [ ] <NEWLINE> result = dfs ( use , 0 , n , 0 ) <NEWLINE> assert result <NEWLINE> <NL> ans = [ ] <NEWLINE> c = 1 <NEWLINE> for lengths in use : <NEWLINE> <INDENT> if len ( lengths ) == 1 : <NEWLINE> <INDENT> ans . extend ( [ c ] * lengths [ 0 ] ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( 2 ) : <NEWLINE> <INDENT> for i , l in enumerate ( lengths ) : <NEWLINE> <INDENT> ans . extend ( [ c + i ] * l ) <NEWLINE> <DEDENT> <DEDENT> c += len ( lengths ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE> print ( * ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> for index , i in enumerate ( s ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> s [ index ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> . join ( s ) <NEWLINE> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> S = input ( ) <NEWLINE> d = deque ( ) <NEWLINE> for i in S : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> Flag = True <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> L = input ( ) . split ( ) <NEWLINE> if L [ 0 ] == <STRING> : <NEWLINE> <INDENT> Flag = not Flag <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if L [ 1 ] == <STRING> and Flag or L [ 1 ] == <STRING> and not Flag : <NEWLINE> <INDENT> d . appendleft ( L [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( L [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in d : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> if not Flag : <NEWLINE> <INDENT> ans = ans [ : : - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sum = 0 <NEWLINE> count = [ 0 for _ in range ( K + 1 ) ] <NEWLINE> pows = [ 0 for _ in range ( K + 1 ) ] <NEWLINE> <NL> def cal_pow ( k , pows ) : <NEWLINE> <INDENT> if pows [ k ] == 0 : <NEWLINE> <INDENT> pows [ k ] = pow ( k , N , mod ) <NEWLINE> return pows [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return pows [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> for h in range ( K ) : <NEWLINE> <INDENT> k = K - h <NEWLINE> sub , alpha = 0 , 2 <NEWLINE> while True : <NEWLINE> <INDENT> if alpha * k <= K : <NEWLINE> <INDENT> sub += count [ alpha * k ] <NEWLINE> alpha += 1 <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> count [ k ] = ( cal_pow ( K // k , pows ) - sub ) % mod <NEWLINE> <NL> <DEDENT> for k , c in enumerate ( count ) : <NEWLINE> <INDENT> sum += k * c % mod <NEWLINE> <DEDENT> print ( sum % mod ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> from math import sqrt , ceil , pow <NEWLINE> import bisect <NEWLINE> <NL> <NL> <COMMENT> <NL> class SieveOfAtkin : <NEWLINE> <INDENT> def __init__ ( self , limit ) : <NEWLINE> <INDENT> self . limit = limit <NEWLINE> self . primes = [ ] <NEWLINE> self . sieve = [ False ] * ( self . limit + 1 ) <NEWLINE> <NL> <DEDENT> def flip ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> self . sieve [ prime ] = True if self . sieve [ prime ] == False else False <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> def invalidate ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if self . sieve [ prime ] == True : self . sieve [ prime ] = False <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> def isPrime ( self , prime ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return self . sieve [ prime ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def getPrimes ( self ) : <NEWLINE> <INDENT> testingLimit = int ( ceil ( sqrt ( self . limit ) ) ) <NEWLINE> <NL> for i in range ( testingLimit ) : <NEWLINE> <INDENT> for j in range ( testingLimit ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = 4 * int ( pow ( i , 2 ) ) + int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and ( n % 12 == 1 or n % 12 == 5 ) : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n = 3 * int ( pow ( i , 2 ) ) + int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and n % 12 == 7 : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> n = 3 * int ( pow ( i , 2 ) ) - int ( pow ( j , 2 ) ) <NEWLINE> if n <= self . limit and i > j and n % 12 == 11 : <NEWLINE> <INDENT> self . flip ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 5 , testingLimit ) : <NEWLINE> <INDENT> if self . isPrime ( i ) : <NEWLINE> <INDENT> k = int ( pow ( i , 2 ) ) <NEWLINE> for j in range ( k , self . limit , k ) : <NEWLINE> <INDENT> self . invalidate ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> self . primes = [ 2 , 3 ] + [ x for x in range ( len ( self . sieve ) ) if self . isPrime ( x ) and x >= 5 ] <NEWLINE> return self . primes <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> def solve1 ( num , primes ) : <NEWLINE> <COMMENT> <NL> <INDENT> result = 0 <NEWLINE> <NL> <COMMENT> <NL> i = bisect . bisect_left ( primes , num ) <NEWLINE> list_primes = primes [ : i ] <NEWLINE> <NL> <NL> set_primes = set ( list_primes ) <NEWLINE> for x in list_primes : <NEWLINE> <INDENT> if x > num / 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( num - x ) in set_primes : <NEWLINE> <COMMENT> <NL> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def solve2 ( num , primes ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> sub_primes = set ( x for x in primes if x < num ) <NEWLINE> while sub_primes : <NEWLINE> <INDENT> x = sub_primes . pop ( ) <NEWLINE> if x * 2 == num : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> elif ( num - x ) in sub_primes : <NEWLINE> <INDENT> result += 1 <NEWLINE> sub_primes . remove ( num - x ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <NL> <DEDENT> def solve3 ( num , primes ) : <NEWLINE> <COMMENT> <NL> <INDENT> result = 0 <NEWLINE> sub_primes = [ x for x in primes if x < num ] <NEWLINE> primes_len = len ( sub_primes ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> n = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if sub_primes [ n ] > num / 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = bisect . bisect_left ( sub_primes , num - sub_primes [ n ] ) <NEWLINE> if i != primes_len and sub_primes [ i ] == num - sub_primes [ n ] : <NEWLINE> <COMMENT> <NL> <INDENT> result += 1 <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> A = SieveOfAtkin ( 50000 ) <NEWLINE> A . getPrimes ( ) <NEWLINE> while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> result = solve1 ( num , A . primes ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> LR = np . array ( [ list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for _ in range ( M ) ] ) <NEWLINE> print ( max ( min ( LR [ : , 1 ] ) - max ( LR [ : , 0 ] ) + 1 , 0 ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - 1 * ( k - a - b ) ) <NEWLINE> <DEDENT>
<NL> H , W , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h = [ 0 ] * H <NEWLINE> w = [ 0 ] * W <NEWLINE> <NL> hw = { } <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h [ a - 1 ] += 1 <NEWLINE> w [ b - 1 ] += 1 <NEWLINE> temp = <STRING> + str ( a - 1 ) + <STRING> + str ( b - 1 ) <NEWLINE> hw [ temp ] = 1 <NEWLINE> <NL> <DEDENT> hm = max ( h ) <NEWLINE> wm = max ( w ) <NEWLINE> <NL> hp = [ i for i , v in enumerate ( h ) if v == hm ] <NEWLINE> wp = [ i for i , v in enumerate ( w ) if v == wm ] <NEWLINE> <NL> for x in hp : <NEWLINE> <INDENT> for y in wp : <NEWLINE> <INDENT> temp = <STRING> + str ( x ) + <STRING> + str ( y ) <NEWLINE> if temp not in hw : <NEWLINE> <INDENT> print ( hm + wm ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( hm + wm - 1 ) <NEWLINE> <NL> <DEDENT>
from collections import Counter , deque <NEWLINE> <NL> _ , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> d = deque ( sorted ( Counter ( a ) . values ( ) ) ) <NEWLINE> while k < len ( d ) : <NEWLINE> <INDENT> ans += d . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ 0 ] * n <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> i -= 1 <NEWLINE> data [ i ] += 1 <NEWLINE> <NL> <DEDENT> for j in data : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> L , R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 2019 <NEWLINE> if R - L >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> import itertools <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i , j in itertools . combinations ( list ( range ( L , R + 1 ) ) , 2 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % MOD ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> cnt = 0 <NEWLINE> <NL> def merge_sort ( a , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( left + ( right - left ) / 2 ) <NEWLINE> merge_sort ( a , left , mid ) <NEWLINE> merge_sort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = a [ left : left + n1 ] <NEWLINE> R = a [ mid : mid + n2 ] <NEWLINE> L . append ( sys . maxsize ) <NEWLINE> R . append ( sys . maxsize ) <NEWLINE> i = j = 0 <NEWLINE> tmp = n1 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> if R [ j ] != sys . maxsize : <NEWLINE> <INDENT> tmp -= 1 <NEWLINE> <DEDENT> a [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if L [ i ] != sys . maxsize : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt += tmp <NEWLINE> <DEDENT> a [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> merge_sort ( a , 0 , len ( a ) ) <NEWLINE> print ( cnt ) <NEWLINE> <NL>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> l = list ( map ( int , s ) ) <NEWLINE> max = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> ans *= l [ n - 1 ] <NEWLINE> n -= 1 <NEWLINE> if ans > max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( ( S - h * 3600 ) / 60 ) <NEWLINE> s = int ( S - h * 3600 - m * 60 ) <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) <NEWLINE> write = lambda x : sys . stdout . write ( x + <STRING> ) <NEWLINE> <NL> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> import networkx as nx <NEWLINE> ans = ( - float ( <STRING> ) , None ) <NEWLINE> f = n * k <NEWLINE> g = nx . DiGraph ( ) <NEWLINE> for i in range ( 2 * n ) : <NEWLINE> <INDENT> g . add_node ( i ) <NEWLINE> <DEDENT> g . add_node ( 2 * n , demand = - f ) <NEWLINE> g . add_node ( 2 * n + 1 , demand = f ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> g . add_edge ( 2 * n , i , capacity = k , weight = 0 ) <NEWLINE> g . add_edge ( i + n , 2 * n + 1 , capacity = k , weight = 0 ) <NEWLINE> <DEDENT> g . add_edge ( 2 * n , 2 * n + 1 , capacity = f , weight = 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> g . add_edge ( i , j + n , capacity = 1 , weight = - a [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> val , d = nx . network_simplex ( g ) <NEWLINE> vals = [ [ <STRING> ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if d [ i ] [ j + n ] == 1 : <NEWLINE> <INDENT> vals [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if - val > ans [ 0 ] : <NEWLINE> <INDENT> ans = ( - val , vals ) <NEWLINE> <DEDENT> print ( ans [ 0 ] ) <NEWLINE> print ( <STRING> . join ( <STRING> . join ( ans [ 1 ] [ i ] ) for i in range ( n ) ) ) <NEWLINE>
import bisect <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = { i for i in range ( 102 ) } <NEWLINE> <NL> S = list ( A - P ) <NEWLINE> <NL> T = bisect . bisect_left ( S , X ) <NEWLINE> <NL> if T == 0 : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> <DEDENT> elif X - S [ T - 1 ] > S [ T ] - X : <NEWLINE> <INDENT> print ( S [ T ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ T - 1 ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> dp = { 0 : 1 } <NEWLINE> q = 1 <NEWLINE> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p += int ( S [ n - 1 - i ] ) * q <NEWLINE> q *= 10 <NEWLINE> q = q % 2019 <NEWLINE> p = p % 2019 <NEWLINE> if p not in dp : <NEWLINE> <INDENT> dp [ p ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( dp [ i ] * ( dp [ i ] - 1 ) // 2 for i in dp ) ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> command = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> ans = collections . deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if command [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . appendleft ( command [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif ans == [ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif command [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans . remove ( command [ i ] [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> elif command [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sum ( a ) % ( 10 ** 9 + 7 ) <NEWLINE> c = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> amod = a [ i ] % ( 10 ** 9 + 7 ) <NEWLINE> c += ( s - b ) * amod <NEWLINE> <DEDENT> print ( c % ( 10 ** 9 + 7 ) ) <NEWLINE>
import copy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort_x = copy . copy ( x ) <NEWLINE> sort_x . sort ( ) <NEWLINE> <NL> center_num = ( N - 1 ) // 2 <NEWLINE> <NL> for l in x : <NEWLINE> <INDENT> if l <= sort_x [ center_num ] : <NEWLINE> <INDENT> print ( sort_x [ center_num + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sort_x [ center_num ] ) <NEWLINE> <DEDENT> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y // gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( gcd ( a [ 0 ] , a [ 1 ] ) , lcm ( a [ 0 ] , a [ 1 ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> r = float ( input ( ) ) <NEWLINE> s = round ( r ** 2 * 3.141592653589 , 6 ) <NEWLINE> l = round ( 2 * r * 3.141592653589 , 6 ) <NEWLINE> print ( str ( s ) + <STRING> + str ( l ) ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loop = N <NEWLINE> pos = 0 <NEWLINE> oto = defaultdict ( int ) <NEWLINE> ind = 0 <NEWLINE> tej = deque ( [ ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pos = A [ pos ] - 1 <NEWLINE> tej . append ( pos + 1 ) <NEWLINE> if oto [ pos ] == 1 : <NEWLINE> <INDENT> ind = tej . index ( pos + 1 ) <NEWLINE> loop = i - ind <NEWLINE> break <NEWLINE> <DEDENT> oto [ pos ] = 1 <NEWLINE> <DEDENT> K -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if K <= ind : <NEWLINE> <INDENT> print ( tej [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tej [ ( K - ind ) % loop + ind ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> cnt = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <DEDENT> total = sum ( A ) <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> total += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def dfs ( f ) : <NEWLINE> <INDENT> if vis [ f ] == 1 : return <NEWLINE> vis [ f ] = 1 <NEWLINE> for t in V [ f ] : <NEWLINE> <INDENT> dfs ( t ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ [ * map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ] for _ in range ( m ) ] <NEWLINE> V = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b in E : V [ a ] . append ( b ) ; V [ b ] . append ( a ) <NEWLINE> ans = 0 <NEWLINE> vis = [ 0 ] * n <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> if vis [ a ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> dfs ( a ) <NEWLINE> <DEDENT> print ( ans - 1 ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> from math import pi <NEWLINE> s = r * r * pi <NEWLINE> l = 2 * r * pi <NEWLINE> print ( <STRING> . format ( s ) , <STRING> . format ( l ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> lr_list = [ list ( map ( int , input ( ) . split ( ) ) ) for nesya in range ( q ) ] <NEWLINE> hoge = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> hoge [ i + 1 ] = hoge [ i ] + ( 1 if s [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for lr in lr_list : <NEWLINE> <INDENT> l = lr [ 0 ] <NEWLINE> r = lr [ 1 ] <NEWLINE> print ( hoge [ r - 1 ] - hoge [ l - 1 ] ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k * 2 >= ( b - a + 1 ) : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : print ( i ) <NEWLINE> for i in range ( b - k + 1 , b + 1 ) : print ( i ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> L = sorted ( L ) <NEWLINE> for i in L : <NEWLINE> <INDENT> a = a * i <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if a <= 10 ** 18 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> A = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> s_i = s [ i : i + len ( t ) + 1 ] <NEWLINE> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s_i [ j ] == t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> A . append ( count ) <NEWLINE> <NL> <DEDENT> ans = len ( t ) - max ( A ) <NEWLINE> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = k * ( k + 1 ) // 2 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> ans += 3 * 2 * math . gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> ans += 3 * 2 * math . gcd ( a , math . gcd ( b , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def inputlist ( ) : return [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = inputlist ( ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = inputlist ( ) <NEWLINE> uf . union ( A , B ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> x = 1 <NEWLINE> y = True <NEWLINE> for i in A : <NEWLINE> <INDENT> x = x * i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> y = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> for i in range ( int ( N ** ( 1 / 2 ) ) ) : <NEWLINE> <INDENT> for j in range ( int ( N ** ( 1 / 2 ) ) ) : <NEWLINE> <INDENT> for k in range ( int ( N ** ( 1 / 2 ) ) ) : <NEWLINE> <INDENT> a = ( i + 1 ) ** 2 + ( j + 1 ) ** 2 + ( k + 1 ) ** 2 + ( i + 1 ) * ( j + 1 ) + ( j + 1 ) * ( k + 1 ) + ( k + 1 ) * ( i + 1 ) <NEWLINE> if a > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l [ a - 1 ] = l [ a - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for c in range ( N ) : <NEWLINE> <INDENT> print ( l [ c ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z <= k and z >= 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S_list = [ input ( ) for i in range ( N ) ] <NEWLINE> c = collections . Counter ( S_list ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
import base64 <NEWLINE> import subprocess <NEWLINE> <NL> <NL> exe_bin = <STRING> <NEWLINE> <NL> exe_bin = base64 . b85decode ( exe_bin ) <NEWLINE> <NL> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( exe_bin ) <NEWLINE> <NL> <DEDENT> subprocess . run ( [ <STRING> ] , shell = True ) <NEWLINE> subprocess . run ( [ <STRING> ] , shell = True ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( ( n - i ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if i + j + j <= n - 1 : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i ] != s [ i + j + j ] and s [ i + j ] != s [ i + j + j ] : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> x . sort ( ) <NEWLINE> for i in range ( a ) : <NEWLINE> <NL> <INDENT> if x [ i ] != 1 and x [ i ] != 0 : <NEWLINE> <INDENT> ans = ans * x [ i ] <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a , b = 1 , 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> n = max ( ( a + x - 1 ) // x , ( b + y - 1 ) // y ) <NEWLINE> a = n * x <NEWLINE> b = n * y <NEWLINE> <DEDENT> print ( a + b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> i = 0 <NEWLINE> s = 1 <NEWLINE> f = 0 <NEWLINE> while i < a : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> f = f + 1 <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> while ( i < a ) and f == 0 : <NEWLINE> <INDENT> s = s * int ( b [ i ] ) <NEWLINE> i = i + 1 <NEWLINE> if s > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if ( s <= 10 ** 18 ) and ( i == a ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> N = str ( x ) <NEWLINE> array = list ( map ( int , N ) ) <NEWLINE> if sum ( array ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> ans += <STRING> + str ( i ) <NEWLINE> <DEDENT> elif <STRING> in str ( i ) : <NEWLINE> <INDENT> ans += <STRING> + str ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> x [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in x : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> flagWhile = True <NEWLINE> flagManip = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while List [ i ] % 2 == 0 : <NEWLINE> <INDENT> List [ i ] = List [ i ] // 2 <NEWLINE> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> x = bisect . bisect_left ( l , l [ i ] + l [ j ] ) - j - 1 <NEWLINE> ans += max ( 0 , x ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> count += 6 * ( gcd ( i , j , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> count += 6 * ( gcd ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> count += i <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> <NL> def b_search ( x , y ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = len ( x ) <NEWLINE> if y > x [ b - 1 ] or y < x [ a ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> while b - a > 1 : <NEWLINE> <INDENT> c = ( a + b ) // 2 <NEWLINE> if x [ c ] == y : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif y < x [ c ] : <NEWLINE> <INDENT> b = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = c <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> count += b_search ( s , t [ i ] ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> N , M , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> A_cum = [ 0 ] <NEWLINE> B_cum = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A_cum . append ( A_cum [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> B_cum . append ( B_cum [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> cnt , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A_cum [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B_cum [ j ] > K - A_cum [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> cnt = max ( cnt , i + j ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r ** 2 , 2 * math . pi * r ) ) <NEWLINE>
from sys import stdin <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> readline = stdin . readline <NEWLINE> <NL> dp = [ - float ( <STRING> ) ] <NEWLINE> <NL> for ai in ( int ( readline ( ) ) for _ in range ( int ( readline ( ) ) ) ) : <NEWLINE> <INDENT> if dp [ - 1 ] < ai : dp . append ( ai ) <NEWLINE> for i in range ( bisect_right ( dp , ai ) , bisect_left ( dp , ai ) + 1 ) : dp [ i ] = ai <NEWLINE> <DEDENT> print ( len ( dp ) - 1 ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c_dic = defaultdict ( list ) <NEWLINE> for idx , i in enumerate ( s ) : <NEWLINE> <INDENT> c_dic [ i ] . append ( idx ) <NEWLINE> <DEDENT> ans = len ( c_dic [ <STRING> ] ) * len ( c_dic [ <STRING> ] ) * len ( c_dic [ <STRING> ] ) <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> number = int ( input ( ) ) <NEWLINE> <NL> number3 = number * number * number <NEWLINE> <NL> print ( number3 ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def find ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> idx = [ ] <NEWLINE> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> var = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> idx . append ( var ) <NEWLINE> <NL> <NL> <DEDENT> r = { } <NEWLINE> c = { } <NEWLINE> <COMMENT> <NL> mz = { } <NEWLINE> <NL> for i in idx : <NEWLINE> <INDENT> mz . setdefault ( ( i [ 0 ] - 1 , i [ 1 ] - 1 ) , 0 ) <NEWLINE> mz [ ( i [ 0 ] - 1 , i [ 1 ] - 1 ) ] = 1 <NEWLINE> <COMMENT> <NL> r . setdefault ( i [ 0 ] - 1 , 0 ) <NEWLINE> r [ i [ 0 ] - 1 ] += 1 <NEWLINE> c . setdefault ( i [ 1 ] - 1 , 0 ) <NEWLINE> c [ i [ 1 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> maxval = 0 <NEWLINE> <NL> <NL> <NL> row = [ ] <NEWLINE> col = [ ] <NEWLINE> maxr = max ( r . values ( ) ) <NEWLINE> maxc = max ( c . values ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> r . setdefault ( i , 0 ) <NEWLINE> if r [ i ] == maxr : <NEWLINE> <INDENT> row . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> c . setdefault ( j , 0 ) <NEWLINE> if c [ j ] == maxc : <NEWLINE> <INDENT> col . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in row : <NEWLINE> <INDENT> for j in col : <NEWLINE> <INDENT> mz . setdefault ( ( i , j ) , 0 ) <NEWLINE> if ( mz [ ( i , j ) ] == 0 ) : <NEWLINE> <INDENT> return maxc + maxr <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return maxc + maxr - 1 <NEWLINE> <NL> <DEDENT> print ( find ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> if n % x == 0 : <NEWLINE> <INDENT> print ( math . floor ( ( n / x ) * t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( ( ( n + x ) // x ) * t ) ) <NEWLINE> <DEDENT>
def calc_k ( p , ws ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> s = 0 <NEWLINE> for w in ws : <NEWLINE> <INDENT> if w > p : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif s + w <= p : <NEWLINE> <INDENT> s += w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> s = w <NEWLINE> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <DEDENT> def search_minimum_p ( k , ws ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lp = max ( ws ) <NEWLINE> rp = 10000 * 100000 <NEWLINE> <NL> while lp <= rp : <NEWLINE> <INDENT> cp = ( lp + rp ) // 2 <NEWLINE> k1 = calc_k ( cp , ws ) <NEWLINE> if k1 <= k : <NEWLINE> <COMMENT> <NL> <INDENT> k2 = calc_k ( cp - 1 , ws ) <NEWLINE> if k2 == None or k2 > k : <NEWLINE> <COMMENT> <NL> <INDENT> return cp <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> rp = cp - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> lp = cp + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ws = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ws . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( search_minimum_p ( k , ws ) ) <NEWLINE>
import bisect <NEWLINE> primes = [ 0 , 0 ] + [ 1 ] * 49999 <NEWLINE> for i in range ( 2 , 224 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 50001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> values = [ i for i , k in enumerate ( primes ) if k ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> I = bisect . bisect ( values , n // 2 ) <NEWLINE> print ( len ( [ 1 for v in values [ : I ] if primes [ n - v ] ] ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> S = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( L ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> copyan = an [ : ] <NEWLINE> i = copyan [ 0 ] <NEWLINE> copyan [ 0 ] = 10 ** 6 <NEWLINE> movecount = 1 <NEWLINE> <NL> if i != 1 : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> memo = i <NEWLINE> if k == movecount : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> exit ( ) <NEWLINE> <DEDENT> i = copyan [ i - 1 ] <NEWLINE> <NL> if i >= 300000 : <NEWLINE> <INDENT> yokei = i % ( 10 ** 6 ) <NEWLINE> break <NEWLINE> <DEDENT> copyan [ memo - 1 ] = 10 ** 6 + movecount <NEWLINE> movecount += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> roopnum = movecount - yokei <NEWLINE> x = ( k - yokei ) % roopnum <NEWLINE> <NL> ans = copyan . index ( 10 ** 6 + yokei + x ) + 1 <NEWLINE> print ( ans ) <NEWLINE>
N = eval ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = [ eval ( item ) for item in input ( ) . split ( ) ] <NEWLINE> if abs ( x1 - x2 ) < 1e-10 or abs ( x3 - x4 ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> if abs ( x1 - x2 ) < 1e-10 and abs ( x3 - x4 ) < 1e-10 else <STRING> ) <NEWLINE> <DEDENT> elif abs ( ( y1 - y2 ) / ( x1 - x2 ) - ( y3 - y4 ) / ( x3 - x4 ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> INFTY = 1e9 + 1 <NEWLINE> <NL> <NL> def merge ( a , l , m , r ) : <NEWLINE> <INDENT> global cnt <NEWLINE> ll = deque ( a [ l : m ] ) <NEWLINE> rl = deque ( a [ m : r ] ) <NEWLINE> for k in range ( l , r ) : <NEWLINE> <INDENT> if not rl or ll and ll [ 0 ] < rl [ 0 ] : <NEWLINE> <INDENT> a [ k ] = ll . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = rl . popleft ( ) <NEWLINE> cnt += len ( ll ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( a , l , r ) : <NEWLINE> <INDENT> if l + 1 < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> merge_sort ( a , l , m ) <NEWLINE> merge_sort ( a , m , r ) <NEWLINE> merge ( a , l , m , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , a , cnt = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , 0 <NEWLINE> merge_sort ( a , 0 , n ) <NEWLINE> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for v in itertools . combinations_with_replacement ( list ( range ( 1 , k + 1 ) ) , 3 ) : <NEWLINE> <INDENT> a , b , c = v <NEWLINE> x = x + math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> y = 0 <NEWLINE> for v in itertools . combinations ( list ( range ( 1 , k + 1 ) ) , 3 ) : <NEWLINE> <INDENT> a , b , c = v <NEWLINE> y = y + math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> z = k * ( 1 + k ) / 2 <NEWLINE> print ( int ( 3 * x + y * 3 - 2 * z ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ a ] += b <NEWLINE> <NL> <DEDENT> v = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> v += ans [ i ] <NEWLINE> if ans [ i ] == 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> if v >= k : <NEWLINE> <INDENT> a = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import itertools <NEWLINE> <COMMENT> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> nums = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> count = 0 <NEWLINE> inp = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> I = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inp . append ( I ) <NEWLINE> <NL> <DEDENT> for v in itertools . combinations_with_replacement ( nums , N ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> v = list ( v ) <NEWLINE> for i in inp : <NEWLINE> <NL> <INDENT> if v [ i [ 1 ] - 1 ] - v [ i [ 0 ] - 1 ] == i [ 2 ] : <NEWLINE> <INDENT> c += i [ 3 ] <NEWLINE> <DEDENT> <DEDENT> count = max ( count , c ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for m in range ( 1000 ) : <NEWLINE> <INDENT> m = str ( m ) . zfill ( 3 ) <NEWLINE> j = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> if i not in s [ j : ] : break <NEWLINE> j += s [ j : ] . index ( i ) + 1 <NEWLINE> <DEDENT> else : cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> E = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> E . append ( ( P [ i ] + 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> tnt = sum ( E [ : K ] ) <NEWLINE> ans = tnt <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> tnt = tnt + E [ K + i ] - E [ i ] <NEWLINE> ans = max ( ans , tnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ 0 ] * N <NEWLINE> k = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> lis [ i - 1 ] = k <NEWLINE> k += 1 <NEWLINE> <DEDENT> lis = map ( str , lis ) <NEWLINE> ans = <STRING> . join ( lis ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> newP = P [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> newP = ( min ( newP , P [ i ] ) ) <NEWLINE> if newP == P [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> i = float ( input ( ) ) <NEWLINE> print ( i ** 2 * math . pi , i * 2 * math . pi ) <NEWLINE>
r , g , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> times = int ( input ( ) ) <NEWLINE> <NL> def check ( r , g , b , times ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if b > g > r : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif b <= g : <NEWLINE> <INDENT> times -= 1 <NEWLINE> b *= 2 <NEWLINE> <DEDENT> elif g <= r : <NEWLINE> <INDENT> times -= 1 <NEWLINE> g *= 2 <NEWLINE> <DEDENT> if times < 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( check ( r , g , b , times ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> m = s . count ( <STRING> ) <NEWLINE> p = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> p += ( n - m ) - ( i ) <NEWLINE> m -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> c = A - K <NEWLINE> d = B <NEWLINE> <DEDENT> elif A == 0 and B >= K : <NEWLINE> <INDENT> c = 0 <NEWLINE> d = B - K <NEWLINE> <DEDENT> elif A + B <= K : <NEWLINE> <INDENT> c = 0 <NEWLINE> d = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = B - ( K - A ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> print ( str ( c ) + <STRING> + str ( d ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a = sorted ( a ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> <NL> sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> <NL> def dfs ( u , prev ) : <NEWLINE> <INDENT> global post_order , pre_order <NEWLINE> <NL> pre_order . append ( ( u , prev ) ) <NEWLINE> for w , t in edges [ u ] : <NEWLINE> <INDENT> if t != prev : <NEWLINE> <INDENT> dfs ( t , u ) <NEWLINE> <DEDENT> <DEDENT> post_order . append ( u ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> edges = [ set ( ) for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ s ] . add ( ( w , t ) ) <NEWLINE> edges [ t ] . add ( ( w , s ) ) <NEWLINE> <NL> <DEDENT> post_order , pre_order = [ ] , [ ] <NEWLINE> farthest = [ { } for _ in range ( n ) ] <NEWLINE> height = [ 0 ] * n <NEWLINE> <NL> if n > 1 : <NEWLINE> <INDENT> dfs ( 0 , None ) <NEWLINE> <NL> <DEDENT> for i in post_order : <NEWLINE> <INDENT> for w , t in edges [ i ] : <NEWLINE> <INDENT> farthest [ i ] [ t ] = w + max ( ( d for tt , d in farthest [ t ] . items ( ) if tt != i ) , default = 0 ) <NEWLINE> <DEDENT> <DEDENT> for i , parent in pre_order : <NEWLINE> <INDENT> sorted_farthest = sorted ( farthest [ i ] . items ( ) , key = itemgetter ( 1 ) ) <NEWLINE> max_t , max_d = sorted_farthest . pop ( ) <NEWLINE> height [ i ] = max_d <NEWLINE> for w , t in edges [ i ] : <NEWLINE> <INDENT> if t == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> farthest [ t ] [ i ] = w + ( ( max_d if t != max_t else sorted_farthest [ - 1 ] [ 1 ] ) if sorted_farthest else 0 ) <NEWLINE> <DEDENT> <DEDENT> for h in height : <NEWLINE> <INDENT> print ( h ) <NEWLINE> <DEDENT>
from itertools import permutations as P <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) [ : 4 ] <NEWLINE> p = [ int ( <STRING> . join ( map ( str , v ) ) ) for v in list ( P ( a , 2 ) ) ] <NEWLINE> print ( sorted ( p ) [ 2 ] ) <NEWLINE>
import sys <COMMENT> <NEWLINE> sys . setrecursionlimit ( 500 * 500 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cost = [ 0 ] * n <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> edge [ a ] . append ( b ) <NEWLINE> edge [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> cost [ p - 1 ] += x <NEWLINE> <NL> <NL> <DEDENT> visited = [ - 1 ] * n <NEWLINE> <NL> <NL> def dfs ( n , c ) : <NEWLINE> <NL> <INDENT> cost [ n ] += c <NEWLINE> tmp = cost [ n ] <NEWLINE> visited [ n ] = 0 <NEWLINE> <NL> for v in edge [ n ] : <NEWLINE> <INDENT> if visited [ v ] == - 1 : <NEWLINE> <INDENT> dfs ( v , tmp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> <NL> print ( * cost ) <NEWLINE>
def calc ( i , j , B1 , len_b ) : <NEWLINE> <INDENT> extra = 0 <NEWLINE> d = j - i <NEWLINE> <NL> <COMMENT> <NL> k1 = d + j <NEWLINE> if k1 < len_b : <NEWLINE> <INDENT> extra += B1 [ k1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> k2 = i - d <NEWLINE> if 0 <= k2 and k2 < len_b : <NEWLINE> <INDENT> extra += B1 [ k2 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> s = i + j <NEWLINE> if s % 2 == 0 : <NEWLINE> <INDENT> k3 = s // 2 <NEWLINE> if k3 < len_b : <NEWLINE> <INDENT> extra += B1 [ k3 ] <NEWLINE> <DEDENT> <DEDENT> return extra <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R , G , B = [ ] , [ ] , [ ] <NEWLINE> num_r , num_g , num_b = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> num_r += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> num_g += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> num_b += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( R ) == 0 or len ( G ) == 0 or len ( B ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> len_b = ( B [ - 1 ] + 1 ) <NEWLINE> B1 = [ 0 ] * len_b <NEWLINE> for b in B : <NEWLINE> <INDENT> B1 [ b ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> ans += num_b <NEWLINE> if i < j : <NEWLINE> <INDENT> ans -= calc ( i , j , B1 , len_b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= calc ( j , i , B1 , len_b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> A = [ I ( ) for _ in range ( N ) ] <NEWLINE> <NL> is_ok = True <NEWLINE> <NL> <COMMENT> <NL> if [ A [ i ] for i in range ( N ) if A [ i ] > i ] : <NEWLINE> <INDENT> is_ok = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] + 1 < A [ i + 1 ] : <NEWLINE> <INDENT> is_ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if is_ok : <NEWLINE> <COMMENT> <NL> <INDENT> ans = 0 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <DEDENT> <DEDENT> ans += A [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if is_ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> mojiretsu = list ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> for b in mojiretsu : <NEWLINE> <INDENT> a += int ( b ) <NEWLINE> <NL> <NL> <DEDENT> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> def calc ( x ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> if x <= 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n // x == n % x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += calc ( n // i ) + calc ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> from math import pi <NEWLINE> <NL> radius = float ( input ( ) ) <NEWLINE> r = radius <NEWLINE> <NL> area = r * r * pi <NEWLINE> circumference = 2 * r * pi <NEWLINE> print ( area , end = <STRING> ) <NEWLINE> print ( circumference ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> from functools import lru_cache <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> <NL> @ lru_cache ( maxsize = None ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return f ( x % bin ( x ) . count ( <STRING> ) ) + 1 <NEWLINE> <NL> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> X = readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> X_ = int ( X , 2 ) <NEWLINE> X_cnt = X . count ( <STRING> ) <NEWLINE> p1 = X_ % ( X_cnt + 1 ) <NEWLINE> m1 = X_ % ( X_cnt - 1 ) if X_cnt > 1 else 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> cnt = X_cnt + 1 <NEWLINE> acc = ( p1 + pow ( 2 , N - i - 1 , cnt ) ) % cnt <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> cnt = X_cnt - 1 <NEWLINE> if cnt == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> acc = ( m1 - pow ( 2 , N - i - 1 , cnt ) ) % cnt <NEWLINE> <DEDENT> print ( f ( acc ) + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <COMMENT> <NL> a_max = A [ - 1 ] <NEWLINE> dp = [ True ] * ( a_max + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> p = A [ i ] <NEWLINE> if dp [ p ] == True : <NEWLINE> <COMMENT> <NL> <INDENT> for q in range ( a_max // p + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ p * q ] = False <NEWLINE> <DEDENT> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ A [ - 1 ] ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import heapq <NEWLINE> from collections import namedtuple <NEWLINE> inf = float ( <STRING> ) <NEWLINE> Node = namedtuple ( <STRING> , <STRING> ) <NEWLINE> <NL> def debug ( x , table ) : <NEWLINE> <INDENT> for name , val in table . items ( ) : <NEWLINE> <INDENT> if x is val : <NEWLINE> <INDENT> print ( <STRING> . format ( name , val ) , file = sys . stderr ) <NEWLINE> return None <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def SSSP ( n , Adj ) : <NEWLINE> <INDENT> d = [ inf ] * n <NEWLINE> p = [ - 1 ] * n <NEWLINE> checked = [ False ] * n <NEWLINE> d [ 0 ] = 0 <NEWLINE> checked [ 0 ] = True <NEWLINE> heap = [ Node ( d [ 0 ] , 0 ) ] <NEWLINE> <NL> while heap : <NEWLINE> <INDENT> u = heapq . heappop ( heap ) <NEWLINE> <NL> if d [ u . no ] < u . d : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> checked [ u . no ] = True <NEWLINE> <NL> for v , cost in Adj [ u . no ] : <NEWLINE> <INDENT> if not checked [ v ] and d [ u . no ] + cost < d [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u . no ] + cost <NEWLINE> p [ v ] = u . no <NEWLINE> heapq . heappush ( heap , Node ( d [ v ] , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> Adj = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> u , k , * line = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> Adj [ u ] . append ( ( line [ 2 * j ] , line [ 2 * j + 1 ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> d = SSSP ( n , Adj ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( i , d [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prod = 1 <NEWLINE> a = 10 ** 18 <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for k in range ( K ) : <NEWLINE> <INDENT> prod = prod * s [ k ] <NEWLINE> if prod > a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X , Y , C = [ ] , [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y , c = input ( ) . split ( ) <NEWLINE> X . append ( int ( x ) % ( 2 * k ) ) <NEWLINE> Y . append ( int ( y ) % ( 2 * k ) ) <NEWLINE> C . append ( c == <STRING> ) <NEWLINE> <DEDENT> G = [ [ 0 ] * k for _ in range ( k ) ] <NEWLINE> cnt = 0 <NEWLINE> for x , y , c in zip ( X , Y , C ) : <NEWLINE> <INDENT> if ( x >= k and y < k ) or ( x < k and y >= k ) : <NEWLINE> <INDENT> x += k <NEWLINE> c ^= 1 <NEWLINE> <DEDENT> x %= k <NEWLINE> y %= k <NEWLINE> G [ x ] [ y ] += ( - 1 ) ** c <NEWLINE> cnt += c <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k - 1 ) : <NEWLINE> <INDENT> G [ i ] [ j + 1 ] += G [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> for i in range ( k - 1 ) : <NEWLINE> <INDENT> G [ i + 1 ] [ j ] += G [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> temp = G [ k - 1 ] [ k - 1 ] - G [ i ] [ k - 1 ] - G [ k - 1 ] [ j ] + G [ i ] [ j ] * 2 + cnt <NEWLINE> ans = max ( ans , temp , n - temp ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <NL> <INDENT> n , a , b , c , x = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if n == 0 and a == 0 and b == 0 and c == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> y = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while ans <= 10000 : <NEWLINE> <INDENT> if x == y [ i ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> if i == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = ( a * x + b ) % c <NEWLINE> ans += 1 <NEWLINE> <DEDENT> if ans >= 10001 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> maxq = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxq = b - 1 <NEWLINE> <NL> <DEDENT> ans = a * maxq // b <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <NL> <DEDENT> elif K % 2 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> j = 0 <NEWLINE> i = N - 1 <NEWLINE> for _ in range ( K // 2 ) : <NEWLINE> <INDENT> if A [ j ] * A [ j + 1 ] > A [ i ] * A [ i - 1 ] : <NEWLINE> <INDENT> ans *= A [ j ] * A [ j + 1 ] <NEWLINE> ans %= mod <NEWLINE> j += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ i ] * A [ i - 1 ] <NEWLINE> ans %= mod <NEWLINE> i -= 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <DEDENT> elif A [ - 1 ] < 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ - ( i + 1 ) ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ - 1 ] <NEWLINE> j = 0 <NEWLINE> i = N - 2 <NEWLINE> for _ in range ( K // 2 ) : <NEWLINE> <INDENT> if A [ j ] * A [ j + 1 ] > A [ i ] * A [ i - 1 ] : <NEWLINE> <INDENT> ans *= A [ j ] * A [ j + 1 ] <NEWLINE> ans %= mod <NEWLINE> j += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ i ] * A [ i - 1 ] <NEWLINE> ans %= mod <NEWLINE> i -= 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> ans = abs ( b - a ) - ( v - w ) * t <NEWLINE> if ans > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> dp = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i + 1 < H and maze [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] += dp [ i ] [ j ] % mod <NEWLINE> <DEDENT> if j + 1 < W and maze [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j + 1 ] += dp [ i ] [ j ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ H - 1 ] [ W - 1 ] % mod ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import copy <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> n = int ( readline ( ) ) <NEWLINE> arr = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> arr2 = copy . copy ( arr ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> arr2 [ i ] = ( arr2 [ i ] + arr2 [ i - 1 ] ) % mod <NEWLINE> <DEDENT> base = arr2 [ n - 1 ] + mod <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans = ( ans + arr [ i ] * ( ( base - arr2 [ i ] ) % mod ) ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> MAP = [ list ( input ( ) . strip ( ) ) for i in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if MAP [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> MAP [ i ] [ j ] = 1 << 30 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAP [ i ] [ j ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> Q = deque ( ) <NEWLINE> Q . append ( ( x1 - 1 , y1 - 1 ) ) <NEWLINE> MAP [ x1 - 1 ] [ y1 - 1 ] = 0 <NEWLINE> <NL> while Q : <NEWLINE> <INDENT> x , y = Q . pop ( ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if 0 <= x + i < H and 0 <= y < W and ( MAP [ x + i ] [ y ] == 1 << 30 or MAP [ x + i ] [ y ] > MAP [ x ] [ y ] ) : <NEWLINE> <INDENT> if MAP [ x + i ] [ y ] == 1 << 30 : <NEWLINE> <INDENT> MAP [ x + i ] [ y ] = MAP [ x ] [ y ] + 1 <NEWLINE> Q . appendleft ( ( x + i , y ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if 0 <= x - i < H and 0 <= y < W and ( MAP [ x - i ] [ y ] == 1 << 30 or MAP [ x - i ] [ y ] > MAP [ x ] [ y ] ) : <NEWLINE> <INDENT> if MAP [ x - i ] [ y ] == 1 << 30 : <NEWLINE> <INDENT> MAP [ x - i ] [ y ] = MAP [ x ] [ y ] + 1 <NEWLINE> Q . appendleft ( ( x - i , y ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if 0 <= x < H and 0 <= y + i < W and ( MAP [ x ] [ y + i ] == 1 << 30 or MAP [ x ] [ y + i ] > MAP [ x ] [ y ] ) : <NEWLINE> <INDENT> if MAP [ x ] [ y + i ] == 1 << 30 : <NEWLINE> <INDENT> MAP [ x ] [ y + i ] = MAP [ x ] [ y ] + 1 <NEWLINE> Q . appendleft ( ( x , y + i ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if 0 <= x < H and 0 <= y - i < W and ( MAP [ x ] [ y - i ] == 1 << 30 or MAP [ x ] [ y - i ] > MAP [ x ] [ y ] ) : <NEWLINE> <INDENT> if MAP [ x ] [ y - i ] == 1 << 30 : <NEWLINE> <INDENT> MAP [ x ] [ y - i ] = MAP [ x ] [ y ] + 1 <NEWLINE> Q . appendleft ( ( x , y - i ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if MAP [ x2 - 1 ] [ y2 - 1 ] == 1 << 30 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( MAP [ x2 - 1 ] [ y2 - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> Nlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> <NL> if Nlist . count ( 0 ) >= 1 : <NEWLINE> <INDENT> total = 0 <NEWLINE> print ( total ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> total = total * Nlist [ i ] <NEWLINE> if total > 1000000000000000000 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> from math import * <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> if ( k % 2 == 0 or k % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> num = 7 % k <NEWLINE> while ( num > 0 ) : <NEWLINE> <INDENT> num = ( ( num * 10 ) + 7 ) % k <NEWLINE> ans = ans + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import string <NEWLINE> import sys <NEWLINE> from itertools import chain , dropwhile , takewhile <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def read ( <NEWLINE> <INDENT> * shape , f = int , it = chain . from_iterable ( sys . stdin ) , whitespaces = set ( string . whitespace ) <NEWLINE> <DEDENT> ) : <NEWLINE> <INDENT> def read_word ( ) : <NEWLINE> <INDENT> w = lambda c : c in whitespaces <NEWLINE> nw = lambda c : c not in whitespaces <NEWLINE> return f ( <STRING> . join ( takewhile ( nw , dropwhile ( w , it ) ) ) ) <NEWLINE> <NL> <DEDENT> if not shape : <NEWLINE> <INDENT> return read_word ( ) <NEWLINE> <DEDENT> elif len ( shape ) == 1 : <NEWLINE> <INDENT> return [ read_word ( ) for _ in range ( shape [ 0 ] ) ] <NEWLINE> <DEDENT> elif len ( shape ) == 2 : <NEWLINE> <INDENT> return [ [ read_word ( ) for _ in range ( shape [ 1 ] ) ] for _ in range ( shape [ 0 ] ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def readi ( * shape ) : <NEWLINE> <INDENT> return read ( * shape ) <NEWLINE> <NL> <NL> <DEDENT> def readi1 ( * shape ) : <NEWLINE> <INDENT> return [ i - 1 for i in readi ( * shape ) ] <NEWLINE> <NL> <NL> <DEDENT> def readf ( * shape ) : <NEWLINE> <INDENT> return read ( * shape , f = float ) <NEWLINE> <NL> <NL> <DEDENT> def reads ( * shape ) : <NEWLINE> <INDENT> return read ( * shape , f = str ) <NEWLINE> <NL> <NL> <DEDENT> def arr ( * shape , fill_value = 0 ) : <NEWLINE> <INDENT> if len ( shape ) == 1 : <NEWLINE> <INDENT> return [ fill_value ] * shape [ 0 ] <NEWLINE> <DEDENT> elif len ( shape ) == 2 : <NEWLINE> <INDENT> return [ [ fill_value ] * shape [ 1 ] for _ in range ( shape [ 0 ] ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dbg ( ** kwargs ) : <NEWLINE> <INDENT> print ( <NEWLINE> <INDENT> <STRING> . join ( <STRING> . format ( k , repr ( v ) ) for k , v in kwargs . items ( ) ) , <NEWLINE> file = sys . stderr , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , W = readi ( 2 ) <NEWLINE> vs , ws = zip ( * readi ( N , 2 ) ) <NEWLINE> dp = arr ( N + 1 , W + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> if j - ws [ i ] >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = max ( <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] , dp [ i ] [ j - ws [ i ] ] + vs [ i ] , dp [ i + 1 ] [ j - ws [ i ] ] + vs [ i ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> if s [ a ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> s [ a ] = 1 <NEWLINE> if not <STRING> in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
R , G , B , n = map ( int , input ( ) . split ( ) ) <NEWLINE> r = n // R <NEWLINE> g = n // G <NEWLINE> b = n // B <NEWLINE> ans = 0 <NEWLINE> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( ( n - R * i ) // G + 1 ) : <NEWLINE> <INDENT> if ( n - i * R - j * G ) % B == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> if a == i : <NEWLINE> <INDENT> if i != len ( A ) : <NEWLINE> <INDENT> x = A [ i - 1 ] <NEWLINE> y = A [ i ] <NEWLINE> A [ i - 1 ] = y <NEWLINE> A [ i ] = x <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = A [ i - 2 ] <NEWLINE> y = A [ i - 1 ] <NEWLINE> A [ i - 2 ] = y <NEWLINE> A [ i - 1 ] = x <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if a [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ 0 ] > 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> pre_no_ha = 1 <NEWLINE> all_ha = sum ( a ) <NEWLINE> <NL> for ai in a [ 1 : ] : <NEWLINE> <INDENT> if pre_no_ha <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ai > pre_no_ha * 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pre_no_ha *= 2 <NEWLINE> pre_no_ha -= ai <NEWLINE> all_ha -= ai <NEWLINE> pre_no_ha = min ( pre_no_ha , all_ha ) <NEWLINE> ans += pre_no_ha + ai <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = n [ 1 ] * n [ 3 ] <NEWLINE> ans = max ( n [ 0 ] * n [ 2 ] , ans ) <NEWLINE> ans = max ( n [ 0 ] * n [ 3 ] , ans ) <NEWLINE> ans = max ( n [ 1 ] * n [ 2 ] , ans ) <NEWLINE> ans = max ( n [ 1 ] * n [ 3 ] , ans ) <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> L [ A - 1 ] . append ( B - 1 ) <NEWLINE> L [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> ans = [ 0 ] * N <NEWLINE> visit = [ 0 ] * N <NEWLINE> visit [ 0 ] = 1 <NEWLINE> from queue import Queue <NEWLINE> q = Queue ( ) <NEWLINE> q . put ( 0 ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> current = q . get ( ) <NEWLINE> for a in L [ current ] : <NEWLINE> <INDENT> if visit [ a ] == 0 : <NEWLINE> <INDENT> visit [ a ] = visit [ current ] + 1 <NEWLINE> ans [ a ] = current + 1 <NEWLINE> q . put ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if visit [ a ] > visit [ current ] + 1 : <NEWLINE> <INDENT> visit [ a ] = visit [ current ] + 1 <NEWLINE> ans [ a ] = current + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> flag = True <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ans [ i ] == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
from math import * <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> g = gcd ( a , b ) <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> if s [ a // g * i ] != t [ b // g * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a * b // g ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . r = [ - 1 ] * ( N + 1 ) <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if ( self . r [ x ] < 0 ) : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . r [ x ] = self . root ( self . r [ x ] ) <NEWLINE> return self . r [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . r [ x ] > self . r [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . r [ x ] += self . r [ y ] <NEWLINE> self . r [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . r [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda i : int ( i ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . unite ( A , B ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
fact = [ 1 for _ in range ( 200000 ) ] <NEWLINE> inv = [ 1 for _ in range ( 200000 ) ] <NEWLINE> fact_inv = [ 1 for _ in range ( 200000 ) ] <NEWLINE> <NL> mod = 998244353 <NEWLINE> for i in range ( 2 , 200000 ) : <NEWLINE> <INDENT> fact [ i ] = ( fact [ i - 1 ] * i ) % mod <NEWLINE> inv [ i ] = mod - ( inv [ mod % i ] * ( mod // i ) ) % mod <NEWLINE> fact_inv [ i ] = ( fact_inv [ i - 1 ] * inv [ i ] ) % mod <NEWLINE> <NL> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> a = pow ( M - 1 , N - 1 - K , mod ) <NEWLINE> for i in range ( K , - 1 , - 1 ) : <NEWLINE> <INDENT> ans += ( fact [ N - 1 ] * fact_inv [ i ] * fact_inv [ N - 1 - i ] ) * M * a <NEWLINE> ans = ans % mod <NEWLINE> a *= M - 1 <NEWLINE> a = a % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> search = [ ( <STRING> + str ( s ) ) [ - 3 : ] for s in range ( 0 , 1000 ) ] <NEWLINE> <NL> for v in search : <NEWLINE> <INDENT> tmp = s <NEWLINE> if v [ 0 ] in tmp : <NEWLINE> <INDENT> tmp = tmp [ tmp . index ( v [ 0 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v [ 1 ] in tmp : <NEWLINE> <INDENT> tmp = tmp [ tmp . index ( v [ 1 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v [ 2 ] in tmp : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> j = ( i - 1 ) // 2 <NEWLINE> print ( 1 + j , M + 1 - j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = ( i - 2 ) // 2 <NEWLINE> print ( M + 2 + j , 2 * M + 1 - j ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> s0 = A [ 0 ] <NEWLINE> <NL> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> s1 = A [ K + i ] <NEWLINE> if s1 > s0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> s0 = A [ i + 1 ] <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> from sys import stdin , stdout <NEWLINE> <NL> readline = stdin . readline <NEWLINE> write = stdout . write <NEWLINE> <NL> def dist2 ( x0 , y0 , z0 , x1 , y1 , z1 ) : <NEWLINE> <INDENT> return ( x0 - x1 ) ** 2 + ( y0 - y1 ) ** 2 + ( z0 - z1 ) ** 2 <NEWLINE> <DEDENT> def dot ( x0 , y0 , z0 , x1 , y1 , z1 ) : <NEWLINE> <INDENT> return x0 * x1 + y0 * y1 + z0 * z1 <NEWLINE> <DEDENT> def cross2 ( x0 , y0 , z0 , x1 , y1 , z1 ) : <NEWLINE> <INDENT> return ( y0 * z1 - y1 * z0 ) ** 2 + ( z0 * x1 - z1 * x0 ) ** 2 + ( x0 * y1 - x1 * y0 ) ** 2 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> N , M , R = map ( int , readline ( ) . split ( ) ) <NEWLINE> if N == M == R == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> T = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> ex , ey , ez = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = [ ( sx - ex , sy - ey , sz - ez , sr ) for sx , sy , sz , sr in S ] <NEWLINE> T = [ ( tx - ex , ty - ey , tz - ez , tb ) for tx , ty , tz , tb in T ] <NEWLINE> L = [ tb / ( tx ** 2 + ty ** 2 + tz ** 2 ) for tx , ty , tz , tb in T ] <NEWLINE> <NL> rem = [ 0 ] * M <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> tx , ty , tz , tb = T [ i ] <NEWLINE> ld = tx ** 2 + ty ** 2 + tz ** 2 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> sx , sy , sz , sr = S [ j ] <NEWLINE> sr2 = sr ** 2 <NEWLINE> ok = 1 <NEWLINE> dd1 = ( sx ** 2 + sy ** 2 + sz ** 2 <= sr2 ) <NEWLINE> dd2 = ( dist2 ( sx , sy , sz , tx , ty , tz ) <= sr2 ) <NEWLINE> if dd1 ^ dd2 : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> elif dd1 == dd2 == 0 : <NEWLINE> <INDENT> if ( cross2 ( sx , sy , sz , tx , ty , tz ) <= sr2 * ld ) : <NEWLINE> <INDENT> if ( dot ( sx , sy , sz , tx , ty , tz ) >= 0 and <NEWLINE> <INDENT> dot ( tx - sx , ty - sy , tz - sz , tx , ty , tz ) >= 0 ) : <NEWLINE> ok = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not ok : <NEWLINE> <INDENT> rem [ i ] |= 1 << j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for P in product ( [ 0 , 1 ] , repeat = M ) : <NEWLINE> <INDENT> need = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if P [ i ] : need |= rem [ i ] <NEWLINE> <DEDENT> if bin ( need ) . count ( <STRING> ) <= R : <NEWLINE> <INDENT> ans = max ( ans , sum ( L [ i ] for i in range ( M ) if P [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> write ( <STRING> % ans ) <NEWLINE> <DEDENT>
w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( input ( ) ) for _ in range ( w ) ] <NEWLINE> q = [ int ( input ( ) ) for _ in range ( h ) ] <NEWLINE> p . sort ( reverse = True ) <NEWLINE> q . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> c , r = w + 1 , h + 1 <NEWLINE> while p or q : <NEWLINE> <INDENT> if q and ( not p or p [ - 1 ] > q [ - 1 ] ) : <NEWLINE> <INDENT> ans += q . pop ( ) * c <NEWLINE> r -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += p . pop ( ) * r <NEWLINE> c -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> c ^= i <NEWLINE> <NL> <DEDENT> buf = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> buf . append ( c ^ i ) <NEWLINE> <NL> <DEDENT> print ( * buf ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s *= a [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> num = 1 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> num *= a <NEWLINE> if num > 1E18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> <DEDENT>
input ( ) <NEWLINE> x = 1 <NEWLINE> l = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> x *= i <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> length = int ( n / 19 ) + 1 <NEWLINE> if n > 19 and n % 19 == 0 : <NEWLINE> <INDENT> length -= 1 <NEWLINE> <DEDENT> d = [ ] <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> d += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> start , end = 1 , 10 <NEWLINE> l = [ ] <NEWLINE> flag = False <NEWLINE> for j in range ( 1 , len ( d ) + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( d ) ) : <NEWLINE> <INDENT> tmp = <STRING> . join ( map ( str , d [ i : i + j ] ) ) <NEWLINE> if len ( tmp ) > 1 and tmp [ 0 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif len ( tmp ) == j : <NEWLINE> <INDENT> l . append ( int ( tmp ) ) <NEWLINE> <DEDENT> <DEDENT> l = sorted ( set ( l ) ) <NEWLINE> if start == 1 : <NEWLINE> <INDENT> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> if k not in l : <NEWLINE> <INDENT> print ( k ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( start , end ) : <NEWLINE> <INDENT> if k not in l : <NEWLINE> <INDENT> print ( k ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> start , end = start * 10 , end * 10 <NEWLINE> l = [ ] <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , m = nii ( ) <NEWLINE> l = [ lnii ( ) for i in range ( m ) ] <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> for a , b , in l : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if uf . same ( a , b ) == False : <NEWLINE> <INDENT> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> roots = uf . roots ( ) <NEWLINE> for i in uf . roots ( ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def insertionSort ( nums , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> i = g <NEWLINE> while i < n : <NEWLINE> <INDENT> v = nums [ i ] <NEWLINE> j = i - g <NEWLINE> while 0 <= j and v < nums [ j ] : <NEWLINE> <INDENT> nums [ j + g ] = nums [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> nums [ j + g ] = v <NEWLINE> i += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shellSort ( nums , n ) : <NEWLINE> <INDENT> g = [ ] <NEWLINE> val = 1 <NEWLINE> while val <= n : <NEWLINE> <INDENT> g . append ( val ) <NEWLINE> val = 3 * val + 1 <NEWLINE> <NL> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt += insertionSort ( nums , n , g [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nums . append ( int ( sys . stdin . readline ( ) ) ) <NEWLINE> <NL> <DEDENT> shellSort ( nums , n ) <NEWLINE> print ( <STRING> . join ( map ( str , nums ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sorted ( [ a - i for i , a in enumerate ( l , start = 1 ) ] ) <NEWLINE> b1 , b2 = m [ n // 2 ] , m [ n // 2 - 1 ] <NEWLINE> print ( min ( sum ( [ abs ( a - b1 ) for a in m ] ) , sum ( [ abs ( a - b2 ) for a in m ] ) ) ) <NEWLINE>
<NL> 2 <NEWLINE> 3 <NEWLINE> 4 <NEWLINE> 5 <NEWLINE> 6 <NEWLINE> 7 <NEWLINE> 8 <NEWLINE> 9 <NEWLINE> 10 <NEWLINE> 11 <NEWLINE> 12 <NEWLINE> 13 <NEWLINE> 14 <NEWLINE> 15 <NEWLINE> 16 <NEWLINE> 17 <NEWLINE> 18 <NEWLINE> from itertools import combinations <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mn = 10 ** 18 <NEWLINE> for B in combinations ( range ( 1 , N ) , K - 1 ) : <COMMENT> <NEWLINE> <INDENT> mx = A [ 0 ] <COMMENT> <NEWLINE> score = 0 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> if n in B : <COMMENT> <NEWLINE> <INDENT> if A [ n ] <= mx : <COMMENT> <NEWLINE> <INDENT> mx += 1 <NEWLINE> score += ( mx - A [ n ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> mx = A [ n ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mx = max ( mx , A [ n ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> mn = min ( mn , score ) <NEWLINE> <DEDENT> print ( mn ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = [ 0 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma [ a - 1 ] = max ( ma [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> ma [ b - 1 ] = max ( ma [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ma [ i ] < h [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x . sort ( ) <NEWLINE> if ( n >= m ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> dist = abs ( x [ - 1 ] - x [ 0 ] ) <NEWLINE> <NL> diff = [ ] <NEWLINE> <NL> for i in range ( m - 1 ) : <NEWLINE> <INDENT> diff . append ( [ abs ( x [ i ] - x [ i + 1 ] ) , i ] ) <NEWLINE> <NL> <DEDENT> diff . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> dist -= diff [ i ] [ 0 ] <NEWLINE> <DEDENT> print ( dist ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ x - 1 ] . append ( y - 1 ) <NEWLINE> <DEDENT> dp = [ - 1 ] * N <NEWLINE> <NL> def calc ( x ) : <NEWLINE> <INDENT> if dp [ x ] != - 1 : <NEWLINE> <INDENT> return dp [ x ] <NEWLINE> <DEDENT> if not len ( edge [ x ] ) : <NEWLINE> <INDENT> dp [ x ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> dp [ x ] = max ( [ calc ( i ) for i in edge [ x ] ] ) + 1 <NEWLINE> return dp [ x ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if dp [ i ] != - 1 : continue <NEWLINE> ans = max ( ans , calc ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
( n , k ) = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ [ 0 for i in range ( k ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( 0 , k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> for m in a : <NEWLINE> <INDENT> data [ m - 1 ] [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dd = [ ] <NEWLINE> <NL> for d in data : <NEWLINE> <INDENT> dd . append ( sum ( d ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for ddd in dd : <NEWLINE> <INDENT> if ddd == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = - 1 <NEWLINE> j = N <NEWLINE> while ( True ) : <NEWLINE> <NL> <INDENT> i += 1 <NEWLINE> while ( i < j ) : <NEWLINE> <INDENT> if ( C [ i ] == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> j -= 1 <NEWLINE> while ( j > i ) : <NEWLINE> <INDENT> if ( C [ j ] == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( i < j ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if X < min ( n ) or X > max ( n ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> key = min ( n ) - 1 <NEWLINE> Key = max ( n ) + 1 <NEWLINE> l = list ( range ( key , Key + 1 ) ) <NEWLINE> ll = [ x for x in l if x not in n ] <NEWLINE> ll . append ( X ) <NEWLINE> ll . sort ( ) <NEWLINE> i = ll . index ( X ) <NEWLINE> if abs ( X - ll [ i - 1 ] ) > abs ( X - ll [ i + 1 ] ) : <NEWLINE> <INDENT> print ( ll [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ll [ i - 1 ] ) <NEWLINE> <NL> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> <NL> dist1 = a [ 2 ] - a [ 0 ] <NEWLINE> dist2 = a [ 2 ] - a [ 1 ] <NEWLINE> <NL> if ( dist1 % 2 ) == 0 and ( dist2 % 2 ) == 0 : <NEWLINE> <INDENT> ans = ( dist1 + dist2 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> elif ( dist1 % 2 ) == 1 and ( dist2 % 2 ) == 1 : <NEWLINE> <INDENT> ans = ( dist1 + dist2 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> elif ( dist1 % 2 ) == 0 and ( dist2 % 2 ) == 1 : <NEWLINE> <INDENT> ans = ( dist1 // 2 ) + ( dist2 + 1 ) // 2 <NEWLINE> print ( ans + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = ( dist2 // 2 ) + ( dist1 + 1 ) // 2 <NEWLINE> print ( ans + 1 ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( n ) ] <NEWLINE> b = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> rst = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> rst += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( str ( rst ) ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> maximum = [ ( 0 , [ ( ) ] ) ] <NEWLINE> <NL> s = tuple ( s ) <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> j = i - 1 <NEWLINE> while j >= 0 : <NEWLINE> <INDENT> max_count , previous = maximum [ j ] <NEWLINE> if max_count < 0 : <NEWLINE> <INDENT> j -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> current = s [ j : i ] <NEWLINE> if any ( p != current for p in previous ) : <NEWLINE> <INDENT> if len ( maximum ) == i + 1 : <NEWLINE> <INDENT> mc , blocks = maximum [ i ] <NEWLINE> if mc == max_count + 1 : <NEWLINE> <INDENT> blocks . append ( current ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maximum . append ( ( max_count + 1 , [ current ] ) ) <NEWLINE> <DEDENT> <DEDENT> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( maximum ) != i + 1 : <NEWLINE> <INDENT> maximum . append ( ( - 1 , [ ] ) ) <NEWLINE> <DEDENT> <DEDENT> assert len ( maximum ) == i + 1 <NEWLINE> <NL> <DEDENT> print ( maximum [ - 1 ] [ 0 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> gcd = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> key = i * N + j <NEWLINE> gcd [ key ] = math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> for k , i in gcd . items ( ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> key = j * N + i <NEWLINE> ans += gcd [ key ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <COMMENT> <NEWLINE> <NL> s = [ 0 ] <COMMENT> <NEWLINE> for i in range ( 0 , N ) : <COMMENT> <NEWLINE> <INDENT> s . append ( s [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for j in range ( 0 , N ) : <COMMENT> <NEWLINE> <INDENT> sum += A [ j ] * ( s [ N ] - s [ j + 1 ] ) <NEWLINE> <NL> <DEDENT> ans = sum % MOD <COMMENT> <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> su = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = n // i <NEWLINE> l = t * i <NEWLINE> m = t / 2 <NEWLINE> su += m * ( i + l ) <NEWLINE> <DEDENT> print ( int ( su ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = float ( <STRING> ) <NEWLINE> L = L % 2019 <NEWLINE> R = R % 2019 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> res = min ( res , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = max ( A ) <NEWLINE> dp = [ True for _ in range ( MAX + 1 ) ] <NEWLINE> <NL> for a in set ( A ) : <NEWLINE> <INDENT> for k in range ( 2 * a , MAX + 1 , a ) : <NEWLINE> <INDENT> dp [ k ] = False <NEWLINE> <DEDENT> <DEDENT> B = sorted ( A ) <NEWLINE> for i in range ( len ( B ) - 1 ) : <NEWLINE> <INDENT> if B [ i ] == B [ i + 1 ] : <NEWLINE> <INDENT> dp [ B [ i ] ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( dp [ a ] for a in set ( A ) ) ) <NEWLINE>
def compare_cards ( a , b ) : <NEWLINE> <INDENT> return a [ 1 ] < b [ 1 ] <NEWLINE> <NL> <DEDENT> def bubble ( C ) : <NEWLINE> <INDENT> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> for j in range ( len ( C ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if compare_cards ( C [ j ] , C [ j - 1 ] ) : <NEWLINE> <INDENT> C [ j ] , C [ j - 1 ] = C [ j - 1 ] , C [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def selection ( C ) : <NEWLINE> <INDENT> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> mini = i <NEWLINE> for j in range ( i , len ( C ) ) : <NEWLINE> <INDENT> if compare_cards ( C [ j ] , C [ mini ] ) : <NEWLINE> <INDENT> mini = j <NEWLINE> <DEDENT> <DEDENT> C [ i ] , C [ mini ] = C [ mini ] , C [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def check_stable ( originC , sortedC ) : <NEWLINE> <INDENT> for i in range ( len ( originC ) - 1 ) : <NEWLINE> <INDENT> if not compare_cards ( sortedC [ i ] , sortedC [ i + 1 ] ) : <NEWLINE> <INDENT> if originC . index ( sortedC [ i ] ) > originC . index ( sortedC [ i + 1 ] ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> C = input ( ) . split ( ) <NEWLINE> <NL> bubbleC = list ( C ) <NEWLINE> selectionC = list ( C ) <NEWLINE> <NL> bubble ( bubbleC ) <NEWLINE> selection ( selectionC ) <NEWLINE> <NL> print ( * bubbleC ) <NEWLINE> print ( check_stable ( C , bubbleC ) ) <NEWLINE> print ( * selectionC ) <NEWLINE> print ( check_stable ( C , selectionC ) ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( c , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> INF = 1 << 29 <NEWLINE> lINF = 1 << 35 <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = readInt ( ) <NEWLINE> a = readInt ( ) <NEWLINE> pos = 0 <NEWLINE> visit = [ 0 ] * n <NEWLINE> move = [ ] <NEWLINE> roop = [ ] <NEWLINE> while visit [ pos ] != 2 : <NEWLINE> <INDENT> if visit [ pos ] == 0 : <NEWLINE> <INDENT> move . append ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop . append ( pos ) <NEWLINE> <DEDENT> visit [ pos ] += 1 <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> <DEDENT> num = 0 <NEWLINE> if len ( move ) > k : <NEWLINE> <INDENT> print ( move [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( k - ( len ( move ) - len ( roop ) ) ) % len ( roop ) <NEWLINE> print ( roop [ num ] + 1 ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( collections . Counter ( S ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kiseki = [ - 1 ] * n <NEWLINE> i = 0 <NEWLINE> v = 1 <NEWLINE> while kiseki [ v - 1 ] == - 1 : <NEWLINE> <INDENT> kiseki [ v - 1 ] = i <NEWLINE> v = l [ v - 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> saisyo = kiseki [ v - 1 ] <NEWLINE> kuri = i - saisyo <NEWLINE> <NL> if saisyo > k : <NEWLINE> <INDENT> print ( kiseki . index ( k ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari = ( k - saisyo ) % kuri <NEWLINE> print ( kiseki . index ( amari + saisyo ) + 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> A . sort ( ) <NEWLINE> A = deque ( A ) <NEWLINE> BC . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> fin = False <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> if fin == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = 0 <NEWLINE> while i < BC [ m ] [ 0 ] : <NEWLINE> <INDENT> if A : <NEWLINE> <INDENT> if BC [ m ] [ 1 ] >= A [ 0 ] : <NEWLINE> <INDENT> ans += BC [ m ] [ 1 ] <NEWLINE> A . popleft ( ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += sum ( A ) <NEWLINE> fin = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> fin = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if fin == False and A : <NEWLINE> <INDENT> ans += sum ( A ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> l = [ str ( 0 ) for i in range ( n ) ] <NEWLINE> key = list ( c . keys ( ) ) <NEWLINE> for i in range ( len ( list ( c . keys ( ) ) ) ) : <NEWLINE> <INDENT> l [ key [ i ] - 1 ] = str ( c [ key [ i ] ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE>
def search ( l , n ) : <NEWLINE> <INDENT> l = l . copy ( ) <NEWLINE> l . append ( n ) <NEWLINE> i = 0 <NEWLINE> while l [ i ] != n : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> if i == len ( l ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> s = set ( s ) <NEWLINE> ans = 0 <NEWLINE> for ti in t : <NEWLINE> <INDENT> if ti in s : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> A = [ ( i ** 5 ) for i in range ( 0 , 1000 ) ] <NEWLINE> res = [ ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> b = - A [ j ] <NEWLINE> cal = a - b <NEWLINE> cal2 = a + b <NEWLINE> if cal == X : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif cal2 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> L = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import bisect <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> limit = L [ i ] + L [ j ] <NEWLINE> ok = bisect . bisect_left ( L , limit ) <NEWLINE> <COMMENT> <NL> ans += ok - 1 - j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> T = T // math . gcd ( T , t ) * t <NEWLINE> <DEDENT> print ( T ) <NEWLINE>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> m = 0 <NEWLINE> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> if m < a : <NEWLINE> <INDENT> s = m <NEWLINE> m = a <NEWLINE> <DEDENT> elif s < a : <NEWLINE> <INDENT> s = a <NEWLINE> <NL> <DEDENT> <DEDENT> c = [ ] <NEWLINE> mL = 0 <NEWLINE> mR = 0 <NEWLINE> <COMMENT> <NL> <NL> <NL> for i , a in enumerate ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a == m : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> rt = { } <NEWLINE> clist = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> id , k , * c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in c : <NEWLINE> <INDENT> rt [ j ] = id <NEWLINE> <DEDENT> clist [ id ] = c <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> p = [ i ] <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> p . append ( rt [ p [ - 1 ] ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( p ) == 1 : <NEWLINE> <INDENT> print ( <STRING> , clist [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % p [ 1 ] , len ( p ) - 1 , end = <STRING> ) <NEWLINE> if clist [ i ] == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , clist [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> INF = int ( 1e18 ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( A [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > INF ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> import collections <NEWLINE> <NL> from math import gcd <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <STRING> <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ra = list ( reversed ( a ) ) <NEWLINE> <NL> left = [ ] <NEWLINE> right = [ ] <NEWLINE> right . append ( ra [ 0 ] ) <NEWLINE> left . append ( a [ 0 ] ) <NEWLINE> <NL> if n > 2 : <NEWLINE> <INDENT> k = math . gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> left . append ( k ) <NEWLINE> for i in range ( 2 , n - 1 ) : <NEWLINE> <INDENT> k = math . gcd ( k , a [ i ] ) <NEWLINE> left . append ( k ) <NEWLINE> <NL> <DEDENT> k = math . gcd ( ra [ 0 ] , ra [ 1 ] ) <NEWLINE> right . append ( k ) <NEWLINE> for i in range ( 2 , n - 1 ) : <NEWLINE> <INDENT> k = math . gcd ( k , ra [ i ] ) <NEWLINE> right . append ( k ) <NEWLINE> <NL> <DEDENT> ans = [ right [ - 1 ] ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> ans . append ( math . gcd ( left [ i - 1 ] , right [ len ( right ) - i - 1 ] ) ) <NEWLINE> <DEDENT> ans . append ( left [ - 1 ] ) <NEWLINE> print ( max ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a [ 1 ] , a [ 0 ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> <NL> <NL> def main ( K , N ) : <NEWLINE> <INDENT> P = 10 ** 9 + 7 <NEWLINE> <NL> P25 = [ 1 ] * ( K + 1 ) <NEWLINE> P26 = [ 1 ] * ( K + 1 ) <NEWLINE> F = [ 1 ] * ( N + K ) <NEWLINE> INV = [ 1 ] * ( N + K ) <NEWLINE> INVF = [ 1 ] * ( N + K ) <NEWLINE> <NL> p25 = 1 <NEWLINE> p26 = 1 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> p25 *= 25 <NEWLINE> p25 %= P <NEWLINE> P25 [ i ] = p25 <NEWLINE> <NL> p26 *= 26 <NEWLINE> p26 %= P <NEWLINE> P26 [ i ] = p26 <NEWLINE> <NL> <DEDENT> f = 1 <NEWLINE> invf = 1 <NEWLINE> for i in range ( 2 , N + K ) : <NEWLINE> <INDENT> f *= i <NEWLINE> f %= P <NEWLINE> F [ i ] = f <NEWLINE> q , r = divmod ( P , i ) <NEWLINE> INV [ i ] = - INV [ r ] * q % P <NEWLINE> invf *= INV [ i ] <NEWLINE> invf %= P <NEWLINE> INVF [ i ] = invf <NEWLINE> <NL> <DEDENT> def comb_rep ( n , r ) : <NEWLINE> <INDENT> return ( F [ n + r - 1 ] * INVF [ r ] % P ) * INVF [ n - 1 ] % P <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ret += ( <NEWLINE> <INDENT> P25 [ i ] * <NEWLINE> P26 [ K - i ] % P * <NEWLINE> comb_rep ( N , i ) % P <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> return ( ret % P ) <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import main <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( main ( K , len ( S ) ) ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> person = int ( input ( ) ) <NEWLINE> longs = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> longsi_dic = { } <NEWLINE> for i in range ( len ( longs ) ) : <NEWLINE> <INDENT> if str ( i + longs [ i ] ) not in longsi_dic : <NEWLINE> <INDENT> longsi_dic [ str ( i + longs [ i ] ) ] = 0 <NEWLINE> <DEDENT> longsi_dic [ str ( i + longs [ i ] ) ] += 1 <NEWLINE> <NL> <DEDENT> longsj_dic = { } <NEWLINE> for j in range ( len ( longs ) ) : <NEWLINE> <INDENT> if str ( j - longs [ j ] ) not in longsj_dic : <NEWLINE> <INDENT> longsj_dic [ str ( j - longs [ j ] ) ] = 0 <NEWLINE> <DEDENT> longsj_dic [ str ( j - longs [ j ] ) ] += 1 <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for val , sumi in longsi_dic . items ( ) : <NEWLINE> <INDENT> if val not in longsj_dic : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sum += int ( sumi ) * int ( longsj_dic [ val ] ) <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
def isPrime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i * i > n : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> ans = ans + isPrime ( x ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
res = 1 <NEWLINE> <NL> A = int ( input ( ) ) <NEWLINE> N = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> for x in N : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > pow ( 10 , 18 ) : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<NL> def check ( st ) : <NEWLINE> <NL> <INDENT> n = len ( st ) <NEWLINE> digitSum = 0 <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> digitSum = digitSum + ( int ) ( st [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> return ( digitSum % 9 == 0 ) <NEWLINE> <NL> <NL> <DEDENT> st = input ( ) <NEWLINE> <NL> if ( check ( st ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
def enum_divisors ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> res . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> divs = filter ( lambda x : x <= M // N , enum_divisors ( M ) ) <NEWLINE> print ( max ( divs ) ) <NEWLINE>
def f ( N , L ) : <NEWLINE> <INDENT> S = N * [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S [ L [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> return S <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = f ( N , L ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> print ( A [ j ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> x = H [ A - 1 ] <NEWLINE> y = H [ B - 1 ] <NEWLINE> if x > y : <NEWLINE> <INDENT> ans [ B - 1 ] = 0 <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> ans [ B - 1 ] = 0 <NEWLINE> ans [ A - 1 ] = 0 <NEWLINE> <DEDENT> elif y > x : <NEWLINE> <INDENT> ans [ A - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> As = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> As_set = set ( As ) <NEWLINE> <NL> limit = 10 ** 18 <NEWLINE> <NL> prod = 1 <NEWLINE> <NL> if 0 in As_set : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> over = False <NEWLINE> for A in As : <NEWLINE> <INDENT> prod *= A <NEWLINE> if prod > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> total = sum ( lis ) <NEWLINE> <NL> nlis = [ 0 ] * 100002 <NEWLINE> <NL> for i in lis : <NEWLINE> <INDENT> nlis [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> total = total - ( b * nlis [ b - 1 ] ) + ( c * nlis [ b - 1 ] ) <NEWLINE> nlis [ c - 1 ] += nlis [ b - 1 ] <NEWLINE> nlis [ b - 1 ] = 0 <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> input_data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> input_data . reverse ( ) <NEWLINE> print ( <STRING> . join ( str ( b ) for b in input_data ) ) <NEWLINE>
N = input ( ) <NEWLINE> M = N <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> n , M = int ( M [ 0 ] ) , M [ 1 : ] <NEWLINE> tmp += n <NEWLINE> <DEDENT> if tmp % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , * t = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> r = [ 0 ] + [ 1 ] * n <NEWLINE> for a , b in zip ( t [ n + 1 : : 2 ] , t [ n + 2 : : 2 ] ) : r [ a ] &= t [ a ] > t [ b ] ; r [ b ] &= t [ b ] > t [ a ] <NEWLINE> print ( sum ( r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> <COMMENT> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> M = 256 <NEWLINE> sq = [ i ** 2 for i in range ( M ) ] <NEWLINE> nkss = [ [ sq [ abs ( x - nk ) ] for nk in range ( M ) ] for x in range ( M ) ] <NEWLINE> ML = list ( range ( M ) ) <NEWLINE> <NL> def f ( m , n ) : <NEWLINE> <INDENT> cs = [ I ( ) for _ in range ( m ) ] <NEWLINE> xs = [ I ( ) for _ in range ( n ) ] <NEWLINE> ml = list ( range ( m ) ) <NEWLINE> d = [ inf ] * M <NEWLINE> nd = [ inf ] * M <NEWLINE> d [ 128 ] = 0 <NEWLINE> ckl = list ( map ( lambda x : ( max ( min ( x [ 0 ] + x [ 1 ] , 255 ) , 0 ) , x [ 1 ] ) , ( itertools . product ( cs , ML ) ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nd = [ inf ] * M <NEWLINE> for nk , k in ckl : <NEWLINE> <INDENT> if nd [ nk ] > d [ k ] : <NEWLINE> <INDENT> nd [ nk ] = d [ k ] <NEWLINE> <DEDENT> <DEDENT> d = [ nn + kk for nn , kk in zip ( nd , nkss [ xs [ i ] ] ) ] <NEWLINE> <DEDENT> return min ( d ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , m = LI ( ) <NEWLINE> if m == 0 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( m , n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> mod = 998244353 <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> N = INT ( ) <NEWLINE> xy = [ LIST ( ) for _ in range ( N ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> xy . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) <NEWLINE> diff = [ ] <NEWLINE> <NL> for s , t in combinations ( xy , 2 ) : <NEWLINE> <INDENT> st = str ( t [ 0 ] - s [ 0 ] ) + <STRING> + str ( t [ 1 ] - s [ 1 ] ) <NEWLINE> diff . append ( st ) <NEWLINE> <NL> <DEDENT> print ( max ( N - Counter ( diff ) . most_common ( ) [ 0 ] [ 1 ] , 1 ) ) <NEWLINE> <NL>
K = int ( input ( ) ) <NEWLINE> <NL> if ( K % 10 ) % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> elif ( K % 10 ) % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 7 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if num % K == 0 : <NEWLINE> <INDENT> print ( str ( i + 1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> num = ( num * 10 + 7 ) % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> dq = deque ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dq . remove ( cmd [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * dq ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( x + 1 ) : <NEWLINE> <INDENT> foot = 2 * i + 4 * ( x - i ) <NEWLINE> if foot == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> L = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> com = input ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> C = com . split ( ) <NEWLINE> L . appendleft ( int ( C [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if com [ 6 ] == <STRING> : <NEWLINE> <INDENT> L . popleft ( ) <NEWLINE> <DEDENT> elif com [ 6 ] == <STRING> : <NEWLINE> <INDENT> L . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = com . split ( ) <NEWLINE> x = int ( C [ 1 ] ) <NEWLINE> try : <NEWLINE> <INDENT> L . remove ( x ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * L ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += As [ i ] <NEWLINE> sum %= 10 ** 9 + 7 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum -= As [ i ] <NEWLINE> ans += As [ i ] * sum <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = N <NEWLINE> if N > B - 1 : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> print ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> difs = { } <NEWLINE> points = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for j in range ( len ( points ) ) : <NEWLINE> <INDENT> dif1 = ( points [ j ] [ 0 ] - x , points [ j ] [ 1 ] - y ) <NEWLINE> dif2 = ( - dif1 [ 0 ] , - dif1 [ 1 ] ) <NEWLINE> <NL> difs [ dif1 ] = 1 if dif1 not in difs else difs [ dif1 ] + 1 <NEWLINE> difs [ dif2 ] = 1 if dif2 not in difs else difs [ dif2 ] + 1 <NEWLINE> <NL> <DEDENT> points . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - max ( difs . values ( ) ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if T in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> slen = len ( S ) <NEWLINE> tlen = len ( T ) <NEWLINE> ansCnt = tlen <NEWLINE> <NL> for i in range ( slen - tlen + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( tlen ) : <NEWLINE> <INDENT> if T [ j ] != S [ i + j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ansCnt > cnt : <NEWLINE> <INDENT> ansCnt = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ansCnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st = str ( i ) <NEWLINE> for x in range ( 0 , len ( st ) ) : <NEWLINE> <INDENT> if st [ x ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> seven = 7 <NEWLINE> ans = 1 <NEWLINE> <NL> <COMMENT> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> elif K == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_list = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> while not seven % K == 0 : <COMMENT> <NEWLINE> <INDENT> seven = seven * 10 + 7 <NEWLINE> seven = seven % K <NEWLINE> ans += 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def Base_10_to_n ( X , n ) : <NEWLINE> <INDENT> X_dumy = X <NEWLINE> out = [ ] <NEWLINE> while X_dumy > 0 : <NEWLINE> <INDENT> X_dumy -= 1 <NEWLINE> out . append ( X_dumy % n ) <NEWLINE> X_dumy = int ( X_dumy / n ) <NEWLINE> <DEDENT> return out <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> d = { y : x for x , y in zip ( <STRING> , range ( 26 ) ) } <NEWLINE> <NL> res = [ ] <NEWLINE> array = Base_10_to_n ( n , 26 ) <NEWLINE> <NL> print ( <STRING> . join ( [ d [ x ] for x in array [ : : - 1 ] ] ) ) <NEWLINE>
n , nq = map ( int , input ( ) . split ( ) ) <NEWLINE> set_list = list ( range ( n ) ) <NEWLINE> <NL> def find ( n ) : <NEWLINE> <INDENT> global set_list <NEWLINE> if set_list [ n ] == n : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> result = set_list [ n ] = find ( set_list [ n ] ) <NEWLINE> return result <NEWLINE> <NL> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> set_list [ find ( y ) ] = find ( x ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <DEDENT> for _ in range ( nq ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> same ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if unite ( x , y ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import collections <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> item = [ input ( ) for i in range ( num ) ] <NEWLINE> <NL> item_count = collections . Counter ( item ) <NEWLINE> <NL> print ( len ( item_count . keys ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> U = 10 ** 6 <NEWLINE> line = [ 1 ] * ( U + 1 ) <NEWLINE> ans = set ( ) <NEWLINE> depricated = set ( ) <NEWLINE> cnt = [ 0 ] * ( U + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> if cnt [ a ] == 2 and line [ a ] : <NEWLINE> <INDENT> depricated . add ( a ) <NEWLINE> continue <NEWLINE> <DEDENT> if 2 < cnt [ a ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if line [ a ] : <NEWLINE> <INDENT> ans . add ( a ) <NEWLINE> for p in range ( 2 * a , U + 1 , a ) : <NEWLINE> <INDENT> line [ p ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( ans - depricated ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> listA = [ 0 ] * ( 10 ** 6 + 10 ) <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if listA [ i ] != 0 : <NEWLINE> <INDENT> listA [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( i , 10 ** 6 + 10 , i ) : <NEWLINE> <INDENT> listA [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> if listA [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> i = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> dif = ( N // 2 ) // ( 5 ** i ) <NEWLINE> count += dif <NEWLINE> if dif == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
def popcount ( num ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> while num : <NEWLINE> <INDENT> if num % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> num //= 2 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> popcount_X = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> popcount_X += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> tmp4p = int ( X , 2 ) % ( popcount_X + 1 ) <NEWLINE> if popcount_X != 1 : <NEWLINE> <INDENT> tmp4m = int ( X , 2 ) % ( popcount_X - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> bit = X [ i ] <NEWLINE> <NL> f = 0 <NEWLINE> if ( popcount_X == 1 and bit == <STRING> ) : <NEWLINE> <INDENT> print ( f ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if bit == <STRING> : <NEWLINE> <INDENT> nxt = ( tmp4m - pow ( 2 , N - i - 1 , ( popcount_X - 1 ) ) + ( popcount_X - 1 ) ) % ( popcount_X - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nxt = ( tmp4p + pow ( 2 , N - i - 1 , ( popcount_X + 1 ) ) ) % ( popcount_X + 1 ) <NEWLINE> <NL> <DEDENT> f += 1 <NEWLINE> while nxt : <NEWLINE> <INDENT> pc = popcount ( nxt ) <NEWLINE> nxt = nxt % pc <NEWLINE> f += 1 <NEWLINE> <NL> <DEDENT> print ( f ) <NEWLINE> <DEDENT>
def e_multiplication_4 ( MOD = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> from functools import reduce <NEWLINE> N , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> sign = { - 1 : 0 , 0 : 0 , 1 : 0 } <COMMENT> <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> sign [ 0 ] += 1 <NEWLINE> continue <NEWLINE> <DEDENT> sign [ a // abs ( a ) ] += 1 <NEWLINE> <NL> <DEDENT> if sign [ 1 ] == 0 and K % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> A . sort ( reverse = True ) <NEWLINE> return reduce ( lambda x , y : ( x * y ) % MOD , A [ : K ] ) <NEWLINE> <DEDENT> if sign [ 1 ] == 0 and K % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> A . sort ( ) <NEWLINE> return reduce ( lambda x , y : ( x * y ) % MOD , A [ : K ] ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> i , j = 0 , N - 1 <NEWLINE> while K > 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if K > 1 and A [ i ] * A [ i + 1 ] >= A [ j ] * A [ j - 1 ] : <NEWLINE> <INDENT> ans *= A [ i ] * A [ i + 1 ] <NEWLINE> i += 2 <NEWLINE> K -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ j ] <NEWLINE> j -= 1 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> ans %= MOD <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( e_multiplication_4 ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ki = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ki [ a - 1 ] . append ( b - 1 ) <NEWLINE> ki [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> tf = [ False for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> def dfs ( v ) : <NEWLINE> <INDENT> global eda <NEWLINE> tf [ v ] = True <NEWLINE> eda += 1 <NEWLINE> for nv in set ( ki [ v ] ) : <NEWLINE> <INDENT> if not tf [ nv ] : <NEWLINE> <INDENT> dfs ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not tf [ i ] : <NEWLINE> <INDENT> eda = 0 <NEWLINE> dfs ( i ) <NEWLINE> ans = max ( ans , eda ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <DEDENT> l = ( lcm ( n , m ) ) <NEWLINE> <NL> sdict = { } <NEWLINE> s_num = [ ] <NEWLINE> for i , moji in enumerate ( list ( s ) ) : <NEWLINE> <INDENT> num = i * l // n + 1 <NEWLINE> sdict [ num - 1 ] = moji <NEWLINE> s_num . append ( num - 1 ) <NEWLINE> <NL> <DEDENT> tdct = { } <NEWLINE> t_num = [ ] <NEWLINE> for i , moji in enumerate ( list ( t ) ) : <NEWLINE> <INDENT> num = i * l // m + 1 <NEWLINE> tdct [ num - 1 ] = moji <NEWLINE> t_num . append ( num - 1 ) <NEWLINE> <NL> <DEDENT> stlst = list ( set ( s_num ) & set ( t_num ) ) <NEWLINE> <NL> for i in stlst : <NEWLINE> <INDENT> if sdict [ i ] != tdct [ i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( min ( k , len ( s ) ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> ans = int ( s [ i ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> lst [ i - 1 ] += 1 <NEWLINE> <DEDENT> for syainn in lst : <NEWLINE> <INDENT> print ( syainn ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> cand = [ [ 1 ] ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> while cand : <NEWLINE> <INDENT> x = cand . pop ( ) <NEWLINE> for i in range ( x [ - 1 ] , M + 1 ) : <NEWLINE> <INDENT> tmp . append ( x + [ i ] ) <NEWLINE> <DEDENT> <DEDENT> cand = tmp <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for X in cand : <NEWLINE> <INDENT> score = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if X [ b - 1 ] - X [ a - 1 ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> d = [ 0 ] * mod <NEWLINE> d [ 0 ] = 1 <NEWLINE> t = 1 <NEWLINE> rem = 0 <NEWLINE> <NL> for i in reversed ( S ) : <NEWLINE> <INDENT> rem += int ( i ) * t <NEWLINE> <COMMENT> <NL> rem %= mod <NEWLINE> <COMMENT> <NL> t *= 10 <NEWLINE> t %= mod <NEWLINE> d [ rem ] += 1 <NEWLINE> <NL> <DEDENT> print ( int ( sum ( [ i * ( i - 1 ) / 2 for i in d ] ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> D = [ 1 ] * ( A [ - 1 ] + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if D [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( A [ - 1 ] // i ) : <NEWLINE> <INDENT> D [ i * ( j + 1 ) ] = 0 <NEWLINE> <DEDENT> D [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> dic = { } <NEWLINE> for i in A : <NEWLINE> <INDENT> if i not in dic : <NEWLINE> <INDENT> dic [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in dic : <NEWLINE> <INDENT> if dic [ i ] > 1 : <NEWLINE> <INDENT> D [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if D [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for a in range ( k - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k - 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k ) : <NEWLINE> <INDENT> sum += 6 * math . gcd ( a + 1 , math . gcd ( b + 1 , c + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( k - 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k ) : <NEWLINE> <INDENT> sum += 6 * math . gcd ( a + 1 , b + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> sum += k * ( k + 1 ) // 2 <NEWLINE> <NL> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> nums = [ i for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> nums = sorted ( nums ) <NEWLINE> max = nums [ - 1 ] <NEWLINE> dp = [ 1 ] * ( max + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( nums ) - 1 ) : <NEWLINE> <INDENT> p = nums [ i ] <NEWLINE> if dp [ p ] == 1 : <NEWLINE> <INDENT> for q in range ( max // p + 1 ) : <NEWLINE> <INDENT> dp [ p * q ] = 0 <NEWLINE> <DEDENT> if nums [ i ] != nums [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if dp [ max ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = A [ 0 ] <NEWLINE> i = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( i < n ) and ( ans <= 10 ** 18 ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> if ( ans <= 10 ** 18 ) and i == n : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> class LinkedList : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . ll = [ [ ] for _ in range ( self . n ) ] <NEWLINE> <NL> <DEDENT> def link ( self , u , v , direction = False ) : <NEWLINE> <INDENT> self . ll [ u ] . append ( v ) <NEWLINE> if not direction : <NEWLINE> <INDENT> self . ll [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dfs ( self ) : <NEWLINE> <INDENT> self . cc = [ None ] * self . n <NEWLINE> <NL> color = 1 <NEWLINE> for u in range ( self . n ) : <NEWLINE> <INDENT> if not self . cc [ u ] : <NEWLINE> <INDENT> self . dfs_visit ( u , color ) <NEWLINE> color += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs_visit ( self , u , color ) : <NEWLINE> <INDENT> self . cc [ u ] = color <NEWLINE> for v in self . ll [ u ] : <NEWLINE> <INDENT> if not self . cc [ v ] : <NEWLINE> <INDENT> self . dfs_visit ( v , color ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def check ( self , u , v ) : <NEWLINE> <INDENT> if self . cc [ u ] == self . cc [ v ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ll = LinkedList ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> ll . link ( u , v ) <NEWLINE> <DEDENT> ll . dfs ( ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> ll . check ( u , v ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 1 <NEWLINE> <NL> if any ( [ i == 0 for i in a ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> t = t * x <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if t > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> <DEDENT>
r = float ( input ( ) ) <NEWLINE> pi = 3.141592653589 <NEWLINE> print ( <STRING> . format ( r ** 2 * pi , 2 * r * pi ) ) <NEWLINE>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> index = s . find ( s [ 0 ] , 1 ) <NEWLINE> if index >= 1 : <NEWLINE> <INDENT> s = s . replace ( s [ 0 ] , <STRING> ) <NEWLINE> if ( len ( s ) == 2 ) : <NEWLINE> <INDENT> if ( s [ 0 ] == s [ 1 ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tot = sum ( a ) <NEWLINE> b = 0 <NEWLINE> c = 10 ** 10 <NEWLINE> d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> d = abs ( tot / 2 - b ) <NEWLINE> if d < c : <NEWLINE> <INDENT> c = d <NEWLINE> <DEDENT> <DEDENT> print ( int ( 2 * c ) ) <NEWLINE>
l , n , r = set ( ) , int ( input ( ) ) , str . maketrans ( <STRING> , <STRING> ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> opr , word = input ( ) . split ( ) <NEWLINE> word = int ( word . translate ( r ) , base = 5 ) <NEWLINE> if opr . startswith ( <STRING> ) : <NEWLINE> <INDENT> l . add ( word ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if word in l else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> L . append ( x ) <NEWLINE> <NL> <DEDENT> ma = L [ 1 ] - L [ 0 ] <NEWLINE> mi = L [ 0 ] <NEWLINE> for x in range ( n - 1 ) : <NEWLINE> <INDENT> ma = max ( [ ma , L [ x + 1 ] - mi ] ) <NEWLINE> mi = min ( mi , L [ x + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( ma ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n , m = INTM ( ) <NEWLINE> b_sts = [ False ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b = INT ( ) <NEWLINE> b -= 1 <NEWLINE> b_sts [ b ] = True <NEWLINE> <NL> <DEDENT> step = [ 0 ] * ( n + 2 ) <NEWLINE> step [ 1 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b_sts [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step [ i + 2 ] = ( step [ i + 1 ] + step [ i ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( step [ - 1 ] % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> count = 0 <NEWLINE> a = [ 0 for i in range ( 2019 ) ] <NEWLINE> a [ 0 ] = 1 <NEWLINE> k = 0 <NEWLINE> b = [ 0 for i in range ( n ) ] <NEWLINE> b [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> b [ i ] = b [ i - 1 ] * 10 % 2019 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in reversed ( range ( 0 , n ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> k += ( b [ n - i - 1 ] ) * int ( s [ i ] ) % 2019 <NEWLINE> <COMMENT> <NL> a [ k % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] >= 2 : <NEWLINE> <INDENT> count += ( a [ i ] ) * ( a [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = input ( ) <NEWLINE> m = [ 0 ] * a <NEWLINE> for i in range ( 1 , a ) : <NEWLINE> <INDENT> if n [ i - 1 : i + 1 ] == <STRING> : <NEWLINE> <INDENT> m [ i ] = m [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ i ] = m [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( b ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( m [ t - 1 ] - m [ s - 1 ] ) <NEWLINE> <DEDENT>
def popcount ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 20 ) : <NEWLINE> <INDENT> if n >> i & 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> n = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> np1 = 0 <NEWLINE> nm1 = 0 <NEWLINE> temp1 = 1 <NEWLINE> temp2 = 1 <NEWLINE> nm = n - 1 <NEWLINE> if nm == 0 : <NEWLINE> <INDENT> nm = 1 <NEWLINE> <DEDENT> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> np1 = ( np1 + temp1 ) % ( n + 1 ) <NEWLINE> nm1 = ( nm1 + temp2 ) % nm <NEWLINE> <DEDENT> temp1 = ( temp1 * 2 ) % ( n + 1 ) <NEWLINE> temp2 = ( temp2 * 2 ) % nm <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> temp = ( nm1 - pow ( 2 , ( N - 1 - i ) , n - 1 ) ) % ( n - 1 ) <NEWLINE> while temp > 0 : <NEWLINE> <INDENT> pop_n = popcount ( temp ) <NEWLINE> temp = temp % pop_n <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> elif X [ i ] == <STRING> : <NEWLINE> <INDENT> temp = ( np1 + pow ( 2 , ( N - 1 - i ) , n + 1 ) ) % ( n + 1 ) <NEWLINE> while temp > 0 : <NEWLINE> <INDENT> pop_n = popcount ( temp ) <NEWLINE> temp = temp % pop_n <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> num_list = np . array ( input ( ) . split ( ) , dtype = <STRING> ) <NEWLINE> <NL> max_num = max ( num_list ) <NEWLINE> max_bit_num = format ( max_num , <STRING> ) <NEWLINE> max_bit_num_length = len ( max_bit_num ) <NEWLINE> ans = 0 <NEWLINE> radix = 1 <NEWLINE> for i in range ( max_bit_num_length ) : <NEWLINE> <INDENT> new_num_list = ( num_list >> i ) & 1 <NEWLINE> one_amount = np . count_nonzero ( new_num_list == 1 ) <NEWLINE> zero_amount = len ( num_list ) - one_amount <NEWLINE> ans += ( one_amount * zero_amount ) * radix <NEWLINE> radix *= 2 <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def find ( x , parent ) : <NEWLINE> <INDENT> if parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ x ] = find ( parent [ x ] , parent ) <NEWLINE> return ( parent [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( x , y , parent , rank ) : <NEWLINE> <INDENT> xroot = find ( x , parent ) <NEWLINE> yroot = find ( y , parent ) <NEWLINE> if rank [ xroot ] > rank [ yroot ] : <NEWLINE> <INDENT> parent [ yroot ] = xroot <NEWLINE> <DEDENT> elif rank [ yroot ] > rank [ xroot ] : <NEWLINE> <INDENT> parent [ xroot ] = yroot <NEWLINE> <DEDENT> elif rank [ yroot ] == rank [ xroot ] : <NEWLINE> <INDENT> parent [ yroot ] = xroot <NEWLINE> rank [ xroot ] += 1 <NEWLINE> <DEDENT> return ( parent , rank ) <NEWLINE> <NL> <NL> <DEDENT> parent = [ i for i in range ( N + 1 ) ] <NEWLINE> rank = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> parent , rank = union ( A [ i ] , B [ i ] , parent , rank ) <NEWLINE> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> find ( i , parent ) <NEWLINE> <DEDENT> G = parent [ 1 : ] <NEWLINE> import collections <NEWLINE> c = collections . Counter ( G ) <NEWLINE> print ( int ( c . most_common ( ) [ 0 ] [ 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> max = A [ 0 ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> while ( max > A [ i ] ) : <NEWLINE> <INDENT> count = count + ( max - A [ i ] ) <NEWLINE> A [ i ] = max <NEWLINE> <COMMENT> <NL> <DEDENT> if ( max <= A [ i ] ) : <NEWLINE> <INDENT> max = A [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p_e = list ( ) <NEWLINE> exp = 0 <NEWLINE> for p in P : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> exp += ( 1 + p ) / 2 <NEWLINE> p_e . append ( exp ) <NEWLINE> <DEDENT> if n == k : <NEWLINE> <INDENT> print ( p_e [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> maxv = p_e [ k - 1 ] - p_e [ 0 ] <NEWLINE> for i in range ( 1 , n - k ) : <NEWLINE> <COMMENT> <NL> <INDENT> p_sum = p_e [ k + i ] - p_e [ i ] <NEWLINE> maxv = max ( maxv , p_sum ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> year = 0 <NEWLINE> yokin = 100 <NEWLINE> <NL> while yokin < X : <NEWLINE> <INDENT> year += 1 <NEWLINE> yokin += math . floor ( yokin * 0.01 ) <NEWLINE> <DEDENT> print ( year ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> answer = 1000000000000 <NEWLINE> for i in range ( 1 , int ( N ** ( 0.5 ) ) + 2 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> j = N // i <NEWLINE> if i + j - 2 < answer : <NEWLINE> <INDENT> answer = i + j - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> ans = 0 <NEWLINE> diff_list = [ ] <COMMENT> <NEWLINE> count = defaultdict ( int ) <COMMENT> <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i == A [ 0 ] + A [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> d1 = A [ i ] - A [ 0 ] <NEWLINE> d2 = i <NEWLINE> diff_list . append ( d1 + d2 ) <NEWLINE> <NL> count [ A [ 0 ] + A [ i ] - i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> count [ A [ 0 ] + A [ i + 1 ] - ( i + 1 ) ] -= 1 <COMMENT> <NEWLINE> d = diff_list [ i ] <NEWLINE> ans += count [ - d ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = NMI ( ) <NEWLINE> A = NLI ( ) <NEWLINE> ng = 0 <NEWLINE> ok = 10 ** 10 <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if mid == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % mid == 0 : <NEWLINE> <INDENT> tmp += a // mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += a // mid <NEWLINE> <DEDENT> <DEDENT> if tmp <= K : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 = 2 <NEWLINE> l2 = 1 <NEWLINE> l3 = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l3 = l1 <NEWLINE> l1 = l2 <NEWLINE> l2 += l3 <NEWLINE> <DEDENT> print ( l2 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> mark = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cards = [ <STRING> . format ( mark [ i ] , j + 1 ) for i in range ( 4 ) for j in range ( 13 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cards . remove ( raw_input ( ) ) <NEWLINE> <DEDENT> while len ( cards ) != 0 : <NEWLINE> <INDENT> print cards . pop ( 0 ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( x , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> uru = [ str ( i ) for i in range ( a , b + 1 ) if i % 400 == 0 or ( i % 4 == 0 and i % 100 != 0 ) ] <NEWLINE> result = <STRING> . join ( uru ) <NEWLINE> <NL> if not result : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b == 0 : break <NEWLINE> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> S = [ ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> S . append ( sum ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] * ( S [ N - 1 ] - S [ i ] ) <NEWLINE> <NL> <DEDENT> print ( int ( ans % ( 10 ** 9 + 7 ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 1 <NEWLINE> q = [ 0 ] * n <NEWLINE> q [ 0 ] = 1 <NEWLINE> r = [ 1 ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s = l [ s - 1 ] <NEWLINE> if q [ s - 1 ] == 0 : <NEWLINE> <INDENT> q [ s - 1 ] += 1 <NEWLINE> r . append ( s ) <NEWLINE> if i == k - 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = r . index ( s ) <NEWLINE> mod = len ( r ) - x <NEWLINE> t = ( k - i - 1 ) % mod <NEWLINE> print ( r [ x + t ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x , y = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dif = b [ i ] - a [ i ] <NEWLINE> if dif > 0 : <NEWLINE> <INDENT> x += dif // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += - dif <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if x >= y else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if p == sorted ( p ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> is_sorted = False <NEWLINE> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if p [ i ] < p [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = p . copy ( ) <NEWLINE> k [ i ] , k [ j ] = k [ j ] , k [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if k == sorted ( p ) : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> is_sorted = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_sorted : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
lst = input ( ) . split ( ) <NEWLINE> <NL> X = int ( lst [ 0 ] ) <NEWLINE> K = int ( lst [ 1 ] ) <NEWLINE> D = int ( lst [ 2 ] ) <NEWLINE> <NL> a = int ( ( D * K - X ) / ( 2 * D ) ) <NEWLINE> <NL> if a < 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <NL> <DEDENT> if a > K : <NEWLINE> <INDENT> a = K <NEWLINE> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> return X - D * K + 2 * D * x <NEWLINE> <NL> <DEDENT> lst2 = [ abs ( f ( a ) ) ] <NEWLINE> <NL> if a + 1 <= K : <NEWLINE> <INDENT> lst2 . append ( abs ( f ( a + 1 ) ) ) <NEWLINE> <NL> <DEDENT> if 0 < a : <NEWLINE> <INDENT> lst2 . append ( abs ( f ( a - 1 ) ) ) <NEWLINE> <NL> <DEDENT> result = min ( lst2 ) <NEWLINE> <NL> print ( result ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> keep = [ ] <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> keep . append ( c ) <NEWLINE> <DEDENT> for j in range ( 2 ** n ) : <NEWLINE> <INDENT> bag = [ 0 ] * m <NEWLINE> total = 0 <NEWLINE> check = 1 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if ( ( j >> k ) & 1 ) : <NEWLINE> <INDENT> for l in range ( m ) : <NEWLINE> <INDENT> bag [ l ] += keep [ k ] [ l + 1 ] <NEWLINE> <DEDENT> total += keep [ k ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> for a in range ( m ) : <NEWLINE> <INDENT> if bag [ a ] < x : <NEWLINE> <INDENT> check *= 0 <NEWLINE> <DEDENT> <DEDENT> if ans * check > total : <NEWLINE> <INDENT> ans = total <NEWLINE> <DEDENT> <DEDENT> if ans == 10 ** 10 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import string <NEWLINE> a = string . ascii_lowercase <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , 27 ) : <NEWLINE> <INDENT> t = s [ : - 1 ] . translate ( str . maketrans ( a , a [ i : ] + a [ : i ] ) ) <NEWLINE> if <STRING> in t or <STRING> in t or <STRING> in t : <NEWLINE> <INDENT> print ( t + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict , deque <NEWLINE> import sys , heapq , bisect , math , itertools , string , queue , datetime <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> eps = 10 ** - 7 <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpl_str ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def rev_w ( MAP , H , W ) : <NEWLINE> <INDENT> nextMAP = [ [ ] for y in range ( H ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> nextMAP [ y ] = MAP [ y ] [ : : - 1 ] <NEWLINE> <DEDENT> return nextMAP <NEWLINE> <NL> <DEDENT> def rev_h ( MAP , H , W ) : <NEWLINE> <INDENT> nextMAP = [ [ 0 ] * W for y in range ( H ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> nextMAP [ y ] [ x ] = MAP [ H - y - 1 ] [ x ] <NEWLINE> <DEDENT> <DEDENT> return nextMAP <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> W , H , t , p = inpl ( ) <NEWLINE> if W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAP = [ [ 1 ] * W for y in range ( H ) ] <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> d , c = inpl ( ) <NEWLINE> if d == 1 : <NEWLINE> <INDENT> if W // 2 >= c : <NEWLINE> <INDENT> hanten = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hanten = True <NEWLINE> <NL> <DEDENT> if hanten : <NEWLINE> <INDENT> MAP = rev_w ( MAP , H , W ) <NEWLINE> c = W - c <NEWLINE> <NL> <DEDENT> nextW = W - c <NEWLINE> nextH = H <NEWLINE> nextMAP = [ [ 1 ] * nextW for y in range ( H ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( c ) : <NEWLINE> <INDENT> nextMAP [ y ] [ x ] = MAP [ y ] [ x + c ] + MAP [ y ] [ ( c - 1 ) - x ] <NEWLINE> <DEDENT> for x in range ( c , nextW ) : <NEWLINE> <INDENT> nextMAP [ y ] [ x ] = MAP [ y ] [ x + c ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif d == 2 : <NEWLINE> <INDENT> if H // 2 >= c : <NEWLINE> <INDENT> hanten = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hanten = True <NEWLINE> <NL> <DEDENT> if hanten : <NEWLINE> <INDENT> MAP = rev_h ( MAP , H , W ) <NEWLINE> c = H - c <NEWLINE> <NL> <DEDENT> nextW = W <NEWLINE> nextH = H - c <NEWLINE> nextMAP = [ [ 1 ] * W for y in range ( nextH ) ] <NEWLINE> for x in range ( W ) : <NEWLINE> <INDENT> for y in range ( c ) : <NEWLINE> <INDENT> nextMAP [ y ] [ x ] = MAP [ y + c ] [ x ] + MAP [ ( c - 1 ) - y ] [ x ] <NEWLINE> <DEDENT> for y in range ( c , nextH ) : <NEWLINE> <INDENT> nextMAP [ y ] [ x ] = MAP [ y + c ] [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> MAP = nextMAP <NEWLINE> H , W = nextH , nextW <NEWLINE> <NL> <DEDENT> for _ in range ( p ) : <NEWLINE> <INDENT> x , y = inpl ( ) <NEWLINE> print ( MAP [ y ] [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1010 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> src = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> src . append ( ( s , [ ] ) ) <NEWLINE> if i == 0 : continue <NEWLINE> src [ k - 1 ] [ 1 ] . append ( i ) <NEWLINE> <NL> <DEDENT> def dfs ( i , depth ) : <NEWLINE> <INDENT> s , ch = src [ i ] <NEWLINE> print ( <STRING> * depth + s ) <NEWLINE> for c in ch : <NEWLINE> <INDENT> dfs ( c , depth + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , 0 ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> s = math . sqrt ( n ) <NEWLINE> i = 2 <NEWLINE> f = { } <NEWLINE> while i <= s : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> f [ i ] = f . get ( i , 0 ) + 1 <NEWLINE> n = n // i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for x in f . values ( ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> cumsum = 0 <NEWLINE> while e + cumsum + 1 <= x : <NEWLINE> <INDENT> e += 1 <NEWLINE> cumsum += e <NEWLINE> <DEDENT> ans += e <NEWLINE> <DEDENT> print ( ans + ( n > 1 ) ) <NEWLINE>
import sys <NEWLINE> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A > B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> if A == B : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> x = B * ( N - 1 ) + A <NEWLINE> n = A * ( N - 1 ) + B <NEWLINE> print ( x - n + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> while a [ i ] % 2 == 0 : <NEWLINE> <INDENT> a [ i ] = a [ i ] // 2 <NEWLINE> t += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
import collections <NEWLINE> N = input ( ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> c = collections . Counter ( l ) <NEWLINE> <NL> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> print ( c [ str ( i + 1 ) ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ u - 1 ] . append ( v - 1 ) <NEWLINE> <NL> <DEDENT> S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> S -= 1 <NEWLINE> T -= 1 <NEWLINE> <NL> from collections import deque <NEWLINE> q = deque ( [ ] ) <NEWLINE> q . append ( [ S , 0 , 0 ] ) <NEWLINE> <NL> seen = [ [ False ] * 3 for i in range ( N ) ] <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v , cost , step = q . popleft ( ) <NEWLINE> if seen [ v ] [ step ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> seen [ v ] [ step ] = True <NEWLINE> if step == 0 : <NEWLINE> <INDENT> if v == T : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> break <NEWLINE> <DEDENT> cost += 1 <NEWLINE> step = 3 <NEWLINE> <DEDENT> for u in graph [ v ] : <NEWLINE> <INDENT> q . append ( [ u , cost , step - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def insert ( root , insert_node ) : <NEWLINE> <INDENT> focus_node = root <NEWLINE> parent = None <NEWLINE> while not focus_node == None : <NEWLINE> <INDENT> parent = focus_node <NEWLINE> if focus_node [ <STRING> ] > insert_node [ <STRING> ] : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> if parent [ <STRING> ] > insert_node [ <STRING> ] : <NEWLINE> <INDENT> parent [ <STRING> ] = insert_node <NEWLINE> insert_node [ <STRING> ] = parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ <STRING> ] = insert_node <NEWLINE> insert_node [ <STRING> ] = parent <NEWLINE> <NL> <DEDENT> <DEDENT> def get_preorder ( node ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> r = [ ] <NEWLINE> r . append ( str ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_preorder ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_preorder ( node [ <STRING> ] ) ) <NEWLINE> <NL> return r <NEWLINE> <NL> <DEDENT> def get_inorder ( node ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> r = [ ] <NEWLINE> r . extend ( get_inorder ( node [ <STRING> ] ) ) <NEWLINE> r . append ( str ( node [ <STRING> ] ) ) <NEWLINE> r . extend ( get_inorder ( node [ <STRING> ] ) ) <NEWLINE> <NL> return r <NEWLINE> <NL> <DEDENT> def delete_tree ( root , target ) : <NEWLINE> <NL> <INDENT> delete_node = find_tree ( root , target ) <NEWLINE> parent = delete_node [ <STRING> ] <NEWLINE> if parent [ <STRING> ] == delete_node : <NEWLINE> <INDENT> parent_direction = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent_direction = <STRING> <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if delete_node [ <STRING> ] == None and delete_node [ <STRING> ] == None : <NEWLINE> <INDENT> parent [ parent_direction ] = None <NEWLINE> break <NEWLINE> <DEDENT> elif delete_node [ <STRING> ] and delete_node [ <STRING> ] : <NEWLINE> <INDENT> p = get_inorder ( root ) <NEWLINE> next_num = int ( p [ p . index ( str ( delete_node [ <STRING> ] ) ) + 1 ] ) <NEWLINE> tmp_delete_node = find_tree ( root , next_num ) <NEWLINE> delete_node [ <STRING> ] = next_num <NEWLINE> delete_node = tmp_delete_node <NEWLINE> parent = delete_node [ <STRING> ] <NEWLINE> if parent == None : <NEWLINE> <INDENT> parent_direction = None <NEWLINE> <DEDENT> elif parent [ <STRING> ] == delete_node : <NEWLINE> <INDENT> parent_direction = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent_direction = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if delete_node [ <STRING> ] : <NEWLINE> <INDENT> parent [ parent_direction ] = delete_node [ <STRING> ] <NEWLINE> delete_node [ <STRING> ] [ <STRING> ] = parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ parent_direction ] = delete_node [ <STRING> ] <NEWLINE> delete_node [ <STRING> ] [ <STRING> ] = parent <NEWLINE> <DEDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def find_tree ( root , target ) : <NEWLINE> <INDENT> focus_node = root <NEWLINE> <NL> while not focus_node == None : <NEWLINE> <INDENT> if focus_node [ <STRING> ] == target : <NEWLINE> <INDENT> return focus_node <NEWLINE> <DEDENT> elif focus_node [ <STRING> ] < target : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> focus_node = focus_node [ <STRING> ] <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def print_tree ( root ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( get_inorder ( root ) ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( get_preorder ( root ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> n_line = int ( input ( ) ) <NEWLINE> input_list = [ input ( ) for i in range ( n_line ) ] <NEWLINE> root = { <STRING> : None , <STRING> : None , <STRING> : int ( input_list [ 0 ] . split ( ) [ 1 ] ) , <STRING> : None } <NEWLINE> <NL> for line in input_list [ 1 : ] : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> print_tree ( root ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> split_line = line . split ( ) <NEWLINE> if split_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> node = { <STRING> : None , <STRING> : None , <STRING> : int ( split_line [ 1 ] ) , <STRING> : None } <NEWLINE> insert ( root , node ) <NEWLINE> <DEDENT> elif split_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> if find_tree ( root , int ( split_line [ 1 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif split_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> delete_tree ( root , int ( split_line [ 1 ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> A_ = sorted ( A ) <NEWLINE> max1 = A_ [ - 1 ] <NEWLINE> max2 = A_ [ - 2 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == max1 : <NEWLINE> <INDENT> print ( max2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ ] <NEWLINE> for I in range ( M ) : <NEWLINE> <INDENT> bom = tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> bomb . append ( bom ) <NEWLINE> <DEDENT> X = [ 0 ] * H <COMMENT> <NEWLINE> Y = [ 0 ] * W <COMMENT> <NEWLINE> for h , w in bomb : <NEWLINE> <INDENT> X [ h ] += 1 <NEWLINE> Y [ w ] += 1 <NEWLINE> <DEDENT> maxX = max ( X ) <NEWLINE> maxY = max ( Y ) <NEWLINE> <NL> R = [ h for h , x in enumerate ( X ) if x == maxX ] <COMMENT> <NEWLINE> C = [ w for w , y in enumerate ( Y ) if y == maxY ] <COMMENT> <NEWLINE> <NL> bomb = set ( bomb ) <NEWLINE> for r in R : <NEWLINE> <INDENT> for c in C : <NEWLINE> <INDENT> if ( r , c ) not in bomb : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( maxX + maxY ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( maxX + maxY - 1 ) <NEWLINE>
import queue <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> q = queue . Queue ( ) <NEWLINE> vals = [ [ float ( <STRING> ) ] * w for _ in range ( h ) ] <NEWLINE> vals [ 0 ] [ 0 ] = 0 <NEWLINE> q . put ( [ 0 , 0 ] ) <NEWLINE> <NL> while not q . empty ( ) : <NEWLINE> <INDENT> a = q . get ( ) <NEWLINE> for i , j in ( ( 1 , 0 ) , ( 0 , 1 ) ) : <NEWLINE> <INDENT> x , y = a [ 0 ] + i , a [ 1 ] + j <NEWLINE> if 0 <= x < h and 0 <= y < w : <NEWLINE> <INDENT> if s [ x ] [ y ] == <STRING> and s [ a [ 0 ] ] [ a [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> if vals [ x ] [ y ] > vals [ a [ 0 ] ] [ a [ 1 ] ] + 1 : <NEWLINE> <INDENT> vals [ x ] [ y ] = vals [ a [ 0 ] ] [ a [ 1 ] ] + 1 <NEWLINE> q . put ( [ x , y ] ) <NEWLINE> <DEDENT> <DEDENT> elif vals [ x ] [ y ] > vals [ a [ 0 ] ] [ a [ 1 ] ] : <NEWLINE> <INDENT> vals [ x ] [ y ] = vals [ a [ 0 ] ] [ a [ 1 ] ] <NEWLINE> q . put ( [ x , y ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = vals [ - 1 ] [ - 1 ] <NEWLINE> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> ans += 3 * gcd ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> m = a_ [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = gcd ( m , a_ [ i ] ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i + K ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ False ] * N <NEWLINE> b = [ False ] * M <NEWLINE> <NL> ans = 0 <NEWLINE> now = 0 <NEWLINE> bf = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if now + A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> now += A [ i ] <NEWLINE> ans += 1 <NEWLINE> a [ i ] = True <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if now + B [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> now += B [ i ] <NEWLINE> ans += 1 <NEWLINE> b [ i ] = True <NEWLINE> bf = i <NEWLINE> <NL> <DEDENT> if all ( a ) and all ( b ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if not any ( a ) and not any ( b ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = K - now <NEWLINE> ans2 = ans <NEWLINE> for i in reversed ( range ( N ) ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> a [ i ] = False <NEWLINE> n += A [ i ] <NEWLINE> ans2 -= 1 <NEWLINE> for j in range ( bf , M ) : <NEWLINE> <INDENT> if not b [ j ] : <NEWLINE> <INDENT> if n - B [ j ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b [ j ] = True <NEWLINE> bf = j <NEWLINE> n -= B [ j ] <NEWLINE> ans2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans2 > ans : <NEWLINE> <INDENT> ans = ans2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> <NL> b_count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for pos in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ pos ] == <STRING> : <NEWLINE> <INDENT> b_count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b_count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( n - 2 * i ) : <NEWLINE> <INDENT> if a [ j ] != a [ j + i ] and a [ j + i ] != a [ j + 2 * i ] and a [ j ] != a [ j + 2 * i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = a . count ( <STRING> ) * a . count ( <STRING> ) * a . count ( <STRING> ) - c <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> fib = [ 0 ] * ( n + 1 ) <NEWLINE> if n == 0 or n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> fib [ 0 ] = 1 <NEWLINE> fib [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] <NEWLINE> <NL> <DEDENT> print ( fib [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sysread = sys . stdin . readline <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> def run ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N , M , S = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> to = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> max_m = 2500 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , m , a , b = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> to [ u ] . append ( ( m , b , a ) ) <NEWLINE> to [ m ] . append ( ( u , b , a ) ) <NEWLINE> <NL> <NL> <DEDENT> C , D = [ 0 ] , [ 0 ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c , d = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> C . append ( c ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> queue = [ ] <NEWLINE> <COMMENT> <NL> if S > max_m : S = max_m <NEWLINE> heappush ( queue , ( 0 , 1 , S ) ) <NEWLINE> <NL> state = [ [ 1 << 61 ] * ( max_m + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> time , node , coin = heappop ( queue ) <NEWLINE> if state [ node ] [ coin ] < time : continue <NEWLINE> if coin + C [ node ] <= max_m and time + D [ node ] < state [ node ] [ coin + C [ node ] ] : <NEWLINE> <INDENT> state [ node ] [ coin + C [ node ] ] = time + D [ node ] <NEWLINE> heappush ( queue , ( time + D [ node ] , node , coin + C [ node ] ) ) <NEWLINE> <DEDENT> for n_node , n_time , n_coin in to [ node ] : <NEWLINE> <INDENT> if coin >= n_coin and state [ n_node ] [ coin - n_coin ] > n_time + time : <NEWLINE> <INDENT> state [ n_node ] [ coin - n_coin ] = n_time + time <NEWLINE> heappush ( queue , ( time + n_time , n_node , coin - n_coin ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for s in state [ 2 : ] : <NEWLINE> <INDENT> print ( min ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import heapq as hq <NEWLINE> from itertools import accumulate <NEWLINE> from math import ceil <NEWLINE> N , H = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ab . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ab . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> ma , mb = ab [ 0 ] <NEWLINE> q = [ ab [ i ] [ 1 ] for i in range ( 1 , N ) ] <NEWLINE> q . sort ( reverse = True ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> acc = [ 0 ] + list ( accumulate ( q , lambda x , y : x + y ) ) <NEWLINE> for l in range ( len ( q ) + 1 ) : <NEWLINE> <INDENT> h = H <NEWLINE> cnt = l <NEWLINE> h -= acc [ l ] <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> continue <NEWLINE> <DEDENT> h -= mb <NEWLINE> cnt += 1 <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> continue <NEWLINE> <DEDENT> cnt += ceil ( h / ma ) <NEWLINE> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> pres = [ 0 ] <NEWLINE> for i in nums : <NEWLINE> <INDENT> pres . append ( pres [ - 1 ] + i ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> temp = nums [ i ] * ( pres [ n ] - pres [ i + 1 ] ) <NEWLINE> ans += temp <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> def divisor ( x ) : <NEWLINE> <INDENT> divs = [ ] <NEWLINE> for i in range ( 1 , math . floor ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> divs . append ( i ) <NEWLINE> if i ** 2 != x : <NEWLINE> <INDENT> divs . append ( x // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divs <NEWLINE> <NL> <DEDENT> def evPrimal ( x ) : <NEWLINE> <INDENT> if x < 4 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> divs = [ ] <NEWLINE> for i in range ( 2 , math . floor ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> codiv = set ( divisor ( A ) ) & set ( divisor ( B ) ) <NEWLINE> <NL> for i in codiv : <NEWLINE> <INDENT> if evPrimal ( i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tl = [ 0 ] <NEWLINE> ts = { 0 } <NEWLINE> <NL> t = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = As [ t ] - 1 <NEWLINE> if t in ts : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl . append ( t ) <NEWLINE> ts . add ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> d = tl . index ( t ) <NEWLINE> p = i - d + 1 <NEWLINE> <NL> if K > d : <NEWLINE> <INDENT> idx = ( K - d ) % p + d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = K <NEWLINE> <NL> <DEDENT> print ( tl [ idx ] + 1 ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> def Calcf ( i ) : <NEWLINE> <INDENT> return math . floor ( ( a * i ) / b ) - a * math . floor ( i / b ) <NEWLINE> <NL> <DEDENT> print ( Calcf ( min ( b - 1 , n ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> for b in range ( a , n , a ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) for i in range ( n ) ) <NEWLINE> t = set ( s ) <NEWLINE> <NL> print ( len ( t ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> before = k <NEWLINE> roop = 1 <NEWLINE> cnt = { } <NEWLINE> nxt = 1 <NEWLINE> mp = [ 1 ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if nxt not in cnt : <NEWLINE> <INDENT> cnt [ nxt ] = i <NEWLINE> nxt = a [ nxt ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop = i - cnt [ nxt ] <NEWLINE> before = cnt [ nxt ] - 1 <NEWLINE> break <NEWLINE> <DEDENT> mp . append ( nxt ) <NEWLINE> <DEDENT> print ( mp [ before + ( k - before ) % roop ] ) <NEWLINE>
x , y = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> if y == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif x not in nums : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if i not in nums : <NEWLINE> <INDENT> if abs ( x - i ) < abs ( x - ans ) : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> rr = 0 <NEWLINE> gg = 0 <NEWLINE> bb = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rr += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> gg += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> bb += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = rr * gg * bb <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> for i in range ( min ( j + 1 , n - j ) ) : <NEWLINE> <INDENT> if s [ j - i ] != s [ j ] and s [ j ] != s [ j + i ] and s [ j + i ] != s [ j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> q = N // ( i + 1 ) <NEWLINE> <COMMENT> <NL> ans += ( i + 1 ) * q * ( q + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if N < B : <NEWLINE> <INDENT> max_x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_x = B - 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( int ( A * max_x / B ) - A * int ( max_x / B ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> l = 0 <NEWLINE> r = len ( s ) - 1 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> flg = False <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> l = i + 1 <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( r , l - 1 , - 1 ) : <NEWLINE> <INDENT> if ( s [ j ] == <STRING> ) : <NEWLINE> <INDENT> r = j - 1 <NEWLINE> if flg : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if flg == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = list ( range ( 1 , N + 1 ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> <NL> if M % 2 == 0 : <NEWLINE> <INDENT> for i in range ( M // 2 ) : <NEWLINE> <INDENT> ans . append ( [ i + 1 , M + 1 - i ] ) <NEWLINE> <DEDENT> for i in range ( M // 2 ) : <NEWLINE> <INDENT> ans . append ( [ i + 2 + M , 2 * M + 1 - i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if M % 2 != 0 : <NEWLINE> <INDENT> for i in range ( M // 2 ) : <NEWLINE> <INDENT> ans . append ( [ i + 1 , M - i ] ) <NEWLINE> <DEDENT> for i in range ( M - M // 2 ) : <NEWLINE> <INDENT> ans . append ( [ i + 1 + M , 2 * M + 1 - i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for an in ans : <NEWLINE> <INDENT> print ( an [ 0 ] , an [ 1 ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m , p , z = [ ] , [ ] , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> m . append ( a ) <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> p . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> <DEDENT> m . sort ( ) <NEWLINE> p . sort ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from functools import reduce <NEWLINE> if ( len ( p ) or K % 2 == 0 ) and K < len ( m ) + len ( p ) or K == len ( m ) + len ( p ) and len ( m ) % 2 == 0 : <NEWLINE> <INDENT> r = 1 <NEWLINE> i , j = 0 , 0 <NEWLINE> while i + j < K : <NEWLINE> <INDENT> if i < len ( m ) - 1 and i + j < K - 1 and ( j >= len ( p ) - 1 or m [ i ] * m [ i + 1 ] > p [ - j - 1 ] * p [ - j - 2 ] ) : <NEWLINE> <INDENT> r = r * m [ i ] * m [ i + 1 ] % mod <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = r * p [ - j - 1 ] % mod <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <DEDENT> elif z : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( reduce ( lambda x , y : x * y % mod , ( m + p ) [ - K : ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = r * g * b <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> si = s [ i ] <NEWLINE> for j in range ( i + 1 , i + ( n - i - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> if si != s [ j ] : <NEWLINE> <INDENT> sj = s [ j ] <NEWLINE> k = j + ( j - i ) <NEWLINE> if s [ k ] != si and s [ k ] != sj : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
i = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> count = 0 <NEWLINE> h = list ( ) <NEWLINE> c = [ 0 for i in range ( 0 , i [ 1 ] + 1 ) ] <NEWLINE> while count < i [ 0 ] : <NEWLINE> <INDENT> l = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> l . append ( sum ( l ) ) <NEWLINE> h . append ( l ) <NEWLINE> for j , c_ in enumerate ( l ) : <NEWLINE> <INDENT> c [ j ] += c_ <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> for r_ in h : <NEWLINE> <INDENT> print ( <STRING> % r_ [ 0 ] , end = <STRING> ) <NEWLINE> for c_ in r_ [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> % c_ , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> % c [ 0 ] , end = <STRING> ) <NEWLINE> for c_ in c [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> % c_ , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = ( ans * i ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> P1 = [ ] <NEWLINE> P2 = [ ] <NEWLINE> P3 = [ ] <NEWLINE> for a , b in zip ( map ( int , input ( ) . split ( ) ) , map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> t = abs ( a - b ) <NEWLINE> P1 . append ( t ) <NEWLINE> P2 . append ( t ** 2 ) <NEWLINE> P3 . append ( t ** 3 ) <NEWLINE> <DEDENT> print ( <STRING> . format ( sum ( P1 ) ) ) <NEWLINE> print ( sum ( P2 ) ** ( 1 / 2 ) ) <NEWLINE> print ( sum ( P3 ) ** ( 1 / 3 ) ) <NEWLINE> print ( <STRING> . format ( max ( P1 ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_l = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> dp = [ 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if 1 not in a_l : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> for i in a_l : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> if 2 not in a_l : <NEWLINE> <INDENT> dp [ 2 ] = dp [ 0 ] + dp [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 2 ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if dp [ i ] != 0 : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from math import gcd <NEWLINE> <NL> nums = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <NL> gcd_dict = { } <NEWLINE> <NL> for i in range ( 1 , nums + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , nums + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , nums + 1 ) : <NEWLINE> <INDENT> result += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> BC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> <COMMENT> <NL> BC = sorted ( BC , reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> m = A [ 0 ] <NEWLINE> D = [ ] <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> if c > m : <NEWLINE> <INDENT> _ = [ D . append ( c ) for i in range ( b ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if len ( D ) > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> D . append ( 0 ) <NEWLINE> <NL> for i , d in enumerate ( D ) : <NEWLINE> <INDENT> if i >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ i ] < d : <NEWLINE> <INDENT> A [ i ] = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
<COMMENT> <NL> price = [ int ( input ( ) ) for p in range ( int ( input ( ) ) ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> min_ = price [ 0 ] <NEWLINE> max_ = - 1000000000000 <NEWLINE> for i in range ( 1 , len ( price ) ) : <NEWLINE> <INDENT> if price [ i ] - min_ > max_ : <NEWLINE> <INDENT> max_ = price [ i ] - min_ <NEWLINE> <NL> <DEDENT> if price [ i ] < min_ : <NEWLINE> <INDENT> min_ = price [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_ ) <NEWLINE> <NL>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , k = I ( ) <NEWLINE> p = l ( ) <NEWLINE> x = list ( itertools . accumulate ( p ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( ( p [ 0 ] + 1 ) / 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if n == k : <NEWLINE> <INDENT> print ( ( x [ - 1 ] + k ) / 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n - k + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , x [ i + k - 1 ] - x [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ( ans + k ) / 2 ) <NEWLINE>
W = <STRING> <NEWLINE> R = <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> numR = C . count ( R ) <NEWLINE> result = 0 <NEWLINE> for i in range ( numR ) : <NEWLINE> <INDENT> if C [ i ] == W : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <NL> <DEDENT>
N , * ABC = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> yes_flag = True <NEWLINE> ans_list = [ ] <NEWLINE> <NL> if sum ( ABC ) == 0 : <NEWLINE> <INDENT> yes_flag = False <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if not yes_flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> u = ord ( s [ i ] [ 0 ] ) - 65 <NEWLINE> v = ord ( s [ i ] [ 1 ] ) - 65 <NEWLINE> if ABC [ u ] + ABC [ v ] == 0 : <NEWLINE> <INDENT> yes_flag = False <NEWLINE> <DEDENT> elif ABC [ u ] + ABC [ v ] == 1 : <NEWLINE> <INDENT> if ABC [ u ] == 1 : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 1 ] ] <NEWLINE> ABC [ u ] -= 1 <NEWLINE> ABC [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 0 ] ] <NEWLINE> ABC [ v ] -= 1 <NEWLINE> ABC [ u ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif ABC [ u ] + ABC [ v ] == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> if ABC [ u ] * ABC [ v ] == 1 : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> if ABC [ u ] > 0 : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 0 ] ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] [ 1 ] in s [ i + 1 ] : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 1 ] ] <NEWLINE> ABC [ u ] -= 1 <NEWLINE> ABC [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 0 ] ] <NEWLINE> ABC [ v ] -= 1 <NEWLINE> ABC [ u ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ABC [ u ] > 1 : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 1 ] ] <NEWLINE> ABC [ u ] -= 1 <NEWLINE> ABC [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 0 ] ] <NEWLINE> ABC [ v ] -= 1 <NEWLINE> ABC [ u ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ABC [ u ] > 1 : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 1 ] ] <NEWLINE> ABC [ u ] -= 1 <NEWLINE> ABC [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list += [ s [ i ] [ 0 ] ] <NEWLINE> ABC [ v ] -= 1 <NEWLINE> ABC [ u ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if yes_flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> K = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ] <NEWLINE> M = 998244353 <NEWLINE> <NL> dp = [ 0 ] * N <NEWLINE> dp [ 1 ] = 1 <NEWLINE> prefix = [ 1 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> cur = 0 <NEWLINE> for L , R in K : <NEWLINE> <INDENT> a = i - R <NEWLINE> b = i - L <NEWLINE> if b < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cur += prefix [ b ] - ( prefix [ a - 1 ] if a - 1 >= 0 else 0 ) <NEWLINE> <DEDENT> dp [ i ] = cur % M <NEWLINE> prefix [ i ] = prefix [ i - 1 ] + dp [ i ] <NEWLINE> prefix [ i ] %= M <NEWLINE> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> t = len ( s ) <NEWLINE> <NL> x = [ ] <NEWLINE> y = 0 <NEWLINE> <NL> while 10 ** y % 2019 not in x : <NEWLINE> <INDENT> x . append ( 10 ** y % 2019 ) <NEWLINE> y += 1 <NEWLINE> <NL> <DEDENT> z = len ( x ) <NEWLINE> <NL> m = [ 0 for i in range ( 2019 ) ] <NEWLINE> m [ 0 ] = 1 <NEWLINE> a = 0 <NEWLINE> for i in reversed ( range ( 0 , t ) ) : <NEWLINE> <INDENT> a += x [ ( t - i - 1 ) % z ] * ( int ( s [ i ] ) % 2019 ) <NEWLINE> a = a % 2019 <NEWLINE> m [ a ] += 1 <NEWLINE> <NL> <DEDENT> def triangle ( n ) : <NEWLINE> <INDENT> if n > 1 : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> p = list ( map ( triangle , m ) ) <NEWLINE> <COMMENT> <NL> print ( sum ( p ) ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> point_div = abs ( a - b ) <NEWLINE> speed_div = v - w <NEWLINE> if speed_div * t >= point_div : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( float ( r * r * math . pi ) , float ( r * 2 * math . pi ) ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if a >= k : <NEWLINE> <INDENT> ans = k <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= a <NEWLINE> ans = a <NEWLINE> <DEDENT> k -= b <NEWLINE> if k > 0 : <NEWLINE> <INDENT> ans -= k <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> a = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> b = [ 0 for i in range ( m ) ] <NEWLINE> c = [ 0 for i in range ( n ) ] <NEWLINE> for s in range ( 0 , n ) : <NEWLINE> <INDENT> a [ s ] = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <DEDENT> for s in range ( 0 , m ) : <NEWLINE> <INDENT> b [ s ] = int ( input ( ) ) <NEWLINE> <DEDENT> for s in range ( 0 , n ) : <NEWLINE> <INDENT> for t in range ( 0 , m ) : <NEWLINE> <INDENT> c [ s ] += a [ s ] [ t ] * b [ t ] <NEWLINE> <DEDENT> <DEDENT> for t in range ( 0 , n ) : <NEWLINE> <INDENT> print ( <STRING> % c [ t ] ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 119 , 120 , 1 ) : <NEWLINE> <INDENT> A = a ** 5 <NEWLINE> for b in range ( - 119 , 120 , 1 ) : <NEWLINE> <INDENT> B = b ** 5 <NEWLINE> if ( A - B == X ) : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> circle = r * 2 * math . pi <NEWLINE> area = ( r ** 2 ) * math . pi <NEWLINE> <NL> print ( <STRING> . format ( area , circle ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n - 1 , 0 , - 2 ) : <NEWLINE> <INDENT> print ( str ( l [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> print ( str ( l [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 , - 1 , - 2 ) : <NEWLINE> <INDENT> print ( str ( l [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> print ( str ( l [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = [ i for i in map ( int , input ( ) . split ( <STRING> ) ) ] <NEWLINE> <NL> hist = [ - 1 for i in range ( N ) ] <NEWLINE> route = [ ] <NEWLINE> loop = [ ] <NEWLINE> <NL> jump = 0 <NEWLINE> cur = A [ 0 ] - 1 <NEWLINE> route . append ( 0 ) <NEWLINE> hist [ 0 ] = jump <NEWLINE> while hist [ cur ] == - 1 : <NEWLINE> <INDENT> jump = jump + 1 <NEWLINE> route . append ( cur ) <NEWLINE> hist [ cur ] = jump <NEWLINE> cur = A [ cur ] - 1 <NEWLINE> <NL> <DEDENT> loop = route [ hist [ cur ] : ] <NEWLINE> <NL> <COMMENT> <NL> <NL> if K < len ( route ) : <NEWLINE> <INDENT> print ( route [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - len ( route ) <NEWLINE> <COMMENT> <NL> K = K % len ( loop ) <NEWLINE> <COMMENT> <NL> print ( loop [ K ] + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> N , d = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> a = sorted ( [ ( b , x , y ) for l in sys . stdin . readlines ( ) for x , y , b in ( map ( int , l . split ( ) ) , ) ] ) <NEWLINE> x_max , x_min , y_max , y_min = [ ] , [ ] , [ ] , [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> for b , x , y in a : <NEWLINE> <INDENT> heappush ( x_max , ( - x , b ) ) <NEWLINE> heappush ( x_min , ( x , b ) ) <NEWLINE> heappush ( y_max , ( - y , b ) ) <NEWLINE> heappush ( y_min , ( y , b ) ) <NEWLINE> for _a in ( x_max , x_min , y_max , y_min ) : <NEWLINE> <INDENT> while _a [ 0 ] [ 1 ] < b - d : <NEWLINE> <INDENT> heappop ( _a ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , ( - x_max [ 0 ] [ 0 ] - x_min [ 0 ] [ 0 ] ) * ( - y_max [ 0 ] [ 0 ] - y_min [ 0 ] [ 0 ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> q = [ 0 ] * 13 <NEWLINE> i = 10 <NEWLINE> n = N <NEWLINE> cflag = 0 <NEWLINE> zflag = 0 <NEWLINE> str = [ ] <NEWLINE> while i != - 1 : <NEWLINE> <INDENT> q [ i ] = n // 26 ** i <NEWLINE> mod = n % 26 ** i <NEWLINE> n = mod <NEWLINE> i -= 1 <NEWLINE> <DEDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> if q [ i ] == 0 : <NEWLINE> <INDENT> zflag = 1 <NEWLINE> for j in range ( i , 13 ) : <NEWLINE> <INDENT> if q [ j ] != 0 : <NEWLINE> <INDENT> zflag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if zflag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif cflag == 1 : <NEWLINE> <INDENT> str . append ( <STRING> ) <NEWLINE> cflag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> str . append ( <STRING> ) <NEWLINE> cflag = 1 <NEWLINE> <DEDENT> <DEDENT> elif q [ i ] == 1 and cflag == 1 : <NEWLINE> <INDENT> zflag = 1 <NEWLINE> for j in range ( i + 1 , 13 ) : <NEWLINE> <INDENT> if q [ j ] != 0 : <NEWLINE> <INDENT> zflag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if zflag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> str . append ( <STRING> ) <NEWLINE> cflag = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> str . append ( chr ( q [ i ] + 96 - cflag ) ) <NEWLINE> cflag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> i = len ( str ) - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> if [ str ] == <STRING> : <NEWLINE> <INDENT> i -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> print ( str [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str [ i ] , end = <STRING> ) <NEWLINE> i -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> count = 0 <NEWLINE> <NL> if x - k * d > 0 : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <NL> <DEDENT> elif x - k * d == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count = x // d + 1 <NEWLINE> x -= count * d <NEWLINE> <NL> if ( k - count ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( x + d ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> pay = 1000 * ( i + 1 ) <NEWLINE> change = 0 <NEWLINE> if pay >= n : <NEWLINE> <INDENT> change = pay - n <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( change ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> ans = A [ 0 ] <NEWLINE> N -= 2 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if N >= 2 : <NEWLINE> <INDENT> ans += A [ i ] * 2 <NEWLINE> N -= 2 <NEWLINE> <DEDENT> elif N == 1 : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> N -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= b : <NEWLINE> <INDENT> print ( int ( ( b - 1 ) / b * a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n / b * a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> b = [ j - i for i , j in enumerate ( a , start = 1 ) ] <NEWLINE> <COMMENT> <NL> count = { } <NEWLINE> for i , j in enumerate ( a , start = 1 ) : <NEWLINE> <INDENT> num = - i - j <NEWLINE> if num not in count : <NEWLINE> <INDENT> count [ num ] = 0 <NEWLINE> <DEDENT> count [ num ] += 1 <NEWLINE> <DEDENT> result = sum ( [ count . get ( i , 0 ) for i in b ] ) <NEWLINE> print ( result ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MOD = 10 ** 9 + 7 ; EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> <NL> n = iinput ( ) <NEWLINE> a = iarr ( ) <NEWLINE> <NL> cum = [ ] ; sum = 0 <NEWLINE> for num in a : sum += num ; cum . append ( sum ) <NEWLINE> <NL> ans = 1 <NEWLINE> now = 1 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> next = min ( 2 * ( now - a [ i ] ) , cum [ n ] - cum [ i ] ) <NEWLINE> now = next <NEWLINE> if n == i and next < 0 : ans = - 1 ; break <NEWLINE> if n != i and next <= 0 : ans = - 1 ; break <NEWLINE> ans += next <NEWLINE> <NL> <DEDENT> if a [ n ] > 2 ** n : ans = - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = list ( range ( 1 , n + 1 ) ) <NEWLINE> ab = [ list ( ) for _ in range ( m ) ] <NEWLINE> <NL> p = [ ] <NEWLINE> <NL> ih = dict ( zip ( li , h ) ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = ih [ a ] <NEWLINE> d = ih [ b ] <NEWLINE> if c > d : <NEWLINE> <INDENT> p . append ( b ) <NEWLINE> <DEDENT> elif d > c : <NEWLINE> <INDENT> p . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . append ( a ) <NEWLINE> p . append ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - len ( set ( p ) ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> p_under = list ( filter ( lambda v : v <= x , p ) ) <NEWLINE> p_upper = list ( filter ( lambda v : v >= x , p ) ) <NEWLINE> p_under . sort ( reverse = True ) <NEWLINE> p_upper . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if x - cnt not in p_under : <NEWLINE> <INDENT> print ( x - cnt ) <NEWLINE> break <NEWLINE> <DEDENT> if x + cnt not in p_upper : <NEWLINE> <INDENT> print ( x + cnt ) <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 0 ] * ( n - 1 ) <NEWLINE> k = 0 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] - h [ i + 1 ] >= 0 : <NEWLINE> <INDENT> d [ k ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( d ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> assert len ( a ) == n <NEWLINE> <NL> <COMMENT> <NL> p = list ( range ( n ) ) <NEWLINE> p . sort ( key = lambda i : a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - i ) : <NEWLINE> <INDENT> dp [ j ] = max ( dp [ j ] + a [ p [ i ] ] * abs ( p [ i ] - ( j + i ) ) , <NEWLINE> <INDENT> dp [ j + 1 ] + a [ p [ i ] ] * abs ( p [ i ] - j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> val = list ( str ( i ) . zfill ( 3 ) ) <NEWLINE> k = val [ count ] <NEWLINE> for j in s : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count <= 2 : <NEWLINE> <INDENT> k = val [ count ] <NEWLINE> <DEDENT> elif count == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> L = input ( ) . split ( ) <NEWLINE> L = [ int ( s ) for s in L ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> l = [ int ( s ) for s in l ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> k = N - 1 <NEWLINE> while ( 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = int ( ( j + k ) / 2 ) <NEWLINE> if l [ i ] == L [ a ] or l [ i ] == L [ j ] or l [ i ] == L [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif k == j + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif l [ i ] > L [ a ] : <NEWLINE> <INDENT> j = a <NEWLINE> <DEDENT> elif l [ i ] < L [ a ] : <NEWLINE> <INDENT> k = a <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def dist ( x1 , x2 , y1 , y2 ) : <NEWLINE> <INDENT> return ( y1 - y2 ) * ( y1 - y2 ) + ( x1 - x2 ) * ( x1 - x2 ) <NEWLINE> <NL> <NL> <DEDENT> def farthest ( x , y ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> point = ( - 1 , - 1 ) <NEWLINE> for u , v in X : <NEWLINE> <INDENT> d = dist ( x , u , y , v ) <NEWLINE> if d > ret : <NEWLINE> <INDENT> ret = d <NEWLINE> point = u , v <NEWLINE> <DEDENT> <DEDENT> return ret , point <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = [ ] <NEWLINE> for _ in [ 0 ] * N : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> x = ( max ( x for x , y in X ) - min ( x for x , y in X ) ) / 2 <NEWLINE> y = ( max ( y for x , y in X ) - min ( y for x , y in X ) ) / 2 <NEWLINE> x = Decimal ( str ( x ) ) <NEWLINE> y = Decimal ( str ( y ) ) <NEWLINE> step = Decimal ( <STRING> ) <NEWLINE> o = 1 <NEWLINE> eps = Decimal ( <STRING> ) <NEWLINE> while o > eps : <NEWLINE> <INDENT> _ , ( u , v ) = farthest ( x , y ) <NEWLINE> x += ( u - x ) * step <NEWLINE> y += ( v - y ) * step <NEWLINE> step *= Decimal ( <STRING> ) <NEWLINE> o = ( abs ( u - x ) + abs ( x - y ) ) * step <NEWLINE> <NL> <DEDENT> ans , _ = farthest ( x , y ) <NEWLINE> ans **= Decimal ( <STRING> ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> ok = True <NEWLINE> for i in a : <NEWLINE> <INDENT> if ok == True : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if all ( <STRING> . count ( c ) == 1 for c in S [ i : j + 1 ] ) : <NEWLINE> <INDENT> ans = max ( ans , j - i + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from typing import List <NEWLINE> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def binary_search ( A : List [ int ] , key : int ) -> int : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( A ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = math . floor ( ( left + right ) / 2 ) <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> elif key < A [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if binary_search ( S , t ) != - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 2020202020 <NEWLINE> a = 0 <NEWLINE> b = sum ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += s [ i ] <NEWLINE> b -= s [ i ] <NEWLINE> ans = min ( ans , abs ( a - b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def edu_dp_a_frog2 ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( [ dp [ i - j ] + abs ( h [ i ] - h [ i - j ] ) for j in range ( 1 , min ( i + 1 , k + 1 ) ) ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> edu_dp_a_frog2 ( ) <NEWLINE>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> dp = [ 0 for i in range ( 2019 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> r = 0 <NEWLINE> for i in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> r += int ( s [ - i ] ) * pow ( 10 , i - 1 , 2019 ) <NEWLINE> r %= 2019 <NEWLINE> dp [ r ] += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( [ ( i * ( i - 1 ) ) // 2 for i in dp ] ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> possesion = 1000 <NEWLINE> num_stock = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( a_list ) - 1 ) : <NEWLINE> <INDENT> a_today = a_list [ i ] <NEWLINE> for a in a_list [ i + 1 : ] : <NEWLINE> <INDENT> a_next = a <NEWLINE> if a != a_today : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if a_next == a_today : <NEWLINE> <INDENT> possesion += num_stock * a_list [ - 1 ] <NEWLINE> print ( possesion ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if a_today < a_next : <NEWLINE> <COMMENT> <NL> <INDENT> possesion_yesterday = possesion <NEWLINE> possesion = possesion % a_today <NEWLINE> num_stock += possesion_yesterday // a_today <NEWLINE> <DEDENT> if a_today > a_next : <NEWLINE> <COMMENT> <NL> <INDENT> possesion += num_stock * a_today <NEWLINE> num_stock = 0 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> possesion += num_stock * a_list [ - 1 ] <NEWLINE> print ( possesion ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 == 1 : ans = [ [ 1 + i , n - i ] for i in range ( n // 2 ) ] <NEWLINE> else : ans = [ [ 1 + i , n - i ] for i in range ( n // 4 ) ] + [ [ n // 2 + 1 + i , n // 2 - 1 - i ] for i in range ( n // 2 - n // 4 - 1 ) ] <NEWLINE> for i in range ( m ) : print ( ans [ i ] [ 0 ] , ans [ i ] [ 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> kk = 1 <NEWLINE> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans_ = 0 <NEWLINE> k = x <NEWLINE> for y in range ( 999 ) : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> x /= 2 <NEWLINE> ans_ += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans_ > ans : <NEWLINE> <INDENT> ans = ans_ <NEWLINE> kk = k <NEWLINE> <DEDENT> <DEDENT> print ( kk ) <NEWLINE>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> p = a * b <COMMENT> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> hoge = a <NEWLINE> a = b % a <NEWLINE> b = hoge <NEWLINE> if a == 0 : <NEWLINE> <INDENT> gcd = b <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> lcm = p // gcd <NEWLINE> print ( gcd , lcm ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> ans = 0 <NEWLINE> N = int ( pin ( ) ) <NEWLINE> A = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> t = max ( A ) <NEWLINE> dp = [ True ] * t <NEWLINE> for i in A : <NEWLINE> <INDENT> if dp [ i - 1 ] : <NEWLINE> <INDENT> n = 2 * i <NEWLINE> while n <= t : <NEWLINE> <INDENT> dp [ n - 1 ] = False <NEWLINE> n += i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in A : <NEWLINE> <INDENT> if c [ k ] == 1 and dp [ k - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> while H > 2 : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> H -= 1 <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = [ 0 ] * ( 100000 + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ma [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = c * ma [ b ] - ma [ b ] * b <NEWLINE> ma [ c ] += ma [ b ] <NEWLINE> ma [ b ] = 0 <NEWLINE> s += diff <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import datetime <NEWLINE> import string <NEWLINE> import re <NEWLINE> import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 7 <NEWLINE> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if s % K == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> s = ( s % K ) * 10 + 7 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A = [ ] <NEWLINE> a1 = [ ] <NEWLINE> a2 = [ ] <NEWLINE> a3 = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for K in range ( 3 ) : <NEWLINE> <INDENT> A . append ( a [ K ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> for k in range ( 9 ) : <NEWLINE> <INDENT> if b == A [ k ] : <NEWLINE> <INDENT> A [ k ] = 0 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> if 0 <= i <= 2 : <NEWLINE> <INDENT> a1 . append ( A [ i ] ) <NEWLINE> <DEDENT> elif 3 <= i <= 5 : <NEWLINE> <INDENT> a2 . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a3 . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> x = 0 <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if a1 [ i ] == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> if a2 [ i ] == 0 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> if a3 [ i ] == 0 : <NEWLINE> <INDENT> z += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if x == 3 or y == 3 or z == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if a1 [ i ] == 0 and a2 [ i ] == 0 and a3 [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if a2 [ 1 ] == 0 : <NEWLINE> <INDENT> if a1 [ 0 ] == 0 and a3 [ 2 ] == 0 or a1 [ 2 ] == 0 and a3 [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 5 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> repn = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> repn [ u - 1 ] . append ( v - 1 ) <NEWLINE> repn [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> length = [ 0 ] * ( N + 1 ) <NEWLINE> dp = [ - 1 ] <NEWLINE> <NL> <STRING> <NEWLINE> <NL> def dfs ( v , p = N ) : <NEWLINE> <INDENT> if A [ v ] > dp [ - 1 ] : <NEWLINE> <INDENT> dp . append ( A [ v ] ) <NEWLINE> length [ v ] = length [ p ] + 1 <NEWLINE> for u in repn [ v ] : <NEWLINE> <INDENT> if u == p : continue <NEWLINE> dfs ( u , v ) <NEWLINE> <DEDENT> dp . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> length [ v ] = length [ p ] <NEWLINE> idx = bisect_left ( dp , A [ v ] ) <COMMENT> <NEWLINE> old = dp [ idx ] <NEWLINE> dp [ idx ] = A [ v ] <NEWLINE> for u in repn [ v ] : <NEWLINE> <INDENT> if u == p : continue <NEWLINE> dfs ( u , v ) <NEWLINE> <DEDENT> dp [ idx ] = old <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> length . pop ( ) <NEWLINE> for ans in length : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> class union_find : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . r = np . ones ( N ) * - 1 <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . r [ x ] < 0 : <NEWLINE> <INDENT> return int ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . r [ x ] = self . root ( int ( self . r [ x ] ) ) <NEWLINE> return int ( self . r [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . r [ x ] += self . r [ y ] <NEWLINE> self . r [ y ] = int ( x ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . r [ self . root ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> Union = union_find ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Union . unite ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> Y = - min ( Union . r ) <NEWLINE> print ( int ( Y ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math , sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> a = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> g = math . gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> g = math . gcd ( g , a [ i ] ) <NEWLINE> <DEDENT> M = max ( a ) <NEWLINE> acc = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acc = math . gcd ( acc , a [ i ] ) <NEWLINE> <DEDENT> if acc != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> LIMIT = max ( a ) <NEWLINE> minPrime = [ 0 ] * ( LIMIT + 1 ) <NEWLINE> minPrime [ 1 ] = 1 <NEWLINE> def make ( ) : <NEWLINE> <INDENT> for i in range ( 2 , LIMIT + 1 ) : <NEWLINE> <INDENT> if minPrime [ i ] == 0 : <NEWLINE> <INDENT> minPrime [ i ] = i <NEWLINE> <COMMENT> <NL> for j in range ( i + i , LIMIT + 1 , i ) : <NEWLINE> <COMMENT> <NL> <INDENT> if minPrime [ j ] == 0 : <NEWLINE> <INDENT> minPrime [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> make ( ) <NEWLINE> def factrial ( N ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> while minPrime [ N ] != N : <NEWLINE> <INDENT> ret . append ( minPrime [ N ] ) <NEWLINE> N = N // minPrime [ N ] <NEWLINE> <DEDENT> if N != 1 : <NEWLINE> <INDENT> ret . append ( N ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> judge = set ( [ ] ) <NEWLINE> <NL> for e in a : <NEWLINE> <INDENT> asf = set ( factrial ( e ) ) <NEWLINE> if judge & asf != set ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> judge |= asf <NEWLINE> <COMMENT> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def call ( n ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if int ( x ) % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x /= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> call ( n ) <NEWLINE>
MOD = 998244353 <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> inv_table = [ 0 ] + [ 1 ] <NEWLINE> for i in range ( 2 , K + 2 ) : <NEWLINE> <INDENT> inv_table . append ( - ( MOD // i ) * inv_table [ MOD % i ] % MOD ) <NEWLINE> <NL> <DEDENT> def powmod ( a , p ) : <NEWLINE> <INDENT> if p == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pow2 = powmod ( a , p // 2 ) <NEWLINE> if p % 2 == 0 : <NEWLINE> <INDENT> return ( pow2 ** 2 ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( a * pow2 ** 2 ) % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def invmod ( a ) : <NEWLINE> <INDENT> return powmod ( a , MOD - 2 ) <NEWLINE> <NL> <DEDENT> if M == 1 and K < N - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif K == N - 1 : <NEWLINE> <INDENT> print ( powmod ( M , N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> term1 = powmod ( M - 1 , N - 1 ) <NEWLINE> term2 = 1 <NEWLINE> inv_M1 = invmod ( M - 1 ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> ans += term1 * term2 <NEWLINE> ans %= MOD <NEWLINE> term1 = term1 * inv_M1 % MOD <NEWLINE> term2 = term2 * ( N - i - 1 ) * inv_table [ i + 1 ] % MOD <NEWLINE> <NL> <DEDENT> answer = M * ans % MOD <NEWLINE> print ( answer ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = [ 1 for i in range ( N ) ] <NEWLINE> for a in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> ans [ B - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A - 1 ] == H [ B - 1 ] : <NEWLINE> <INDENT> ans [ B - 1 ] = 0 <NEWLINE> ans [ A - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ A - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
<NL> class UnionFind : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def is_same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> sub_friend = [ 1 ] * N <COMMENT> <NEWLINE> <NL> frind = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> frind [ a ] . append ( b ) <NEWLINE> frind [ b ] . append ( a ) <NEWLINE> sub_friend [ a ] += 1 <NEWLINE> sub_friend [ b ] += 1 <NEWLINE> <NL> <DEDENT> block = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> c , d = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> block [ c ] . append ( d ) <NEWLINE> block [ d ] . append ( c ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for to in frind [ i ] : <NEWLINE> <INDENT> uf . union ( i , to ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ uf . size ( i ) - sub_friend [ i ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for bl in block [ i ] : <NEWLINE> <INDENT> if uf . is_same ( i , bl ) : <NEWLINE> <INDENT> ans [ i ] -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> s = np . array ( list ( input ( ) ) ) <NEWLINE> t = np . array ( list ( input ( ) ) ) <NEWLINE> dp = np . zeros ( ( len ( s ) + 1 , len ( t ) + 1 ) , dtype = int ) <NEWLINE> <NL> equal = s [ : , None ] == t [ None , : ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> dp [ i + 1 , 1 : ] = np . maximum ( dp [ i , : - 1 ] + equal [ i ] , dp [ i , 1 : ] ) <NEWLINE> dp [ i + 1 ] = np . maximum . accumulate ( dp [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> i = len ( s ) <NEWLINE> j = len ( t ) <NEWLINE> ans = [ ] <NEWLINE> <NL> while i > 0 and j > 0 : <NEWLINE> <INDENT> if s [ i - 1 ] == t [ j - 1 ] : <NEWLINE> <INDENT> ans . append ( s [ i - 1 ] ) <NEWLINE> i -= 1 <NEWLINE> j -= 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] == dp [ i - 1 ] [ j ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans [ : : - 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> dic = { } <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in dic . keys ( ) : <NEWLINE> <INDENT> cnt += dic [ s ] <NEWLINE> dic [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> memo = [ 0 ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> memo [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in memo : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) . strip ( ) ) <NEWLINE> s = input ( ) . strip ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * ( n - r - g ) <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> for d in range ( 1 , ( n - i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + d ] and s [ i ] != s [ i + d + d ] and s [ i + d ] != s [ i + d + d ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = np . zeros ( W + 1 , np . int64 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> np . maximum ( dp [ w : ] , dp [ : - w ] + v , out = dp [ w : ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <NL> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> sum += a [ i ] * s <NEWLINE> <NL> <DEDENT> ans = sum % mod <NEWLINE> print ( ans ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> n , m = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> n = int ( n ) ; m = int ( m ) <NEWLINE> <NL> c = n <NEWLINE> <NL> a = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( line ) <NEWLINE> c -= 1 <NEWLINE> if c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> c = m <NEWLINE> <NL> b = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> b . append ( line ) <NEWLINE> c -= 1 <NEWLINE> if c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] . strip ( ) . split ( <STRING> ) <NEWLINE> for j in range ( 0 , len ( a [ i ] ) ) : <NEWLINE> <INDENT> a [ i ] [ j ] = int ( a [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( b ) ) : <NEWLINE> <INDENT> b [ i ] = int ( b [ i ] . strip ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( 0 , m ) : <NEWLINE> <INDENT> sum += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from math import ceil , log <NEWLINE> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> k2 = int ( log ( ceil ( k / 10 ) , 3 ) ) + 1 <NEWLINE> def getlun ( n , keta , last ) : <NEWLINE> <INDENT> lunluns . append ( n ) <NEWLINE> if keta > k2 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 = n * 10 + last <NEWLINE> getlun ( l1 , keta + 1 , last ) <NEWLINE> if last > 0 : <NEWLINE> <INDENT> l2 = n * 10 + last - 1 <NEWLINE> getlun ( l2 , keta + 1 , last - 1 ) <NEWLINE> <DEDENT> if last < 9 : <NEWLINE> <INDENT> l3 = n * 10 + last + 1 <NEWLINE> getlun ( l3 , keta + 1 , last + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> lunluns = [ ] <NEWLINE> for i1 in range ( 1 , 10 ) : <NEWLINE> <INDENT> getlun ( i1 , 0 , i1 ) <NEWLINE> <DEDENT> lunluns . sort ( ) <NEWLINE> print ( lunluns [ k - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = n // i <NEWLINE> ans += i * k * ( k + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ 0 ] <NEWLINE> visitedSet = { 0 } <NEWLINE> flag = False <NEWLINE> loopStart = 0 <NEWLINE> loopCycle = 0 <NEWLINE> currentTown = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> currentTown = a [ visited [ - 1 ] ] - 1 <NEWLINE> if currentTown in visitedSet : <NEWLINE> <INDENT> flag = True <NEWLINE> loopStart = visited . index ( currentTown ) <NEWLINE> loopCycle = i + 1 - loopStart <NEWLINE> break <NEWLINE> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> print ( currentTown + 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> visited . append ( currentTown ) <NEWLINE> visitedSet . add ( currentTown ) <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> print ( visited [ loopStart + ( k - loopStart ) % loopCycle ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> <NL> count = len ( str ( n ) ) <NEWLINE> ans = <STRING> <NEWLINE> if count % 2 == 0 : <NEWLINE> <INDENT> for i in range ( count - 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ( count // 2 ) * <STRING> <NEWLINE> try : <NEWLINE> <INDENT> ans = n - int ( ans ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> ans = n <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
def abc177_c_2 ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> x = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = ( ans + a [ i ] * x ) % mod <NEWLINE> x = ( x + a [ i ] ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc177_c_2 ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> aaa = list ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> aaa . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for a in aaa : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> str_list = [ ] <NEWLINE> str_list = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> print ( <STRING> + str ( str_list . count ( ( <STRING> ) ) ) ) <NEWLINE> print ( <STRING> + str ( str_list . count ( ( <STRING> ) ) ) ) <NEWLINE> print ( <STRING> + str ( str_list . count ( ( <STRING> ) ) ) ) <NEWLINE> print ( <STRING> + str ( str_list . count ( ( <STRING> ) ) ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> D = defaultdict ( int ) <NEWLINE> D [ 0 ] += 1 <NEWLINE> x = 0 <NEWLINE> d = 1 <NEWLINE> for s in reversed ( S ) : <NEWLINE> <INDENT> x = ( x + int ( s ) * d ) % 2019 <NEWLINE> D [ x ] += 1 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> print ( sum ( x * ( x - 1 ) // 2 for x in D . values ( ) ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> if a >= b : <NEWLINE> <INDENT> while a >= b : <NEWLINE> <INDENT> if K > 0 : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b >= c and flag == 0 : <NEWLINE> <INDENT> while b >= c : <NEWLINE> <INDENT> if K > 0 : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> newA = sorted ( A ) <NEWLINE> <NL> P = 1 <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P = P * newA [ i ] <NEWLINE> if P == 0 : <NEWLINE> <INDENT> print ( P ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif P > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( P ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = [ 0 , 0 , 0 ] <NEWLINE> col1 = [ ] <NEWLINE> col2 = [ ] <NEWLINE> col3 = [ ] <NEWLINE> res = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> col1 . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> col2 . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> col3 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = len ( col1 ) * len ( col2 ) * len ( col3 ) <NEWLINE> <NL> for i in range ( ( n + 1 ) // 2 ) : <NEWLINE> <INDENT> for j in range ( n - ( i + 1 ) * 2 ) : <NEWLINE> <INDENT> x = s [ j ] <NEWLINE> y = s [ j + i + 1 ] <NEWLINE> z = s [ j + ( i + 1 ) * 2 ] <NEWLINE> if x == y or y == z or x == z : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = res - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def cross_product ( vect1 , vect2 ) : <NEWLINE> <INDENT> return vect1 [ 0 ] * vect2 [ 1 ] - vect1 [ 1 ] * vect2 [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> def vector_plus ( vect1 , vect2 ) : <NEWLINE> <INDENT> return [ el1 + el2 for el1 , el2 in zip ( vect1 , vect2 ) ] <NEWLINE> <NL> <NL> <DEDENT> def vector_minus ( vect1 , vect2 ) : <NEWLINE> <INDENT> return [ el1 - el2 for el1 , el2 in zip ( vect1 , vect2 ) ] <NEWLINE> <NL> <NL> <DEDENT> def vector_product ( vect1 , vect2 ) : <NEWLINE> <INDENT> return [ el1 * el2 for el1 , el2 in zip ( vect1 , vect2 ) ] <NEWLINE> <NL> <NL> <DEDENT> def vector_divide ( vect1 , vect2 ) : <NEWLINE> <INDENT> return [ el1 / el2 for el1 , el2 in zip ( vect1 , vect2 ) ] <NEWLINE> <NL> <NL> <DEDENT> def which_place ( origin , line_to1 , line_to2 ) : <NEWLINE> <INDENT> line1 = vector_minus ( line_to1 , origin ) <NEWLINE> line2 = vector_minus ( line_to2 , origin ) <NEWLINE> judge = cross_product ( line1 , line2 ) <NEWLINE> <NL> if judge > 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if judge < 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if judge == 0 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> judge2 = line2 [ 0 ] / line1 [ 0 ] <NEWLINE> <DEDENT> except ZeroDivisionError : <NEWLINE> <INDENT> judge2 = line2 [ 1 ] / line1 [ 1 ] <NEWLINE> <NL> <DEDENT> if judge2 < 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if judge2 > 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> xy_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p0_list = xy_list [ : 2 ] <NEWLINE> p1_list = xy_list [ 2 : ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> p2_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> place = which_place ( p0_list , p1_list , p2_list ) <NEWLINE> print ( place ) <NEWLINE> <NL> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ls = len ( S ) <NEWLINE> lt = len ( T ) <NEWLINE> left = - 1 <NEWLINE> <NL> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> for j in range ( lt ) : <NEWLINE> <INDENT> if S [ i + j ] != <STRING> and S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> left = i <NEWLINE> <DEDENT> <DEDENT> if left == - 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = S [ : left ] + T + S [ left + lt : ] <NEWLINE> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tree = [ [ ] for _ in [ 0 ] * N ] <NEWLINE> for u , v in [ map ( int , input ( ) . split ( ) ) for _ in [ 0 ] * ( N - 1 ) ] : <NEWLINE> <INDENT> tree [ u - 1 ] . append ( v - 1 ) <NEWLINE> tree [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> dp = [ 1001001001 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = - 1001001001 <NEWLINE> ans = [ 0 ] * N <NEWLINE> def dfs ( now , p = - 1 ) : <NEWLINE> <INDENT> idx = bisect_left ( dp , a [ now ] ) <NEWLINE> old = dp [ idx ] <NEWLINE> dp [ idx ] = a [ now ] <NEWLINE> ans [ now ] = idx <NEWLINE> if p != - 1 and ans [ now ] < ans [ p ] : <NEWLINE> <INDENT> ans [ now ] = ans [ p ] <NEWLINE> <DEDENT> for child in tree [ now ] : <NEWLINE> <INDENT> if child == p : continue <NEWLINE> dfs ( child , now ) <NEWLINE> <DEDENT> dp [ idx ] = old <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> add_dic = { } <NEWLINE> sub_dic = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> add_tmp = i + a [ i ] <NEWLINE> sub_tmp = i - a [ i ] <NEWLINE> if not add_tmp in add_dic . keys ( ) : <NEWLINE> <INDENT> add_dic [ add_tmp ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> add_dic [ add_tmp ] += 1 <NEWLINE> <DEDENT> if not sub_tmp in sub_dic . keys ( ) : <NEWLINE> <INDENT> sub_dic [ sub_tmp ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sub_dic [ sub_tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k , v in add_dic . items ( ) : <NEWLINE> <INDENT> if k in sub_dic . keys ( ) : <NEWLINE> <INDENT> ans += v * sub_dic [ k ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
num = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> b , f , r , v , v1 , n , x , y , z = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if y >= 1 : <NEWLINE> <INDENT> z = 0 <NEWLINE> y = 0 <NEWLINE> x += 1 <NEWLINE> print ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if z >= 1 : <NEWLINE> <INDENT> z = 0 <NEWLINE> y += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , num [ x ] [ y ] [ z ] , end = <STRING> ) <NEWLINE> z += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> excess = [ ] <NEWLINE> shortage = [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= b [ i ] : <NEWLINE> <INDENT> excess . append ( a [ i ] - b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> shortage . append ( b [ i ] - a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( shortage ) <NEWLINE> <NL> if sum ( excess ) < sum ( shortage ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif len ( shortage ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> excess . sort ( reverse = True ) <NEWLINE> excess_num = 0 <NEWLINE> shortage_num = sum ( shortage ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> excess_num += excess [ i ] <NEWLINE> ans += 1 <NEWLINE> if excess_num >= shortage_num : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <STRING> <NEWLINE> <COMMENT> <NL> import math <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> key = 10 ** 9 + 7 <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> n = S // 3 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = S - 3 * i <NEWLINE> <COMMENT> <NL> tmp = combinations_count ( i - 1 + a , i - 1 ) <NEWLINE> tmp %= key <NEWLINE> ans += tmp <NEWLINE> ans %= key <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def readstr ( ) : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def readint ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readnums ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readstrs ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = readint ( ) <NEWLINE> A = list ( readnums ( ) ) <NEWLINE> b = 1000 <NEWLINE> s = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> s += b // A [ i ] <NEWLINE> b %= A [ i ] <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> b += A [ i ] * s <NEWLINE> s = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if A [ - 1 ] >= A [ - 2 ] : <NEWLINE> <INDENT> b += A [ - 1 ] * s <NEWLINE> s = 0 <NEWLINE> <NL> <DEDENT> print ( b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> out = <STRING> <NEWLINE> for i in range ( 1 , int ( n ) + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> out += <STRING> + str ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ S ] * N <NEWLINE> m = 10 ** 9 <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans [ i ] %= m <NEWLINE> ans [ i ] += 1 <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> aas = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import heapq <NEWLINE> hq = [ ] <NEWLINE> for i in aas : <NEWLINE> <INDENT> heapq . heappush ( hq , - i ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( hq ) <NEWLINE> heapq . heappush ( hq , - ( ( - tmp ) // 2 ) ) <NEWLINE> <DEDENT> print ( - sum ( hq ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for A in range ( 1 , N ) : <NEWLINE> <INDENT> count += int ( ( N - 1 ) / A ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S // 60 % 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( m , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( s ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = i + 1 <NEWLINE> b = 1 <NEWLINE> c = n - a * b <NEWLINE> ans += math . ceil ( c / a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> u = [ 0 ] <NEWLINE> v = [ ] <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> u . append ( u [ i ] + p [ i ] ) <NEWLINE> <DEDENT> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> w . append ( u [ k + i ] - u [ i ] ) <NEWLINE> <DEDENT> x = w . index ( max ( w ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> v . append ( p [ x + i ] ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a += 1 + 0.5 * ( v [ i ] - 1 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> now = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> now += ( i + ( i * ( n // i ) ) ) * ( n // i ) // 2 <NEWLINE> <DEDENT> print ( now ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> from collections import deque <NEWLINE> <NL> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def IS ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def IL ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> def ILL ( n ) : <NEWLINE> <INDENT> return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <DEDENT> def S ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def SS ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = IS ( ) <NEWLINE> to = [ [ ] for _ in range ( N ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = IS ( ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> to [ A ] . append ( B ) <NEWLINE> to [ B ] . append ( A ) <NEWLINE> <COMMENT> <NL> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> <COMMENT> <NL> dist = [ INF ] * N <NEWLINE> <COMMENT> <NL> prev = [ - 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> while len ( q ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> v = q . popleft ( ) <NEWLINE> <COMMENT> <NL> for u in to [ v ] : <NEWLINE> <INDENT> if prev [ u ] == - 1 : <NEWLINE> <INDENT> dist [ u ] = dist [ v ] + 1 <NEWLINE> prev [ u ] = v <NEWLINE> q . append ( u ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , len ( prev ) ) : <NEWLINE> <INDENT> print ( prev [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> h = int ( s / 3600 ) <NEWLINE> m = int ( s % 3600 / 60 ) <NEWLINE> s2 = int ( s % 3600 % 60 ) <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s2 ) ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> n_k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = n_k [ 0 ] <NEWLINE> k = n_k [ 1 ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_pos = list ( filter ( lambda v : v >= 0 , a ) ) <NEWLINE> a_neg = list ( filter ( lambda v : v < 0 , a ) ) <NEWLINE> <NL> a_pos . sort ( reverse = True ) <NEWLINE> a_neg . sort ( ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 1 <NEWLINE> if n == k : <NEWLINE> <INDENT> for a_i in a : <NEWLINE> <INDENT> ans = ans * a_i % mod <NEWLINE> <DEDENT> <DEDENT> elif len ( a_pos ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> for i in reversed ( range ( len ( a_neg ) - k , len ( a_neg ) ) ) : <NEWLINE> <INDENT> ans = ans * a_neg [ i ] % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i_p = 0 <NEWLINE> i_n = 0 <NEWLINE> i = 0 <NEWLINE> while i < k : <NEWLINE> <INDENT> if i_p < len ( a_pos ) and ( i == k - 1 or i_n + 1 >= len ( a_neg ) or a_pos [ i_p ] * ( a_pos [ i_p + 1 ] if i_p + 1 < len ( a_pos ) else 1 ) > a_neg [ i_n ] * a_neg [ i_n + 1 ] ) : <NEWLINE> <INDENT> ans = ans * a_pos [ i_p ] % mod <NEWLINE> i_p += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * a_neg [ i_n ] % mod * a_neg [ i_n + 1 ] % mod <NEWLINE> i_n += 2 <NEWLINE> i += 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( 10 ** 9 ) : <NEWLINE> <INDENT> if i ** 5 <= 10 ** 13 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> l . append ( - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( l ) - 1 ) : <NEWLINE> <INDENT> for j in range ( i , len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] ** 5 - l [ j ] ** 5 == x : <NEWLINE> <INDENT> print ( l [ i ] , l [ j ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def erase ( w , h , x , y ) : <NEWLINE> <INDENT> c [ y ] [ x ] = <STRING> <NEWLINE> for dx , dy in ( ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 1 ) , ( - 1 , 0 ) , ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) ) : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if 0 <= nx <= w - 1 and 0 <= ny <= h - 1 : <NEWLINE> <INDENT> if c [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> erase ( w , h , nx , ny ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = [ [ i for i in input ( ) . split ( ) ] for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if c [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> erase ( w , h , x , y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> c = list ( c ) <NEWLINE> arr = [ ] <NEWLINE> a = 0 <NEWLINE> b = c . count ( <STRING> ) <NEWLINE> arr . append ( max ( a , b ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif c [ i ] == <STRING> : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> arr . append ( max ( a , b ) ) <NEWLINE> <DEDENT> ans = min ( arr ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> def IS ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def II ( ) : return int ( IS ( ) ) <NEWLINE> def MII ( ) : return list ( map ( int , IS ( ) . split ( ) ) ) <NEWLINE> def MIIZ ( ) : return list ( map ( lambda x : x - 1 , MII ( ) ) ) <NEWLINE> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n = II ( ) <NEWLINE> aa = MII ( ) <NEWLINE> aa . sort ( ) <NEWLINE> maxa = aa [ - 1 ] <NEWLINE> dp = [ False ] * ( maxa + 1 ) <NEWLINE> for a in aa : <NEWLINE> <INDENT> dp [ a ] = True <NEWLINE> <DEDENT> dup = set ( ) <NEWLINE> for a in aa : <NEWLINE> <INDENT> if a in dup : <NEWLINE> <INDENT> dp [ a ] = False <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dup . add ( a ) <NEWLINE> <DEDENT> if dp [ a ] : <NEWLINE> <INDENT> for j in range ( a * 2 , maxa + 1 , a ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( 1 for d in dp if d ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , k , v <NEWLINE> <NL> <DEDENT> def main ( n , k , v ) : <NEWLINE> <INDENT> ruisekiL = [ 0 ] * ( n + 1 ) <NEWLINE> ruisekiR = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ruisekiL [ i ] = ruisekiL [ i - 1 ] + v [ i - 1 ] <NEWLINE> ruisekiR [ i ] = ruisekiR [ i - 1 ] + v [ n - i ] <NEWLINE> <DEDENT> vv = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> vv . append ( ( i + 1 , v [ i ] ) ) <NEWLINE> <DEDENT> vv . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> maxown = - 10 ** 7 <NEWLINE> for kk in range ( k + 1 ) : <NEWLINE> <INDENT> if n < kk : <NEWLINE> <INDENT> own = ruisekiL [ n ] <NEWLINE> m = 0 <NEWLINE> while m < n and vv [ m ] [ 1 ] < 0 : <NEWLINE> <INDENT> own -= vv [ i ] [ 1 ] <NEWLINE> m += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> maxown = max ( maxown , own ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for l in range ( kk // 2 + 1 ) : <NEWLINE> <INDENT> for i in range ( kk - l + 1 ) : <NEWLINE> <INDENT> j = kk - i - l <NEWLINE> jj = n - j + 1 <NEWLINE> own = ruisekiL [ i ] + ruisekiR [ j ] <NEWLINE> <COMMENT> <NL> m = 0 <NEWLINE> mcnt = 0 <NEWLINE> while ( mcnt < l ) : <NEWLINE> <INDENT> if i < vv [ m ] [ 0 ] and vv [ m ] [ 0 ] < jj : <NEWLINE> <INDENT> m += 1 <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> own -= vv [ m ] [ 1 ] <NEWLINE> mcnt += 1 <NEWLINE> m += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> maxown = max ( own , maxown ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return maxown <NEWLINE> <NL> <DEDENT> def main2 ( n , k , v ) : <NEWLINE> <INDENT> ruisekiL = [ 0 ] * ( n + 1 ) <NEWLINE> ruisekiR = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ruisekiL [ i ] = ruisekiL [ i - 1 ] + v [ i - 1 ] <NEWLINE> ruisekiR [ i ] = ruisekiR [ i - 1 ] + v [ n - i ] <NEWLINE> <DEDENT> vv = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> vv . append ( ( i + 1 , v [ i ] ) ) <NEWLINE> <DEDENT> vv . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> maxown = - 10 ** 7 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> if i + j > k or i + j > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> jj = n - j + 1 <NEWLINE> own = ruisekiL [ i ] + ruisekiR [ j ] <NEWLINE> <COMMENT> <NL> l = min ( i + j , k - i - j ) <NEWLINE> m = 0 <NEWLINE> mcnt = 0 <NEWLINE> while ( mcnt < l ) : <NEWLINE> <INDENT> if i < vv [ m ] [ 0 ] and vv [ m ] [ 0 ] < jj : <NEWLINE> <INDENT> m += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if vv [ m ] [ 1 ] >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> own -= vv [ m ] [ 1 ] <NEWLINE> mcnt += 1 <NEWLINE> m += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> maxown = max ( own , maxown ) <NEWLINE> <DEDENT> <DEDENT> return maxown <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k , v = readinput ( ) <NEWLINE> ans = main2 ( n , k , v ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> dp = [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp += [ min ( [ dp [ - j ] + abs ( h [ i ] - h [ i - j ] ) for j in range ( 1 , min ( i , k ) + 1 ) ] ) ] <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> def do ( ) : <NEWLINE> <INDENT> n , k = INTM ( ) <NEWLINE> A = LIST ( ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ i ] < A [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> T = str ( input ( ) ) <NEWLINE> try : <NEWLINE> <INDENT> for i in range ( T . count ( <STRING> ) ) : <NEWLINE> <INDENT> index = T . index ( <STRING> ) <NEWLINE> if T [ index - 1 ] == <STRING> : <NEWLINE> <INDENT> T = T . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif T [ index + 1 ] == <STRING> : <NEWLINE> <INDENT> T = T . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif T [ index + 1 ] == <STRING> : <NEWLINE> <INDENT> T = T . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T = T . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( T ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> count = int ( input ( ) ) <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> ans = x + y <NEWLINE> dif = 100000000000000000000000000000000000000000000000000000000000000000000000000000000 <NEWLINE> if ans >= dif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = abs ( X ) // D <NEWLINE> s = abs ( X ) % D <NEWLINE> <NL> if abs ( X ) > K * D : <NEWLINE> <INDENT> print ( abs ( X ) - K * D ) <NEWLINE> <DEDENT> elif t % 2 == K % 2 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> class BinarySearchTree : <NEWLINE> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , value ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> def has_left ( self ) : <NEWLINE> <INDENT> return self . left is not None <NEWLINE> <NL> <DEDENT> def has_right ( self ) : <NEWLINE> <INDENT> return self . right is not None <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . value ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , value ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> self . root = self . Node ( value ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> node = self . root <NEWLINE> while True : <NEWLINE> <INDENT> if node . value > value : <NEWLINE> <INDENT> if node . has_left ( ) : <NEWLINE> <INDENT> node = node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . left = self . Node ( value ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if node . has_right ( ) : <NEWLINE> <INDENT> node = node . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = self . Node ( value ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> def _preorder ( node ) : <NEWLINE> <INDENT> yield node <NEWLINE> if node . has_left ( ) : <NEWLINE> <INDENT> yield from _preorder ( node . left ) <NEWLINE> <DEDENT> if node . has_right ( ) : <NEWLINE> <INDENT> yield from _preorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> if self . root is not None : <NEWLINE> <INDENT> yield from _preorder ( self . root ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> def _inorder ( node ) : <NEWLINE> <INDENT> if node . has_left ( ) : <NEWLINE> <INDENT> yield from _inorder ( node . left ) <NEWLINE> <DEDENT> yield node <NEWLINE> if node . has_right ( ) : <NEWLINE> <INDENT> yield from _inorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> if self . root is not None : <NEWLINE> <INDENT> yield from _inorder ( self . root ) <NEWLINE> <NL> <DEDENT> <DEDENT> def postorder ( self ) : <NEWLINE> <INDENT> def _postorder ( node ) : <NEWLINE> <INDENT> if node . has_left ( ) : <NEWLINE> <INDENT> yield from _postorder ( node . left ) <NEWLINE> <DEDENT> if node . has_right ( ) : <NEWLINE> <INDENT> yield from _postorder ( node . right ) <NEWLINE> <DEDENT> yield node <NEWLINE> <DEDENT> if self . root is not None : <NEWLINE> <INDENT> yield from _postorder ( self . root ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> tree = BinarySearchTree ( ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> command = line . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( command [ 1 ] ) ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> inorder = <STRING> <NEWLINE> for node in tree . inorder ( ) : <NEWLINE> <INDENT> inorder += <STRING> . format ( node ) <NEWLINE> <DEDENT> print ( inorder ) <NEWLINE> preorder = <STRING> <NEWLINE> for node in tree . preorder ( ) : <NEWLINE> <INDENT> preorder += <STRING> . format ( node ) <NEWLINE> <DEDENT> print ( preorder ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + a <NEWLINE> c = [ 1 ] <NEWLINE> x = True <NEWLINE> y = [ 1 , 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> <NL> while x : <NEWLINE> <INDENT> c . append ( a [ c [ - 1 ] ] ) <NEWLINE> y [ c [ - 1 ] ] += 1 <NEWLINE> if y [ c [ - 1 ] ] == 2 : <NEWLINE> <INDENT> x = False <NEWLINE> <NL> <DEDENT> <DEDENT> t = c . index ( c [ - 1 ] ) <NEWLINE> if k <= t : <NEWLINE> <INDENT> ans = c [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = c [ t + ( ( k - t ) % ( len ( c ) - 1 - t ) ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> s = N % 26 <NEWLINE> if s == 0 : <NEWLINE> <INDENT> s = 26 <NEWLINE> <DEDENT> N = int ( ( N - s ) / 26 ) <NEWLINE> Ans = chr ( ord ( <STRING> ) + s - 1 ) + Ans <NEWLINE> <NL> <DEDENT> print ( Ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = A * ( N // ( A + B ) ) <NEWLINE> if N % ( A + B ) > A : <NEWLINE> <INDENT> ans += A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += N % ( A + B ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> result = 1 <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for _a in a : <NEWLINE> <INDENT> result *= _a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> def find ( par , i ) : <NEWLINE> <INDENT> if par [ i ] < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> par [ i ] = find ( par , par [ i ] ) <NEWLINE> return par [ i ] <NEWLINE> <NL> <DEDENT> def unite ( par , i , j ) : <NEWLINE> <INDENT> ri = find ( par , i ) <NEWLINE> rj = find ( par , j ) <NEWLINE> if ri == rj : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> par [ rj ] += par [ ri ] <NEWLINE> par [ ri ] = rj <NEWLINE> <NL> <DEDENT> setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> parent = [ - 1 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> unite ( parent , a , b ) <NEWLINE> <NL> <DEDENT> print ( - min ( parent ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ary = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ary = sorted ( ary ) <NEWLINE> <NL> from math import log2 <NEWLINE> lt = log2 ( 10 ** 18 ) <NEWLINE> <NL> if ary [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if any ( log2 ( ary [ i ] ) > lt / ( n - i ) for i in range ( n ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> prod = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> prod *= ary [ i ] <NEWLINE> <DEDENT> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> items = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> item = input ( ) <NEWLINE> items . append ( item ) <NEWLINE> <DEDENT> items . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> before = <STRING> <NEWLINE> for index , item in enumerate ( items ) : <NEWLINE> <INDENT> if index == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif before != item : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> before = item <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import bisect <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> xnum = [ [ 0 , i ] for i in range ( h ) ] <NEWLINE> ynum = [ [ 0 , i ] for i in range ( w ) ] <NEWLINE> hw = [ ] <NEWLINE> xmax = [ ] <NEWLINE> ymax = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> xnum [ s - 1 ] [ 0 ] += 1 <NEWLINE> ynum [ t - 1 ] [ 0 ] += 1 <NEWLINE> hw . append ( [ s - 1 , t - 1 ] ) <NEWLINE> <DEDENT> hw . sort ( ) <NEWLINE> xnum . sort ( ) <NEWLINE> ynum . sort ( ) <NEWLINE> xmax . append ( xnum [ - 1 ] [ 1 ] ) <NEWLINE> ymax . append ( ynum [ - 1 ] [ 1 ] ) <NEWLINE> for i in range ( 2 , len ( xnum ) + 1 ) : <NEWLINE> <INDENT> if xnum [ - 1 * i ] [ 0 ] == xnum [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> xmax . append ( xnum [ - 1 * i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 , len ( ynum ) + 1 ) : <NEWLINE> <INDENT> if ynum [ - 1 * i ] [ 0 ] == ynum [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> ymax . append ( ynum [ - 1 * i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> flag = True <NEWLINE> for i in xmax : <NEWLINE> <INDENT> for j in ymax : <NEWLINE> <INDENT> l = bisect . bisect_left ( hw , [ i , j ] ) <NEWLINE> r = bisect . bisect_right ( hw , [ i , j ] ) <NEWLINE> if [ i , j ] in hw [ l : r ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = xnum [ - 1 ] [ 0 ] + ynum [ - 1 ] [ 0 ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = xnum [ - 1 ] [ 0 ] + ynum [ - 1 ] [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> from functools import reduce <NEWLINE> n , * a , = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> m = max ( a ) <NEWLINE> <NL> d = [ 0 ] * ( m + 1 ) <NEWLINE> d [ 1 ] = 1 <NEWLINE> for i in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> if d [ j ] == 0 : <NEWLINE> <INDENT> d [ j ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def primes ( x ) : <NEWLINE> <INDENT> ps = set ( ) <NEWLINE> while x != 1 : <NEWLINE> <INDENT> p = d [ x ] <NEWLINE> ps . add ( p ) <NEWLINE> x = x // d [ x ] <NEWLINE> <DEDENT> return ps <NEWLINE> <NL> <DEDENT> b = set ( ) <NEWLINE> f = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> ps = primes ( i ) <NEWLINE> if b & ps : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> b |= ps <NEWLINE> <DEDENT> if f > 0 and reduce ( gcd , a ) != 1 : <NEWLINE> <INDENT> f = 2 <NEWLINE> <NL> <DEDENT> ans = [ <STRING> , <STRING> , <STRING> ] [ f ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> array . sort ( ) <NEWLINE> ansarray = [ ] <NEWLINE> ansnum = 1 <NEWLINE> ans = 0 <NEWLINE> ansindex = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( ansindex , N - 1 ) : <NEWLINE> <INDENT> if ( array [ j ] == i ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> ansindex += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ansarray . append ( ans ) <NEWLINE> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ( j == N - 2 ) : <NEWLINE> <INDENT> ansarray . append ( ans ) <NEWLINE> ansindex += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N - len ( ansarray ) ) : <NEWLINE> <INDENT> ansarray . append ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ansarray [ i ] ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def f ( C ) : <NEWLINE> <INDENT> NX = float ( <STRING> ) <NEWLINE> if C > K : <NEWLINE> <INDENT> return NX <NEWLINE> <NL> <DEDENT> if K % 2 == 0 : <NEWLINE> <INDENT> if C % 2 == 0 : <NEWLINE> <INDENT> NX = abs ( abs ( X ) - C * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> NX = abs ( abs ( X ) - ( C + 1 ) * D ) <NEWLINE> if C > 0 : <NEWLINE> <INDENT> NX = min ( NX , abs ( abs ( X ) - ( C - 1 ) * D ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if C % 2 == 0 : <NEWLINE> <INDENT> NX = abs ( abs ( X ) - ( C + 1 ) * D ) <NEWLINE> if C > 0 : <NEWLINE> <INDENT> NX = min ( NX , abs ( abs ( X ) - ( C - 1 ) * D ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> NX = abs ( abs ( X ) - C * D ) <NEWLINE> <NL> <DEDENT> <DEDENT> return NX <NEWLINE> <NL> <NL> <DEDENT> C = min ( abs ( X ) // D , K ) <NEWLINE> <NL> print ( min ( f ( C ) , f ( C + 1 ) ) ) <NEWLINE>
def readinput ( ) : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> return n , a <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> nroute = [ 0 ] * ( n + 2 ) <NEWLINE> nroute [ 0 ] = 0 <NEWLINE> nroute [ 1 ] = 1 <NEWLINE> nroute [ 2 ] = 1 <NEWLINE> for i in range ( 3 , n + 2 ) : <NEWLINE> <INDENT> nroute [ i ] = ( nroute [ i - 1 ] + nroute [ i - 2 ] ) % MOD <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> subn = [ ] <NEWLINE> i = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> subn . append ( ( i , j - 1 ) ) <NEWLINE> i = j + 1 <NEWLINE> <DEDENT> subn . append ( ( i , n ) ) <NEWLINE> <COMMENT> <NL> <NL> nways = 1 <NEWLINE> for i , j in subn : <NEWLINE> <INDENT> l = j - i + 1 <NEWLINE> nways = nways * nroute [ l ] % MOD <NEWLINE> <NL> <DEDENT> return nways <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , a = readinput ( ) <NEWLINE> ans = main ( n , a ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
for t in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mid = [ X [ i ] - X [ i - 1 ] for i in range ( 1 , n ) ] <NEWLINE> mid . sort ( ) <NEWLINE> ans = [ 0 , sum ( mid [ : n - k ] ) ] [ k < n ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m = n // i <NEWLINE> total += i * m * ( m + 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) ; M = [ input ( ) for _ in <STRING> * H ] ; D = [ [ 0 ] * - ~ W for _ in <STRING> * - ~ H ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> a = b = 999 <NEWLINE> if i > 0 : a = D [ i ] [ j + 1 ] + ( M [ i - 1 ] [ j ] > M [ i ] [ j ] ) <NEWLINE> if j > 0 : b = D [ i + 1 ] [ j ] + ( M [ i ] [ j - 1 ] > M [ i ] [ j ] ) <NEWLINE> D [ i + 1 ] [ j + 1 ] = min ( a , b , 999 * ( i + j > 0 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( D [ - 1 ] [ - 1 ] + ( M [ 0 ] [ 0 ] < <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> if abs ( ( x2 - x1 ) * ( y4 - y3 ) - ( y2 - y1 ) * ( x4 - x3 ) ) < 1e-10 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect as bi <NEWLINE> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( Q ) ] <NEWLINE> B = [ K ] * N <NEWLINE> p = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> A . append ( i + 1 ) <NEWLINE> <DEDENT> C = sorted ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ i ] += bi . bisect_left ( C , i + 2 ) - p - 1 <NEWLINE> p = bi . bisect_left ( C , i + 2 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( B [ i ] > Q ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> wa = 0 <NEWLINE> <NL> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> wa += list [ i + 1 ] <NEWLINE> ans += list [ i ] * wa <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
import math <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S += math . gcd ( s , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , node_id , left , right ) : <NEWLINE> <INDENT> self . node_id = node_id <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def pre_order_search ( self ) : <NEWLINE> <INDENT> l = self . left <NEWLINE> r = self . right <NEWLINE> print ( <STRING> , self . node_id , end = <STRING> ) <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> tree [ l ] . pre_order_search ( ) <NEWLINE> <DEDENT> if r != - 1 : <NEWLINE> <INDENT> tree [ r ] . pre_order_search ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def in_order_search ( self ) : <NEWLINE> <INDENT> l = self . left <NEWLINE> r = self . right <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> tree [ l ] . in_order_search ( ) <NEWLINE> <DEDENT> print ( <STRING> , self . node_id , end = <STRING> ) <NEWLINE> if r != - 1 : <NEWLINE> <INDENT> tree [ r ] . in_order_search ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def post_order_search ( self ) : <NEWLINE> <INDENT> l = self . left <NEWLINE> r = self . right <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> tree [ l ] . post_order_search ( ) <NEWLINE> <DEDENT> if r != - 1 : <NEWLINE> <INDENT> tree [ r ] . post_order_search ( ) <NEWLINE> <DEDENT> print ( <STRING> , self . node_id , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = [ None for i in range ( n ) ] <NEWLINE> root_set = set ( range ( n ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> node_id , left , right = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ node_id ] = Node ( node_id , left , right ) <NEWLINE> root_set -= set ( [ left , right ] ) <NEWLINE> <DEDENT> root = root_set . pop ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> tree [ root ] . pre_order_search ( ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> tree [ root ] . in_order_search ( ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> tree [ root ] . post_order_search ( ) <NEWLINE> print ( ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p . sort ( ) <NEWLINE> <NL> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( p ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if p [ i ] == x : <NEWLINE> <INDENT> index = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> right = x + 1 <NEWLINE> for i in p [ index + 1 : ] : <NEWLINE> <INDENT> if i != right : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> right += 1 <NEWLINE> <NL> <DEDENT> left = x - 1 <NEWLINE> for i in reversed ( p [ : index ] ) : <NEWLINE> <INDENT> if i != left : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> left -= 1 <NEWLINE> <NL> <DEDENT> if x - left <= right - x : <NEWLINE> <INDENT> print ( left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lower = min ( a ) <NEWLINE> upper = max ( a ) <NEWLINE> mini = 10000005 <NEWLINE> res = - 1 <NEWLINE> for i in range ( lower - 1 , upper + 2 ) : <NEWLINE> <INDENT> if i not in a : <NEWLINE> <INDENT> if abs ( x - i ) < mini : <NEWLINE> <INDENT> mini = abs ( x - i ) <NEWLINE> res = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> d = deque ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> com = input ( ) <NEWLINE> if ( com [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> com , i = com . split ( ) <NEWLINE> d . appendleft ( int ( i ) ) <NEWLINE> <DEDENT> elif ( com [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> if ( com [ 6 ] == <STRING> ) : <NEWLINE> <INDENT> com , i = com . split ( ) <NEWLINE> try : <NEWLINE> <INDENT> d . remove ( int ( i ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif ( com [ 6 ] == <STRING> ) : <NEWLINE> <INDENT> d . popleft ( ) <NEWLINE> <DEDENT> elif ( com [ 6 ] == <STRING> ) : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = map ( str , d ) <NEWLINE> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> p *= i <NEWLINE> if p > 1000000000000000000 : <NEWLINE> <INDENT> p = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> list = input ( ) . split ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> max_ans = 10 ** 18 <NEWLINE> <NL> if <STRING> in list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for num in list : <NEWLINE> <INDENT> ans = ans * int ( num ) <NEWLINE> if ans > max_ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> l = list ( range ( 1 , K + 1 ) ) <NEWLINE> ans = K * ( K + 1 ) // 2 <NEWLINE> for i in itertools . combinations ( l , 2 ) : <NEWLINE> <INDENT> ans += 3 * ( gcd ( i [ 0 ] , i [ 0 ] , i [ 1 ] ) + gcd ( i [ 0 ] , i [ 1 ] , i [ 1 ] ) ) <NEWLINE> <DEDENT> for i in itertools . combinations ( l , 3 ) : <NEWLINE> <INDENT> ans += 6 * gcd ( i [ 0 ] , i [ 1 ] , i [ 2 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> m = ( n - 1 ) // i <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list_min = sorted ( a_list ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a_list_min [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def Fib ( n ) : <NEWLINE> <INDENT> a , b = 1 , 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i + 1 ] == a [ i ] + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> x = [ ] <NEWLINE> temp = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x . append ( a [ i ] - temp - 1 ) <NEWLINE> temp = a [ i ] + 1 <NEWLINE> <DEDENT> x . append ( n - temp ) <NEWLINE> <NL> temp = 1 <NEWLINE> div = 1000000007 <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> temp = ( temp * Fib ( i + 1 ) ) % div <NEWLINE> <NL> <DEDENT> print ( temp ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if not ( i in p ) : <NEWLINE> <INDENT> b . append ( ( i , abs ( i - x ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> b . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> print ( b [ 0 ] [ 0 ] ) <NEWLINE>
import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Bs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def get_cum ( arr ) : <NEWLINE> <INDENT> cum_arr = [ 0 ] <NEWLINE> for e in arr : <NEWLINE> <INDENT> tot = cum_arr [ - 1 ] + e <NEWLINE> if tot > K : <NEWLINE> <INDENT> return cum_arr <NEWLINE> <DEDENT> cum_arr . append ( tot ) <NEWLINE> <DEDENT> return cum_arr <NEWLINE> <NL> <NL> <DEDENT> cumA = get_cum ( As ) <NEWLINE> cumB = get_cum ( Bs ) <NEWLINE> <NL> max_count = 0 <NEWLINE> a_thresh = len ( cumA ) - 1 <NEWLINE> a_count = a_thresh <NEWLINE> b_count = 0 <NEWLINE> b_thresh = len ( cumB ) - 1 <NEWLINE> while a_count >= 0 and b_count <= b_thresh : <NEWLINE> <INDENT> while b_count <= b_thresh and cumA [ a_count ] + cumB [ b_count ] <= K : <NEWLINE> <INDENT> b_count += 1 <NEWLINE> <DEDENT> b_count = max ( 0 , b_count - 1 ) <NEWLINE> if cumA [ a_count ] + cumB [ b_count ] <= K : <NEWLINE> <INDENT> max_count = max ( max_count , a_count + b_count ) <NEWLINE> <DEDENT> a_count -= 1 <NEWLINE> <NL> <DEDENT> print ( max_count ) <NEWLINE>
for i in range ( 10000 ) : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> h = int ( x [ 0 ] ) <NEWLINE> w = int ( x [ 1 ] ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for i in range ( w - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def prime_factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( 2 , int ( pow ( n , 0.5 ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ex = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> ex += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> res . append ( [ i , ex ] ) <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> res . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prime = [ 0 ] * max ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> primes = prime_factorization ( a ) <NEWLINE> for num , ex in primes : <NEWLINE> <INDENT> prime [ num - 1 ] = max ( prime [ num - 1 ] , ex ) <NEWLINE> <NL> <DEDENT> <DEDENT> L = 1 <NEWLINE> for i in range ( len ( prime ) ) : <NEWLINE> <INDENT> if prime [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> L *= pow ( i + 1 , prime [ i ] ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> res += L * pow ( a , mod - 2 , mod ) <NEWLINE> res %= mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( T ) ] <NEWLINE> M = N <NEWLINE> m = 0 <NEWLINE> <NL> for a , b in X : <NEWLINE> <INDENT> M = min ( M , b ) <NEWLINE> m = max ( m , a ) <NEWLINE> <NL> <DEDENT> if M < m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( M - m + 1 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> N = len ( input ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> div = pow ( 26 , - 1 , mod ) <NEWLINE> comb_i = pow ( 26 , K , mod ) <NEWLINE> ans = comb_i <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> comb_i = ( comb_i * ( N - 1 + i ) * pow ( i , - 1 , mod ) ) % mod <NEWLINE> comb_i = ( comb_i * 25 * div ) % mod <NEWLINE> ans = ( ans + comb_i ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> r , l = map ( int , input ( ) . split ( ) ) <NEWLINE> maze [ r - 1 ] . append ( l - 1 ) <NEWLINE> maze [ l - 1 ] . append ( r - 1 ) <NEWLINE> <NL> <DEDENT> stamp = [ - 1 ] * n <NEWLINE> queue = deque ( [ 0 ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> d = queue . popleft ( ) <NEWLINE> for i in maze [ d ] : <NEWLINE> <INDENT> if stamp [ i ] == - 1 : <NEWLINE> <INDENT> stamp [ i ] = d <NEWLINE> queue . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n , 1 ) : <NEWLINE> <INDENT> print ( stamp [ i ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in num_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in num_list : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> IDs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> c = Counter ( IDs ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> S = set ( s ) <NEWLINE> print ( len ( S ) ) <NEWLINE>
import itertools <NEWLINE> import functools <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> from itertools import combinations <NEWLINE> <NL> def CHK ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> H = <STRING> <NEWLINE> B = <STRING> <NEWLINE> rflg = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> Que = input ( ) <NEWLINE> if Que == <STRING> : <NEWLINE> <INDENT> if rflg == 0 : <NEWLINE> <INDENT> rflg = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rflg = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> T , F , C = map ( str , Que . split ( ) ) <NEWLINE> if F == <STRING> and rflg == 0 or ( F != <STRING> and rflg == 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> H = C + H <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> B = B + C <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> S = list ( H ) + S + list ( B ) <NEWLINE> if rflg == 1 : <NEWLINE> <INDENT> S = list ( reversed ( S ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( S ) ) <NEWLINE> <NL> <DEDENT> CHK ( ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in S ] <COMMENT> <NEWLINE> a . reverse ( ) <NEWLINE> <COMMENT> <NL> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> T = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> T += ( int ( i ) * d ) <NEWLINE> T %= 2019 <NEWLINE> l [ T ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <DEDENT> result = 0 <NEWLINE> for n in l : <NEWLINE> <INDENT> result += n * ( n - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( result ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> sevens = 7 % k <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> if sevens % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sevens = ( sevens * 10 + 7 ) % k <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if 0 in set ( A ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ) <NEWLINE>
<COMMENT> <NL> <NL> x = input ( ) <NEWLINE> k = x . split ( <STRING> ) <NEWLINE> a = int ( k [ 0 ] ) <NEWLINE> b = int ( k [ 1 ] ) <NEWLINE> <NL> area = int ( a ) * int ( b ) <NEWLINE> length = int ( a ) * 2 + int ( b ) * 2 <NEWLINE> <NL> print ( area , length ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> def get_keys_of_max_value ( d ) : <NEWLINE> <INDENT> v_max = 0 <NEWLINE> keys = [ ] <NEWLINE> for k , v in d . items ( ) : <NEWLINE> <INDENT> if v_max < v : <NEWLINE> <INDENT> v_max = v <NEWLINE> keys = [ k ] <NEWLINE> <DEDENT> elif v_max == v : <NEWLINE> <INDENT> keys . append ( k ) <NEWLINE> <DEDENT> <DEDENT> return keys , v_max <NEWLINE> <NL> <DEDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> targets = { tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) } <NEWLINE> n_r = defaultdict ( int ) <NEWLINE> n_c = defaultdict ( int ) <NEWLINE> for x , y in targets : <NEWLINE> <INDENT> n_r [ x ] += 1 <NEWLINE> n_c [ y ] += 1 <NEWLINE> <NL> <DEDENT> rows , n_r_max = get_keys_of_max_value ( n_r ) <NEWLINE> columns , n_c_max = get_keys_of_max_value ( n_c ) <NEWLINE> <NL> for r in rows : <NEWLINE> <INDENT> for c in columns : <NEWLINE> <INDENT> if ( r , c ) not in targets : <NEWLINE> <INDENT> print ( n_r_max + n_c_max ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n_r_max + n_c_max - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> y = N // i <NEWLINE> ans += y * ( y + 1 ) * i // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> n = I ( ) <NEWLINE> inf = 10 ** 6 + 1 <NEWLINE> a = LI ( ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> li = [ 0 ] * inf <NEWLINE> for x in a : <NEWLINE> <INDENT> p = li [ x ] <NEWLINE> if p != 0 : <NEWLINE> <INDENT> li [ x ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( x , inf , x ) : <NEWLINE> <INDENT> li [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> if li [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 0 for _ in range ( n ) ] <NEWLINE> already = set ( ) <NEWLINE> next = 1 <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> l [ i ] = a <NEWLINE> <DEDENT> while c <= n : <NEWLINE> <INDENT> next = l [ next - 1 ] <NEWLINE> c += 1 <NEWLINE> if next == 2 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> elif next in already : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> already . add ( next ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> B = [ 0 for i in range ( 10 ** 5 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> B [ a - 1 ] += 1 <NEWLINE> <DEDENT> suma = sum ( A ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( B [ b - 1 ] * ( c - b ) + suma ) <NEWLINE> suma += B [ b - 1 ] * ( c - b ) <NEWLINE> B [ c - 1 ] += B [ b - 1 ] <NEWLINE> B [ b - 1 ] = 0 <NEWLINE> <DEDENT>
w = [ str ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> num = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> w1 = [ ] <NEWLINE> m = 0 <NEWLINE> t = 0 <NEWLINE> for h in w : <NEWLINE> <INDENT> for j in num : <NEWLINE> <INDENT> if h [ - 1 ] == j : <NEWLINE> <INDENT> w1 . append ( int ( h ) + num . index ( j ) ) <NEWLINE> if m <= num . index ( j ) : <NEWLINE> <INDENT> m = num . index ( j ) <NEWLINE> k = w . index ( h ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for l in range ( 5 ) : <NEWLINE> <INDENT> if l != k : <NEWLINE> <INDENT> t += w1 [ l ] <NEWLINE> <DEDENT> <DEDENT> print ( t + int ( w [ k ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> max = a_list [ 0 ] <NEWLINE> count = 0 <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> if max > a : <NEWLINE> <INDENT> d = max - a <NEWLINE> count += d <NEWLINE> a += d <NEWLINE> <DEDENT> max = a <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> now = 1 <NEWLINE> town_list = [ 0 ] * n <NEWLINE> town_list [ 0 ] = 1 <NEWLINE> tn_list = [ 1 ] <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> next = a [ now - 1 ] <NEWLINE> now = next <NEWLINE> if town_list [ now - 1 ] == 0 : <NEWLINE> <INDENT> town_list [ now - 1 ] = 1 <NEWLINE> tn_list . append ( now ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> idx = tn_list . index ( now ) <NEWLINE> initial = tn_list [ : idx ] <NEWLINE> cycle = tn_list [ idx : ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k >= len ( initial ) : <NEWLINE> <INDENT> end_idx = ( k - len ( initial ) ) % len ( cycle ) <NEWLINE> print ( cycle [ end_idx ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( initial [ k ] ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . sort ( ) <NEWLINE> sum = 1 <NEWLINE> done = False <NEWLINE> <NL> <NL> <NL> for i in x : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if i == 0 : <NEWLINE> <INDENT> sum = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> sum = sum * i <NEWLINE> <NL> if sum > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = [ ] * N <NEWLINE> y = [ ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( a ) <NEWLINE> y . append ( b ) <NEWLINE> <DEDENT> d = 0 <NEWLINE> ma = x [ 0 ] + y [ 0 ] <NEWLINE> ima = 0 <NEWLINE> mi = x [ 0 ] + y [ 0 ] <NEWLINE> imi = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if x [ i ] + y [ i ] < mi : <NEWLINE> <INDENT> mi = x [ i ] + y [ i ] <NEWLINE> imi = i <NEWLINE> <DEDENT> if x [ i ] + y [ i ] > ma : <NEWLINE> <INDENT> ma = x [ i ] + y [ i ] <NEWLINE> ima = i <NEWLINE> <DEDENT> <DEDENT> d1 = abs ( x [ ima ] - x [ imi ] ) + abs ( y [ ima ] - y [ imi ] ) <NEWLINE> ma = - x [ 0 ] + y [ 0 ] <NEWLINE> ima2 = 0 <NEWLINE> mi = - x [ 0 ] + y [ 0 ] <NEWLINE> imi2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if - x [ i ] + y [ i ] < mi : <NEWLINE> <INDENT> mi = - x [ i ] + y [ i ] <NEWLINE> imi2 = i <NEWLINE> <DEDENT> if - x [ i ] + y [ i ] > ma : <NEWLINE> <INDENT> ma = - x [ i ] + y [ i ] <NEWLINE> ima2 = i <NEWLINE> <DEDENT> <DEDENT> d2 = abs ( x [ ima2 ] - x [ imi2 ] ) + abs ( y [ ima2 ] - y [ imi2 ] ) <NEWLINE> if d1 > d2 : <NEWLINE> <INDENT> print ( d1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d2 ) <NEWLINE> <DEDENT>
c = int ( input ( ) ) <NEWLINE> total = c - 1 <NEWLINE> for i in range ( 2 , c ) : <NEWLINE> <INDENT> total += ( c - 1 ) // i <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> r , g , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for ir in range ( n + 1 ) : <NEWLINE> <INDENT> vr = r * ir <NEWLINE> if vr > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for ig in range ( n + 1 ) : <NEWLINE> <INDENT> vg = g * ig <NEWLINE> if vg + vr > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cb = n - vr - vg <NEWLINE> if cb % b == 0 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( n ) ] <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def find ( x , par ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = find ( par [ x ] , par ) <NEWLINE> par [ x ] = a <NEWLINE> return a <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x , par ) <NEWLINE> y = find ( y , par ) <NEWLINE> if x != y : <NEWLINE> <INDENT> par [ x ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> groups = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == par [ i ] : <NEWLINE> <INDENT> groups += 1 <NEWLINE> <DEDENT> <DEDENT> print ( groups - 1 ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a_nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> max_count = 0 <NEWLINE> b_i = M <NEWLINE> a_cums = [ 0 ] * ( N + 1 ) <NEWLINE> b_cums = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> a_cums [ i ] = a_cums [ i - 1 ] + a_nums [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_cums [ i ] = a_nums [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> b_cums [ i ] = b_cums [ i - 1 ] + b_nums [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_cums [ i ] = b_nums [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a_cums [ i ] <= K : <NEWLINE> <INDENT> while b_i > 0 and a_cums [ i ] + b_cums [ b_i ] > K : <NEWLINE> <INDENT> b_i -= 1 <NEWLINE> <DEDENT> if i + b_i > max_count : <NEWLINE> <INDENT> max_count = i + b_i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> maxnum = l [ len ( l ) - 1 ] <NEWLINE> flag = [ 0 ] * ( maxnum + 1 ) <NEWLINE> <NL> for num in l : <NEWLINE> <INDENT> flag [ num ] += 1 <NEWLINE> if flag [ num ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( num * 2 , maxnum + 1 , num ) : <NEWLINE> <INDENT> flag [ j ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for num in l : <NEWLINE> <INDENT> if flag [ num ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minus = [ 0 ] * N <NEWLINE> plus = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> minus [ i ] = ( i + 1 ) - A [ i ] <NEWLINE> plus [ i ] = ( i + 1 ) + A [ i ] <NEWLINE> <NL> <DEDENT> count = Counter ( minus ) <NEWLINE> most = count . most_common ( ) <NEWLINE> num = len ( most ) <NEWLINE> <NL> countPP = Counter ( plus ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> elm = most [ i ] <NEWLINE> fir = elm [ 0 ] <NEWLINE> sec = elm [ 1 ] <NEWLINE> <COMMENT> <NL> <NL> aa = countPP [ fir ] <NEWLINE> <COMMENT> <NL> ans += aa * sec <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
r = [ 59049 , 243 , 1 , 3125 , 1024 , 16807 , 32768 , 7776 , 0 , 32 , 371293 , 161051 , 100000 , 537824 , 1419857 , 1048576 , 1889568 , 248832 , 2476099 , 759375 , 20511149 , 11881376 , 7962624 , 9765625 , 4084101 , 3200000 , 5153632 , 14348907 , 17210368 , 6436343 , 33554432 , 60466176 , 28629151 , 69343957 , 79235168 , 52521875 , 24300000 , 45435424 , 90224199 , 39135393 , 229345007 , 254803968 , 184528125 , 102400000 , 130691232 , 147008443 , 205962976 , 164916224 , 282475249 , 115856201 , 601692057 , 418195493 , 459165024 , 380204032 , 312500000 , 345025251 , 714924299 , 503284375 , 550731776 , 656356768 , 1160290625 , 1350125107 , 916132832 , 1564031349 , 844596301 , 1252332576 , 1453933568 , 777600000 , 992436543 , 1073741824 , 2706784157 , 2887174368 , 3077056399 , 1934917632 , 2373046875 , 2535525376 , 2219006624 , 2073071593 , 1804229351 , 1680700000 , 3939040643 , 4437053125 , 4182119424 , 3276800000 , 3707398432 , 5277319168 , 5584059449 , 3486784401 , 4704270176 , 4984209207 , 7339040224 , 8587340257 , 6240321451 , 5904900000 , 6590815232 , 6956883693 , 7737809375 , 8153726976 , 9509900499 , 9039207968 , 10000000000 , 12762815625 , 11040808032 , 14693280768 , 15386239549 , 11592740743 , 14025517307 , 13382255776 , 12166529024 , 10510100501 , 20113571875 , 16105100000 , 17623416832 , 22877577568 , 21003416576 , 18424351793 , 21924480357 , 23863536599 , 19254145824 , 16850581551 , 33038369407 , 28153056843 , 27027081632 , 24883200000 , 30517578125 , 35723051649 , 34359738368 , 25937424601 , 31757969376 , 29316250624 , 46525874176 , 51888844699 , 41615795893 , 43204003424 , 40074642432 , 38579489651 , 44840334375 , 37129300000 , 48261724457 , 50049003168 , 57735339232 , 61917364224 , 71008211968 , 64097340625 , 68641485507 , 55730836701 , 66338290976 , 53782400000 , 73439775749 , 59797108943 , 75937500000 , 101621504799 , 78502725751 , 83841135993 , 92389579776 , 95388992557 , 89466096875 , 81136812032 , 98465804768 , 86617093024 , 118636749824 , 129891985607 , 108175616801 , 137858491849 , 122298103125 , 133827821568 , 115063617043 , 111577100832 , 104857600000 , 126049300576 , 146211169851 , 141985700000 , 159494694624 , 154963892093 , 173726604657 , 150536645632 , 168874213376 , 164130859375 , 178689902368 , 183765996899 , 199690286432 , 194264244901 , 188956800000 , 205236901143 , 216699865625 , 222620278176 , 210906087424 , 241162079949 , 234849287168 , 228669389707 , 312079600999 , 254194901951 , 274794888224 , 289254654976 , 296709280757 , 267785184193 , 304316815968 , 260919263232 , 281950621875 , 247609900000 ] <NEWLINE> r . sort ( ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> for i in r : <NEWLINE> <INDENT> for j in r : <NEWLINE> <INDENT> if i - j == x : <NEWLINE> <INDENT> print ( <STRING> % ( int ( i ** 0.2 ) , int ( j ** 0.2 ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if i + j == x : <NEWLINE> <INDENT> print ( <STRING> % ( int ( i ** 0.2 ) , int ( j ** 0.2 ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> d . sort ( ) <NEWLINE> t . sort ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while i < n and j < m : <NEWLINE> <INDENT> if d [ i ] == t [ j ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if j == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n [ 0 ] ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n [ 1 ] ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n [ 0 ] ) : <NEWLINE> <INDENT> ab_sum = 0 <NEWLINE> for j in range ( n [ 1 ] ) : <NEWLINE> <INDENT> ab_sum += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( ab_sum ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M , K = 3 , 4 , 240 <NEWLINE> ARR = [ 60 , 90 , 120 ] <NEWLINE> BRR = [ 80 , 150 , 80 , 150 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M , K = 5 , 4 , 1 <NEWLINE> ARR = [ 1000000000 , 1000000000 , 1000000000 , 1000000000 , 1000000000 ] <NEWLINE> BRR = [ 1000000000 , 1000000000 , 1000000000 , 1000000000 ] <NEWLINE> <NL> N , M , K = 7 , 4 , 14 <NEWLINE> ARR = [ 1 , 6 , 1 , 1 , 1 , 7 , 2 ] <NEWLINE> BRR = [ 5 , 1 , 5 , 6 , 7 ] <NEWLINE> <NL> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BRR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def calculate ( n , m , k , arr , brr ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> <NL> result = [ ] <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( total + arr [ i ] ) > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total += arr [ i ] <NEWLINE> q . append ( arr [ i ] ) <NEWLINE> <NL> <DEDENT> result . append ( len ( q ) ) <NEWLINE> <NL> remain = k - total <NEWLINE> <NL> q2 = deque ( brr ) <NEWLINE> sss = 0 <NEWLINE> <NL> while ( len ( q2 ) > 0 ) and ( ( sss + q2 [ 0 ] ) <= remain ) : <NEWLINE> <INDENT> v = q2 . popleft ( ) <NEWLINE> sss += v <NEWLINE> <NL> <DEDENT> result . append ( len ( q ) + ( m - len ( q2 ) ) ) <NEWLINE> <NL> while len ( q ) > 0 : <NEWLINE> <INDENT> right = q . pop ( ) <NEWLINE> remain += right <NEWLINE> <NL> while ( len ( q2 ) > 0 ) and ( ( sss + q2 [ 0 ] ) <= remain ) : <NEWLINE> <INDENT> v = q2 . popleft ( ) <NEWLINE> sss += v <NEWLINE> <NL> <DEDENT> result . append ( len ( q ) + ( m - len ( q2 ) ) ) <NEWLINE> <NL> <DEDENT> print ( max ( result ) ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( N , M , K , ARR , BRR ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> first = [ 0 ] * 10 <NEWLINE> a = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if first [ S [ i ] ] == 0 : <NEWLINE> <INDENT> first [ S [ i ] ] = 1 <NEWLINE> a += 1 <NEWLINE> second = [ 0 ] * 10 <NEWLINE> b = 0 <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if second [ S [ j ] ] == 0 : <NEWLINE> <INDENT> second [ S [ j ] ] = 1 <NEWLINE> b += 1 <NEWLINE> third = [ 0 ] * 10 <NEWLINE> c = 0 <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if third [ S [ k ] ] == 0 : <NEWLINE> <INDENT> third [ S [ k ] ] = 1 <NEWLINE> ans += 1 <NEWLINE> c += 1 <NEWLINE> if c == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a == 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S in ans : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . add ( S ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ j ] != s [ j + i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> a . append ( count ) <NEWLINE> <NL> <DEDENT> print ( min ( a ) ) <NEWLINE>
S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 2 ** ( l - 1 ) ) : <NEWLINE> <INDENT> T = S [ 0 ] <NEWLINE> for j in range ( l - 1 ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> T = T + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T = T + <STRING> <NEWLINE> <DEDENT> T = T + S [ j + 1 ] <NEWLINE> <DEDENT> if eval ( T ) == 7 : <NEWLINE> <INDENT> print ( T + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> a = 0 <NEWLINE> t = 1 <NEWLINE> d = [ 0 ] * 2019 <NEWLINE> d [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a += int ( S [ N - 1 - i ] ) * t <NEWLINE> a %= 2019 <NEWLINE> t *= 10 <NEWLINE> t %= 2019 <NEWLINE> d [ a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n in d : <NEWLINE> <INDENT> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List = sorted ( List ) <NEWLINE> List = List [ : : - 1 ] <NEWLINE> <COMMENT> <NL> if List . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> ANS = List [ 0 ] <NEWLINE> i = 1 <NEWLINE> while i < N : <NEWLINE> <INDENT> ANS = ANS * List [ i ] <NEWLINE> if ANS > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ANS ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> my_cards = { input ( ) for _ in range ( n ) } <NEWLINE> lost_cards = ( <NEWLINE> <INDENT> <STRING> . format ( s , i ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for i in range ( 1 , 13 + 1 ) <NEWLINE> if <STRING> . format ( s , i ) not in my_cards <NEWLINE> <DEDENT> ) <NEWLINE> for card in lost_cards : <NEWLINE> <INDENT> print ( card ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> modn = int ( 1e9 + 7 ) <NEWLINE> <NL> ruiseki = sum ( A ) <NEWLINE> <NL> ret = 0 <NEWLINE> for i in range ( 0 , len ( A ) - 1 ) : <NEWLINE> <INDENT> ruiseki -= A [ i ] <NEWLINE> ret += A [ i ] * ruiseki <NEWLINE> <NL> <DEDENT> print ( np . mod ( ret , modn ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> n = 10 ** 9 + 7 <NEWLINE> power = math . factorial ( N ) <NEWLINE> print ( power % n ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> CH , CW = map ( int , input ( ) . split ( ) ) <NEWLINE> DH , DW = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> + input ( ) + <STRING> for _ in range ( H ) ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> S . insert ( 0 , <STRING> * ( W + 4 ) ) <NEWLINE> S . append ( <STRING> * ( W + 4 ) ) <NEWLINE> <NL> <DEDENT> inf = int ( 1e9 ) <NEWLINE> cost = [ [ inf for _ in range ( W + 4 ) ] for _ in range ( H + 4 ) ] <NEWLINE> cost0 = deque ( ) <NEWLINE> ans = - 1 <NEWLINE> <NL> cost0 . append ( ( CH + 1 , CW + 1 , 0 ) ) <NEWLINE> cost [ CH + 1 ] [ CW + 1 ] = 0 <NEWLINE> <NL> move = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> warp = [ ( i , j ) for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) if ( i , j ) not in [ ( 0 , 0 ) ] + move ] <NEWLINE> <NL> cost1 = deque ( ) <NEWLINE> <NL> while cost0 : <NEWLINE> <INDENT> h , w , c = cost0 . popleft ( ) <NEWLINE> cost1 . append ( ( h , w , c ) ) <NEWLINE> <NL> for i , j in move : <NEWLINE> <INDENT> dh = h + i <NEWLINE> dw = w + j <NEWLINE> if S [ dh ] [ dw ] == <STRING> and c < cost [ dh ] [ dw ] : <NEWLINE> <INDENT> cost [ dh ] [ dw ] = c <NEWLINE> cost0 . appendleft ( ( dh , dw , cost [ dh ] [ dw ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( cost0 ) == 0 : <NEWLINE> <INDENT> while cost1 : <NEWLINE> <INDENT> h , w , c = cost1 . popleft ( ) <NEWLINE> for i , j in warp : <NEWLINE> <INDENT> dh = h + i <NEWLINE> dw = w + j <NEWLINE> if S [ dh ] [ dw ] == <STRING> and c + 1 < cost [ dh ] [ dw ] : <NEWLINE> <INDENT> cost [ dh ] [ dw ] = c + 1 <NEWLINE> cost0 . append ( ( dh , dw , cost [ dh ] [ dw ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cost [ DH + 1 ] [ DW + 1 ] != inf : <NEWLINE> <INDENT> ans = cost [ DH + 1 ] [ DW + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> modnum = 998244353 <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> <NL> def mod ( num ) : <NEWLINE> <INDENT> return num % modnum <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> sdp = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> dp [ 1 ] = 1 <NEWLINE> sdp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for l , r in LR : <NEWLINE> <INDENT> ri = max ( 0 , i - l ) <NEWLINE> li = max ( 0 , i - r - 1 ) <NEWLINE> <NL> dp [ i ] += sdp [ ri ] - sdp [ li ] <NEWLINE> dp [ i ] = mod ( dp [ i ] ) <NEWLINE> <NL> <DEDENT> sdp [ i ] = sdp [ i - 1 ] + dp [ i ] <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lng = [ 0 ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> lng . append ( lng [ - 1 ] + int ( input ( ) ) ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> sm = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> j = i + int ( input ( ) ) <NEWLINE> sm += abs ( lng [ i ] - lng [ j ] ) <NEWLINE> sm %= 100000 <NEWLINE> i = j <NEWLINE> <DEDENT> print ( sm ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> import sys <NEWLINE> import copy <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> <NL> num = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> y = N // i <NEWLINE> num += int ( ( y * ( y + 1 ) * i ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s = deque ( list ( input ( ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> normal = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li = input ( ) . split ( ) <NEWLINE> if int ( li [ 0 ] ) == 1 : <NEWLINE> <INDENT> normal ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = int ( li [ 1 ] ) - 1 <NEWLINE> k ^= normal <NEWLINE> if k == 1 : <NEWLINE> <INDENT> s . append ( li [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( li [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) if normal == 0 else <STRING> . join ( list ( s ) [ : : - 1 ] ) ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> x = L [ i ] - L [ j ] <NEWLINE> bottom = bisect_right ( L , x ) <NEWLINE> if j > bottom : <NEWLINE> <INDENT> ans += j - bottom <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> <NL> cnts = [ 0 ] * 2019 <NEWLINE> cnts [ 0 ] = 1 <NEWLINE> <NL> n , d = 0 , 1 <NEWLINE> <NL> for char in s : <NEWLINE> <INDENT> n = ( n + int ( char ) * d ) % 2019 <NEWLINE> d = d * 10 % 2019 <NEWLINE> cnts [ n ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for cnt in cnts : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b ) <NEWLINE> g [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> check = [ 0 ] * n <NEWLINE> check [ 0 ] = 1 <NEWLINE> ans = [ 0 ] * n <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for u in g [ v - 1 ] : <NEWLINE> <INDENT> if check [ u - 1 ] == 0 : <NEWLINE> <INDENT> check [ u - 1 ] = 1 <NEWLINE> ans [ u - 1 ] = v <NEWLINE> q . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> INT_MAX = ( 1 << 31 ) - 1 <NEWLINE> _N , num = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( num ) ] <NEWLINE> N = 1 << 17 <NEWLINE> N1 = N - 1 <NEWLINE> N2 = N1 // 2 <NEWLINE> ars = 2 * N - 1 <NEWLINE> A = [ INT_MAX ] * ( ars ) <NEWLINE> L = [ - 1 ] * ( ars ) <NEWLINE> <NL> def propagate ( k ) : <NEWLINE> <NL> <INDENT> if ( L [ k ] == - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> left = k * 2 + 1 <NEWLINE> right = k * 2 + 2 <NEWLINE> if ( k < N2 ) : <NEWLINE> <INDENT> A [ left ] = A [ right ] = L [ left ] = L [ right ] = L [ k ] <NEWLINE> L [ k ] = - 1 <NEWLINE> return <NEWLINE> <DEDENT> if ( k < N1 ) : <NEWLINE> <INDENT> A [ left ] = A [ right ] = L [ k ] <NEWLINE> L [ k ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( s , t , x , k , l , r ) : <NEWLINE> <NL> <INDENT> if ( r <= s or t <= l ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if ( s <= l and r <= t ) : <NEWLINE> <INDENT> A [ k ] = x <NEWLINE> if ( k < N1 ) : <NEWLINE> <INDENT> L [ k ] = x <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> propagate ( k ) <NEWLINE> mid = ( l + r ) // 2 <NEWLINE> left = k * 2 + 1 <NEWLINE> right = k * 2 + 2 <NEWLINE> update ( s , t , x , left , l , mid ) <NEWLINE> update ( s , t , x , right , mid , r ) <NEWLINE> <NL> A [ k ] = min ( A [ left ] , A [ right ] ) <NEWLINE> <NL> <DEDENT> def find ( s , t , k , l , r ) : <NEWLINE> <NL> <INDENT> if ( r <= s or t <= l ) : <NEWLINE> <INDENT> return INT_MAX <NEWLINE> <NL> <DEDENT> if ( s <= l and r <= t ) : <NEWLINE> <INDENT> return A [ k ] <NEWLINE> <NL> <DEDENT> propagate ( k ) <NEWLINE> mid = ( l + r ) // 2 <NEWLINE> left = k * 2 + 1 <NEWLINE> right = k * 2 + 2 <NEWLINE> v_left = find ( s , t , left , l , mid ) <NEWLINE> v_right = find ( s , t , right , mid , r ) <NEWLINE> return min ( v_left , v_right ) <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> for q in Q : <NEWLINE> <COMMENT> <NL> <INDENT> if ( q [ 0 ] == 0 ) : <NEWLINE> <INDENT> update ( q [ 1 ] , q [ 2 ] + 1 , q [ 3 ] , 0 , 0 , N ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> res . append ( find ( q [ 1 ] , q [ 2 ] + 1 , 0 , 0 , N ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( r ) for r in res ] ) ) <NEWLINE> <NL>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <NL> <DEDENT> value = int ( A * x / B ) - A * int ( x / B ) <NEWLINE> print ( value ) <NEWLINE>
ansOut = [ ] <NEWLINE> coin = [ 10 , 50 , 100 , 500 ] <NEWLINE> while True : <NEWLINE> <INDENT> price = int ( input ( ) ) <NEWLINE> if price == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cash = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumCash = sum ( c * n for c , n in zip ( coin , cash ) ) <NEWLINE> change = sumCash - price <NEWLINE> changeCoins = [ ( change % 50 ) // 10 , ( change % 100 ) // 50 , ( change % 500 ) // 100 , change // 500 ] <NEWLINE> <NL> out = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if cash [ i ] > changeCoins [ i ] : <NEWLINE> <INDENT> out . append ( <STRING> . format ( coin [ i ] , cash [ i ] - changeCoins [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> ansOut . append ( <STRING> . join ( out ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ansOut ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sa = [ ] <NEWLINE> ka = 0 <NEWLINE> sb = [ ] <NEWLINE> kb = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ka + a [ i ] <= k : <NEWLINE> <INDENT> ka += a [ i ] <NEWLINE> sa . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if kb + b [ i ] <= k : <NEWLINE> <INDENT> kb += b [ i ] <NEWLINE> sb . append ( b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( len ( sa ) , len ( sb ) ) <NEWLINE> tb = [ ] <NEWLINE> for i in range ( len ( sa ) ) : <NEWLINE> <INDENT> if sa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while kb + sa [ i ] > k : <NEWLINE> <INDENT> kb -= sb [ - 1 ] <NEWLINE> sb . pop ( - 1 ) <NEWLINE> <DEDENT> tb . append ( sa [ i ] ) <NEWLINE> kb += sa [ i ] <NEWLINE> if ans < ( len ( sb ) + len ( tb ) ) : <NEWLINE> <INDENT> ans = ( len ( sb ) + len ( tb ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1001000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minimum_jump = [ - 1 ] * N <NEWLINE> minimum_jump [ 0 ] = 0 <NEWLINE> minimum_jump [ 1 ] = abs ( height [ 0 ] - height [ 1 ] ) <NEWLINE> <NL> def frog_jump ( n ) : <COMMENT> <NEWLINE> <INDENT> if minimum_jump [ n ] != - 1 : <NEWLINE> <INDENT> return minimum_jump [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if minimum_jump [ n - 1 ] != - 1 : <NEWLINE> <INDENT> temp1 = minimum_jump [ n - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp1 = frog_jump ( n - 1 ) <NEWLINE> <DEDENT> if minimum_jump [ n - 2 ] != - 1 : <NEWLINE> <INDENT> temp2 = minimum_jump [ n - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp2 = frog_jump ( n - 2 ) <NEWLINE> <DEDENT> minimum_jump [ n ] = min ( temp1 + abs ( height [ n ] - height [ n - 1 ] ) , temp2 + abs ( height [ n ] - height [ n - 2 ] ) ) <NEWLINE> return minimum_jump [ n ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( frog_jump ( N - 1 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ [ ] for _ in range ( N ) ] <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> root [ a ] . append ( b ) <NEWLINE> root [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visited = [ False ] * N <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for go in root [ v ] : <NEWLINE> <INDENT> if visited [ go ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ go ] += ans [ v ] <NEWLINE> dfs ( go ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> VW = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> for v , w in VW : <NEWLINE> <INDENT> ans . append ( min ( v , w ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for v , w in VW : <NEWLINE> <INDENT> while v != w : <NEWLINE> <INDENT> if v > w : v , w = w , v <NEWLINE> w = ( w + N - 2 ) // N <NEWLINE> <DEDENT> ans . append ( v ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for num in A : <NEWLINE> <INDENT> if num in dic : <NEWLINE> <INDENT> dic [ num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ num ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> prev_sum = 0 <NEWLINE> <NL> for key , value in dic . items ( ) : <NEWLINE> <INDENT> prev_sum += key * value <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if B in dic and C in dic : <NEWLINE> <INDENT> dic [ C ] += dic [ B ] <NEWLINE> dif = ( C - B ) * dic [ B ] <NEWLINE> prev_sum += dif <NEWLINE> del dic [ B ] <NEWLINE> <DEDENT> elif B in dic and C not in dic : <NEWLINE> <INDENT> dic [ C ] = dic [ B ] <NEWLINE> dif = ( C - B ) * dic [ B ] <NEWLINE> prev_sum += dif <NEWLINE> del dic [ B ] <NEWLINE> <DEDENT> print ( prev_sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = N <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> S . sort ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> ans = ans - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import functools <NEWLINE> def euclid ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return euclid ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def gcd ( nums ) : <NEWLINE> <INDENT> if len ( nums ) == 1 : <NEWLINE> <INDENT> return nums [ 0 ] <NEWLINE> <DEDENT> return functools . reduce ( euclid , nums ) <NEWLINE> <NL> <NL> <NL> <DEDENT> n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . append ( k ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> sa = [ ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sa . append ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( gcd ( sa ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for own in range ( n ) : <NEWLINE> <INDENT> is_good = True <NEWLINE> for pair in edges [ own ] : <NEWLINE> <INDENT> if h [ own ] <= h [ pair ] : <NEWLINE> <INDENT> is_good = False <NEWLINE> <DEDENT> <DEDENT> if is_good : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> re = 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if array [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= array [ i ] <NEWLINE> if ans > re : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
import collections as col <NEWLINE> cnt = col . Counter ( ) <NEWLINE> cnt [ 0 ] += 1 <NEWLINE> <NL> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> num = 0 <NEWLINE> for i , s in enumerate ( s [ : : - 1 ] ) : <NEWLINE> <INDENT> num += int ( s ) * pow ( 10 , i , 2019 ) <NEWLINE> cnt [ num % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for key , val in cnt . items ( ) : <NEWLINE> <INDENT> ans += val * ( val - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prev = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if i == 0 : continue <NEWLINE> prev = a [ cnt ] <NEWLINE> crnt = a [ i ] <NEWLINE> if crnt > prev : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> prev = crnt <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def insertionSort ( nums , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> i = g <NEWLINE> n = len ( nums ) <NEWLINE> while i < n : <NEWLINE> <INDENT> v = nums [ i ] <NEWLINE> j = i - g <NEWLINE> while 0 <= j and v < nums [ j ] : <NEWLINE> <INDENT> nums [ j + g ] = nums [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> nums [ j + g ] = v <NEWLINE> i += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def shellSort ( nums , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> g = [ ] <NEWLINE> val = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> val = 3 * val + 1 <NEWLINE> if n < val : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> g . append ( val ) <NEWLINE> <NL> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> cnt += insertionSort ( nums , g [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> nums . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> shellSort ( nums , n ) <NEWLINE> for val in nums : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> y = math . gcd ( l , x ) <NEWLINE> ans += y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( N == 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P_set = list ( set ( P ) ) <NEWLINE> <NL> <NL> ans_chk = 0 <NEWLINE> <NL> if ( X < P_set [ 0 ] or X > P_set [ N - 1 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( X ) <NEWLINE> ans_chk = 1 <NEWLINE> <NL> <DEDENT> if ( ans_chk == 0 ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( P_set [ i ] == X ) : <NEWLINE> <INDENT> X_i = i <NEWLINE> break <NEWLINE> <DEDENT> elif ( P_set [ i ] > X ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( X ) <NEWLINE> ans_chk = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( ans_chk == 0 ) : <NEWLINE> <NL> <INDENT> if ( X_i > N - ( X_i + 1 ) ) : <COMMENT> <NEWLINE> <INDENT> M = N - ( X_i + 1 ) <NEWLINE> temp_ans = X + N - ( X_i + 1 ) + 1 <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if ( P_set [ X_i - i ] != X - i ) : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> ans_chk = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif ( P_set [ X_i + i ] != X + i ) : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> ans_chk = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans_chk == 0 ) : <NEWLINE> <INDENT> if ( P_set [ X_i - ( M + 1 ) ] != X - ( M + 1 ) ) : <NEWLINE> <INDENT> print ( X - ( M + 1 ) ) <NEWLINE> ans_chk = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> M = X_i <NEWLINE> temp_ans = X - X_i - 1 <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if ( P_set [ X_i - i ] != X - i ) : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> ans_chk = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif ( P_set [ X_i + i ] != X + i ) : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> ans_chk = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( ans_chk == 0 ) : <NEWLINE> <INDENT> print ( temp_ans ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> l_s = len ( s ) <NEWLINE> l_t = len ( t ) <NEWLINE> <NL> s2 = s + s <NEWLINE> l_s2 = len ( s2 ) <NEWLINE> <NL> next_idx = [ [ l_s2 ] * 26 for i in range ( l_s2 ) ] <NEWLINE> <NL> for i in reversed ( range ( 1 , l_s2 ) ) : <NEWLINE> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> next_idx [ i - 1 ] [ j ] = next_idx [ i ] [ j ] <NEWLINE> <DEDENT> next_idx [ i - 1 ] [ ord ( s2 [ i ] ) - ord ( <STRING> ) ] = i <NEWLINE> <NL> <DEDENT> cur_idx = 0 <NEWLINE> for i in range ( l_t ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> for j in range ( l_s ) : <NEWLINE> <INDENT> if t [ i ] == s [ j ] : <NEWLINE> <INDENT> cur_idx += j <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = next_idx [ cur_idx % l_s ] [ ord ( t [ i ] ) - ord ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> if idx == l_s2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cur_idx += idx - ( cur_idx % l_s ) <NEWLINE> <NL> <DEDENT> print ( cur_idx + 1 ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> now = 1 <NEWLINE> tmp = [ deque ( [ ] ) , deque ( [ ] ) ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> t = list ( input ( ) . split ( ) ) <NEWLINE> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> now = 1 + ( now == 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( t [ 1 ] ) == now : <NEWLINE> <INDENT> tmp [ 0 ] . append ( t [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp [ 1 ] . append ( t [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> if now == 1 : <NEWLINE> <INDENT> i , j = 0 , 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i , j = 1 , 0 <NEWLINE> <DEDENT> while len ( tmp [ i ] ) > 0 : <NEWLINE> <INDENT> ans += tmp [ i ] . pop ( ) <NEWLINE> <DEDENT> if now == 2 : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> <DEDENT> ans += S <NEWLINE> while len ( tmp [ j ] ) > 0 : <NEWLINE> <INDENT> ans += tmp [ j ] . popleft ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readList ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readMap ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def readStr ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> import math <NEWLINE> from itertools import permutations <NEWLINE> def solve ( N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> count += ( N - 1 ) // i <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> N = readInt ( ) <NEWLINE> print ( solve ( N ) ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> max_dp = np . max ( A ) + 1 <NEWLINE> dp = np . zeros ( max_dp , dtype = <STRING> ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if dp [ a ] >= 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> fancy = np . arange ( a , max_dp , a ) <NEWLINE> dp [ fancy ] += 2 <NEWLINE> dp [ a ] -= 1 <NEWLINE> <DEDENT> print ( np . sum ( dp == 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Highs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Roads = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> winner = set ( ) <NEWLINE> looser = set ( ) <NEWLINE> appears = set ( ) <NEWLINE> <NL> def devide ( w , l ) : <NEWLINE> <INDENT> if w not in looser : <NEWLINE> <INDENT> winner . add ( w ) <NEWLINE> <DEDENT> if l not in looser : <NEWLINE> <INDENT> looser . add ( l ) <NEWLINE> <DEDENT> if l in winner : <NEWLINE> <INDENT> winner . remove ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT> def remove ( e ) : <NEWLINE> <INDENT> if e not in looser : <NEWLINE> <INDENT> looser . add ( e ) <NEWLINE> <DEDENT> if e in winner : <NEWLINE> <INDENT> winner . remove ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> for road in Roads : <NEWLINE> <INDENT> f = road [ 0 ] <NEWLINE> t = road [ 1 ] <NEWLINE> <NL> appears . add ( f ) <NEWLINE> appears . add ( t ) <NEWLINE> <NL> f_h = Highs [ f - 1 ] <NEWLINE> t_h = Highs [ t - 1 ] <NEWLINE> <NL> if f_h > t_h : <NEWLINE> <INDENT> devide ( f , t ) <NEWLINE> <DEDENT> elif f_h < t_h : <NEWLINE> <INDENT> devide ( t , f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> remove ( t ) <NEWLINE> remove ( f ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( winner ) + N - len ( appears ) ) <NEWLINE>
def digitSum ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = str ( n ) <NEWLINE> <COMMENT> <NL> array = list ( map ( int , s ) ) <NEWLINE> <COMMENT> <NL> return sum ( array ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> if digitSum ( N ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = a [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x *= a [ i + 1 ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = <STRING> ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> q = int ( ( A >> i & 0b1 ) . sum ( ) ) <NEWLINE> ans += q * ( n - q ) * pow ( 2 , i , mod ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> H = INT ( ) <NEWLINE> <COMMENT> <NL> A = [ <STRING> ] + LIST ( ) <NEWLINE> <NL> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> l = i * 2 <NEWLINE> r = i * 2 + 1 <NEWLINE> if l <= H and A [ l ] > A [ i ] : <NEWLINE> <INDENT> mx = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mx = i <NEWLINE> <DEDENT> if r <= H and A [ r ] > A [ mx ] : <NEWLINE> <INDENT> mx = r <NEWLINE> <DEDENT> if mx != i : <NEWLINE> <INDENT> A [ i ] , A [ mx ] = A [ mx ] , A [ i ] <NEWLINE> maxHeapify ( A , mx ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( H // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( A , i ) <NEWLINE> <NL> <DEDENT> print ( * A ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in d : <NEWLINE> <INDENT> ans += d [ s ] <NEWLINE> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = 1 <NEWLINE> r = N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , L ) <NEWLINE> r = min ( r , R ) <NEWLINE> <DEDENT> ans = r - l + 1 <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ 0 ] * k <NEWLINE> sunuke = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sunuke . setdefault ( str ( i ) , 0 ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> for j in range ( d [ i ] ) : <NEWLINE> <INDENT> sunuke [ str ( A [ j ] - 1 ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = list ( sunuke . values ( ) ) . count ( 0 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> bits = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> if ( x >> i ) & 1 : <NEWLINE> <INDENT> bits += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ( ( bits * ( N - bits ) ) * 2 ** i ) % mod <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> color = [ - 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> w %= 2 <NEWLINE> graph [ a ] . append ( ( b , w ) ) <NEWLINE> graph [ b ] . append ( ( a , w ) ) <NEWLINE> <NL> <DEDENT> next_q = [ ( 0 , 0 ) ] <NEWLINE> while len ( next_q ) > 0 : <NEWLINE> <INDENT> nw , nc = next_q . pop ( ) <NEWLINE> color [ nw ] = nc <NEWLINE> for nxt , nl in graph [ nw ] : <NEWLINE> <INDENT> if color [ nxt ] == - 1 : <NEWLINE> <INDENT> next_q . append ( ( nxt , ( nl + nc ) % 2 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in color : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> sum_a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] ** 2 <NEWLINE> sum_a += a [ i ] <NEWLINE> <DEDENT> tmp = ( sum_a ** 2 - ans ) // 2 <NEWLINE> print ( tmp % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> import sys <NEWLINE> <NL> __input = sys . stdin . readlines ( ) <NEWLINE> length_1 = int ( __input [ 0 ] ) <NEWLINE> array_1 = list ( map ( int , __input [ 1 ] . split ( ) ) ) <NEWLINE> length_2 = int ( __input [ 2 ] ) <NEWLINE> array_2 = list ( map ( int , __input [ 3 ] . split ( ) ) ) <NEWLINE> <NL> record = [ False ] * 2000 <NEWLINE> <NL> <NL> def solution ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> assert length_1 == len ( array_1 ) and length_2 == len ( array_2 ) <NEWLINE> <NL> for i in array_1 : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( 2000 - i , 0 , - 1 ) : <NEWLINE> <INDENT> if record [ j ] : <NEWLINE> <COMMENT> <NL> <INDENT> record [ i + j ] = True <NEWLINE> <DEDENT> <DEDENT> record [ i ] = True <NEWLINE> <NL> <DEDENT> for index in array_2 : <NEWLINE> <INDENT> if record [ index ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter , defaultdict <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> S = read ( ) . decode ( ) . rstrip ( ) <NEWLINE> <NL> reminders = defaultdict ( lambda : 0 ) <NEWLINE> tmp = 0 <NEWLINE> mul = 1 <NEWLINE> <NL> for c in S [ : : - 1 ] : <NEWLINE> <INDENT> c = int ( c ) <NEWLINE> tmp = ( tmp + c * mul ) % 2019 <NEWLINE> mul = mul * 10 % 2019 <NEWLINE> reminders [ tmp ] += 1 <NEWLINE> <DEDENT> reminders [ 0 ] += 1 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for r , cnt in reminders . items ( ) : <NEWLINE> <INDENT> ans += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Aset = set ( A ) <NEWLINE> <NL> if 0 in Aset : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> A . sort ( reverse = True ) <NEWLINE> <NL> res = 1 <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> res *= A [ i ] <NEWLINE> if res > INF : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . sort ( reverse = True ) <NEWLINE> t = 0 <NEWLINE> <NL> del h [ 0 : k ] <NEWLINE> <NL> if len ( h ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += sum ( h ) <NEWLINE> print ( t ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <NL> N = 1000000 <NEWLINE> primes = [ 1 ] * N <NEWLINE> primes [ 0 : 2 ] = [ 0 , 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if primes [ i ] == 1 : <NEWLINE> <INDENT> j = i + i <NEWLINE> while j <= N : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> j += i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> for query in map ( int , sys . stdin ) : <NEWLINE> <INDENT> print ( sum ( primes [ 2 : query + 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> sum = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum += ( c - b ) * num [ b - 1 ] <NEWLINE> num [ c - 1 ] += num [ b - 1 ] <NEWLINE> num [ b - 1 ] = 0 <NEWLINE> <NL> print ( sum ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> s = input ( ) . rstrip ( ) <NEWLINE> n = len ( s ) <NEWLINE> t = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if s [ : i ] + s [ j : ] == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> con = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s [ s [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> con += 1 <NEWLINE> <DEDENT> <DEDENT> print ( con // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = n % 1000 <NEWLINE> if k != 0 : <NEWLINE> <INDENT> print ( 1000 - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> sums = 0 <NEWLINE> <NL> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for k in range ( n ) : <NEWLINE> <INDENT> if s [ k ] == <STRING> : <NEWLINE> <INDENT> r . append ( k ) <NEWLINE> for p in range ( 0 , min ( k + 1 , n - k ) ) : <NEWLINE> <INDENT> if { s [ k - p ] , s [ k + p ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> sums -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s [ k ] == <STRING> : <NEWLINE> <INDENT> g . append ( k ) <NEWLINE> for p in range ( 0 , min ( k + 1 , n - k ) ) : <NEWLINE> <INDENT> if { s [ k - p ] , s [ k + p ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> sums -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b . append ( k ) <NEWLINE> for p in range ( 0 , min ( k + 1 , n - k ) ) : <NEWLINE> <INDENT> if { s [ k - p ] , s [ k + p ] } == { <STRING> , <STRING> } : <NEWLINE> <INDENT> sums -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sums += len ( r ) * len ( g ) * len ( b ) <NEWLINE> print ( sums ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> final = - 1 <NEWLINE> <NL> q , n = X % D , X // D <NEWLINE> <NL> if n >= K : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if q <= X / 2 : <NEWLINE> <INDENT> if ( K - n ) % 2 == 0 : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - q ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( K - n ) % 2 == 0 : <NEWLINE> <INDENT> print ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - q ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> Sliststr = list ( S ) <NEWLINE> Slist = [ int ( s ) for s in Sliststr ] <NEWLINE> Smod = [ 0 ] <NEWLINE> mod10 = [ 1 ] <NEWLINE> count = [ 0 ] * 2019 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> mod10 . append ( mod10 [ i ] * 10 % 2019 ) <NEWLINE> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> Smod . append ( ( Smod [ i ] + Slist [ - i - 1 ] * mod10 [ i ] ) % 2019 ) <NEWLINE> <DEDENT> for i in range ( len ( Smod ) ) : <NEWLINE> <INDENT> count [ Smod [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += count [ i ] * ( count [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if len ( str ( abs ( a - b ) ) ) > 18 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( a - b ) * ( - 1 ) ** ( k % 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> def L ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> import collections <NEWLINE> <NL> def solver ( N , A , Q , BC ) : <NEWLINE> <INDENT> T = sum ( map ( int , A ) ) <NEWLINE> <COMMENT> <NL> <NL> Nums = collections . Counter ( A ) <NEWLINE> <COMMENT> <NL> for b , c in BC : <NEWLINE> <INDENT> diff = c - b <NEWLINE> <NL> T += Nums [ b ] * diff <NEWLINE> print ( T ) <NEWLINE> <NL> Nums [ c ] += Nums [ b ] <NEWLINE> Nums [ b ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> Q = I ( ) <NEWLINE> BC = [ ] * Q <NEWLINE> BC = [ LI ( ) for _ in range ( Q ) ] <NEWLINE> <NL> solver ( N , A , Q , BC ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a + b < k : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> num = [ 0 ] <NEWLINE> be = <STRING> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if be == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> num . append ( num [ - 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> num . append ( num [ - 1 ] ) <NEWLINE> <NL> <DEDENT> be = s [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( abs ( num [ l ] - num [ r ] ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> from bisect import bisect_left <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> dp = [ - float ( <STRING> ) ] <NEWLINE> n = int ( readline ( ) ) <NEWLINE> a = ( int ( readline ( ) ) for _ in range ( n ) ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> if dp [ - 1 ] < ai : <NEWLINE> <INDENT> dp . append ( ai ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ bisect_left ( dp , ai ) ] = ai <NEWLINE> <DEDENT> <DEDENT> print ( len ( dp ) - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( list ) ) ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> h = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> <NL> <COMMENT> <NL> inf = 10 ** 9 <NEWLINE> dp = np . full ( N , inf , np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> <NL> for i , e in enumerate ( h [ 1 : ] , 1 ) : <NEWLINE> <INDENT> lb = max ( 0 , i - K ) <NEWLINE> dp [ i ] = np . min ( dp [ lb : i ] + np . abs ( h [ lb : i ] - e ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
input ( ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ 0 ] * ( 10 ** 7 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> D [ a - 1 ] += 1 <NEWLINE> D [ a ] += 1 <NEWLINE> D [ a + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( D ) ) <NEWLINE>
def n0 ( ) : return int ( input ( ) ) <NEWLINE> def n1 ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def n2 ( n ) : return [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def n3 ( n ) : return [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] <NEWLINE> <NL> n , m , x = n1 ( ) <NEWLINE> ca = n3 ( n ) <NEWLINE> ans = 9999999999 <NEWLINE> <NL> import itertools <NEWLINE> book = list ( itertools . product ( [ 0 , 1 ] , repeat = n ) ) <NEWLINE> price = [ ] <NEWLINE> for line in book : <NEWLINE> <INDENT> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if line [ i ] == 1 : <NEWLINE> <INDENT> p += ca [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> price . append ( p ) <NEWLINE> <DEDENT> for i in range ( len ( book ) ) : <NEWLINE> <INDENT> t = book [ i ] <NEWLINE> s = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if t [ j ] == 1 : <NEWLINE> <INDENT> s = [ s [ k ] + ca [ j ] [ k + 1 ] for k in range ( m ) ] <NEWLINE> <DEDENT> <DEDENT> if len ( [ y for y in s if y >= x ] ) == m : <NEWLINE> <INDENT> ans = min ( ans , price [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if ans == 9999999999 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 for _ in range ( W + 1 ) ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( W , 0 , - 1 ) : <NEWLINE> <INDENT> if i >= w : <NEWLINE> <INDENT> a = dp [ i ] <NEWLINE> b = dp [ i - w ] + v <NEWLINE> if a > b : <NEWLINE> <INDENT> dp [ i ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if Y < 2 * X or Y > 4 * X or abs ( Y - 2 * X ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + k - 1 >= b - k + 1 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> b = 0 <NEWLINE> <NL> if N >= B : <NEWLINE> <INDENT> b = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = N <NEWLINE> <NL> <DEDENT> c = math . floor ( A * b / B ) - A * math . floor ( b / B ) <NEWLINE> print ( c ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ang = min ( h * 30 + ( m / 60 ) * 30 - m * 6 , 360 - ( h * 30 + ( m / 60 ) * 30 - m * 6 ) ) <NEWLINE> print ( math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( ang ) ) ) ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cnt += math . gcd ( tmp , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * m <NEWLINE> t = [ 0 ] * m <NEWLINE> temp = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sm , tm = map ( int , input ( ) . split ( ) ) <NEWLINE> s [ i ] = sm <NEWLINE> t [ i ] = tm <NEWLINE> temp . add ( ( s [ i ] , t [ i ] ) ) <NEWLINE> <DEDENT> st = [ 0 ] * h <NEWLINE> tt = [ 0 ] * w <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> st [ s [ i ] - 1 ] = st [ s [ i ] - 1 ] + 1 <NEWLINE> tt [ t [ i ] - 1 ] = tt [ t [ i ] - 1 ] + 1 <NEWLINE> <DEDENT> smax = max ( st ) <NEWLINE> tmax = max ( tt ) <NEWLINE> ans = smax + tmax <NEWLINE> maxs = [ ] <NEWLINE> maxt = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if st [ i ] == smax : <NEWLINE> <INDENT> maxs . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if tt [ i ] == tmax : <NEWLINE> <INDENT> maxt . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( maxs ) * len ( maxt ) > m : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( maxs ) ) : <NEWLINE> <INDENT> for j in range ( len ( maxt ) ) : <NEWLINE> <INDENT> if ( maxs [ i ] + 1 , maxt [ j ] + 1 ) not in temp : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = collections . Counter ( A ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> max = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> D [ C ] += B <NEWLINE> <NL> <DEDENT> D = sorted ( D . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> sum = 0 <NEWLINE> count = 0 <NEWLINE> for k , v in D : <NEWLINE> <INDENT> if N > v : <NEWLINE> <INDENT> sum += k * v <NEWLINE> N -= v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += k * N <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> area = math . pi * r ** 2 <NEWLINE> length = 2 * math . pi * r <NEWLINE> print ( <STRING> ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> dp = [ True ] + [ False ] * ( X ) <NEWLINE> <NL> if X < 106 : <NEWLINE> <INDENT> if 100 <= X <= 105 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 100 , 106 ) : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> <NL> <DEDENT> for i in range ( 106 , X + 1 ) : <NEWLINE> <INDENT> for j in range ( 100 , 106 ) : <NEWLINE> <INDENT> if dp [ i - j ] == True : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( 1 if dp [ X ] == True else 0 ) <NEWLINE>
import numpy as np <NEWLINE> import networkx as nx <NEWLINE> g = nx . Graph ( ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g . add_edge ( a , b ) <NEWLINE> <NL> <DEDENT> res = np . array ( [ 0 ] * 2 + [ - 1 ] * ( n - 1 ) ) <NEWLINE> <NL> from collections import deque <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> vis = q . popleft ( ) <COMMENT> <NEWLINE> <COMMENT> <NL> cands = list ( nx . all_neighbors ( g , vis ) ) <COMMENT> <NEWLINE> <NL> if cands : <NEWLINE> <INDENT> for c in cands : <NEWLINE> <INDENT> if res [ c ] == - 1 : <NEWLINE> <INDENT> res [ c ] = vis <COMMENT> <NEWLINE> q . append ( c ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( res == - 1 ) . sum ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in res [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
n_m = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> <NL> n = int ( n_m [ 0 ] ) <NEWLINE> m = int ( n_m [ 1 ] ) <NEWLINE> <NL> a_i = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> a_i_list = [ int ( i ) for i in a_i [ : m ] ] <NEWLINE> <NL> finish_day = sum ( a_i_list ) <NEWLINE> <NL> if n >= finish_day : <NEWLINE> <INDENT> ans = n - finish_day <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( N + 1 ) ] <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> par [ x ] = y <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( a , b ) <NEWLINE> <DEDENT> ans = dict ( ) <NEWLINE> for i in par : <NEWLINE> <INDENT> tmp = find ( i ) <NEWLINE> if tmp in ans : <NEWLINE> <INDENT> ans [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ tmp ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans . values ( ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> P . sort ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> s += P [ i ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
def is_prime ( num ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( num ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> nums = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> print ( sum ( map ( is_prime , nums ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> product = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> product *= a [ i ] <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if product <= 10 ** 18 : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> def nu ( x ) : <NEWLINE> <INDENT> if x == <STRING> or x == <STRING> or x == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> def c ( a , b , l ) : <NEWLINE> <INDENT> if l == <STRING> : <NEWLINE> <INDENT> d = a + b <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> d = a - b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = a * b <NEWLINE> <DEDENT> return d <NEWLINE> <DEDENT> F = [ i for i in input ( ) . split ( ) ] <NEWLINE> i = 0 <NEWLINE> S = [ ] <NEWLINE> while i < len ( F ) : <NEWLINE> <INDENT> if nu ( F [ i ] ) == 0 : <NEWLINE> <INDENT> S [ - 2 ] = c ( S [ - 2 ] , S [ - 1 ] , F [ i ] ) <NEWLINE> S . pop ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( int ( F [ i ] ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( S [ 0 ] ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = list ( range ( - 1 , 102 ) ) <NEWLINE> for p in ps : <NEWLINE> <INDENT> nums . remove ( p ) <NEWLINE> <DEDENT> min_diff = float ( <STRING> ) <NEWLINE> min_original = float ( <STRING> ) <NEWLINE> for num in nums : <NEWLINE> <INDENT> diff = abs ( num - x ) <NEWLINE> if diff < min_diff : <NEWLINE> <INDENT> min_diff = diff <NEWLINE> min_original = num <NEWLINE> <DEDENT> elif diff == min_diff : <NEWLINE> <INDENT> if num < min_original : <NEWLINE> <INDENT> min_original = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min_original ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ans = [ ] <NEWLINE> c = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i in a : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += [ c ] <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> ans += [ c ] <NEWLINE> if ans == [ ] : <NEWLINE> <INDENT> print ( len ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( ans ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> b = ( n - 1 ) // a <NEWLINE> count += b <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> Ans = [ ] <NEWLINE> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> ab = i ** 5 - j ** 5 <NEWLINE> if ab == X : <NEWLINE> <INDENT> Ans . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = Ans [ 0 ] <NEWLINE> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> l = [ 1 ] + [ 0 for _ in range ( n + 5 ) ] <NEWLINE> if m == 0 : a = [ 200000 ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> if x < a [ 0 ] : <NEWLINE> <INDENT> l [ x + 1 ] += l [ x ] <NEWLINE> l [ x + 2 ] += l [ x ] <NEWLINE> <DEDENT> if x == a [ 0 ] : <NEWLINE> <INDENT> if len ( a ) >= 2 : a . pop ( 0 ) <NEWLINE> else : a [ 0 ] = 200000 <NEWLINE> <DEDENT> <DEDENT> print ( l [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
a , b , c , d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( max ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> strings = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( list ( input ( ) ) ) ) <NEWLINE> if s in strings : <NEWLINE> <INDENT> strings [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> strings [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( list ( map ( lambda x : x * ( x - 1 ) // 2 , strings . values ( ) ) ) ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> i = min ( B - 1 , N ) <NEWLINE> <NL> print ( ( A * i ) // B - A * ( i // B ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> LIMIT = 1000000 <NEWLINE> p = 2 <NEWLINE> pList = [ True ] * ( LIMIT + 1 ) <NEWLINE> <NL> <NL> while p ** 2 <= LIMIT : <NEWLINE> <INDENT> if ( pList [ p ] ) : <NEWLINE> <INDENT> for i in range ( p * 2 , LIMIT + 1 , p ) : <NEWLINE> <INDENT> pList [ i ] = False <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> lines = str ( sys . stdin . read ( ) ) . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> for line in lines : <NEWLINE> <INDENT> line = int ( line ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 2 , line + 1 ) : <NEWLINE> <INDENT> if pList [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 1 <NEWLINE> zero_check = 0 in a <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> answer = a [ i ] * answer <NEWLINE> if zero_check : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> elif answer > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> k = k * i <NEWLINE> if k > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if k <= 10 ** 18 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b . append ( A [ i ] ) <NEWLINE> <DEDENT> b . append ( 0 ) <NEWLINE> <NL> sumb = 0 <NEWLINE> for i in range ( 1 , len ( b ) ) : <NEWLINE> <INDENT> sumb += abs ( b [ i ] - b [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sumc = sumb <NEWLINE> sumc = sumc - abs ( b [ j + 1 ] - b [ j ] ) - abs ( b [ j ] - b [ j - 1 ] ) + abs ( b [ j + 1 ] - b [ j - 1 ] ) <NEWLINE> print ( sumc ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_s = s [ : k ] + <STRING> <NEWLINE> print ( t_s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> from copy import deepcopy , copy <NEWLINE> class Node : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , value = None ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <DEDENT> <DEDENT> class BinTree : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> ] <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> self . _tree = None <NEWLINE> <DEDENT> def insert ( self , value ) : <NEWLINE> <INDENT> p = None <NEWLINE> c = self . _tree <NEWLINE> while c is not None : <NEWLINE> <INDENT> p = c <NEWLINE> if value < c . value : <NEWLINE> <INDENT> c = c . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c . right <NEWLINE> <DEDENT> <DEDENT> if p is None : <NEWLINE> <INDENT> self . _tree = Node ( value ) <NEWLINE> <DEDENT> elif value < p . value : <NEWLINE> <INDENT> p . left = Node ( value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . right = Node ( value ) <NEWLINE> <DEDENT> <DEDENT> def find ( self , value ) : <NEWLINE> <INDENT> c = self . _tree <NEWLINE> while c is not None : <NEWLINE> <INDENT> if value == c . value : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif value < c . value : <NEWLINE> <INDENT> c = c . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c . right <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> def delete ( self , value ) : <NEWLINE> <INDENT> parent = None <NEWLINE> current = self . _tree <NEWLINE> while current . value != value : <NEWLINE> <INDENT> parent = current <NEWLINE> if current is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif value < current . value : <NEWLINE> <INDENT> current = current . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current = current . right <NEWLINE> <DEDENT> <DEDENT> if current . left is None and current . right is None : <NEWLINE> <INDENT> if parent . left is current : <NEWLINE> <INDENT> parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = None <NEWLINE> <DEDENT> <DEDENT> elif current . left is None : <NEWLINE> <INDENT> if parent . left is current : <NEWLINE> <INDENT> parent . left = current . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = current . right <NEWLINE> <DEDENT> <DEDENT> elif current . right is None : <NEWLINE> <INDENT> if parent . left is current : <NEWLINE> <INDENT> parent . left = current . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = current . left <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> next_node_parent = current <NEWLINE> next_node = current . right <NEWLINE> while next_node . left is not None : <NEWLINE> <INDENT> next_node_parent = next_node <NEWLINE> next_node = next_node . left <NEWLINE> <DEDENT> if next_node . right is None : <NEWLINE> <INDENT> if next_node_parent . left is next_node : <NEWLINE> <INDENT> next_node_parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next_node_parent . right = None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if next_node_parent . left is next_node : <NEWLINE> <INDENT> next_node_parent . left = next_node . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next_node_parent . right = next_node . right <NEWLINE> <DEDENT> <DEDENT> current . value = next_node . value <NEWLINE> <DEDENT> <DEDENT> def preoder_walk ( self ) : <NEWLINE> <INDENT> self . result = [ ] <NEWLINE> def preoder ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> self . result . append ( node . value ) <NEWLINE> preoder ( node . left ) <NEWLINE> preoder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> preoder ( self . _tree ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , self . result ) ) ) <NEWLINE> <DEDENT> def inorder_walk ( self ) : <NEWLINE> <INDENT> self . result = [ ] <NEWLINE> def inorder ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> inorder ( node . left ) <NEWLINE> self . result . append ( node . value ) <NEWLINE> inorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> inorder ( self . _tree ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , self . result ) ) ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = BinTree ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> com = readline ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if tree . find ( int ( com [ 1 ] ) ) else <STRING> ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . delete ( int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . inorder_walk ( ) <NEWLINE> tree . preoder_walk ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import itertools <NEWLINE> def bfs ( G , visited , sy , sx ) : <NEWLINE> <INDENT> queue = deque ( [ [ sy , sx ] ] ) <NEWLINE> visited [ sy ] [ sx ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> y , x = queue . popleft ( ) <NEWLINE> if ( y , x ) == ( H - 1 , W - 1 ) : <NEWLINE> <INDENT> return visited [ y ] [ x ] <NEWLINE> <DEDENT> for j , k in ( [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ) : <NEWLINE> <INDENT> tmp_y , tmp_x = y + j , x + k <NEWLINE> if 0 <= tmp_y <= H - 1 and 0 <= tmp_x <= W - 1 and G [ tmp_y ] [ tmp_x ] != <STRING> : <NEWLINE> <INDENT> if visited [ tmp_y ] [ tmp_x ] == - 1 : <NEWLINE> <INDENT> visited [ tmp_y ] [ tmp_x ] = visited [ y ] [ x ] + 1 <NEWLINE> queue . append ( [ tmp_y , tmp_x ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> sy , sx = 0 , 0 <NEWLINE> dist = 0 <NEWLINE> visited = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> dist = bfs ( G , visited , sy , sx ) <NEWLINE> if dist == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( list ( itertools . chain . from_iterable ( G ) ) . count ( <STRING> ) - dist - 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> sum_A = sum ( A ) <NEWLINE> <NL> tot = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum_A -= A [ i ] <NEWLINE> tot += A [ i ] * sum_A <NEWLINE> <NL> <DEDENT> print ( tot % 1000000007 ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> D = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D = L [ i ] + D <NEWLINE> <COMMENT> <NL> if D > X : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mul = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> mul = mul * i <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> mul = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> mul = 0 <NEWLINE> <NL> <DEDENT> print ( mul ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans , a , b = 0 , [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( x + y ) <NEWLINE> b . append ( [ x , y ] ) <NEWLINE> <DEDENT> num = [ x for x in range ( n ) ] <NEWLINE> a , a0 = zip ( * sorted ( zip ( a , num ) ) ) <NEWLINE> a , a0 = list ( a ) , list ( a0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> val = a0 . pop ( ) <NEWLINE> a . pop ( ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> ans += b [ val ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= b [ val ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> path = [ 1 ] <NEWLINE> for i in range ( 2 * N ) : <NEWLINE> <INDENT> cur = A [ path [ - 1 ] - 1 ] <NEWLINE> path . append ( cur ) <NEWLINE> <NL> <DEDENT> if K < N : <NEWLINE> <INDENT> print ( path [ K ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> end = N <NEWLINE> si = N - 1 <NEWLINE> while path [ si ] != path [ end ] : <NEWLINE> <INDENT> si -= 1 <NEWLINE> <DEDENT> dist = end - si <NEWLINE> K = K % dist <NEWLINE> while K < N : <NEWLINE> <INDENT> K += dist <NEWLINE> <NL> <DEDENT> print ( path [ K ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = [ 0 ] * n <NEWLINE> for i in ls_a : <NEWLINE> <INDENT> ls [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in ls : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> def is_leapyear ( year ) : <NEWLINE> <INDENT> return year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> leapyear = [ year for year in range ( a , b + 1 ) if is_leapyear ( year ) ] <NEWLINE> print ( <STRING> . join ( map ( str , leapyear ) ) if leapyear else <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import collections <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> N = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> <NL> ans = 0 <NEWLINE> x = [ 0 ] * N <NEWLINE> x [ 0 ] = int ( S [ 0 ] ) % mod <NEWLINE> ruijo = 10 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x [ i ] = ( ruijo * int ( S [ i ] ) + x [ i - 1 ] ) % mod <NEWLINE> if x [ i ] % mod == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> ruijo *= 10 <NEWLINE> ruijo %= mod <NEWLINE> <NL> <DEDENT> d = collections . Counter ( x ) <NEWLINE> <NL> for i in d . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> aL = list ( map ( lambda x : int ( x ) * ( - 1 ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> heapq . heapify ( aL ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a = heapq . heappop ( aL ) <NEWLINE> a = int ( a / 2 ) <NEWLINE> heapq . heappush ( aL , a ) <NEWLINE> <NL> <DEDENT> print ( int ( sum ( aL ) * - 1 ) ) <NEWLINE>
from itertools import combinations <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if y % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 2 * x == y or 4 * x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = 0 <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( x - i ) == y or 4 * i + 2 * ( x - i ) == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> v = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if v == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> class Prime ( ) : <NEWLINE> <INDENT> def __init__ ( self , m ) : <NEWLINE> <INDENT> self . M = m + 1 <NEWLINE> self . A = a = [ True ] * self . M <NEWLINE> a [ 0 ] = a [ 1 ] = 0 <NEWLINE> self . T = t = [ ] <NEWLINE> sq = int ( math . sqrt ( self . M ) ) <NEWLINE> q = 0 <NEWLINE> for i in range ( 2 , sq + 1 ) : <NEWLINE> <INDENT> if not a [ i ] : <NEWLINE> <INDENT> a [ i ] = q <NEWLINE> continue <NEWLINE> <DEDENT> t . append ( i ) <NEWLINE> a [ i ] = q <NEWLINE> q += 1 <NEWLINE> for j in range ( i * i , m , i ) : <NEWLINE> <INDENT> a [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( sq + 1 , self . M ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> a [ i ] = q <NEWLINE> q += 1 <NEWLINE> t . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = q <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def is_prime ( self , n ) : <NEWLINE> <INDENT> return self . A [ n ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> M = 7368792 <NEWLINE> pr = Prime ( M ) <NEWLINE> <NL> def f ( m , n ) : <NEWLINE> <INDENT> nn = n <NEWLINE> g = [ None ] * ( m * m ) <NEWLINE> for i in range ( m , m * m ) : <NEWLINE> <INDENT> if not g [ i ] : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> n -= 1 <NEWLINE> for j in range ( i , m * m , i ) : <NEWLINE> <INDENT> g [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> d = pr . A [ m * m ] <NEWLINE> return pr . T [ d + n ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m , n = LI ( ) <NEWLINE> if m == 0 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( m , n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ [ ] for _ in range ( n ) ] <NEWLINE> C = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c_as = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] , A [ i ] = c_as [ 0 ] , c_as [ 1 : ] <NEWLINE> <NL> <DEDENT> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> <NL> for s in range ( 1 << n ) : <NEWLINE> <INDENT> smart = [ 0 ] * m <NEWLINE> cost_sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( s >> i ) % 2 == 0 : continue <NEWLINE> cost_sum += C [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> smart [ j ] += A [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> ok = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if x > smart [ i ] : <NEWLINE> <INDENT> ok = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , cost_sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , a = int ( input ( ) ) , 0 <NEWLINE> V = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = V [ i ] - C [ i ] <NEWLINE> if ans > 0 : <NEWLINE> <INDENT> a += ans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> ans = 0 <NEWLINE> ans += A [ 0 ] <NEWLINE> <NL> if len ( A ) % 2 == 0 : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( 1 , int ( ( N - 2 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> tmp += A [ i ] * 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( 1 , int ( ( N - 1 ) / 2 ) + 1 ) : <NEWLINE> <INDENT> tmp += A [ i ] * 2 <NEWLINE> <DEDENT> tmp -= A [ int ( ( N - 1 ) / 2 ) ] <NEWLINE> <NL> <DEDENT> ans += tmp <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return solve ( N , S , A ) <NEWLINE> <NL> <DEDENT> def solve ( N , S , A ) : <NEWLINE> <INDENT> mod = 998244353 <NEWLINE> dp = [ 0 ] * ( S + 1 ) <NEWLINE> dp [ 0 ] = pow ( 2 , N , mod ) <NEWLINE> div2 = pow ( 2 , mod - 2 , mod ) <NEWLINE> m = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> m += a <NEWLINE> for i in reversed ( range ( a , min ( S , m ) + 1 ) ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i ] + dp [ i - a ] * div2 ) % mod <NEWLINE> <DEDENT> <DEDENT> return dp [ S ] <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = N // i <NEWLINE> b = i * ( a + 1 ) * a // 2 <NEWLINE> ans += b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def set_array ( a , n ) : <NEWLINE> <INDENT> str = input ( ) <NEWLINE> array = str . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( array [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> set_array ( S , n ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> set_array ( T , q ) <NEWLINE> C = 0 <NEWLINE> <NL> def linear_search ( S , x ) : <NEWLINE> <INDENT> S . append ( x ) <NEWLINE> l = len ( S ) <NEWLINE> i = 0 <NEWLINE> while ( l > i ) : <NEWLINE> <INDENT> if S [ i ] == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> S . pop ( - 1 ) <NEWLINE> if i != l - 1 : <NEWLINE> <INDENT> return 1 ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 ; <NEWLINE> <DEDENT> <DEDENT> for v in T : <NEWLINE> <INDENT> C += linear_search ( S , v ) <NEWLINE> <NL> <DEDENT> print ( C ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if ans * i > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( k == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> s , a = divmod ( n , k ) <NEWLINE> <NL> t = k - a <NEWLINE> <NL> if ( a < t ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( <STRING> [ ( x + y ) % 2 ] for x in range ( w ) ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> items = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> items . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( items ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> list_in = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> counter = collections . Counter ( list_in ) <NEWLINE> sum = sum ( list_in ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> bc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> sum_diff = ( bc [ 1 ] - bc [ 0 ] ) * counter [ bc [ 0 ] ] <NEWLINE> counter [ bc [ 1 ] ] = counter [ bc [ 1 ] ] + counter [ bc [ 0 ] ] <NEWLINE> counter [ bc [ 0 ] ] = 0 <NEWLINE> print ( sum + sum_diff ) <NEWLINE> sum = sum + sum_diff <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> g . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 10 ** 9 for _ in range ( W ) ] for __ in range ( H ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] = 1 if g [ 0 ] [ 0 ] == <STRING> else 0 <NEWLINE> d = ( [ 0 , 1 ] , [ 1 , 0 ] ) <NEWLINE> for ix in range ( H ) : <NEWLINE> <INDENT> for jx in range ( W ) : <NEWLINE> <INDENT> for dx , dy in d : <NEWLINE> <INDENT> ni = ix + dx <NEWLINE> nj = jx + dy <NEWLINE> if ni >= H or nj >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> add = 0 <NEWLINE> if g [ ix ] [ jx ] == <STRING> and g [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> add += 1 <NEWLINE> <DEDENT> dp [ ni ] [ nj ] = min ( dp [ ni ] [ nj ] , dp [ ix ] [ jx ] + add ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ H - 1 ] [ W - 1 ] ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) ; count = 0 <NEWLINE> if k <= a : print ( k ) <NEWLINE> elif k <= a + b : print ( a ) <NEWLINE> else : print ( a - ( k - a - b ) ) <NEWLINE>
class Tree : <NEWLINE> <INDENT> def __init__ ( self , parent , left , right ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> <DEDENT> def getdepth ( u ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> depth = 0 <NEWLINE> j = i <NEWLINE> while trees [ j ] . parent != - 1 : <NEWLINE> <INDENT> j = trees [ j ] . parent <NEWLINE> depth += 1 <NEWLINE> <DEDENT> depths [ i ] = depth <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> trees = [ Tree ( - 1 , - 1 , - 1 ) for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> no = l [ 0 ] <NEWLINE> jisu = l [ 1 ] <NEWLINE> <COMMENT> <NL> childs = l [ 2 : ] <NEWLINE> for j in range ( jisu ) : <NEWLINE> <INDENT> child = childs [ j ] <NEWLINE> if j == 0 : <NEWLINE> <INDENT> trees [ no ] . left = child <NEWLINE> <NL> <DEDENT> if j != len ( childs ) - 1 : <NEWLINE> <INDENT> trees [ child ] . right = childs [ j + 1 ] <NEWLINE> <NL> <DEDENT> trees [ child ] . parent = no <NEWLINE> <NL> <DEDENT> <DEDENT> r = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if trees [ i ] . parent == - 1 : <NEWLINE> <INDENT> r = i <NEWLINE> <NL> <DEDENT> <DEDENT> depths = [ - 1 ] * N <NEWLINE> getdepth ( r ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> type = <STRING> <NEWLINE> if trees [ i ] . parent == - 1 : type = <STRING> <NEWLINE> elif trees [ i ] . left == - 1 : type = <STRING> <NEWLINE> else : type = <STRING> <NEWLINE> childs = <STRING> <NEWLINE> child = trees [ i ] . left <NEWLINE> while child != - 1 : <NEWLINE> <INDENT> childs += str ( child ) <NEWLINE> child = trees [ child ] . right <NEWLINE> if child != - 1 : childs += <STRING> <NEWLINE> <DEDENT> childs += <STRING> <NEWLINE> <NL> print ( <STRING> . format ( i , trees [ i ] . parent , depths [ i ] , type , childs ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> answer = 0 <NEWLINE> for w_a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for w_b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> w = math . gcd ( w_a , w_b ) <NEWLINE> for w_c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> answer += math . gcd ( w , w_c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> n , m , k = MI ( ) <NEWLINE> <NL> s = [ 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> s . append ( s [ - 1 ] * i % MOD ) <NEWLINE> <DEDENT> if m == 1 and k < n - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif m == 1 and k == n - 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif k == n - 1 : <NEWLINE> <INDENT> print ( pow ( m , n , MOD ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = m * pow ( m - 1 , n - 1 , MOD ) % MOD <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = m * pow ( m - 1 , n - 1 - i , MOD ) * s [ n - 2 ] * pow ( s [ n - 2 - i ] , MOD - 2 , MOD ) * pow ( s [ i - 1 ] , MOD - 2 , MOD ) <NEWLINE> ans += tmp <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while ( A or C <= 0 ) : <NEWLINE> <INDENT> C = C - B <NEWLINE> if ( C <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A = A - D <NEWLINE> if ( A <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = b [ 0 ] + b [ 2 : ] <NEWLINE> b = int ( b ) <NEWLINE> ans = a * b <NEWLINE> ans = str ( ans ) <NEWLINE> if len ( ans ) >= 3 : <NEWLINE> <INDENT> ans = ans [ : - 2 ] <NEWLINE> ans = int ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( N - 1 ) ] <NEWLINE> PX = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( Q ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> value = [ 0 ] * ( N + 1 ) <NEWLINE> for p , x in PX : <NEWLINE> <INDENT> value [ p ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v , parent , add ) : <NEWLINE> <INDENT> value [ v ] += add <NEWLINE> for x in graph [ v ] : <NEWLINE> <INDENT> if x == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( x , v , value [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , 0 , 0 ) <NEWLINE> <NL> answer = <STRING> . join ( map ( str , value [ 1 : ] ) ) <NEWLINE> print ( answer ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> for _ in range ( r ) : <NEWLINE> <INDENT> ns = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ns . append ( sum ( ns ) ) <NEWLINE> C . append ( ns ) <NEWLINE> <COMMENT> <NL> <DEDENT> R = list ( zip ( * C ) ) <NEWLINE> <COMMENT> <NL> C . append ( [ sum ( x ) for x in R ] ) <NEWLINE> for r in C : <NEWLINE> <INDENT> print ( * r ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def primeFactorization ( n ) : <NEWLINE> <INDENT> D = list ( range ( n + 1 ) ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if D [ i ] == i : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> if D [ j ] == j : <NEWLINE> <INDENT> D [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return D <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> <COMMENT> <NL> is_pc = True <NEWLINE> D = primeFactorization ( max ( A ) ) <NEWLINE> pf = set ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> tmp = i <NEWLINE> cnt = collections . Counter ( ) <NEWLINE> while tmp != 1 : <NEWLINE> <INDENT> cnt [ D [ tmp ] ] += 1 <NEWLINE> tmp //= D [ tmp ] <NEWLINE> <DEDENT> fact = set ( cnt . keys ( ) ) <NEWLINE> if pf & fact : <NEWLINE> <INDENT> is_pc = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pf |= fact <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> is_sc = False <NEWLINE> if not is_pc : <NEWLINE> <INDENT> gcd = A [ 0 ] <NEWLINE> for i in A [ 1 : ] : <NEWLINE> <INDENT> gcd = math . gcd ( i , gcd ) <NEWLINE> <DEDENT> if gcd == 1 : <NEWLINE> <INDENT> is_sc = True <NEWLINE> <NL> <DEDENT> <DEDENT> if is_pc : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif is_sc : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> out = 0 <NEWLINE> <NL> <COMMENT> <NL> out = out + ( 1 + k ) * k / 2 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( k ) : <NEWLINE> <INDENT> a = i + 1 <NEWLINE> b = i + 1 <NEWLINE> for j in range ( a - 1 ) : <NEWLINE> <INDENT> c = j + 1 <NEWLINE> out = out + gcd ( a , c ) * 6 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for m in range ( k ) : <NEWLINE> <INDENT> a = m + 1 <NEWLINE> for n in range ( a - 1 ) : <NEWLINE> <INDENT> b = n + 1 <NEWLINE> gcd2 = gcd ( a , b ) <NEWLINE> for o in range ( b - 1 ) : <NEWLINE> <INDENT> c = o + 1 <NEWLINE> out = out + gcd ( gcd2 , c ) * 6 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( out ) ) <NEWLINE>
c = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> a = int ( c [ 0 ] ) <NEWLINE> <NL> e = 100 * int ( c [ 1 ] [ 0 ] ) + 10 * int ( c [ 1 ] [ 2 ] ) + int ( c [ 1 ] [ 3 ] ) <NEWLINE> <NL> d = int ( a * e ) <NEWLINE> s = str ( d ) <NEWLINE> if ( len ( s ) < 3 ) : <NEWLINE> <INDENT> f = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = s [ : len ( s ) - 2 ] <NEWLINE> <NL> <DEDENT> print ( f ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> if D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> maze = [ [ ] for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> maze [ i ] = np . array ( list ( input ( ) ) ) == <STRING> <NEWLINE> <DEDENT> maze = np . array ( maze ) <NEWLINE> <NL> up = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> down = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> right = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> left = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> up [ i ] = ( up [ i - 1 ] + 1 ) * maze [ i ] <NEWLINE> down [ - ( i + 1 ) ] = ( down [ - i ] + 1 ) * maze [ - ( i + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> right [ : , i ] = ( right [ : , i - 1 ] + 1 ) * maze [ : , i ] <NEWLINE> left [ : , - ( i + 1 ) ] = ( left [ : , - i ] + 1 ) * maze [ : , - ( i + 1 ) ] <NEWLINE> <NL> <DEDENT> print ( np . max ( up + down + right + left ) - 3 ) <NEWLINE>
import numpy as np <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . cumsum ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = np . cumsum ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ i ] + B [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> i += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> c = Counter ( s ) <NEWLINE> total = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n and s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total - count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> num_sub = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> num_sub [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for num in num_sub : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // x <NEWLINE> answer += y * ( y + 1 ) * x / 2 <NEWLINE> <DEDENT> print ( int ( answer ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> ind = [ ] <NEWLINE> for i , char in enumerate ( s ) : <NEWLINE> <INDENT> if char == <STRING> : <NEWLINE> <INDENT> ind . append ( i ) <NEWLINE> <DEDENT> <DEDENT> lst = 0 <NEWLINE> <COMMENT> <NL> for i in ind : <NEWLINE> <INDENT> ans += ( i - lst ) <NEWLINE> lst += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> from bisect import bisect_left , bisect , insort_left , insort <NEWLINE> INF = 10000 <NEWLINE> def lcs ( s1 , s2 ) : <NEWLINE> <INDENT> c = defaultdict ( list ) <NEWLINE> for i , s in enumerate ( s1 ) : <NEWLINE> <INDENT> c [ s ] . append ( i ) <NEWLINE> <DEDENT> for s in set ( s2 ) : <NEWLINE> <INDENT> c [ s ] . append ( INF ) <NEWLINE> <DEDENT> def g ( li , a ) : <NEWLINE> <INDENT> for i in li : <NEWLINE> <INDENT> if i >= a : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> dp = [ ] <NEWLINE> for s2_k in s2 : <NEWLINE> <INDENT> bgn_idx = 0 <NEWLINE> for i , cur_idx in enumerate ( dp ) : <NEWLINE> <INDENT> chr_idx = c [ s2_k ] [ bisect_left ( c [ s2_k ] , bgn_idx ) ] <NEWLINE> if chr_idx == INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] = min ( cur_idx , chr_idx + 1 ) <NEWLINE> bgn_idx = cur_idx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> chr_idx = c [ s2_k ] [ bisect_left ( c [ s2_k ] , bgn_idx ) ] <NEWLINE> if chr_idx != INF : <NEWLINE> <INDENT> dp . append ( chr_idx + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return len ( dp ) <NEWLINE> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> print ( lcs ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT> solve ( ) <NEWLINE> <NL>
from heapq import heappop , heappush <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> num_stones = 0 <NEWLINE> row_stones = [ None ] * n <NEWLINE> edges = [ None ] * n <NEWLINE> visited = [ None ] * n <NEWLINE> for row in range ( n ) : <NEWLINE> <INDENT> ( num , * stones ) = map ( int , input ( ) . split ( ) ) <NEWLINE> row_stones [ row ] = list ( zip ( * [ iter ( stones ) ] * 2 ) ) <NEWLINE> edges [ row ] = [ None ] * num <NEWLINE> visited [ row ] = [ 1 ] * num <NEWLINE> <NL> <DEDENT> for row , stones in enumerate ( row_stones ) : <NEWLINE> <INDENT> next_stones = [ row_stones [ row + j ] if row + j < n else [ ] for j in ( 1 , 2 ) ] <NEWLINE> for i , ( column1 , slip1 ) in enumerate ( stones ) : <NEWLINE> <INDENT> edges [ row ] [ i ] = [ { ( abs ( column1 - column2 ) * ( slip1 + slip2 ) , j ) <NEWLINE> <INDENT> for j , ( column2 , slip2 ) in enumerate ( next_stones [ k ] ) } for k in ( 0 , 1 ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> queue = [ ( 0 , 0 , - m , i ) for i in range ( len ( row_stones [ 0 ] ) ) ] <NEWLINE> if m : <NEWLINE> <INDENT> queue . extend ( ( 0 , - 1 , - m + 1 , i ) for i in range ( len ( row_stones [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> while queue : <NEWLINE> <INDENT> total_risk , row , remains , i = heappop ( queue ) <NEWLINE> row = - row <NEWLINE> if row == n - 1 or ( remains and row == n - 2 ) : <NEWLINE> <INDENT> print ( total_risk ) <NEWLINE> break <NEWLINE> <DEDENT> if visited [ row ] [ i ] <= remains : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ row ] [ i ] = remains <NEWLINE> next_stones = edges [ row ] [ i ] <NEWLINE> for risk , j in next_stones [ 0 ] : <NEWLINE> <INDENT> heappush ( queue , ( total_risk + risk , - row - 1 , remains , j ) ) <NEWLINE> <DEDENT> if remains : <NEWLINE> <INDENT> for risk , j in next_stones [ 1 ] : <NEWLINE> <INDENT> heappush ( queue , ( total_risk + risk , - row - 2 , remains + 1 , j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> ls2 = sorted ( ls ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> ans += ls2 [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> not_good_set = set ( ) <NEWLINE> not_good_count = 0 <NEWLINE> AB_list = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> AB_list . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for t in AB_list : <NEWLINE> <INDENT> A = t [ 0 ] <NEWLINE> B = t [ 1 ] <NEWLINE> <NL> if ( A not in not_good_set ) : <NEWLINE> <INDENT> if ( H_list [ A - 1 ] <= H_list [ B - 1 ] ) : <NEWLINE> <INDENT> not_good_set . add ( A ) <NEWLINE> not_good_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( B not in not_good_set ) : <NEWLINE> <INDENT> if ( H_list [ B - 1 ] <= H_list [ A - 1 ] ) : <NEWLINE> <INDENT> not_good_set . add ( B ) <NEWLINE> not_good_count += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( N - not_good_count ) <NEWLINE>
<COMMENT> <NL> <NL> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> set , mod = divmod ( N , ( A + B ) ) <NEWLINE> ans = set * A <NEWLINE> <NL> if mod < A : <NEWLINE> <INDENT> ans += mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H . reverse ( ) <NEWLINE> <NL> check = True <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if H [ i + 1 ] - H [ i ] > 1 : <NEWLINE> <INDENT> check = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H [ i + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ak = 0 <NEWLINE> ak_2 = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ak += A [ i ] <NEWLINE> ak_2 += A [ i ] ** 2 <NEWLINE> <DEDENT> s = int ( ( ( ak ** 2 ) - ak_2 ) // 2 ) <NEWLINE> print ( s % mod ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> result = N <NEWLINE> for i in range ( 1 , int ( math . sqrt ( N ) ) + 2 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> result = min ( result , i - 1 + N // i - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
INF = 1000000000 + 7 <NEWLINE> <NL> s = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( 2000 + 1 ) ; <NEWLINE> <NL> dp [ 0 ] = dp [ 1 ] = dp [ 2 ] = 0 <NEWLINE> dp [ 3 ] = 1 <NEWLINE> <NL> <NL> for i in range ( 4 , s + 1 ) : <NEWLINE> <INDENT> temp = 1 <NEWLINE> for j in range ( 3 , i - 2 ) : <NEWLINE> <INDENT> temp += dp [ j ] % INF ; <NEWLINE> <DEDENT> temp %= INF ; <NEWLINE> dp [ i ] = temp <NEWLINE> <DEDENT> print ( dp [ s ] ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> ki = 0 <NEWLINE> for i in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> ki = ( ki * 10 + 7 ) % k <NEWLINE> if ki == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = Counter ( list ( i + 1 + A [ i ] for i in range ( N ) ) ) <NEWLINE> <COMMENT> <NL> C = Counter ( ( i + 1 - A [ i ] for i in range ( N ) ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for j in range ( N ) : <NEWLINE> <INDENT> ans += B [ j ] * C [ j ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> A_max = max ( A ) <NEWLINE> dp = [ True ] * ( A_max + 1 ) <NEWLINE> count = 0 <NEWLINE> A_f = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> A_f [ a ] += 1 <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> if dp [ a ] : <NEWLINE> <INDENT> for i in range ( 1 , A_max + 1 ) : <NEWLINE> <INDENT> if a * i > A_max : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ a * i ] = False <NEWLINE> <DEDENT> if A_f [ a ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> from itertools import product <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> maze = [ input ( ) for _ in range ( H ) ] <NEWLINE> <NL> points = [ ( y , x ) for y , x in product ( range ( H ) , range ( W ) ) if maze [ y ] [ x ] == <STRING> ] <NEWLINE> <NL> ans = 0 <NEWLINE> for sy , sx in points : <NEWLINE> <INDENT> costs = { } <NEWLINE> queue = deque ( ) <NEWLINE> queue . append ( ( sy , sx , 0 ) ) <NEWLINE> while queue : <NEWLINE> <INDENT> y , x , cost = queue . popleft ( ) <NEWLINE> if ( y , x ) in costs : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> costs [ ( y , x ) ] = cost <NEWLINE> <NL> <DEDENT> for ny , nx in ( ( y + 1 , x ) , ( y - 1 , x ) , ( y , x + 1 ) , ( y , x - 1 ) ) : <NEWLINE> <INDENT> if not 0 <= ny < H : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not 0 <= nx < W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( ny , nx ) in costs : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if maze [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> queue . append ( ( ny , nx , cost + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , max ( costs . values ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> cuts = X // D <NEWLINE> <NL> if cuts >= K : <NEWLINE> <INDENT> print ( X - ( K * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> remainingcuts = K - cuts <NEWLINE> r = X - cuts * D <NEWLINE> <NL> if remainingcuts % 2 == 1 : <NEWLINE> <INDENT> print ( abs ( r - D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mycounter = Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( mycounter [ i ] ) <NEWLINE> <DEDENT>
S = list ( str ( input ( ) ) ) <NEWLINE> <NL> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if i == 0 and S [ 0 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> S [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if S [ len ( S ) - 1 ] == <STRING> : <NEWLINE> <INDENT> S [ len ( S ) - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> strS = <STRING> . join ( S ) <NEWLINE> <NL> print ( strS ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> result = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> right = sum ( num_list ) <NEWLINE> for number in num_list : <NEWLINE> <COMMENT> <NL> <INDENT> right -= number <NEWLINE> result += ( number * right ) % mod <NEWLINE> <DEDENT> print ( result % mod ) <NEWLINE>
S = input ( ) <NEWLINE> li = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> li_len = [ 5 , 7 , 5 , 6 ] <NEWLINE> <NL> while S : <NEWLINE> <INDENT> for i , moji in enumerate ( li ) : <NEWLINE> <INDENT> if S [ - li_len [ i ] : ] == moji : <NEWLINE> <INDENT> S = S [ : - li_len [ i ] ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not S : print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> if n == k : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> res = ( res * a ) % mod <NEWLINE> <DEDENT> print ( res ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P , M = [ ] , [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> P . append ( a ) if a >= 0 else M . append ( a ) <NEWLINE> <NL> <DEDENT> if len ( P ) == n : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> res = ( res * A [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> elif len ( M ) == n : <NEWLINE> <INDENT> A . sort ( reverse = True ) if k % 2 else A . sort ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> res = ( res * A [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> P . sort ( reverse = True ) <NEWLINE> M . sort ( ) <NEWLINE> B = [ ] <NEWLINE> if k % 2 : <NEWLINE> <INDENT> k -= 1 <NEWLINE> b = P . pop ( 0 ) <NEWLINE> B . append ( b ) <NEWLINE> res = ( res * b ) % mod <NEWLINE> <DEDENT> for i in range ( 0 , len ( P ) , 2 ) : <NEWLINE> <INDENT> if i + 1 < len ( P ) : <NEWLINE> <INDENT> B . append ( P [ i ] * P [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 0 , len ( M ) , 2 ) : <NEWLINE> <INDENT> if j + 1 < len ( M ) : <NEWLINE> <INDENT> B . append ( M [ j ] * M [ j + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> B . sort ( reverse = True ) <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> res = ( res * B [ i ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for i in range ( N ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x - 1 ] . append ( y - 1 ) <NEWLINE> G [ y - 1 ] . append ( x - 1 ) <NEWLINE> <NL> <DEDENT> dp_black = [ - 1 ] * N <NEWLINE> dp_white = [ - 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> def search ( v , parent ) : <NEWLINE> <INDENT> if dp_black [ v ] != - 1 : <NEWLINE> <INDENT> return ( dp_black [ v ] , dp_white [ v ] ) <NEWLINE> <DEDENT> black = 1 <NEWLINE> white = 1 <NEWLINE> for child in G [ v ] : <NEWLINE> <INDENT> if child == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b , w = search ( child , v ) <NEWLINE> black *= w <NEWLINE> black %= MOD <NEWLINE> white *= ( b + w ) <NEWLINE> white %= MOD <NEWLINE> <DEDENT> dp_black [ v ] = black <NEWLINE> dp_white [ v ] = white <NEWLINE> return ( black , white ) <NEWLINE> <NL> <DEDENT> print ( sum ( search ( 0 , - 1 ) ) % MOD ) <NEWLINE>
from sys import stdin <NEWLINE> from operator import attrgetter <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> def norm ( a ) : <NEWLINE> <INDENT> return a . real * a . real + a . imag * a . imag <NEWLINE> <NL> <NL> <DEDENT> def closest_pair ( p ) : <NEWLINE> <INDENT> if len ( p ) <= 1 : <NEWLINE> <INDENT> return float ( <STRING> ) <NEWLINE> <DEDENT> m = len ( p ) // 2 <NEWLINE> d = min ( closest_pair ( p [ : m ] ) , closest_pair ( p [ m : ] ) ) <NEWLINE> p = [ pi for pi in p if p [ m ] . imag - d < pi . imag < p [ m ] . imag + d ] <NEWLINE> return brute_force ( p , d ) <NEWLINE> <NL> <DEDENT> def brute_force ( p , d = float ( <STRING> ) ) : <NEWLINE> <INDENT> p . sort ( key = attrgetter ( <STRING> ) ) <NEWLINE> for i in range ( 1 , len ( p ) ) : <NEWLINE> <INDENT> for j in reversed ( range ( i ) ) : <NEWLINE> <INDENT> tmp = p [ i ] - p [ j ] <NEWLINE> if d < tmp . real : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = abs ( tmp ) <NEWLINE> if d > tmp : <NEWLINE> <INDENT> d = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) ) <NEWLINE> p = [ map ( float , readline ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> p = [ x + y * 1j for x , y in p ] <NEWLINE> <NL> p . sort ( key = attrgetter ( <STRING> ) ) <NEWLINE> print ( <STRING> . format ( closest_pair ( p ) ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> t = x - i <NEWLINE> s = x + i <NEWLINE> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> if t not in p : <NEWLINE> <INDENT> print ( t ) <NEWLINE> break <NEWLINE> <DEDENT> if s not in p : <NEWLINE> <INDENT> print ( s ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> abc = math . gcd ( ab , c ) <NEWLINE> ans += abc <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> result = result * a <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = k <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> p *= k - 1 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ 0 ] * ( n ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s [ a [ i ] - 1 ] = s [ a [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( s [ j ] ) <NEWLINE> <DEDENT>
l = input ( ) . split ( ) <NEWLINE> l = list ( map ( int , l ) ) <NEWLINE> <NL> if l [ 2 ] - l [ 4 ] >= 0 and l [ 3 ] - l [ 4 ] >= 0 and l [ 2 ] + l [ 4 ] <= l [ 0 ] and l [ 3 ] + l [ 4 ] <= l [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> ans = [ ] <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= h [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == n - 2 : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for item in List : <NEWLINE> <INDENT> ans *= item <NEWLINE> if ans > 10 ** 18 or ans <= - 1 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N < 10 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = N - int ( ( len ( str ( N ) ) - 1 ) * <STRING> ) <NEWLINE> tmp = ( len ( str ( N ) ) - 1 ) * <STRING> <NEWLINE> if len ( str ( n ) ) > ( len ( str ( N ) ) - 1 ) : <NEWLINE> <INDENT> tmp = str ( n ) [ 0 ] + tmp <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for t in tmp : <NEWLINE> <INDENT> res += int ( t ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> left = 0 <NEWLINE> right = S [ 1 : N ] . count ( <STRING> ) <NEWLINE> ans = left + right <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> ans = min ( ans , left + right ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
class Node ( object ) : <NEWLINE> <INDENT> root = None <NEWLINE> <NL> <STRING> <NEWLINE> def __init__ ( self , key , parent = None , left = None , right = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> self . height = None <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def insert ( cls , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = cls . root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y == None : <NEWLINE> <INDENT> cls . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return z <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def walk_preorder ( cls , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> if node . left != None : <NEWLINE> <COMMENT> <NL> <INDENT> cls . walk_preorder ( node . left ) <NEWLINE> <DEDENT> if node . right != None : <NEWLINE> <COMMENT> <NL> <INDENT> cls . walk_preorder ( node . right ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def walk_inorder ( cls , node ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> if node . left != None : <NEWLINE> <COMMENT> <NL> <INDENT> cls . walk_inorder ( node . left ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( <STRING> . format ( node . key ) , end = <STRING> ) <NEWLINE> if node . right != None : <NEWLINE> <COMMENT> <NL> <INDENT> cls . walk_inorder ( node . right ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def get_type ( self ) : <NEWLINE> <INDENT> if self . parent : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif self . left == None and self . right == None : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def get_depth ( self ) : <NEWLINE> <INDENT> if self . parent == None : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> depth = 1 <NEWLINE> t = self . parent <NEWLINE> while t . parent != None : <NEWLINE> <INDENT> t = t . parent <NEWLINE> depth += 1 <NEWLINE> <DEDENT> return depth <NEWLINE> <NL> <DEDENT> <DEDENT> def get_height ( self ) : <NEWLINE> <INDENT> if self . height : <NEWLINE> <INDENT> return self . height <NEWLINE> <DEDENT> h_left = 0 <NEWLINE> h_right = 0 <NEWLINE> if self . left != None : <NEWLINE> <INDENT> h_left = self . left . get_height ( ) + 1 <NEWLINE> <DEDENT> if self . right != None : <NEWLINE> <INDENT> h_right = self . right . get_height ( ) + 1 <NEWLINE> <DEDENT> self . height = max ( h_left , h_right ) <NEWLINE> return self . height <NEWLINE> <NL> <DEDENT> def get_degree ( self ) : <NEWLINE> <INDENT> degree = 0 <NEWLINE> if self . left != None : <NEWLINE> <INDENT> degree += 1 <NEWLINE> <DEDENT> if self . right != None : <NEWLINE> <INDENT> degree += 1 <NEWLINE> <DEDENT> return degree <NEWLINE> <NL> <DEDENT> def get_sibling ( self ) : <NEWLINE> <INDENT> if self . parent == None : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> p = self . parent <NEWLINE> if p . left != self and p . left != None : <NEWLINE> <INDENT> return p . left <NEWLINE> <DEDENT> if p . right != self and p . right != None : <NEWLINE> <INDENT> return p . right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def process_node_data ( node_data ) : <NEWLINE> <INDENT> last = None <NEWLINE> for inst in node_data : <NEWLINE> <INDENT> if inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> result = Node . walk_inorder ( last . root ) <NEWLINE> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> result = Node . walk_preorder ( last . root ) <NEWLINE> <COMMENT> <NL> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node_key = int ( inst [ 1 ] ) <NEWLINE> new_node = Node ( node_key ) <NEWLINE> last = Node . insert ( new_node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def flatten ( l ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import collections <NEWLINE> for el in l : <NEWLINE> <INDENT> if isinstance ( el , collections . Iterable ) and not isinstance ( el , ( str , bytes ) ) : <NEWLINE> <INDENT> yield from flatten ( el ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield el <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> num_of_nodes = int ( input ( ) ) <NEWLINE> node_data = [ input ( ) . split ( <STRING> ) for _ in range ( num_of_nodes ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> process_node_data ( node_data ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if k < a : <NEWLINE> <INDENT> print ( k * 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a * 1 <NEWLINE> k -= a <NEWLINE> if k > 0 : <NEWLINE> <INDENT> k -= b * 1 <NEWLINE> if k > 0 : <NEWLINE> <INDENT> ans += k * - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + a_ [ i ] ) <NEWLINE> <NL> <DEDENT> b = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + b_ [ i ] ) <NEWLINE> <NL> <DEDENT> j = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while 1 : <COMMENT> <NEWLINE> <INDENT> if b [ j ] <= k - a [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if W >= V : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( ( A - B ) / ( W - V ) ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
cards = list ( ) <NEWLINE> mark = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in ( mark ) : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> cards . append ( i + <STRING> + str ( j ) ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> cards . remove ( a ) <NEWLINE> <DEDENT> if len ( cards ) > 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( cards ) ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ [ ] for _ in range ( n ) ] <NEWLINE> city = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> city . append ( [ p , y ] ) <NEWLINE> l [ p - 1 ] . append ( y ) <NEWLINE> <NL> <DEDENT> for i in l : i . sort ( ) <NEWLINE> for i in city : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> ans += <STRING> * ( 6 - len ( str ( i [ 0 ] ) ) ) + str ( i [ 0 ] ) <NEWLINE> t = str ( bisect_left ( l [ i [ 0 ] - 1 ] , i [ 1 ] ) + 1 ) <NEWLINE> ans += <STRING> * ( 6 - len ( t ) ) + t <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> from math import gcd , pi , sqrt <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> import itertools <NEWLINE> from collections import Counter , deque <NEWLINE> def i_input ( ) : return int ( input ( ) ) <NEWLINE> def i_map ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def i_list ( ) : return list ( i_map ( ) ) <NEWLINE> def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] <NEWLINE> def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] <NEWLINE> def s_input ( ) : return input ( ) <NEWLINE> def s_map ( ) : return input ( ) . split ( ) <NEWLINE> def s_list ( ) : return list ( s_map ( ) ) <NEWLINE> def s_row ( N ) : return [ s_input for _ in range ( N ) ] <NEWLINE> def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] <NEWLINE> def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = i_input ( ) <NEWLINE> t = i_input ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> k = i_input ( ) <NEWLINE> t = t * k // gcd ( t , k ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mul = 1 <NEWLINE> if 0 in set ( a ) : mul = 0 <NEWLINE> else : <NEWLINE> <INDENT> iter = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mul *= a [ i ] <NEWLINE> if mul > 1e18 : <NEWLINE> <INDENT> mul = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = len ( R ) * len ( G ) * len ( B ) <NEWLINE> for i in R : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 and S [ ( i + j ) // 2 ] == <STRING> : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in R : <NEWLINE> <INDENT> for j in B : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 and S [ ( i + j ) // 2 ] == <STRING> : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in B : <NEWLINE> <INDENT> for j in G : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 and S [ ( i + j ) // 2 ] == <STRING> : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> li [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * li , sep = <STRING> ) <NEWLINE>
a = [ int ( <STRING> ) for i in range ( 10 ) ] <NEWLINE> w = [ <STRING> for i in range ( 20 ) ] <NEWLINE> z = [ ] <NEWLINE> for i in range ( 15 ) : <NEWLINE> <INDENT> z += [ a ] <NEWLINE> if i == 3 or i == 7 or i == 11 : <NEWLINE> <INDENT> z += [ w ] <NEWLINE> <DEDENT> <DEDENT> x = [ [ [ 0 for i in range ( 10 ) ] for k in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> x [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( str ( x [ i ] [ k ] [ o ] ) for o in range ( 10 ) ) ) <NEWLINE> <DEDENT> if i == 0 or i == 1 or i == 2 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
def calc ( x , y ) : <NEWLINE> <INDENT> n = len ( x ) <NEWLINE> m = len ( y ) <NEWLINE> dp1 = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = x [ i ] <NEWLINE> dp2 = dp1 [ : ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if s == y [ j ] : <NEWLINE> <INDENT> dp1 [ j + 1 ] = dp2 [ j ] + 1 <NEWLINE> <DEDENT> elif dp1 [ j + 1 ] < dp1 [ j ] : <NEWLINE> <INDENT> dp1 [ j + 1 ] = dp1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp1 [ - 1 ] <NEWLINE> <NL> <DEDENT> q = int ( input ( ) . rstrip ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> ans . append ( calc ( x , y ) ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n , k , q = map ( int , input ( ) . split ( ) ) ; a = [ k - q for i in range ( n ) ] <NEWLINE> for _ in range ( q ) : a [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> print ( * [ <STRING> if i > 0 else <STRING> for i in a ] , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> x = a [ 0 ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if x < a [ i ] : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> <DEDENT> res += x - a [ i ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> mx = max ( a ) <NEWLINE> <NL> mark = [ 0 for _ in range ( mx + 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for x in range ( a [ i ] , mx + 1 , a [ i ] ) : <NEWLINE> <INDENT> mark [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if mark [ a [ i ] ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * N <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> parent = [ - 1 ] * N <NEWLINE> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> d = dist [ v ] <NEWLINE> for w in G [ v ] : <NEWLINE> <INDENT> if dist [ w ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w ] = d + 1 <NEWLINE> parent [ w ] = v <NEWLINE> que . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ x + 1 for x in parent [ 1 : ] ] <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> s = 7 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> m = s % k <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> s = m * 10 + 7 <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def mapline ( t = int ) : <NEWLINE> <INDENT> return map ( t , sysread ( ) . split ( ) ) <NEWLINE> <DEDENT> def mapread ( t = int ) : <NEWLINE> <INDENT> return map ( t , read ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N , * A = mapread ( ) <NEWLINE> ans = 1 <NEWLINE> current = [ 0 , 0 , 0 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> transition = 0 <NEWLINE> cache = 0 <NEWLINE> for i , c in enumerate ( current ) : <NEWLINE> <INDENT> if c == a : <NEWLINE> <INDENT> transition += 1 <NEWLINE> cache = i <NEWLINE> <DEDENT> <DEDENT> ans *= transition <NEWLINE> ans %= mod <NEWLINE> current [ cache ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> range ( 1 , k + 1 ) <NEWLINE> <NL> l1 = range ( 1 , k + 1 ) <NEWLINE> def loop ( s ) : <NEWLINE> <INDENT> for a in l1 : <NEWLINE> <INDENT> for b in l1 : <NEWLINE> <INDENT> for c in l1 : <NEWLINE> <INDENT> l2 = ( a , b , c ) <NEWLINE> g1 = gcd ( a , b ) <NEWLINE> g2 = gcd ( g1 , c ) <NEWLINE> s += g2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <DEDENT> print ( loop ( 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( R ) * len ( G ) * len ( B ) <NEWLINE> <NL> <NL> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ k ] != s [ j ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> うんち = 0 <NEWLINE> for デビ in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for デビデ in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for ビル in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> うんち += gcd ( デビ , gcd ( デビデ , ビル ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( うんち ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ABCD = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> R = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> <COMMENT> <NL> <NL> for comb in itertools . combinations_with_replacement ( R , N ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for abcd in ABCD : <NEWLINE> <INDENT> a , b , c , d = abcd <NEWLINE> if comb [ b - 1 ] - comb [ a - 1 ] == c : <NEWLINE> <INDENT> temp += d <NEWLINE> <DEDENT> <DEDENT> if temp >= ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( arr [ n - i - 1 ] ) ) <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> while que : <NEWLINE> <INDENT> nn = que . popleft ( ) <NEWLINE> for n in edges [ nn - 1 ] : <NEWLINE> <INDENT> if D [ n - 1 ] == INF or D [ n - 1 ] > D [ nn - 1 ] + 1 : <NEWLINE> <INDENT> D [ n - 1 ] = D [ nn - 1 ] + 1 <NEWLINE> que . append ( n ) <NEWLINE> if n > 1 : <NEWLINE> <INDENT> B [ n - 2 ] = nn <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for b in B : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b ) <NEWLINE> edges [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> B = [ 0 ] * ( N - 1 ) <NEWLINE> que = deque ( [ 1 ] ) <NEWLINE> INF = 10 ** 10 <NEWLINE> D = [ INF ] * N <NEWLINE> D [ 0 ] = 0 <NEWLINE> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> v = <STRING> <NEWLINE> <NL> w = [ ] <NEWLINE> def dfs ( s , t ) : <NEWLINE> <INDENT> if len ( s ) == n : <NEWLINE> <INDENT> w . append ( s ) <NEWLINE> return <NEWLINE> <DEDENT> u = len ( set ( s ) ) <NEWLINE> for i in range ( u + 1 ) : <NEWLINE> <INDENT> dfs ( s + v [ i ] , u + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( <STRING> , 1 ) <NEWLINE> <NL> for i in w : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MAP1 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> def LIST1 ( ) : return list ( MAP1 ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = INT ( ) <NEWLINE> xbin = input ( ) <NEWLINE> xdec = int ( xbin , 2 ) <NEWLINE> m = xbin . count ( <STRING> ) <NEWLINE> <NL> a = xdec % ( m + 1 ) <NEWLINE> b = xdec % ( m - 1 ) if m > 1 else 0 <NEWLINE> <NL> num = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> num [ i ] = num [ i % bin ( i ) . count ( <STRING> ) ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if xbin [ i ] == <STRING> : <NEWLINE> <INDENT> y = ( a + pow ( 2 , N - i - 1 , m + 1 ) ) % ( m + 1 ) <NEWLINE> print ( num [ y ] + 1 ) <NEWLINE> <DEDENT> elif m <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = ( b - pow ( 2 , N - i - 1 , m - 1 ) ) % ( m - 1 ) <NEWLINE> print ( num [ y ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n , T = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ 0 ] * n <NEWLINE> t = [ 0 ] * n <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c [ i ] , t [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if t [ i ] <= T : <NEWLINE> <INDENT> ans . append ( c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse import lil_matrix , csr_matrix <NEWLINE> from scipy . sparse . csgraph import shortest_path <NEWLINE> M = 49 * 50 + 1 <NEWLINE> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> s = min ( s , M - 1 ) <NEWLINE> G = lil_matrix ( ( n * M , n * M ) ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b , silver , time = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> for i in range ( silver , M ) : <NEWLINE> <INDENT> G [ a * M + i , b * M + i - silver ] = time <NEWLINE> G [ b * M + i , a * M + i - silver ] = time <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> silver , time = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( M - 1 ) : <NEWLINE> <INDENT> G [ i * M + j , i * M + min ( j + silver , M - 1 ) ] = time <NEWLINE> <DEDENT> <DEDENT> G = G . tocsr ( ) <NEWLINE> G = shortest_path ( G , method = <STRING> , indices = s ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = np . min ( G [ i * M : i * M + M ] ) <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> t = int ( args [ 0 ] ) <NEWLINE> ret = [ ] <NEWLINE> for i in range ( 1 , 3 * t + 1 , 3 ) : <NEWLINE> <INDENT> n = int ( args [ i ] ) <NEWLINE> A = tuple ( map ( int , args [ i + 1 ] . split ( ) ) ) <NEWLINE> S = tuple ( map ( int , tuple ( args [ i + 2 ] ) ) ) <NEWLINE> <NL> ans = False <NEWLINE> dp = [ 0 ] * ( max ( A ) . bit_length ( ) + 1 ) <NEWLINE> for a , s in reversed ( tuple ( zip ( A , S ) ) ) : <NEWLINE> <INDENT> m = a . bit_length ( ) <NEWLINE> if s == 0 : <NEWLINE> <INDENT> while 0 < a and 0 < dp [ m ] : <NEWLINE> <INDENT> a ^= dp [ m ] <NEWLINE> m = a . bit_length ( ) <NEWLINE> <DEDENT> if 0 < a : <NEWLINE> <INDENT> dp [ m ] = a <NEWLINE> <DEDENT> <DEDENT> elif s == 1 : <NEWLINE> <INDENT> while 0 < a : <NEWLINE> <INDENT> if 0 < dp [ m ] : <NEWLINE> <INDENT> a ^= dp [ m ] <NEWLINE> m = a . bit_length ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ret . append ( 1 * ans ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , ret ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from numpy import * <NEWLINE> def main ( n , k , p , c ) : <NEWLINE> <INDENT> m = - 10 ** 12 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = i <NEWLINE> t = 1 <NEWLINE> x = c [ s ] <NEWLINE> while p [ s ] - 1 != i : <NEWLINE> <INDENT> s = p [ s ] - 1 <NEWLINE> t += 1 <NEWLINE> x += c [ s ] <NEWLINE> <DEDENT> if x > 0 : <NEWLINE> <INDENT> a = ( k // t - 1 ) * x <NEWLINE> if a > m : m = a <NEWLINE> s = i <NEWLINE> for _ in range ( k % t + t ) : <NEWLINE> <INDENT> s = p [ s ] - 1 <NEWLINE> a += c [ s ] <NEWLINE> if a > m : m = a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> s = i <NEWLINE> for _ in range ( min ( k , t ) ) : <NEWLINE> <INDENT> s = p [ s ] - 1 <NEWLINE> a += c [ s ] <NEWLINE> if a > m : m = a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return m <NEWLINE> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> ( n , k ) , p , c = [ int_ ( t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> print ( main ( n , k , p , c ) ) <NEWLINE>
<COMMENT> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nxt = 1 <NEWLINE> loop = [ ] <NEWLINE> tset = set ( ) <NEWLINE> final = - 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> loop . append ( nxt ) <NEWLINE> tset . add ( nxt ) <NEWLINE> nxt = a [ nxt - 1 ] <NEWLINE> if nxt in tset : <NEWLINE> <INDENT> final = nxt <COMMENT> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> m = - 1 <NEWLINE> for i in range ( len ( loop ) ) : <NEWLINE> <INDENT> if loop [ i ] == final : <NEWLINE> <INDENT> m = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> l = len ( loop ) <NEWLINE> if k < m : <NEWLINE> <INDENT> print ( loop [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( k - m ) % ( l - m ) + m ] ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( max ( x ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> n = 0 <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> count = - 1 <NEWLINE> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = ( n * 10 + 7 ) % K <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> num = len ( s ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> a = 122 - ord ( s [ i ] ) + 1 <NEWLINE> if a <= k and s [ i ] != <STRING> : <NEWLINE> <INDENT> k -= a <NEWLINE> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if k > 0 : <NEWLINE> <INDENT> s [ - 1 ] = chr ( ord ( s [ - 1 ] ) + k % 26 ) <NEWLINE> <DEDENT> print ( * s , sep = <STRING> ) <NEWLINE> <NL>
import numpy as np <NEWLINE> <NL> input_str = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> <NL> <NL> if len ( input_str ) == 1 : <NEWLINE> <INDENT> input_str [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if input_str [ 0 ] == <STRING> : <NEWLINE> <INDENT> if input_str [ 1 ] == <STRING> : <NEWLINE> <INDENT> input_str [ 0 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input_str [ 0 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if input_str [ - 1 ] == <STRING> : <NEWLINE> <INDENT> input_str [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( input_str ) - 1 ) : <NEWLINE> <INDENT> if input_str [ i ] == <STRING> : <NEWLINE> <INDENT> if input_str [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> input_str [ i ] = <STRING> <NEWLINE> <DEDENT> elif input_str [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> input_str [ i ] = <STRING> <NEWLINE> <DEDENT> elif input_str [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if input_str [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> input_str [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input_str [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> input_str [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> . join ( input_str ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ran = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ran . sort ( reverse = True ) <NEWLINE> <NL> gen = len ( ran ) - 2 <NEWLINE> goukei = ran [ 0 ] <NEWLINE> if gen % 2 == 0 : <NEWLINE> <INDENT> for i in range ( int ( gen / 2 ) ) : <NEWLINE> <INDENT> goukei += 2 * ran [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( int ( ( gen - 1 ) / 2 ) ) : <NEWLINE> <INDENT> goukei += 2 * ran [ i + 1 ] <NEWLINE> <DEDENT> goukei += ran [ i + 2 ] <NEWLINE> <NL> <DEDENT> print ( goukei ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> s1 = 0 <NEWLINE> s2 = 0 <NEWLINE> <NL> at = - 1 <NEWLINE> atc = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if at == a : <NEWLINE> <INDENT> atc += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if atc >= 4 : <NEWLINE> <INDENT> s1 = at <NEWLINE> s2 = at <NEWLINE> <DEDENT> elif atc >= 2 : <NEWLINE> <INDENT> s2 = s1 <NEWLINE> s1 = at <NEWLINE> <NL> <DEDENT> at = a <NEWLINE> atc = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if atc >= 4 : <NEWLINE> <INDENT> s1 = at <NEWLINE> s2 = at <NEWLINE> <DEDENT> elif atc >= 2 : <NEWLINE> <INDENT> s2 = s1 <NEWLINE> s1 = at <NEWLINE> <NL> <DEDENT> print ( s1 * s2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> A = [ ( i + 1 , a ) for i , a in enumerate ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> A = sorted ( A , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> dp = [ [ - INF ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> for s in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for l in range ( s + 1 ) : <NEWLINE> <INDENT> r = s - l <NEWLINE> dp [ l ] [ r ] = max ( dp [ l - 1 ] [ r ] + A [ s - 1 ] [ 1 ] * abs ( A [ s - 1 ] [ 0 ] - l ) , dp [ l ] [ r - 1 ] + A [ s - 1 ] [ 1 ] * abs ( N - r + 1 - A [ s - 1 ] [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for m in range ( N ) : <NEWLINE> <INDENT> if ( dp [ m ] [ N - m ] > ans ) : <NEWLINE> <INDENT> ans = dp [ m ] [ N - m ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<NL> def f ( a , b , x ) : <NEWLINE> <INDENT> return int ( a * x / b ) - a * int ( x / b ) <NEWLINE> <NL> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> print ( f ( a , b , n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( a , b , b - 1 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> % ( s , l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = h * w <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> a [ w * i + j ] = t [ j ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def dist ( i , j ) : <NEWLINE> <INDENT> dh = abs ( i // w - j // w ) <NEWLINE> dw = abs ( i % w - j % w ) <NEWLINE> return dh + dw <NEWLINE> <NL> <DEDENT> idx_list = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> idx_list [ a [ i ] ] = i <NEWLINE> <NL> <DEDENT> dist_list = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i < d : <NEWLINE> <INDENT> dist_list [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dist_list [ i ] = dist_list [ i - d ] + dist ( idx_list [ i - d ] , idx_list [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 ; r -= 1 <NEWLINE> print ( dist_list [ r ] - dist_list [ l ] ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> K = list ( sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) ) <NEWLINE> <NL> max1 = K [ 0 ] <NEWLINE> max2 = K [ 1 ] <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max3 = K [ 2 ] <NEWLINE> count = max1 + max2 <NEWLINE> cands = deque ( [ max2 , max3 , max3 ] ) <NEWLINE> for k in K [ 3 : ] : <NEWLINE> <INDENT> cand = cands . popleft ( ) <NEWLINE> count += cand <NEWLINE> cands . append ( k ) <NEWLINE> cands . append ( k ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sorted ( a ) [ 0 ] == 0 : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 1 <NEWLINE> <DEDENT> if sum == 1 : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> sum *= i <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bombs = { } <NEWLINE> rows = [ ] <NEWLINE> cols = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> rows . append ( [ i , 0 ] ) <NEWLINE> <DEDENT> for i in range ( W ) : <NEWLINE> <INDENT> cols . append ( [ i , 0 ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> y , x = map ( lambda x : x - 1 , map ( int , input ( ) . split ( ) ) ) <NEWLINE> bombs [ ( y , x ) ] = True <NEWLINE> rows [ y ] [ 1 ] += 1 <NEWLINE> cols [ x ] [ 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> rows = sorted ( rows , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> cols = sorted ( cols , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> answer = 0 <NEWLINE> for row in rows : <NEWLINE> <INDENT> a = cols [ 0 ] [ 1 ] + row [ 1 ] - ( 1 if ( row [ 0 ] , cols [ 0 ] [ 0 ] ) in bombs else 0 ) <NEWLINE> if a > answer : <NEWLINE> <INDENT> answer = a <NEWLINE> <DEDENT> <DEDENT> for col in cols : <NEWLINE> <INDENT> a = rows [ 0 ] [ 1 ] + col [ 1 ] - ( 1 if ( rows [ 0 ] [ 0 ] , col [ 0 ] ) in bombs else 0 ) <NEWLINE> if a > answer : <NEWLINE> <INDENT> answer = a <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import math <NEWLINE> <NL> w = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> m = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> w += math . gcd ( m , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( w ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans_box = dict ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = sorted ( map ( str , input ( ) ) ) <NEWLINE> if <STRING> . join ( s ) in ans_box . keys ( ) : <NEWLINE> <INDENT> ans_box [ <STRING> . join ( s ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_box [ <STRING> . join ( s ) ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for key , value in ans_box . items ( ) : <NEWLINE> <INDENT> if value == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += value * ( value - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answers = [ ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> answers . append ( a [ i - k ] < a [ i ] ) <NEWLINE> <DEDENT> for ans in answers : <NEWLINE> <INDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( [ int ( t ) for t in input ( ) . split ( ) ] ) <NEWLINE> c = Counter ( a ) <NEWLINE> checker = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> times = [ False ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> for a_i in a : <NEWLINE> <INDENT> checker [ a_i ] = True <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if times [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not checker [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if checker [ i ] and c [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> times [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import numba <NEWLINE> import math <NEWLINE> <NL> @ numba . njit <NEWLINE> def main ( N , K , steps ) : <NEWLINE> <NL> <INDENT> dpt = [ 10 ** 9 ] * ( N ) <NEWLINE> dpt [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i + j > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ij = i + j <NEWLINE> x = dpt [ i ] + abs ( steps [ i ] - steps [ ij ] ) <NEWLINE> if x < dpt [ ij ] : <NEWLINE> <INDENT> dpt [ ij ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dpt [ N - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> steps = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int32 ) <NEWLINE> main ( N , K , steps ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> Num , Count = zip ( * sorted ( collections . Counter ( int ( T ) for T in input ( ) . split ( ) ) . most_common ( ) ) ) <NEWLINE> DisN = ( ( min ( Num ) - 1 ) , ) + Num + ( ( max ( Num ) + 1 ) , ) <NEWLINE> DisC = ( 0 , ) + Count + ( 0 , ) <NEWLINE> MAX = 0 <NEWLINE> for T in range ( 1 , len ( Num ) + 1 ) : <NEWLINE> <INDENT> Dis = DisC [ T ] <NEWLINE> if DisN [ T - 1 ] == DisN [ T ] - 1 : <NEWLINE> <INDENT> Dis += DisC [ T - 1 ] <NEWLINE> <DEDENT> if DisN [ T + 1 ] == DisN [ T ] + 1 : <NEWLINE> <INDENT> Dis += DisC [ T + 1 ] <NEWLINE> <DEDENT> if MAX < Dis : <NEWLINE> <INDENT> MAX = Dis <NEWLINE> <DEDENT> <DEDENT> print ( MAX ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for j in range ( int ( X ** 0.5 ) + 2 , 0 , - 1 ) : <NEWLINE> <INDENT> if X % j == 0 : <NEWLINE> <INDENT> for a in range ( 2 * ( 10 ** 4 ) ) : <NEWLINE> <INDENT> b = a - j <NEWLINE> S = j * ( a ** 4 + b ** 4 + ( a ** 3 ) * b + ( a ** 2 ) * ( b ** 2 ) + a * ( b ** 3 ) ) <NEWLINE> if S == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def solution ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> num = [ 0 ] * 2019 <NEWLINE> num [ 0 ] = 1 <NEWLINE> c , ans , dgt = 0 , 0 , 1 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> c = ( c + int ( S [ i ] ) * dgt ) % 2019 <NEWLINE> dgt *= 10 <NEWLINE> dgt %= 2019 <NEWLINE> ans += num [ c ] <NEWLINE> num [ c ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> solution ( ) <NEWLINE> <NL> <NL> <NL> def sample ( ) : <NEWLINE> <INDENT> x = - 1 <NEWLINE> count = 0 <NEWLINE> for i in op : <NEWLINE> <INDENT> x += 1 <NEWLINE> group = <STRING> <NEWLINE> for j , name in enumerate ( op , x ) : <NEWLINE> <INDENT> group += name <NEWLINE> if int ( group ) % 2019 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> def checkValue ( ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> group = <STRING> <NEWLINE> for j in range ( i , length ) : <NEWLINE> <INDENT> group += op [ j ] <NEWLINE> if int ( group ) % 2019 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT>
def abc070_d ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10010010 ) <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> inp = iter ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> <NL> n = next ( inp ) <NEWLINE> adjlist = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a = next ( inp ) - 1 <NEWLINE> b = next ( inp ) - 1 <NEWLINE> c = next ( inp ) <NEWLINE> adjlist [ a ] . append ( ( b , c ) ) <NEWLINE> adjlist [ b ] . append ( ( a , c ) ) <NEWLINE> <NL> <DEDENT> q = next ( inp ) <NEWLINE> k = next ( inp ) - 1 <NEWLINE> <NL> dist = [ - 1 ] * n <NEWLINE> <NL> def dfs ( x : int , d : int ) : <NEWLINE> <INDENT> dist [ x ] = d <NEWLINE> for nx , nd in adjlist [ x ] : <NEWLINE> <INDENT> if dist [ nx ] != - 1 : continue <NEWLINE> dfs ( nx , d + nd ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( k , 0 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> x = next ( inp ) - 1 <NEWLINE> y = next ( inp ) - 1 <NEWLINE> ans = dist [ x ] + dist [ y ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc070_d ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dll = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> input_line = input ( ) . split ( ) <NEWLINE> if input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . appendleft ( input_line [ 1 ] ) <NEWLINE> <DEDENT> elif input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . remove ( input_line [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * dll ) <NEWLINE>
import numpy as np <NEWLINE> from collections import deque <NEWLINE> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> roads = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> roads [ A ] . append ( B ) <NEWLINE> roads [ B ] . append ( A ) <NEWLINE> <DEDENT> places = [ 0 ] * ( N + 1 ) <NEWLINE> places [ 1 ] = 1 <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> vis = [ False ] * ( N + 1 ) <NEWLINE> vis [ 1 ] = True <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> L = roads [ now ] <NEWLINE> for j in L : <NEWLINE> <INDENT> if vis [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> vis [ j ] = True <NEWLINE> places [ j ] = now <NEWLINE> q . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> s = <STRING> . join ( map ( str , places [ 2 : ] ) ) <NEWLINE> print ( s ) <NEWLINE>
from math import log10 as log10 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> _max = 10 ** ( 18 ) <NEWLINE> <NL> ans = a [ 0 ] <NEWLINE> min_a = min ( a ) <NEWLINE> <NL> for _a in a [ 1 : ] : <NEWLINE> <INDENT> if min_a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans > _max : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> ans *= _a <NEWLINE> <NL> <DEDENT> if ( ans > _max ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif min_a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = Counter ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = sum ( x * y for x , y in a . items ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = s + ( c - b ) * a [ b ] <NEWLINE> a [ c ] += a [ b ] <NEWLINE> a [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> c = [ ] <NEWLINE> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> c . append ( count ) <NEWLINE> <DEDENT> print ( lt - max ( c ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> NI = lambda : int ( input ( ) ) <NEWLINE> NMI = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> NLI = lambda : list ( NMI ( ) ) <NEWLINE> SI = lambda : input ( ) <NEWLINE> <NL> <NL> def make_grid ( h , w , num ) : return [ [ int ( num ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = NMI ( ) <NEWLINE> A = NLI ( ) <NEWLINE> <NL> match_dict = { i + 1 : m for i , m in enumerate ( [ 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ) } <NEWLINE> usable_list = [ [ a , match_dict [ a ] ] for a in A ] <NEWLINE> usable_list . sort ( key = lambda x : ( x [ 1 ] , - x [ 0 ] ) ) <NEWLINE> <NL> <COMMENT> <NL> dp = [ - 1 ] * ( N + 10 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for num , m in usable_list : <NEWLINE> <INDENT> dp [ i + m ] = max ( dp [ i + m ] , dp [ i ] * 10 + num ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> if k == 7 or k == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> r = 7 % k <NEWLINE> g = { r } <NEWLINE> ans = 1 <NEWLINE> while True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> r = ( 10 * r + 7 ) % k <NEWLINE> if r == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> if r in g : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g . add ( r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ ] <NEWLINE> def dfs ( l ) : <NEWLINE> <INDENT> if len ( l ) == n : <NEWLINE> <INDENT> return [ l ] <NEWLINE> <NL> <DEDENT> if len ( l ) == 0 : <NEWLINE> <INDENT> t = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = l [ - 1 ] <NEWLINE> <DEDENT> res = [ ] <NEWLINE> for i in range ( t , m + 1 ) : <NEWLINE> <INDENT> temp = l + [ i ] <NEWLINE> for j in dfs ( temp ) : <NEWLINE> <INDENT> res . append ( j ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> t . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> l = dfs ( [ ] ) <NEWLINE> for i in l : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for a , b , c , d in t : <NEWLINE> <INDENT> if i [ b - 1 ] - i [ a - 1 ] == c : <NEWLINE> <INDENT> temp += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d / s > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from time import time <NEWLINE> <NL> def solve ( N , S ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> Cs = [ [ ] , [ ] , [ ] ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = S [ i ] <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> Cs [ 0 ] . append ( i ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> Cs [ 1 ] . append ( i ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> Cs [ 2 ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> answer = len ( Cs [ 0 ] ) * len ( Cs [ 1 ] ) * len ( Cs [ 2 ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( 1 , N - i ) : <NEWLINE> <INDENT> if i + 2 * d < N and not ( S [ i ] == S [ i + d ] or S [ i ] == S [ i + 2 * d ] or S [ i + d * 2 ] == S [ i + d ] ) : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> def main ( N , S ) : <NEWLINE> <INDENT> import sys <NEWLINE> start = time ( ) <NEWLINE> from itertools import combinations <NEWLINE> Cs = [ [ ] , [ ] , [ ] ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = S [ i ] <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> Cs [ 0 ] . append ( i ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> Cs [ 1 ] . append ( i ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> Cs [ 2 ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> answer = 0 <NEWLINE> for C in Cs : <NEWLINE> <INDENT> a = 0 <NEWLINE> print ( C , len ( C ) ) <NEWLINE> for Ci in range ( len ( C ) - 1 ) : <NEWLINE> <INDENT> i = C [ Ci ] <NEWLINE> for Cj in range ( Ci + 1 , len ( C ) ) : <NEWLINE> <INDENT> j = C [ Cj ] <NEWLINE> print ( <STRING> , i , j ) <NEWLINE> print ( i ) <COMMENT> <NEWLINE> print ( j - i - 1 ) <COMMENT> <NEWLINE> print ( N - 1 - j ) <COMMENT> <NEWLINE> print ( Ci ) <NEWLINE> print ( Cj - Ci - 1 ) <NEWLINE> print ( len ( C ) - 1 - Cj ) <NEWLINE> a += i <COMMENT> <NEWLINE> a += N - 1 - j <COMMENT> <NEWLINE> a += j - i - 1 <COMMENT> <NEWLINE> a -= Ci <NEWLINE> a -= Cj - Ci - 1 <NEWLINE> a -= len ( C ) - 1 - Cj <NEWLINE> <DEDENT> <DEDENT> print ( S [ C [ 0 ] ] , <STRING> , sum ( S [ C [ 0 ] ] in ( i , j , k ) and ( i == j or j == k or i == k ) for i , j , k in combinations ( S , 3 ) ) ) <NEWLINE> print ( S [ C [ 0 ] ] , <STRING> , a ) <NEWLINE> answer += a <NEWLINE> <DEDENT> print ( <STRING> , sum ( i == j or j == k or i == k for i , j , k in combinations ( S , 3 ) ) ) <NEWLINE> print ( <STRING> , answer ) <NEWLINE> <NL> print ( answer , time ( ) - start , file = sys . stderr ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( 1 , N - i ) : <NEWLINE> <INDENT> if i + 2 * d < N and not ( S [ i ] == S [ i + d ] or S [ i ] == S [ i + 2 * d ] ) : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> total = N * ( N - 1 ) * ( N - 2 ) // 6 <NEWLINE> print ( total , answer , file = sys . stderr ) <NEWLINE> print ( total - answer ) <NEWLINE> print ( time ( ) - start , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> solve ( N , S ) <NEWLINE> <COMMENT> <NL>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> num [ i - 1 ] -= i <NEWLINE> <DEDENT> numbers = np . array ( num ) <NEWLINE> b = int ( round ( np . median ( numbers ) ) ) <NEWLINE> numbers -= b <NEWLINE> number = np . abs ( numbers ) <NEWLINE> print ( number . sum ( ) ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> N = I ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= ( i + 1 ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> res . append ( a [ i - k ] < a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for b in res : <NEWLINE> <INDENT> if ( b ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> * H , = map ( int , input ( ) . split ( ) ) <NEWLINE> st = [ ( 0 , - 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> h = H [ i ] <NEWLINE> base = i <NEWLINE> while st and h <= st [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> h0 , j = st . pop ( ) <NEWLINE> ans = max ( ans , ( i - j ) * h0 ) <NEWLINE> base = j <NEWLINE> <DEDENT> st . append ( ( h , base ) ) <NEWLINE> <DEDENT> while st : <NEWLINE> <INDENT> h0 , j = st . pop ( ) <NEWLINE> ans = max ( ans , ( N - j ) * h0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> i = 0 <NEWLINE> l = int ( k ) <NEWLINE> p = str ( ) <NEWLINE> <NL> while i < l and len ( s ) > l : <NEWLINE> <INDENT> p = p + s [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> while i < len ( s ) and len ( s ) <= l : <NEWLINE> <INDENT> p = p + s [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> if len ( s ) > l : <NEWLINE> <INDENT> print ( p + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( T ) == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif T [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = T [ 0 ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( T ) - 2 ) : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if ans [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += T [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( T ) > 1 : <NEWLINE> <INDENT> if T [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += T [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> a , b , i = 0 , 1 , 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> while i < K - 1 : <NEWLINE> <INDENT> if A [ a ] * A [ a + 1 ] > A [ - b ] * A [ - b - 1 ] : <NEWLINE> <INDENT> ans *= A [ a ] * A [ a + 1 ] <NEWLINE> ans %= mod <NEWLINE> a += 2 <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ - b ] <NEWLINE> ans %= mod <NEWLINE> b += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> ans *= A [ - b ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if A [ - 1 ] < 0 and K % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A [ N - K : ] : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) . strip ( ) ) <NEWLINE> <NL> l = 0 <NEWLINE> r = N - 1 <NEWLINE> ans = 0 <NEWLINE> while l < r : <NEWLINE> <INDENT> if S [ l ] == <STRING> and S [ r ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <DEDENT> while l < N and S [ l ] != <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> while r >= 0 and S [ r ] != <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> flag = True <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> flag = False <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > ( 10 ** 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( ans ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> yakusuu = [ ] <NEWLINE> <NL> for i in range ( 1 , min ( A , B ) + 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> yakusuu . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( yakusuu [ - K ] ) <NEWLINE>
import itertools <NEWLINE> import numpy <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ ] * Q <NEWLINE> d_list = [ ] <NEWLINE> sum_d = 0 <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> abcd . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> A = [ 1 for i in range ( N ) ] <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ abcd [ i ] [ 1 ] - 1 ] - A [ abcd [ i ] [ 0 ] - 1 ] == abcd [ i ] [ 2 ] : <NEWLINE> <INDENT> d_list . append ( abcd [ i ] [ 3 ] ) <NEWLINE> <DEDENT> <DEDENT> if sum_d <= sum ( d_list ) : <NEWLINE> <INDENT> sum_d = sum ( d_list ) <NEWLINE> <DEDENT> d_list . clear ( ) <NEWLINE> <DEDENT> print ( sum_d ) <NEWLINE>
<COMMENT> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i + 1 ) + <STRING> + str ( x ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = Counter ( s ) <NEWLINE> ans = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if n <= 2 * j - i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ 2 * j - i ] and s [ j ] != s [ 2 * j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> C , D = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( C * D ) ) <NEWLINE>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> f = <STRING> <NEWLINE> b = <STRING> <NEWLINE> r = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query = input ( ) . split ( ) <NEWLINE> if int ( query [ 0 ] ) == 1 : <NEWLINE> <INDENT> r = 1 - r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( r ^ ( int ( query [ 1 ] ) - 1 ) ) == 0 : <NEWLINE> <INDENT> f += query [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += query [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ret = f [ : : - 1 ] + s + b <NEWLINE> if r : <NEWLINE> <INDENT> ret = ret [ : : - 1 ] <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> class GCD : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . cache = { } <NEWLINE> self . cache3 = { } <NEWLINE> <DEDENT> def gcd2 ( self , a , b ) : <NEWLINE> <INDENT> a , b = sorted ( [ a , b ] , reverse = True ) <NEWLINE> if ( a in self . cache and b in self . cache [ a ] ) : <NEWLINE> <INDENT> return self . cache [ a ] [ b ] <NEWLINE> <DEDENT> if ( a % b == 0 ) : <NEWLINE> <INDENT> if ( a not in self . cache ) : <NEWLINE> <INDENT> self . cache [ a ] = { } <NEWLINE> <DEDENT> self . cache [ a ] [ b ] = b <NEWLINE> return b <NEWLINE> <DEDENT> return self . gcd2 ( b , a % b ) <NEWLINE> <DEDENT> def gcd3 ( self , a , b , c ) : <NEWLINE> <INDENT> a , b , c = sorted ( [ a , b , c ] , reverse = True ) <NEWLINE> if ( a in self . cache3 and b in self . cache3 [ a ] and c in self . cache3 [ a ] [ b ] ) : <NEWLINE> <INDENT> return self . cache3 [ a ] [ b ] [ c ] <NEWLINE> <DEDENT> if ( a not in self . cache3 ) : <NEWLINE> <INDENT> self . cache3 [ a ] = { } <NEWLINE> <DEDENT> if ( b not in self . cache3 [ a ] ) : <NEWLINE> <INDENT> self . cache3 [ a ] [ b ] = { } <NEWLINE> <DEDENT> result = self . gcd2 ( self . gcd2 ( a , c ) , b ) <NEWLINE> self . cache3 [ a ] [ b ] [ c ] = result <NEWLINE> return result <NEWLINE> <NL> <DEDENT> <DEDENT> a = 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> result = 0 <NEWLINE> client = GCD ( ) <NEWLINE> while ( a <= k ) : <NEWLINE> <INDENT> b = a <NEWLINE> while ( b <= k ) : <NEWLINE> <INDENT> interval = client . gcd2 ( a , b ) <NEWLINE> c = b <NEWLINE> while ( c <= k ) : <NEWLINE> <INDENT> if ( a == b and b == c ) : <NEWLINE> <INDENT> result += client . gcd2 ( interval , c ) <NEWLINE> <DEDENT> elif ( a != b and b != c and a != c ) : <NEWLINE> <INDENT> result += client . gcd2 ( interval , c ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += client . gcd2 ( interval , c ) * 3 <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> pl = factorization ( n ) <NEWLINE> if len ( pl ) == 0 : exit ( print ( 0 ) ) <NEWLINE> count = 0 <NEWLINE> for a , b in pl : <NEWLINE> <INDENT> if a == 1 and b == 1 : exit ( print ( 0 ) ) <NEWLINE> t = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if b < t : break <NEWLINE> count += 1 <NEWLINE> b -= t <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
l = set ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> l . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( l ) ) <NEWLINE>
class Tree : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . p = - 1 <NEWLINE> self . left = - 1 <NEWLINE> self . right = - 1 <NEWLINE> self . type = <STRING> <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tree = tuple ( Tree ( i ) for i in range ( n ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> id , l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l != - 1 : <NEWLINE> <INDENT> tree [ id ] . left = l <NEWLINE> tree [ l ] . p = id <NEWLINE> <DEDENT> if r != - 1 : <NEWLINE> <INDENT> tree [ id ] . right = r <NEWLINE> tree [ r ] . p = id <NEWLINE> <DEDENT> <DEDENT> root = 0 <NEWLINE> while tree [ root ] . p != - 1 : <NEWLINE> <INDENT> root = tree [ root ] . p <NEWLINE> <DEDENT> def preorder_tree_walk ( id ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if tree [ id ] . left != - 1 : <NEWLINE> <INDENT> preorder_tree_walk ( tree [ id ] . left ) <NEWLINE> <DEDENT> if tree [ id ] . right != - 1 : <NEWLINE> <INDENT> preorder_tree_walk ( tree [ id ] . right ) <NEWLINE> <DEDENT> <DEDENT> def inorder_tree_walk ( id ) : <NEWLINE> <INDENT> if tree [ id ] . left != - 1 : <NEWLINE> <INDENT> inorder_tree_walk ( tree [ id ] . left ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if tree [ id ] . right != - 1 : <NEWLINE> <INDENT> inorder_tree_walk ( tree [ id ] . right ) <NEWLINE> <DEDENT> <DEDENT> def postorder_tree_walk ( id ) : <NEWLINE> <INDENT> if tree [ id ] . left != - 1 : <NEWLINE> <INDENT> postorder_tree_walk ( tree [ id ] . left ) <NEWLINE> <DEDENT> if tree [ id ] . right != - 1 : <NEWLINE> <INDENT> postorder_tree_walk ( tree [ id ] . right ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> preorder_tree_walk ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> inorder_tree_walk ( root ) <NEWLINE> print ( <STRING> ) <NEWLINE> postorder_tree_walk ( root ) <NEWLINE> print ( ) <NEWLINE> <NL>
def doSame ( n ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i <= n : <NEWLINE> <INDENT> i += 1 <NEWLINE> cn ( i , n ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> def cn ( i , n ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> if i <= n : <NEWLINE> <INDENT> print ( <STRING> % ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> i3 ( x , i , n ) <NEWLINE> <NL> <DEDENT> def i3 ( x , i , n ) : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> if i <= n : <NEWLINE> <INDENT> print ( <STRING> % ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> x = int ( x / 10 ) <NEWLINE> if x > 0 : <NEWLINE> <INDENT> i3 ( x , i , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> doSame ( int ( input ( ) ) ) <NEWLINE>
from sys import stdin <NEWLINE> for line in stdin : <NEWLINE> <INDENT> tmp = line . strip ( <STRING> ) . split ( <STRING> ) <NEWLINE> a , b = int ( tmp [ 0 ] ) , int ( tmp [ - 1 ] ) <NEWLINE> if tmp [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif tmp [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif tmp [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif tmp [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> import bisect <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> X = ii ( ) <NEWLINE> <NL> lim = 10 ** 3 <NEWLINE> for a in range ( ( - 1 ) * lim , lim + 1 ) : <NEWLINE> <INDENT> for b in range ( ( - 1 ) * lim , lim + 1 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a_list : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aL = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bcL = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> sums = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> <NL> for a in aL : <NEWLINE> <INDENT> sums [ a ] += 1 <NEWLINE> <NL> <DEDENT> _sum = 0 <NEWLINE> for i , a in enumerate ( sums ) : <NEWLINE> <INDENT> _sum += i * a <NEWLINE> <NL> <DEDENT> for b , c in bcL : <NEWLINE> <INDENT> _sum += ( c - b ) * sums [ b ] <NEWLINE> <NL> sums [ c ] += sums [ b ] <NEWLINE> sums [ b ] = 0 <NEWLINE> print ( _sum ) <NEWLINE> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> i = ( L // 2019 ) + 1 <NEWLINE> ans = 0 <NEWLINE> if L <= 2019 * i <= R : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2020 <NEWLINE> for n in range ( L , R ) : <NEWLINE> <INDENT> for m in range ( n + 1 , R + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( n * m ) % 2019 ) <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> L , R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> src = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> e = [ ] <NEWLINE> for i , s in enumerate ( src , 1 ) : <NEWLINE> <INDENT> l = i + s <NEWLINE> r = i - s <NEWLINE> d [ l ] += 1 <NEWLINE> ans += d [ r ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N , D = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> h = math . sqrt ( A * A + B * B ) <NEWLINE> if D >= h : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string , decimal <NEWLINE> import sys <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def SS ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def II ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N , K = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> flag = [ False ] * N <NEWLINE> past = [ ] <NEWLINE> past . append ( 0 ) <NEWLINE> now = 0 <NEWLINE> cnt = 1 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> now = A [ now ] - 1 <NEWLINE> if flag [ now ] : <NEWLINE> <INDENT> past = past [ past . index ( now ) : : ] <NEWLINE> print ( past [ ( K - cnt ) % len ( past ) ] + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> flag [ now ] = True <NEWLINE> cnt += 1 <NEWLINE> past . append ( now ) <NEWLINE> <DEDENT> print ( now + 1 ) <NEWLINE>
import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> arr = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> unique , cnts = np . unique ( arr , return_counts = True ) <NEWLINE> <NL> counts = defaultdict ( int ) <NEWLINE> sum = arr . sum ( ) <NEWLINE> <NL> for key , val in zip ( unique , cnts ) : <NEWLINE> <INDENT> counts [ key ] = val <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counts [ C ] += counts [ B ] <NEWLINE> sum += counts [ B ] * ( C - B ) <NEWLINE> counts [ B ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> ans = L [ n ] * ans <NEWLINE> if ans >= 1000000000000000001 : ans = - 1 <NEWLINE> if ans == - 1 : break <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> if L [ n ] == 0 : ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> def do ( ) : <NEWLINE> <INDENT> s = STR ( ) <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> temp = 0 <NEWLINE> keta = 1 <NEWLINE> ans = 0 <NEWLINE> for i in s [ : : - 1 ] : <NEWLINE> <INDENT> temp = ( temp + int ( i ) * keta ) % 2019 <NEWLINE> keta = ( keta * 10 ) % 2019 <NEWLINE> cnt [ temp ] += 1 <NEWLINE> <DEDENT> for i in cnt : <NEWLINE> <INDENT> ans += ( i * ( i - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
import math as m <NEWLINE> <NL> def isltK ( K , X ) : <NEWLINE> <INDENT> ccut = 0 <NEWLINE> for Ai in As : <NEWLINE> <INDENT> ccut += m . ceil ( Ai / X ) - 1 <NEWLINE> <DEDENT> if ccut <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = 1 <NEWLINE> h = max ( As ) <NEWLINE> while l < h : <NEWLINE> <INDENT> mid = ( l + h ) // 2 <NEWLINE> if isltK ( K , mid ) : <NEWLINE> <INDENT> h = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid + 1 <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> point = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> point . append ( ( tuple ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <DEDENT> point = list ( set ( point ) ) <NEWLINE> point = sorted ( point ) <NEWLINE> if len ( point ) == 1 : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> d1 = max ( [ ( x + y ) for x , y in point ] ) - min ( [ ( x + y ) for x , y in point ] ) <NEWLINE> d2 = max ( [ ( x - y ) for x , y in point ] ) - min ( [ ( x - y ) for x , y in point ] ) <NEWLINE> print ( max ( d1 , d2 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = r * r * math . pi <NEWLINE> l = r * 2.0 * math . pi <NEWLINE> print ( <STRING> . format ( s , l ) ) <NEWLINE> <NL>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> su = 0 <NEWLINE> lis = [ ] <NEWLINE> for x in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = math . gcd ( x , y ) <NEWLINE> lis . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> for z in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for p in lis : <NEWLINE> <INDENT> ans = math . gcd ( p , z ) <NEWLINE> su += ans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( su ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> import collections <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> clist = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> c = collections . Counter ( clist ) <NEWLINE> cr = c [ <STRING> ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = clist [ : cr ] . count ( <STRING> ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> C = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> C = sorted ( C . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> rods = [ ] <NEWLINE> for k , v in C : <NEWLINE> <INDENT> if v >= 4 : <NEWLINE> <INDENT> rods . append ( k ) <NEWLINE> rods . append ( k ) <NEWLINE> break <NEWLINE> <DEDENT> if v >= 2 : <NEWLINE> <INDENT> rods . append ( k ) <NEWLINE> <DEDENT> if len ( rods ) == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( rods ) >= 2 : <NEWLINE> <INDENT> ans = rods [ 0 ] * rods [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> count , max_n = 0 , a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if max_n > a [ i ] : <NEWLINE> <INDENT> count += max_n - a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_n = max ( max_n , a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
w = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> nums = [ i for i in range ( 1 , w + 1 ) ] <NEWLINE> ab = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> nums [ a - 1 ] , nums [ b - 1 ] = nums [ b - 1 ] , nums [ a - 1 ] <NEWLINE> <DEDENT> for i in nums : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for A in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> result += ( N - 1 ) // A <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> ans . append ( s [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> minimun = max ( l ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] <= minimun : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> minimun = l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> ro = 1 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> num = int ( N / n ) <NEWLINE> if num == 1 : <NEWLINE> <INDENT> record = n <NEWLINE> break <NEWLINE> <DEDENT> s = int ( ( ( 1 + num ) * num ) / 2 ) <NEWLINE> sum += ro * s <NEWLINE> ro += 1 <NEWLINE> <NL> <NL> <DEDENT> sum += int ( ( ( record + N ) * ( N - record + 1 ) ) / 2 ) <NEWLINE> print ( sum ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> lndmrk = [ - 1 ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> q = deque ( ) <NEWLINE> lndmrk [ 1 ] = 0 <NEWLINE> q . append ( 1 ) <NEWLINE> while ( len ( q ) != 0 ) : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for i in e [ v ] : <NEWLINE> <INDENT> if lndmrk [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> lndmrk [ i ] = v <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> f = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if lndmrk [ i ] == - 1 : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( lndmrk [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> item = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> row = [ 0 ] * h <NEWLINE> col = [ 0 ] * w <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = item [ i ] <NEWLINE> row [ x - 1 ] += 1 <NEWLINE> col [ y - 1 ] += 1 <NEWLINE> <DEDENT> mr , mc = max ( row ) , max ( col ) <NEWLINE> xr = set ( [ i for i in range ( h ) if row [ i ] == mr ] ) <NEWLINE> xc = set ( [ i for i in range ( w ) if col [ i ] == mc ] ) <NEWLINE> check = len ( xr ) * len ( xc ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> r , c = item [ i ] <NEWLINE> if r - 1 in xr and c - 1 in xc : <NEWLINE> <INDENT> check -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( mr + mc if check > 0 else mr + mc - 1 ) <NEWLINE>
def postorder ( g ) : <NEWLINE> <INDENT> parent_stack = [ ] <NEWLINE> dfs_stack = [ ( 0 , None ) ] <NEWLINE> while dfs_stack : <NEWLINE> <INDENT> u , prev = dfs_stack . pop ( ) <NEWLINE> dfs_stack . extend ( ( t , u ) for d , t in g [ u ] ) <NEWLINE> while parent_stack and parent_stack [ - 1 ] != prev : <NEWLINE> <INDENT> yield parent_stack . pop ( ) <NEWLINE> <DEDENT> parent_stack . append ( u ) <NEWLINE> <DEDENT> while parent_stack : <NEWLINE> <INDENT> yield parent_stack . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> from sys import stdin <NEWLINE> from collections import defaultdict <NEWLINE> readline = stdin . readline <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> g = defaultdict ( list ) <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> s , t , d = map ( int , readline ( ) . split ( ) ) <NEWLINE> g [ s ] . append ( ( d , t ) ) <NEWLINE> <DEDENT> diameter = [ 0 ] <NEWLINE> dp = [ 0 ] * n <NEWLINE> for i in postorder ( g ) : <NEWLINE> <INDENT> if len ( g [ i ] ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> candidate = sorted ( d + dp [ t ] for d , t in g [ i ] ) <NEWLINE> dp [ i ] = candidate [ - 1 ] <NEWLINE> diameter . append ( dp [ i ] if len ( candidate ) == 1 else sum ( candidate [ - 2 : ] ) ) <NEWLINE> <NL> <DEDENT> print ( max ( diameter ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def comb ( a , b ) : <NEWLINE> <INDENT> comb = 1 <NEWLINE> chld = 1 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> comb = comb * ( a - i ) % mod <NEWLINE> chld = chld * ( b - i ) % mod <NEWLINE> <DEDENT> return ( comb * pow ( chld , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nm = ( x + y ) // 3 <NEWLINE> n = y - nm <NEWLINE> m = x - nm <NEWLINE> if n >= 0 and m >= 0 : <NEWLINE> <INDENT> print ( comb ( n + m , m ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from collections import defaultdict <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> diff_a = defaultdict ( int ) <NEWLINE> diff_b = defaultdict ( int ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> diff_a [ a ] += 1 <NEWLINE> diff_b [ b ] += 1 <NEWLINE> <NL> <DEDENT> cur = 0 <NEWLINE> for i in sorted ( diff_a ) : <NEWLINE> <INDENT> cur += diff_a [ i ] <NEWLINE> if cur >= n // 2 + 1 : <NEWLINE> <INDENT> b1 = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> cur = 0 <NEWLINE> for i in sorted ( diff_b , reverse = True ) : <NEWLINE> <INDENT> cur += diff_b [ i ] <NEWLINE> if cur >= n // 2 + 1 : <NEWLINE> <INDENT> e1 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> print ( e1 - b1 + 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> cur = 0 <NEWLINE> for i in sorted ( diff_a ) : <NEWLINE> <INDENT> cur += diff_a [ i ] <NEWLINE> if cur >= n // 2 : <NEWLINE> <INDENT> b2 = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> cur = 0 <NEWLINE> for i in sorted ( diff_b , reverse = True ) : <NEWLINE> <INDENT> cur += diff_b [ i ] <NEWLINE> if cur >= n // 2 : <NEWLINE> <INDENT> e2 = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = e2 + e1 - ( b1 + b2 ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> for _ in range ( min ( 41 , K ) ) : <NEWLINE> <INDENT> A_cumsum = np . zeros ( shape = N , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_cumsum [ max ( 0 , i - A [ i ] ) ] += 1 <NEWLINE> b = i + A [ i ] + 1 <NEWLINE> if N - 1 < b : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_cumsum [ b ] -= 1 <NEWLINE> <DEDENT> <DEDENT> A = np . cumsum ( A_cumsum ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> <NL> ans = solve ( N , K , A ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> hList = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ABList = [ list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> maxHeights = np . zeros ( n ) <NEWLINE> for a , b in ABList : <NEWLINE> <INDENT> if hList [ a - 1 ] >= maxHeights [ b - 1 ] : <NEWLINE> <INDENT> maxHeights [ b - 1 ] = hList [ a - 1 ] <NEWLINE> <DEDENT> if hList [ b - 1 ] >= maxHeights [ a - 1 ] : <NEWLINE> <INDENT> maxHeights [ a - 1 ] = hList [ b - 1 ] <NEWLINE> <DEDENT> <DEDENT> total = 0 <NEWLINE> i = 0 <NEWLINE> for maxHeight in maxHeights : <NEWLINE> <INDENT> if maxHeight < hList [ i ] : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if l == [ ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif l [ 0 ] < len ( l ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i > len ( l ) - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ( l ) ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> popcount = x . count ( <STRING> ) <NEWLINE> p = int ( x , 2 ) % ( popcount + 1 ) <NEWLINE> q = int ( x , 2 ) % ( popcount - 1 ) if popcount != 1 else 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> y = ( p + pow ( 2 , n - i - 1 , popcount + 1 ) ) % ( popcount + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if popcount != 1 : <NEWLINE> <INDENT> y = ( q - pow ( 2 , n - i - 1 , popcount - 1 ) ) % ( popcount - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> cnt = 1 <NEWLINE> while y != 0 : <NEWLINE> <INDENT> y %= bin ( y ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
ALL = [ ] <NEWLINE> cnt = 0 <NEWLINE> import math <NEWLINE> def decide_sosuu ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> for i in range ( 1 , int ( ( 10 ** 5 ) / 2 + 2 ) ) : <NEWLINE> <INDENT> if decide_sosuu ( i ) : <NEWLINE> <INDENT> if decide_sosuu ( ( i * 2 ) - 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ALL . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ALL . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ALL . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l == 1 : <NEWLINE> <INDENT> print ( ALL [ int ( r / 2 ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ALL [ int ( r / 2 ) ] - ALL [ int ( l / 2 ) - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
st = input ( ) <NEWLINE> stin = st . split ( ) <NEWLINE> a = int ( stin [ 0 ] ) <NEWLINE> b = int ( stin [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> p = 2019 <NEWLINE> n = 0 <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * p <NEWLINE> mods [ 0 ] = 1 <NEWLINE> for i , j in enumerate ( reversed ( s ) ) : <NEWLINE> <INDENT> n += int ( j ) * pow ( 10 , i , p ) <NEWLINE> n %= p <NEWLINE> mods [ n ] += 1 <NEWLINE> <DEDENT> for i in mods : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> ret = - 1 <NEWLINE> if K % 5 != 0 and K % 2 != 0 : <NEWLINE> <INDENT> N = 10 <NEWLINE> if K % 7 == 0 : <NEWLINE> <INDENT> L = K * 9 // 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = K * 9 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if N % L == 1 : <NEWLINE> <INDENT> ret = i <NEWLINE> break <NEWLINE> <DEDENT> N = ( N * 10 ) % L <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> D = int ( input ( ) ) <NEWLINE> c = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> S = np . zeros ( ( D , 26 ) ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> S [ i ] = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> T = np . array ( [ ] ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> T = np . append ( T , int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> def calc_score ( T , D , c , S ) : <NEWLINE> <INDENT> last = np . ones ( 26 ) * ( - 1 ) <NEWLINE> scores = [ ] <NEWLINE> score = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> i = int ( T [ d ] ) - 1 <NEWLINE> score += S [ d , i ] <NEWLINE> last [ i ] = d <NEWLINE> score -= np . sum ( c * ( d - last ) ) <NEWLINE> scores . append ( score ) <NEWLINE> <DEDENT> score = max ( [ 10 ** 6 + score , 0 ] ) <NEWLINE> return score , scores <NEWLINE> <NL> <DEDENT> _ , ans = calc_score ( T , D , c , S ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( int ( a ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for s in itertools . product ( range ( 2 ) , repeat = N ) : <NEWLINE> <NL> <INDENT> li = [ 0 for _ in range ( M ) ] <NEWLINE> cum = 0 <NEWLINE> for i , v in enumerate ( s ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> ca = CA [ i ] <NEWLINE> cum += ca [ 0 ] <NEWLINE> <NL> for j , x in enumerate ( ca [ 1 : ] ) : <NEWLINE> <INDENT> li [ j ] += x <NEWLINE> <NL> <DEDENT> <DEDENT> q = [ p >= X for p in li ] <NEWLINE> if all ( q ) : <NEWLINE> <INDENT> ans . append ( cum ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( ans ) if ans else - 1 ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> tot = k * ( k + 1 ) // 2 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k + 1 ) : <NEWLINE> <INDENT> tot += math . gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( j + 1 , k + 1 ) : <NEWLINE> <INDENT> tot += math . gcd ( i , math . gcd ( j , l ) ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( ( n // x ) * ( ( n // x ) + 1 ) * x ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> m = len ( t ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> or t [ i ] == <STRING> : <NEWLINE> <INDENT> s = s + t [ i ] <NEWLINE> <NL> <DEDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import numpy as np <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> H = np . zeros ( h ) <NEWLINE> W = np . zeros ( w ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hi , wi = hw [ i ] <NEWLINE> H [ hi - 1 ] += 1 <NEWLINE> W [ wi - 1 ] += 1 <NEWLINE> <DEDENT> mh = max ( H ) <NEWLINE> mw = max ( W ) <NEWLINE> hmax = [ i for i , x in enumerate ( H ) if x == mh ] <NEWLINE> wmax = [ i for i , x in enumerate ( W ) if x == mw ] <NEWLINE> f = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hi , wi = hw [ i ] <NEWLINE> if H [ hi - 1 ] == mh and W [ wi - 1 ] == mw : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( hmax ) * len ( wmax ) - f < 1 : <NEWLINE> <INDENT> print ( int ( mh + mw - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( mh + mw ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from math import ceil as C , floor as F , sqrt <NEWLINE> from collections import defaultdict as D , Counter as CNT <NEWLINE> from functools import reduce as R <NEWLINE> <NL> ALP = <STRING> <NEWLINE> alp = <STRING> <NEWLINE> def _X ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> def _S ( ss ) : return tuple ( ss ) if len ( ss ) > 1 else ss [ 0 ] <NEWLINE> def S ( ) : return _S ( _X ( ) ) <NEWLINE> def Ss ( ) : return list ( S ( ) ) <NEWLINE> def _I ( ss ) : return tuple ( [ int ( s ) for s in ss ] ) if isinstance ( ss , tuple ) else int ( ss ) <NEWLINE> def I ( ) : return _I ( S ( ) ) <NEWLINE> def _Is ( ss ) : return list ( ss ) if isinstance ( ss , tuple ) else [ ss ] <NEWLINE> def Is ( ) : return _Is ( I ( ) ) <NEWLINE> <NL> _ , k = Is ( ) <NEWLINE> towns = [ i - 1 for i in Is ( ) ] <NEWLINE> <NL> now = 0 <NEWLINE> seen = [ 0 ] <NEWLINE> seenx = { 0 : 0 } <NEWLINE> <NL> while k > 0 : <NEWLINE> <INDENT> k -= 1 <NEWLINE> now = towns [ now ] <NEWLINE> <NL> if now not in seenx : <NEWLINE> <INDENT> seenx [ now ] = len ( seen ) <NEWLINE> seen . append ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seen = seen [ seenx [ now ] : ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( 1 + now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 + ( seen [ k % len ( seen ) ] ) ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_list = list ( filter ( ( 1 ) . __ne__ , a_list ) ) <NEWLINE> <NL> if 0 in a_list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> result = result * a <NEWLINE> <NL> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> cnt += a [ i ] <NEWLINE> <DEDENT> pre = cnt <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> cnt -= a [ i ] <NEWLINE> cnt += a [ i + k ] <NEWLINE> if cnt > pre : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> pre = cnt <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> l . sort ( key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> h = l [ 0 ] [ 2 ] + abs ( i - l [ 0 ] [ 0 ] ) + abs ( j - l [ 0 ] [ 1 ] ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> tmp = max ( h - abs ( i - l [ k ] [ 0 ] ) - abs ( j - l [ k ] [ 1 ] ) , 0 ) <NEWLINE> if tmp != l [ k ] [ 2 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif k == N - 1 : <NEWLINE> <INDENT> X = i <NEWLINE> Y = j <NEWLINE> H = h <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( X , Y , H ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( pi * r ** 2 , 2 * pi * r ) ) <NEWLINE> <NL>
from itertools import combinations <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> skill = [ 0 ] * M <NEWLINE> N_list = [ ] <NEWLINE> C_sum = 0 <NEWLINE> all_list = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> res_list = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> list_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N_list . append ( list_ ) <NEWLINE> all_list = [ all_list [ i ] + list_ [ i ] for i in range ( M + 1 ) ] <NEWLINE> <NL> <DEDENT> result = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ref = list ( combinations ( N_list , i ) ) <NEWLINE> for j in range ( len ( ref ) ) : <NEWLINE> <INDENT> sums = [ 0 ] * ( M + 1 ) <NEWLINE> for k in range ( i ) : <NEWLINE> <INDENT> sums = [ sums [ l ] + ref [ j ] [ k ] [ l ] for l in range ( M + 1 ) ] <NEWLINE> <DEDENT> result . append ( sums ) <NEWLINE> <DEDENT> <DEDENT> kekka = [ ] <NEWLINE> for i in range ( len ( result ) ) : <NEWLINE> <INDENT> if all ( result [ i ] [ j ] >= X for j in range ( 1 , M + 1 ) ) : <NEWLINE> <INDENT> kekka . append ( result [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if kekka != [ ] : <NEWLINE> <INDENT> print ( min ( kekka ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> num_list = input ( ) . split ( ) <NEWLINE> <NL> mod_base = 10 ** 9 + 7 <NEWLINE> <NL> num_list = [ int ( x ) for x in num_list ] <NEWLINE> <NL> sum_list = [ ] <NEWLINE> sum_tmp = sum ( num_list ) <NEWLINE> for i in range ( len ( num_list ) ) : <NEWLINE> <INDENT> sum_list . append ( sum_tmp ) <NEWLINE> sum_tmp -= num_list [ i ] <NEWLINE> <NL> <DEDENT> all_sum = 0 <NEWLINE> for index , num in enumerate ( num_list ) : <NEWLINE> <INDENT> if index + 1 >= len ( num_list ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> all_sum += num * sum_list [ index + 1 ] <NEWLINE> <NL> <DEDENT> print ( all_sum % mod_base ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> layer = 0 <NEWLINE> branch_set = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if h > 1 : <NEWLINE> <INDENT> h //= 2 <NEWLINE> layer += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , layer ) : <NEWLINE> <INDENT> branch_set += 2 ** i <NEWLINE> <NL> <DEDENT> print ( branch_set + 2 ** layer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ( i + N // i * i ) * ( N // i ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power = power % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> T = list ( input ( ) ) <NEWLINE> Q = [ i for i , x in enumerate ( T ) if x == <STRING> ] <NEWLINE> <NL> if len ( T ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in Q : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if T [ i + 1 ] == <STRING> or T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == len ( T ) - 1 : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if T [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> or T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , T ) ) ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> from math import cos , sin , tan , sqrt <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> import re <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> n = iinput ( ) <NEWLINE> a = iarr ( ) <NEWLINE> amax = max ( a ) <NEWLINE> <COMMENT> <NL> <NL> cnt = [ 0 for i in range ( amax + 1 ) ] <NEWLINE> for num in a : <NEWLINE> <INDENT> for i in range ( 1 , amax // num + 1 ) : <NEWLINE> <INDENT> tmp = num * i <NEWLINE> cnt [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for num in a : <NEWLINE> <INDENT> if cnt [ num ] == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def floor ( x ) : <NEWLINE> <INDENT> return int ( a * x / b ) - a * int ( x / b ) <NEWLINE> <NL> <DEDENT> if n >= b - 1 : <NEWLINE> <INDENT> ans = floor ( b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = floor ( n ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> pos = [ [ ] for _ in range ( 26 ) ] <NEWLINE> <NL> len_s = len ( s ) <NEWLINE> len_t = len ( t ) <NEWLINE> <NL> <NL> for i in range ( len_s ) : <NEWLINE> <INDENT> idx = ord ( s [ i ] ) - 97 <NEWLINE> pos [ idx ] . append ( i ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> tmp = - 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len_t ) : <NEWLINE> <INDENT> idx = ord ( t [ i ] ) - 97 <NEWLINE> if len ( pos [ idx ] ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if tmp < pos [ idx ] [ - 1 ] : <NEWLINE> <INDENT> l = - 1 <NEWLINE> r = len ( pos [ idx ] ) - 1 <NEWLINE> while l + 1 < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if pos [ idx ] [ mid ] <= tmp : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> ans . append ( pos [ idx ] [ r ] ) <NEWLINE> tmp = pos [ idx ] [ r ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans . append ( pos [ idx ] [ 0 ] ) <NEWLINE> tmp = pos [ idx ] [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt * len_s + ans [ - 1 ] + 1 ) <NEWLINE> <NL> <NL>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( A + B ) % 2 == 0 : <NEWLINE> <INDENT> print ( int ( ( A + B ) / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = eval ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> prod = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> prod *= int ( a [ i ] ) <NEWLINE> if prod > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if prod > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( prod ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - A + B ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> road . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> tall = [ 1 for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if h [ road [ i ] [ 0 ] - 1 ] > h [ road [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> tall [ road [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ road [ i ] [ 0 ] - 1 ] == h [ road [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> tall [ road [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> tall [ road [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tall [ road [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> counter = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if tall [ i ] == 1 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> scores = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for remover , new_commer in zip ( scores , scores [ k : ] ) : <NEWLINE> <INDENT> if remover < new_commer : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> lcm = int ( n * m / math . gcd ( n , m ) ) <NEWLINE> if ( n - 1 ) // ( lcm // m ) == 0 : <NEWLINE> <INDENT> if s [ 0 ] == t [ 0 ] : <NEWLINE> <INDENT> print ( lcm ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ( n - 1 ) // ( lcm // m ) ) : <NEWLINE> <INDENT> if s [ i * ( lcm // m ) ] != t [ i * ( lcm // n ) ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif i == ( n - 1 ) // ( lcm // m ) - 1 : <NEWLINE> <INDENT> print ( lcm ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < b : <NEWLINE> <INDENT> print ( ( a * n ) // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * ( b - 1 ) // b ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ cc + [ sum ( cc ) ] for cc in ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( r ) ) ] <NEWLINE> table . append ( list ( map ( sum , zip ( * table ) ) ) ) <NEWLINE> for line in table : <NEWLINE> <INDENT> print ( * line ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> n = [ 0 for _ in range ( 100000 + 1 ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> n [ i ] += 1 <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s += ( c - b ) * n [ b ] <NEWLINE> print ( s ) <NEWLINE> n [ c ] += n [ b ] <NEWLINE> n [ b ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> self . dist = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return self . dist [ x ] , x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . find ( self . parents [ x ] ) <NEWLINE> self . dist [ x ] += tmp [ 0 ] <NEWLINE> self . parents [ x ] = tmp [ 1 ] <NEWLINE> <DEDENT> return self . dist [ x ] , self . parents [ x ] <NEWLINE> <NL> <DEDENT> def union ( self , x , y , d ) : <NEWLINE> <INDENT> rx = self . find ( x ) [ 1 ] <NEWLINE> ry = self . find ( y ) [ 1 ] <NEWLINE> diff = self . dist [ y ] - self . dist [ x ] - d <NEWLINE> if rx == ry : <NEWLINE> <INDENT> if diff != 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> if diff < 0 : <NEWLINE> <INDENT> rx , ry = ry , rx <NEWLINE> diff = - diff <NEWLINE> <DEDENT> self . parents [ ry ] = min ( self . parents [ ry ] , self . parents [ rx ] - diff ) <NEWLINE> self . parents [ rx ] = ry <NEWLINE> self . dist [ rx ] = diff <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * lrd = map ( int , read ( ) . split ( ) ) <NEWLINE> v = Unionfind ( n ) <NEWLINE> for l , r , d in zip ( * [ iter ( lrd ) ] * 3 ) : <NEWLINE> <INDENT> if v . union ( l - 1 , r - 1 , d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max ( - d - 1 for d in v . parents if d < 0 ) > 10 ** 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> acA = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acA . append ( acA [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> acB = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> acB . append ( acB [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( n + 1 ) : <NEWLINE> <INDENT> if k - acA [ a ] < 0 : break <NEWLINE> b = bisect . bisect ( acB , k - acA [ a ] ) - 1 <NEWLINE> ans = max ( ans , a + b ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ A [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( count / 2 ) ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : d [ i ] = d [ i - 1 ] + a [ i - 1 ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> b , c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 , 0 ] ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p = bisect . bisect_right ( a , b [ i ] ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ d [ p ] < c [ i ] ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( N ) ] <NEWLINE> rank = [ 0 ] * ( N + 1 ) <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <COMMENT> <NEWLINE> return par [ x ] <NEWLINE> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if rank [ x ] < rank [ y ] : <NEWLINE> <INDENT> par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ y ] = x <NEWLINE> if rank [ x ] == rank [ y ] : rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> unite ( a , b ) <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> a = [ - 1 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ i ] = find ( i ) <NEWLINE> <DEDENT> ca = Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for c in ca . values ( ) : <NEWLINE> <INDENT> ans = max ( ans , c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> dic = { } <NEWLINE> isOK = False <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a in [ 1 , n ] : <NEWLINE> <INDENT> dic . setdefault ( b , 0 ) <NEWLINE> dic [ b ] += 1 <NEWLINE> if dic [ b ] == 2 : <NEWLINE> <INDENT> isOK = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif b in [ 1 , n ] : <NEWLINE> <INDENT> dic . setdefault ( a , 0 ) <NEWLINE> dic [ a ] += 1 <NEWLINE> if dic [ a ] == 2 : <NEWLINE> <INDENT> isOK = True <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if isOK : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> left = 0 <NEWLINE> right = max ( Alist ) <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> <NL> cnt = 0 <NEWLINE> for A in Alist : <NEWLINE> <INDENT> if A % mid == 0 : <NEWLINE> <INDENT> cnt += ( A // mid ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += ( A // mid ) <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt <= K : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> coins = [ 100 , 101 , 102 , 103 , 104 , 105 ] <NEWLINE> dp = [ int ( i % coins [ 0 ] == 0 ) for i in range ( N + 1 ) ] <NEWLINE> for coin in coins [ 1 : ] : <NEWLINE> <INDENT> for i in range ( coin , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ i - coin ] <NEWLINE> <DEDENT> <DEDENT> if dp [ - 1 ] != 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> heap = [ ] <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> inst = input ( ) <NEWLINE> if inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( heap , - int ( inst [ 7 : ] ) ) <NEWLINE> <DEDENT> elif inst [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( - heapq . heappop ( heap ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> ma = max ( a ) <NEWLINE> f = [ 1 ] * ( ma + 1 ) <NEWLINE> <NL> count = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if f [ i ] : <NEWLINE> <INDENT> if count [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( i , min ( ma + i , ma + 1 ) , i ) : <NEWLINE> <INDENT> f [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> inpt = input ( ) <NEWLINE> inpt_list = inpt . split ( <STRING> ) <NEWLINE> X , K , D = [ int ( x ) for x in inpt_list ] <NEWLINE> <NL> X_abs = np . abs ( X ) <NEWLINE> num = X_abs // D <NEWLINE> rem = K - num <NEWLINE> if rem < 0 : <NEWLINE> <INDENT> out = X_abs - D * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if rem % 2 == 0 : <NEWLINE> <INDENT> out = X_abs - num * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out = np . abs ( X_abs - num * D - D ) <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1000 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> ans += ans // A [ i ] * ( A [ i + 1 ] - A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> ans = 1 ; <NEWLINE> flg = True <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flg ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if A < B : <NEWLINE> <INDENT> Ap = A + V * T <NEWLINE> Bp = B + W * T <NEWLINE> <NL> if Ap >= Bp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Ap = A + ( - V * T ) <NEWLINE> Bp = B + ( - W * T ) <NEWLINE> <NL> if Ap <= Bp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def main ( * , int = int , input = input ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Alog = [ math . log10 ( x ) for x in A ] <NEWLINE> <NL> <DEDENT> if sum ( Alog ) > 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import io , sys <NEWLINE> if <STRING> in locals ( ) : <NEWLINE> <INDENT> sys . stdin = io . StringIO ( _INPUT ) <NEWLINE> <DEDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( l ) <NEWLINE> s = set ( l ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> ans = max ( c [ i - 1 ] + c [ i ] + c [ i + 1 ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> query = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> ls = list ( range ( n + m - 1 ) ) <NEWLINE> mx = 0 <NEWLINE> for l in itertools . combinations ( ls , m - 1 ) : <NEWLINE> <INDENT> a = [ 0 ] <NEWLINE> idx = 0 <NEWLINE> val = 1 <NEWLINE> for i in range ( n + m - 1 ) : <NEWLINE> <INDENT> if idx < m - 1 and i == l [ idx ] : <NEWLINE> <INDENT> val += 1 <NEWLINE> idx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( val ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> v = 0 <NEWLINE> for i in query : <NEWLINE> <INDENT> if a [ i [ 1 ] ] - a [ i [ 0 ] ] == i [ 2 ] : v += i [ 3 ] <NEWLINE> <DEDENT> mx = max ( v , mx ) <NEWLINE> <DEDENT> print ( mx ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ 0 ] * ( N + 1 ) <NEWLINE> now = 1 <NEWLINE> p = [ ] <NEWLINE> f = False <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if L [ now ] == 1 : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> p . append ( now ) <NEWLINE> L [ now ] = 1 <NEWLINE> now = A [ now - 1 ] <NEWLINE> <NL> <DEDENT> if f : <NEWLINE> <INDENT> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ i ] == now : <NEWLINE> <INDENT> ans = p [ i + ( K - i ) % len ( p [ i : ] ) ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = now <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> SET = set ( ) <NEWLINE> for _ in range ( int ( readline ( ) ) ) : <NEWLINE> <INDENT> c , s = readline ( ) . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> SET . add ( s ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> print ( <STRING> if s in SET else <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 100000 <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> ans [ x * x + y * y + z * z + x * y + y * z + z * x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> num_list = [ 0 ] * ( n + 1 ) <NEWLINE> num_list [ 0 ] = 1 <NEWLINE> a_list = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> if 1 not in a_list : <NEWLINE> <INDENT> num_list [ 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i not in a_list : <NEWLINE> <INDENT> num_list [ i ] = num_list [ i - 1 ] + num_list [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( num_list [ n ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
def mod_pow ( a , n , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> result = 1 <NEWLINE> a_n = a <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> result = result * a_n % mod <NEWLINE> <DEDENT> a_n = a_n * a_n % mod <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> class ModCombination : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , mod , n_max ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . mod = mod <NEWLINE> self . n_max = n_max <NEWLINE> self . facts = [ 1 , 1 ] <NEWLINE> self . inverses = [ None , 1 ] <NEWLINE> self . fact_inverses = [ 1 , 1 ] <NEWLINE> <NL> for i in range ( 2 , self . n_max + 1 ) : <NEWLINE> <INDENT> self . facts . append ( self . facts [ i - 1 ] * i % self . mod ) <NEWLINE> self . inverses . append ( <NEWLINE> <INDENT> self . mod - self . inverses [ self . mod % i ] * <NEWLINE> ( self . mod // i ) % self . mod <NEWLINE> <DEDENT> ) <NEWLINE> self . fact_inverses . append ( <NEWLINE> <INDENT> self . fact_inverses [ i - 1 ] * self . inverses [ i ] % self . mod <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def mod_combination ( self , n , k ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> denominator = self . fact_inverses [ k ] * self . fact_inverses [ n - k ] % self . mod <NEWLINE> return self . facts [ n ] * denominator % self . mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> MOD = 998244353 <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> comb = ModCombination ( mod = MOD , n_max = N ) <NEWLINE> for k in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> ans += ( M * comb . mod_combination ( N - 1 , k ) ) % MOD * mod_pow ( M - 1 , N - 1 - k , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = <STRING> <NEWLINE> flag = <STRING> <NEWLINE> ans2 = <STRING> <NEWLINE> <NL> if ( N == 1 ) : <NEWLINE> <INDENT> if ( S == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> flag += <STRING> <NEWLINE> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag += <STRING> <NEWLINE> ans += S [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> if ( ans [ i + 1 ] == <STRING> and flag [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans2 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 += ans [ i ] <NEWLINE> <DEDENT> <DEDENT> elif ( i == N - 1 ) : <NEWLINE> <INDENT> ans2 += ans [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ans2 [ i - 1 ] == <STRING> and ans [ i + 1 ] == <STRING> and flag [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans2 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 += ans [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans2 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> text = [ list ( map ( int , i . strip ( <STRING> ) . split ( ) ) ) for i in sys . stdin ] <NEWLINE> num_tex = [ i for i in range ( 1 , len ( text ) + 1 ) ] <NEWLINE> all_c = [ ] <NEWLINE> for comb in num_tex : <NEWLINE> <INDENT> for v in itertools . combinations ( text , comb ) : <NEWLINE> <INDENT> sum_a = [ ] <NEWLINE> for j in range ( 1 , len ( v [ 0 ] ) ) : <NEWLINE> <INDENT> sum_a . append ( sum ( [ v_ [ j ] for v_ in v ] ) ) <NEWLINE> <DEDENT> if all ( [ x <= sum_a_ for sum_a_ in sum_a ] ) : <NEWLINE> <INDENT> all_c . append ( sum ( [ v_ [ 0 ] for v_ in v ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( all_c ) != 0 : <NEWLINE> <INDENT> print ( sorted ( all_c ) [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <COMMENT> <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> price = [ - i for i in price ] <NEWLINE> <NL> heapq . heapify ( price ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> sm = heapq . heappop ( price ) <NEWLINE> sm = - ( - sm // 2 ) <NEWLINE> heapq . heappush ( price , sm ) <NEWLINE> <NL> <DEDENT> price = [ - i for i in price ] <NEWLINE> <NL> print ( sum ( price ) ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( k + i + 1 , len ( s ) + 1 ) ) : <NEWLINE> <INDENT> ans . append ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = list ( set ( ans ) ) <NEWLINE> ans . sort ( ) <NEWLINE> print ( ans [ k - 1 ] ) <NEWLINE>
from sys import stdin <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = [ 0 ] * ( h * w ) <NEWLINE> y = x . copy ( ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> x [ a [ j ] - 1 ] = i <NEWLINE> y [ a [ j ] - 1 ] = j <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cost = [ [ 0 ] for _ in range ( d ) ] <NEWLINE> for i in range ( d , h * w ) : <NEWLINE> <INDENT> cost [ i % d ] . append ( cost [ i % d ] [ - 1 ] + abs ( x [ i ] - x [ i - d ] ) + abs ( y [ i ] - y [ i - d ] ) ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 <NEWLINE> r -= 1 <NEWLINE> ans . append ( cost [ r % d ] [ r // d ] - cost [ l % d ] [ l // d ] ) <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> from_ , to = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ from_ - 1 ] . append ( to - 1 ) <NEWLINE> edges [ to - 1 ] . append ( from_ - 1 ) <NEWLINE> <NL> <NL> <DEDENT> DP = [ 10 ** 9 + 7 ] * ( n + 1 ) <NEWLINE> DP [ 0 ] = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> <NL> def dfs ( node ) : <NEWLINE> <INDENT> node = node <NEWLINE> num = A [ node ] <NEWLINE> update_idx = bisect . bisect_left ( DP , num ) <NEWLINE> prev = DP [ update_idx ] <NEWLINE> DP [ update_idx ] = num <NEWLINE> lis = bisect . bisect_left ( DP , 10 ** 9 + 1 ) - 1 <NEWLINE> ans [ node ] = lis <NEWLINE> for nex in edges [ node ] : <NEWLINE> <INDENT> if not ans [ nex ] : <NEWLINE> <INDENT> dfs ( nex ) <NEWLINE> <NL> <DEDENT> <DEDENT> DP [ update_idx ] = prev <NEWLINE> <NL> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> for res in ans : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> n , m , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( x [ 0 ] ) <NEWLINE> b . append ( x [ 1 ] ) <NEWLINE> c . append ( x [ 2 ] ) <NEWLINE> d . append ( x [ 3 ] ) <NEWLINE> <NL> <DEDENT> h = [ ] <NEWLINE> A_list = list ( itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <NL> <NL> for A in A_list : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> s += d [ i ] <NEWLINE> <DEDENT> <DEDENT> h . append ( s ) <NEWLINE> <NL> <DEDENT> print ( max ( h ) ) <NEWLINE> <NL> <NL>
from math import gcd <NEWLINE> ans = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> GCD = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( GCD , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def prime ( num ) : <NEWLINE> <INDENT> if num == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif num == 2 or num == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , int ( num ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> tmp = n <NEWLINE> plist = [ ] <NEWLINE> if prime ( n ) : <NEWLINE> <INDENT> print ( <STRING> . format ( n , n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> for i in range ( 2 , tmp + 1 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> plist . append ( i ) <NEWLINE> tmp = tmp // i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( n , <STRING> . join ( map ( str , plist ) ) ) ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> list . append ( a ) <NEWLINE> <DEDENT> b = set ( list ) <NEWLINE> print ( len ( b ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> card_num = 0 <COMMENT> <NEWLINE> card_sum = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> if k <= a : <NEWLINE> <INDENT> card_sum = k <NEWLINE> <COMMENT> <NL> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> card_sum = a <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> card_sum = a - ( k - a - b ) <NEWLINE> <NL> <DEDENT> print ( card_sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ i // 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> words = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> while len ( S ) > 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> for word in words : <NEWLINE> <INDENT> if S . endswith ( word ) : <NEWLINE> <INDENT> flag = False <NEWLINE> S = S [ : - len ( word ) ] <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> road . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> bad_ob = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if H [ road [ i ] [ 0 ] - 1 ] > H [ road [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> bad_ob . append ( road [ i ] [ 1 ] - 1 ) <NEWLINE> <DEDENT> elif H [ road [ i ] [ 0 ] - 1 ] < H [ road [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> bad_ob . append ( road [ i ] [ 0 ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bad_ob . append ( road [ i ] [ 0 ] - 1 ) <NEWLINE> bad_ob . append ( road [ i ] [ 1 ] - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( N - len ( set ( bad_ob ) ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( X ) <NEWLINE> key = x // D <NEWLINE> Key = x % D <NEWLINE> if key > K : <NEWLINE> <INDENT> print ( x - K * D ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> KEY = Key - D <NEWLINE> if ( K - key ) % 2 == 0 : <NEWLINE> <INDENT> ans = abs ( Key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( KEY ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> S . insert ( 0 , 0 ) <NEWLINE> R = S . count ( <STRING> ) <NEWLINE> G = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> ans = R * G * B <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N + 1 and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> start_h , start_w = map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) <NEWLINE> goal_h , goal_w = map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ <STRING> * ( w + 4 ) ] <NEWLINE> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> s . append ( <STRING> * ( w + 4 ) ) <NEWLINE> <NL> ans = [ [ - 1 ] * ( w + 4 ) for _ in range ( h + 4 ) ] <NEWLINE> for i in range ( h + 4 ) : <NEWLINE> <INDENT> for j in range ( w + 4 ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] = - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans [ start_h ] [ start_w ] = 0 <NEWLINE> <NL> move1 = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> move2 = [ ( - 2 , - 2 ) , ( - 2 , - 1 ) , ( - 2 , 0 ) , ( - 2 , 1 ) , ( - 2 , 2 ) , ( - 1 , - 2 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) , ( - 1 , 2 ) , ( 0 , - 2 ) , ( 0 , - 1 ) , ( 0 , 0 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( 1 , - 2 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 1 , 2 ) , ( 2 , - 2 ) , ( 2 , - 1 ) , ( 2 , 0 ) , ( 2 , 1 ) , ( 2 , 2 ) ] <NEWLINE> <NL> yet = deque ( [ ( start_h , start_w ) ] ) <NEWLINE> done = deque ( ) <NEWLINE> <NL> while yet : <NEWLINE> <INDENT> x1 , y1 = yet . popleft ( ) <NEWLINE> done . append ( ( x1 , y1 ) ) <NEWLINE> for ( p , q ) in move1 : <NEWLINE> <INDENT> v1 , v2 = x1 + p , y1 + q <NEWLINE> if ans [ v1 ] [ v2 ] == - 1 : <COMMENT> <NEWLINE> <INDENT> yet . append ( ( v1 , v2 ) ) <NEWLINE> ans [ v1 ] [ v2 ] = ans [ x1 ] [ y1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( yet ) == 0 : <NEWLINE> <INDENT> while done : <NEWLINE> <INDENT> x2 , y2 = done . popleft ( ) <NEWLINE> for ( p , q ) in move2 : <NEWLINE> <INDENT> i , j = x2 + p , y2 + q <NEWLINE> if ans [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> ans [ i ] [ j ] = ans [ x2 ] [ y2 ] + 1 <NEWLINE> yet . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans [ goal_h ] [ goal_w ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> xs = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in xs : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for x in xs : <NEWLINE> <INDENT> s *= x <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def f_xyz ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> li = [ 0 ] * ( n + 5 ) <NEWLINE> for x in range ( 1 , 200 ) : <NEWLINE> <INDENT> for y in range ( 1 , 200 ) : <NEWLINE> <INDENT> for z in range ( 1 , 200 ) : <NEWLINE> <INDENT> num = f_xyz ( x , y , z ) <NEWLINE> if num <= n : <NEWLINE> <INDENT> li [ f_xyz ( x , y , z ) + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in li [ 2 : n + 2 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def carriable_baggage ( baggage , baggage_num , truck_capacity , truck_num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> laden_baggage = 0 <NEWLINE> for i in range ( truck_num ) : <NEWLINE> <INDENT> laden_weight = 0 <NEWLINE> while laden_weight + baggage [ laden_baggage ] <= truck_capacity : <NEWLINE> <INDENT> laden_weight += baggage [ laden_baggage ] <NEWLINE> laden_baggage += 1 <NEWLINE> if laden_baggage == baggage_num : <NEWLINE> <INDENT> return baggage_num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return laden_baggage <NEWLINE> <NL> <DEDENT> def min_capacity ( baggage , baggage_num , truck_num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> left = 0 <NEWLINE> right = 10000 * baggage_num <NEWLINE> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> v = carriable_baggage ( baggage , baggage_num , mid , truck_num ) <NEWLINE> if v >= baggage_num : <NEWLINE> <INDENT> right = mid ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> return right <NEWLINE> <NL> <NL> <DEDENT> import sys <NEWLINE> <NL> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> T = list ( map ( int , sys . stdin ) ) <NEWLINE> <NL> P = min_capacity ( T , n , k ) <NEWLINE> <NL> print ( P ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> width = [ 0 ] * W <NEWLINE> height = [ 0 ] * H <NEWLINE> <NL> st = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> y , x = map ( int , input ( ) . split ( ) ) <NEWLINE> st . add ( ( x - 1 , y - 1 ) ) <NEWLINE> width [ x - 1 ] += 1 <NEWLINE> height [ y - 1 ] += 1 <NEWLINE> <NL> <DEDENT> maxW = max ( width ) <NEWLINE> maxH = max ( height ) <NEWLINE> <NL> indexW = [ i for i , v in enumerate ( width ) if v == maxW ] <NEWLINE> indexH = [ i for i , v in enumerate ( height ) if v == maxH ] <NEWLINE> <NL> ans = maxW + maxH <NEWLINE> <NL> <COMMENT> <NL> tmpX = indexW [ 0 ] <NEWLINE> tmpY = indexH [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> flag = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> for x in indexW : <NEWLINE> <INDENT> y = tmpY <NEWLINE> if not ( x , y ) in st : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for y in indexH : <NEWLINE> <INDENT> x = tmpX <NEWLINE> if not ( x , y ) in st : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import collections <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> XY = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> c = collections . Counter ( ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> xi , yi = XY [ i ] <NEWLINE> xj , yj = XY [ j ] <NEWLINE> c [ ( xi - xj , yi - yj ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - c . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = n <NEWLINE> ng = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] >= h [ b - 1 ] : <NEWLINE> <INDENT> ng [ b ] = 1 <NEWLINE> <DEDENT> if h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> ng [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - len ( ng ) ) <NEWLINE>
s = input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> <NL> l = [ 0 for i in range ( 2019 ) ] <NEWLINE> n = len ( s ) <NEWLINE> l [ 0 ] = 1 <NEWLINE> prev = 0 <NEWLINE> digit = 1 <NEWLINE> for c in s : <NEWLINE> <INDENT> t = ( int ( c ) * digit + prev ) % 2019 <NEWLINE> l [ t ] += 1 <NEWLINE> digit = ( digit * 10 ) % 2019 <NEWLINE> prev = t <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> res += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> count = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if min ( L [ i - 1 ] , L [ i + 1 ] ) < L [ i ] < max ( L [ i - 1 ] , L [ i + 1 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = X_list . copy ( ) <NEWLINE> <NL> tmp . sort ( ) <NEWLINE> a = tmp [ int ( N / 2 ) - 1 ] <NEWLINE> b = tmp [ int ( N / 2 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( X_list [ i ] <= a ) : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> a = sorted ( a ) <NEWLINE> b = sorted ( b ) <NEWLINE> c = sorted ( c ) <NEWLINE> <NL> <COMMENT> <NL> def lower_bound ( arr , x ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = len ( c ) <NEWLINE> for j in range ( 30 ) : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> <COMMENT> <NL> if x <= arr [ mid ] : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_count = lower_bound ( a , b [ i ] ) <NEWLINE> c_count = len ( c ) - lower_bound ( c , b [ i ] + 1 ) <NEWLINE> count += a_count * c_count <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ism ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def isl ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = ii ( ) <NEWLINE> l = [ 0 ] <NEWLINE> i = 0 <NEWLINE> num = 0 <NEWLINE> while num < 10 ** 15 : <NEWLINE> <INDENT> i += 1 <NEWLINE> num = i ** 5 <NEWLINE> l . append ( num ) <NEWLINE> <COMMENT> <NL> <DEDENT> l = set ( l ) <NEWLINE> for item in l : <NEWLINE> <INDENT> if item > x : <NEWLINE> <INDENT> if item - x in l : <NEWLINE> <INDENT> print ( int ( item ** 0.2 ) , int ( ( item - x ) ** 0.2 ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x - item in l : <NEWLINE> <INDENT> print ( int ( item ** 0.2 ) , int ( ( x - item ) ** 0.2 ) * ( - 1 ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE>
import zlib , base64 <NEWLINE> exec ( zlib . decompress ( base64 . b85decode ( <STRING> ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> def sqroot ( n ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> x = ( x + n / x ) / 2 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> x1 , y1 , x2 , y2 = input ( ) . split ( ) <NEWLINE> x1 = float ( x1 ) <NEWLINE> x2 = float ( x2 ) <NEWLINE> y1 = float ( y1 ) <NEWLINE> y2 = float ( y2 ) <NEWLINE> <NL> distance = sqroot ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) <NEWLINE> <NL> print ( <STRING> % distance ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> S = input ( ) <NEWLINE> s = deque ( S ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> reverse = False <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> T = input ( ) . split ( ) <NEWLINE> if T [ 0 ] == <STRING> : <NEWLINE> <INDENT> if reverse : <NEWLINE> <INDENT> reverse = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> reverse = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ 1 ] == <STRING> and not reverse : <NEWLINE> <INDENT> s . appendleft ( T [ 2 ] ) <NEWLINE> <DEDENT> elif T [ 1 ] == <STRING> and reverse : <NEWLINE> <INDENT> s . append ( T [ 2 ] ) <NEWLINE> <DEDENT> elif T [ 1 ] == <STRING> and not reverse : <NEWLINE> <INDENT> s . append ( T [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . appendleft ( T [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if reverse : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) [ : : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dd = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dd [ i ] = [ ] <NEWLINE> <DEDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li_h = [ 0 ] <NEWLINE> li_h . extend ( temp ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> dd [ a ] . append ( b ) <NEWLINE> dd [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> d = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d [ i ] = True <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if not d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in dd [ i ] : <NEWLINE> <INDENT> if li_h [ k ] < li_h [ i ] : <NEWLINE> <INDENT> d [ k ] = False <NEWLINE> <DEDENT> elif li_h [ k ] == li_h [ i ] : <NEWLINE> <INDENT> d [ k ] = False <NEWLINE> d [ i ] = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if d [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> sum_com = 0 <NEWLINE> distinct_a = sorted ( list ( set ( a ) ) , reverse = True ) <NEWLINE> comfort = { i : 0 for i in distinct_a } <NEWLINE> comfort [ a [ 0 ] ] = 1 <NEWLINE> max_com = 0 <NEWLINE> <NL> for ai in a [ 1 : ] : <NEWLINE> <INDENT> sum_com += distinct_a [ max_com ] <NEWLINE> if distinct_a [ max_com ] == ai : <NEWLINE> <INDENT> comfort [ distinct_a [ max_com ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> comfort [ distinct_a [ max_com ] ] -= 1 <NEWLINE> comfort [ ai ] += 2 <NEWLINE> if comfort [ distinct_a [ max_com ] ] == 0 : <NEWLINE> <INDENT> max_com += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum_com ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> w = 0 <NEWLINE> r = c . count ( <STRING> ) <NEWLINE> i = 0 <NEWLINE> ans = max ( w , r ) <NEWLINE> while i <= n - 1 : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> ans = min ( ans , max ( w , r ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 10 ** N - ( ( 9 ** N ) * 2 - 8 ** N ) <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> X , N = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( lambda p : int ( p ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> Q = list ( map ( lambda p : [ p , abs ( X - p ) ] , P ) ) <NEWLINE> Q . sort ( key = lambda q : ( q [ 1 ] , q [ 0 ] ) ) <NEWLINE> <NL> cand = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 and Q [ 0 ] [ 1 ] != 0 : <NEWLINE> <INDENT> cand . append ( X ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Q [ i ] [ 1 ] != math . ceil ( i / 2 ) : <NEWLINE> <INDENT> cand . append ( X + math . ceil ( i / 2 ) ) <NEWLINE> cand . append ( X - math . ceil ( i / 2 ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( cand ) == 0 : <NEWLINE> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> cand . append ( X + int ( N / 2 ) ) <NEWLINE> cand . append ( X - int ( N / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand . append ( X + int ( ( N + 1 ) / 2 ) ) <NEWLINE> cand . append ( X - int ( ( N + 1 ) / 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( list ( filter ( lambda c : c not in P , cand ) ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def isRoot ( point , A , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == point or A [ i ] [ 2 ] == point : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def isBranch ( point , A , ans ) : <NEWLINE> <INDENT> if A [ point ] [ 1 ] != - 1 : <NEWLINE> <INDENT> ans . append ( A [ point ] [ 1 ] ) <NEWLINE> isBranch ( A [ point ] [ 1 ] , A , ans ) <NEWLINE> <DEDENT> if A [ point ] [ 2 ] != - 1 : <NEWLINE> <INDENT> ans . append ( A [ point ] [ 2 ] ) <NEWLINE> isBranch ( A [ point ] [ 2 ] , A , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> def isIn ( point , A , ans ) : <NEWLINE> <INDENT> if A [ point ] [ 1 ] != - 1 : <NEWLINE> <INDENT> isIn ( A [ point ] [ 1 ] , A , ans ) <NEWLINE> <DEDENT> ans . append ( point ) <NEWLINE> if A [ point ] [ 2 ] != - 1 : <NEWLINE> <INDENT> isIn ( A [ point ] [ 2 ] , A , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> def isPost ( point , A , ans ) : <NEWLINE> <INDENT> if A [ point ] [ 1 ] != - 1 : <NEWLINE> <INDENT> isPost ( A [ point ] [ 1 ] , A , ans ) <NEWLINE> <DEDENT> if A [ point ] [ 2 ] != - 1 : <NEWLINE> <INDENT> isPost ( A [ point ] [ 2 ] , A , ans ) <NEWLINE> <DEDENT> ans . append ( point ) <NEWLINE> <NL> <DEDENT> def Pre ( A , n ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if isRoot ( A [ i ] [ 0 ] , A , n ) == True : <NEWLINE> <INDENT> ans . append ( A [ i ] [ 0 ] ) <NEWLINE> if A [ i ] [ 1 ] != - 1 : <NEWLINE> <INDENT> ans . append ( A [ i ] [ 1 ] ) <NEWLINE> isBranch ( A [ i ] [ 1 ] , A , ans ) <NEWLINE> <DEDENT> if A [ i ] [ 2 ] != - 1 : <NEWLINE> <INDENT> ans . append ( A [ i ] [ 2 ] ) <NEWLINE> isBranch ( A [ i ] [ 2 ] , A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = str ( ans [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( ans ) ) <NEWLINE> <NL> <DEDENT> def In ( A , n ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if isRoot ( A [ i ] [ 0 ] , A , n ) == True : <NEWLINE> <INDENT> if A [ i ] [ 1 ] != - 1 : <NEWLINE> <INDENT> isIn ( A [ i ] [ 1 ] , A , ans ) <NEWLINE> <DEDENT> ans . append ( A [ i ] [ 0 ] ) <NEWLINE> if A [ i ] [ 2 ] != - 1 : <NEWLINE> <INDENT> isIn ( A [ i ] [ 2 ] , A , ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = str ( ans [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( ans ) ) <NEWLINE> <NL> <DEDENT> def Post ( A , n ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if isRoot ( A [ i ] [ 0 ] , A , n ) == True : <NEWLINE> <INDENT> if A [ i ] [ 1 ] != - 1 : <NEWLINE> <INDENT> isPost ( A [ i ] [ 1 ] , A , ans ) <NEWLINE> <DEDENT> if A [ i ] [ 2 ] != - 1 : <NEWLINE> <INDENT> isPost ( A [ i ] [ 2 ] , A , ans ) <NEWLINE> <DEDENT> ans . append ( A [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] = str ( ans [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( ans ) ) <NEWLINE> <NL> <DEDENT> def TW ( A , n ) : <NEWLINE> <INDENT> Pre ( A , n ) <NEWLINE> In ( A , n ) <NEWLINE> Post ( A , n ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if A [ j ] [ 0 ] < A [ minj ] [ 0 ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> A [ i ] , A [ minj ] = A [ minj ] , A [ i ] <NEWLINE> <DEDENT> TW ( A , n ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> point = [ 1 ] * N <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if ( A [ K + i ] > A [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> div = { } <NEWLINE> for i in range ( 61 ) : <NEWLINE> <INDENT> div [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = bin ( a [ i ] ) <NEWLINE> l = len ( b ) <NEWLINE> for j in range ( l - 2 ) : <NEWLINE> <INDENT> if b [ l - 1 - j ] == <STRING> : <NEWLINE> <INDENT> div [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in div . keys ( ) : <NEWLINE> <INDENT> ans += div [ k ] * ( n - div [ k ] ) * 2 ** k <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def even_line ( w ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for i in range ( 0 , w ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> def odd_line ( w ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for i in range ( 0 , w ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while ( h != 0 ) and ( w != 0 ) : <NEWLINE> <INDENT> for i in range ( 0 , h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> even_line ( w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd_line ( w ) <NEWLINE> <DEDENT> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> def main ( a ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for item in a : <NEWLINE> <INDENT> ans *= item <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = main ( a ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> exhaustive_dict = { } <NEWLINE> <NL> def create_exhastive_list ( head , sum ) : <NEWLINE> <INDENT> for i in range ( head , N ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> exhaustive_dict [ sum ] = 1 <NEWLINE> create_exhastive_list ( i + 1 , sum ) <NEWLINE> sum -= A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> head = 0 <NEWLINE> sum = 0 <NEWLINE> create_exhastive_list ( head , sum ) <NEWLINE> <NL> for target in M : <NEWLINE> <INDENT> if target in exhaustive_dict . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K2 = K <NEWLINE> count = 0 <NEWLINE> numa = 0 <NEWLINE> numb = 0 <NEWLINE> count2 = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> count += A [ i ] <NEWLINE> A [ i ] = count <NEWLINE> <COMMENT> <NL> <DEDENT> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( M + 1 ) : <NEWLINE> <INDENT> count += B [ i ] <NEWLINE> B [ i ] = count <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( N + 1 ) : <COMMENT> <NEWLINE> <INDENT> K = K2 <NEWLINE> if A [ i ] <= K : <NEWLINE> <INDENT> K -= A [ i ] <NEWLINE> if count2 < i + bisect . bisect_right ( B , K ) : <NEWLINE> <INDENT> count2 = i + bisect . bisect_right ( B , K ) - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count2 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> l = [ a [ i ] + i + 1 for i in range ( n ) ] <NEWLINE> r = [ i + 1 - a [ i ] for i in range ( n ) ] <NEWLINE> <NL> L = collections . Counter ( l ) <NEWLINE> R = collections . Counter ( r ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in L . keys ( ) : <NEWLINE> <INDENT> c += L . get ( i , 0 ) * R . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> CA = collections . Counter ( A ) <NEWLINE> minA = min ( A ) <NEWLINE> maxA = max ( A ) <NEWLINE> X = [ CA [ i ] for i in range ( minA , maxA + 1 ) ] <NEWLINE> if len ( X ) == 1 : <NEWLINE> <INDENT> print ( X [ 0 ] ) <NEWLINE> return 0 <NEWLINE> <DEDENT> if len ( X ) == 2 : <NEWLINE> <INDENT> print ( X [ 0 ] + X [ 1 ] ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> Y = [ X [ j ] + X [ j + 1 ] + X [ j + 2 ] for j in range ( len ( X ) - 2 ) ] <NEWLINE> print ( max ( Y ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a *= x [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> if 0 in x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> x_int = [ int ( i ) for i in x ] <NEWLINE> if x_int [ 0 ] == 0 and x_int [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_int . sort ( ) <NEWLINE> print ( <STRING> . format ( x_int [ 0 ] , x_int [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> v = c . values ( ) <NEWLINE> s = 0 <NEWLINE> for i in v : <NEWLINE> <INDENT> s += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d = c [ a [ i ] ] <NEWLINE> x = ( d * ( d - 1 ) ) // 2 if d > 1 else 0 <NEWLINE> y = ( ( d - 1 ) * ( d - 2 ) ) // 2 if d > 2 else 0 <NEWLINE> print ( s - x + y ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a [ i ] < a [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import copy <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> tall = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> bridge = copy . copy ( tall ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> c = [ int ( f ) - 1 for f in input ( ) . split ( ) ] <NEWLINE> a , b = c [ 0 ] , c [ 1 ] <NEWLINE> if bridge [ a ] < tall [ b ] : <NEWLINE> <INDENT> bridge [ a ] = tall [ b ] <NEWLINE> <DEDENT> elif bridge [ a ] == tall [ b ] : <NEWLINE> <INDENT> bridge [ a ] = 10 ** 10 <NEWLINE> <DEDENT> if bridge [ b ] < tall [ a ] : <NEWLINE> <INDENT> bridge [ b ] = tall [ a ] <NEWLINE> <DEDENT> elif bridge [ b ] == tall [ a ] : <NEWLINE> <INDENT> bridge [ b ] = 10 ** 10 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if tall [ j ] == bridge [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ary = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> aa , bb = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ary . append ( ( aa - 1 , bb - 1 ) ) <NEWLINE> <DEDENT> ary_s = list ( set ( ary ) ) <NEWLINE> a = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( len ( ary_s ) ) : <NEWLINE> <INDENT> a . append ( ary_s [ i ] [ 0 ] ) <NEWLINE> a . append ( ary_s [ i ] [ 1 ] ) <NEWLINE> uf . union ( ary_s [ i ] [ 0 ] , ary_s [ i ] [ 1 ] ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> prim_no = { 2 : True } <COMMENT> <NEWLINE> <NL> def is_prime ( no ) : <NEWLINE> <INDENT> if no == 2 or no == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if no % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if prim_no . get ( no ) is not None : <NEWLINE> <INDENT> return prim_no . get ( no ) <NEWLINE> <NL> <DEDENT> max_check = int ( math . sqrt ( no ) ) <NEWLINE> for i in range ( 3 , max_check + 1 , 2 ) : <NEWLINE> <INDENT> if no % i == 0 : <NEWLINE> <INDENT> prim_no [ no ] = False <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> prim_no [ no ] = True <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> prim_vals = { } <COMMENT> <NEWLINE> num_data = [ ] <COMMENT> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> num = sys . stdin . readline ( ) <NEWLINE> if num is None or num . strip ( ) == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> num = int ( num . strip ( ) ) <NEWLINE> num_data . append ( num ) <NEWLINE> <NL> <DEDENT> sorted_num_data = sorted ( num_data ) <NEWLINE> prim_num = { } <NEWLINE> <NL> for num in sorted_num_data : <NEWLINE> <INDENT> if prim_vals . get ( num ) is not None : <NEWLINE> <INDENT> cnt = prim_vals . get ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if num == 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> if num % 2 == 0 : <NEWLINE> <INDENT> start_num = num - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start_num = num <NEWLINE> <NL> <DEDENT> for i in range ( start_num , 0 , - 2 ) : <NEWLINE> <INDENT> if prim_vals . get ( i ) is not None : <NEWLINE> <INDENT> cnt += prim_vals . get ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if is_prime ( i ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> prim_vals [ num ] = cnt <COMMENT> <NEWLINE> <DEDENT> <DEDENT> prim_num [ num ] = cnt <NEWLINE> <NL> <DEDENT> for num in num_data : <NEWLINE> <INDENT> print ( prim_num [ num ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> MOD = 998244353 <NEWLINE> <NL> <NL> def solve ( n , d ) : <NEWLINE> <INDENT> if d [ 0 ] != 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> dc = Counter ( d ) <NEWLINE> if dc [ 0 ] > 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = 1 <NEWLINE> k = 1 <NEWLINE> dmax = max ( d ) <NEWLINE> while k <= dmax : <NEWLINE> <INDENT> res *= dc [ k - 1 ] ** dc [ k ] <NEWLINE> res %= MOD <NEWLINE> k += 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> print ( solve ( N , d ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 2 * 10 ** 5 ) <NEWLINE> I = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> N = I [ 0 ] <NEWLINE> AB = I [ 1 : ] <NEWLINE> G = collections . defaultdict ( set ) <NEWLINE> for a , b in zip ( AB [ : : 2 ] , AB [ 1 : : 2 ] ) : <NEWLINE> <INDENT> G [ a ] . add ( b ) <NEWLINE> G [ b ] . add ( a ) <NEWLINE> <DEDENT> color = [ None ] * ( N + 1 ) <NEWLINE> <NL> <NL> def dfs ( G , v , cur ) : <NEWLINE> <INDENT> color [ v ] = cur <NEWLINE> for w in G [ v ] : <NEWLINE> <INDENT> if color [ w ] is None : <NEWLINE> <INDENT> dfs ( G , w , 1 - cur ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( G , 1 , 0 ) <NEWLINE> c = collections . Counter ( color [ 1 : ] ) <NEWLINE> cand1 = set ( range ( 1 , N + 1 , 3 ) ) <NEWLINE> cand2 = set ( range ( 2 , N + 1 , 3 ) ) <NEWLINE> cand3 = set ( range ( 3 , N + 1 , 3 ) ) <NEWLINE> <NL> i0 , i1 = 0 , 1 <NEWLINE> if c [ 0 ] > c [ 1 ] : <NEWLINE> <INDENT> i0 , i1 = 1 , 0 <NEWLINE> <NL> <DEDENT> ans = [ None ] * ( N + 1 ) <NEWLINE> if c [ i0 ] <= len ( cand3 ) : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if color [ i ] == i0 : <NEWLINE> <INDENT> ans [ i ] = cand3 . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cand1 : <NEWLINE> <INDENT> ans [ i ] = cand1 . pop ( ) <NEWLINE> <DEDENT> elif cand2 : <NEWLINE> <INDENT> ans [ i ] = cand2 . pop ( ) <NEWLINE> <DEDENT> elif cand3 : <NEWLINE> <INDENT> ans [ i ] = cand3 . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if color [ i ] == i0 : <NEWLINE> <INDENT> if cand2 : <NEWLINE> <INDENT> ans [ i ] = cand2 . pop ( ) <NEWLINE> <DEDENT> elif cand3 : <NEWLINE> <INDENT> ans [ i ] = cand3 . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if cand1 : <NEWLINE> <INDENT> ans [ i ] = cand1 . pop ( ) <NEWLINE> <DEDENT> elif cand3 : <NEWLINE> <INDENT> ans [ i ] = cand3 . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> nr = s . count ( <STRING> ) <NEWLINE> ng = s . count ( <STRING> ) <NEWLINE> nb = s . count ( <STRING> ) <NEWLINE> ans = nr * ng * nb <NEWLINE> for i in range ( 1 , 1 + ( n - 1 ) // 2 ) : <NEWLINE> <INDENT> for j in range ( n - 2 * i ) : <NEWLINE> <INDENT> if s [ j ] != s [ j + i ] and s [ j ] != s [ 2 * i + j ] and s [ j + i ] != s [ j + 2 * i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect_left <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> to = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> to [ u ] . append ( v ) <NEWLINE> to [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> dp = [ ] <NEWLINE> def dfs ( now , pre ) : <NEWLINE> <INDENT> a = A [ now ] <NEWLINE> idx = bisect_left ( dp , a ) <NEWLINE> <NL> if idx == len ( dp ) : <NEWLINE> <INDENT> old = - 1 <NEWLINE> dp . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> old = dp [ idx ] <NEWLINE> dp [ idx ] = a <NEWLINE> <NL> <DEDENT> ans [ now ] = len ( dp ) <NEWLINE> <NL> <NL> for nv in to [ now ] : <NEWLINE> <INDENT> if nv != pre : <NEWLINE> <INDENT> dfs ( nv , now ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if old == - 1 : <NEWLINE> <INDENT> dp . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ idx ] = old <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> <NL> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( <NEWLINE> <INDENT> math . pow ( r , 2 ) * math . pi , <NEWLINE> r * 2 * math . pi <NEWLINE> <DEDENT> ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> from typing import List <NEWLINE> <NL> <COMMENT> <NL> from typing import Tuple <NEWLINE> from typing import Set <NEWLINE> <NL> <COMMENT> <NL> <NL> Cod = Tuple [ int , int ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> args = input ( ) . split ( ) <NEWLINE> H = int ( args [ 0 ] ) <NEWLINE> W = int ( args [ 1 ] ) <NEWLINE> M = int ( args [ 2 ] ) <NEWLINE> <NL> codList = { } <NEWLINE> columnSumList : List [ int ] = [ 0 ] * W <NEWLINE> rowSumList : List [ int ] = [ 0 ] * H <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> item = ( h , w ) <NEWLINE> codList . setdefault ( h , { } ) <NEWLINE> codList [ h ] [ w ] = item <NEWLINE> columnSumList [ w - 1 ] += 1 <NEWLINE> rowSumList [ h - 1 ] += 1 <NEWLINE> <NL> <DEDENT> maxColumnSum = max ( columnSumList ) <NEWLINE> maxColumIndexList = [ i for i , x in enumerate ( columnSumList ) if x == maxColumnSum ] <NEWLINE> maxRowSum = max ( rowSumList ) <NEWLINE> maxRowIndexList = [ i for i , x in enumerate ( rowSumList ) if x == maxRowSum ] <NEWLINE> <NL> result = maxColumnSum + maxRowSum <NEWLINE> for row in maxRowIndexList : <NEWLINE> <INDENT> for column in maxColumIndexList : <NEWLINE> <INDENT> if row + 1 in codList and column + 1 in codList [ row + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> lim = 2510 <NEWLINE> di = [ [ float ( <STRING> ) ] * lim for _ in range ( n ) ] <NEWLINE> di [ 0 ] [ min ( s , lim - 1 ) ] = 0 <NEWLINE> con = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> con [ u - 1 ] . append ( ( v - 1 , a , b ) ) <NEWLINE> con [ v - 1 ] . append ( ( u - 1 , a , b ) ) <NEWLINE> <DEDENT> q = [ ( 0 , min ( s , lim - 1 ) , 0 ) ] <NEWLINE> cd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> while q : <NEWLINE> <INDENT> time , have , cur = heappop ( q ) <NEWLINE> if di [ cur ] [ have ] < time : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c , d = cd [ cur ] <NEWLINE> if have + c < lim and di [ cur ] [ have + c ] > time + d : <NEWLINE> <INDENT> di [ cur ] [ have + c ] = time + d <NEWLINE> heappush ( q , ( time + d , have + c , cur ) ) <NEWLINE> <DEDENT> for nxt , dh , dt in con [ cur ] : <NEWLINE> <INDENT> if have >= dh and di [ nxt ] [ have - dh ] > time + dt : <NEWLINE> <INDENT> di [ nxt ] [ have - dh ] = time + dt <NEWLINE> heappush ( q , ( time + dt , have - dh , nxt ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for p in di [ 1 : ] : <NEWLINE> <INDENT> print ( min ( p ) ) <NEWLINE> <DEDENT>
def getInts ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> [ N ] = getInts ( ) <NEWLINE> As = getInts ( ) <NEWLINE> A = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A [ i ] = As [ i - 1 ] <NEWLINE> <NL> <DEDENT> L = { } <NEWLINE> R = { } <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i - A [ i ] not in L : <NEWLINE> <INDENT> L [ i - A [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i - A [ i ] ] += 1 <NEWLINE> <DEDENT> if i + A [ i ] not in R : <NEWLINE> <INDENT> R [ i + A [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R [ i + A [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for k in R . keys ( ) : <NEWLINE> <INDENT> if k in L : <NEWLINE> <INDENT> count += R [ k ] * L [ k ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
class BinaryTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . key = None <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( z ) : <NEWLINE> <INDENT> global root <NEWLINE> y = None <NEWLINE> x = root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y == None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def inoder ( x ) : <NEWLINE> <INDENT> if x == None : return [ ] <NEWLINE> else : <NEWLINE> <INDENT> r = [ ] <NEWLINE> r . extend ( inoder ( x . left ) ) <NEWLINE> r . append ( str ( x . key ) ) <NEWLINE> r . extend ( inoder ( x . right ) ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def preoder ( x ) : <NEWLINE> <INDENT> if x == None : return [ ] <NEWLINE> else : <NEWLINE> <INDENT> r = [ ] <NEWLINE> r . append ( str ( x . key ) ) <NEWLINE> r . extend ( preoder ( x . left ) ) <NEWLINE> r . extend ( preoder ( x . right ) ) <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def show ( x ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( inoder ( x ) ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( preoder ( x ) ) ) <NEWLINE> <NL> <NL> <DEDENT> root = None <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L = input ( ) . split ( ) <NEWLINE> if L [ 0 ] == <STRING> : <NEWLINE> <INDENT> T = BinaryTree ( ) <NEWLINE> T . key = int ( L [ 1 ] ) <NEWLINE> insert ( T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> show ( root ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> from collections import deque <NEWLINE> import numpy as np <NEWLINE> class edge ( object ) : <NEWLINE> <INDENT> def __init__ ( self , to , rev ) : <NEWLINE> <INDENT> self . to = to <NEWLINE> self . rev = rev <NEWLINE> <DEDENT> <DEDENT> def add_edge ( from_ , to_ , G ) : <NEWLINE> <INDENT> G [ from_ ] . append ( edge ( to_ , len ( G [ to_ ] ) ) ) <NEWLINE> G [ to_ ] . append ( edge ( from_ , len ( G [ from_ ] ) - 1 ) ) <NEWLINE> <NL> <DEDENT> def bfs ( src , level , li , li_from ) : <NEWLINE> <INDENT> que = deque ( [ src ] ) <NEWLINE> level [ src ] = 0 <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> for i in range ( len ( li [ v ] ) ) : <NEWLINE> <INDENT> e = li [ v ] [ i ] <NEWLINE> if level [ e . to ] < 0 : <NEWLINE> <INDENT> level [ e . to ] = level [ v ] + 1 <NEWLINE> li_from [ e . to ] = v <NEWLINE> que . append ( e . to ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li . append ( [ ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> add_edge ( a - 1 , b - 1 , li ) <NEWLINE> <NL> <NL> <DEDENT> if len ( li [ 0 ] ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> level = np . full ( n , - 1 , dtype = np . int ) <NEWLINE> li_from = np . full ( n , - 1 , dtype = np . int ) <NEWLINE> bfs ( 0 , level , li , li_from ) <NEWLINE> for i in li_from : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( ( 1 + N ) * ( N // 2 ) - N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( 1 + N - 1 ) * ( N // 2 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def shellSort ( data , cnt , g , n ) : <NEWLINE> <INDENT> for idx in range ( g , n ) : <NEWLINE> <INDENT> j = idx - g <NEWLINE> v = data [ idx ] <NEWLINE> while j >= 0 and data [ j ] > v : <NEWLINE> <INDENT> data [ j + g ] = data [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> data [ j + g ] = v <NEWLINE> <DEDENT> return data , cnt <NEWLINE> <NL> <DEDENT> n , gap = int ( input ( ) ) , [ ] <NEWLINE> a = ( [ int ( i ) for i in sys . stdin . readlines ( ) ] , 0 ) <NEWLINE> g = 0 <NEWLINE> while g <= n // 9 : <NEWLINE> <INDENT> g = 3 * g + 1 <NEWLINE> gap . append ( g ) <NEWLINE> <DEDENT> m = len ( gap ) <NEWLINE> for i in gap [ : : - 1 ] : <NEWLINE> <INDENT> a = shellSort ( a [ 0 ] , a [ 1 ] , i , n ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , gap [ : : - 1 ] ) ) ) <NEWLINE> print ( a [ 1 ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ 0 ] [ i ] ) <NEWLINE> <NL> <DEDENT>
r = float ( input ( ) ) <NEWLINE> pi = 3.14159265359 <NEWLINE> print ( <STRING> . format ( pi * r ** 2 ) , <STRING> . format ( 2 * pi * r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lis = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> lis . append ( s ) <NEWLINE> <DEDENT> lis = set ( lis ) <NEWLINE> print ( len ( lis ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 2 * 2 * 10 ** 5 ) <NEWLINE> <NL> def dfs ( i , p , edges , num ) : <NEWLINE> <NL> <INDENT> for j in edges [ i ] : <NEWLINE> <INDENT> if ( j != p ) : <NEWLINE> <NL> <INDENT> num [ j ] += num [ i ] <NEWLINE> <NL> dfs ( j , i , edges , num ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> edges = [ [ ] for i in range ( N ) ] <NEWLINE> num = [ 0 ] * N <NEWLINE> <NL> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a0 , b0 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges [ a0 - 1 ] . append ( b0 - 1 ) <NEWLINE> edges [ b0 - 1 ] . append ( a0 - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> p0 , x0 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num [ p0 - 1 ] += x0 <NEWLINE> <NL> <DEDENT> dfs ( 0 , - 1 , edges , num ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( num [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> a = int ( stdin . readline ( ) ) <NEWLINE> A = stdin . readline ( ) . split ( ) <NEWLINE> <NL> product = 1 <NEWLINE> K = 0 <NEWLINE> <NL> for k in range ( 0 , a ) : <NEWLINE> <INDENT> if int ( A [ k ] ) == 0 : <NEWLINE> <INDENT> product = 0 <NEWLINE> K = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if K == 0 : <NEWLINE> <INDENT> for b in range ( 0 , a ) : <NEWLINE> <INDENT> product = product * int ( A [ b ] ) <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> product = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( product ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> visited = { 1 , } <NEWLINE> old = 1 <NEWLINE> count = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> new = a [ old - 1 ] <NEWLINE> count += 1 <NEWLINE> if new in visited : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if new == 2 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> old = new <NEWLINE> visited . add ( new ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def dist ( p1 , p2 ) : <NEWLINE> <INDENT> return math . sqrt ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 ) <NEWLINE> <NL> <DEDENT> def intersection ( o1 , o2 ) : <NEWLINE> <INDENT> if dist ( o1 , o2 ) > 2 : <NEWLINE> <INDENT> p1 , p2 = [ None , None ] , [ None , None ] <NEWLINE> <DEDENT> elif dist ( o1 , o2 ) == 2 : <NEWLINE> <INDENT> p1 , p2 = [ ( o1 [ 0 ] + o2 [ 0 ] ) / 2 , ( o1 [ 1 ] + o2 [ 1 ] ) / 2 ] , [ None , None ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = [ ( o1 [ 0 ] + o2 [ 0 ] ) / 2 , ( o1 [ 1 ] + o2 [ 1 ] ) / 2 ] <NEWLINE> v = [ m [ 0 ] - o1 [ 0 ] , m [ 1 ] - o1 [ 1 ] ] <NEWLINE> v_abs = dist ( v , [ 0 , 0 ] ) <NEWLINE> w = [ v [ 1 ] , - v [ 0 ] ] <NEWLINE> w_abs = dist ( w , [ 0 , 0 ] ) <NEWLINE> n = [ w [ 0 ] / w_abs , w [ 1 ] / w_abs ] <NEWLINE> l = math . sqrt ( 1 - v_abs ** 2 ) <NEWLINE> p1 = [ m [ 0 ] + l * n [ 0 ] , m [ 1 ] + l * n [ 1 ] ] <NEWLINE> p2 = [ m [ 0 ] - l * n [ 0 ] , m [ 1 ] - l * n [ 1 ] ] <NEWLINE> <DEDENT> return p1 , p2 <NEWLINE> <DEDENT> err = 1.0e-6 <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p . append ( list ( map ( float , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> p1 , p2 = intersection ( p [ i ] , p [ j ] ) <NEWLINE> cnt1 = 0 <NEWLINE> cnt2 = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if p1 [ 0 ] and dist ( p1 , p [ k ] ) <= 1 + err : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <DEDENT> if p2 [ 0 ] and dist ( p2 , p [ k ] ) <= 1 + err : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( [ ans , cnt1 , cnt2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> M = 10 ** 6 + 1 <NEWLINE> L = [ 0 ] * M <NEWLINE> for a in A : <NEWLINE> <INDENT> L [ a ] += 1 <NEWLINE> if L [ a ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( 2 * a , M , a ) : <NEWLINE> <INDENT> L [ i ] += 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( L . count ( 1 ) ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> YES = <STRING> <NEWLINE> NO = <STRING> <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , value , p = None , l = None , r = None ) : <NEWLINE> <INDENT> self . key = value <NEWLINE> self . p = p <NEWLINE> self . left = l <NEWLINE> self . right = r <NEWLINE> <NL> <DEDENT> <DEDENT> def chgchild ( parent , old , new = None ) : <NEWLINE> <INDENT> if parent == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if parent . left == old : <NEWLINE> <INDENT> parent . left = new <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent . right = new <NEWLINE> <DEDENT> if new != None : <NEWLINE> <INDENT> new . p = parent <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def delete ( node ) : <NEWLINE> <INDENT> if node == None : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> if node . left == None : <NEWLINE> <INDENT> chgchild ( node . p , node , node . right ) <NEWLINE> <DEDENT> elif node . right == None : <NEWLINE> <INDENT> chgchild ( node . p , node , node . left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ino = [ ] <NEWLINE> inorder ( node , ino ) <NEWLINE> next = 0 <NEWLINE> for i in range ( len ( ino ) ) : <NEWLINE> <INDENT> if ino [ i ] . key == node . key : <NEWLINE> <INDENT> next = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> node . key = ino [ next ] . key <NEWLINE> delete ( ino [ next ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getroot ( x ) : <NEWLINE> <INDENT> if x . p != None : <NEWLINE> <INDENT> return getroot ( x . p ) <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def keylist ( A ) : <NEWLINE> <INDENT> B = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> B . append ( i . key ) <NEWLINE> <DEDENT> return B <NEWLINE> <NL> <DEDENT> def preorder ( x , A ) : <NEWLINE> <INDENT> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> A . append ( x ) <NEWLINE> preorder ( x . left , A ) <NEWLINE> preorder ( x . right , A ) <NEWLINE> <NL> <DEDENT> def inorder ( x , A ) : <NEWLINE> <INDENT> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( x . left , A ) <NEWLINE> A . append ( x ) <NEWLINE> inorder ( x . right , A ) <NEWLINE> <NL> <DEDENT> def postorder ( x , A ) : <NEWLINE> <INDENT> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> postorder ( x . left , A ) <NEWLINE> postorder ( x . right , A ) <NEWLINE> A . append ( x ) <NEWLINE> <NL> <DEDENT> def ptree ( root ) : <NEWLINE> <INDENT> pre = [ ] <NEWLINE> ino = [ ] <NEWLINE> preorder ( root , pre ) <NEWLINE> inorder ( root , ino ) <NEWLINE> ap = keylist ( pre ) <NEWLINE> ip = keylist ( ino ) <NEWLINE> print ( <STRING> . format ( <STRING> . join ( map ( str , ip ) ) ) ) <NEWLINE> print ( <STRING> . format ( <STRING> . join ( map ( str , ap ) ) ) ) <NEWLINE> <NL> <DEDENT> def find ( value , root ) : <NEWLINE> <INDENT> if root == None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif value < root . key : <NEWLINE> <INDENT> return find ( value , root . left ) <NEWLINE> <DEDENT> elif value > root . key : <NEWLINE> <INDENT> return find ( value , root . right ) <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def insert ( root , z ) : <NEWLINE> <INDENT> y = None <COMMENT> <NEWLINE> x = root <COMMENT> <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <COMMENT> <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <COMMENT> <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y == None : <COMMENT> <NEWLINE> <INDENT> return z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <COMMENT> <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> <STRING> <NEWLINE> num = int ( input ( ) . strip ( ) ) <NEWLINE> istr = sys . stdin . read ( ) <NEWLINE> cmds = list ( istr . splitlines ( ) ) <NEWLINE> root = None <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> cmd = cmds [ i ] [ 0 ] <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> n = Node ( int ( cmds [ i ] [ 7 : ] ) ) <NEWLINE> root = insert ( root , n ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> if find ( int ( cmds [ i ] [ 5 : ] ) , root ) == None : <NEWLINE> <INDENT> print ( NO ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( YES ) <NEWLINE> <DEDENT> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> ptree ( root ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> node = find ( int ( cmds [ i ] [ 7 : ] ) , root ) <NEWLINE> delete ( node ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Dictionary = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S not in Dictionary : <NEWLINE> <INDENT> Dictionary [ S ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Dictionary [ S ] = Dictionary [ S ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sorted_Dic = sorted ( Dictionary . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> if len ( sorted_Dic ) == 1 : <NEWLINE> <INDENT> print ( sorted_Dic [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if sorted_Dic [ i ] [ 1 ] == sorted_Dic [ 0 ] [ 1 ] : <NEWLINE> <INDENT> ans_list . append ( sorted_Dic [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> <DEDENT> for item in sorted ( ans_list ) : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> List1 = [ i + A [ i ] for i in range ( N ) ] <NEWLINE> List2 = [ i - A [ i ] for i in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> CList1 = Counter ( List1 ) <NEWLINE> CList2 = Counter ( List2 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += CList1 [ i ] * CList2 [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def map_int_input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) ) <NEWLINE> <NL> <DEDENT> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def MII_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) ) <NEWLINE> <NL> <DEDENT> def MII_split_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def list_int_inputs ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <DEDENT> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def LII_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> def LII_split_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> import math <NEWLINE> def L ( x , y , z ) : <NEWLINE> <INDENT> return int ( x * x + y * y + z * z + x * y + y * z + z * x ) <NEWLINE> <NL> <DEDENT> N = input_int ( ) <NEWLINE> <COMMENT> <NL> <NL> ans = [ 0 for _ in range ( N ) ] <NEWLINE> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> f = L ( x , y , z ) <NEWLINE> <NL> if f <= N : <NEWLINE> <INDENT> ans [ f - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = True <NEWLINE> k = 0 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> b = x - k <NEWLINE> c = x + k <NEWLINE> if ( not ( b in a ) ) : <NEWLINE> <INDENT> print ( b ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> elif ( not ( c in a ) and flag ) : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> k = k + 1 <NEWLINE> <DEDENT>
S = list ( reversed ( input ( ) ) ) <NEWLINE> <NL> length = len ( S ) <NEWLINE> <NL> a = [ 0 ] * length <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> pickup = int ( S [ i ] ) <NEWLINE> a [ i ] = pickup * pow ( 10 , i , 2019 ) <NEWLINE> <NL> <DEDENT> b = [ 0 ] * ( length + 1 ) <NEWLINE> for i in range ( 1 , length + 1 ) : <NEWLINE> <INDENT> b [ i ] = ( b [ i - 1 ] + a [ i - 1 ] ) % 2019 <NEWLINE> <DEDENT> cnt , ans = [ 0 ] * 2019 , 0 <NEWLINE> for x in b : <NEWLINE> <INDENT> ans += cnt [ x ] <NEWLINE> cnt [ x ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> m = sorted ( list ( set ( a ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> <NL> t = [ max ( a ) ] * n <NEWLINE> <NL> if c [ max ( a ) ] == 1 : <NEWLINE> <INDENT> t [ a . index ( max ( a ) ) ] = m [ - 2 ] <NEWLINE> <NL> <DEDENT> [ print ( i ) for i in t ] <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> findCount = 0 <NEWLINE> <NL> for t in T : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> center = right // 2 <NEWLINE> preCenter = 0 <NEWLINE> while left < right : <NEWLINE> <INDENT> if S [ center ] == t : <NEWLINE> <INDENT> findCount += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if S [ center ] > t : <NEWLINE> <INDENT> right = center <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = center + 1 <NEWLINE> <NL> <DEDENT> center = ( left + right ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( findCount ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> c_list = list ( itertools . combinations_with_replacement ( l , 3 ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for l in c_list : <NEWLINE> <INDENT> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> c = l [ 2 ] <NEWLINE> if a == b == c : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> d = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 6 <NEWLINE> <DEDENT> cnt += gcd ( a , b , c ) * d <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> d = sorted ( list ( S ) ) <NEWLINE> x = set ( d ) <NEWLINE> for c in d : <NEWLINE> <INDENT> left = S . index ( c ) <NEWLINE> while left < len ( S ) : <NEWLINE> <INDENT> if S [ left ] != c : <NEWLINE> <INDENT> left += 1 <NEWLINE> continue <NEWLINE> <DEDENT> j = 2 <NEWLINE> while j <= K : <NEWLINE> <INDENT> x . add ( S [ left : left + j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> left += 1 <NEWLINE> <DEDENT> if len ( x ) >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> x = sorted ( list ( x ) ) <NEWLINE> print ( x [ K - 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> G = [ [ 0 ] * K for i in range ( K ) ] <NEWLINE> x = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> g1 = gcd ( i + 1 , j + 1 ) <NEWLINE> G [ i ] [ j ] = g1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> g1 = G [ i ] [ j ] <NEWLINE> <COMMENT> <NL> x = x + G [ g1 - 1 ] [ k ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( x ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> ans = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> if p [ i ] == i + 1 : <NEWLINE> <INDENT> if ( i + 1 < N ) and ( p [ i + 1 ] == i + 2 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> class Graph : <NEWLINE> <INDENT> def __init__ ( self , n , is_directed = False ) : <NEWLINE> <INDENT> self . graph = [ [ ] for _ in range ( n ) ] <NEWLINE> self . is_directed = is_directed <NEWLINE> <NL> <DEDENT> def add_edge ( self , u , v ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . graph [ u ] . append ( v ) <NEWLINE> if not self . is_directed : <NEWLINE> <INDENT> self . graph [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bfs ( self , start ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> distances = [ INF ] * len ( self . graph ) <NEWLINE> queue = deque ( [ start ] ) <NEWLINE> distances [ start ] = 0 <NEWLINE> ans = [ 0 ] * len ( self . graph ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> for to in self . graph [ now ] : <NEWLINE> <INDENT> if distances [ to ] != INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> queue . append ( to ) <NEWLINE> ans [ to ] = now <NEWLINE> distances [ to ] = distances [ now ] + 1 <NEWLINE> <DEDENT> <DEDENT> return distances , ans <NEWLINE> <NL> <DEDENT> def dfs ( self , start ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> distances = [ INF ] * len ( self . graph ) <NEWLINE> queue = deque ( [ start ] ) <NEWLINE> distances [ start ] = 0 <NEWLINE> ans = [ 0 ] * len ( self . graph ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> now = queue . pop ( ) <NEWLINE> for to in self . graph [ now ] : <NEWLINE> <INDENT> if distances [ to ] != INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> queue . append ( to ) <NEWLINE> <COMMENT> <NL> ans [ to ] = now <NEWLINE> distances [ to ] = distances [ now ] + 1 <NEWLINE> <DEDENT> <DEDENT> return distances , ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = LI ( ) <NEWLINE> g = Graph ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = LI ( ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> g . add_edge ( a , b ) <NEWLINE> <NL> <DEDENT> bfs_res , ans = g . bfs ( 0 ) <NEWLINE> for d in bfs_res : <NEWLINE> <INDENT> if d == INF : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * map ( lambda x : x + 1 , ans [ 1 : ] ) , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> L . sort ( ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> count += k - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> coriddorList = [ set ( ) for i in range ( n + 1 ) ] <NEWLINE> deepList = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> <NL> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> coriddorList [ a ] . add ( b ) <NEWLINE> coriddorList [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> checkList = [ 0 ] * ( n + 1 ) <NEWLINE> ansList = [ 0 ] * ( n + 1 ) <NEWLINE> checkList [ 1 ] = 1 <NEWLINE> q = collections . deque ( ) <NEWLINE> q . appendleft ( 1 ) <NEWLINE> <NL> while len ( q ) > 0 : <NEWLINE> <INDENT> value = q . pop ( ) <NEWLINE> for k in coriddorList [ value ] : <NEWLINE> <INDENT> if checkList [ k ] == 0 : <NEWLINE> <INDENT> checkList [ k ] = 1 <NEWLINE> ansList [ k ] = value <NEWLINE> q . appendleft ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ansList [ i ] ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> L = list ( S ) <NEWLINE> L = set ( L ) <NEWLINE> if N != 26 : <COMMENT> <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> temp = chr ( i + 97 ) <NEWLINE> if temp not in L : <NEWLINE> <INDENT> ans = S + temp <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> M = [ ] <NEWLINE> All = [ chr ( 97 + i ) for i in range ( 26 ) ] <NEWLINE> <COMMENT> <NL> for i in range ( 25 ) : <NEWLINE> <INDENT> now = 25 - i <NEWLINE> M . append ( S [ now ] ) <NEWLINE> if S [ now ] > S [ now - 1 ] : <NEWLINE> <INDENT> M . sort ( ) <NEWLINE> for x in M : <NEWLINE> <INDENT> if x > S [ now - 1 ] : <NEWLINE> <INDENT> temp = x <NEWLINE> ans = S [ : now - 1 ] + temp <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> count2 = 0 <NEWLINE> <NL> al = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> <NL> thresh = [ 26 ** i for i in range ( 1 , 12 ) ] <NEWLINE> for i in range ( 1 , len ( thresh ) ) : <NEWLINE> <INDENT> thresh [ i ] = thresh [ i ] + thresh [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( thresh ) ) : <NEWLINE> <INDENT> if thresh [ i ] < N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> char_num = i + 1 <COMMENT> <NEWLINE> name_str = [ <STRING> for i in range ( char_num ) ] <NEWLINE> if char_num > 1 : <NEWLINE> <INDENT> count = N - thresh [ i - 1 ] <COMMENT> <NEWLINE> <COMMENT> <NL> for i in range ( char_num ) : <NEWLINE> <INDENT> count2 = int ( ( count - 1 ) / ( 26 ** ( char_num - i - 1 ) ) ) <NEWLINE> if ( count2 > 0 ) & ( i != ( char_num - 1 ) ) : <NEWLINE> <INDENT> if count2 <= 25 : <NEWLINE> <INDENT> name_str [ i ] = al [ count2 ] <NEWLINE> count = count - ( ( 26 ** ( char_num - i - 1 ) ) * count2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> name_str [ i ] = al [ count2 - 1 ] <NEWLINE> count = count - ( ( 26 ** ( char_num - i - 1 ) ) * count2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = N <NEWLINE> <DEDENT> if count > 0 : <NEWLINE> <INDENT> name_str [ - 1 ] = al [ count - 1 ] <NEWLINE> <DEDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> out = <STRING> <NEWLINE> for i in name_str : <NEWLINE> <INDENT> out = out + i <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_ints2 ( x ) : return map ( lambda num : int ( num ) - x , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def GCD ( a : int , b : int ) -> int : return b if a % b == 0 else GCD ( b , a % b ) <NEWLINE> def LCM ( a : int , b : int ) -> int : return ( a * b ) // GCD ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> def sa_native ( s : list ) : <NEWLINE> <INDENT> from functools import cmp_to_key <NEWLINE> def mycmp ( r , l ) : <NEWLINE> <INDENT> if l == r : return - 1 <NEWLINE> while l < n and r < n : <NEWLINE> <INDENT> if s [ l ] != s [ r ] : return 1 if s [ l ] < s [ r ] else - 1 <NEWLINE> l += 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> return 1 if l == n else - 1 <NEWLINE> <DEDENT> n = len ( s ) <NEWLINE> sa = [ i for i in range ( n ) ] <NEWLINE> sa . sort ( key = cmp_to_key ( mycmp ) ) <NEWLINE> return sa <NEWLINE> <NL> <DEDENT> def sa_doubling ( s : list ) : <NEWLINE> <INDENT> from functools import cmp_to_key <NEWLINE> def mycmp ( y , x ) : <NEWLINE> <INDENT> if rnk [ x ] != rnk [ y ] : return 1 if rnk [ x ] < rnk [ y ] else - 1 <NEWLINE> rx = rnk [ x + k ] if x + k < n else - 1 <NEWLINE> ry = rnk [ y + k ] if y + k < n else - 1 <NEWLINE> return 1 if rx < ry else - 1 <NEWLINE> <NL> <DEDENT> n = len ( s ) <NEWLINE> sa = [ i for i in range ( n ) ] ; rnk = s ; tmp = [ 0 ] * n ; k = 1 <NEWLINE> while k < n : <NEWLINE> <INDENT> sa . sort ( key = cmp_to_key ( mycmp ) ) <NEWLINE> tmp [ sa [ 0 ] ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp [ sa [ i ] ] = tmp [ sa [ i - 1 ] ] <NEWLINE> if mycmp ( sa [ i ] , sa [ i - 1 ] ) == 1 : tmp [ sa [ i ] ] += 1 <NEWLINE> <DEDENT> tmp , rnk = rnk , tmp <NEWLINE> k *= 2 <NEWLINE> <DEDENT> return sa <NEWLINE> <NL> <DEDENT> def sa_is ( s : list , upper : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> THRESHOLD_NATIVE = 10 <NEWLINE> THRESHOLD_DOUBLING = 40 <NEWLINE> n = len ( s ) <NEWLINE> if n == 0 : return [ ] <NEWLINE> if n == 1 : return [ 0 ] <NEWLINE> if n == 2 : <NEWLINE> <INDENT> if s [ 0 ] < s [ 1 ] : <NEWLINE> <INDENT> return [ 0 , 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ 1 , 0 ] <NEWLINE> <DEDENT> <DEDENT> if n < THRESHOLD_NATIVE : <NEWLINE> <INDENT> return sa_native ( s ) <NEWLINE> <DEDENT> if n < THRESHOLD_DOUBLING : <NEWLINE> <INDENT> return sa_doubling ( s ) <NEWLINE> <NL> <DEDENT> sa = [ 0 ] * n <NEWLINE> ls = [ False ] * n <NEWLINE> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> ls [ i ] = ls [ i + 1 ] if s [ i ] == s [ i + 1 ] else s [ i ] < s [ i + 1 ] <NEWLINE> <NL> <DEDENT> sum_l = [ 0 ] * ( upper + 1 ) ; sum_s = [ 0 ] * ( upper + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not ls [ i ] : <NEWLINE> <INDENT> sum_s [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_l [ s [ i ] + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( upper + 1 ) : <NEWLINE> <INDENT> sum_s [ i ] += sum_l [ i ] <NEWLINE> if i < upper : sum_l [ i + 1 ] += sum_s [ i ] <NEWLINE> <NL> <DEDENT> def induce ( lms : list ) : <NEWLINE> <INDENT> from copy import copy <COMMENT> <NEWLINE> for i in range ( n ) : sa [ i ] = - 1 <COMMENT> <NEWLINE> buf = [ 0 ] * ( upper + 1 ) <NEWLINE> buf = copy ( sum_s ) <NEWLINE> for d in lms : <NEWLINE> <INDENT> if d == n : continue <NEWLINE> sa [ buf [ s [ d ] ] ] = d ; buf [ s [ d ] ] += 1 <NEWLINE> <NL> <DEDENT> buf = copy ( sum_l ) <NEWLINE> sa [ buf [ s [ n - 1 ] ] ] = n - 1 ; buf [ s [ n - 1 ] ] += 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = sa [ i ] <NEWLINE> if v >= 1 and not ls [ v - 1 ] : <NEWLINE> <INDENT> sa [ buf [ s [ v - 1 ] ] ] = v - 1 ; buf [ s [ v - 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> buf = copy ( sum_l ) <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> v = sa [ i ] <NEWLINE> if v >= 1 and ls [ v - 1 ] : <NEWLINE> <INDENT> buf [ s [ v - 1 ] + 1 ] -= 1 ; sa [ buf [ s [ v - 1 ] + 1 ] ] = v - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> lms_map = [ - 1 ] * ( n + 1 ) <NEWLINE> m = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if not ls [ i - 1 ] and ls [ i ] : <NEWLINE> <INDENT> lms_map [ i ] = m ; m += 1 <NEWLINE> <DEDENT> <DEDENT> lms = [ i for i in range ( 1 , n ) if not ls [ i - 1 ] and ls [ i ] ] <NEWLINE> induce ( lms ) <NEWLINE> <NL> if m : <NEWLINE> <INDENT> sorted_lms = [ v for v in sa if lms_map [ v ] != - 1 ] <NEWLINE> rec_s = [ 0 ] * m <NEWLINE> rec_upper = 0 <NEWLINE> rec_s [ lms_map [ sorted_lms [ 0 ] ] ] = 0 <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> l = sorted_lms [ i - 1 ] ; r = sorted_lms [ i ] <NEWLINE> end_l = lms [ lms_map [ l ] + 1 ] if lms_map [ l ] + 1 < m else n <NEWLINE> end_r = lms [ lms_map [ r ] + 1 ] if lms_map [ r ] + 1 < m else n <NEWLINE> same = True <NEWLINE> if end_l - l != end_r - r : <NEWLINE> <INDENT> same = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while l < end_l : <NEWLINE> <INDENT> if s [ l ] != s [ r ] : break <NEWLINE> l += 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> if l == n or s [ l ] != s [ r ] : same = False <NEWLINE> <DEDENT> if not same : rec_upper += 1 <NEWLINE> rec_s [ lms_map [ sorted_lms [ i ] ] ] = rec_upper <NEWLINE> <NL> <DEDENT> rec_sa = sa_is ( rec_s , rec_upper ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> sorted_lms [ i ] = lms [ rec_sa [ i ] ] <NEWLINE> <DEDENT> induce ( sorted_lms ) <NEWLINE> <DEDENT> return sa <NEWLINE> <NL> <DEDENT> def suffix_array ( s : list , upper : int ) : <NEWLINE> <INDENT> assert 0 <= upper <NEWLINE> for d in s : <NEWLINE> <INDENT> assert 0 <= d and d <= upper <NEWLINE> <DEDENT> sa = sa_is ( s , upper ) <NEWLINE> return sa <NEWLINE> <NL> <DEDENT> def suffix_array2 ( s : list ) : <NEWLINE> <INDENT> from functools import cmp_to_key <NEWLINE> n = len ( s ) <NEWLINE> idx = [ i for i in range ( n ) ] <NEWLINE> idx . sort ( key = cmp_to_key ( lambda l , r : s [ l ] < s [ r ] ) ) <NEWLINE> s2 = [ 0 ] * n <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i and s [ idx [ i - 1 ] ] != s [ idx [ i ] ] : now += 1 <NEWLINE> s2 [ idx [ i ] ] = now <NEWLINE> <DEDENT> return sa_is ( s2 , now ) <NEWLINE> <NL> <DEDENT> def suffix_array3 ( s : str ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> s2 = list ( map ( ord , s ) ) <NEWLINE> return sa_is ( s2 , 255 ) <NEWLINE> <NL> <DEDENT> def lcp_array ( s : list , sa : list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = len ( s ) <NEWLINE> assert n >= 1 <NEWLINE> rnk = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> rnk [ sa [ i ] ] = i <NEWLINE> <DEDENT> lcp = [ 0 ] * ( n - 1 ) <NEWLINE> h = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h > 0 : h -= 1 <NEWLINE> if rnk [ i ] == 0 : continue <NEWLINE> j = sa [ rnk [ i ] - 1 ] <NEWLINE> while j + h < n and i + h < n : <NEWLINE> <INDENT> if s [ j + h ] != s [ i + h ] : break <NEWLINE> h += 1 <NEWLINE> <DEDENT> lcp [ rnk [ i ] - 1 ] = h <NEWLINE> <DEDENT> return lcp <NEWLINE> <NL> <DEDENT> def lcp_array2 ( s : str , sa : list ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> s2 = list ( map ( ord , s ) ) <NEWLINE> return lcp_array ( s2 , sa ) <NEWLINE> <NL> <DEDENT> def z_algorithm ( s : list ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = len ( s ) <NEWLINE> if n == 0 : return [ ] <NEWLINE> z = [ - 1 ] * n <NEWLINE> z [ 0 ] = 0 ; j = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> k = z [ i ] = 0 if j + z [ j ] <= i else min ( j + z [ j ] - i , z [ i - j ] ) <NEWLINE> while i + k < n and s [ k ] == s [ i + k ] : k += 1 <NEWLINE> z [ i ] = k <NEWLINE> if j + z [ j ] < i + z [ i ] : j = i <NEWLINE> <DEDENT> z [ 0 ] = n <NEWLINE> return z <NEWLINE> <NL> <DEDENT> def z_algorithm2 ( s : str ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> s2 = list ( map ( ord , s ) ) <NEWLINE> return z_algorithm ( s2 ) <NEWLINE> <NL> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> s = read_str ( ) <NEWLINE> sa = suffix_array3 ( s ) <NEWLINE> ans = len ( s ) * ( len ( s ) + 1 ) // 2 <NEWLINE> for x in lcp_array2 ( s , sa ) : <NEWLINE> <INDENT> ans -= x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def aa ( ) : <NEWLINE> <INDENT> x , n = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> return <NEWLINE> <DEDENT> arr = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> diff = [ ] <NEWLINE> for i in arr : <NEWLINE> <NL> <INDENT> diff . append ( x - i ) <NEWLINE> <DEDENT> i = - 1 <NEWLINE> j = 0 <NEWLINE> while i in diff : <NEWLINE> <INDENT> i = i - 1 <NEWLINE> <DEDENT> while j in diff : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> <DEDENT> if abs ( i ) < abs ( j ) : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - j ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> aa ( ) <NEWLINE>
def aising19_c ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> <NL> h , w = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> color = [ [ s == <STRING> for s in str ( input ( ) ) ] for _ in range ( h ) ] <NEWLINE> used = [ [ False ] * w for _ in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if used [ i ] [ j ] : continue <NEWLINE> bk , wt = 0 , 0 <NEWLINE> que = deque ( ) <NEWLINE> used [ i ] [ j ] = True <NEWLINE> que . append ( ( i , j ) ) <NEWLINE> while que : <NEWLINE> <INDENT> ci , cj = que . popleft ( ) <NEWLINE> if color [ ci ] [ cj ] : bk += 1 <NEWLINE> else : wt += 1 <NEWLINE> for di , dj in ( ( - 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 1 , 0 ) ) : <NEWLINE> <INDENT> ni , nj = ci + di , cj + dj <NEWLINE> if ni < 0 or h <= ni or nj < 0 or w <= nj : continue <NEWLINE> if color [ ci ] [ cj ] == color [ ni ] [ nj ] : continue <NEWLINE> if used [ ni ] [ nj ] : continue <NEWLINE> used [ ni ] [ nj ] = True <NEWLINE> que . append ( ( ni , nj ) ) <NEWLINE> <DEDENT> <DEDENT> ans += bk * wt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> aising19_c ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 1000000007 <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum = sum + a [ i ] <NEWLINE> sum = sum % mod <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> sum = sum - a [ i ] <NEWLINE> if sum < 0 : <NEWLINE> <INDENT> sum = sum + mod <NEWLINE> <DEDENT> ans = ans + a [ i ] * sum <NEWLINE> ans = ans % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> AList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AList . sort ( ) <NEWLINE> AMax = AList [ - 1 ] + 1 <NEWLINE> <NL> dp = [ True ] * AMax <NEWLINE> answer = 0 <NEWLINE> <NL> ACheckSet = set ( ) <NEWLINE> ACheckSetCheckSet = set ( ) <NEWLINE> <NL> for A in AList : <NEWLINE> <NL> <INDENT> if dp [ A ] : <NEWLINE> <INDENT> answer = answer + 1 <NEWLINE> ACheckSet . add ( A ) <NEWLINE> <NL> for x in range ( A , AMax , A ) : <NEWLINE> <INDENT> dp [ x ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> elif A in ACheckSet : <NEWLINE> <NL> <INDENT> if A in ACheckSetCheckSet : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = answer - 1 <NEWLINE> ACheckSetCheckSet . add ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> mod = 10 ** 18 <NEWLINE> <NL> cnt = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt *= a [ i ] <NEWLINE> if cnt > mod : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a * min ( b - 1 , n ) ) // b ) <NEWLINE>
def insertion_sort ( target_list ) : <NEWLINE> <INDENT> sorted_list = list ( ) <NEWLINE> for target in target_list [ : ] : <NEWLINE> <INDENT> for i , num in enumerate ( sorted_list ) : <NEWLINE> <INDENT> if num > target : <NEWLINE> <INDENT> sorted_list [ i : i ] = [ target ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sorted_list . append ( target ) <NEWLINE> <DEDENT> target_list . pop ( 0 ) <NEWLINE> print ( <STRING> . join ( str ( s ) for s in sorted_list + target_list ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> insertion_sort ( A ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sa = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sa . append ( ( sa [ i ] + a [ i ] ) % mod ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ i ] * ( sa [ - 1 ] - sa [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s [ i ] = s [ i - 1 ] + a [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += a [ i ] * s [ i ] <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( ans % mod ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> n = int ( args [ 0 ] ) <NEWLINE> A = list ( map ( int , args [ 1 ] . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> ret = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if 10 ** 18 < ret * a : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret *= a <NEWLINE> <NL> <DEDENT> <DEDENT> return str ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict as dd <NEWLINE> sys . setrecursionlimit ( 4100000 ) <NEWLINE> <NL> def dfs ( node ) : <NEWLINE> <INDENT> visited [ node - 1 ] = True <NEWLINE> <NL> for next_node in tree [ node ] : <NEWLINE> <INDENT> if visited [ next_node - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter [ next_node - 1 ] += counter [ node - 1 ] <NEWLINE> dfs ( next_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = dd ( list ) <NEWLINE> visited = [ False ] * N <NEWLINE> counter = [ 0 ] * N <NEWLINE> operation = [ ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> tree [ b ] . append ( a ) <NEWLINE> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> operation . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for p , x in operation : <NEWLINE> <INDENT> counter [ p - 1 ] += x <NEWLINE> <DEDENT> dfs ( 1 ) <NEWLINE> print ( * counter ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = [ i for i in range ( 0 , 102 ) ] <NEWLINE> <NL> for p in P : <NEWLINE> <INDENT> N . pop ( N . index ( p ) ) <NEWLINE> <NL> <DEDENT> L = [ ] <NEWLINE> for a in N : <NEWLINE> <INDENT> l = abs ( a - x ) <NEWLINE> L . append ( l ) <NEWLINE> <NL> <DEDENT> m = L . index ( min ( L ) ) <NEWLINE> print ( N [ m ] ) <NEWLINE> <DEDENT>
<NL> S = input ( ) [ : : - 1 ] <NEWLINE> l = len ( S ) <NEWLINE> t = 0 <NEWLINE> p = 0 <NEWLINE> <NL> ss = [ 0 ] * 2019 <NEWLINE> ss [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> p = ( p + int ( i ) * d ) % 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> ss [ p ] += 1 <NEWLINE> <NL> <DEDENT> for c in ss : <NEWLINE> <INDENT> t += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def log ( * args ) : <NEWLINE> <INDENT> print ( * args , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> tmp = pow ( x , 2 ) + pow ( y , 2 ) + pow ( z , 2 ) + x * y + y * z + z * x <NEWLINE> if tmp > n : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans [ tmp - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for v in ans : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 118 , 120 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> A = a <NEWLINE> B = b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
N = input ( ) <NEWLINE> print ( max ( sum ( [ int ( i ) for i in N ] ) , ( len ( N ) - 1 ) * 9 + int ( N [ 0 ] ) - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d = N // k <NEWLINE> ans += k * ( d + 1 ) * d // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> <NL> count = x . count ( <STRING> ) <NEWLINE> <NL> mod1 = 0 <COMMENT> <NEWLINE> mod2 = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> mod1_list = [ 0 ] * n <NEWLINE> mod2_list = [ 0 ] * n <NEWLINE> <NL> now1 = 1 <NEWLINE> <NL> x = x [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> mod1_list [ i ] = now1 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> mod1 += now1 % ( count + 1 ) <NEWLINE> <DEDENT> now1 *= 2 <NEWLINE> now1 %= ( count + 1 ) <NEWLINE> <NL> <DEDENT> mod1 %= ( count + 1 ) <NEWLINE> <NL> now2 = 1 <NEWLINE> <NL> <COMMENT> <NL> if count >= 3 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> mod2_list [ i ] = now2 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> mod2 += now2 % ( count - 1 ) <NEWLINE> <DEDENT> now2 *= 2 <NEWLINE> now2 %= ( count - 1 ) <NEWLINE> <NL> <DEDENT> mod2 %= ( count - 1 ) <NEWLINE> <NL> <DEDENT> mod1_list = mod1_list [ : : - 1 ] <NEWLINE> mod2_list = mod2_list [ : : - 1 ] <NEWLINE> x = x [ : : - 1 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> total = 1 <NEWLINE> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if count == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> elif count == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> now = mod2 - mod2_list [ i ] <NEWLINE> now %= ( count - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = mod1 + mod1_list [ i ] <NEWLINE> now %= ( count + 1 ) <NEWLINE> <NL> <DEDENT> while now != 0 : <NEWLINE> <INDENT> now = now % ( bin ( now ) . count ( <STRING> ) ) <NEWLINE> total += 1 <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans + a [ i // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = [ 0 ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> x [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in x : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> sum_ = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum_ -= A [ i ] <NEWLINE> ans += sum_ * A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ls_str_l = input ( ) . split ( ) <NEWLINE> <NL> if n < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls_l = [ ] <NEWLINE> for l in ls_str_l : <NEWLINE> <INDENT> ls_l . append ( int ( l ) ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> ls_tri_n = list ( combinations ( ls_l , 3 ) ) <NEWLINE> for ls_tri in ls_tri_n : <NEWLINE> <INDENT> if ls_tri [ 0 ] == ls_tri [ 1 ] or ls_tri [ 0 ] == ls_tri [ 2 ] or ls_tri [ 1 ] == ls_tri [ 2 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ls_tri [ 0 ] + ls_tri [ 1 ] > ls_tri [ 2 ] and ls_tri [ 0 ] + ls_tri [ 2 ] > ls_tri [ 1 ] and ls_tri [ 1 ] + ls_tri [ 2 ] > ls_tri [ 0 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
from sys import exit <NEWLINE> import queue <NEWLINE> V , E = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> ans = [ ] <NEWLINE> <NL> <COMMENT> <NL> graph = [ [ ] for _ in range ( V ) ] <NEWLINE> indeg = [ 0 ] * V <NEWLINE> yet = [ True ] * V <NEWLINE> def bfs ( s ) : <NEWLINE> <INDENT> q = queue . Queue ( ) <NEWLINE> q . put ( s ) <NEWLINE> while ( not q . empty ( ) ) : <NEWLINE> <INDENT> u = q . get ( ) <NEWLINE> ans . append ( u ) <NEWLINE> yet [ u ] = False <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> indeg [ v ] -= 1 <NEWLINE> if ( indeg [ v ] == 0 ) : <NEWLINE> <INDENT> q . put ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( E ) : <NEWLINE> <INDENT> s , t = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> graph [ s ] . append ( t ) <NEWLINE> indeg [ t ] += 1 <NEWLINE> <DEDENT> for i in range ( V ) : <NEWLINE> <INDENT> if ( indeg [ i ] == 0 and yet [ i ] ) : <NEWLINE> <INDENT> bfs ( i ) <NEWLINE> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> L [ a ] = - 1 <NEWLINE> <DEDENT> L [ 0 ] = 1 <NEWLINE> L [ 1 ] += 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if L [ i ] == - 1 : <NEWLINE> <INDENT> L [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> print ( L [ - 1 ] % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> su = sum ( arr ) <NEWLINE> lst = [ 0 ] * 100001 <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in arr : <NEWLINE> <INDENT> lst [ i ] += 1 <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> su += ( c - b ) * lst [ b ] <NEWLINE> print ( su ) <NEWLINE> lst [ c ] += lst [ b ] <NEWLINE> lst [ b ] = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> from heapq import heapify , heappop , heappush , heappushpop <NEWLINE> import math <NEWLINE> import collections <NEWLINE> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if n < b - 1 : <NEWLINE> <INDENT> ans = math . floor ( ( a * n ) / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = math . floor ( ( a * ( b - 1 ) ) / b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> S = deque ( input ( ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> reverse = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> Query = list ( input ( ) . split ( ) ) <NEWLINE> T = Query [ 0 ] <NEWLINE> if T == <STRING> : <NEWLINE> <INDENT> reverse += 1 <NEWLINE> <DEDENT> if T == <STRING> : <NEWLINE> <INDENT> F , C = Query [ 1 ] , Query [ 2 ] <NEWLINE> if F == <STRING> and reverse % 2 == 0 or F == <STRING> and reverse % 2 == 1 : <NEWLINE> <INDENT> S . appendleft ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( C ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> S = <STRING> . join ( S ) <NEWLINE> print ( S if reverse % 2 == 0 else S [ : : - 1 ] ) <NEWLINE>
from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edge [ u ] . append ( v ) <NEWLINE> edge [ v ] . append ( u ) <NEWLINE> <DEDENT> stack = deque ( [ ] ) <NEWLINE> inf = 10 ** 18 <NEWLINE> lis = [ inf ] * ( n + 1 ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> visited = [ True ] * n <NEWLINE> <COMMENT> <NL> def dfs ( s ) : <NEWLINE> <INDENT> visited [ s ] = False <NEWLINE> idx = bisect_left ( lis , a [ s ] ) <NEWLINE> stack . append ( ( idx , lis [ idx ] ) ) <NEWLINE> lis [ idx ] = a [ s ] <NEWLINE> ans [ s ] = bisect_left ( lis , inf ) <NEWLINE> for x in edge [ s ] : <NEWLINE> <INDENT> if visited [ x ] : <NEWLINE> <INDENT> dfs ( x ) <NEWLINE> <DEDENT> <DEDENT> idx , val = stack . pop ( ) <NEWLINE> lis [ idx ] = val <NEWLINE> <DEDENT> dfs ( 0 ) <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a <= 0 and b >= 0 ) or ( a == 0 ) or ( b == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a > 0 ) or ( b < 0 and ( b - a ) % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( b < 0 and ( b - a ) % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> clist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> slist = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> tlist = [ int ( input ( ) ) for _ in range ( D ) ] <NEWLINE> zlist = [ ] <NEWLINE> dlist = [ 0 ] * 26 <NEWLINE> ans = 0 <NEWLINE> <STRING> <NEWLINE> for i in range ( D ) : <NEWLINE> <COMMENT> <NL> <INDENT> zlist . append ( clist [ tlist [ i ] - 1 ] * ( ( i + 1 ) - dlist [ tlist [ i ] - 1 ] ) ) <NEWLINE> dlist [ tlist [ i ] - 1 ] = i + 1 <NEWLINE> ans += slist [ i ] [ tlist [ i ] - 1 ] - ( ( i + 1 ) * sum ( clist ) ) + sum ( zlist ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> money = 1000 <NEWLINE> kabu = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if kabu == 0 : <NEWLINE> <INDENT> if a [ i ] <= a [ i + 1 ] : <NEWLINE> <INDENT> kabu += money // a [ i ] <NEWLINE> money %= a [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> money += kabu * a [ i ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( money + kabu * a [ - 1 ] ) <NEWLINE>
alphabets = <STRING> <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> A . append ( n % 26 ) <NEWLINE> n //= 26 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ i ] <= 0 : <NEWLINE> <INDENT> A [ i ] += 26 ; A [ i + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ANS = [ ] <NEWLINE> for a in A [ : : - 1 ] : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ANS . append ( alphabets [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ANS ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> used = list ( input ( ) for x in range ( n ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if used . count ( used [ i ] ) == 2 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if used [ i ] [ - 1 ] != used [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nmax = 0 <NEWLINE> <NL> Asum = list ( ) <NEWLINE> Asum . append ( 0 ) <NEWLINE> Bsum = list ( ) <NEWLINE> Bsum . append ( 0 ) <NEWLINE> <NL> imax_a = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = Asum [ i ] + A [ i ] <NEWLINE> Asum . append ( s ) <NEWLINE> if s > K : <NEWLINE> <INDENT> imax_a = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> imax_b = M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s = Bsum [ i ] + B [ i ] <NEWLINE> Bsum . append ( s ) <NEWLINE> if s > K : <NEWLINE> <INDENT> imax_b = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( imax_a + 1 ) : <NEWLINE> <INDENT> for j in range ( imax_b , - 1 , - 1 ) : <NEWLINE> <INDENT> time = Asum [ i ] + Bsum [ j ] <NEWLINE> <COMMENT> <NL> if time <= K : <NEWLINE> <INDENT> imax_b = j <NEWLINE> <NL> if nmax < i + j : <NEWLINE> <INDENT> nmax = i + j <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( nmax ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> _range = int ( pow ( X , 1 / 5 ) ) <NEWLINE> for i in range ( - 2 * _range - 1 , 2 * _range + 2 ) : <NEWLINE> <INDENT> for j in range ( - 2 * _range - 1 , 2 * _range + 2 ) : <NEWLINE> <INDENT> if pow ( i , 5 ) - pow ( j , 5 ) == X : <NEWLINE> <INDENT> ans_a = i <NEWLINE> ans_b = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans_a , ans_b ) <NEWLINE>
def find ( target ) : <NEWLINE> <INDENT> if parent [ target ] < 0 : <NEWLINE> <INDENT> return target <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ target ] = find ( parent [ target ] ) <NEWLINE> return parent [ target ] <NEWLINE> <NL> <DEDENT> <DEDENT> def is_same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> root_x = find ( x ) <NEWLINE> root_y = find ( y ) <NEWLINE> if root_x == root_y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if parent [ root_x ] > parent [ root_y ] : <NEWLINE> <INDENT> root_x , root_y = root_y , root_x <NEWLINE> <DEDENT> parent [ root_x ] += parent [ root_y ] <NEWLINE> parent [ root_y ] = root_x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def members ( n , x ) : <NEWLINE> <INDENT> root = find ( x ) <NEWLINE> return [ i for i in range ( n ) if find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def get_size ( x ) : <NEWLINE> <INDENT> return - parent [ find ( x ) ] <NEWLINE> <NL> <DEDENT> def get_root ( ) : <NEWLINE> <INDENT> return [ i for i , root in enumerate ( parent ) if root < 0 ] <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> parent = [ - 1 for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> union ( a , b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , get_size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> x_val = int ( X , 2 ) <NEWLINE> pc_x = X . count ( <STRING> ) <NEWLINE> <NL> x_mod_pc_x_plus_1 = x_val % ( pc_x + 1 ) <NEWLINE> x_mod_pc_x_minus_1 = x_val % max ( pc_x - 1 , 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> pc = pc_x - 1 <NEWLINE> if pc == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> val = ( x_mod_pc_x_minus_1 - pow ( 2 , N - i - 1 , pc ) ) % pc <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pc = pc_x + 1 <NEWLINE> val = ( x_mod_pc_x_plus_1 + pow ( 2 , N - i - 1 , pc ) ) % pc <NEWLINE> <DEDENT> ans = 1 <NEWLINE> while val > 0 : <NEWLINE> <INDENT> val %= bin ( val ) . count ( <STRING> ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> table = [ 0 ] * 102 <NEWLINE> for a in data : <NEWLINE> <INDENT> table [ a ] = 1 <NEWLINE> <NL> <DEDENT> left = None <NEWLINE> idx = x <NEWLINE> while idx >= 0 : <NEWLINE> <INDENT> if table [ idx ] == 0 : <NEWLINE> <INDENT> left = idx <NEWLINE> break <NEWLINE> <DEDENT> idx -= 1 <NEWLINE> <DEDENT> idx = x <NEWLINE> right = None <NEWLINE> while idx < 102 : <NEWLINE> <INDENT> if table [ idx ] == 0 : <NEWLINE> <INDENT> right = idx <NEWLINE> break <NEWLINE> <DEDENT> idx += 1 <NEWLINE> <NL> <DEDENT> lscore = abs ( x - left ) <NEWLINE> rscore = abs ( x - right ) <NEWLINE> <NL> if lscore <= rscore : <NEWLINE> <INDENT> print ( left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mx = sum ( p [ : K ] ) <NEWLINE> cur = mx <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> cur = cur - p [ i ] + p [ i + K ] <NEWLINE> mx = max ( mx , cur ) <NEWLINE> <NL> <DEDENT> ans = ( mx + K ) / 2 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> S = sum ( a ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> S -= a [ i ] <NEWLINE> ans += a [ i ] * S <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> LIMIT = 999999 <NEWLINE> <NL> prime = [ 0 , 1 ] + [ 0 if i % 2 == 0 else 1 for i in range ( 3 , LIMIT + 1 ) ] <NEWLINE> <NL> for i in range ( 3 , LIMIT + 1 ) : <NEWLINE> <INDENT> if prime [ i - 1 ] : <NEWLINE> <INDENT> for j in range ( i ** 2 , LIMIT + 1 , i ) : <NEWLINE> <INDENT> prime [ j - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( sum ( prime [ : n ] ) ) <NEWLINE> <NL> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( b // x ) - ( ( a - 1 ) // x ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import random <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def det ( a , b , c ) : <NEWLINE> <INDENT> return + a [ 0 ] * b [ 1 ] * c [ 2 ] + a [ 2 ] * b [ 0 ] * c [ 1 ] + a [ 1 ] * b [ 2 ] * c [ 0 ] - a [ 2 ] * b [ 1 ] * c [ 0 ] - a [ 1 ] * b [ 0 ] * c [ 2 ] - a [ 0 ] * b [ 2 ] * c [ 1 ] <NEWLINE> <NL> <DEDENT> def sub ( v0 , v1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> return ( v0 [ 0 ] - v1 [ 0 ] , v0 [ 1 ] - v1 [ 1 ] , v0 [ 2 ] - v1 [ 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> p0 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> p1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( p0 , p1 , A , B , C ) : <NEWLINE> <INDENT> a = sub ( p1 , p0 ) <NEWLINE> b = sub ( A , B ) <NEWLINE> c = sub ( A , C ) <NEWLINE> d = sub ( A , p0 ) <NEWLINE> <NL> EPS = 0.0000001 <NEWLINE> lower = - EPS <NEWLINE> upper = 1 + EPS <NEWLINE> <NL> denom = det ( a , b , c ) <NEWLINE> <NL> if denom != 0 : <NEWLINE> <INDENT> t = det ( d , b , c ) / denom <NEWLINE> u = det ( a , d , c ) / denom <NEWLINE> v = det ( a , b , d ) / denom <NEWLINE> <NL> if t < lower : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif lower < t < upper and lower <= u <= upper and lower <= v <= upper and lower <= u + v <= upper : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def correct_solve ( p0 , p1 , A , B , C ) : <NEWLINE> <INDENT> from fractions import Fraction <NEWLINE> def gauss ( a ) : <NEWLINE> <INDENT> if not a or len ( a ) == 0 : return None <NEWLINE> n = len ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] [ i ] == 0 : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ j ] [ i ] != 0 : <NEWLINE> <INDENT> for k in range ( i , n + 1 ) : a [ i ] [ k ] += a [ j ] [ k ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> r = Fraction ( a [ j ] [ i ] , a [ i ] [ i ] ) <NEWLINE> for k in range ( i , n + 1 ) : a [ j ] [ k ] = a [ j ] [ k ] - a [ i ] [ k ] * r <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = Fraction ( a [ i ] [ i ] , 1 ) <NEWLINE> for j in range ( len ( a [ i ] ) ) : <NEWLINE> <INDENT> a [ i ] [ j ] /= x <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> uaz = p0 <NEWLINE> enemy = [ 0 ] + [ - x + y for x , y in zip ( p1 , uaz ) ] <NEWLINE> b0 = [ 1 ] + [ x - y for x , y in zip ( A , uaz ) ] <NEWLINE> b1 = [ 1 ] + [ x - y for x , y in zip ( B , uaz ) ] <NEWLINE> b2 = [ 1 ] + [ x - y for x , y in zip ( C , uaz ) ] <NEWLINE> sol = gauss ( list ( map ( list , zip ( b0 , b1 , b2 , enemy , [ 1 , 0 , 0 , 0 ] ) ) ) ) <NEWLINE> if sol and all ( 0 <= e [ - 1 ] <= 1 for e in sol ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def rand_v ( ) : <NEWLINE> <INDENT> return ( random . randrange ( - 100 , 100 ) , random . randrange ( - 100 , 100 ) , random . randrange ( - 100 , 100 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> res = solve ( p0 , p1 , A , B , C ) <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def get_articulation_points ( G , N , start = 0 ) : <NEWLINE> <INDENT> v_min = [ 0 ] * N ; order = [ None ] * N <NEWLINE> result = [ ] ; count = 0 <NEWLINE> def dfs ( v , prev ) : <NEWLINE> <INDENT> nonlocal count <NEWLINE> r_min = order [ v ] = count <NEWLINE> fcnt = 0 ; p_art = 0 <NEWLINE> count += 1 <NEWLINE> for w in G [ v ] : <NEWLINE> <INDENT> if w == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if order [ w ] is None : <NEWLINE> <INDENT> ret = dfs ( w , v ) <NEWLINE> p_art |= ( order [ v ] <= ret ) <NEWLINE> r_min = min ( r_min , ret ) <NEWLINE> fcnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r_min = min ( r_min , order [ w ] ) <NEWLINE> <DEDENT> <DEDENT> p_art |= ( r_min == order [ v ] and len ( G [ v ] ) > 1 ) <NEWLINE> if ( prev == - 1 and fcnt > 1 ) or ( prev != - 1 and p_art ) : <NEWLINE> <INDENT> result . append ( v ) <NEWLINE> <DEDENT> return r_min <NEWLINE> <DEDENT> dfs ( start , - 1 ) <NEWLINE> return result <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> G [ t ] . append ( s ) <NEWLINE> <DEDENT> * _ , = map ( print , sorted ( get_articulation_points ( G , n ) ) ) <NEWLINE>
N , W , H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> map_x = [ 0 ] * W <NEWLINE> map_y = [ 0 ] * H <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , w = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> map_x [ max ( 0 , x - w ) ] = max ( map_x [ max ( 0 , x - w ) ] , x + w - max ( 0 , x - w ) ) <NEWLINE> map_y [ max ( 0 , y - w ) ] = max ( map_y [ max ( 0 , y - w ) ] , y + w - max ( 0 , y - w ) ) <NEWLINE> <NL> <NL> <DEDENT> def check_wifi ( wifi ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> end = len ( wifi ) <NEWLINE> <NL> for i , x in enumerate ( wifi ) : <NEWLINE> <INDENT> if x : <NEWLINE> <INDENT> m = max ( m , i + x ) <NEWLINE> <NL> <DEDENT> if m >= end : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if i < m : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <DEDENT> print ( <STRING> if check_wifi ( map_x ) or check_wifi ( map_y ) else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , n ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> ans += n // a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> m = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> for a , b in m : <NEWLINE> <INDENT> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> par = [ 0 ] * ( N + 1 ) <NEWLINE> visited = [ 0 ] * ( N + 1 ) <NEWLINE> root = 1 <NEWLINE> visited [ root ] = 1 <NEWLINE> q = deque ( [ root ] ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for w in G [ v ] : <NEWLINE> <INDENT> if visited [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ w ] = 1 <NEWLINE> par [ w ] = v <NEWLINE> q . append ( w ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * par [ 2 : ] , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = sum ( a_list ) <NEWLINE> ans = 0 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum_a -= a_list [ i ] <NEWLINE> ans += a_list [ i ] * sum_a <NEWLINE> ans %= m <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for n in range ( K , N ) : <NEWLINE> <INDENT> print ( <STRING> if A [ n ] > A [ n - K ] else <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> dp = [ 1 ] + [ 0 for i in range ( S ) ] <NEWLINE> i = 3 <NEWLINE> k = 1000000007 <NEWLINE> if S < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i <= S : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 3 ] ) % k <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( dp [ S ] ) <NEWLINE> <DEDENT>
memo = input ( ) . split ( ) <NEWLINE> [ int ( i ) for i in memo ] <NEWLINE> memo . sort ( ) <NEWLINE> print ( memo [ 0 ] + <STRING> + memo [ 1 ] + <STRING> + memo [ 2 ] ) <NEWLINE>
N , K = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> h . sort ( ) <NEWLINE> <NL> print ( min ( h [ i + K - 1 ] - h [ i ] for i in range ( N - K + 1 ) ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , W = map ( int , input ( ) . split ( ) ) <NEWLINE> w = [ ] <NEWLINE> v = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w_ , v_ = map ( int , input ( ) . split ( ) ) <NEWLINE> w . append ( w_ ) <NEWLINE> v . append ( v_ ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( W + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ w [ i ] : ] = np . maximum ( dp [ : - w [ i ] ] + v [ i ] , dp [ w [ i ] : ] ) <NEWLINE> <DEDENT> print ( dp [ W ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> b , c = [ ] , [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> c . reverse ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> c . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( c + b ) ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n . append ( - 1 ) <NEWLINE> <DEDENT> s = 0 <NEWLINE> c = - 1 <NEWLINE> d = A [ 1 - 1 ] <NEWLINE> r = [ 1 ] <NEWLINE> n [ 0 ] = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if n [ d - 1 ] == - 1 : <NEWLINE> <INDENT> n [ d - 1 ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = n [ d - 1 ] <NEWLINE> c = i - n [ d - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> r . append ( d ) <NEWLINE> d = A [ d - 1 ] <NEWLINE> <DEDENT> if c == - 1 : <NEWLINE> <INDENT> print ( r [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cr = r [ s : s + c ] <NEWLINE> k = ( K - s ) % c <NEWLINE> print ( cr [ k ] ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = ( n - 1 ) * n // 2 <NEWLINE> print ( a ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import bisect_right <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> fr = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = AB [ i ] <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> fr [ a ] . append ( b ) <NEWLINE> fr [ b ] . append ( a ) <NEWLINE> <DEDENT> def dfs ( fr , cur , parent , index , li ) : <NEWLINE> <INDENT> children = fr [ cur ] <NEWLINE> for chi in children : <NEWLINE> <INDENT> if chi == parent or used [ chi ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ chi ] = index <NEWLINE> li . append ( chi ) <NEWLINE> dfs ( fr , chi , cur , index , li ) <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = AB [ i ] <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> used = [ - 1 ] * N <COMMENT> <NEWLINE> renketu = [ ] <NEWLINE> index = 0 <NEWLINE> fr [ a ] . remove ( b ) <NEWLINE> fr [ b ] . remove ( a ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if used [ j ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> li = [ j ] <NEWLINE> used [ j ] = index <NEWLINE> dfs ( fr , j , - 1 , index , li ) <NEWLINE> index += 1 <NEWLINE> renketu . append ( li ) <NEWLINE> <DEDENT> if len ( renketu ) != 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> fr [ a ] . append ( b ) <NEWLINE> fr [ b ] . append ( a ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( b - a + 1 ) <= 2 * k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 0 , N - K ) : <NEWLINE> <INDENT> print ( <STRING> if 1 < A [ i + K ] / A [ i ] else <STRING> ) <NEWLINE> <DEDENT>
s = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> from itertools import product <NEWLINE> L = product ( [ i for i in range ( 1 , k + 1 ) ] , repeat = 2 ) <NEWLINE> S = [ gcd ( a , b ) for ( a , b ) in L ] <NEWLINE> from collections import Counter <NEWLINE> S_counter = Counter ( S ) <NEWLINE> for key , value in S_counter . items ( ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += gcd ( key , i ) * value <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for n in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> b = math . gcd ( m , n ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a += math . gcd ( l , b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> col = [ 0 ] * w <NEWLINE> row = [ 0 ] * h <NEWLINE> ypos = [ ] <NEWLINE> xpos = [ ] <NEWLINE> bomb = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> H , W = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> col [ W ] += 1 <NEWLINE> row [ H ] += 1 <NEWLINE> bomb . append ( ( H , W ) ) <NEWLINE> <NL> <DEDENT> maxcol = max ( col ) <NEWLINE> maxrow = max ( row ) <NEWLINE> <NL> xpos = [ h for h , x in enumerate ( col ) if x == maxcol ] <NEWLINE> ypos = [ w for w , y in enumerate ( row ) if y == maxrow ] <NEWLINE> <NL> ans = maxcol + maxrow - 1 <NEWLINE> bomb = set ( bomb ) <NEWLINE> <NL> for i in ypos : <NEWLINE> <INDENT> for j in xpos : <NEWLINE> <INDENT> if ( i , j ) not in bomb : <NEWLINE> <INDENT> ans += 1 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h , w = [ 0 ] * M , [ 0 ] * M <NEWLINE> dic = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h [ i ] , w [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> dic . add ( ( h [ i ] , w [ i ] ) ) <NEWLINE> <NL> <DEDENT> counter = collections . Counter ( h ) <NEWLINE> h_max = max ( counter . values ( ) ) <NEWLINE> mode_h = [ key for key , value in counter . items ( ) if value == h_max ] <NEWLINE> counter = collections . Counter ( w ) <NEWLINE> w_max = max ( counter . values ( ) ) <NEWLINE> mode_w = [ key for key , value in counter . items ( ) if value == w_max ] <NEWLINE> <NL> for i in mode_h : <NEWLINE> <INDENT> for j in mode_w : <NEWLINE> <INDENT> if ( i , j ) not in dic : <NEWLINE> <INDENT> print ( h_max + w_max ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( h_max + w_max - 1 ) <NEWLINE> <NL>
<COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> def msb ( x , ma = 59 ) : <NEWLINE> <INDENT> for i in range ( ma , - 1 , - 1 ) : <NEWLINE> <INDENT> if ( x >> i ) & 1 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return len ( ) <NEWLINE> <DEDENT> t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> msbs = [ 0 for i in range ( 60 ) ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = a [ i ] <NEWLINE> m = 59 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> m = msb ( now , m ) <NEWLINE> if msbs [ m ] == 0 : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> now = msbs [ m ] ^ now <NEWLINE> if now == 0 : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if f : <NEWLINE> <INDENT> msbs [ m ] = now <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if f : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> HW = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> g_h = [ 0 ] * ( H + 1 ) <NEWLINE> g_w = [ 0 ] * ( W + 1 ) <NEWLINE> <NL> for h , w in HW : <NEWLINE> <INDENT> g_h [ h ] += 1 <NEWLINE> g_w [ w ] += 1 <NEWLINE> <NL> <DEDENT> mxh = max ( g_h ) <NEWLINE> mxw = max ( g_w ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for h , w in HW : <NEWLINE> <INDENT> if g_h [ h ] == mxh and g_w [ w ] == mxw : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == g_h . count ( mxh ) * g_w . count ( mxw ) : <NEWLINE> <INDENT> print ( mxh + mxw - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mxh + mxw ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> n = len ( t ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( t [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> b = a . split ( ) <NEWLINE> <NL> x1 = int ( b [ 0 ] ) <COMMENT> <NEWLINE> x2 = int ( b [ 1 ] ) <COMMENT> <NEWLINE> x3 = int ( b [ 2 ] ) <COMMENT> <NEWLINE> x4 = int ( b [ 3 ] ) <COMMENT> <NEWLINE> <NL> if x4 <= x1 : <NEWLINE> <INDENT> print ( x4 ) <NEWLINE> <NL> <DEDENT> elif x4 <= x1 + x2 : <NEWLINE> <INDENT> print ( x1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( x1 - ( x4 - x1 - x2 ) ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> num = [ ] <NEWLINE> summ = 0 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> num . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> num [ a [ i ] - 1 ] += 1 <NEWLINE> summ += a [ i ] <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> summ += ( c - b ) * num [ b - 1 ] <NEWLINE> num [ c - 1 ] += num [ b - 1 ] <NEWLINE> num [ b - 1 ] = 0 <NEWLINE> print ( summ ) <NEWLINE> <DEDENT>
in_str = input ( ) . split ( <STRING> ) <NEWLINE> in_int = sorted ( list ( map ( int , in_str ) ) ) <NEWLINE> in_sstr = list ( map ( str , in_int ) ) <NEWLINE> tes = <STRING> . join ( in_sstr ) <NEWLINE> print ( tes ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> from itertools import cycle <NEWLINE> <NL> <NL> def guruguru ( n ) : <NEWLINE> <INDENT> line = 0 <NEWLINE> dirs = cycle ( [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] ) <NEWLINE> <NL> M = [ [ <STRING> ] * n for _ in range ( n ) ] <NEWLINE> cx = 0 <NEWLINE> cy = n - 1 <NEWLINE> <NL> while line < n : <NEWLINE> <INDENT> line += 1 <NEWLINE> dx , dy = dirs . __next__ ( ) <NEWLINE> while True : <NEWLINE> <INDENT> M [ cy ] [ cx ] = <STRING> <NEWLINE> nx = cx + dx <NEWLINE> ny = cy + dy <NEWLINE> nnx = nx + dx <NEWLINE> nny = ny + dy <NEWLINE> <NL> if nx < 0 or nx >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ny < 0 or ny >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if nny < 0 or nny >= n or nnx < 0 or nnx >= n : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if M [ nny ] [ nnx ] != <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> cx = nx <NEWLINE> cy = ny <NEWLINE> <NL> <DEDENT> <DEDENT> for l in M : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , l ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> size = int ( input ( ) ) <NEWLINE> guruguru ( size ) <NEWLINE> if i != ( n - 1 ) : <NEWLINE> <INDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> a = [ 0 ] * 2019 <NEWLINE> a [ 0 ] = 1 <NEWLINE> k = 0 <NEWLINE> ans = 0 <NEWLINE> mod = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> k = ( k + int ( s [ i ] ) * mod ) % 2019 <NEWLINE> mod = ( mod * 10 ) % 2019 <NEWLINE> a [ k ] += 1 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans += i * ( i - 1 ) * 0.5 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> A . sort ( ) <NEWLINE> overwrite = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B , C = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> overwrite . append ( { <NEWLINE> <INDENT> <STRING> : B , <NEWLINE> <STRING> : C <NEWLINE> <DEDENT> } ) <NEWLINE> <DEDENT> overwrite . sort ( key = lambda o : - o [ <STRING> ] ) <NEWLINE> j = 0 <NEWLINE> k = 0 <NEWLINE> flag = False <NEWLINE> while not flag and j < len ( A ) and k < len ( overwrite ) : <NEWLINE> <INDENT> o = overwrite [ k ] <NEWLINE> for m in range ( o [ <STRING> ] ) : <NEWLINE> <INDENT> if j < len ( A ) and A [ j ] <= o [ <STRING> ] : <NEWLINE> <INDENT> A [ j ] = o [ <STRING> ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> k += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) , dtype = np . int64 ) <NEWLINE> bc = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] , key = lambda x : - x [ 1 ] ) <NEWLINE> <NL> p = 0 <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> a [ p : p + b ] = np . maximum ( a [ p : p + b ] , c ) <NEWLINE> p += b <NEWLINE> <DEDENT> print ( np . sum ( a ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = [ 0 ] * ( len ( S ) - len ( T ) + 1 ) <NEWLINE> for a in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> for b in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ a + b ] != T [ b ] : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> dp = [ True for _ in range ( A [ - 1 ] + 1 ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <COMMENT> <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> dp [ A [ i ] ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> for b in range ( a , len ( dp ) , a ) : <COMMENT> <NEWLINE> <INDENT> dp [ b ] = False <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if aa [ i - k ] < aa [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> col = [ 0 ] * w <NEWLINE> row = [ 0 ] * h <NEWLINE> ypos = [ ] <NEWLINE> xpos = [ ] <NEWLINE> bomb = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> H , W = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> col [ W ] += 1 <NEWLINE> row [ H ] += 1 <NEWLINE> bomb . append ( ( H , W ) ) <NEWLINE> <NL> <DEDENT> maxcol = max ( col ) <NEWLINE> maxrow = max ( row ) <NEWLINE> <NL> for i in range ( w ) : <NEWLINE> <INDENT> if col [ i ] == maxcol : <NEWLINE> <INDENT> xpos . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if row [ i ] == maxrow : <NEWLINE> <INDENT> ypos . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = maxcol + maxrow - 1 <NEWLINE> bomb = set ( bomb ) <COMMENT> <NEWLINE> <NL> for i in ypos : <NEWLINE> <INDENT> for j in xpos : <NEWLINE> <INDENT> if ( i , j ) not in bomb : <NEWLINE> <INDENT> ans += 1 <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> m = m * a [ i ] <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif i == n - 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> f = [ [ <STRING> ] * ( w + 2 ) ] + [ list ( <STRING> + input ( ) + <STRING> ) for i in range ( h ) ] + [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> <NL> flg = False <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if f [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if f [ y + 1 ] [ x ] == f [ y - 1 ] [ x ] == f [ y ] [ x + 1 ] == f [ y ] [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> flg = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) if flg else print ( <STRING> ) <NEWLINE>
from bisect import bisect_left as bl <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ i for i in range ( n ) ] <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ind = 0 <NEWLINE> for a in alst : <NEWLINE> <INDENT> if a % 2 == 0 : <NEWLINE> <INDENT> ind += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind -= a <NEWLINE> <DEDENT> ind = ind % len ( lst ) <NEWLINE> lst . pop ( ind ) <NEWLINE> ind = ind % len ( lst ) <NEWLINE> <NL> <DEDENT> qlst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for q in qlst : <NEWLINE> <INDENT> qi = bl ( lst , q ) <NEWLINE> if qi >= len ( lst ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( lst [ qi ] == q ) ) <NEWLINE> <DEDENT> <DEDENT>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> ans += bisect . bisect_left ( a , a [ i ] + a [ j ] ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = T <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if t [ i + 1 ] - t [ i ] >= T : <NEWLINE> <INDENT> ans += T <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans += t [ i + 1 ] - t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : break <NEWLINE> x , y = map ( int , n . split ( ) ) <NEWLINE> if x > y : print ( y , x ) <NEWLINE> else : print ( n ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , key = None , prev = None , next = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . prev = prev <NEWLINE> self . next = next <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class DoublyLinkedList ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . head = Node ( ) <NEWLINE> self . head . next = self . head <NEWLINE> self . head . prev = self . head <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> node = Node ( key = x , prev = self . head , next = self . head . next ) <NEWLINE> self . head . next . prev = node <NEWLINE> self . head . next = node <NEWLINE> <NL> <DEDENT> def search ( self , x ) : <NEWLINE> <INDENT> node = self . head . next <NEWLINE> while node is not self . head and node . key != x : <NEWLINE> <INDENT> node = node . next <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def delete_key ( self , x ) : <NEWLINE> <INDENT> node = self . search ( x ) <NEWLINE> self . _delete ( node ) <NEWLINE> <NL> <DEDENT> def _delete ( self , node ) : <NEWLINE> <INDENT> if node is self . head : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> node . prev . next = node . next <NEWLINE> node . next . prev = node . prev <NEWLINE> <NL> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . _delete ( self . head . next ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . _delete ( self . head . prev ) <NEWLINE> <NL> <DEDENT> def getKeys ( self ) : <NEWLINE> <INDENT> node = self . head . next <NEWLINE> keys = [ ] <NEWLINE> while node is not self . head : <NEWLINE> <INDENT> keys . append ( node . key ) <NEWLINE> node = node . next <NEWLINE> <DEDENT> return <STRING> . join ( keys ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> L = DoublyLinkedList ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> x = i [ 7 : - 1 ] <NEWLINE> L . insert ( x ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> L . deleteFirst ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> L . deleteLast ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> x = i [ 7 : - 1 ] <NEWLINE> L . delete_key ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( L . getKeys ( ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N_MAX = 200000 + 5 <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( N_MAX ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> Arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> K = 43 <NEWLINE> <NL> <COMMENT> <NL> A = Arr [ 0 ] <NEWLINE> B = Arr [ 1 ] <NEWLINE> <NL> S = A + B <NEWLINE> X = 0 <NEWLINE> for i in range ( 2 , len ( Arr ) ) : <NEWLINE> <INDENT> X ^= Arr [ i ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> dp = [ [ [ - 1 for x in [ 0 , 1 ] ] for _ in [ 0 , 1 ] ] for _ in range ( K ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] [ 0 ] = 0 <COMMENT> <NEWLINE> <NL> v = 1 <NEWLINE> for i in range ( K - 1 ) : <COMMENT> <NEWLINE> <INDENT> cx = X & 1 <COMMENT> <NEWLINE> cs = S & 1 <COMMENT> <NEWLINE> ca = A & 1 <COMMENT> <NEWLINE> for j in range ( 2 ) : <COMMENT> <NEWLINE> <INDENT> for k in range ( 2 ) : <COMMENT> <NEWLINE> <INDENT> if dp [ i ] [ j ] [ k ] == - 1 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for na in range ( 2 ) : <NEWLINE> <INDENT> for nb in range ( 2 ) : <NEWLINE> <INDENT> ni = i + 1 <NEWLINE> nj = 0 <NEWLINE> nk = k <NEWLINE> if na ^ nb != cx : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ns = na + nb + j <NEWLINE> if ns % 2 != cs : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if ns >= 2 : <COMMENT> <NEWLINE> <INDENT> nj = 1 <NEWLINE> <NL> <DEDENT> if ca < na : <NEWLINE> <INDENT> nk = 1 <NEWLINE> <DEDENT> elif ca == na : <NEWLINE> <INDENT> nk = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nk = 0 <NEWLINE> <NL> <DEDENT> dp [ ni ] [ nj ] [ nk ] = max ( dp [ ni ] [ nj ] [ nk ] , dp [ i ] [ j ] [ k ] | ( v * na ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> X >>= 1 <NEWLINE> S >>= 1 <NEWLINE> A >>= 1 <NEWLINE> v <<= 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> a = dp [ K - 1 ] [ 0 ] [ 0 ] <NEWLINE> if a == - 1 or a == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Arr [ 0 ] - a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> def TreasureHunt ( ) : <NEWLINE> <INDENT> x , y = ( 0.0 , 0.0 ) <NEWLINE> alpha = 90 <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> x += a * math . cos ( alpha / 180.0 * math . pi ) <NEWLINE> y += a * math . sin ( alpha / 180.0 * math . pi ) <NEWLINE> alpha = ( alpha - b + 360 ) % 360 <NEWLINE> <NL> <DEDENT> print ( int ( x ) ) <NEWLINE> print ( int ( y ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> TreasureHunt ( ) <NEWLINE>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( pi * r ** 2 , pi * r * 2 ) <NEWLINE> <NL>
a = input ( ) . split ( ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <NL> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <NL> <INDENT> b [ len ( b ) - 2 ] = b [ len ( b ) - 2 ] + b [ len ( b ) - 1 ] ; <NEWLINE> del b [ len ( b ) - 1 ] <NEWLINE> <NL> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <NL> <INDENT> b [ len ( b ) - 2 ] = b [ len ( b ) - 2 ] - b [ len ( b ) - 1 ] ; <NEWLINE> del b [ len ( b ) - 1 ] <NEWLINE> <NL> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <NL> <INDENT> b [ len ( b ) - 2 ] = b [ len ( b ) - 2 ] * b [ len ( b ) - 1 ] ; <NEWLINE> del b [ len ( b ) - 1 ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> b . append ( int ( a [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( b [ len ( b ) - 1 ] ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == 0 and k % 2 == 0 : print ( 0 ) <NEWLINE> if x == 0 and k % 2 == 1 : print ( d ) <NEWLINE> <NL> if x > 0 and x >= k * d : print ( x - k * d ) <NEWLINE> if x > 0 and x < k * d : <NEWLINE> <INDENT> if ( ( x - x % d ) // d ) % 2 == k % 2 : print ( x % d ) <NEWLINE> else : print ( abs ( x % d - d ) ) <NEWLINE> <DEDENT> if x < 0 and - x >= k * d : print ( - x - k * d ) <NEWLINE> if x < 0 and - x < k * d : <NEWLINE> <INDENT> if ( ( abs ( x ) - abs ( x ) % d ) // d ) % 2 == k % 2 : print ( - x % d ) <NEWLINE> else : print ( abs ( - x % d - d ) ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> while b <= a : <NEWLINE> <INDENT> b *= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> while c <= b : <NEWLINE> <INDENT> c *= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( <STRING> if ans <= k else <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> upper = ( N - 1 ) * ( N - 2 ) // 2 <NEWLINE> if upper < K : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = upper - K <NEWLINE> edges = [ ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> edges . append ( ( 1 , i ) ) <NEWLINE> <DEDENT> j = 2 <NEWLINE> while diff > 0 : <NEWLINE> <INDENT> k = j + 1 <NEWLINE> while k <= N and diff > 0 : <NEWLINE> <INDENT> edges . append ( ( j , k ) ) <NEWLINE> k += 1 <NEWLINE> diff -= 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> print ( len ( edges ) ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> print ( * e ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N , K = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> N = len ( A ) <NEWLINE> <NL> def get_keys_from_value ( d , val ) : <NEWLINE> <INDENT> return [ k for k , v in d . items ( ) if v == val ] [ 0 ] <NEWLINE> <NL> <DEDENT> now = 0 <NEWLINE> lis = [ ] <NEWLINE> p = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now = A [ now ] <NEWLINE> if now in p : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> p [ now ] = i <NEWLINE> lis . append ( now ) <NEWLINE> <NL> <DEDENT> if K < i : <NEWLINE> <INDENT> print ( lis [ K - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( lis [ ( K - i - 1 ) % ( i - p [ now ] ) + p [ now ] ] + 1 ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> result = 0 <NEWLINE> max_height = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> an = a [ i ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> max_height = an <NEWLINE> max_height_idx = 0 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if an >= max_height : <NEWLINE> <INDENT> max_height = an <NEWLINE> max_height_idx = i <NEWLINE> continue <NEWLINE> <NL> <DEDENT> result += ( max_height - an ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def gcd_kai ( * numbers ) : <NEWLINE> <INDENT> return reduce ( gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> if K == 1 : <NEWLINE> <INDENT> next <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( K - 1 ) * K * 3 <NEWLINE> ans_sub = 0 <NEWLINE> for i in range ( 2 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( i , K + 1 ) : <NEWLINE> <INDENT> ans_sub += gcd_kai ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += ans_sub * 3 <NEWLINE> for i in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( X ) > D * K : <NEWLINE> <INDENT> abso = abs ( X ) - D * K <NEWLINE> print ( abso ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> div = abs ( X ) // D <NEWLINE> mod = abs ( X ) % D <COMMENT> <NEWLINE> if ( K - div ) % 2 == 0 : <COMMENT> <NEWLINE> <INDENT> print ( mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - mod ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( n , r ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if n == 0 and r == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> cards = [ n - i for i in range ( n ) ] <NEWLINE> for _ in range ( r ) : <NEWLINE> <INDENT> ( p , c ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> cards = cards [ p - 1 : p - 1 + c ] + cards [ : p - 1 ] + cards [ p - 1 + c : ] <NEWLINE> <DEDENT> print ( cards [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> <COMMENT> <NL> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> fs = factorize ( N ) <NEWLINE> <NL> from collections import Counter <NEWLINE> c = Counter ( fs ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 1 <NEWLINE> for k , v in c . items ( ) : <NEWLINE> <INDENT> k2 , v2 = k , v <NEWLINE> while v2 >= i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> v2 -= i <NEWLINE> i += 1 <NEWLINE> <DEDENT> i = 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> f_i = sys . stdin <NEWLINE> <NL> n = int ( f_i . readline ( ) ) <NEWLINE> <NL> class VCost : <NEWLINE> <INDENT> def __init__ ( self , v , cost ) : <NEWLINE> <INDENT> self . v_n = v <NEWLINE> self . cost = cost <NEWLINE> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . cost < other . cost <NEWLINE> <DEDENT> def __gt__ ( self , other ) : <NEWLINE> <INDENT> return self . cost > other . cost <NEWLINE> <NL> <DEDENT> <DEDENT> adj = [ [ VCost ( int ( v ) , int ( c ) ) for v , c in zip ( x . split ( ) [ 2 : : 2 ] , x . split ( ) [ 3 : : 2 ] ) ] for x in f_i ] <NEWLINE> <NL> import heapq <NEWLINE> <NL> def dijkstra ( ) : <NEWLINE> <INDENT> PQ = [ ] <NEWLINE> isVisited = [ False ] * n <NEWLINE> distance = [ 999900001 ] * n <NEWLINE> <NL> distance [ 0 ] = 0 <NEWLINE> heapq . heappush ( PQ , VCost ( 0 , 0 ) ) <NEWLINE> <NL> while PQ : <NEWLINE> <INDENT> uc = heapq . heappop ( PQ ) <NEWLINE> u = uc . v_n <NEWLINE> <NL> if uc . cost > distance [ uc . v_n ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> isVisited [ u ] = True <NEWLINE> <NL> for vc in adj [ u ] : <NEWLINE> <INDENT> v = vc . v_n <NEWLINE> if isVisited [ v ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t_cost = distance [ u ] + vc . cost <NEWLINE> if t_cost < distance [ v ] : <NEWLINE> <INDENT> distance [ v ] = t_cost = distance [ u ] + vc . cost <NEWLINE> heapq . heappush ( PQ , VCost ( v , t_cost ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for v , d in enumerate ( distance ) : <NEWLINE> <INDENT> print ( v , d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dijkstra ( ) <NEWLINE>
import heapq <NEWLINE> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for _ in range ( 10 ** 5 + 1 ) ] <COMMENT> <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ a ] . append ( - b ) <NEWLINE> <DEDENT> q = [ ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for b in AB [ i ] : <NEWLINE> <INDENT> heapq . heappush ( q , b ) <NEWLINE> <DEDENT> if len ( q ) > 0 : <NEWLINE> <INDENT> ans += - heapq . heappop ( q ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
<NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import bisect <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> ans [ 0 ] = 1 <NEWLINE> dp = [ l [ 0 ] ] <NEWLINE> <NL> def dfs ( now , bef ) : <NEWLINE> <NL> <INDENT> change = True <NEWLINE> if l [ now ] > dp [ - 1 ] : <NEWLINE> <INDENT> dp . append ( l [ now ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = bisect . bisect_left ( dp , l [ now ] ) <NEWLINE> change = False <NEWLINE> s = dp [ index ] <NEWLINE> dp [ index ] = l [ now ] <NEWLINE> <DEDENT> ans [ now ] = len ( dp ) <NEWLINE> <NL> for nex in e [ now ] : <NEWLINE> <INDENT> if nex != bef : <NEWLINE> <INDENT> dfs ( nex , now ) <NEWLINE> <DEDENT> <DEDENT> if change : <NEWLINE> <INDENT> dp . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ index ] = s <NEWLINE> <NL> <DEDENT> <DEDENT> for i in e [ 0 ] : <NEWLINE> <INDENT> dfs ( i , 0 ) <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> import itertools <NEWLINE> <NL> <COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> i = K <NEWLINE> while ( i <= N + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> max = ( ( N - i + 1 + N ) * i ) / 2 <NEWLINE> min = ( ( 0 + i - 1 ) * i ) / 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = ans + ( max - min ) + 1 <NEWLINE> <NL> i = i + 1 <NEWLINE> <NL> <NL> <DEDENT> print ( int ( ans ) % 1000000007 ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n , m = ( 2 * x - y ) / 3 , ( 2 * y - x ) / 3 <NEWLINE> ans = 0 <NEWLINE> if n >= 0 and m >= 0 : <NEWLINE> <INDENT> n , m = int ( n ) , int ( m ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( min ( m , n ) ) : <NEWLINE> <INDENT> ans = ans * ( n + m - i ) % mod <NEWLINE> ans *= pow ( i + 1 , mod - 2 , mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
def isprime ( n ) : <NEWLINE> <INDENT> if n < 2 : return 0 <NEWLINE> elif n == 2 : return 1 <NEWLINE> <NL> if n % 2 == 0 : return 0 <NEWLINE> <NL> for i in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> if i > n / i : return 1 <NEWLINE> if n % i == 0 : return 0 <NEWLINE> <NL> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> n = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> a = [ i for i in n if isprime ( i ) ] <NEWLINE> <NL> print ( len ( a ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> m_a = a [ - 1 ] + 1 <NEWLINE> <COMMENT> <NL> dp = [ 0 ] * m_a <NEWLINE> <NL> for i in a : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i ] += 1 <NEWLINE> <COMMENT> <NL> if dp [ i ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( i * 2 , m_a , i ) : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ j ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> s += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> n = int ( n ) <NEWLINE> if n % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ 0 ] * n <NEWLINE> a [ 0 ] = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> an = int ( input ( ) ) <NEWLINE> a [ i ] = max ( an , a [ i - 1 ] + an ) <NEWLINE> <DEDENT> print ( max ( a ) ) <NEWLINE> <DEDENT>
class UnionFindTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uft = UnionFindTree ( N ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uft . union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( - min ( uft . parents ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> global cnt <NEWLINE> cnt = 0 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> cnt += mid - left - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( int ) ( ( left + right ) / 2 ) <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mergeSort ( S , 0 , n ) <NEWLINE> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> c = 1 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> c *= l [ i ] <NEWLINE> i += 1 <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c <= 1000000000000000000 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total += A [ i ] <NEWLINE> <DEDENT> if A [ M - 1 ] >= total / ( 4 * M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ 0 ] * n <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if i + l [ i ] + 1 < n : <NEWLINE> <INDENT> d [ i + l [ i ] ] += 1 <NEWLINE> <DEDENT> if i - l [ i ] + 1 > 0 : <NEWLINE> <INDENT> cnt += d [ i - l [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = n // i <NEWLINE> k = num * i * ( num + 1 ) <NEWLINE> ans += k // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> countlist = [ 0 for i in range ( n ) ] <NEWLINE> for j in range ( n - 1 ) : <NEWLINE> <INDENT> countlist [ a [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( countlist [ i ] ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LRD = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> adj_list = [ [ ] for _ in range ( N ) ] <NEWLINE> for lrd in LRD : <NEWLINE> <INDENT> l , r , d = lrd <NEWLINE> adj_list [ l - 1 ] . append ( ( l - 1 , r - 1 , d ) ) <NEWLINE> adj_list [ r - 1 ] . append ( ( r - 1 , l - 1 , - d ) ) <NEWLINE> <NL> <DEDENT> X = [ None ] * N <NEWLINE> import collections <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] is not None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q = collections . deque ( adj_list [ i ] ) <NEWLINE> X [ i ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> src , nxt , d = q . pop ( ) <NEWLINE> if X [ nxt ] is not None : <NEWLINE> <INDENT> if X [ nxt ] != X [ src ] + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> X [ nxt ] = X [ src ] + d <NEWLINE> q . extend ( adj_list [ nxt ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> N = input ( ) <NEWLINE> As = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BCs = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> BCs . append ( tuple ( map ( int , ( input ( ) . split ( ) ) ) ) ) <NEWLINE> <NL> <DEDENT> counter = dict ( Counter ( As ) ) <NEWLINE> sum_ = sum ( As ) <NEWLINE> <NL> for BC in BCs : <NEWLINE> <INDENT> if not BC [ 0 ] in counter : <NEWLINE> <INDENT> counter [ BC [ 0 ] ] = 0 <NEWLINE> <DEDENT> if not BC [ 1 ] in counter : <NEWLINE> <INDENT> counter [ BC [ 1 ] ] = 0 <NEWLINE> <DEDENT> sa = BC [ 1 ] - BC [ 0 ] <NEWLINE> sum_ += counter [ BC [ 0 ] ] * sa <NEWLINE> counter [ BC [ 1 ] ] = counter [ BC [ 1 ] ] + counter [ BC [ 0 ] ] <NEWLINE> counter [ BC [ 0 ] ] = 0 <NEWLINE> <COMMENT> <NL> print ( sum_ ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> al = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> sakai = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> k += 26 ** ( i + 1 ) <NEWLINE> sakai . append ( k ) <NEWLINE> <NL> <DEDENT> if n <= 26 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> u = 1 <NEWLINE> <DEDENT> elif n > sakai [ 9 ] : <NEWLINE> <INDENT> n -= sakai [ 9 ] + 1 <NEWLINE> u = 11 <NEWLINE> <DEDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> if ( sakai [ i ] < n <= sakai [ i + 1 ] ) : <NEWLINE> <INDENT> n -= sakai [ i ] + 1 <NEWLINE> u = i + 2 <NEWLINE> <NL> <DEDENT> <DEDENT> def base ( n ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> while ( n >= 26 ) : <NEWLINE> <INDENT> r = n % 26 <NEWLINE> n = ( n - r ) // 26 <NEWLINE> ans . append ( r ) <NEWLINE> <DEDENT> ans . append ( n ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> p = base ( n ) <NEWLINE> <NL> if u - len ( p ) > 0 : <NEWLINE> <INDENT> ans_3 = <STRING> <NEWLINE> if u - len ( p ) > 1 : <NEWLINE> <INDENT> for j in range ( u - len ( p ) - 1 ) : <NEWLINE> <INDENT> ans_3 += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans_2 = al [ p [ len ( p ) - i - 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_2 = ans_2 + al [ p [ len ( p ) - i - 1 ] ] <NEWLINE> <DEDENT> <DEDENT> if u - len ( p ) > 0 : <NEWLINE> <INDENT> print ( ans_3 + ans_2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_2 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> ans = 1 <NEWLINE> L . sort ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans *= L [ i ] <NEWLINE> if ans == 0 or ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( l ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ [ None ] * 2000 for i in range ( 2000 ) ] <NEWLINE> <NL> <NL> def exhaustivesearch ( i , target ) : <NEWLINE> <INDENT> if memo [ i ] [ target ] is not None : <NEWLINE> <INDENT> return memo [ i ] [ target ] <NEWLINE> <DEDENT> if target == 0 : <NEWLINE> <INDENT> memo [ i ] [ target ] = True <NEWLINE> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> memo [ i ] [ target ] = False <NEWLINE> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ i ] [ target ] = exhaustivesearch ( i + 1 , target ) or exhaustivesearch ( i + 1 , target - A [ i ] ) <NEWLINE> return memo [ i ] [ target ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for j in m : <NEWLINE> <INDENT> if exhaustivesearch ( 0 , j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> input_list = input ( ) <NEWLINE> area = 0 <NEWLINE> depth_arr = deque ( ) <NEWLINE> area_arr = deque ( ) <NEWLINE> <NL> for i , input_str in enumerate ( input_list ) : <NEWLINE> <INDENT> if <STRING> == input_str : <NEWLINE> <INDENT> depth_arr . append ( i ) <NEWLINE> <DEDENT> elif <STRING> == input_str : <NEWLINE> <INDENT> if len ( depth_arr ) : <NEWLINE> <INDENT> position = depth_arr . pop ( ) <NEWLINE> pool = i - position <NEWLINE> area += pool <NEWLINE> <NL> while len ( area_arr ) : <NEWLINE> <INDENT> pre_position , pre_pool = area_arr . pop ( ) <NEWLINE> if position <= pre_position : <NEWLINE> <INDENT> pool += pre_pool <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> area_arr . append ( ( pre_position , pre_pool ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> area_arr . append ( ( position , pool ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> areas = 0 <NEWLINE> for pos , pool in area_arr : <NEWLINE> <INDENT> areas += pool <NEWLINE> <DEDENT> print ( areas ) <NEWLINE> print ( len ( area_arr ) , * [ list [ 1 ] for list in area_arr ] ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import jit <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> @ jit ( cache = True ) <NEWLINE> def solve ( A ) : <NEWLINE> <INDENT> count = np . zeros ( 10 ** 6 + 10 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> if count [ x ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count [ : : x ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> ans += count [ x ] == 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A ) <NEWLINE> print ( solve ( A ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> N , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> A = np . array ( sorted ( [ int ( _ ) for _ in input ( ) . split ( ) ] ) ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> lb = - 10 ** 18 - 1 <NEWLINE> rb = 10 ** 18 + 1 <NEWLINE> <NL> def check ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> l = 0 <NEWLINE> r = i <NEWLINE> if a > 0 : <NEWLINE> <INDENT> l = - 1 <NEWLINE> r = np . searchsorted ( A , x // a , side = <STRING> ) <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> l = np . searchsorted ( A , 0 - x // ( - a ) , side = <STRING> ) <NEWLINE> r = N + 1 <NEWLINE> <DEDENT> elif x < 0 : <NEWLINE> <INDENT> r = 0 <NEWLINE> <DEDENT> l = min ( max ( l , 0 ) , i ) <NEWLINE> r = max ( min ( r , i ) , 0 ) <NEWLINE> cnt += r - l <NEWLINE> <DEDENT> return cnt >= K <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> while rb - lb > 1 : <NEWLINE> <INDENT> mid = ( rb + lb ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> rb = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lb = mid <NEWLINE> <DEDENT> <DEDENT> print ( rb ) <NEWLINE> <NL> <NL> <DEDENT> solve ( N , K , A ) <NEWLINE>
import sys <NEWLINE> import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , K , L , R = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> a = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> m = n // 2 <NEWLINE> ls = [ [ ] for _ in range ( m + 1 ) ] <NEWLINE> for i in range ( 1 << m ) : <NEWLINE> <INDENT> ls [ bin ( i ) . count ( <STRING> ) ] . append ( sum ( [ a [ j ] for j in range ( m ) if i >> j & 1 ] ) ) <NEWLINE> <DEDENT> for i in range ( m + 1 ) : <NEWLINE> <INDENT> ls [ i ] . sort ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 << n - m ) : <NEWLINE> <INDENT> cnt = bin ( i ) . count ( <STRING> ) <NEWLINE> val = sum ( [ a [ m + j ] for j in range ( n - m ) if i >> j & 1 ] ) <NEWLINE> if K - m <= cnt <= K : <NEWLINE> <INDENT> ans += bisect . bisect_right ( ls [ K - cnt ] , R - val ) - bisect . bisect_right ( ls [ K - cnt ] , L - val - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> m = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> m *= x <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from math import ceil , floor , factorial , gcd , sqrt , log2 , cos , sin , tan , acos , asin , atan , degrees , radians , pi , inf , comb <NEWLINE> from itertools import accumulate , groupby , permutations , combinations , product , combinations_with_replacement <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from queue import Queue , LifoQueue , PriorityQueue <NEWLINE> from copy import deepcopy <NEWLINE> from time import time <NEWLINE> from functools import reduce <NEWLINE> import string <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n = INT ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = n - r - g <NEWLINE> ans = comb ( n , 3 ) - ( comb ( r , 2 ) + comb ( g , 2 ) + comb ( b , 2 ) ) * ( n - 2 ) + ( comb ( r , 3 ) + comb ( g , 3 ) + comb ( b , 3 ) ) * 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = 1 <NEWLINE> j = i + d <NEWLINE> k = j + d <NEWLINE> while k < n : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> d += 1 <NEWLINE> j += 1 <NEWLINE> k += 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 13 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> mod2 = 10 ** 9 + 9 <NEWLINE> sa = [ S ( ) for _ in range ( 2 ) ] <NEWLINE> ml = min ( map ( len , sa ) ) <NEWLINE> ss = [ ] <NEWLINE> r = 0 <NEWLINE> for si in range ( 2 ) : <NEWLINE> <INDENT> s = sa [ si ] <NEWLINE> a = [ 0 ] <NEWLINE> a2 = [ 0 ] <NEWLINE> b = [ set ( ) for _ in range ( ml ) ] <NEWLINE> b2 = [ set ( ) for _ in range ( ml ) ] <NEWLINE> for c in s : <NEWLINE> <INDENT> k = 97 ** ( ord ( c ) - ord ( <STRING> ) ) <NEWLINE> a . append ( ( a [ - 1 ] + k ) % mod ) <NEWLINE> a2 . append ( ( a2 [ - 1 ] + k ) % mod2 ) <NEWLINE> <DEDENT> if si == 1 : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( a ) ) : <NEWLINE> <INDENT> if j - i > ml : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if j - i <= r : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( a [ j ] - a [ i ] ) % mod in ss [ 0 ] [ j - i - 1 ] and ( a2 [ j ] - a2 [ i ] ) % mod2 in ss [ 1 ] [ j - i - 1 ] : <NEWLINE> <INDENT> r = j - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( a ) ) : <NEWLINE> <INDENT> if j - i > ml : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b [ j - i - 1 ] . add ( ( a [ j ] - a [ i ] ) % mod ) <NEWLINE> b2 [ j - i - 1 ] . add ( ( a2 [ j ] - a2 [ i ] ) % mod2 ) <NEWLINE> <DEDENT> <DEDENT> ss = [ b , b2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> delta = 0 <NEWLINE> if N > 1 : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( i - 1 ) * i < 2 * N < i * ( i + 1 ) : <NEWLINE> <INDENT> delta = i * ( i + 1 ) // 2 - N <NEWLINE> res_list = list ( range ( 1 , i + 1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> elif 2 * N == i * ( i + 1 ) : <NEWLINE> <INDENT> res_list = range ( 1 , i + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> res_list = [ 1 ] <NEWLINE> <NL> <DEDENT> if delta > 0 : <NEWLINE> <INDENT> while delta > res_list [ - 1 ] : <NEWLINE> <INDENT> delta -= res_list [ - 1 ] <NEWLINE> del res_list [ - 1 ] <NEWLINE> <NL> <DEDENT> res_list . remove ( delta ) <NEWLINE> <NL> <NL> <DEDENT> for item in res_list : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> ans . append ( input ( ) ) <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> print ( j ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> H , W , T , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> que = [ ] <NEWLINE> state = [ [ 0 ] * ( W + 1 ) for i in range ( H + 1 ) ] <NEWLINE> data1 = [ [ 0 ] * ( W + 1 ) for i in range ( H + 1 ) ] <NEWLINE> data2 = [ [ 0 ] * ( W + 1 ) for i in range ( H + 1 ) ] <NEWLINE> def get ( data , h , w ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while h : <NEWLINE> <INDENT> w0 = w <NEWLINE> el = data [ h ] <NEWLINE> while w0 : <NEWLINE> <INDENT> s += el [ w0 ] <NEWLINE> w0 -= w0 & - w0 <NEWLINE> <DEDENT> h -= h & - h <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> def add ( data , h , w , x ) : <NEWLINE> <INDENT> while h <= H : <NEWLINE> <INDENT> w0 = w <NEWLINE> el = data [ h ] <NEWLINE> while w0 <= W : <NEWLINE> <INDENT> el [ w0 ] += x <NEWLINE> w0 += w0 & - w0 <NEWLINE> <DEDENT> h += h & - h <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( Q ) : <NEWLINE> <INDENT> t , c , * ps = map ( int , input ( ) . split ( ) ) <NEWLINE> while que and que [ 0 ] [ 0 ] <= t : <NEWLINE> <INDENT> _ , h0 , w0 = heappop ( que ) <NEWLINE> add ( data1 , h0 , w0 , - 1 ) <NEWLINE> add ( data2 , h0 , w0 , 1 ) <NEWLINE> state [ h0 ] [ w0 ] = 2 <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> h0 , w0 = ps <NEWLINE> state [ h0 ] [ w0 ] = 1 <NEWLINE> add ( data1 , h0 , w0 , 1 ) <NEWLINE> heappush ( que , ( t + T , h0 , w0 ) ) <NEWLINE> <DEDENT> elif c == 1 : <NEWLINE> <INDENT> h0 , w0 = ps <NEWLINE> if state [ h0 ] [ w0 ] == 2 : <NEWLINE> <INDENT> add ( data2 , h0 , w0 , - 1 ) <NEWLINE> state [ h0 ] [ w0 ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> h0 , w0 , h1 , w1 = ps <NEWLINE> result1 = get ( data1 , h1 , w1 ) - get ( data1 , h1 , w0 - 1 ) - get ( data1 , h0 - 1 , w1 ) + get ( data1 , h0 - 1 , w0 - 1 ) <NEWLINE> result2 = get ( data2 , h1 , w1 ) - get ( data2 , h1 , w0 - 1 ) - get ( data2 , h0 - 1 , w1 ) + get ( data2 , h0 - 1 , w0 - 1 ) <NEWLINE> print ( result2 , result1 ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 10 <NEWLINE> dp = [ INF ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ j ] + abs ( h [ j ] - h [ i ] ) for j in range ( max ( 0 , i - k ) , i ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d = Counter ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> def sum_from_counter ( d ) : <NEWLINE> <INDENT> return sum ( map ( lambda k : k * d [ k ] , d ) ) <NEWLINE> <NL> <DEDENT> s = sum ( map ( lambda k : k * d [ k ] , d ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d [ C ] = d . get ( C , 0 ) + d [ B ] <NEWLINE> s += ( C - B ) * d [ B ] <NEWLINE> d [ B ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
def calc ( X ) : <NEWLINE> <INDENT> A = 1 <NEWLINE> B = 1 <NEWLINE> if X == 0 : <NEWLINE> <INDENT> return A , B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_bound = 1 <NEWLINE> h_bound = 200 <NEWLINE> for i in range ( l_bound , h_bound ) : <NEWLINE> <INDENT> for j in range ( 0 , i + 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> A = i <NEWLINE> B = j <NEWLINE> return A , B <NEWLINE> <DEDENT> if i ** 5 + j ** 5 == X : <NEWLINE> <INDENT> A = i <NEWLINE> B = - j <NEWLINE> return A , B <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> A , B = calc ( X ) <NEWLINE> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> array = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> array . append ( a ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> data = [ 0 ] * 101 <NEWLINE> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> data [ array [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> m = [ i for i , j in enumerate ( data ) if j == max ( data ) ] <NEWLINE> for i in range ( len ( m ) ) : <NEWLINE> <INDENT> print ( m [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 ( i8 , i8 , i8 [ : , : ] ) , cache = True ) <NEWLINE> def solve ( R , C , items ) : <NEWLINE> <INDENT> dp = np . zeros ( ( R + 1 , C + 1 , 4 ) , dtype = np . int64 ) <NEWLINE> for i in range ( R ) : <NEWLINE> <INDENT> for j in range ( C ) : <NEWLINE> <INDENT> for k in range ( 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k + 1 ] = max ( dp [ i ] [ j ] [ k + 1 ] , dp [ i ] [ j ] [ k ] + items [ i ] [ j ] ) <NEWLINE> <DEDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] [ 0 ] = max ( dp [ i + 1 ] [ j ] [ 0 ] , dp [ i ] [ j ] [ k ] ) <NEWLINE> dp [ i ] [ j + 1 ] [ k ] = max ( dp [ i ] [ j + 1 ] [ k ] , dp [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ R ] [ C - 1 ] [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> R , C , K , * rcv = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> items = np . zeros ( ( R + 1 , C + 1 ) , dtype = np . int64 ) <NEWLINE> for r , c , v in zip ( * [ iter ( rcv ) ] * 3 ) : <NEWLINE> <INDENT> items [ r - 1 ] [ c - 1 ] = v <NEWLINE> <DEDENT> print ( solve ( R , C , items ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num = 7 <NEWLINE> i = 1 <NEWLINE> a = [ ] <NEWLINE> prir1 = 1 <NEWLINE> while i <= N : <NEWLINE> <INDENT> xx = num % N <NEWLINE> if xx == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> prir1 = 0 <NEWLINE> break <NEWLINE> <DEDENT> num = 10 * xx + 7 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if prir1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<NL> <NL> def solve ( N , X , M ) : <NEWLINE> <INDENT> if X == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> memo = [ - 1 ] * ( M + 3 ) <NEWLINE> acc = [ 0 ] * ( M + 4 ) <NEWLINE> x = X <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if memo [ x ] >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> acc [ i + 1 ] = acc [ i ] + x <NEWLINE> memo [ x ] = i <NEWLINE> x = ( x * x ) % M <NEWLINE> <NL> <NL> <DEDENT> end = i <NEWLINE> start = memo [ x ] <NEWLINE> cycle = end - start <NEWLINE> <NL> if N < end : <NEWLINE> <INDENT> return acc [ N ] <NEWLINE> <NL> <DEDENT> cycle_sum = acc [ end ] - acc [ start ] <NEWLINE> <NL> res = acc [ start ] <NEWLINE> <NL> N -= start <NEWLINE> res += ( N // cycle ) * cycle_sum <NEWLINE> res += acc [ start + ( N % cycle ) ] - acc [ start ] <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( N , X , M ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> training = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> training = i * training % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( training ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Acum = [ 0 ] * n <NEWLINE> Bcum = [ 0 ] * m <NEWLINE> Acum [ 0 ] = A [ 0 ] <NEWLINE> Bcum [ 0 ] = B [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> Acum [ i ] = Acum [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> Bcum [ i ] = Bcum [ i - 1 ] + B [ i ] <NEWLINE> <NL> <DEDENT> mx = 0 <NEWLINE> <NL> import bisect <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> rest = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = k - Acum [ i - 1 ] <NEWLINE> cnt = i <NEWLINE> if rest < 0 : continue <NEWLINE> <NL> <DEDENT> idx = bisect . bisect_right ( Bcum , rest ) <NEWLINE> cnt += idx <NEWLINE> <NL> if cnt > mx : <NEWLINE> <INDENT> mx = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mx ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 1 ] <NEWLINE> di = { } <NEWLINE> di [ 1 ] = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b = a [ l [ - 1 ] - 1 ] <NEWLINE> if b in di : <NEWLINE> <INDENT> x = b <NEWLINE> break <NEWLINE> <DEDENT> l . append ( b ) <NEWLINE> di [ b ] = 1 <NEWLINE> <DEDENT> t1 = 0 <NEWLINE> for j in l : <NEWLINE> <INDENT> if j == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> t2 = len ( l ) - t1 <NEWLINE> if k <= t1 : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> aa = ( k - t1 ) % t2 <NEWLINE> print ( l [ t1 + aa ] ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> con = True <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans *= x [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> con = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if con : print ( ans ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> candi = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> or s [ 0 ] == <STRING> : <NEWLINE> <INDENT> candi . append ( s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> col_s = collections . Counter ( candi ) <NEWLINE> combi_s = itertools . combinations ( list ( col_s ) , 3 ) <NEWLINE> counter = 0 <NEWLINE> for i in combi_s : <NEWLINE> <INDENT> counter += col_s [ i [ 0 ] ] * col_s [ i [ 1 ] ] * col_s [ i [ 2 ] ] <NEWLINE> <DEDENT> print ( counter ) <NEWLINE>
def is_ok ( index , key ) : <NEWLINE> <INDENT> return B [ index ] <= key <NEWLINE> <NL> <DEDENT> def upper_bound ( key ) : <NEWLINE> <INDENT> ng = len ( B ) <NEWLINE> ok = - 1 <NEWLINE> <NL> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid , key ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> tmpA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmpB = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> <COMMENT> <NL> if A : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = A [ i ] + tmpA [ i ] <NEWLINE> if tmp > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if B : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> tmp = B [ i ] + tmpB [ i ] <NEWLINE> if tmp > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> answer = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> key = k - A [ i ] <NEWLINE> answer = max ( answer , upper_bound ( key ) + i ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <NL> <DEDENT> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> primes = factorization ( M ) <NEWLINE> <COMMENT> <NL> <NL> if N == 1 or M == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for p , cnt in primes : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( 1 , min ( cnt , N ) + 1 ) : <NEWLINE> <INDENT> tmp += cmb ( N , i , mod ) * cmb ( cnt - 1 , i - 1 , mod ) <NEWLINE> <COMMENT> <NL> tmp %= mod <NEWLINE> <DEDENT> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> vals = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> rslt = 1 <NEWLINE> <NL> if 0 in vals : <NEWLINE> <INDENT> rslt = 0 <NEWLINE> <NL> <DEDENT> for v in vals : <NEWLINE> <INDENT> rslt = rslt * v <NEWLINE> <NL> if rslt > 10 ** 18 : <NEWLINE> <INDENT> rslt = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( rslt ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ j ] == s [ i + j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> a . append ( cnt ) <NEWLINE> <DEDENT> print ( len ( t ) - max ( a ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def main ( N , K , P , C ) : <COMMENT> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = - 10 ** 9 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> cycleIDs = np . full ( N , - 1 , dtype = np . int64 ) <NEWLINE> cycleInfs = [ ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> cycleID = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <NL> <INDENT> v = n <NEWLINE> currentCycleItemCnt = 0 <NEWLINE> currentCycleTotal = 0 <NEWLINE> <NL> if cycleIDs [ v ] != - 1 : <NEWLINE> <INDENT> currentCycleItemCnt , currentCycleTotal = cycleInfs [ cycleIDs [ v ] ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> currentCycleItemCnt += 1 <NEWLINE> currentCycleTotal += C [ v ] <NEWLINE> <NL> v = P [ v ] <NEWLINE> if v == n : <NEWLINE> <COMMENT> <NL> <INDENT> cycleInfs . append ( ( currentCycleItemCnt , currentCycleTotal ) ) <NEWLINE> cycleID += 1 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cycleIDs [ v ] = cycleID <NEWLINE> <NL> <DEDENT> <DEDENT> procCnt = 0 <NEWLINE> currentCycleSumTmp = 0 <NEWLINE> <NL> while True : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> procCnt += 1 <NEWLINE> currentCycleSumTmp += C [ v ] <NEWLINE> if K < procCnt : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cycleLoopCnt = 0 <NEWLINE> if procCnt < K and 0 < currentCycleTotal : <NEWLINE> <INDENT> cycleLoopCnt = int ( ( K - procCnt ) // currentCycleItemCnt ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> tmp = currentCycleSumTmp + cycleLoopCnt * currentCycleTotal <NEWLINE> ans = max ( int ( ans ) , int ( tmp ) ) <NEWLINE> <NL> v = P [ v ] <NEWLINE> if v == n : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> P -= 1 <NEWLINE> C = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , K , P , C ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , m , * pqc = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> g = { } <NEWLINE> M = iter ( pqc ) <NEWLINE> <NL> for p , q , c in zip ( M , M , M ) : <NEWLINE> <INDENT> pc = ( ( p - 1 ) << 20 ) + c <NEWLINE> qc = ( ( q - 1 ) << 20 ) + c <NEWLINE> pp = ( p - 1 ) << 20 <NEWLINE> qq = ( q - 1 ) << 20 <NEWLINE> <NL> if pc not in g : g [ pc ] = [ ] <NEWLINE> if qc not in g : g [ qc ] = [ ] <NEWLINE> if pp not in g : g [ pp ] = [ ] <NEWLINE> if qq not in g : g [ qq ] = [ ] <NEWLINE> <NL> g [ pc ] . append ( qc ) <NEWLINE> g [ pc ] . append ( pp ) <NEWLINE> <NL> g [ qc ] . append ( pc ) <NEWLINE> g [ qc ] . append ( qq ) <NEWLINE> <NL> g [ pp ] . append ( pc ) <NEWLINE> g [ qq ] . append ( qc ) <NEWLINE> <NL> <DEDENT> if 0 not in g : g [ 0 ] = [ ] <NEWLINE> <NL> from collections import deque <NEWLINE> q = deque ( [ ( 0 , 0 ) ] ) <NEWLINE> res = { 0 : 0 } <NEWLINE> <NL> mask = ( 1 << 20 ) - 1 <NEWLINE> while q : <NEWLINE> <INDENT> vl , dv = q . popleft ( ) <NEWLINE> if res [ vl ] < dv : continue <NEWLINE> if ( vl >> 20 ) == n - 1 : <NEWLINE> <INDENT> res [ ( n - 1 ) << 20 ] = dv + 1 <NEWLINE> break <NEWLINE> <DEDENT> for tl in g [ vl ] : <NEWLINE> <INDENT> ndv = dv + ( vl & mask == 0 or tl & mask == 0 ) <NEWLINE> if tl not in res or res [ tl ] > ndv : <NEWLINE> <INDENT> res [ tl ] = ndv <NEWLINE> if vl & mask == 0 or tl & mask == 0 : <NEWLINE> <INDENT> q . append ( ( tl , ndv ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . appendleft ( ( tl , ndv ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( n - 1 ) << 20 in res : <NEWLINE> <INDENT> print ( res [ ( n - 1 ) << 20 ] // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hyouka = [ 0 ] * ( N - K + 1 ) <NEWLINE> <STRING> <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if As [ i ] < As [ i + K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> ( * a , ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ただの倍数 = 1 <NEWLINE> for i in set ( a ) : <NEWLINE> <INDENT> ただの倍数 *= i <NEWLINE> <DEDENT> ans = ただの倍数 / sum ( ただの倍数 // i for i in a ) <NEWLINE> print ( [ ans , int ( ans ) ] [ ans % 1 == 0 ] ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> N , D , A = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> AB . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> imos = [ 0 ] * ( N + 1 ) <NEWLINE> ans = 0 <NEWLINE> R = 0 <NEWLINE> for l in range ( N ) : <NEWLINE> <INDENT> if l : <NEWLINE> <INDENT> imos [ l ] += imos [ l - 1 ] <NEWLINE> <DEDENT> x = AB [ l ] [ 0 ] <NEWLINE> h = AB [ l ] [ 1 ] <NEWLINE> if imos [ l ] < h : <NEWLINE> <INDENT> R = max ( R , l + 1 ) <NEWLINE> while R < N and AB [ R ] [ 0 ] <= 2 * D + x : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> d = h - imos [ l ] <NEWLINE> cnt = ( d + A - 1 ) // A <NEWLINE> imos [ l ] += cnt * A <NEWLINE> imos [ R ] -= cnt * A <NEWLINE> ans += cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def dfs ( i , j , s ) : <NEWLINE> <INDENT> if j > 3 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if j == 3 and s == x : <NEWLINE> <INDENT> ans . append ( 1 ) <NEWLINE> <NL> <DEDENT> for k in range ( 1 , i ) : <NEWLINE> <INDENT> if s + k > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dfs ( k , j + 1 , s + k ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> dfs ( i , 1 , i ) <NEWLINE> <NL> <DEDENT> print ( sum ( ans ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> a = 0 <NEWLINE> count = [ ] <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> count . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> count . append ( a ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( list ( map ( int , count ) ) ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < 0 and b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , K = mi ( ) <NEWLINE> A = li ( ) <NEWLINE> flag = [ 0 ] * N <NEWLINE> l = [ ] <NEWLINE> i = 1 <NEWLINE> ind = 0 <NEWLINE> while True : <NEWLINE> <INDENT> flag [ ind ] = i <NEWLINE> l . append ( ind + 1 ) <NEWLINE> if not flag [ A [ ind ] - 1 ] : <NEWLINE> <INDENT> ind = A [ ind ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = A [ ind ] - 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if K <= flag [ ind ] - 1 : <NEWLINE> <INDENT> print ( l [ K ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ind != 0 : <NEWLINE> <INDENT> K -= flag [ ind ] - 1 <NEWLINE> i -= flag [ ind ] - 1 <NEWLINE> l = l [ flag [ ind ] - 1 : ] <NEWLINE> <DEDENT> print ( l [ K % i ] ) <NEWLINE>
n = input ( ) <NEWLINE> countArray = [ 0 ] * 2019 <NEWLINE> count = 0 <NEWLINE> countArray [ 0 ] += 1 <NEWLINE> nums = 0 <NEWLINE> for i in range ( len ( n ) ) [ : : - 1 ] : <NEWLINE> <INDENT> nums = nums + int ( n [ len ( n ) - 1 - i ] ) * pow ( 10 , i , 2019 ) <NEWLINE> countArray [ nums % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> for i in countArray : <NEWLINE> <INDENT> count += ( i * ( i - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> for B in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from time import time <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ - 1 for i in range ( N ) ] <NEWLINE> <NL> visited = [ ] <NEWLINE> now = 0 <NEWLINE> loopstarts = None <NEWLINE> looplength = None <NEWLINE> t0 = time ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if L [ now ] != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ now ] = i <NEWLINE> visited . append ( now ) <NEWLINE> now = A [ now ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> loopstarts = visited . index ( now ) <NEWLINE> looplength = len ( visited ) - loopstarts <NEWLINE> <NL> if K < loopstarts : <NEWLINE> <INDENT> print ( visited [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( visited [ loopstarts + ( K - loopstarts ) % looplength ] + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> i = min ( n , b - 1 ) <NEWLINE> print ( int ( a * i / b ) - a * int ( i / b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> from math import gcd <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ 0 ] * 1000001 <NEWLINE> for a in A : C [ a ] += 1 <NEWLINE> if reduce ( gcd , A ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif all ( sum ( C [ i : : i ] ) <= 1 for i in range ( 2 , 1000001 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> good = set ( range ( n ) ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a_ , b_ = map ( int , input ( ) . split ( ) ) <NEWLINE> a_ -= 1 <NEWLINE> b_ -= 1 <NEWLINE> if h [ a_ ] == h [ b_ ] : <NEWLINE> <INDENT> if a_ in good : <NEWLINE> <INDENT> good . remove ( a_ ) <NEWLINE> <DEDENT> if b_ in good : <NEWLINE> <INDENT> good . remove ( b_ ) <NEWLINE> <DEDENT> <DEDENT> elif h [ a_ ] < h [ b_ ] : <NEWLINE> <INDENT> if a_ in good : <NEWLINE> <INDENT> good . remove ( a_ ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b_ in good : <NEWLINE> <INDENT> good . remove ( b_ ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( good ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def document_it ( func ) : <NEWLINE> <INDENT> def new_function ( * args , ** kwargs ) : <NEWLINE> <INDENT> print ( <STRING> , func . __name__ ) <NEWLINE> print ( <STRING> , args ) <NEWLINE> print ( <STRING> , kwargs ) <NEWLINE> result = func ( * args , ** kwargs ) <NEWLINE> print ( <STRING> , result ) <NEWLINE> return result <NEWLINE> <DEDENT> return new_function <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def bsearch ( v , list , l = None ) : <NEWLINE> <INDENT> if l == 0 or list == [ ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if l == None : <NEWLINE> <INDENT> l = len ( list ) <NEWLINE> <NL> <DEDENT> import math <NEWLINE> T = math . ceil ( math . log2 ( l ) ) <NEWLINE> t = 0 <NEWLINE> wid = l <NEWLINE> offset = 0 <NEWLINE> while t <= T : <NEWLINE> <INDENT> if wid == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> pos = wid // 2 + offset <NEWLINE> w = list [ pos ] <NEWLINE> if wid == 1 : <NEWLINE> <INDENT> if v == w : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if v == w : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif v < w : <NEWLINE> <INDENT> wid = wid // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wid = wid // 2 - 1 + wid % 2 <NEWLINE> offset = pos + 1 <NEWLINE> <DEDENT> <DEDENT> t += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def exe ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for t in T : <NEWLINE> <INDENT> if bsearch ( t , S , n ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> exe ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> num = int ( sys . stdin . readline ( ) ) <NEWLINE> i += 1 <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i , num ) ) <NEWLINE> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> nl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in nl : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> lim = 10 ** 18 <NEWLINE> <NL> for i in nl : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > lim : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import re <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> key = None <NEWLINE> left = None <NEWLINE> right = None <NEWLINE> def __init__ ( self , k ) : <NEWLINE> <INDENT> self . key = k <NEWLINE> <NL> <DEDENT> <DEDENT> class BST : <NEWLINE> <INDENT> root = None <NEWLINE> def insert ( self , k ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> y = None <NEWLINE> z = Node ( k ) <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < y . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> elif y . key < z . key : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <DEDENT> <DEDENT> if y is None : <NEWLINE> <COMMENT> <NL> <INDENT> self . root = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> elif y . key < z . key : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> def preorder ( self , r , lis ) : <NEWLINE> <COMMENT> <NL> <INDENT> if r != None : <NEWLINE> <INDENT> lis . append ( r . key ) <NEWLINE> self . preorder ( r . left , lis ) <NEWLINE> self . preorder ( r . right , lis ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> bst = BST ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> query = input ( ) . split ( ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> bst . insert ( int ( query [ 1 ] ) ) <NEWLINE> <DEDENT> elif query [ 0 ] == <STRING> : <NEWLINE> <INDENT> root = bst . root <NEWLINE> lis = [ ] <NEWLINE> bst . preorder ( root , lis ) <NEWLINE> print ( <STRING> + <STRING> . join ( list ( map ( str , sorted ( lis ) ) ) ) ) <NEWLINE> print ( <STRING> + <STRING> . join ( list ( map ( str , lis ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , X , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> x = { } <NEWLINE> <NL> ruiseki = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> cnt = 1 <NEWLINE> ans = X <NEWLINE> c = X <NEWLINE> ruiseki [ 1 ] = ans <NEWLINE> while cnt < N : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> next = c ** 2 % M <NEWLINE> if next in x . keys ( ) : <NEWLINE> <INDENT> y = x [ next ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if N == cnt : <NEWLINE> <INDENT> print ( ans + next ) <NEWLINE> return <NEWLINE> <DEDENT> loop = ruiseki [ cnt ] - ruiseki [ y - 1 ] <NEWLINE> loopcnt = cnt - y + 1 <NEWLINE> ans += ( ( N - cnt ) // loopcnt ) * loop <NEWLINE> <COMMENT> <NL> amari = ( N - cnt ) % loopcnt <NEWLINE> <COMMENT> <NL> if amari != 0 : <NEWLINE> <INDENT> ans += ruiseki [ y - 1 + amari ] - ruiseki [ y - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> break <NEWLINE> <NL> <DEDENT> ans += next <NEWLINE> cnt += 1 <NEWLINE> ruiseki [ cnt ] = next <NEWLINE> ruiseki [ cnt ] += ruiseki [ cnt - 1 ] <NEWLINE> c = next <NEWLINE> x [ next ] = cnt <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = [ 1 ] * N <NEWLINE> <NL> <NL> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> flg [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> flg [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg [ a - 1 ] = flg [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( flg . count ( 1 ) ) <NEWLINE> <NL>
from collections import deque <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = [ list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> d = deque ( s ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if len ( t [ i ] ) == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( int ( t [ i ] [ 1 ] ) + cnt ) % 2 != 0 : <NEWLINE> <INDENT> d . appendleft ( t [ i ] [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . append ( t [ i ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt % 2 != 0 : <NEWLINE> <INDENT> d = list ( d ) [ : : - 1 ] <NEWLINE> <DEDENT> print ( <STRING> . join ( d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] * ( n ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> [ print ( i ) for i in ans ] <NEWLINE>
import heapq <NEWLINE> import math <NEWLINE> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def C ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += math . ceil ( A [ i ] / m ) - 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> l , r = 0 , max ( A ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if C ( mid ) <= K : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( [ 1 for z in range ( k + 1 ) for y in range ( k + 1 ) if 0 <= s - z - y <= k ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxa = a [ - 1 ] + 1 <NEWLINE> tf = [ False ] * maxa <NEWLINE> r = 0 <NEWLINE> n -= 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_i = a [ i ] <NEWLINE> if tf [ a_i ] == False : <NEWLINE> <INDENT> for j in range ( a_i , maxa , a_i ) : <NEWLINE> <INDENT> tf [ j ] = True <NEWLINE> <DEDENT> if a_i < a [ i + 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if tf [ - 1 ] == False : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> F = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> fl = min ( F ) ; fr = max ( F ) <NEWLINE> G = { i for i in range ( 1 , 14 ) } - F - { 7 } <NEWLINE> gl = min ( G ) ; gr = max ( G ) <NEWLINE> <NL> memo = { } <NEWLINE> def dfs ( s , t , u ) : <NEWLINE> <INDENT> if ( s , t , u ) in memo : <NEWLINE> <INDENT> return memo [ s , t , u ] <NEWLINE> <DEDENT> T = [ G , F ] [ u ] <NEWLINE> res = 0 <NEWLINE> if s - 1 in T : <NEWLINE> <INDENT> if s - 1 <= [ gl , fl ] [ u ] and [ gr , fr ] [ u ] <= t : <NEWLINE> <INDENT> res = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res |= dfs ( s - 1 , t , u ^ 1 ) ^ 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if t + 1 in T : <NEWLINE> <INDENT> if s <= [ gl , fl ] [ u ] and [ gr , fr ] [ u ] <= t + 1 : <NEWLINE> <INDENT> res = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res |= dfs ( s , t + 1 , u ^ 1 ) ^ 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if s - 1 not in T and t + 1 not in T : <NEWLINE> <INDENT> res = dfs ( s , t , u ^ 1 ) ^ 1 <NEWLINE> <DEDENT> memo [ s , t , u ] = res <NEWLINE> return res <NEWLINE> <DEDENT> print ( [ <STRING> , <STRING> ] [ dfs ( 7 , 7 , 1 ) ] ) <NEWLINE> <DEDENT>
INF = 10 ** 18 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> for val in a : <NEWLINE> <INDENT> ans *= val <NEWLINE> if val == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ans > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> f = True <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> P , X = [ ] , [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( p ) <NEWLINE> X . append ( x ) <NEWLINE> <NL> <DEDENT> t_sum = sum ( T ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> print ( t_sum - T [ P [ i ] - 1 ] + X [ i ] ) <NEWLINE> <DEDENT>
n , a_start , b_start , a_goal , b_goal = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> no_rock_double = True <NEWLINE> for i in range ( a_start , max ( b_goal , a_goal ) ) : <NEWLINE> <INDENT> if i + 1 < n : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> no_rock_double = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> can_switch = False <NEWLINE> if a_goal > b_goal : <NEWLINE> <INDENT> for i in range ( b_start - 1 , b_goal ) : <NEWLINE> <INDENT> if s [ i - 1 : i + 2 ] == <STRING> : <NEWLINE> <INDENT> can_switch = True <NEWLINE> <DEDENT> <DEDENT> if no_rock_double and can_switch : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if no_rock_double : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> class Combi ( ) : <NEWLINE> <INDENT> def __init__ ( self , N , mod ) : <NEWLINE> <INDENT> self . power = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> self . rev = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> self . mod = mod <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> self . power [ i ] = ( self . power [ i - 1 ] * i ) % self . mod <NEWLINE> <DEDENT> self . rev [ N ] = pow ( self . power [ N ] , self . mod - 2 , self . mod ) <NEWLINE> for j in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> self . rev [ j - 1 ] = ( self . rev [ j ] * j ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def com ( self , K , R ) : <NEWLINE> <INDENT> if K < R : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( self . power [ K ] ) * ( self . rev [ K - R ] ) * ( self . rev [ R ] ) ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def pom ( self , K , R ) : <NEWLINE> <INDENT> if K < R : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( self . power [ K ] ) * ( self . rev [ K - R ] ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> c = Combi ( N , mod ) <NEWLINE> <NL> ans = 0 <NEWLINE> if K == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ans += c . com ( i , K - 1 ) * a <NEWLINE> ans -= c . com ( N - 1 - i , K - 1 ) * a <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ [ ] * w for _ in range ( h ) ] <NEWLINE> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if t [ j ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> s [ i ] . append ( 10 ** 5 ) <NEWLINE> <DEDENT> elif t [ j ] == <STRING> : <NEWLINE> <INDENT> s [ i ] . append ( t [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> now = [ 0 , 0 ] <NEWLINE> steps = [ ] <NEWLINE> steps . append ( now ) <NEWLINE> direction = [ ] <NEWLINE> s [ 0 ] [ 0 ] = 0 <NEWLINE> a = [ 2 ] <NEWLINE> while len ( steps ) > 0 : <NEWLINE> <INDENT> now = copy . copy ( steps [ 0 ] ) <NEWLINE> if s [ now [ 0 ] ] [ now [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in [ [ 0 , 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> now = copy . copy ( steps [ 0 ] ) <NEWLINE> if now [ 0 ] + k [ 0 ] >= 0 and now [ 0 ] + k [ 0 ] < h : <NEWLINE> <INDENT> now [ 0 ] += k [ 0 ] <NEWLINE> if now [ 1 ] + k [ 1 ] >= 0 and now [ 1 ] + k [ 1 ] < w : <NEWLINE> <INDENT> now [ 1 ] += k [ 1 ] <NEWLINE> if s [ now [ 0 ] ] [ now [ 1 ] ] == 10 ** 5 : <NEWLINE> <INDENT> if not [ now [ 0 ] , now [ 1 ] ] in steps : <NEWLINE> <INDENT> steps . append ( [ now [ 0 ] , now [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if s [ steps [ 0 ] [ 0 ] ] [ steps [ 0 ] [ 1 ] ] > 10 ** 4 : <NEWLINE> <INDENT> direction = [ ] <NEWLINE> for l in [ [ 0 , 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> if steps [ 0 ] [ 0 ] + l [ 0 ] >= 0 and steps [ 0 ] [ 0 ] + l [ 0 ] < h and steps [ 0 ] [ 1 ] + l [ 1 ] < w and steps [ 0 ] [ 1 ] + l [ 1 ] >= 0 and s [ steps [ 0 ] [ 0 ] + l [ 0 ] ] [ steps [ 0 ] [ 1 ] + l [ 1 ] ] != <STRING> : <NEWLINE> <INDENT> s [ steps [ 0 ] [ 0 ] ] [ steps [ 0 ] [ 1 ] ] = min ( s [ steps [ 0 ] [ 0 ] + l [ 0 ] ] [ steps [ 0 ] [ 1 ] + l [ 1 ] ] + 1 , s [ steps [ 0 ] [ 0 ] ] [ steps [ 0 ] [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> steps . pop ( 0 ) <NEWLINE> <DEDENT> if s [ h - 1 ] [ w - 1 ] == <STRING> or s [ h - 1 ] [ w - 1 ] == 10 ** 5 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( white - 1 - s [ h - 1 ] [ w - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ls = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> sum1 = sum ( ls ) % m <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum1 = sum1 - ls [ i ] <NEWLINE> ans = ( ( sum1 * ls [ i ] ) + ans ) % m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> s = deque ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query = list ( input ( ) . split ( ) ) <NEWLINE> if query [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( cnt + int ( query [ 1 ] ) ) % 2 == 1 : <NEWLINE> <INDENT> s . appendleft ( query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( query [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> s = reversed ( s ) <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> A = [ int ( a [ i ] ) for i in range ( N ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> Query = [ input ( ) . split ( ) for i in range ( Q ) ] <NEWLINE> SUM = sum ( A ) <NEWLINE> A_count = Counter ( A ) <NEWLINE> num = [ A_count [ i + 1 ] for i in range ( 100000 ) ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B = int ( Query [ i ] [ 0 ] ) <NEWLINE> C = int ( Query [ i ] [ 1 ] ) <NEWLINE> SUM += ( C - B ) * num [ B - 1 ] <NEWLINE> print ( SUM ) <NEWLINE> num [ C - 1 ] += num [ B - 1 ] <NEWLINE> num [ B - 1 ] = 0 <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> N = len ( S ) <NEWLINE> d = { } <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <NL> <DEDENT> d [ 0 ] = 1 <NEWLINE> <NL> mod = 0 <NEWLINE> dig = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> mod += dig * int ( S [ N - 1 - i ] ) <NEWLINE> mod %= 2019 <NEWLINE> d [ mod ] += 1 <NEWLINE> dig *= 10 <NEWLINE> dig %= 2019 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for k in d . keys ( ) : <NEWLINE> <INDENT> v = d [ k ] <NEWLINE> if v > 1 : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( d [ i + 1 ] ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> un = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> un . union ( a , b ) <NEWLINE> <DEDENT> print ( un . group_count ( ) - 1 ) <NEWLINE>
import math <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> a = ( m * ( m + 1 ) ) // 2 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( i + 1 , m ) : <NEWLINE> <INDENT> b += math . gcd ( i + 1 , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( i + 1 , m ) : <NEWLINE> <INDENT> l = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( j + 1 , m ) : <NEWLINE> <INDENT> c += math . gcd ( l , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a + b * 6 + c * 6 ) <NEWLINE>
import numpy as np <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> gcd2 = np . zeros ( ( K + 1 , K + 1 ) , dtype = int ) <NEWLINE> <NL> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> gcd2 [ i , j ] = gcd2 [ j , i ] = np . gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd2 [ i , i ] = i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += 3 * gcd2 [ i , j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> ans += 3 * gcd2 [ i , j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> ans += 6 * gcd2 [ i , gcd2 [ j , k ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> RGB = [ list ( ) ] * 3 <NEWLINE> color = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> RGB [ 0 ] = [ i for i , s in enumerate ( S ) if s == color [ 0 ] ] <NEWLINE> RGB [ 1 ] = [ i for i , s in enumerate ( S ) if s == color [ 1 ] ] <NEWLINE> RGB [ 2 ] = [ i for i , s in enumerate ( S ) if s == color [ 2 ] ] <NEWLINE> <NL> order = sorted ( [ 0 , 1 , 2 ] , key = lambda i : len ( RGB [ i ] ) ) <NEWLINE> color = [ color [ i ] for i in order ] <NEWLINE> RGB = [ RGB [ i ] for i in order ] <NEWLINE> <NL> <COMMENT> <NL> ans = len ( RGB [ 0 ] ) * len ( RGB [ 1 ] ) * len ( RGB [ 2 ] ) <NEWLINE> for c1 in RGB [ 0 ] : <NEWLINE> <INDENT> for c2 in RGB [ 1 ] : <NEWLINE> <INDENT> p = c1 * 2 - c2 <NEWLINE> if 0 <= p and p < N and S [ p ] == color [ 2 ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> p = c2 * 2 - c1 <NEWLINE> if 0 <= p and p < N and S [ p ] == color [ 2 ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> if ( c1 + c2 ) % 2 == 0 and S [ ( c1 + c2 ) // 2 ] == color [ 2 ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> x = 0 <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif k <= a + b + c : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> mul = A [ 0 ] <NEWLINE> <NL> if np . sum ( A < 0 ) % 2 == 1 : <NEWLINE> <INDENT> for i in A [ 1 : ] : <NEWLINE> <INDENT> mul *= i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in A [ 1 : ] : <NEWLINE> <INDENT> if 1000000000000000000 / i < mul : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> mul *= i <NEWLINE> <NL> <DEDENT> <DEDENT> if mul > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> print ( mul ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> B = [ 0 for i in range ( N ) ] <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i - 1 ] = B [ i - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in B : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> ai = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ai = ( ai * 10 + 7 ) % K <NEWLINE> i += 1 <NEWLINE> if ai == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Al = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> maxAl = Al [ - 1 ] <NEWLINE> markl = [ - 1 ] * ( maxAl + 1 ) <NEWLINE> <NL> for i in Al : <NEWLINE> <INDENT> if markl [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if markl [ i ] == 0 : <NEWLINE> <INDENT> markl [ i ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> markl [ i ] = 0 <NEWLINE> p = i * 2 <NEWLINE> while p <= maxAl : <NEWLINE> <INDENT> markl [ p ] = 1 <NEWLINE> p += i <NEWLINE> <DEDENT> <DEDENT> print ( markl . count ( 0 ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> dp = np . array ( [ np . inf ] * N ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i - K >= 0 : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - K : i ] + abs ( h [ i ] - h [ i - K : i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ 0 : i ] + abs ( h [ i ] - h [ 0 : i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( dp [ N - 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> pre = [ arr [ 0 ] ] <NEWLINE> for i in range ( 1 , len ( arr ) ) : <NEWLINE> <INDENT> pre . append ( ( pre [ - 1 ] + arr [ i ] ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( arr ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> ans += ( pre [ i - 1 ] * arr [ i ] ) <NEWLINE> <DEDENT> print ( ans % ( ( 10 ** 9 ) + ( 7 ) ) ) <NEWLINE>
<COMMENT> <NL> import math as m <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * m . pi , 2 * r * m . pi ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( S . count ( <STRING> ) ) <NEWLINE>
import numpy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> res . append ( A [ 0 ] ) <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> res . append ( res [ i ] + A [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sum += A [ i ] * ( res [ N - 1 ] - res [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> result = [ ] <NEWLINE> count = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> <NL> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> cnt += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> p = <STRING> * i <NEWLINE> if p in N : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
alpha = <STRING> <NEWLINE> inp = input ( ) <NEWLINE> def split ( w ) : <NEWLINE> <INDENT> return [ all for all in w ] <NEWLINE> <DEDENT> alpha = split ( alpha ) <NEWLINE> x = alpha . index ( inp ) <NEWLINE> try : <NEWLINE> <INDENT> print ( alpha [ x + 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb = [ tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> x = [ 0 ] * h <NEWLINE> y = [ 0 ] * w <NEWLINE> <NL> for h , w in bomb : <NEWLINE> <INDENT> x [ h ] += 1 <NEWLINE> y [ w ] += 1 <NEWLINE> <NL> <DEDENT> maxX = max ( x ) <NEWLINE> maxY = max ( y ) <NEWLINE> <NL> r = [ h for h , x in enumerate ( x ) if x == maxX ] <NEWLINE> c = [ w for w , y in enumerate ( y ) if y == maxY ] <NEWLINE> <NL> bomb = set ( bomb ) <NEWLINE> <NL> for ri in r : <NEWLINE> <INDENT> for ci in c : <NEWLINE> <INDENT> if ( ri , ci ) not in bomb : <NEWLINE> <INDENT> print ( maxX + maxY ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( maxX + maxY - 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> <NL> PC = True <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> MAX = A [ 0 ] + 1 <NEWLINE> mp = [ 0 ] * MAX <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> mp [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> if sum ( mp [ i : : i ] ) > 1 : <NEWLINE> <INDENT> PC = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if PC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if reduce ( gcd , A ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> x = float ( input ( ) ) <NEWLINE> print ( x ** 2 * math . pi , x * 2 * math . pi ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = collections . Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s = [ 0 for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> sa = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] += a [ i ] <NEWLINE> sa += i * a [ i ] <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> b , c = map ( int , x . split ( ) ) <NEWLINE> s [ c ] += s [ b ] <NEWLINE> sa = sa + c * s [ b ] - b * s [ b ] <NEWLINE> s [ b ] = 0 <NEWLINE> print ( sa ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> n_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> s = sum ( n_list ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> <NL> for num in n_list : <NEWLINE> <INDENT> s -= num <NEWLINE> result += num * s % m <NEWLINE> result %= m <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z <= k and z >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <NL> <INDENT> N_machi , K_teleport = map ( int , input ( ) . split ( ) ) <NEWLINE> to_teleport = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited_city = [ 1 ] <NEWLINE> order = [ - 1 for i in range ( N_machi + 1 ) ] <NEWLINE> order [ 1 ] = 0 <NEWLINE> next_city = 1 <NEWLINE> <NL> for i in range ( N_machi ) : <NEWLINE> <INDENT> next_city = to_teleport [ next_city - 1 ] <NEWLINE> tmp = order [ next_city ] <NEWLINE> <NL> if ( tmp == - 1 ) : <NEWLINE> <INDENT> visited_city . append ( next_city ) <NEWLINE> order [ next_city ] = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> first = order [ next_city ] <NEWLINE> len_loop = len ( visited_city ) - first <NEWLINE> <NL> if ( K_teleport < first ) : <NEWLINE> <INDENT> ans = visited_city [ K_teleport ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = ( K_teleport - first ) % len_loop <NEWLINE> ans = visited_city [ first + mod ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> x = A [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> x = min ( x , A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
array = [ 0 for i in range ( 100001 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> array [ a ] += 1 <NEWLINE> <DEDENT> souwa = sum ( A ) <NEWLINE> <NL> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> souwa = souwa + ( C [ i ] - B [ i ] ) * array [ B [ i ] ] <NEWLINE> array [ C [ i ] ] += array [ B [ i ] ] <NEWLINE> array [ B [ i ] ] = 0 <NEWLINE> print ( souwa ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> a , b = nm ( ) <NEWLINE> <NL> n = math . gcd ( a , b ) <NEWLINE> <NL> count = 1 <COMMENT> <NEWLINE> for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n = n / i <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b [ j ] += b [ j - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> bc = m <NEWLINE> <NL> for ac in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ ac ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> while a [ ac ] + b [ bc ] > k : <NEWLINE> <INDENT> bc -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , ac + bc ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
k = int ( input ( ) ) <NEWLINE> rm = 7 % k <NEWLINE> an = - 1 <NEWLINE> for i in range ( 10 ** 6 ) : <NEWLINE> <INDENT> if rm == 0 : <NEWLINE> <INDENT> an = i + 1 ; break <NEWLINE> <DEDENT> rm = ( rm * 10 + 7 ) % k <NEWLINE> <DEDENT> print ( an ) <NEWLINE>
<NL> XKD = input ( ) . split ( <STRING> ) <NEWLINE> X = int ( XKD [ 0 ] ) <NEWLINE> K = int ( XKD [ 1 ] ) <NEWLINE> D = int ( XKD [ 2 ] ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> if ( X >= K * D ) : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = int ( ( X - X % D ) / D ) <NEWLINE> if ( ( K - k ) % 2 == 0 ) : <NEWLINE> <INDENT> print ( X % D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X % D - D ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> out = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = n // ( i + 1 ) <NEWLINE> out += ( i + 1 ) * k * ( k + 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( int ( out ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> import math <NEWLINE> d = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> f = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g = math . gcd ( f , c ) <NEWLINE> d += g <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> fact = [ ( i , i ** 5 ) for i in range ( - 10 ** 3 , 10 ** 3 ) ] <NEWLINE> <NL> for i in range ( 0 , len ( fact ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( fact ) ) : <NEWLINE> <INDENT> if abs ( fact [ i ] [ 1 ] - fact [ j ] [ 1 ] ) == X : <NEWLINE> <INDENT> A = fact [ j ] [ 0 ] <NEWLINE> B = fact [ i ] [ 0 ] <NEWLINE> break ; <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> l = i <NEWLINE> r = N - i <NEWLINE> print ( l , r ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> l = 1 <NEWLINE> r = N - 1 <NEWLINE> cnt = 0 <NEWLINE> while cnt < M : <NEWLINE> <INDENT> if not flag and r - l <= N // 2 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> print ( l , r ) <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT>
def abc177d ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> check = [ - 1 ] * n <NEWLINE> group_no = 0 <NEWLINE> group = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if check [ a ] == check [ b ] != - 1 : continue <NEWLINE> if check [ a ] == check [ b ] == - 1 : <NEWLINE> <INDENT> group [ group_no ] = { a , b } <NEWLINE> check [ a ] = check [ b ] = group_no <NEWLINE> group_no += 1 <NEWLINE> <DEDENT> elif check [ a ] == - 1 or check [ b ] == - 1 : <NEWLINE> <INDENT> max_g = max ( check [ a ] , check [ b ] ) <NEWLINE> group [ max_g ] |= { a , b } <NEWLINE> check [ b ] = check [ a ] = max_g <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re = min ( check [ a ] , check [ b ] ) <NEWLINE> de = max ( check [ a ] , check [ b ] ) <NEWLINE> for v in group [ de ] : <NEWLINE> <INDENT> check [ v ] = re <NEWLINE> <DEDENT> group [ re ] |= group [ de ] <NEWLINE> del group [ de ] <NEWLINE> <DEDENT> <DEDENT> max_val = max ( map ( len , group . values ( ) ) ) <NEWLINE> print ( max ( 1 , max_val ) ) <NEWLINE> <NL> <NL> <DEDENT> abc177d ( ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> m = 2 * 10 ** 9 <NEWLINE> l = [ ] <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> p = 0 <NEWLINE> <COMMENT> <NL> while p < 1000 : <NEWLINE> <INDENT> b = a ** 5 <NEWLINE> l . append ( b ) <NEWLINE> a += 1 <NEWLINE> p += 1 <NEWLINE> <NL> <NL> <DEDENT> flg = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <NL> <INDENT> if flg == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( i + 1 , len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] + l [ j ] == x : <NEWLINE> <INDENT> res = [ i , - j ] <NEWLINE> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif l [ i ] - l [ j ] == x : <NEWLINE> <INDENT> res = [ i , j ] <NEWLINE> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif - l [ i ] + l [ j ] == x : <NEWLINE> <INDENT> res = [ - i , - j ] <NEWLINE> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif - l [ i ] - l [ j ] == x : <NEWLINE> <INDENT> res = [ - i , j ] <NEWLINE> flg = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res [ 0 ] , res [ 1 ] ) <NEWLINE>
import numpy <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> self . parent = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , i ) : <NEWLINE> <INDENT> if self . parent [ i ] < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> r = self . root ( self . parent [ i ] ) <NEWLINE> self . parent [ i ] = r <NEWLINE> return r <NEWLINE> <NL> <DEDENT> def unite ( self , i , j ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = self . root ( i ) <NEWLINE> j = self . root ( j ) <NEWLINE> <COMMENT> <NL> <NL> if i == j : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if i > j : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <NL> <DEDENT> self . parent [ i ] += self . parent [ j ] <NEWLINE> self . parent [ j ] = i <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def same ( self , i , j ) : <NEWLINE> <INDENT> return self . root ( i ) == self . root ( j ) <NEWLINE> <NL> <DEDENT> def size ( self , i ) : <NEWLINE> <INDENT> return - self . parent [ self . root ( i ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> R = numpy . array ( [ [ int ( r ) for r in input ( ) . split ( ) ] for _ in range ( M ) ] ) - 1 <NEWLINE> <NL> forest = UnionFind ( N ) <NEWLINE> for p1 , p2 in R : <NEWLINE> <INDENT> forest . unite ( p1 , p2 ) <NEWLINE> <NL> <DEDENT> s = [ forest . size ( i ) for i in range ( N ) ] <NEWLINE> print ( max ( s ) ) <NEWLINE>
def pcmod ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 1 + pcmod ( n % bin ( n ) . count ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> m_1 = x . count ( 1 ) - 1 <NEWLINE> m_0 = x . count ( 1 ) + 1 <NEWLINE> baser_1 = 0 <NEWLINE> baser_0 = 0 <NEWLINE> if m_1 != 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> baser_1 += x [ i ] * pow ( 2 , ( n - 1 - i ) , m_1 ) <NEWLINE> baser_1 %= m_1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> baser_0 += x [ i ] * pow ( 2 , ( n - 1 - i ) , m_0 ) <NEWLINE> baser_0 %= m_0 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> if x [ i ] == 1 : <NEWLINE> <INDENT> if m_1 == 0 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> t = ( baser_1 - pow ( 2 , ( n - 1 - i ) , m_1 ) ) % m_1 <NEWLINE> a = pcmod ( t ) <NEWLINE> <NL> <DEDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> t = ( baser_0 + pow ( 2 , ( n - 1 - i ) , m_0 ) ) % m_0 <NEWLINE> a = pcmod ( t ) <NEWLINE> <DEDENT> ans [ i ] = a <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) + 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ ] <NEWLINE> for i in range ( 100005 ) : <NEWLINE> <INDENT> cnt . append ( 0 ) <NEWLINE> <DEDENT> sum = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 100005 ) : <NEWLINE> <INDENT> sum += i * cnt [ i ] <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( sum ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if A < B and A + T * V >= B + T * W : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif B < A and A - T * V <= B - T * W : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ ] <NEWLINE> r_sum = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> num . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> line_sum = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> line_sum += num [ i ] [ j ] <NEWLINE> <DEDENT> num [ i ] . append ( line_sum ) <NEWLINE> <DEDENT> for i in range ( c + 1 ) : <NEWLINE> <INDENT> row_sum = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> row_sum += num [ j ] [ i ] <NEWLINE> <DEDENT> r_sum . append ( row_sum ) <NEWLINE> <DEDENT> num . append ( r_sum ) <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( str ( i ) for i in num [ i ] ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> b = 0 <NEWLINE> dp = [ True ] * ( a [ - 1 ] + 1 ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> if not dp [ ai ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( ai * 2 , a [ - 1 ] + 1 , ai ) : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> <DEDENT> if ai == b : <NEWLINE> <INDENT> dp [ ai ] = False <NEWLINE> <DEDENT> b = ai <NEWLINE> <DEDENT> print ( sum ( dp [ ai ] for ai in a ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for m in b : <NEWLINE> <INDENT> l_idx = bisect . bisect_left ( a , m ) <NEWLINE> u_idx = bisect . bisect_right ( c , m ) <NEWLINE> ans += l_idx * ( n - u_idx ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ll = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> dp = [ 0 ] * ( 3 * n ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for l , r in ll : <NEWLINE> <INDENT> dp [ l + i ] += dp [ i ] <NEWLINE> dp [ i + r + 1 ] -= dp [ i ] <NEWLINE> <DEDENT> dp [ i + 1 ] = ( dp [ i ] + dp [ i + 1 ] ) % 998244353 <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> cnt = collections . Counter ( a ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N * ( N - 1 ) ) // 2 ) <NEWLINE> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans1 = sum ( range ( 1 , N + 1 ) ) <NEWLINE> <NL> ans2 = 0 <NEWLINE> for x in itertools . combinations ( range ( 1 , N + 1 ) , 3 ) : <NEWLINE> <INDENT> ans2 = ans2 + math . gcd ( math . gcd ( x [ 0 ] , x [ 1 ] ) , x [ 2 ] ) ; <NEWLINE> <NL> <NL> <DEDENT> ans2 = ans2 * 6 <NEWLINE> <NL> ans3 = 0 <NEWLINE> for x in itertools . combinations ( range ( 1 , N + 1 ) , 2 ) : <NEWLINE> <INDENT> ans3 = ans3 + math . gcd ( math . gcd ( x [ 0 ] , x [ 0 ] ) , x [ 1 ] ) ; <NEWLINE> <NL> <NL> <DEDENT> ans3 = ans3 * 6 <NEWLINE> <NL> print ( ans1 + ans2 + ans3 ) <NEWLINE>
class Dictionary_class : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . dic = set ( ) <NEWLINE> <NL> <DEDENT> def insert ( self , str ) : <NEWLINE> <INDENT> self . dic . add ( str ) <NEWLINE> <NL> <DEDENT> def find ( self , str ) : <NEWLINE> <INDENT> if str in self . dic : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> answer = <STRING> <NEWLINE> dic = Dictionary_class ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> instruction = input ( ) . split ( ) <NEWLINE> if instruction [ 0 ] == <STRING> : <NEWLINE> <INDENT> dic . insert ( instruction [ 1 ] ) <NEWLINE> <DEDENT> elif instruction [ 0 ] == <STRING> : <NEWLINE> <INDENT> if dic . find ( instruction [ 1 ] ) : <NEWLINE> <INDENT> answer += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer , end = <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> num = 7 <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> num %= k <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num = num * 10 + 7 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tasizann = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tasizann = tasizann + A [ i ] <NEWLINE> <DEDENT> nijou = tasizann ** 2 <NEWLINE> nijouwa = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> nijouwa = nijouwa + A [ i ] ** 2 <NEWLINE> <DEDENT> ans = ( nijou - nijouwa ) // 2 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if x < y : <NEWLINE> <INDENT> a = x <NEWLINE> x = y <NEWLINE> y = a <NEWLINE> <NL> <DEDENT> def kouyakusu ( x , y ) : <NEWLINE> <INDENT> yakusu = x % y <NEWLINE> if yakusu == 0 : <NEWLINE> <INDENT> print ( y ) <NEWLINE> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kouyakusu ( y , yakusu ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_kouyakusu = kouyakusu ( x , y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tmp += arr [ i ] % 1000000007 <NEWLINE> ans += tmp * arr [ i + 1 ] % 1000000007 <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) ; <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in sorted ( A , reverse = True ) : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> ans = int ( 0 ) <NEWLINE> temp = int ( 0 ) <NEWLINE> MOD = int ( 1000000007 ) <NEWLINE> sumari = sum ( a ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sumari = sumari - a [ i ] <NEWLINE> temp = sumari % MOD <NEWLINE> temp = temp * a [ i ] <NEWLINE> temp = temp % MOD <NEWLINE> ans += temp <NEWLINE> ans = ans % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 20202020200 <NEWLINE> sum_A = 0 <NEWLINE> sum_B = sum ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum_A += A [ i ] <NEWLINE> sum_B -= A [ i ] <NEWLINE> tmp = abs ( sum_A - sum_B ) <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ str ( i ) for i in input ( ) ] <NEWLINE> <NL> search = [ ( <STRING> + str ( s ) ) [ - 3 : ] for s in range ( 0 , 1000 ) ] <NEWLINE> ans = [ ] <NEWLINE> for num in search : <NEWLINE> <INDENT> tmp_S = S <NEWLINE> if num [ 0 ] in tmp_S : <NEWLINE> <INDENT> tmp_S = tmp_S [ tmp_S . index ( num [ 0 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num [ 1 ] in tmp_S : <NEWLINE> <INDENT> tmp_S = tmp_S [ tmp_S . index ( num [ 1 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if num [ 2 ] in tmp_S : <NEWLINE> <INDENT> ans . append ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
L , R = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if R - L > 2019 * 2 : <NEWLINE> <INDENT> R -= ( ( R - L ) // 2019 - 1 ) * 2019 <NEWLINE> <DEDENT> ans = 2019 <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b - a + 1 <= k * 2 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( ( b - k + 1 ) , ( b + 1 ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> ss = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ss . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( ss ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> <NL> if k - a > 0 : <NEWLINE> <INDENT> num += a <NEWLINE> k -= a <NEWLINE> if k - b > 0 : <NEWLINE> <INDENT> k -= b <NEWLINE> print ( num - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> X = list ( input ( ) ) <NEWLINE> <NL> pc = X . count ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> if pc == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> sml = pc - 1 <NEWLINE> big = pc + 1 <NEWLINE> <NL> b = 0 <NEWLINE> mod_s = 0 <NEWLINE> mod_b = 0 <NEWLINE> for x in X [ : : - 1 ] : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> if sml : <NEWLINE> <INDENT> mod_s += pow ( 2 , b , sml ) <NEWLINE> mod_s %= sml <NEWLINE> <NL> <DEDENT> mod_b += pow ( 2 , b , big ) <NEWLINE> mod_b %= big <NEWLINE> <NL> <DEDENT> b += 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> ELE = [ ] <NEWLINE> <NL> b = 0 <NEWLINE> for x in X [ : : - 1 ] : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> t = ( mod_b + pow ( 2 , b , big ) ) % big <NEWLINE> ELE . append ( ( t , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( mod_s - pow ( 2 , b , sml ) ) % sml if sml else 0 <NEWLINE> <NL> if sml : <NEWLINE> <INDENT> ELE . append ( ( t , 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ELE . append ( ( 0 , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> b += 1 <NEWLINE> <NL> <NL> <DEDENT> def solve ( x , c ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return c <NEWLINE> <NL> <DEDENT> b = 0 <NEWLINE> nx = x <NEWLINE> while nx > 0 : <NEWLINE> <INDENT> b += nx & 1 <NEWLINE> nx >>= 1 <NEWLINE> <NL> <DEDENT> ret = solve ( x % b , c + 1 ) <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> ANS = [ ] <NEWLINE> for x , pc in ELE : <NEWLINE> <INDENT> ANS . append ( solve ( x , pc ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ANS [ : : - 1 ] ) ) ) <NEWLINE> <NL>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_ints2 ( x ) : return map ( lambda num : int ( num ) - x , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def GCD ( a : int , b : int ) -> int : return b if a % b == 0 else GCD ( b , a % b ) <NEWLINE> def LCM ( a : int , b : int ) -> int : return ( a * b ) // GCD ( a , b ) <NEWLINE> <NL> def popcount ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while num > 0 : <NEWLINE> <INDENT> num %= bin ( num ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> n = read_int ( ) <NEWLINE> x = read_str ( ) <NEWLINE> x_int = int ( x , 2 ) <NEWLINE> <NL> cnt = x . count ( <STRING> ) <NEWLINE> minus_cnt = cnt - 1 <NEWLINE> plus_cnt = cnt + 1 <NEWLINE> <NL> minus_mod = x_int % minus_cnt if minus_cnt != 0 else 0 <NEWLINE> plus_mod = x_int % plus_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( popcount ( ( plus_mod + pow ( 2 , n - 1 - i , plus_cnt ) ) % plus_cnt ) + 1 ) <NEWLINE> <DEDENT> elif minus_cnt != 0 : <NEWLINE> <INDENT> print ( popcount ( ( minus_mod - pow ( 2 , n - 1 - i , minus_cnt ) ) % minus_cnt ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = input ( ) <NEWLINE> keta = len ( n ) <NEWLINE> c = n [ 0 ] <NEWLINE> ans = int ( c ) + 9 * ( keta - 1 ) <NEWLINE> if n [ 1 : ] != ( <STRING> * ( keta - 1 ) ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> <NL> l = [ ] <NEWLINE> for j , s in enumerate ( x ) : <NEWLINE> <INDENT> l . append ( [ ] ) <NEWLINE> l [ j ] . append ( - 1 ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> endPos = y . find ( s ) <NEWLINE> if endPos != - 1 : <NEWLINE> <INDENT> l [ j ] . append ( endPos ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k , t in enumerate ( l [ j - 1 ] [ : - 1 ] ) : <NEWLINE> <INDENT> endPos = y . find ( s , t + 1 ) <NEWLINE> if endPos != - 1 : <NEWLINE> <INDENT> l [ j ] . append ( min ( endPos , l [ j - 1 ] [ k + 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ j ] . append ( l [ j - 1 ] [ k + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> endPos = y . find ( s , l [ j - 1 ] [ - 1 ] + 1 ) <NEWLINE> if endPos != - 1 : <NEWLINE> <INDENT> l [ j ] . append ( endPos ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( l [ - 1 ] ) - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> A . sort ( ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda s : int ( s ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = 0 <NEWLINE> visit = { 0 } <NEWLINE> ls = [ 0 ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> n = A [ n ] <NEWLINE> if n not in visit : <NEWLINE> <INDENT> visit . add ( n ) <NEWLINE> ls += [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop_start = 0 <NEWLINE> loop_length = 0 <NEWLINE> flag = False <NEWLINE> m = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if n == m : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> loop_length += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop_start += 1 <NEWLINE> <DEDENT> m = A [ m ] <NEWLINE> <NL> <DEDENT> print ( ls [ loop_start + ( ( K - loop_start ) % loop_length ) ] + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( n + 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 150 , 150 ) : <NEWLINE> <INDENT> for b in range ( - 150 , 150 ) : <NEWLINE> <INDENT> if ( a ** 5 - b ** 5 ) == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
M , N = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if M < sum ( l ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( M - sum ( l ) ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bb = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> asum = [ 0 ] <NEWLINE> bsum = [ 0 ] <NEWLINE> <NL> for i in range ( len ( aa ) ) : <NEWLINE> <INDENT> asum . append ( asum [ i ] + aa [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( bb ) ) : <NEWLINE> <INDENT> bsum . append ( bsum [ i ] + bb [ i ] ) <NEWLINE> <NL> <DEDENT> j = len ( bsum ) - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( asum ) ) : <NEWLINE> <INDENT> while j >= 0 : <NEWLINE> <INDENT> if k >= asum [ i ] + bsum [ j ] : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> <NL> lst = [ ] <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lst . append ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> nums = [ list ( map ( int , elem . split ( <STRING> ) ) ) for elem in lst ] <NEWLINE> <NL> <COMMENT> <NL> res_gcd = [ fractions . gcd ( num [ 0 ] , num [ 1 ] ) for num in nums ] <NEWLINE> <NL> <COMMENT> <NL> res_lcm = [ nums [ i ] [ 0 ] * nums [ i ] [ 1 ] // res_gcd [ i ] for i in range ( len ( nums ) ) ] <NEWLINE> <NL> for ( a , b ) in zip ( res_gcd , res_lcm ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a . append ( len ( list ( set ( s [ 0 : i ] ) & set ( s [ i : ] ) ) ) ) <NEWLINE> <DEDENT> print ( max ( a ) ) <NEWLINE>
mod = 998244353 <NEWLINE> n , a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> if n < 0 or r < 0 : return 0 <NEWLINE> return fa [ n ] * fi [ r ] % mod * fi [ n - r ] % mod <NEWLINE> <DEDENT> fa = [ 1 ] * ( n + 1 ) <NEWLINE> fi = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fa [ i ] = fa [ i - 1 ] * i % mod <NEWLINE> fi [ i ] = pow ( fa [ i ] , mod - 2 , mod ) <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> x = k - a * i <NEWLINE> if x >= 0 and x % b == 0 : <NEWLINE> <INDENT> j = x // b <NEWLINE> if j <= n : <NEWLINE> <INDENT> ans += comb ( n , i ) * comb ( n , j ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> list . sort ( table ) <NEWLINE> if num == 2 : <NEWLINE> <INDENT> if table [ 0 ] == table [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , num - 1 ) : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> if table [ 0 ] == table [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> elif table [ i ] == table [ i + 1 ] or table [ i - 1 ] == table [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> import bisect as bs <NEWLINE> import numpy as np <NEWLINE> A . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <COMMENT> <NL> B_a = np . array ( [ bs . bisect_left ( A , b ) for b in B ] ) <NEWLINE> B_c = np . array ( [ N - bs . bisect_right ( C , b ) for b in B ] ) <NEWLINE> ans = np . dot ( B_a , B_c ) <NEWLINE> print ( ans ) <NEWLINE>
_ = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = 0 if 0 in A else ans <NEWLINE> ans = ans if ans <= 10 ** 18 else - 1 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans_x = min ( N , B - 1 ) <NEWLINE> ans = math . floor ( A * ans_x / B ) - A * math . floor ( ans_x / B ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max = line [ 0 ] <NEWLINE> min = line [ 0 ] <NEWLINE> sum = line [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if max < line [ i ] : <NEWLINE> <INDENT> max = line [ i ] <NEWLINE> <DEDENT> elif min > line [ i ] : <NEWLINE> <INDENT> min = line [ i ] <NEWLINE> <DEDENT> sum += line [ i ] <NEWLINE> <NL> <DEDENT> print ( min , max , sum ) <NEWLINE>
q = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> MAX = 10 ** 5 + 1 <NEWLINE> l = [ 0 ] * MAX <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , MAX , 2 ) : <NEWLINE> <INDENT> if is_prime ( i ) and is_prime ( ( i + 1 ) / 2 ) : <NEWLINE> <INDENT> l [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> l2 = [ 0 ] * ( MAX + 1 ) <NEWLINE> for i in range ( 0 , MAX ) : <NEWLINE> <INDENT> l2 [ i + 1 ] = l2 [ i ] + l [ i ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> r += 1 <NEWLINE> print ( l2 [ r ] - l2 [ l ] ) <NEWLINE> <DEDENT>
n , m = ( int ( xi ) for xi in input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> diff = [ ] <NEWLINE> a0 = 0 <NEWLINE> if m > 0 : <NEWLINE> <INDENT> a1 = int ( input ( ) ) <NEWLINE> a . append ( a1 ) <NEWLINE> diff . append ( a1 + 1 ) <NEWLINE> <NL> if m > 1 : <NEWLINE> <INDENT> for xi in range ( m - 1 ) : <NEWLINE> <INDENT> a0 = a1 <NEWLINE> a1 = int ( input ( ) ) <NEWLINE> a . append ( a1 ) <NEWLINE> diff . append ( a1 - a0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if a1 == n - 1 : <NEWLINE> <INDENT> diff . append ( n - a1 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff . append ( n - a1 + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n == 1 : diff . append ( n + 1 ) <NEWLINE> diff . append ( n + 2 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> p = [ 0 ] <NEWLINE> p . append ( 1 ) <NEWLINE> p . append ( 1 ) <NEWLINE> for xi in range ( 3 , max ( diff ) + 2 ) : <NEWLINE> <INDENT> add = ( p [ xi - 1 ] + p [ xi - 2 ] ) % 1_000_000_007 <NEWLINE> p . append ( add ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> out = 1 <NEWLINE> for xi in range ( len ( diff ) ) : <NEWLINE> <INDENT> out *= p [ diff [ xi ] - 1 ] <NEWLINE> <NL> <DEDENT> print ( out % 1_000_000_007 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if A [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 300 <NEWLINE> for i in range ( - 200 , 201 ) : <NEWLINE> <INDENT> if i not in list : <NEWLINE> <INDENT> if abs ( x - i ) < abs ( x - ans ) : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) == 1 : <NEWLINE> <INDENT> print ( int ( S ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Sum = 0 <NEWLINE> for TR in product ( [ 0 , 1 ] , repeat = ( len ( S ) - 1 ) ) : <NEWLINE> <INDENT> Op = [ <STRING> if TO == 1 else <STRING> for TO in TR ] + [ <STRING> ] <NEWLINE> Sum += eval ( <STRING> . join ( [ TS + TO for TS , TO in zip ( S , Op ) ] ) ) <NEWLINE> <DEDENT> print ( Sum ) <NEWLINE> <DEDENT>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> for n in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( tmp , n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> L [ b - 1 ] += 1 <NEWLINE> <DEDENT> elif H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> L [ a - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ a - 1 ] += 1 <NEWLINE> L [ b - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = L . count ( 0 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> minij = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if a [ j ] < a [ minij ] : <NEWLINE> <INDENT> minij = j <NEWLINE> <DEDENT> <DEDENT> if a [ i ] > a [ minij ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> a [ i ] , a [ minij ] = a [ minij ] , a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> print ( count ) <NEWLINE> <NL>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> root = list ( ) <NEWLINE> <NL> <NL> def dfs ( A , num , N , memo ) : <NEWLINE> <INDENT> if memo [ A [ num ] - 1 ] == 1 : <NEWLINE> <INDENT> return root . index ( A [ num ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root . append ( A [ num ] ) <NEWLINE> memo [ A [ num ] - 1 ] = 1 <NEWLINE> return dfs ( A , A [ num ] - 1 , N , memo ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> memo = [ 0 ] * N <NEWLINE> start = dfs ( A , 0 , N , memo ) <NEWLINE> <NL> if K <= len ( root ) : <NEWLINE> <INDENT> print ( root [ K - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = ( K - start ) % ( len ( root ) - start ) <NEWLINE> loop = root [ start : ] <NEWLINE> print ( loop [ index - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> hoge = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if ( tmp in hoge ) : <NEWLINE> <INDENT> hoge [ tmp ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hoge [ tmp ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> key_max = max ( hoge . values ( ) ) <NEWLINE> keys = [ k for k , v in hoge . items ( ) if v == key_max ] <NEWLINE> hoge = sorted ( keys ) <NEWLINE> for i in range ( len ( hoge ) ) : <NEWLINE> <INDENT> print ( hoge [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> b = list ( s ) <NEWLINE> b . sort ( ) <NEWLINE> b = <STRING> . join ( b ) <NEWLINE> a . append ( b ) <NEWLINE> <DEDENT> c = collections . Counter ( a ) <NEWLINE> ans = 0 <NEWLINE> for e in c : <NEWLINE> <INDENT> ans += c [ e ] * ( c [ e ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = [ 0 ] * ( k - 1 ) <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> b [ i ] = a [ i + 1 ] - a [ i ] <NEWLINE> <DEDENT> b . append ( n - a [ - 1 ] + a [ 0 ] ) <NEWLINE> <NL> print ( sum ( b ) - max ( b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list_S = list ( input ( ) ) <NEWLINE> list_R = [ ] <NEWLINE> list_B = [ ] <NEWLINE> list_G = [ ] <NEWLINE> ans = 0 <NEWLINE> for i , c in enumerate ( list_S ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> list_R . append ( i + 1 ) <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> list_B . append ( i + 1 ) <NEWLINE> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> list_G . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> set_R = set ( list_R ) <NEWLINE> set_G = set ( list_G ) <NEWLINE> set_B = set ( list_B ) <NEWLINE> cnt = 0 <NEWLINE> for i in list_R : <NEWLINE> <INDENT> for j in list_G : <NEWLINE> <INDENT> max_value = max ( i , j ) <NEWLINE> min_value = min ( i , j ) <NEWLINE> d = ( max_value - min_value ) <NEWLINE> if d % 2 == 0 : <NEWLINE> <INDENT> if max_value - d // 2 in set_B : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if max_value + d in set_B : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if min_value - d in set_B : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans += len ( set_B ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans - cnt ) <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ int ( n ) for n in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> B = [ [ int ( n ) for n in input ( ) . split ( ) ] for i in range ( m ) ] <NEWLINE> C = [ [ 0 for i in range ( l ) ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> if j == l - 1 : <NEWLINE> <INDENT> print ( C [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> Y = X - i <NEWLINE> if Y not in A : <NEWLINE> <INDENT> print ( Y ) <NEWLINE> break <NEWLINE> <DEDENT> Y = X + i <NEWLINE> if Y not in A : <NEWLINE> <INDENT> print ( Y ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> cumsum = A . cumsum ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def f ( n ) : <NEWLINE> <INDENT> return n * ( n - 1 ) // 2 <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for key , value in Counter ( cumsum ) . items ( ) : <NEWLINE> <INDENT> if key == 0 : <NEWLINE> <INDENT> ans += value <NEWLINE> <DEDENT> if value >= 2 : <NEWLINE> <INDENT> ans += f ( value ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> def maxHeapify ( i ) : <NEWLINE> <INDENT> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> <COMMENT> <NL> largest = 0 <NEWLINE> if l <= H and A [ l ] > A [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <NL> <DEDENT> if r <= H and A [ r ] > A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( largest ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> H = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ - 1 ] + A <NEWLINE> <NL> for i in range ( int ( H / 2 ) , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( i ) <NEWLINE> <NL> <DEDENT> Astr = list ( map ( str , A ) ) <NEWLINE> <NL> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> print ( * A [ 1 : ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s = input ( ) <NEWLINE> x = int ( s , base = 2 ) <NEWLINE> popcount = s . count ( <STRING> ) <NEWLINE> y_zero = x % ( popcount + 1 ) <NEWLINE> if popcount > 1 : <NEWLINE> <INDENT> y_one = x % ( popcount - 1 ) <NEWLINE> <DEDENT> dp = [ - 1 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> <NL> def calc ( y ) : <NEWLINE> <INDENT> if dp [ y ] != - 1 : <NEWLINE> <INDENT> return dp [ y ] <NEWLINE> <DEDENT> dp [ y ] = 1 + calc ( y % bin ( y ) . count ( <STRING> ) ) <NEWLINE> return dp [ y ] <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> rem_zero = 1 <NEWLINE> if popcount > 1 : <NEWLINE> <INDENT> rem_one = popcount - 2 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> ans [ n - 1 - i ] = 1 + calc ( ( y_zero + rem_zero ) % ( popcount + 1 ) ) <NEWLINE> <DEDENT> elif popcount > 1 : <NEWLINE> <INDENT> ans [ n - 1 - i ] = 1 + calc ( ( y_one + rem_one ) % ( popcount - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ n - 1 - i ] = 0 <NEWLINE> <DEDENT> rem_zero = rem_zero * 2 % ( popcount + 1 ) <NEWLINE> if popcount > 1 : <NEWLINE> <INDENT> rem_one = rem_one * 2 % ( popcount - 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> def set1 ( sq ) : <NEWLINE> <INDENT> x = len ( sq ) // 2 <NEWLINE> y = len ( sq ) // 2 + 1 <NEWLINE> square [ y ] [ x ] = 1 <NEWLINE> return x , y , 1 <NEWLINE> <DEDENT> def mv_r ( sq , x , y ) : <NEWLINE> <INDENT> x = ( x + 1 ) % len ( sq ) <NEWLINE> y = ( y + 1 ) % len ( sq ) <NEWLINE> return x , y <NEWLINE> <DEDENT> def mv_l ( sq , x , y ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x += len ( sq ) <NEWLINE> <DEDENT> y = ( y + 1 ) % len ( sq ) <NEWLINE> return x , y <NEWLINE> <NL> <DEDENT> def setnext ( sq , x , y , i ) : <NEWLINE> <INDENT> x , y = mv_r ( sq , x , y ) <NEWLINE> i += 1 <NEWLINE> while sq [ y ] [ x ] : <NEWLINE> <INDENT> x , y = mv_l ( sq , x , y ) <NEWLINE> <DEDENT> sq [ y ] [ x ] = i <NEWLINE> return x , y , i <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( f . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> square = [ [ None for j in range ( n ) ] for i in range ( n ) ] <NEWLINE> arg = set1 ( square ) <NEWLINE> for i in range ( n * n - 1 ) : <NEWLINE> <INDENT> arg = setnext ( square , * arg ) <NEWLINE> <NL> <DEDENT> for line in square : <NEWLINE> <INDENT> for num in line : <NEWLINE> <INDENT> print ( <STRING> . format ( num ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def manipulate ( A_i ) : <NEWLINE> <INDENT> if 0 in A_i : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for a in A_i : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( manipulate ( A_i ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X >= K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> elif X == D : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> K -= X // D <NEWLINE> X = X % D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X - D ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> absv = x <NEWLINE> value = x <NEWLINE> for i in range ( - 1 , 102 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if absv > abs ( x - i ) : <NEWLINE> <INDENT> absv = abs ( x - i ) <NEWLINE> value = x - i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x - value ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c . sort ( ) <NEWLINE> a = c [ N - 1 ] <NEWLINE> list_c = [ 0 ] * ( a + 1 ) <NEWLINE> for i in c : <NEWLINE> <INDENT> mal = 2 <NEWLINE> b = i <NEWLINE> while i <= a : <NEWLINE> <INDENT> list_c [ i ] += 1 <NEWLINE> i = b * mal <NEWLINE> mal += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> if list_c [ i ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> R = [ ] <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 5 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> if i - L [ j ] >= 0 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - L [ j ] ] <NEWLINE> <DEDENT> if i - R [ j ] - 1 >= 0 : <NEWLINE> <INDENT> dp [ i ] -= dp [ i - R [ j ] - 1 ] <NEWLINE> <DEDENT> dp [ i ] %= 998244353 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( dp [ N ] - dp [ N - 1 ] ) % 998244353 ) <NEWLINE>
class SegmentTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . dat = [ 0 for _ in range ( n * 2 - 1 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> self . n = n <NEWLINE> <NL> <DEDENT> def update ( self , node_index , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> index = node_index + ( self . n - 1 ) <COMMENT> <NEWLINE> self . dat [ index ] += value <NEWLINE> <NL> <COMMENT> <NL> while index > 0 : <NEWLINE> <INDENT> index = ( index - 1 ) // 2 <COMMENT> <NEWLINE> self . dat [ index ] = self . dat [ index * 2 + 1 ] + self . dat [ index * 2 + 2 ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def querry ( self , left , right , nowNode , nowLeft , nowRight ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> if nowRight < left or nowLeft > right : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if left <= nowLeft and nowRight <= right : <NEWLINE> <INDENT> return self . dat [ nowNode ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> value_left = self . querry ( left , right , 2 * nowNode + 1 , nowLeft , ( nowLeft + nowRight ) // 2 ) <NEWLINE> value_right = self . querry ( left , right , 2 * nowNode + 2 , ( nowLeft + nowRight ) // 2 + 1 , nowRight ) <NEWLINE> return ( value_left + value_right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def DEBUG_dat ( self ) : <NEWLINE> <INDENT> print ( self . dat ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> result = [ ] <NEWLINE> <NL> for i in range ( 1 , 20 ) : <NEWLINE> <INDENT> if 2 ** i >= n : <NEWLINE> <INDENT> min_pow2 = 2 ** i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> tree = SegmentTree ( min_pow2 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> tree . update ( x - 1 , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( tree . querry ( x - 1 , y - 1 , 0 , 0 , min_pow2 - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for ans in result : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> if <STRING> in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans = ans * int ( i ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
line = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> line . sort ( reverse = True ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> print ( line [ i ] , end = <STRING> if i != 4 else <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> r = N % K <NEWLINE> <NL> if N % K == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( r , abs ( r - K ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def cmb ( n ) : <NEWLINE> <INDENT> over = reduce ( mul , range ( n , n - 2 , - 1 ) ) <NEWLINE> under = reduce ( mul , range ( 1 , 2 + 1 ) ) <NEWLINE> return over // under <NEWLINE> <NL> <NL> <DEDENT> S = input ( ) [ : : - 1 ] <NEWLINE> keta = 1 <NEWLINE> A_num = 0 <NEWLINE> x = 0 <NEWLINE> mod = np . array ( [ 0 ] * 2019 ) <NEWLINE> mod [ 0 ] += 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> A_num += ( int ( S [ i : i + 1 ] ) * keta ) % 2019 <NEWLINE> if A_num >= 2019 : <NEWLINE> <INDENT> A_num = A_num % 2019 <NEWLINE> <DEDENT> mod [ A_num ] += 1 <NEWLINE> <COMMENT> <NL> keta = keta * 10 % 2019 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( int ( np . sum ( mod * ( mod - 1 ) / 2 ) ) ) <NEWLINE>
def t ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> T *= i <NEWLINE> if T > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return T <NEWLINE> <DEDENT> print ( t ( ) ) <NEWLINE>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if arr [ i ] > arr [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( t , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import mul <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import heapq <NEWLINE> <NL> n , p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if p == 2 or p == 5 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( s [ n - 1 - i ] ) <NEWLINE> if a % p == 0 : ans += n - i <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d = { 0 : 1 } <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += ( pow ( 10 , i , p ) * int ( s [ n - 1 - i ] ) ) % p <NEWLINE> c %= p <NEWLINE> if c not in d : <NEWLINE> <INDENT> d [ c ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for dd in d . values ( ) : <NEWLINE> <INDENT> ans += dd * ( dd - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in l : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = min ( N , len ( l ) ) <NEWLINE> ans = 1 <NEWLINE> for i in l [ : n ] : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> print ( sum ( [ math . gcd ( math . gcd ( i , j ) , k ) for i in range ( 1 , K + 1 ) for j in range ( 1 , K + 1 ) for k in range ( 1 , K + 1 ) ] ) ) <NEWLINE> <NL>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if a - k >= 0 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = k - a <NEWLINE> if b - num >= 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num -= b <NEWLINE> print ( a - num ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> def digit ( b , n ) : <NEWLINE> <INDENT> if n < b : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return digit ( b , math . floor ( n / b ) ) + n % b <NEWLINE> <NL> <DEDENT> <DEDENT> n , s = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> <NL> if n == s : <NEWLINE> <INDENT> print ( n + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n < s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 2 ) : <NEWLINE> <INDENT> if digit ( i , n ) == s : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for p in range ( 1 , int ( math . sqrt ( n ) ) ) [ : : - 1 ] : <NEWLINE> <INDENT> q = s - p <NEWLINE> b = ( n - s ) // p + 1 <NEWLINE> if 1 <= p < b and 0 <= q < b and ( n - s ) % p == 0 : <NEWLINE> <INDENT> if digit ( b , n ) == s : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( [ b - 1 , c ] ) <NEWLINE> G [ b - 1 ] . append ( [ a - 1 , c ] ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> SD = [ 0 ] * N <NEWLINE> def DFS ( v , p , d ) : <NEWLINE> <INDENT> SD [ v ] = d <NEWLINE> for i , co in G [ v ] : <NEWLINE> <INDENT> if i == p : continue <NEWLINE> DFS ( i , v , d + co ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> DFS ( K - 1 , - 1 , 0 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = SD [ x - 1 ] + SD [ y - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N , K = MI ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> for i in range ( K - 1 , N - 1 ) : <NEWLINE> <INDENT> b = A [ i - K + 1 ] <NEWLINE> f = A [ i + 1 ] <NEWLINE> if f > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , M , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> R = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> dist = [ [ 10e8 for _ in range ( N ) ] for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : dist [ i ] [ i ] = 0 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> dist [ a - 1 ] [ b - 1 ] = dist [ b - 1 ] [ a - 1 ] = c <NEWLINE> <DEDENT> del a , b , c , K <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> dist [ i ] [ j ] = dist [ j ] [ i ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mindist ( x , X ) : <NEWLINE> <INDENT> global dist <NEWLINE> Y = X . copy ( ) <NEWLINE> Y . remove ( x ) <NEWLINE> if len ( Y ) == 0 : return 0 <NEWLINE> return min ( [ dist [ x ] [ y ] + mindist ( y , Y ) for y in Y ] ) <NEWLINE> <NL> <DEDENT> ans = min ( [ mindist ( r , R ) for r in R ] ) <NEWLINE> print ( ans ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = [ X ] <NEWLINE> sa = set ( [ X ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> X = ( X ** 2 ) % M <NEWLINE> if X in sa : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( X ) <NEWLINE> sa . add ( X ) <NEWLINE> <NL> <DEDENT> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> start = a . index ( X ) <NEWLINE> ans = sum ( a [ : start ] ) <NEWLINE> base = sum ( a [ start : ] ) <NEWLINE> rep = i - start <NEWLINE> sets = ( N - start ) // rep <NEWLINE> more = ( N - start ) % rep <NEWLINE> ans += base * sets + sum ( a [ start : start + more ] ) <NEWLINE> print ( ans ) <NEWLINE>
S = set ( x for x in input ( ) ) <NEWLINE> if len ( S ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( S ) == 2 : <NEWLINE> <INDENT> if <STRING> in S and <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <STRING> in S and <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> s = [ ] <NEWLINE> ord = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> v = 1 <NEWLINE> c = 1 <NEWLINE> l = 0 <NEWLINE> while ord [ v ] == - 1 : <NEWLINE> <INDENT> ord [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <DEDENT> c = len ( s ) - ord [ v ] <NEWLINE> l = ord [ v ] <NEWLINE> <NL> if l > k : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> inp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp . append ( list ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> sq_max = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> <NL> for y in range ( n ) : <NEWLINE> <INDENT> for x in range ( n ) : <NEWLINE> <INDENT> if inp [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> sq_max [ y + 1 ] [ x + 1 ] = min ( sq_max [ y ] [ x + 1 ] , sq_max [ y + 1 ] [ x ] , sq_max [ y ] [ x ] ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sq_max [ y + 1 ] [ x + 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( map ( max , sq_max ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> <NL> def gcd ( a , b , c ) : <NEWLINE> <INDENT> d = math . gcd ( a , b ) <NEWLINE> return math . gcd ( c , d ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum += gcd ( i , i , i ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> sum += 0 <NEWLINE> <DEDENT> elif i == j or j == k or i == k : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) * 3 <NEWLINE> <DEDENT> elif i != j and j != k : <NEWLINE> <INDENT> sum += gcd ( i , j , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N + 1 ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( A , B ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( max ( [ uf . size ( r ) for r in uf . roots ( ) ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> g [ u ] . append ( v ) <NEWLINE> g [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> vis = [ False ] * n <NEWLINE> stk = [ ] <NEWLINE> <NL> cnt = 0 <NEWLINE> tt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not vis [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> stk . append ( i ) <NEWLINE> <DEDENT> while len ( stk ) != 0 : <NEWLINE> <INDENT> u = stk [ - 1 ] <NEWLINE> stk . pop ( ) <NEWLINE> if vis [ u ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> vis [ u ] = True <NEWLINE> for v in g [ u ] : <NEWLINE> <INDENT> tt += 1 <NEWLINE> if not vis [ v ] : <NEWLINE> <INDENT> stk . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> even_odd_length = n / 2 <NEWLINE> replace_total = 0 <NEWLINE> <NL> list_odd = v [ 0 : : 2 ] <NEWLINE> list_even = v [ 1 : : 2 ] <NEWLINE> <NL> dict_c_odd = dict ( collections . Counter ( list_odd ) ) <NEWLINE> dict_c_even = dict ( collections . Counter ( list_even ) ) <NEWLINE> dict_c_even_bk = dict_c_even . copy ( ) <NEWLINE> dict_c_odd_bk = dict_c_odd . copy ( ) <NEWLINE> <NL> replace_total_tmp = 0 <NEWLINE> replace_total_tmp2 = 0 <NEWLINE> max_count_c_odd = max ( dict_c_odd . values ( ) ) <NEWLINE> max_count_c_even = max ( dict_c_even . values ( ) ) <NEWLINE> max_count_c_even_bk = max_count_c_even <NEWLINE> max_c_odd_keys = [ k for k , v in dict_c_odd . items ( ) if v == max_count_c_odd ] <NEWLINE> max_c_even_keys = [ k for k , v in dict_c_even . items ( ) if v == max_count_c_even ] <NEWLINE> <NL> if len ( set ( v ) ) == 1 : <NEWLINE> <INDENT> print ( int ( even_odd_length ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_c_odd_keys [ 0 ] in dict_c_even : <NEWLINE> <INDENT> del dict_c_even [ max_c_odd_keys [ 0 ] ] <NEWLINE> <DEDENT> max_count_c_even = max ( dict_c_even . values ( ) ) <NEWLINE> replace_total_tmp = ( n - max_count_c_odd - max_count_c_even ) <NEWLINE> <NL> dict_c_even = dict_c_even_bk <NEWLINE> max_count_c_even = max_count_c_even_bk <NEWLINE> <NL> if max_c_even_keys [ 0 ] in dict_c_odd : <NEWLINE> <INDENT> del dict_c_odd [ max_c_even_keys [ 0 ] ] <NEWLINE> <DEDENT> max_count_c_odd = max ( dict_c_odd . values ( ) ) <NEWLINE> replace_total_tmp2 = ( n - max_count_c_odd - max_count_c_even ) <NEWLINE> <NL> if replace_total_tmp >= replace_total_tmp2 : <NEWLINE> <INDENT> replace_total = replace_total_tmp2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> replace_total = replace_total_tmp <NEWLINE> <DEDENT> print ( replace_total ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> num = 0 <NEWLINE> <NL> r_lst = [ 0 ] * 2019 <NEWLINE> r_lst [ 0 ] = 1 <NEWLINE> cnt = 0 <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> num = ( num + pow ( 10 , i , 2019 ) * int ( s ) ) % 2019 <NEWLINE> cnt += r_lst [ num ] <NEWLINE> <NL> r_lst [ num ] += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max_v = 0 <NEWLINE> for x in range ( - 1 , min ( B , N + 1 ) , min ( B , N + 1 ) ) : <NEWLINE> <INDENT> if x <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> if max_v < v : <NEWLINE> <INDENT> max_v = v <NEWLINE> <DEDENT> <DEDENT> print ( max_v ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in num_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in num_list : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> D = float ( abs ( A - B ) ) <NEWLINE> E = float ( V - W ) <NEWLINE> <NL> if E <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> time = D / E <NEWLINE> if time <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> a = [ 0 ] * 1000001 <NEWLINE> a [ 0 ] = 7 % K <NEWLINE> for i in range ( 1000000 ) : <NEWLINE> <INDENT> a [ i + 1 ] = ( a [ i ] * 10 + 7 ) % K <NEWLINE> <NL> if ( a [ i ] == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( i == 999999 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( ( n - 1 ) // i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin , exit <NEWLINE> <NL> <NL> def make_number_of_combination ( ) : <NEWLINE> <INDENT> pre = [ [ 0 ] * 10 for _ in xrange ( 1001 ) ] <NEWLINE> now = [ [ 0 ] * 10 for _ in xrange ( 1001 ) ] <NEWLINE> <NL> for a in xrange ( 101 ) : <NEWLINE> <INDENT> now [ a ] [ 0 ] = 1 <NEWLINE> for i in xrange ( 1001 ) : <NEWLINE> <INDENT> if i + a > 1000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in xrange ( 9 ) : <NEWLINE> <INDENT> now [ i + a ] [ j + 1 ] += pre [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in xrange ( 1001 ) : <NEWLINE> <INDENT> for j in xrange ( 10 ) : <NEWLINE> <INDENT> pre [ i ] [ j ] = now [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return pre <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = make_number_of_combination ( ) <NEWLINE> for line in stdin : <NEWLINE> <INDENT> n , s = ( int ( s ) for s in line . split ( ) ) <NEWLINE> if not n and not s : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> print ( ans [ s ] [ n - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def readinput ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> return n <NEWLINE> <NL> <DEDENT> def main ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> j = len ( n ) - 1 <NEWLINE> while ( j >= 0 ) : <NEWLINE> <INDENT> sum += int ( n [ j ] ) <NEWLINE> j -= 1 <NEWLINE> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = readinput ( ) <NEWLINE> ans = main ( n ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , Ma , Mb = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <DEDENT> sa = sum ( A ) <NEWLINE> sb = sum ( B ) <NEWLINE> <NL> dp = [ [ [ 10000 ] * ( sb + 1 ) for _ in range ( sa + 1 ) ] for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> ta = 0 <NEWLINE> tb = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> b = B [ i ] <NEWLINE> for j in range ( sa ) : <NEWLINE> <INDENT> for k in range ( sb ) : <NEWLINE> <INDENT> if j - a >= 0 and k - b >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] [ k ] = min ( dp [ i ] [ j - a ] [ k - b ] + C [ i ] , dp [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] [ k ] = min ( dp [ i + 1 ] [ j ] [ k ] , dp [ i ] [ j ] [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 10000 <NEWLINE> for i in range ( 1 , sa + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , sb + 1 ) : <NEWLINE> <INDENT> if Ma * j == Mb * i : <NEWLINE> <INDENT> ans = min ( ans , dp [ N ] [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 10000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> d = [ 0 ] * ( M + 1 ) <NEWLINE> e = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for r in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for x in itertools . combinations ( c , r ) : <NEWLINE> <INDENT> for y in range ( len ( x ) ) : <NEWLINE> <INDENT> for z in range ( M + 1 ) : <NEWLINE> <INDENT> d [ z ] += x [ y ] [ z ] <NEWLINE> <DEDENT> <DEDENT> for z in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if d [ z ] < X : <NEWLINE> <INDENT> d = [ 0 ] * ( M + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif z == M : <NEWLINE> <INDENT> e . append ( d [ 0 ] ) <NEWLINE> d = [ 0 ] * ( M + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( e ) > 0 : <NEWLINE> <INDENT> print ( min ( e ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> b = x % m <NEWLINE> add = 0 <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> if n <= m : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += b <NEWLINE> b = pow ( b , 2 , m ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> cnt = 0 <NEWLINE> while 2 ** cnt < m : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> s = set ( ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i < cnt : <NEWLINE> <INDENT> add += b <NEWLINE> tmp = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( b ) <NEWLINE> <DEDENT> b = pow ( b , 2 , m ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> rest = ( n - cnt ) % len ( s ) <NEWLINE> div = ( n - cnt ) // len ( s ) <NEWLINE> <NL> rep = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> tmp = pow ( tmp , 2 , m ) <NEWLINE> rep . append ( tmp ) <NEWLINE> <NL> <DEDENT> ans = add + sum ( rep ) * div + sum ( rep [ : rest ] ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_ = int ( input ( ) ) <NEWLINE> if a_ not in a : <NEWLINE> <INDENT> a [ a_ ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ a_ ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> tmp = 1 <NEWLINE> A . sort ( reverse = True ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> tmp *= A [ i ] <NEWLINE> if tmp > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> S = input ( ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> dp = np . zeros ( 13 , dtype = int ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> <NL> @ njit ( cache = True ) <NEWLINE> def q_mark ( dp ) : <NEWLINE> <INDENT> new_dp = np . zeros ( 13 , dtype = i8 ) <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> new_dp [ np . arange ( i , i + 10 ) % 13 ] += dp [ i ] <NEWLINE> new_dp %= MOD <NEWLINE> <DEDENT> return new_dp <NEWLINE> <NL> <NL> <DEDENT> for s in S : <NEWLINE> <COMMENT> <NL> <INDENT> dp = dp [ np . arange ( 0 , 52 , 4 ) % 13 ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> dp = q_mark ( dp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp = np . roll ( dp , int ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 5 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> xy = [ ] <NEWLINE> d0 , d1 = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> d0 . append ( x - y ) <NEWLINE> d1 . append ( x + y ) <NEWLINE> <DEDENT> print ( max ( max ( d0 ) - min ( d0 ) , max ( d1 ) - min ( d1 ) ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> b_cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b_cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b_cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if ( x % 3 == 0 ) or ( x % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( x ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = x <NEWLINE> while ( temp > 0 ) : <NEWLINE> <INDENT> if ( temp % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( x ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = temp // 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = [ map ( int , input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> kousya = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> for b , f , r , v in n : <NEWLINE> <INDENT> kousya [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> , * kousya [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 3 : break <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( x + 1 ) : <NEWLINE> <INDENT> c = i <NEWLINE> t = abs ( x - i ) <NEWLINE> if 2 * c + 4 * t == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if i == x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for index in range ( m ) : <NEWLINE> <INDENT> a [ index ] . append ( sum ( a [ index ] ) ) <NEWLINE> <DEDENT> for a_column in a : <NEWLINE> <INDENT> for num in a_column [ : - 1 ] : <NEWLINE> <INDENT> print ( num , end = <STRING> ) <NEWLINE> <DEDENT> print ( a_column [ - 1 ] ) <NEWLINE> <DEDENT> for row_index in range ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for a_column in a : <NEWLINE> <INDENT> sum += a_column [ row_index ] <NEWLINE> <DEDENT> print ( sum , end = <STRING> ) <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for a_column in a : <NEWLINE> <INDENT> sum += a_column [ - 1 ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = n <NEWLINE> q = 2 * ( 10 ** 5 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> q = min ( p [ i ] , q ) <NEWLINE> if not p [ i ] <= q : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : print ( <STRING> ) <NEWLINE> elif a < b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max = 10 ** 6 + 1 <NEWLINE> memo = [ 0 ] * max <NEWLINE> <NL> for a in a_list : <NEWLINE> <INDENT> memo [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , max ) : <NEWLINE> <INDENT> if sum ( memo [ i : : i ] ) > 1 : <NEWLINE> <INDENT> if reduce ( math . gcd , a_list ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> line = [ int ( y ) for y in input ( ) . split ( ) ] <NEWLINE> line . sort ( ) <NEWLINE> <NL> yeet = 1 <NEWLINE> solved = False <NEWLINE> <NL> if line [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , x ) : <NEWLINE> <INDENT> yeet = yeet * line [ i ] <NEWLINE> if yeet > 10 ** 18 : <NEWLINE> <INDENT> solved = True <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if solved == False : <NEWLINE> <INDENT> print ( yeet ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> maxs = 0 <NEWLINE> for x in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for y in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ y ] == S [ x + y ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> maxs = max ( count , maxs ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( T ) - maxs ) <NEWLINE>
A , B = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> <NL> if B == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif B % A == 0 : <NEWLINE> <INDENT> ans = B // A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B // A + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
t = input ( ) <NEWLINE> <NL> stack = <STRING> <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> word = t [ i ] <NEWLINE> if word == <STRING> : <NEWLINE> <INDENT> next_word = t [ i + 1 ] if i < len ( t ) - 1 else None <NEWLINE> if next_word is None : <NEWLINE> <INDENT> word = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( stack ) <= 0 and next_word == <STRING> : <NEWLINE> <INDENT> word = <STRING> <NEWLINE> <DEDENT> elif len ( stack ) <= 0 and ( next_word == <STRING> or next_word == <STRING> ) : <NEWLINE> <INDENT> word = <STRING> <NEWLINE> <DEDENT> elif stack [ - 1 ] == <STRING> and ( next_word == <STRING> or next_word == <STRING> ) : <NEWLINE> <INDENT> word = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> word = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> stack += word <NEWLINE> <DEDENT> print ( stack ) <NEWLINE>
c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( c , n ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> J = 1000 <NEWLINE> N = [ 0 ] * J <NEWLINE> for i in range ( 0 , J ) : <NEWLINE> <INDENT> N [ i ] = i ** 5 <NEWLINE> <DEDENT> for i in range ( 0 , J ) : <NEWLINE> <INDENT> for j in range ( 0 , J ) : <NEWLINE> <INDENT> if abs ( N [ i ] - N [ j ] ) == X : <NEWLINE> <INDENT> print ( int ( max ( N [ i ] , N [ j ] ) ** ( 1 / 5 ) ) , int ( min ( N [ i ] , N [ j ] ) ** ( 1 / 5 ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif N [ i ] + N [ j ] == X : <NEWLINE> <INDENT> print ( int ( N [ i ] ** ( 1 / 5 ) ) , int ( - 1 * N [ j ] ** ( 1 / 5 ) ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_lst . sort ( ) <NEWLINE> a_set_lst = list ( set ( a_lst ) ) <NEWLINE> a_set_lst . sort ( ) <NEWLINE> <NL> count_lst = [ ] <NEWLINE> count = 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> count_lst . append ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a1 = a_lst [ i ] <NEWLINE> a2 = a_lst [ i + 1 ] <NEWLINE> <NL> if a1 == a2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if i == n - 2 : <NEWLINE> <INDENT> count_lst . append ( count ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count_lst . append ( count ) <NEWLINE> count = 1 <NEWLINE> <DEDENT> <DEDENT> if a_lst [ - 1 ] != a_lst [ - 2 ] : <NEWLINE> <INDENT> count_lst . append ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> minimum = 0 <NEWLINE> for i in range ( len ( a_set_lst ) ) : <NEWLINE> <INDENT> number = a_set_lst [ i ] <NEWLINE> count = count_lst [ i ] <NEWLINE> <NL> if count < number : <NEWLINE> <INDENT> minimum += count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minimum += count - number <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def dfs ( u , color ) : <NEWLINE> <INDENT> global c <NEWLINE> global g <NEWLINE> s = [ u ] <NEWLINE> c [ u ] = color <NEWLINE> while 0 < len ( s ) : <NEWLINE> <INDENT> ch = s . pop ( ) <NEWLINE> for ch in g [ ch ] : <NEWLINE> <INDENT> u_c = c [ ch ] <NEWLINE> if u_c is None : <NEWLINE> <INDENT> c [ ch ] = color <NEWLINE> s . append ( ch ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def colorize ( ) : <NEWLINE> <INDENT> global g <NEWLINE> global c <NEWLINE> global n <NEWLINE> color = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == None : <NEWLINE> <INDENT> dfs ( i , color ) <NEWLINE> color += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g [ s ] . append ( t ) <NEWLINE> g [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> c = [ None for i in range ( n ) ] <NEWLINE> <NL> colorize ( ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if c [ s ] == c [ t ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( L ) ** 2 <NEWLINE> for i in L : <NEWLINE> <INDENT> S -= i ** 2 <NEWLINE> <NL> <DEDENT> print ( ( S // 2 ) % k ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> ai = 0 <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> l = set ( ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ai = ( ai * 10 + 7 ) % K <NEWLINE> if ai == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ai in l : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . add ( ai ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> A . append ( b ) <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> B . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if len ( set ( A ) & set ( B ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> @ njit <NEWLINE> def loop1 ( a ) : <NEWLINE> <INDENT> b = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = max ( 0 , i - a [ i ] ) <NEWLINE> r = min ( i + a [ i ] + 1 , n ) <NEWLINE> b [ l ] += 1 <NEWLINE> if r <= n - 1 : b [ r ] -= 1 <NEWLINE> <NL> <DEDENT> b = np . cumsum ( b ) [ : - 1 ] <NEWLINE> return b <NEWLINE> <NL> <DEDENT> for q in range ( min ( 42 , k ) ) : <NEWLINE> <INDENT> a = loop1 ( a ) <NEWLINE> <NL> <DEDENT> print ( * a ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = int ) <NEWLINE> I = np . arange ( N ) <COMMENT> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> B = np . zeros ( N + 1 , int ) <NEWLINE> <COMMENT> <NL> np . add . at ( B , np . maximum ( 0 , I - A ) , 1 ) <NEWLINE> np . add . at ( B , np . minimum ( N , I + A + 1 ) , - 1 ) <NEWLINE> A = B . cumsum ( ) [ : - 1 ] <NEWLINE> if np . all ( A == N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( * A ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> r = g = b = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> ans = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> dif = 2 * j - i <NEWLINE> if dif >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ dif ] and S [ j ] != S [ dif ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> nm = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = nm [ 0 ] <NEWLINE> m = nm [ 1 ] <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> friends = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uf . union ( friends [ 0 ] - 1 , friends [ 1 ] - 1 ) <NEWLINE> if ans < uf . size ( friends [ 1 ] - 1 ) : <NEWLINE> <INDENT> ans = uf . size ( friends [ 1 ] - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> tree_sub = list ( tree ) <COMMENT> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if tree [ a - 1 ] > tree [ b - 1 ] : <NEWLINE> <INDENT> tree_sub [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif tree [ a - 1 ] < tree [ b - 1 ] : <NEWLINE> <INDENT> tree_sub [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree_sub [ a - 1 ] = 0 <NEWLINE> tree_sub [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( len ( tree_sub ) - tree_sub . count ( 0 ) ) <NEWLINE>
import os <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> syo_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> syo = input ( ) <NEWLINE> syo_list . append ( syo ) <NEWLINE> <DEDENT> print ( len ( set ( syo_list ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mem = [ ] <NEWLINE> mind = 100 <NEWLINE> for i in range ( - 100 , 200 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> t = abs ( x - i ) <NEWLINE> if t < mind : <NEWLINE> <INDENT> mem . append ( [ i , t ] ) <NEWLINE> mind = t <NEWLINE> <DEDENT> <DEDENT> <DEDENT> mem = sorted ( mem , key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) <NEWLINE> print ( mem [ 0 ] [ 0 ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from itertools import accumulate <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = set ( ) <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> S . add ( i ) <NEWLINE> S . add ( n // i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> L = [ 0 ] + sorted ( S ) <NEWLINE> l = len ( L ) - 1 <NEWLINE> num = [ 0 ] * l <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> num [ i ] = L [ i + 1 ] - L [ i ] <NEWLINE> <DEDENT> dp = [ 0 ] * l <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> A = list ( accumulate ( dp ) ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> dp [ i ] = A [ l - 1 - i ] * num [ i ] <NEWLINE> dp [ i ] %= MOD <NEWLINE> <DEDENT> <DEDENT> ans = sum ( dp ) % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> base = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , len ( A ) , 1 ) : <NEWLINE> <INDENT> s = ( s + A [ i ] ) % base <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> ans = ( ans + ( A [ i ] * s ) ) % base <NEWLINE> s = ( s - A [ i + 1 ] + base ) % base <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> A = [ list ( input ( ) . split ( ) ) for i in range ( Q ) ] <NEWLINE> c = 0 <NEWLINE> R = <STRING> <NEWLINE> L = <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if c % 2 == 1 and A [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> R = R + A [ i ] [ 2 ] <NEWLINE> <DEDENT> elif A [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> L = A [ i ] [ 2 ] + L <NEWLINE> <DEDENT> <DEDENT> elif c % 2 == 0 and A [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> L = A [ i ] [ 2 ] + L <NEWLINE> <DEDENT> elif A [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> R = R + A [ i ] [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> S = L + S + R <NEWLINE> if c % 2 == 1 : <NEWLINE> <INDENT> S = S [ : : - 1 ] <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
import bisect <NEWLINE> <NL> n , m , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> sum_a = [ a [ 0 ] ] <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> sum_a . append ( sum_a [ i ] + a [ i + 1 ] ) <NEWLINE> <DEDENT> sum_b = [ b [ 0 ] ] <NEWLINE> for i in range ( len ( b ) - 1 ) : <NEWLINE> <INDENT> sum_b . append ( sum_b [ i ] + b [ i + 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> idx_a = 0 <NEWLINE> idx_b = 0 <NEWLINE> <NL> while idx_a < n or idx_b < m : <NEWLINE> <INDENT> read = <STRING> <NEWLINE> <COMMENT> <NL> oset_a = sum_a [ idx_a - 1 ] if idx_a > 0 else 0 <NEWLINE> can_cnt_a = bisect . bisect_right ( sum_a , k + oset_a ) <NEWLINE> <COMMENT> <NL> oset_b = sum_b [ idx_b - 1 ] if idx_b > 0 else 0 <NEWLINE> can_cnt_b = bisect . bisect_right ( sum_b , k + oset_b ) <NEWLINE> read = <STRING> if can_cnt_a - idx_a > can_cnt_b - idx_b else <STRING> <NEWLINE> if idx_a == n : <NEWLINE> <INDENT> read = <STRING> <NEWLINE> <DEDENT> if idx_b == m : <NEWLINE> <INDENT> read = <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> k -= a [ idx_a ] if read == <STRING> else b [ idx_b ] <NEWLINE> <COMMENT> <NL> if k < 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> if read == <STRING> : <NEWLINE> <INDENT> idx_a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx_b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( idx_a + idx_b ) <NEWLINE>
from scipy . sparse . csgraph import csgraph_from_dense , dijkstra <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> import heapq <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ [ - 1 ] * N for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> G [ A ] [ B ] = C <NEWLINE> G [ B ] [ A ] = C <NEWLINE> <DEDENT> g = csgraph_from_dense ( G , null_value = - 1 ) <NEWLINE> D = dijkstra ( g ) <NEWLINE> G2 = [ [ - 1 ] * N for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if D [ i ] [ j ] >= 0 and D [ i ] [ j ] <= L : <NEWLINE> <INDENT> G2 [ i ] [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> g2 = csgraph_from_dense ( G2 , null_value = - 1 ) <NEWLINE> D = dijkstra ( g2 ) <NEWLINE> <NL> <NL> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> t -= 1 <NEWLINE> if D [ s ] [ t ] <= N ** 2 : <NEWLINE> <INDENT> print ( int ( D [ s ] [ t ] ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = input ( ) <NEWLINE> prod = 1 <NEWLINE> k = 1 ; <NEWLINE> l = list ( map ( int , arr . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> <NL> for x in l : <NEWLINE> <INDENT> if ( x == 0 ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( k == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in l : <NEWLINE> <INDENT> prod *= x <NEWLINE> if ( prod > 1000000000000000000 ) : <NEWLINE> <INDENT> prod = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> if K >= 3 : <NEWLINE> <INDENT> for i in range ( 1 , K - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , K ) : <NEWLINE> <INDENT> for k in range ( j + 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( gcd ( i , j ) , k ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> table = [ - 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , s = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( s - 1 ) ; edges [ s - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> l = [ 0 ] <NEWLINE> print ( ) <NEWLINE> from collections import deque as que <NEWLINE> q = que ( [ ( - 1 , 0 ) ] ) <NEWLINE> p = que ( ) <NEWLINE> flag = 1 <NEWLINE> ok = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> while len ( q ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> pre , now = q . pop ( ) <NEWLINE> if table [ now ] == - 1 : <NEWLINE> <INDENT> ok += 1 <NEWLINE> table [ now ] = pre + 1 <NEWLINE> for i in edges [ now ] : <NEWLINE> <INDENT> if table [ i ] == - 1 : <NEWLINE> <INDENT> p . append ( ( now , i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> p , q = q , p <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if ok == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( table [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE>
N , M = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> import collections <NEWLINE> Parent = [ i for i in range ( N ) ] <NEWLINE> def fp ( i ) : <NEWLINE> <INDENT> global Parent <NEWLINE> if Parent [ i ] == i : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Parent [ i ] = fp ( Parent [ i ] ) <NEWLINE> return Parent [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> par_a , par_b = fp ( a - 1 ) , fp ( b - 1 ) <NEWLINE> if par_a < par_b : <NEWLINE> <INDENT> Parent [ par_b ] = par_a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Parent [ par_a ] = par_b <NEWLINE> <NL> <DEDENT> <DEDENT> Groupsize = collections . defaultdict ( lambda : 0 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> i = fp ( i ) <NEWLINE> Groupsize [ i ] += 1 <NEWLINE> <DEDENT> ans = max ( gs for gs in Groupsize . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE>
while True : <NEWLINE> <INDENT> card_num = int ( input ( ) ) <NEWLINE> if ( card_num == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( card_num ) : <NEWLINE> <INDENT> comp = input ( ) <NEWLINE> if ( int ( comp [ 0 ] ) == int ( comp [ 2 ] ) ) : <NEWLINE> <INDENT> a += int ( comp [ 0 ] ) <NEWLINE> b += int ( comp [ 0 ] ) <NEWLINE> <DEDENT> elif ( int ( comp [ 0 ] ) > int ( comp [ 2 ] ) ) : <NEWLINE> <INDENT> a += int ( comp [ 0 ] ) + int ( comp [ 2 ] ) <NEWLINE> <DEDENT> elif ( int ( comp [ 0 ] ) < int ( comp [ 2 ] ) ) : <NEWLINE> <INDENT> b += int ( comp [ 0 ] ) + int ( comp [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> count = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> count += a * ( N - c ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( a , min ( a + k , b + 1 ) , 1 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> for i in range ( b , max ( a , b - k ) , - 1 ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> ans = list ( set ( ans ) ) <COMMENT> <NEWLINE> ans . sort ( ) <COMMENT> <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> print ( ( n * ( n - 1 ) ) // 2 ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> Info = [ [ ] for T in range ( 0 , N ) ] <NEWLINE> for I in range ( 0 , N ) : <NEWLINE> <INDENT> Info [ I ] = [ int ( T ) for T in input ( ) . split ( ) ] <NEWLINE> <DEDENT> Info = sorted ( Info , reverse = True , key = lambda X : X [ 2 ] ) <NEWLINE> for CX in range ( 0 , 101 ) : <NEWLINE> <INDENT> for CY in range ( 0 , 101 ) : <NEWLINE> <INDENT> Flag = True <NEWLINE> BaseH = abs ( Info [ 0 ] [ 0 ] - CX ) + abs ( Info [ 0 ] [ 1 ] - CY ) + Info [ 0 ] [ 2 ] <NEWLINE> for I in range ( 1 , N ) : <NEWLINE> <INDENT> if max ( BaseH - abs ( Info [ I ] [ 0 ] - CX ) - abs ( Info [ I ] [ 1 ] - CY ) , 0 ) != Info [ I ] [ 2 ] : <NEWLINE> <INDENT> Flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> Ans = [ str ( CX ) , str ( CY ) , str ( BaseH ) ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( Ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> T = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> T [ a - 1 ] . append ( ( b - 1 , c ) ) <NEWLINE> T [ b - 1 ] . append ( ( a - 1 , c ) ) <NEWLINE> <NL> <DEDENT> Q , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ - 1 ] * N <NEWLINE> D [ K - 1 ] = 0 <NEWLINE> def dfs ( start , nowd ) : <NEWLINE> <INDENT> to = T [ start ] <NEWLINE> for t in to : <NEWLINE> <INDENT> next_node , c = t <NEWLINE> if D [ next_node ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nextd = nowd + c <NEWLINE> D [ next_node ] = nextd <NEWLINE> dfs ( next_node , nextd ) <NEWLINE> <DEDENT> <DEDENT> dfs ( K - 1 , 0 ) <NEWLINE> <COMMENT> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( D [ x - 1 ] + D [ y - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> totalsqr = ( sum ( l ) ) ** 2 <NEWLINE> <NL> individualsqrsum = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> individualsqrsum += i ** 2 <NEWLINE> <NL> <DEDENT> ans = ( totalsqr - individualsqrsum ) // 2 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd , string = input ( ) . split ( ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> d [ string ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if d [ string ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 4000 ) <NEWLINE> <NL> import math <NEWLINE> p = math . log ( 1.01 , 10 ) <NEWLINE> q = int ( math . log ( x / 100 , 10 ) / p ) <NEWLINE> <NL> <NL> def f ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 101 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return int ( f ( n - 1 ) * 1.01 ) <NEWLINE> <DEDENT> <DEDENT> n = q <NEWLINE> while f ( n ) < x : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> counter = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - counter ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> route = defaultdict ( int ) <NEWLINE> i = 0 <NEWLINE> loop = [ ] <NEWLINE> tail = [ ] <NEWLINE> <NL> while route [ i ] < 2 : <NEWLINE> <NL> <INDENT> if route [ i ] == 0 : <NEWLINE> <INDENT> tail . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop . append ( i ) <NEWLINE> <NL> <DEDENT> route [ i ] += 1 <NEWLINE> i = a [ i ] - 1 <NEWLINE> <NL> <DEDENT> if len ( tail ) > k : <NEWLINE> <INDENT> print ( tail [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = len ( tail ) - len ( loop ) <NEWLINE> print ( loop [ ( k - temp ) % len ( loop ) ] + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> f = [ { } for _ in range ( N + 1 ) ] <COMMENT> <NEWLINE> if len ( f ) > 6 : <NEWLINE> <INDENT> f [ 6 ] = { ( 1 , 1 , 1 ) : 1 } <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> args = f [ i ] <NEWLINE> for ( x , y , z ) , k in args . items ( ) : <NEWLINE> <INDENT> index = i + 2 * x + y + z + 1 <NEWLINE> arg = ( x + 1 , y , z ) <NEWLINE> if index < N + 1 : <NEWLINE> <INDENT> f [ index ] [ arg ] = 1 <NEWLINE> <DEDENT> index = i + x + 2 * y + z + 1 <NEWLINE> arg = ( x , y + 1 , z ) <NEWLINE> if index < N + 1 : <NEWLINE> <INDENT> f [ index ] [ arg ] = 1 <NEWLINE> <DEDENT> index = i + x + y + 2 * z + 1 <NEWLINE> arg = ( x , y , z + 1 ) <NEWLINE> if index < N + 1 : <NEWLINE> <INDENT> f [ index ] [ arg ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( sum ( f [ i ] . values ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> maxh = [ 0 ] * n <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> maxh [ a - 1 ] = max ( maxh [ a - 1 ] , hlist [ b - 1 ] ) <NEWLINE> maxh [ b - 1 ] = max ( maxh [ b - 1 ] , hlist [ a - 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if maxh [ i ] < hlist [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] = B [ A [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <NL> <NL> x = int ( input ( ) ) <NEWLINE> for b in itertools . count ( ) : <NEWLINE> <INDENT> for a in itertools . count ( b ) : <NEWLINE> <INDENT> a5b5 = a ** 5 + b ** 5 <NEWLINE> if a5b5 == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> a5b5 = a ** 5 - b ** 5 <NEWLINE> if a5b5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if x < a5b5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import base64 <NEWLINE> import subprocess <NEWLINE> import zlib <NEWLINE> <NL> <NL> exe_bin = <STRING> <NEWLINE> <NL> open ( <STRING> , <STRING> ) . write ( zlib . decompress ( base64 . b85decode ( exe_bin ) ) ) <NEWLINE> subprocess . run ( [ <STRING> ] , shell = True ) <NEWLINE> subprocess . run ( [ <STRING> ] , shell = True ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = list ( range ( 0 , 102 ) ) <NEWLINE> if y != 0 : <NEWLINE> <INDENT> L2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( L2 ) ) : <NEWLINE> <INDENT> L . remove ( L2 [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> t = len ( L ) // 2 <NEWLINE> <NL> for j in range ( len ( L ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if L [ t ] >= x : <NEWLINE> <COMMENT> <NL> <INDENT> if t == 0 : <NEWLINE> <INDENT> print ( L [ t ] ) <NEWLINE> break <NEWLINE> <DEDENT> elif L [ t - 1 ] <= x : <NEWLINE> <INDENT> if abs ( L [ t ] - x ) < abs ( L [ t - 1 ] - x ) : <NEWLINE> <INDENT> print ( L [ t ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( L [ t - 1 ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> t = t // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t == y - 1 : <NEWLINE> <INDENT> print ( L [ t ] ) <NEWLINE> break <NEWLINE> <DEDENT> elif L [ t + 1 ] >= x : <NEWLINE> <INDENT> if abs ( L [ t ] - x ) > abs ( L [ t + 1 ] - x ) : <NEWLINE> <INDENT> print ( L [ t + 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( L [ t ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> t = t + ( len ( L ) - t ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> t = len ( s ) <NEWLINE> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> b = set ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <DEDENT> <DEDENT> d = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for ri in r : <NEWLINE> <INDENT> for gi in g : <NEWLINE> <INDENT> dist = abs ( ri - gi ) <NEWLINE> if ri > gi : <NEWLINE> <INDENT> bi = dist + ri <NEWLINE> if bi in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> bi = gi - dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> bi = dist + gi <NEWLINE> if bi in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> bi = ri - dist <NEWLINE> if bi in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ri + gi ) % 2 == 0 : <NEWLINE> <INDENT> bi = ( ri + gi ) / 2 <NEWLINE> if bi in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> S = Counter ( S ) . most_common ( ) <NEWLINE> l = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> if i [ 1 ] == S [ 0 ] [ 1 ] : l . append ( i [ 0 ] ) <NEWLINE> <NL> <DEDENT> l = sorted ( l ) <NEWLINE> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = a <NEWLINE> <NL> if a > k : <NEWLINE> <INDENT> ak = a - k <NEWLINE> ans = ans - ak <NEWLINE> <DEDENT> if a + b < k : <NEWLINE> <INDENT> ans = ans - ( k - ( a + b ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a_li [ i - k ] < a_li [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = sorted ( a ) <NEWLINE> max1 = ans [ - 1 ] <NEWLINE> max2 = ans [ - 2 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == max1 : <NEWLINE> <INDENT> print ( max2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a_dict = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in a_dict : <NEWLINE> <INDENT> a_dict [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> replace = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> m , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> replace . append ( ( m , n ) ) <NEWLINE> <NL> <DEDENT> res = sum ( [ m * n for m , n in a_dict . items ( ) ] ) <NEWLINE> <NL> for r in replace : <NEWLINE> <INDENT> if r [ 0 ] in a_dict : <NEWLINE> <INDENT> res += ( r [ 1 ] - r [ 0 ] ) * a_dict [ r [ 0 ] ] <NEWLINE> <NL> if r [ 1 ] in a_dict : <NEWLINE> <INDENT> a_dict [ r [ 1 ] ] += a_dict [ r [ 0 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ r [ 1 ] ] = a_dict [ r [ 0 ] ] <NEWLINE> <DEDENT> a_dict [ r [ 0 ] ] = 0 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
r , g , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( g * 10 + b ) % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> sr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> ir = lambda : int ( sr ( ) ) <NEWLINE> lr = lambda : list ( map ( int , sr ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> N , S = lr ( ) <NEWLINE> A = lr ( ) <NEWLINE> dp = np . zeros ( S + 1 , np . int64 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prev = dp . copy ( ) <NEWLINE> dp [ a : ] += dp [ : - a ] <NEWLINE> dp += prev <NEWLINE> dp %= MOD <NEWLINE> <NL> <DEDENT> answer = dp [ S ] <NEWLINE> print ( answer % MOD ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A , B , C = [ list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( 3 ) ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> def bs_l ( lis , x ) : <NEWLINE> <INDENT> low , high = 0 , len ( lis ) <NEWLINE> while low < high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if lis [ mid ] < x : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <DEDENT> def bs_r ( lis , x ) : <NEWLINE> <INDENT> low , high = 0 , len ( lis ) <NEWLINE> while low < high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> if lis [ mid ] > x : <NEWLINE> <INDENT> high = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return low <NEWLINE> <NL> <DEDENT> for i in B : <NEWLINE> <INDENT> count += bs_l ( A , i ) * ( N - bs_r ( C , i ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> S = input ( ) <NEWLINE> P = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> mod = 2019 <NEWLINE> d = 1 <NEWLINE> for i in range ( len ( S ) , 0 , - 1 ) : <NEWLINE> <INDENT> P [ i - 1 ] = int ( S [ i - 1 ] ) * d + P [ i ] <NEWLINE> P [ i - 1 ] = P [ i - 1 ] % mod <NEWLINE> d *= 10 <NEWLINE> d = d % mod <NEWLINE> <NL> <DEDENT> P = Counter ( P ) <NEWLINE> ans = 0 <NEWLINE> for p in P . values ( ) : <NEWLINE> <INDENT> ans += p * ( p - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( A_list ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> if a > 0 and b > 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a < 0 and b < 0 : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dic = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if not a in dic : <NEWLINE> <INDENT> dic [ a ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in dic : <NEWLINE> <INDENT> if dic [ a ] > 1 : <NEWLINE> <INDENT> ans += dic [ a ] * ( dic [ a ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> ansdic = { } <NEWLINE> <NL> for a in dic : <NEWLINE> <INDENT> ansdic [ a ] = ans <NEWLINE> if dic [ a ] > 1 : <NEWLINE> <INDENT> ansdic [ a ] = ans - ( dic [ a ] - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> print ( ansdic [ a ] ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> t , c = int ( a . split ( <STRING> ) [ 0 ] ) , int ( a . split ( <STRING> ) [ 1 ] ) <NEWLINE> <NL> if not c : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> lst = [ int ( x ) for x in b . split ( <STRING> ) ] <NEWLINE> <NL> for i in range ( c + 2 ) : <NEWLINE> <INDENT> if t - i not in lst : <NEWLINE> <INDENT> print ( t - i ) <NEWLINE> break <NEWLINE> <DEDENT> if t + i not in lst : <NEWLINE> <INDENT> print ( t + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> flag = 1 <NEWLINE> upper = pow ( 10 , 18 ) <NEWLINE> for num in nums : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> sum = 0 <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> sum = sum * num <NEWLINE> if sum > upper : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> elif flag == 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = collections . Counter ( int ( T ) for T in input ( ) . split ( ) ) . most_common ( ) <NEWLINE> Remove = 0 <NEWLINE> for T in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> if A [ T ] [ 0 ] > A [ T ] [ 1 ] : <NEWLINE> <INDENT> Remove += A [ T ] [ 1 ] <NEWLINE> <DEDENT> elif A [ T ] [ 0 ] < A [ T ] [ 1 ] : <NEWLINE> <INDENT> Remove += A [ T ] [ 1 ] - A [ T ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( Remove ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n > 60 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = [ ] <COMMENT> <NEWLINE> for i in range ( 1 , int ( p ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> s = [ ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] ** n <= p and p % ( l [ i ] ** n ) == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> s . append ( l [ i ] ) <NEWLINE> <DEDENT> if l [ i ] ** n > p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> cnt = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> cnt *= ai <NEWLINE> if cnt > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for num in range ( A , min ( B + 1 , A + K ) ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> for num in range ( max ( A + K , B - K + 1 ) , B + 1 ) : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> if B + 1 < N : <NEWLINE> <INDENT> C = B + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = N <NEWLINE> <DEDENT> if B // A == 0 : <NEWLINE> <INDENT> D = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = B // A <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 1 , C + D , D ) : <NEWLINE> <INDENT> val = math . floor ( A * i / B ) - A * math . floor ( i / B ) <NEWLINE> <COMMENT> <NL> ans = max ( ans , val ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n // 2 == 1 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n < 20 : <NEWLINE> <INDENT> d = a . copy ( ) <NEWLINE> <NL> for i in range ( 1 , n // 2 ) : <NEWLINE> <INDENT> b = [ 0 ] * n <NEWLINE> c = - 10 ** 24 <NEWLINE> ans = - 10 ** 24 <NEWLINE> for j in range ( i * 2 , n ) : <NEWLINE> <INDENT> c = max ( c , a [ j - 2 ] ) <NEWLINE> b [ j ] = c + d [ j ] <NEWLINE> ans = max ( ans , c + d [ j ] ) <NEWLINE> <NL> <DEDENT> a = b . copy ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = a [ : 10 ] <NEWLINE> e = [ True ] * 10 <NEWLINE> <NL> for i in range ( 1 , n // 2 ) : <NEWLINE> <INDENT> c = [ 0 ] * 10 <NEWLINE> f = [ False ] * 10 <NEWLINE> d = - 10 ** 24 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if 2 * i + j >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not e [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d = max ( d , b [ j ] ) <NEWLINE> c [ j ] = d + a [ 2 * i + j ] <NEWLINE> f [ j ] = True <NEWLINE> <DEDENT> e = f . copy ( ) <NEWLINE> b = c . copy ( ) <NEWLINE> <DEDENT> ans = - 10 ** 24 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if e [ i ] : <NEWLINE> <INDENT> ans = max ( ans , b [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> class Uf : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . p = list ( range ( N ) ) <NEWLINE> self . rank = [ 0 ] * N <NEWLINE> self . size = [ 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . p [ x ] != x : <NEWLINE> <INDENT> self . p [ x ] = self . root ( self . p [ x ] ) <NEWLINE> <NL> <DEDENT> return self . p [ x ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> u = self . root ( x ) <NEWLINE> v = self . root ( y ) <NEWLINE> <NL> if u == v : return <NEWLINE> <NL> if self . rank [ u ] < self . rank [ v ] : <NEWLINE> <INDENT> self . p [ u ] = v <NEWLINE> self . size [ v ] += self . size [ u ] <NEWLINE> self . size [ u ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ v ] = u <NEWLINE> self . size [ u ] += self . size [ v ] <NEWLINE> self . size [ v ] = 0 <NEWLINE> <NL> if self . rank [ u ] == self . rank [ v ] : <NEWLINE> <INDENT> self . rank [ u ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def count ( self , x ) : <NEWLINE> <INDENT> return self . size [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = mi ( ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> A , B = i2 ( M ) <NEWLINE> <NL> uf = Uf ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> uf . unite ( A [ i ] - 1 , B [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( max ( uf . count ( i ) for i in range ( N ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( 1 * K ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> K -= A <NEWLINE> if B >= K : <NEWLINE> <INDENT> print ( 1 * A ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> K -= B <NEWLINE> if K <= C : <NEWLINE> <INDENT> print ( 1 * A + - 1 * K ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> d = [ - 1 , 0 , 1 ] <NEWLINE> def search ( x , y , m ) : <NEWLINE> <INDENT> if not ( 0 <= x < len ( m [ 0 ] ) and 0 <= y < len ( m ) ) or m [ y ] [ x ] == <STRING> : return <NEWLINE> m [ y ] [ x ] = <STRING> <NEWLINE> for dy in d : <NEWLINE> <INDENT> for dx in d : <NEWLINE> <INDENT> search ( x + dx , y + dy , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == h == 0 : break <NEWLINE> m = [ input ( ) . split ( ) for _ in range ( h ) ] <NEWLINE> c = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if m [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> search ( x , y , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> t = 7 <NEWLINE> flag = True <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if t % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( t * 10 + 7 ) % k <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if len ( str ( ans ) ) >= 19 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 1000000000000000000 : <NEWLINE> <INDENT> ans = 1000000000000000000 <NEWLINE> <DEDENT> elif len ( str ( ans ) ) >= 19 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
L = 1000000000000000000 <NEWLINE> r = 1 <NEWLINE> n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = True <NEWLINE> while len ( A ) > 0 : <NEWLINE> <INDENT> b = A . pop ( ) <NEWLINE> r *= b <NEWLINE> if r > L : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> p = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p : print ( r ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { k : v for k , v in zip ( range ( 26 ) , <STRING> ) } <NEWLINE> i = 1 <NEWLINE> while n > 26 ** i : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> i += 1 <NEWLINE> <DEDENT> res = <STRING> <NEWLINE> n -= 1 <NEWLINE> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> jn , n = divmod ( n , 26 ** j ) <NEWLINE> res += d [ jn ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> h [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> h = sorted ( h ) <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( N - ( K - 1 ) ) : <NEWLINE> <INDENT> tmp = h [ i + K - 1 ] - h [ i ] <NEWLINE> ans = min ( tmp , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> nums . append ( x ) <NEWLINE> <NL> <DEDENT> max = float ( <STRING> ) <NEWLINE> min = nums [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if nums [ i ] - min > max : <NEWLINE> <INDENT> max = nums [ i ] - min <NEWLINE> <NL> <DEDENT> if nums [ i ] < min : <NEWLINE> <INDENT> min = nums [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( [ 0 , 1 , 9 , 30 , 76 , 141 , 267 , 400 , 624 , 885 , 1249 , 1590 , 2208 , 2689 , 3411 , 4248 , 5248 , 6081 , 7485 , 8530 , 10248 , 11889 , 13687 , 15228 , 17988 , 20053 , 22569 , 25242 , 28588 , 31053 , 35463 , 38284 , 42540 , 46581 , 50893 , 55362 , 61824 , 65857 , 71247 , 76884 , 84388 , 89349 , 97881 , 103342 , 111528 , 120141 , 128047 , 134580 , 146316 , 154177 , 164817 , 174438 , 185836 , 194157 , 207927 , 218812 , 233268 , 245277 , 257857 , 268182 , 288216 , 299257 , 313635 , 330204 , 347836 , 362973 , 383709 , 397042 , 416448 , 434025 , 456967 , 471948 , 499740 , 515581 , 536073 , 559758 , 583960 , 604833 , 633651 , 652216 , 683712 , 709065 , 734233 , 754734 , 793188 , 818917 , 846603 , 874512 , 909496 , 933081 , 977145 , 1006126 , 1041504 , 1073385 , 1106467 , 1138536 , 1187112 , 1215145 , 1255101 , 1295142 , 1342852 , 1373253 , 1422195 , 1453816 , 1502376 , 1553361 , 1595437 , 1629570 , 1691292 , 1726717 , 1782111 , 1827492 , 1887772 , 1925853 , 1986837 , 2033674 , 2089776 , 2145333 , 2197483 , 2246640 , 2332104 , 2379085 , 2434833 , 2490534 , 2554600 , 2609625 , 2693919 , 2742052 , 2813988 , 2875245 , 2952085 , 3003306 , 3096024 , 3157249 , 3224511 , 3306240 , 3388576 , 3444609 , 3533637 , 3591322 , 3693924 , 3767085 , 3842623 , 3912324 , 4027884 , 4102093 , 4181949 , 4270422 , 4361548 , 4427853 , 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> <INDENT> [ K ] ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import Counter , deque <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n_minus = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> n_minus += 1 <NEWLINE> <DEDENT> <DEDENT> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> elif n_minus == N and K % 2 == 1 : <NEWLINE> <INDENT> def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 10 ** 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return abs ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> A = sorted ( A , key = f ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = sorted ( A , key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> plus = deque ( ) <NEWLINE> minus = deque ( ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if A [ i ] >= 0 : <NEWLINE> <INDENT> plus . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( minus ) % 2 == 1 : <NEWLINE> <INDENT> if len ( plus ) == 0 : <NEWLINE> <INDENT> minus . pop ( ) <NEWLINE> for a in A [ K : ] : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> plus . append ( a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = None <NEWLINE> m = None <NEWLINE> for a in A [ K : ] : <NEWLINE> <INDENT> if a >= 0 and p is None : <NEWLINE> <INDENT> p = a <NEWLINE> <DEDENT> if a < 0 and m is None : <NEWLINE> <INDENT> m = a <NEWLINE> <DEDENT> if p is not None and m is not None : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if m is None : <NEWLINE> <INDENT> minus . pop ( ) <NEWLINE> plus . append ( p ) <NEWLINE> <DEDENT> elif p is None : <NEWLINE> <INDENT> plus . pop ( ) <NEWLINE> minus . append ( m ) <NEWLINE> <DEDENT> elif minus [ - 1 ] * m > plus [ - 1 ] * p : <NEWLINE> <INDENT> plus . pop ( ) <NEWLINE> minus . append ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . pop ( ) <NEWLINE> plus . append ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> while plus : <NEWLINE> <INDENT> ans *= plus . popleft ( ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> while minus : <NEWLINE> <INDENT> ans *= minus . popleft ( ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> A , B , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> a_divisor = divisor ( A ) <NEWLINE> b_divisor = divisor ( B ) <NEWLINE> <NL> print ( sorted ( list ( set ( a_divisor ) & set ( b_divisor ) ) , reverse = True ) [ K - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 20000 ) <NEWLINE> h = 0 <NEWLINE> w = 0 <NEWLINE> list1 = [ ] <NEWLINE> <NL> def dfs ( x , y , f ) : <NEWLINE> <INDENT> list1 [ y ] = list1 [ y ] [ : x ] + <STRING> + list1 [ y ] [ x + 1 : ] <NEWLINE> <NL> if y - 1 >= 0 : <NEWLINE> <INDENT> if list1 [ y - 1 ] [ x ] == f : <NEWLINE> <INDENT> dfs ( x , y - 1 , f ) <NEWLINE> <DEDENT> <DEDENT> if y + 1 < h : <NEWLINE> <INDENT> if list1 [ y + 1 ] [ x ] == f : <NEWLINE> <INDENT> dfs ( x , y + 1 , f ) <NEWLINE> <DEDENT> <DEDENT> if x - 1 >= 0 : <NEWLINE> <INDENT> if list1 [ y ] [ x - 1 ] == f : <NEWLINE> <INDENT> dfs ( x - 1 , y , f ) <NEWLINE> <DEDENT> <DEDENT> if x + 1 < w : <NEWLINE> <INDENT> if list1 [ y ] [ x + 1 ] == f : <NEWLINE> <INDENT> dfs ( x + 1 , y , f ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> h , w = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if 0 in ( h , w ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = 0 <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> list1 . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> if list1 [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> dfs ( j , i , list1 [ i ] [ j ] ) <NEWLINE> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE> list1 = [ ] <NEWLINE> <DEDENT>
<COMMENT> <NL> def dfs ( p , s , c , cmin , cmax ) : <NEWLINE> <INDENT> if len ( p ) == 0 : <NEWLINE> <INDENT> return solve ( s , c , cmin , cmax ) <NEWLINE> <DEDENT> lower , u = p [ 0 ] <NEWLINE> c += lower <NEWLINE> if u <= 9 : <NEWLINE> <INDENT> cmin [ lower ] = 0 <NEWLINE> cmax [ lower ] = u <NEWLINE> return dfs ( p [ 1 : ] , s , c , cmin , cmax ) <NEWLINE> <NL> <DEDENT> cmin [ lower ] = 0 <NEWLINE> cmax [ lower ] = 9 <NEWLINE> ret = dfs ( p [ 1 : ] , s , c , cmin , cmax ) <NEWLINE> <NL> upper = lower . upper ( ) <NEWLINE> s = s . translate ( str . maketrans ( { lower : upper + lower } ) ) <NEWLINE> <NL> c += upper <NEWLINE> if u % 10 == 9 : <NEWLINE> <INDENT> cmin [ upper ] = 1 <NEWLINE> cmax [ upper ] = u // 10 <NEWLINE> return ret + dfs ( p [ 1 : ] , s , c , cmin , cmax ) <NEWLINE> <DEDENT> if 20 <= u : <NEWLINE> <INDENT> cmin [ upper ] = 1 <NEWLINE> cmax [ upper ] = u // 10 - 1 <NEWLINE> ret += dfs ( p [ 1 : ] , s , c , cmin , cmax ) <NEWLINE> <DEDENT> cmin [ lower ] = 0 <NEWLINE> cmax [ lower ] = u % 10 <NEWLINE> cmin [ upper ] = u // 10 <NEWLINE> cmax [ upper ] = u // 10 <NEWLINE> return ret + dfs ( p [ 1 : ] , s , c , cmin , cmax ) <NEWLINE> <COMMENT> <NL> <DEDENT> def solve ( s , c , cmin , cmax ) : <NEWLINE> <INDENT> uf = [ - 1 ] * 128 <NEWLINE> s1 = map ( ord , s [ : len ( s ) // 2 ] ) <NEWLINE> s2 = map ( ord , s [ : : - 1 ] [ : len ( s ) // 2 ] ) <NEWLINE> for p , q in zip ( s1 , s2 ) : <NEWLINE> <INDENT> p = root ( uf , p ) <NEWLINE> q = root ( uf , q ) <NEWLINE> if p != q : <NEWLINE> <INDENT> if uf [ p ] >= uf [ q ] : <NEWLINE> <INDENT> uf [ p ] += uf [ q ] <NEWLINE> uf [ q ] = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> uf [ q ] += uf [ p ] <NEWLINE> uf [ p ] = q <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> nmin , nmax = { } , { } <NEWLINE> for ci in c : <NEWLINE> <INDENT> p = root ( uf , ord ( ci ) ) <NEWLINE> p = str ( p ) <NEWLINE> try : <NEWLINE> <INDENT> nmax [ p ] = min ( nmax [ p ] , cmax [ ci ] ) <NEWLINE> nmin [ p ] = max ( nmin [ p ] , cmin [ ci ] ) <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> nmax [ p ] = cmax [ ci ] <NEWLINE> nmin [ p ] = cmin [ ci ] <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 1 <NEWLINE> for p in nmax . keys ( ) : <NEWLINE> <INDENT> if nmax [ p ] < nmin [ p ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> ret *= nmax [ p ] - nmin [ p ] + 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def root ( uf , p ) : <NEWLINE> <INDENT> if uf [ p ] < 0 : <NEWLINE> <INDENT> return p <NEWLINE> <DEDENT> uf [ p ] = root ( uf , uf [ p ] ) <NEWLINE> return uf [ p ] <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> _ , _ = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> s = f . readline ( ) . strip ( ) <NEWLINE> p = [ line . split ( ) for line in f ] <NEWLINE> for pi in p : <NEWLINE> <INDENT> pi [ 1 ] = int ( pi [ 1 ] ) <NEWLINE> <DEDENT> cmin , cmax = { str ( i ) : i for i in range ( 10 ) } , { str ( i ) : i for i in range ( 10 ) } <NEWLINE> characters = <STRING> <NEWLINE> print ( dfs ( p , s , characters , cmin , cmax ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> A = sorted ( AB , key = lambda x : x [ 0 ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> buy = min ( M , A [ i ] [ 1 ] ) <NEWLINE> ans += buy * A [ i ] [ 0 ] <NEWLINE> M -= buy <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> sentence = sys . stdin . read ( ) . lower ( ) <NEWLINE> alf = [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <NEWLINE> <NL> ans = dict ( zip ( alf , [ 0 ] * 26 ) ) <NEWLINE> <NL> for a in sentence : <NEWLINE> <INDENT> if a in ans : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for ( key , val ) in sorted ( ans . items ( ) ) : <NEWLINE> <INDENT> print ( key , <STRING> , val ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> nums = list ( range ( 1 , k + 1 ) ) <NEWLINE> for balls in itertools . combinations_with_replacement ( nums , 3 ) : <NEWLINE> <INDENT> i , j , l = balls [ 0 ] , balls [ 1 ] , balls [ 2 ] <NEWLINE> ans = gcd ( i , j ) <NEWLINE> ans = gcd ( ans , l ) <NEWLINE> if len ( set ( balls ) ) == 1 : <NEWLINE> <INDENT> answer += ans <NEWLINE> <DEDENT> elif len ( set ( balls ) ) == 2 : <NEWLINE> <INDENT> answer += ans * 3 <NEWLINE> <DEDENT> elif len ( set ( balls ) ) == 3 : <NEWLINE> <INDENT> answer += ans * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( 1 , k ) : <NEWLINE> <INDENT> for l in range ( 1 , k ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
pi = 3.141592653589793 <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * r * pi ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> K_main = X // D <NEWLINE> K_sub = K - K_main <NEWLINE> <NL> if ( K_sub < 0 ) : <NEWLINE> <INDENT> print ( abs ( X - D * K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = abs ( X - D * K_main ) <NEWLINE> if ( K_sub % 2 == 0 ) : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( answer - D ) ) <NEWLINE> <DEDENT> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = collections . Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( A [ i + 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ) <NEWLINE> <NL> cnt = defaultdict ( int ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> cnt [ b ] += 1 <NEWLINE> <DEDENT> ans = all ( cnt [ i ] % 2 == 0 for i in cnt ) <NEWLINE> print ( <STRING> if ans else <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> toujou = [ 0 ] * N <NEWLINE> toujou [ 0 ] = 1 <NEWLINE> kosuu = 1 <NEWLINE> tadoru = [ 1 ] <NEWLINE> pin = 1 <NEWLINE> tmp = 1 <NEWLINE> while pin == 1 : <NEWLINE> <INDENT> tmp = A [ tmp - 1 ] <NEWLINE> toujou [ tmp - 1 ] += 1 <NEWLINE> if toujou [ tmp - 1 ] == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tadoru . append ( tmp ) <NEWLINE> kosuu += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> loop_start = tadoru . index ( tmp ) <NEWLINE> loop = kosuu - loop_start <NEWLINE> if K < kosuu : <NEWLINE> <INDENT> print ( tadoru [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - loop_start <NEWLINE> a = K % loop <NEWLINE> print ( tadoru [ loop_start + a ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> def solve ( h , n ) : <NEWLINE> <INDENT> if ( 4 * h * n - N * n - N * h ) == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> w = N * h * n // ( 4 * h * n - N * n - N * h ) <NEWLINE> if w < 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if w * ( 4 * h * n - N * n - N * h ) == N * h * n : <NEWLINE> <INDENT> print ( h , n , w ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if N < 2000 : <NEWLINE> <INDENT> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <INDENT> solve ( h , n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for h in reversed ( range ( 1 , 3501 ) ) : <NEWLINE> <INDENT> for n in reversed ( range ( 1 , 3501 ) ) : <NEWLINE> <INDENT> solve ( h , n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
ans = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> s = <STRING> <NEWLINE> while i < h : <NEWLINE> <INDENT> s += <STRING> * w <NEWLINE> s += <STRING> <NEWLINE> i += 1 <NEWLINE> <DEDENT> ans += s + <STRING> <NEWLINE> <DEDENT> <DEDENT> if ans != <STRING> : <NEWLINE> <INDENT> print ( ans [ : - 1 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def search ( n , d , t ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> e = n - 1 <NEWLINE> r = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if b > e : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 1 <NEWLINE> i = ( b + e ) // 2 <NEWLINE> if t == d [ i ] : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> elif t < d [ i ] : <NEWLINE> <INDENT> e = i - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = i + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> m = search ( n , d , t ) <NEWLINE> print ( m ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> B = [ int ( b ) for b in input ( ) . split ( <STRING> ) ] <NEWLINE> C = [ int ( c ) for c in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> combiBC = [ 0 ] * len ( B ) <NEWLINE> <COMMENT> <NL> <NL> ic = 0 <NEWLINE> lc = len ( C ) <NEWLINE> for ib in range ( len ( B ) ) : <NEWLINE> <INDENT> b = B [ ib ] <NEWLINE> while ic < lc : <NEWLINE> <INDENT> c = C [ ic ] <NEWLINE> if b >= c : <NEWLINE> <INDENT> ic += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> combiBC [ ib ] = lc - ic <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sumCombiBC = [ ] <NEWLINE> for i in range ( len ( combiBC ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> sumCombiBC . append ( combiBC [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sumCombiBC . insert ( 0 , combiBC [ - i - 1 ] + sumCombiBC [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> ib = 0 <NEWLINE> for ia in range ( len ( A ) ) : <NEWLINE> <INDENT> a = A [ ia ] <NEWLINE> while ib < len ( B ) : <NEWLINE> <INDENT> b = B [ ib ] <NEWLINE> if a >= b : <NEWLINE> <INDENT> ib += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += sumCombiBC [ ib ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> def solve ( x ) : <NEWLINE> <INDENT> if x >= 2000 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> memo = [ True ] + [ False ] * x <NEWLINE> <NL> def dp ( k ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( 100 , 106 ) : <NEWLINE> <INDENT> if k - i >= 0 and memo [ k - i ] : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> memo [ i + 1 ] = dp ( i + 1 ) <NEWLINE> <DEDENT> return memo [ x ] <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> print ( int ( solve ( X ) ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import math <NEWLINE> from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 0 <NEWLINE> L = deque ( [ 0 ] ) <NEWLINE> R = deque ( [ 0 ] ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> L . append ( math . gcd ( L [ - 1 ] , A [ i - 1 ] ) ) <NEWLINE> R . appendleft ( math . gcd ( R [ 0 ] , A [ N - i ] ) ) <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> m = math . gcd ( L [ j ] , R [ j + 1 ] ) <NEWLINE> M = max ( M , m ) <NEWLINE> <DEDENT> print ( M ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = n // i <NEWLINE> end = i * num <NEWLINE> ans += ( num / 2 ) * ( end + i ) <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
iterator = ( ( <STRING> , <STRING> ) , ( <STRING> , <STRING> ) ) <NEWLINE> var = { } <NEWLINE> <NL> for i , j in iterator : <NEWLINE> <INDENT> var [ i ] = int ( input ( ) ) <NEWLINE> var [ j ] = [ int ( k ) for k in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for T in var [ <STRING> ] : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( var [ <STRING> ] ) <NEWLINE> while ( left < right ) : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if var [ <STRING> ] [ mid ] == T : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif var [ <STRING> ] [ mid ] <= T : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if N % a == 0 : <NEWLINE> <INDENT> b_max = int ( N / a ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_max = int ( N // a ) <NEWLINE> <NL> <DEDENT> ans += b_max <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = 1 <NEWLINE> <COMMENT> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif max ( A ) > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> B *= i <NEWLINE> if B > 10 ** 18 : <NEWLINE> <INDENT> B = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( B ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 1 ] <NEWLINE> p = [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( 2 * a [ i ] + 3 ) <NEWLINE> p . append ( 2 * p [ i ] + 1 ) <NEWLINE> <DEDENT> def f ( n , x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return int ( n <= 0 ) <NEWLINE> <DEDENT> elif 1 < x <= a [ n - 1 ] + 1 : <NEWLINE> <INDENT> return f ( n - 1 , x - 1 ) <NEWLINE> <DEDENT> elif x == 2 + a [ n - 1 ] : <NEWLINE> <INDENT> return 1 + p [ n - 1 ] <NEWLINE> <DEDENT> elif 2 + a [ n - 1 ] < x <= 2 + 2 * a [ n - 1 ] : <NEWLINE> <INDENT> return p [ n - 1 ] + 1 + f ( n - 1 , x - 2 - a [ n - 1 ] ) <NEWLINE> <DEDENT> elif x == 2 * a [ n - 1 ] + 3 : <NEWLINE> <INDENT> return 2 * p [ n - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( f ( n , x ) ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dir = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> ta , tb = map ( int , input ( ) . split ( ) ) <NEWLINE> dir [ ta ] . append ( tb ) <NEWLINE> dir [ tb ] . append ( ta ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> flag = [ False ] * ( n + 1 ) <NEWLINE> flag [ 1 ] = True <NEWLINE> que = deque ( [ 1 ] ) <NEWLINE> while que : <NEWLINE> <COMMENT> <NL> <INDENT> now = que . popleft ( ) <NEWLINE> for to in dir [ now ] : <NEWLINE> <INDENT> if flag [ to ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> que . append ( to ) <NEWLINE> flag [ to ] = True <NEWLINE> ans [ to ] = now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from collections import deque <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> cut = [ ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> cut . append ( K * A [ k ] // S ) <NEWLINE> <NL> <DEDENT> length = [ ] <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> length . append ( [ A [ k ] / ( cut [ k ] + 1 ) , k ] ) <NEWLINE> <NL> <DEDENT> length . sort ( key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> def nibun_insert ( lis , item ) : <NEWLINE> <INDENT> end = len ( lis ) <NEWLINE> start = 0 <NEWLINE> now = ( end + start ) // 2 <NEWLINE> while end > start + 1 : <NEWLINE> <INDENT> if lis [ now ] [ 0 ] > item [ 0 ] : <NEWLINE> <INDENT> start = 0 + now <NEWLINE> now = ( now + end ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end = 0 + now <NEWLINE> now = ( now + start ) // 2 <NEWLINE> <DEDENT> <DEDENT> return deque ( lis [ : now + 1 ] + [ item ] + lis [ now + 1 : ] ) <NEWLINE> <NL> <NL> <DEDENT> C = sum ( cut ) <NEWLINE> res = min ( K - C , N ) <NEWLINE> length = length [ : res + 1 ] <NEWLINE> length = deque ( length ) <NEWLINE> for k in range ( res ) : <NEWLINE> <INDENT> a = length . popleft ( ) <NEWLINE> cut [ a [ 1 ] ] += 1 <NEWLINE> a [ 0 ] = a [ 0 ] * cut [ a [ 1 ] ] / ( cut [ a [ 1 ] ] + 1 ) <NEWLINE> if a [ 0 ] <= length [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> length . append ( a ) <NEWLINE> <DEDENT> elif a [ 0 ] >= length [ 0 ] [ 0 ] : <NEWLINE> <INDENT> length . appendleft ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> length = nibun_insert ( list ( length ) , list ( a ) ) <NEWLINE> <DEDENT> length . pop ( ) <NEWLINE> <NL> <DEDENT> print ( math . ceil ( length . popleft ( ) [ 0 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = li [ 0 ] <NEWLINE> for i , l in enumerate ( li ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans *= l <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for X in range ( K + 1 ) : <NEWLINE> <INDENT> for Y in range ( K + 1 ) : <NEWLINE> <INDENT> Z = S - X - Y <NEWLINE> if 0 <= Z <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> def getH ( x , cx , y , cy , h ) : <NEWLINE> <INDENT> return h + abs ( x - cx ) + abs ( y - cy ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> conditions = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if h > 0 : <NEWLINE> <INDENT> conditions . append ( [ x , y , h ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> num_cnd = len ( conditions ) <NEWLINE> if num_cnd == 1 : <NEWLINE> <INDENT> print ( conditions [ 0 ] [ 0 ] , conditions [ 0 ] [ 1 ] , conditions [ 0 ] [ 2 ] ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> h = 0 <NEWLINE> for i , cnd in enumerate ( conditions ) : <NEWLINE> <INDENT> h_tmp = getH ( cnd [ 0 ] , cx , cnd [ 1 ] , cy , cnd [ 2 ] ) <NEWLINE> if h_tmp >= 1 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> h = h_tmp <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> elif h == h_tmp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == num_cnd : <NEWLINE> <INDENT> print ( cx , cy , h ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) . rstrip ( ) ) <NEWLINE> s = readline ( ) . rstrip ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> x = str ( i ) . zfill ( 3 ) <NEWLINE> a = s [ : - 1 ] . find ( x [ 0 ] ) <NEWLINE> if a != - 1 : <NEWLINE> <INDENT> b = s [ a + 1 : - 1 ] . find ( x [ 1 ] ) <NEWLINE> if b != - 1 : <NEWLINE> <INDENT> c = s [ a + b + 2 : ] . find ( x [ 2 ] ) <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> GOAL = [ i for i in range ( 1 , 16 ) ] + [ 0 ] <NEWLINE> MAX_DEPTH = 45 <COMMENT> <NEWLINE> count = 0 <NEWLINE> <NL> <COMMENT> <NL> adjacent = ( <NEWLINE> <INDENT> ( 1 , 4 ) , <COMMENT> <NEWLINE> ( 0 , 2 , 5 ) , <COMMENT> <NEWLINE> ( 1 , 6 , 3 ) , <COMMENT> <NEWLINE> ( 2 , 7 ) , <COMMENT> <NEWLINE> ( 0 , 5 , 8 ) , <COMMENT> <NEWLINE> ( 1 , 4 , 6 , 9 ) , <COMMENT> <NEWLINE> ( 2 , 5 , 7 , 10 ) , <COMMENT> <NEWLINE> ( 3 , 6 , 11 ) , <COMMENT> <NEWLINE> ( 4 , 9 , 12 ) , <COMMENT> <NEWLINE> ( 5 , 8 , 10 , 13 ) , <COMMENT> <NEWLINE> ( 6 , 9 , 11 , 14 ) , <COMMENT> <NEWLINE> ( 7 , 10 , 15 ) , <COMMENT> <NEWLINE> ( 8 , 13 ) , <COMMENT> <NEWLINE> ( 9 , 12 , 14 ) , <COMMENT> <NEWLINE> ( 10 , 13 , 15 ) , <COMMENT> <NEWLINE> ( 11 , 14 ) <COMMENT> <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <COMMENT> <NL> distance = ( <NEWLINE> <INDENT> ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) , <NEWLINE> ( 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 , 3 , 4 , 5 , 6 ) , <NEWLINE> ( 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 , 4 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 , 5 , 4 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 , 6 , 5 , 4 , 3 ) , <NEWLINE> ( 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 2 , 3 , 4 , 5 ) , <NEWLINE> ( 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 , 3 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 4 , 3 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 , 5 , 4 , 3 , 2 ) , <NEWLINE> ( 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) , <NEWLINE> ( 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 2 , 4 , 3 , 2 , 1 , 3 , 2 , 1 , 0 , 4 , 3 , 2 , 1 ) , <NEWLINE> ( 3 , 4 , 5 , 6 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 ) , <NEWLINE> ( 4 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 , 1 , 0 , 1 , 2 ) , <NEWLINE> ( 5 , 4 , 3 , 4 , 4 , 3 , 2 , 3 , 3 , 2 , 1 , 2 , 2 , 1 , 0 , 1 ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <NL> def manhattan_distance ( board ) : <NEWLINE> <INDENT> return sum ( distance [ bi ] [ i ] for i , bi in enumerate ( board ) ) <NEWLINE> <NL> <NL> <DEDENT> def answer_is_odd ( board ) : <NEWLINE> <INDENT> return sum ( divmod ( board . index ( 0 ) , 4 ) ) % 2 <NEWLINE> <NL> <NL> <DEDENT> def search ( board ) : <NEWLINE> <INDENT> lower = manhattan_distance ( board ) <NEWLINE> start_depth = lower <NEWLINE> if ( lower % 2 ) ^ answer_is_odd ( board ) : <NEWLINE> <INDENT> start_depth += 1 <NEWLINE> <DEDENT> for limit in range ( start_depth , MAX_DEPTH + 1 , 2 ) : <NEWLINE> <INDENT> id_lower_search ( board , limit , 0 , board . index ( 0 ) , None , lower ) <NEWLINE> if count > 0 : <NEWLINE> <INDENT> return limit <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def nxt_board ( board , space , prev ) : <NEWLINE> <INDENT> for nxt in adjacent [ space ] : <NEWLINE> <INDENT> if nxt == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = board [ : ] <NEWLINE> b [ space ] , b [ nxt ] = b [ nxt ] , 0 <NEWLINE> yield b , nxt <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def id_lower_search ( board , limit , move , space , prev , lower ) : <NEWLINE> <INDENT> if move == limit : <NEWLINE> <INDENT> if board == GOAL : <NEWLINE> <INDENT> global count <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for b , nxt in nxt_board ( board , space , prev ) : <NEWLINE> <INDENT> p = board [ nxt ] <NEWLINE> new_lower = lower - distance [ p ] [ nxt ] + distance [ p ] [ space ] <NEWLINE> if new_lower + move <= limit : <NEWLINE> <INDENT> id_lower_search ( b , limit , move + 1 , nxt , space , new_lower ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> start = ( map ( int , readline ( ) . split ( ) ) for _ in range ( 4 ) ) <NEWLINE> start = [ y for x in start for y in x ] <NEWLINE> print ( search ( start ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> NIL = - 1 <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = NIL <NEWLINE> self . left = NIL <NEWLINE> self . right = NIL <NEWLINE> <NL> <DEDENT> <DEDENT> class Tree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = NIL <NEWLINE> <NL> <DEDENT> def insert ( self , z ) : <NEWLINE> <INDENT> y = NIL <NEWLINE> x = self . root <NEWLINE> <NL> while x != NIL : <NEWLINE> <INDENT> y = x <NEWLINE> <NL> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <DEDENT> <DEDENT> z . parent = y <NEWLINE> <NL> if y == NIL : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , value , node ) : <NEWLINE> <INDENT> if node == NIL : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif node . key == value : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif value < node . key : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( value , node = node . left ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( value , node = node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( self , value , node ) : <NEWLINE> <INDENT> if node == NIL : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif value < node . key : <NEWLINE> <INDENT> self . delete ( value , node . left ) <NEWLINE> <DEDENT> elif value > node . key : <NEWLINE> <INDENT> self . delete ( value , node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check = ( node . left != NIL ) + ( node . right != NIL ) <NEWLINE> <NL> if check == 0 : <NEWLINE> <INDENT> if node . parent . left != NIL and node . parent . left . key == value : <NEWLINE> <INDENT> node . parent . left = NIL <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . parent . right = NIL <NEWLINE> <NL> <DEDENT> <DEDENT> elif check == 1 : <NEWLINE> <INDENT> if node . left != NIL : <NEWLINE> <INDENT> child = node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> child = node . right <NEWLINE> <NL> <DEDENT> if node . parent . left != NIL and node . parent . left . key == value : <NEWLINE> <INDENT> node . parent . left = child <NEWLINE> child . parent = node . parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . parent . right = child <NEWLINE> child . parent = node . parent <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> jisetu = node . right <NEWLINE> <NL> while jisetu . left != NIL : <NEWLINE> <INDENT> jisetu = jisetu . left <NEWLINE> <NL> <DEDENT> node . key = jisetu . key <NEWLINE> self . delete ( jisetu . key , jisetu ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def inorder_walk ( self , node ) : <NEWLINE> <INDENT> if node == NIL : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> if node . left != NIL : <NEWLINE> <INDENT> self . inorder_walk ( node = node . left ) <NEWLINE> <NL> <DEDENT> print ( <STRING> + str ( node . key ) , end = <STRING> ) <NEWLINE> <NL> if node . right != NIL : <NEWLINE> <INDENT> self . inorder_walk ( node = node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder_walk ( self , node ) : <NEWLINE> <INDENT> if node == NIL : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> print ( <STRING> + str ( node . key ) , end = <STRING> ) <NEWLINE> <NL> if node . left != NIL : <NEWLINE> <INDENT> self . preorder_walk ( node = node . left ) <NEWLINE> <NL> <DEDENT> if node . right != NIL : <NEWLINE> <INDENT> self . preorder_walk ( node = node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> self . inorder_walk ( self . root ) <NEWLINE> print ( ) <NEWLINE> self . preorder_walk ( self . root ) <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> T = Tree ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) . split ( ) <NEWLINE> <NL> if len ( line ) == 1 : <NEWLINE> <INDENT> T . show ( ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( line [ 1 ] ) <NEWLINE> T . insert ( Node ( key ) ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( line [ 1 ] ) <NEWLINE> print ( <STRING> if T . find ( key , T . root ) else <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = int ( line [ 1 ] ) <NEWLINE> T . delete ( key , T . root ) <NEWLINE> <DEDENT> <DEDENT>
g = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] <NEWLINE> <NL> tmp = input ( ) . split ( <STRING> ) <NEWLINE> print ( <STRING> ) if g [ int ( tmp [ 0 ] ) - 1 ] == g [ int ( tmp [ 1 ] ) - 1 ] else print ( <STRING> ) <NEWLINE>
a , b , c , d = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> % ( ( ( c - a ) ** 2 + ( b - d ) ** 2 ) ** .5 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> dp = [ 0 ] * ( 10 ** 7 ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ arr [ i ] ] == 0 : <NEWLINE> <INDENT> for j in range ( 1 , ( 10 ** 6 + 10 ) // arr [ i ] + 1 ) : <NEWLINE> <INDENT> dp [ arr [ i ] * j ] += 1 <NEWLINE> <DEDENT> if i < n - 1 : <NEWLINE> <INDENT> if arr [ i ] == arr [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pre = <STRING> <NEWLINE> post = <STRING> <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l = input ( ) . strip ( ) . split ( ) <NEWLINE> pre += l [ 0 ] <NEWLINE> post += l [ 1 ] <NEWLINE> <DEDENT> m = int ( input ( ) ) <NEWLINE> data = <STRING> <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> data += input ( ) . strip ( ) <NEWLINE> <DEDENT> print ( data . translate ( str . maketrans ( pre , post ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> d = { } <NEWLINE> for av in a : <NEWLINE> <INDENT> if av not in d : <NEWLINE> <INDENT> d [ av ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ av ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a [ 0 ] != 0 or d [ 0 ] != 1 or len ( set ( d . keys ( ) ) ) != a [ - 1 ] + 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> MOD = 998244353 <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , a [ - 1 ] + 1 ) : <NEWLINE> <INDENT> ans *= pow ( d [ i - 1 ] , d [ i ] , MOD ) <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x ) == abs ( y ) : <NEWLINE> <INDENT> print ( 0 if x == y else 1 ) <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> print ( min ( y - x , abs ( y + x ) + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( y + x ) , abs ( y - x ) ) + 1 if x * y <= 0 else min ( abs ( y + x ) , abs ( y - x ) ) + 2 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( <STRING> ) ) ) <NEWLINE> roop = [ 0 ] <NEWLINE> flg = [ 0 for i in range ( N ) ] <NEWLINE> flg [ 0 ] = 1 <NEWLINE> n = A [ 0 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if flg [ n ] == 0 : <NEWLINE> <INDENT> roop . append ( n ) <NEWLINE> flg [ n ] = i <NEWLINE> n = A [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if K < len ( roop ) : <NEWLINE> <INDENT> print ( roop [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= flg [ n ] - 1 <NEWLINE> K %= ( end - flg [ n ] ) <NEWLINE> roop = roop [ flg [ n ] - 1 : end ] <NEWLINE> print ( roop [ K ] + 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . defaultdict ( int ) <NEWLINE> for val in arr : <COMMENT> <NEWLINE> <INDENT> cnt [ val ] += 1 <NEWLINE> <DEDENT> sums = sum ( arr ) <COMMENT> <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ( c - b ) * ( cnt [ b ] ) <COMMENT> <NEWLINE> sums += diff <NEWLINE> print ( sums ) <NEWLINE> cnt [ c ] += cnt [ b ] <COMMENT> <NEWLINE> cnt [ b ] = 0 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> p = [ ] <NEWLINE> m = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> p . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . append ( a ) <NEWLINE> <DEDENT> <DEDENT> p . sort ( reverse = True ) <NEWLINE> m . sort ( reverse = False ) <NEWLINE> ans = 1 <NEWLINE> if sum ( np . sign ( A ) ) == - N and K % 2 == 1 : <NEWLINE> <INDENT> A = sorted ( A , reverse = True ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * A [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> if N == K : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * A [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> m_pair = [ ] <NEWLINE> p_pair = [ ] <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> ans *= p . pop ( 0 ) % mod <NEWLINE> <DEDENT> for i in range ( 0 , len ( m ) , 2 ) : <NEWLINE> <INDENT> if i + 1 < len ( m ) : <NEWLINE> <INDENT> m_pair . append ( m [ i ] * m [ i + 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( p ) , 2 ) : <NEWLINE> <INDENT> if i + 1 < len ( p ) : <NEWLINE> <INDENT> p_pair . append ( p [ i ] * p [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_pair . append ( p [ i ] ) <NEWLINE> <DEDENT> <DEDENT> pairs = m_pair [ : ] <NEWLINE> pairs . extend ( p_pair ) <NEWLINE> pairs . sort ( reverse = True ) <NEWLINE> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans = ( ans * pairs [ i ] ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> res = 0 <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> k = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t [ n - i ] = ( t [ n - i + 1 ] + int ( s [ n - i ] ) * k ) % 2019 <NEWLINE> k *= 10 <NEWLINE> k = k % 2019 <NEWLINE> <DEDENT> d = Counter ( t ) <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> if i < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> res += i * ( i - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( res ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif a [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = Counter ( A ) <NEWLINE> ans = sum ( A ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x = B [ b ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> continue <NEWLINE> <DEDENT> if c in B : <NEWLINE> <INDENT> B [ c ] += x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ c ] = x <NEWLINE> <DEDENT> B . pop ( b ) <NEWLINE> ans = ans + ( c - b ) * x <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> X , K , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> right = X % D <NEWLINE> left = right - D <NEWLINE> if X in [ left , right ] : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X == left : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( left ) ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT> if X > right : <NEWLINE> <INDENT> to_right = ( X - right ) // D <NEWLINE> if to_right >= K : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if ( K - to_right ) % 2 == 0 : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( left ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> to_left = ( left - X ) // D <NEWLINE> if to_left >= K : <NEWLINE> <INDENT> print ( abs ( X + K * D ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if ( K - to_left ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( left ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
print ( input ( ) . swapcase ( ) ) <NEWLINE>
from math import gcd <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( tmp , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> mod = 998244353 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lr . append ( ( l , r ) ) <NEWLINE> <DEDENT> ans = [ 1 ] <NEWLINE> acc_ans = [ 1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> wa = 0 <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> if i - r > 0 : <NEWLINE> <INDENT> wa += - acc_ans [ i - r - 1 ] + acc_ans [ i - l ] <NEWLINE> <DEDENT> elif i - l >= 0 : <NEWLINE> <INDENT> wa += acc_ans [ i - l ] <NEWLINE> <DEDENT> <DEDENT> wa %= mod <NEWLINE> ans . append ( wa ) <NEWLINE> acc_ans . append ( wa + acc_ans [ - 1 ] ) <NEWLINE> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def isPossible ( X ) : <NEWLINE> <INDENT> global N , K , A <NEWLINE> <NL> cuts = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cuts += math . ceil ( A [ i ] / X ) - 1 <NEWLINE> <NL> <DEDENT> return cuts <= K <NEWLINE> <NL> <DEDENT> minVal = 0 <NEWLINE> maxVal = max ( A ) <NEWLINE> <NL> while math . ceil ( minVal ) != math . ceil ( maxVal ) : <NEWLINE> <INDENT> if isPossible ( ( maxVal + minVal ) / 2 ) : <NEWLINE> <INDENT> maxVal = ( maxVal + minVal ) / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minVal = ( maxVal + minVal ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( math . ceil ( maxVal ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> <NL> total = A [ 0 ] <NEWLINE> limit = 10 ** 18 <NEWLINE> <NL> for a in A [ 1 : ] : <NEWLINE> <INDENT> total *= a <NEWLINE> if total > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> <NL> N = I ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> y = N // i <NEWLINE> sum = y * ( y + 1 ) * i / 2 <NEWLINE> ans += sum <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> def seachPrimeNum ( N ) : <NEWLINE> <INDENT> max = int ( np . sqrt ( N ) ) <NEWLINE> seachList = [ i for i in range ( 2 , N + 1 ) ] <NEWLINE> primeNum = [ ] <NEWLINE> while seachList [ 0 ] <= max : <NEWLINE> <INDENT> primeNum . append ( seachList [ 0 ] ) <NEWLINE> tmp = seachList [ 0 ] <NEWLINE> seachList = [ i for i in seachList if i % tmp != 0 ] <NEWLINE> <DEDENT> primeNum . extend ( seachList ) <NEWLINE> return primeNum <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def divisor_count ( n ) : <NEWLINE> <INDENT> divisors = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors += 1 <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a + b >= 10 ** 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> NEXT = 2 <NEWLINE> DATA = 1 <NEWLINE> PREV = 0 <NEWLINE> from collections import deque <NEWLINE> def dll_processor ( operations ) : <NEWLINE> <NL> <INDENT> front = None <NEWLINE> end = None <NEWLINE> dll = deque ( [ ] ) <NEWLINE> for o in operations : <NEWLINE> <INDENT> if o [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . appendleft ( o [ 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif o [ 0 ] == <STRING> : <NEWLINE> <INDENT> if o [ 1 ] in dll : <NEWLINE> <INDENT> dll . remove ( o [ 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> elif o [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif o [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> return dll <NEWLINE> <NL> <DEDENT> def get_list ( front ) : <NEWLINE> <INDENT> if not front : <NEWLINE> <INDENT> return [ ] <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> target = front <NEWLINE> while True : <NEWLINE> <INDENT> l . append ( target [ DATA ] ) <NEWLINE> if not target [ NEXT ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> target = target [ NEXT ] <NEWLINE> <DEDENT> return l <NEWLINE> <NL> <DEDENT> def insert ( front , end , target ) : <NEWLINE> <INDENT> node = [ None , target , None ] <NEWLINE> if front : <NEWLINE> <INDENT> front [ PREV ] = node <NEWLINE> node [ NEXT ] = front <NEWLINE> return node , end <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node , node <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( front , end , target ) : <NEWLINE> <NL> <INDENT> delete_node = front <NEWLINE> while not delete_node [ DATA ] == target : <NEWLINE> <INDENT> delete_node = delete_node [ NEXT ] <NEWLINE> if delete_node == None : <NEWLINE> <INDENT> return front , end <NEWLINE> <NL> <DEDENT> <DEDENT> if delete_node [ PREV ] == None : <NEWLINE> <INDENT> delete_node [ NEXT ] [ PREV ] = None <NEWLINE> return delete_node [ NEXT ] , end <NEWLINE> <DEDENT> elif delete_node [ NEXT ] == None : <NEWLINE> <INDENT> delete_node [ PREV ] [ NEXT ] = None <NEWLINE> return front , delete_node [ PREV ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> delete_node [ NEXT ] [ PREV ] = delete_node [ PREV ] <NEWLINE> delete_node [ PREV ] [ NEXT ] = delete_node [ NEXT ] <NEWLINE> return front , end <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_last ( front , end ) : <NEWLINE> <NL> <INDENT> if not end [ PREV ] : <NEWLINE> <INDENT> return None , None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end [ PREV ] [ NEXT ] = None <NEWLINE> return front , end [ PREV ] <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_first ( front , end ) : <NEWLINE> <NL> <INDENT> if not front [ NEXT ] : <NEWLINE> <INDENT> return None , None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> front [ NEXT ] [ PREV ] = None <NEWLINE> return front [ NEXT ] , end <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n_list = int ( input ( ) ) <NEWLINE> target_list = [ input ( ) . split ( ) for i in range ( n_list ) ] <NEWLINE> print ( * dll_processor ( target_list ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> import numpy as np <NEWLINE> from numba import njit , i8 , b1 <NEWLINE> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> sh , sw = map ( int , input ( ) . split ( ) ) <NEWLINE> gh , gw = map ( int , input ( ) . split ( ) ) <NEWLINE> s = np . array ( [ list ( input ( ) ) for _ in range ( h ) ] ) == <STRING> <NEWLINE> <NL> @ njit ( i8 ( i8 , i8 , i8 , i8 , i8 , i8 , b1 [ : , : ] ) ) <NEWLINE> def solve ( h , w , sh , sw , gh , gw , s ) : <NEWLINE> <NL> <INDENT> sh -= 1 ; sw -= 1 ; gh -= 1 ; gw -= 1 ; <NEWLINE> <NL> INF = 10 ** 7 <NEWLINE> dist = [ [ INF ] * w for _ in range ( h ) ] <NEWLINE> dist [ sh ] [ sw ] = 0 <NEWLINE> q = [ ( 0 , sh , sw ) ] <NEWLINE> while q : <NEWLINE> <NL> <INDENT> d , vsh , vsw = heapq . heappop ( q ) <NEWLINE> <NL> for dh in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for dw in range ( - 2 , 3 ) : <NEWLINE> <INDENT> newh = vsh + dh <NEWLINE> neww = vsw + dw <NEWLINE> if newh < 0 or h <= newh or neww < 0 or w <= neww : continue <NEWLINE> if dh == 0 and dw == 0 : continue <NEWLINE> if s [ newh ] [ neww ] : continue <NEWLINE> <NL> <NL> if abs ( dh ) + abs ( dw ) == 1 : <NEWLINE> <INDENT> if dist [ newh ] [ neww ] > d : <NEWLINE> <INDENT> dist [ newh ] [ neww ] = d <NEWLINE> if newh == gh and neww == gw : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> heapq . heappush ( q , ( d , newh , neww ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dist [ newh ] [ neww ] > d + 1 : <NEWLINE> <INDENT> dist [ newh ] [ neww ] = d + 1 <NEWLINE> heapq . heappush ( q , ( d + 1 , newh , neww ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if dist [ gh ] [ gw ] == INF : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : return dist [ gh ] [ gw ] <NEWLINE> <NL> <DEDENT> print ( solve ( h , w , sh , sw , gh , gw , s ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> <NL> rl = sys . stdin . readline <NEWLINE> <NL> n = int ( rl ( ) ) <NEWLINE> a = list ( map ( int , rl ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
MAX_NUM = 10 ** 18 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_set = set ( A ) <NEWLINE> log_sum = 0 <NEWLINE> if ( 0 in A_set ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> A_log = [ 0 ] * N <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> log_sum += math . log10 ( A [ i ] ) <NEWLINE> if ( log_sum > 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ( ans > MAX_NUM ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> rr , gg = [ ] , [ ] <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rr . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> gg . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> bb = len ( s ) - len ( rr ) - len ( gg ) <NEWLINE> ans = len ( rr ) * len ( gg ) * bb <NEWLINE> for i in range ( 0 , len ( rr ) ) : <NEWLINE> <INDENT> for j in range ( 0 , len ( gg ) ) : <NEWLINE> <INDENT> che = 0 <NEWLINE> a = rr [ i ] + gg [ j ] <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> if s [ a // 2 ] == <STRING> : <NEWLINE> <INDENT> che += - 1 <NEWLINE> <DEDENT> <DEDENT> b = min ( rr [ i ] , gg [ j ] ) - abs ( rr [ i ] - gg [ j ] ) <NEWLINE> if b >= 0 : <NEWLINE> <INDENT> if s [ b ] == <STRING> : <NEWLINE> <INDENT> che += - 1 <NEWLINE> <DEDENT> <DEDENT> c = a - b <NEWLINE> if c < n : <NEWLINE> <INDENT> if s [ c ] == <STRING> : <NEWLINE> <INDENT> che += - 1 <NEWLINE> <DEDENT> <DEDENT> ans += che <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = N // 2 <NEWLINE> R = sorted ( L ) <NEWLINE> for i in L : <NEWLINE> <INDENT> if i > R [ n - 1 ] : <NEWLINE> <INDENT> print ( R [ n - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R [ n ] ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for a in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for b in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_sum_list = [ A_list [ N - 1 ] ] <NEWLINE> ans = A_list [ N - 1 ] * A_list [ N - 2 ] <NEWLINE> sum_temp_old = A_list [ N - 1 ] <NEWLINE> <NL> for i in range ( N - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> sum_temp = sum_temp_old + A_list [ i - 1 ] <NEWLINE> sum_temp_old = sum_temp <NEWLINE> ans += ( sum_temp * A_list [ i - 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> l1 = [ ] <NEWLINE> for ea in a : <NEWLINE> <INDENT> l1 . append ( cnt - ea ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> l1c = Counter ( l1 ) <NEWLINE> r = 0 <NEWLINE> for i2 in range ( n ) : <NEWLINE> <INDENT> r += l1c [ i2 + a [ i2 ] ] <NEWLINE> <DEDENT> print ( int ( r ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dicplus = { } <NEWLINE> dicmins = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = i + a [ i ] <NEWLINE> c = i - a [ i ] <NEWLINE> if b not in dicplus : <NEWLINE> <INDENT> dicplus [ b ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dicplus [ b ] += 1 <NEWLINE> <DEDENT> if c not in dicmins : <NEWLINE> <INDENT> dicmins [ c ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dicmins [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in dicplus : <NEWLINE> <INDENT> if i in dicmins : <NEWLINE> <INDENT> ans += dicplus [ i ] * dicmins [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import defaultdict <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> counter = defaultdict ( int ) <NEWLINE> mod = 2019 <NEWLINE> counter [ 0 ] += 1 <NEWLINE> num = 0 <NEWLINE> d = 1 <NEWLINE> for c in S [ : : - 1 ] : <NEWLINE> <INDENT> num += int ( c ) * d <NEWLINE> num %= mod <NEWLINE> counter [ num ] += 1 <NEWLINE> d *= 10 <NEWLINE> d %= mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for v in counter . values ( ) : <NEWLINE> <INDENT> ans += ( v * ( v - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( b - a + 1 ) <= 2 * k : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> cou = 1 <NEWLINE> frt = <STRING> <NEWLINE> bck = <STRING> <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> t = list ( input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> cou *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( t [ 1 ] == <STRING> and cou == 1 ) or ( t [ 1 ] == <STRING> and cou == - 1 ) : <NEWLINE> <INDENT> frt = t [ 2 ] + frt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bck = bck + t [ 2 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> s = frt + s + bck <NEWLINE> <COMMENT> <NL> if cou == 1 : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( s [ : : - 1 ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> lim = 10 ** 18 <NEWLINE> if A [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ( ans > lim ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * 1000001 <NEWLINE> result = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> result += i <NEWLINE> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> n = cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> result += ( c - b ) * n <NEWLINE> print ( result ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> x = input ( ) . split ( ) <NEWLINE> m = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> ii = int ( i ) <NEWLINE> if m < ii : <NEWLINE> <INDENT> m = ii <NEWLINE> <DEDENT> elif m > ii : <NEWLINE> <INDENT> cnt += m - ii <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def check_num ( n ) : <NEWLINE> <INDENT> if n % 3 == 0 or n % 10 == 3 or str ( n ) . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( n ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> check_num ( i ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = sum ( sorted ( p ) [ : K ] ) <NEWLINE> print ( ans ) <NEWLINE>
aN = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mN = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def memorize ( f ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> def helper ( * args ) : <NEWLINE> <INDENT> if args not in cache : <NEWLINE> <INDENT> cache [ args ] = f ( * args ) <NEWLINE> <DEDENT> return cache [ args ] <NEWLINE> <DEDENT> return helper <NEWLINE> <NL> <DEDENT> @ memorize <NEWLINE> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= aN : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> print ( <STRING> if solve ( 0 , m ) else <STRING> ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> B = list ( accumulate ( A ) ) <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( B [ - 1 ] - B [ i ] ) % MOD <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> result = <STRING> <NEWLINE> for x in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if x % 3 == 0 or <STRING> in str ( x ) : <NEWLINE> <INDENT> result += ( <STRING> + str ( x ) ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> g = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> total = r * g * b <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
lst = list ( input ( ) ) <NEWLINE> total = sum ( [ int ( i ) for i in lst ] ) <NEWLINE> if total % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> B = [ 0 ] <NEWLINE> a = len ( A ) <NEWLINE> sa = sorted ( A ) <NEWLINE> su = 0 <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> B . append ( B [ i ] + sa [ i ] ) <NEWLINE> <NL> <DEDENT> for j in range ( a ) : <NEWLINE> <INDENT> su += sa [ j ] * B [ j ] <NEWLINE> <NL> <DEDENT> print ( su % p ) <NEWLINE>
while True : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> if N == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> q1 , b , c1 , c2 , q2 = [ int ( i ) for i in N . split ( ) ] <NEWLINE> <NL> if c1 <= c2 : <NEWLINE> <INDENT> x = min ( q2 , b // c1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = min ( ( b - c2 * q1 ) // ( c1 - c2 ) , q2 , b // c1 ) <NEWLINE> <DEDENT> y = ( b - c1 * x ) // c2 <NEWLINE> <NL> if x <= 0 or x + y < q1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 for i in range ( n ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> l [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * l , sep = <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> m = 0 <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> m = i + 1 <NEWLINE> ans = s [ i ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k < m : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a2 = int ( a ) <NEWLINE> b2 = 100 * int ( b [ 0 : 1 ] ) + 10 * int ( b [ 2 : 3 ] ) + int ( b [ 3 : 4 ] ) <NEWLINE> if a2 == 0 or b2 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = str ( a2 * b2 ) <NEWLINE> l = len ( tmp ) <NEWLINE> if l <= 2 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( tmp [ 0 : l - 2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def hitoketame3 ( num ) : <NEWLINE> <INDENT> if num % 10 == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> if hitoketame3 ( x ) == True : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> while x != 0 : <NEWLINE> <INDENT> x = x // 10 <NEWLINE> if hitoketame3 ( x ) == True : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from bisect import bisect_left <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = sorted ( P ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = [ ] <NEWLINE> <NL> <DEDENT> flag = False <NEWLINE> ans = [ ] <NEWLINE> if x not in P or n == 0 : <NEWLINE> <INDENT> ans . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = bisect_left ( P , x ) <NEWLINE> for i in range ( 1 , 110 ) : <NEWLINE> <INDENT> for_num = P [ idx ] + i <NEWLINE> bac_num = P [ idx ] - i <NEWLINE> if for_num not in P : <NEWLINE> <INDENT> ans . append ( for_num ) <NEWLINE> flag = True <NEWLINE> <DEDENT> if bac_num not in P : <NEWLINE> <INDENT> ans . append ( bac_num ) <NEWLINE> flag = True <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE>
<COMMENT> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x % y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> d = gcd ( y , r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = y <NEWLINE> <NL> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if x < y : <NEWLINE> <INDENT> buff = x <NEWLINE> x = y <NEWLINE> y = buff <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> d = gcd ( x , y ) <NEWLINE> <NL> print ( d ) <NEWLINE>
from collections import deque <NEWLINE> N , K = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> route = [ 0 ] + list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> dis = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> checked = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> queue = deque ( [ 1 ] ) <NEWLINE> hop_count = 0 <NEWLINE> offset = 0 <NEWLINE> <NL> ans = 1 <NEWLINE> while queue : <NEWLINE> <INDENT> i = queue . popleft ( ) <NEWLINE> <NL> if hop_count == K : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> A_i = route [ i ] <NEWLINE> <NL> if checked [ A_i ] == 1 : <NEWLINE> <INDENT> roop_node_count = abs ( hop_count + 1 - dis [ A_i ] ) <NEWLINE> offset = ( K - hop_count ) % roop_node_count <NEWLINE> <NL> for _ in range ( offset ) : <NEWLINE> <INDENT> i = route [ i ] <NEWLINE> <DEDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> queue . append ( A_i ) <NEWLINE> hop_count += 1 <NEWLINE> dis [ A_i ] = dis [ i ] + 1 <NEWLINE> checked [ i ] = 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> ans = { 1 : 1 , 2 : 9 , 3 : 30 , 4 : 76 , 5 : 141 , 6 : 267 , 7 : 400 , 8 : 624 , 9 : 885 , 10 : 1249 , 11 : 1590 , 12 : 2208 , 13 : 2689 , 14 : 3411 , 15 : 4248 , 16 : 5248 , 17 : 6081 , 18 : 7485 , 19 : 8530 , 20 : 10248 , 21 : 11889 , 22 : 13687 , 23 : 15228 , 24 : 17988 , 25 : 20053 , 26 : 22569 , 27 : 25242 , 28 : 28588 , 29 : 31053 , 30 : 35463 , 31 : 38284 , 32 : 42540 , 33 : 46581 , 34 : 50893 , 35 : 55362 , 36 : 61824 , 37 : 65857 , 38 : 71247 , 39 : 76884 , 40 : 84388 , 41 : 89349 , 42 : 97881 , 43 : 103342 , 44 : 111528 , 45 : 120141 , 46 : 128047 , 47 : 134580 , 48 : 146316 , 49 : 154177 , 50 : 164817 , 51 : 174438 , 52 : 185836 , 53 : 194157 , 54 : 207927 , 55 : 218812 , 56 : 233268 , 57 : 245277 , 58 : 257857 , 59 : 268182 , 60 : 288216 , 61 : 299257 , 62 : 313635 , 63 : 330204 , 64 : 347836 , 65 : 362973 , 66 : 383709 , 67 : 397042 , 68 : 416448 , 69 : 434025 , 70 : 456967 , 71 : 471948 , 72 : 499740 , 73 : 515581 , 74 : 536073 , 75 : 559758 , 76 : 583960 , 77 : 604833 , 78 : 633651 , 79 : 652216 , 80 : 683712 , 81 : 709065 , 82 : 734233 , 83 : 754734 , 84 : 793188 , 85 : 818917 , 86 : 846603 , 87 : 874512 , 88 : 909496 , 89 : 933081 , 90 : 977145 , 91 : 1006126 , 92 : 1041504 , 93 : 1073385 , 94 : 1106467 , 95 : 1138536 , 96 : 1187112 , 97 : 1215145 , 98 : 1255101 , 99 : 1295142 , 100 : 1342852 , 101 : 1373253 , 102 : 1422195 , 103 : 1453816 , 104 : 1502376 , 105 : 1553361 , 106 : 1595437 , 107 : 1629570 , 108 : 1691292 , 109 : 1726717 , 110 : 1782111 , 111 : 1827492 , 112 : 1887772 , 113 : 1925853 , 114 : 1986837 , 115 : 2033674 , 116 : 2089776 , 117 : 2145333 , 118 : 2197483 , 119 : 2246640 , 120 : 2332104 , 121 : 2379085 , 122 : 2434833 , 123 : 2490534 , 124 : 2554600 , 125 : 2609625 , 126 : 2693919 , 127 : 2742052 , 128 : 2813988 , 129 : 2875245 , 130 : 2952085 , 131 : 3003306 , 132 : 3096024 , 133 : 3157249 , 134 : 3224511 , 135 : 3306240 , 136 : 3388576 , 137 : 3444609 , 138 : 3533637 , 139 : 3591322 , 140 : 3693924 , 141 : 3767085 , 142 : 3842623 , 143 : 3912324 , 144 : 4027884 , 145 : 4102093 , 146 : 4181949 , 147 : 4270422 , 148 : 4361548 , 149 : 4427853 , 150 : 4548003 , 151 : 4616104 , 152 : 4718640 , 153 : 4812789 , 154 : 4918561 , 155 : 5003286 , 156 : 5131848 , 157 : 5205481 , 158 : 5299011 , 159 : 5392008 , 160 : 5521384 , 161 : 5610705 , 162 : 5739009 , 163 : 5818390 , 164 : 5930196 , 165 : 6052893 , 166 : 6156139 , 167 : 6239472 , 168 : 6402720 , 169 : 6493681 , 170 : 6623853 , 171 : 6741078 , 172 : 6864016 , 173 : 6953457 , 174 : 7094451 , 175 : 7215016 , 176 : 7359936 , 177 : 7475145 , 178 : 7593865 , 179 : 7689630 , 180 : 7886244 , 181 : 7984165 , 182 : 8130747 , 183 : 8253888 , 184 : 8403448 , 185 : 8523897 , 186 : 8684853 , 187 : 8802826 , 188 : 8949612 , 189 : 9105537 , 190 : 9267595 , 191 : 9376656 , 192 : 9574704 , 193 : 9686065 , 194 : 9827097 , 195 : 9997134 , 196 : 10174780 , 197 : 10290813 , 198 : 10493367 , 199 : 10611772 , 200 : 10813692 } <NEWLINE> print ( ans [ k ] ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * size <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> while self . parents [ x ] > 0 : <NEWLINE> <INDENT> x = self . parents [ x ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def union ( self , i , j ) : <NEWLINE> <INDENT> pi , pj = self . find ( i ) , self . find ( j ) <NEWLINE> if pi == pj : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ pi ] < self . parents [ pj ] : <NEWLINE> <INDENT> pi , pj = pj , pi <NEWLINE> i , j = j , i <NEWLINE> <DEDENT> self . parents [ pi ] += self . parents [ pj ] <NEWLINE> self . parents [ pj ] = pi <NEWLINE> self . reconnect ( j , pi ) <NEWLINE> <NL> <DEDENT> def reconnect ( self , i , j ) : <NEWLINE> <INDENT> while self . parents [ i ] > 0 : <NEWLINE> <INDENT> t = self . parents [ i ] <NEWLINE> self . parents [ i ] = j <NEWLINE> i = t <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , * ab , = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n + 1 ) <NEWLINE> <NL> for i , j in zip ( ab [ : : 2 ] , ab [ 1 : : 2 ] ) : <NEWLINE> <INDENT> uf . union ( i , j ) <NEWLINE> <NL> <DEDENT> print ( - min ( uf . parents ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> anss = [ 0 ] * n <NEWLINE> for A in As : <NEWLINE> <INDENT> anss [ A - 1 ] += 1 <NEWLINE> <DEDENT> for ans in anss : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> <NL> for y in range ( a + 1 ) : <NEWLINE> <INDENT> for z in range ( a + 1 ) : <NEWLINE> <INDENT> p = b - y - z <NEWLINE> if 0 <= p and p <= a : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> r = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> max_profit = ( - 1 ) * ( 10 ** 9 ) <NEWLINE> min_value = r [ 0 ] <NEWLINE> for j in range ( 1 , len ( r ) ) : <NEWLINE> <INDENT> max_profit = max ( max_profit , r [ j ] - min_value ) <NEWLINE> min_value = min ( min_value , r [ j ] ) <NEWLINE> <DEDENT> print ( max_profit ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> def bit_add ( arr , n , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> arr [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def bit_sum ( arr , i ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> result += arr [ i ] <NEWLINE> i ^= i & - i <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> n = inp [ 0 ] <NEWLINE> q = inp [ 1 ] <NEWLINE> ccc = inp [ 2 : 2 + n ] <NEWLINE> lll = inp [ 2 + n : : 2 ] - 1 <NEWLINE> rrr = inp [ 3 + n : : 2 ] - 1 <NEWLINE> <NL> just_left = { } <NEWLINE> segments = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = ccc [ i ] <NEWLINE> if c in just_left : <NEWLINE> <INDENT> segments . append ( ( i , 0 , just_left [ c ] , 0 ) ) <NEWLINE> <DEDENT> just_left [ c ] = i <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> segments . append ( ( rrr [ i ] , 1 , lll [ i ] , i ) ) <NEWLINE> <NL> <DEDENT> segments . sort ( ) <NEWLINE> bit = np . zeros ( n + 2 , dtype = np . int64 ) <NEWLINE> ans = np . zeros ( q , dtype = np . int64 ) <NEWLINE> <NL> for r , tp , l , i in segments : <NEWLINE> <INDENT> if tp == 0 : <NEWLINE> <INDENT> bit_add ( bit , n + 2 , l + 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> base = r - l + 1 <NEWLINE> ans [ i ] = base - ( bit_sum ( bit , r + 2 ) - bit_sum ( bit , l + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( b ) <NEWLINE> c = b [ 0 ] <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a - 1 ) : <NEWLINE> <INDENT> c *= b [ i + 1 ] <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if c > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> if a . count ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = ans - cnt <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ [ 0 ] * n ] <NEWLINE> list = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list [ i ] = int ( list [ i ] ) <NEWLINE> <NL> <DEDENT> yen = 1000 <NEWLINE> stock = 0 <NEWLINE> keikou = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if list [ i ] - list [ i - 1 ] <= 0 : <NEWLINE> <INDENT> keikou += 1 <NEWLINE> <DEDENT> <DEDENT> if keikou != n - 1 : <NEWLINE> <INDENT> for t in range ( 1 , n ) : <NEWLINE> <INDENT> if list [ t ] - list [ t - 1 ] >= 0 : <NEWLINE> <INDENT> stock += int ( yen / list [ t - 1 ] ) <NEWLINE> yen -= list [ t - 1 ] * int ( yen / list [ t - 1 ] ) <NEWLINE> yen += list [ t ] * stock <NEWLINE> stock = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( yen ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i + 1 ] != 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if n != 0 and a [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n == 0 and a [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> nleaf = 1 <NEWLINE> ans = 0 <NEWLINE> v = list ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> nleaf -= a [ i ] <NEWLINE> v . append ( nleaf ) <NEWLINE> nleaf *= 2 <NEWLINE> <NL> <DEDENT> if nleaf < a [ n ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> nleaf = a [ n ] <NEWLINE> ans += a [ n ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if v [ i ] * 2 < nleaf : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if v [ i ] > nleaf : <NEWLINE> <INDENT> v [ i ] = nleaf <NEWLINE> <DEDENT> nleaf = v [ i ] + a [ i ] <NEWLINE> ans += nleaf <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def partition ( A , p , r ) : <NEWLINE> <INDENT> x = int ( A [ r - 1 ] [ 1 ] ) <NEWLINE> i = p - 1 <NEWLINE> <NL> for j in range ( p , r - 1 ) : <NEWLINE> <INDENT> if int ( A [ j ] [ 1 ] ) <= x : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r - 1 ] = A [ r - 1 ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def qsort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> qsort ( A , p , q ) <NEWLINE> qsort ( A , q + 1 , r ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def isStable ( a ) : <NEWLINE> <INDENT> length = int ( len ( a ) ) <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> for j in range ( i + 1 , length - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] == a [ j ] [ 1 ] and a [ i ] [ 2 ] > a [ j ] [ 2 ] : <NEWLINE> <INDENT> return False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> cnt = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( cnt ) : <NEWLINE> <INDENT> N = input ( ) . split ( ) <NEWLINE> N . append ( i ) <NEWLINE> A . append ( N ) <NEWLINE> <DEDENT> p = 0 <NEWLINE> r = len ( A ) <NEWLINE> B = qsort ( A , p , r ) <NEWLINE> if isStable ( B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for i in B : <NEWLINE> <INDENT> print ( <STRING> . format ( i [ 0 ] , i [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> bt = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( sum ( [ x * y for ( x , y ) in zip ( A [ i ] , bt ) ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = [ max ( A [ 0 ] , A [ 1 ] ) ] <NEWLINE> <NL> list_sum = A [ : : 2 ] <NEWLINE> for i in range ( 1 , len ( list_sum ) ) : <NEWLINE> <INDENT> list_sum [ i ] += list_sum [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> answer . append ( max ( A [ 0 ] , A [ 1 ] , A [ 2 ] ) ) <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> answer . append ( max ( answer [ - 1 ] , answer [ - 2 ] + A [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer . append ( max ( answer [ - 2 ] + A [ i ] , list_sum [ ( i - 1 ) // 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer [ - 1 ] ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max_value = 0 <NEWLINE> n = min ( N , B - 1 ) <NEWLINE> <NL> max_value = math . floor ( A * n / B ) - A * math . floor ( n / B ) <NEWLINE> <NL> <NL> <NL> print ( max_value ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x_s = input ( ) <NEWLINE> x = int ( x_s , 2 ) <NEWLINE> <NL> pops = bin ( x ) . count ( <STRING> ) <NEWLINE> x_pop_p = x % ( pops + 1 ) <NEWLINE> try : <NEWLINE> <INDENT> x_pop_m = x % ( pops - 1 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> x_pop_m = 0 <NEWLINE> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if x_s [ i ] == <STRING> : <NEWLINE> <INDENT> if pops > 1 : <NEWLINE> <INDENT> tmp = ( x_pop_m - pow ( 2 , n - 1 - i , ( pops - 1 ) ) ) % ( pops - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( x_pop_p + pow ( 2 , n - 1 - i , ( pops + 1 ) ) ) % ( pops + 1 ) <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> while tmp : <NEWLINE> <INDENT> tmp %= bin ( tmp ) . count ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ans = [ 0 for i in range ( 10500 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> sumg = ( i + j ) ** 2 + ( j + k ) ** 2 + ( k + i ) ** 2 <NEWLINE> if sumg < 21000 : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> ans [ int ( sumg / 2 ) ] += 1 <NEWLINE> <DEDENT> elif i != j and j != k and k != i : <NEWLINE> <INDENT> ans [ int ( sumg / 2 ) ] += 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ int ( sumg / 2 ) ] += 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if i == H - 1 and j == W - 1 : <NEWLINE> <INDENT> print ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Hlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Hdict = { i : Hlist [ i ] for i in range ( len ( Hlist ) ) } <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> bad_set = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if Hdict [ line [ 0 ] - 1 ] <= Hdict [ line [ 1 ] - 1 ] : <NEWLINE> <INDENT> bad_set . add ( line [ 0 ] ) <NEWLINE> <DEDENT> if Hdict [ line [ 1 ] - 1 ] <= Hdict [ line [ 0 ] - 1 ] : <NEWLINE> <INDENT> bad_set . add ( line [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( bad_set ) ) <NEWLINE>
<COMMENT> <NL> x , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = x - i <NEWLINE> b = x + i <NEWLINE> if not a in num_list : <NEWLINE> <INDENT> min_num = a <NEWLINE> break <NEWLINE> <DEDENT> elif not b in num_list : <NEWLINE> <INDENT> min_num = b <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> <NL> def gcd_list ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> s = [ i , j , k ] <NEWLINE> if i == j == k : <NEWLINE> <INDENT> total += gcd_list ( * s ) <NEWLINE> <DEDENT> elif i == j and j != k : <NEWLINE> <INDENT> total += gcd_list ( * s ) * 3 <NEWLINE> <DEDENT> elif i != j and j == k : <NEWLINE> <INDENT> total += gcd_list ( * s ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += gcd_list ( * s ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> K = input ( ) <NEWLINE> K = int ( K ) <NEWLINE> S = 0 <NEWLINE> a = 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> if gcd ( a , b ) == 1 : <NEWLINE> <INDENT> S += K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += sum ( [ gcd ( a , b , c ) for c in range ( 1 , K + 1 ) ] ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> b = b + 1 <NEWLINE> <DEDENT> b = 1 <NEWLINE> c = 1 <NEWLINE> a = a + 1 <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , a , b , c = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> cc = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ff = input ( ) . strip ( ) <NEWLINE> cc . append ( ( ff ) ) <NEWLINE> <NL> <DEDENT> chk = True <NEWLINE> ans = [ ] <NEWLINE> for num , q in enumerate ( cc ) : <NEWLINE> <INDENT> if q [ 0 ] == <STRING> and q [ 1 ] == <STRING> : <NEWLINE> <INDENT> m = max ( a , b ) <NEWLINE> if m < 1 : <NEWLINE> <INDENT> chk = False <NEWLINE> break <NEWLINE> <DEDENT> if a == 1 and b == 1 : <NEWLINE> <INDENT> if num == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cc [ num + 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif m == a : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if q [ 0 ] == <STRING> and q [ 1 ] == <STRING> : <NEWLINE> <INDENT> m = max ( a , c ) <NEWLINE> if m < 1 : <NEWLINE> <INDENT> chk = False <NEWLINE> break <NEWLINE> <DEDENT> if c == 1 and a == 1 : <NEWLINE> <INDENT> if num == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cc [ num + 1 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif m == a : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if q [ 0 ] == <STRING> and q [ 1 ] == <STRING> : <NEWLINE> <INDENT> m = max ( b , c ) <NEWLINE> if m < 1 : <NEWLINE> <INDENT> chk = False <NEWLINE> break <NEWLINE> <DEDENT> if c == 1 and b == 1 : <NEWLINE> <INDENT> if num == n - 1 : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cc [ num + 1 ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif m == b : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not chk : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = n % k <NEWLINE> b = abs ( a - k ) <NEWLINE> print ( min ( n , a , b ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ <STRING> ] * n <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ans [ s - 1 ] == <STRING> or ans [ s - 1 ] == str ( c ) : <NEWLINE> <INDENT> ans [ s - 1 ] = str ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> if ans [ 0 ] == <STRING> and n > 1 : <NEWLINE> <INDENT> ans [ 0 ] = str ( 1 ) <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( ans ) . replace ( <STRING> , str ( 0 ) ) <NEWLINE> ans = int ( ans ) <NEWLINE> l = str ( ans ) <NEWLINE> if len ( l ) != n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> sum = 0 <NEWLINE> r = int ( s . count ( <STRING> ) ) <NEWLINE> g = int ( s . count ( <STRING> ) ) <NEWLINE> b = int ( s . count ( <STRING> ) ) <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> i = 2 * j - k <NEWLINE> if i + 1 > 0 : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - sum ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loop = 0 <NEWLINE> use = [ 0 ] * n <NEWLINE> now = 0 <NEWLINE> use [ now ] = 1 <NEWLINE> x = [ 1 ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> next = a [ now ] - 1 <NEWLINE> x . append ( next + 1 ) <NEWLINE> if use [ next ] == 0 : <NEWLINE> <INDENT> use [ next ] = 1 <NEWLINE> now = next <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> loop = x . pop ( - 1 ) <NEWLINE> <NL> tmp = x . index ( loop ) <NEWLINE> y = x [ : tmp ] <NEWLINE> x = x [ tmp : ] <NEWLINE> <COMMENT> <NL> <NL> if k < len ( y ) : <NEWLINE> <INDENT> kk = k % len ( y ) <NEWLINE> print ( y [ kk ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= len ( y ) <NEWLINE> kk = k % len ( x ) <NEWLINE> print ( x [ kk ] ) <NEWLINE> <DEDENT>
first = True <NEWLINE> while True : <NEWLINE> <INDENT> P = int ( input ( ) ) <NEWLINE> if P == 0 : break <NEWLINE> if first : <NEWLINE> <INDENT> first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> c1 , c2 , c3 , c4 = map ( int , input ( ) . split ( ) ) <NEWLINE> v = c1 * 10 + c2 * 50 + c3 * 100 + c4 * 500 <NEWLINE> n = c1 + c2 + c3 + c4 <NEWLINE> ans = { } <NEWLINE> rem = v - P <NEWLINE> ans [ 10 ] = c1 - ( rem // 10 ) % 5 <NEWLINE> ans [ 50 ] = c2 - ( rem // 50 ) % 2 <NEWLINE> ans [ 100 ] = c3 - ( rem // 100 ) % 5 <NEWLINE> ans [ 500 ] = c4 - rem // 500 <NEWLINE> for k , v in sorted ( ans . items ( ) ) : <NEWLINE> <INDENT> if v <= 0 : continue <NEWLINE> print ( <STRING> . format ( k , v ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> NR = int ( N ** 0.5 ) <NEWLINE> count = 0 <NEWLINE> if int ( N / 2 ) - N / 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , int ( N / 2 ) ) : <NEWLINE> <INDENT> if int ( N / i ) - N / i == 0 : <NEWLINE> <INDENT> count += int ( N / i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += int ( N / i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , int ( N / 2 ) + 1 ) : <NEWLINE> <INDENT> if int ( N / i ) - N / i == 0 : <NEWLINE> <INDENT> count += int ( N / i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += int ( N / i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count += int ( N / 2 ) <NEWLINE> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def func ( x ) : <NEWLINE> <INDENT> res = ( A * x ) // B - A * ( x // B ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> print ( func ( min ( N , B - 1 ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> A_list = [ ] <NEWLINE> B_list = [ ] <NEWLINE> Remove_list = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list . append ( A - 1 ) <NEWLINE> B_list . append ( B - 1 ) <NEWLINE> <NL> <DEDENT> for A , B in zip ( A_list , B_list ) : <NEWLINE> <INDENT> A_height = H [ A ] <NEWLINE> B_height = H [ B ] <NEWLINE> <NL> if A_height <= B_height : <NEWLINE> <INDENT> Remove_list . append ( A ) <NEWLINE> <NL> <DEDENT> if B_height <= A_height : <NEWLINE> <INDENT> Remove_list . append ( B ) <NEWLINE> <NL> <DEDENT> <DEDENT> S = set ( range ( N ) ) <NEWLINE> S = S - set ( Remove_list ) <NEWLINE> <NL> print ( len ( S ) ) <NEWLINE>
import math <NEWLINE> <NL> a = float ( input ( ) ) <NEWLINE> area = a * a * math . pi <NEWLINE> cir = ( a * 2 ) * math . pi <NEWLINE> print ( area , cir ) <NEWLINE>
import itertools , sys <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> N , M , K = LI ( ) <NEWLINE> A = LI ( ) <NEWLINE> B = LI ( ) <NEWLINE> accumulate_A = [ 0 ] + list ( itertools . accumulate ( A ) ) <NEWLINE> accumulate_B = [ 0 ] + list ( itertools . accumulate ( B ) ) <NEWLINE> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if accumulate_A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while accumulate_A [ i ] + accumulate_B [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
ans = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W == H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r = <STRING> <NEWLINE> r += <STRING> * W + <STRING> <NEWLINE> <NL> for i in range ( H - 2 ) : <NEWLINE> <INDENT> r += <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <NL> <DEDENT> r += <STRING> * W + <STRING> <NEWLINE> ans . append ( r ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list = [ 0 ] * h <NEWLINE> w_list = [ 0 ] * w <NEWLINE> bomb = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h_tmp , w_tmp = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list [ h_tmp - 1 ] += 1 <NEWLINE> w_list [ w_tmp - 1 ] += 1 <NEWLINE> bomb . append ( ( h_tmp - 1 , w_tmp - 1 ) ) <NEWLINE> <DEDENT> bomb = set ( bomb ) <NEWLINE> mh = max ( h_list ) <NEWLINE> id_h = [ ] <NEWLINE> for i , n in enumerate ( h_list ) : <NEWLINE> <INDENT> if n == mh : <NEWLINE> <INDENT> id_h . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> mw = max ( w_list ) <NEWLINE> id_w = [ ] <NEWLINE> for i , n in enumerate ( w_list ) : <NEWLINE> <INDENT> if n == mw : <NEWLINE> <INDENT> id_w . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in id_h : <NEWLINE> <INDENT> for j in id_w : <NEWLINE> <INDENT> if not ( i , j ) in bomb : <NEWLINE> <INDENT> print ( mh + mw ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( mh + mw - 1 ) <NEWLINE>
<NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> n2 = n - 1 <NEWLINE> for i in range ( 1 , n2 ) : <NEWLINE> <INDENT> count += n2 // i <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i - j < 0 or i + j >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = S [ i - j ] <NEWLINE> y = S [ i ] <NEWLINE> z = S [ i + j ] <NEWLINE> <NL> if x != y and x != z and y != z : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( reverse = True ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> numbers = make_divisors ( m ) <NEWLINE> for i in range ( len ( numbers ) ) : <NEWLINE> <INDENT> if numbers [ i ] <= m / n : <NEWLINE> <INDENT> print ( numbers [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( S - A [ i ] ) <NEWLINE> S -= A [ i ] <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
board = [ [ False ] * 1000001 ] * 1000001 <NEWLINE> while True : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> sx , sy = map ( int , input ( ) . split ( ) ) <NEWLINE> star = [ ] <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> star . append ( ( x - sx , y - sy ) ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> starlist = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> board [ starlist [ i ] [ 0 ] ] [ starlist [ i ] [ 1 ] ] = True <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for j in range ( len ( star ) ) : <NEWLINE> <INDENT> dx = starlist [ i ] [ 0 ] + star [ j ] [ 0 ] <NEWLINE> dy = starlist [ i ] [ 1 ] + star [ j ] [ 1 ] <NEWLINE> if 0 <= dx <= 1000000 and 0 <= dy <= 1000000 and board [ dx ] [ dy ] == False : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( <STRING> . format ( str ( starlist [ i ] [ 0 ] - sx ) , str ( starlist [ i ] [ 1 ] - sy ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from bisect import bisect_left as bl <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> p . sort ( ) <NEWLINE> a = bl ( p , x ) <NEWLINE> if a == n : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif p [ a ] != x : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> if p [ bl ( p , x - i ) ] != x - i : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = bl ( p , x + i ) <NEWLINE> if a == n : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> elif p [ a ] != x + i : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import bisect , copy , heapq , string <NEWLINE> from collections import * <NEWLINE> from math import * <NEWLINE> from itertools import * <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> q = INT ( ) <NEWLINE> p = [ 0 ] * q <NEWLINE> flag = 0 <NEWLINE> c0 = c1 = <STRING> <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> p [ i ] = input ( ) <NEWLINE> if p [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 - flag <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t , f , c = p [ i ] . split ( ) <NEWLINE> if ( f == <STRING> and flag == 0 ) or ( f == <STRING> and flag == 1 ) : <NEWLINE> <INDENT> c0 = c + c0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c1 = c1 + c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s = c0 + s + c1 <NEWLINE> print ( s if flag == 0 else s [ : : - 1 ] ) <NEWLINE>
cn = 1 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if cn == 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> cn += 1 <NEWLINE> <DEDENT> if cn == 2 : <NEWLINE> <INDENT> nums = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> nums = list ( map ( int , nums ) ) <NEWLINE> nums . reverse ( ) <NEWLINE> l = <STRING> <NEWLINE> for x in nums : <NEWLINE> <INDENT> l += <STRING> . format ( x ) <NEWLINE> <DEDENT> print ( l [ 1 : ] ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> ones = S . count ( <STRING> ) <NEWLINE> zeros = S . count ( <STRING> ) <NEWLINE> print ( min ( ones , zeros ) * 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> s = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> tmp = s * A [ i + 1 ] <NEWLINE> ans += ( tmp % MOD ) <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
import math <NEWLINE> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> L = b * a ** 2 <NEWLINE> if L == x : <NEWLINE> <INDENT> alfa = 0 <NEWLINE> <DEDENT> elif x >= L / 2 : <NEWLINE> <INDENT> h = x / ( a ** 2 ) <NEWLINE> beta = math . atan ( ( a / 2 ) / ( b - h ) ) <NEWLINE> alfa = ( math . pi ) / 2 - beta <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> alfa = math . atan ( b / ( 2 * x / ( a * b ) ) ) <NEWLINE> <DEDENT> print ( math . degrees ( alfa ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for a in range ( 1 , N , 1 ) : <NEWLINE> <INDENT> ans = ans + ( N - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> mask = 1 <NEWLINE> <NL> for i in range ( 60 ) : <NEWLINE> <INDENT> ones = np . count_nonzero ( A & mask ) <NEWLINE> ans += ( ones * ( N - ones ) % MOD ) * ( mask % MOD ) <NEWLINE> ans %= MOD <NEWLINE> mask <<= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ret = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n <= N : <NEWLINE> <INDENT> ret [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ret [ 1 : N + 1 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> mx = max ( A ) + 1 <NEWLINE> B = np . zeros ( mx ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> for b in range ( a , mx , a ) : <NEWLINE> <INDENT> B [ b ] = B [ b ] + 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if B [ a ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> if A [ 0 ] != 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> MOD = 998244353 <NEWLINE> INF = 10 ** 15 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * ( 1 + S ) <NEWLINE> dp [ 0 ] = pow ( 2 , N , MOD ) <NEWLINE> inv2 = pow ( 2 , MOD - 2 , MOD ) <NEWLINE> for a in A : <NEWLINE> <INDENT> for s in range ( S , a - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ s ] = ( dp [ s ] + dp [ s - a ] * inv2 ) % MOD <NEWLINE> <DEDENT> <DEDENT> print ( dp [ S ] ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> print ( int ( min ( S . count ( <STRING> ) , S . count ( <STRING> ) ) ) * 2 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = 0 <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> print ( [ <STRING> , <STRING> ] [ a [ j ] < a [ i ] ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif A < K <= ( A + B ) : <NEWLINE> <INDENT> print ( 0 , B - ( K - A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> <NL>
<NL> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> tar = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> tar *= i <NEWLINE> if tar > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( tar ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> ans += s * a [ i ] <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> A = [ 0 , 0 , 1 ] <NEWLINE> if S == 1 or S == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif S == 3 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , S ) : <NEWLINE> <INDENT> A += [ A [ i - 1 ] + A [ i - 3 ] ] <NEWLINE> <DEDENT> print ( A [ i ] % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> ini = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> tmp = a [ i ] * s <NEWLINE> ini . append ( tmp ) <NEWLINE> <DEDENT> print ( sum ( ini ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def I2 ( ) : return map ( int , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> def S ( ) : return str ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def L ( ) : return list ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def Intl ( ) : return [ int ( k ) for k in sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ] <NEWLINE> def Lx ( k ) : return list ( map ( lambda x : int ( x ) * - k , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = I2 ( ) <NEWLINE> h = [ I ( ) for _ in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a , b = h [ i ] , h [ i + k - 1 ] <NEWLINE> <COMMENT> <NL> ans = min ( ans , b - a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> result = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> result *= i <NEWLINE> if 10 ** 18 < result : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> fn = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if fn > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ fn ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
import sys <NEWLINE> X = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 118 , 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> import sys <NEWLINE> <NL> n , m = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> n = int ( n ) ; m = int ( m ) <NEWLINE> <NL> c = n <NEWLINE> <NL> a = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( line ) <NEWLINE> c -= 1 <NEWLINE> if c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = a [ i ] . strip ( ) . split ( <STRING> ) <NEWLINE> for j in range ( 0 , len ( a [ i ] ) ) : <NEWLINE> <INDENT> a [ i ] [ j ] = int ( a [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for r in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> a [ r ] . append ( sum ( a [ r ] ) ) <NEWLINE> <NL> <DEDENT> arr = [ ] <NEWLINE> for c in a [ 0 ] : <NEWLINE> <INDENT> arr . append ( 0 ) <NEWLINE> <DEDENT> for r in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> for c in range ( 0 , len ( a [ i ] ) ) : <NEWLINE> <INDENT> arr [ c ] += a [ r ] [ c ] <NEWLINE> <DEDENT> <DEDENT> a . append ( arr ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> for j in range ( 0 , len ( i ) ) : <NEWLINE> <INDENT> if j != len ( i ) - 1 : <NEWLINE> <INDENT> print ( str ( i [ j ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( i [ j ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
class Dice ( ) : <NEWLINE> <INDENT> def __init__ ( self , ary ) : <NEWLINE> <INDENT> self . top = ary [ 0 ] <NEWLINE> self . south = ary [ 1 ] <NEWLINE> self . east = ary [ 2 ] <NEWLINE> self . west = ary [ 3 ] <NEWLINE> self . north = ary [ 4 ] <NEWLINE> self . bottom = ary [ 5 ] <NEWLINE> <NL> <DEDENT> def get_top ( self ) : <NEWLINE> <INDENT> return self . top <NEWLINE> <NL> <DEDENT> def rotate_north ( self ) : <NEWLINE> <INDENT> self . top , self . south , self . north , self . bottom = self . south , self . bottom , self . top , self . north <NEWLINE> <NL> <DEDENT> def rotate_south ( self ) : <NEWLINE> <INDENT> self . top , self . south , self . north , self . bottom = self . north , self . top , self . bottom , self . south <NEWLINE> <NL> <DEDENT> def rotate_west ( self ) : <NEWLINE> <INDENT> self . top , self . west , self . bottom , self . east = self . east , self . top , self . west , self . bottom <NEWLINE> <NL> <DEDENT> def rotate_east ( self ) : <NEWLINE> <INDENT> self . top , self . west , self . bottom , self . east = self . west , self . bottom , self . east , self . top <NEWLINE> <NL> <DEDENT> def rotate_horizon ( self ) : <NEWLINE> <INDENT> self . south , self . east , self . north , self . west = self . west , self . south , self . east , self . north <NEWLINE> <NL> <DEDENT> def get_east ( self ) : <NEWLINE> <INDENT> return self . east <NEWLINE> <NL> <DEDENT> <DEDENT> dice = Dice ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> rot = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if rot [ 0 ] == dice . top : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice . rotate_horizon ( ) <NEWLINE> if dice . south == rot [ 1 ] : <NEWLINE> <INDENT> h = dice . get_east ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif rot [ 0 ] == dice . west : <NEWLINE> <INDENT> dice . rotate_east ( ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice . rotate_horizon ( ) <NEWLINE> if dice . south == rot [ 1 ] : <NEWLINE> <INDENT> h = dice . get_east ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif rot [ 0 ] == dice . bottom : <NEWLINE> <INDENT> dice . rotate_east ( ) <NEWLINE> dice . rotate_east ( ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice . rotate_horizon ( ) <NEWLINE> if dice . south == rot [ 1 ] : <NEWLINE> <INDENT> h = dice . get_east ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif rot [ 0 ] == dice . east : <NEWLINE> <INDENT> dice . rotate_west ( ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice . rotate_horizon ( ) <NEWLINE> if dice . south == rot [ 1 ] : <NEWLINE> <INDENT> h = dice . get_east ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif rot [ 0 ] == dice . north : <NEWLINE> <INDENT> dice . rotate_south ( ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice . rotate_horizon ( ) <NEWLINE> if dice . south == rot [ 1 ] : <NEWLINE> <INDENT> h = dice . get_east ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dice . rotate_north ( ) <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> dice . rotate_horizon ( ) <NEWLINE> if dice . south == rot [ 1 ] : <NEWLINE> <INDENT> h = dice . get_east ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( h ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> numbers = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> numbers . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> lis = [ numbers [ 0 ] ] <NEWLINE> for last in numbers [ 1 : ] : <NEWLINE> <INDENT> if lis [ - 1 ] < last : <NEWLINE> <INDENT> lis . append ( last ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos = bisect . bisect_left ( lis , last ) <NEWLINE> lis [ pos ] = last <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( lis ) ) <NEWLINE>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ 0 ] * N <NEWLINE> for _ in range ( Q ) : <NEWLINE> <COMMENT> <NL> <INDENT> A = int ( input ( ) ) <NEWLINE> p [ A - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for ans in p : <NEWLINE> <INDENT> if ans <= Q - K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from heapq import heappush , heappop , heapify <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> import itertools <NEWLINE> from itertools import permutations , combinations , accumulate , product , combinations_with_replacement <NEWLINE> import sys <NEWLINE> import bisect <NEWLINE> import string <NEWLINE> import math <NEWLINE> import time <NEWLINE> <NL> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> def StoI ( ) : return [ ord ( i ) - 97 for i in input ( ) ] <NEWLINE> def ItoS ( nn ) : return chr ( nn + 97 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] <NEWLINE> def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] <NEWLINE> def print_matrix ( mat ) : <NEWLINE> <INDENT> for i in range ( len ( mat ) ) : <NEWLINE> <INDENT> print ( * [ <STRING> if v == IINF else <STRING> . format ( v ) for v in mat [ i ] ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> yn = { False : <STRING> , True : <STRING> } <NEWLINE> YN = { False : <STRING> , True : <STRING> } <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> IINF = 10 ** 19 <NEWLINE> l_alp = string . ascii_lowercase <NEWLINE> u_alp = string . ascii_uppercase <NEWLINE> ts = time . time ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> nums = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> show_flg = False <NEWLINE> <COMMENT> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = MI ( ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> mid = N // 2 <NEWLINE> print ( B [ mid ] - A [ mid ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mid1 = N // 2 <NEWLINE> mid2 = mid1 - 1 <NEWLINE> r = B [ mid1 ] + B [ mid2 ] <NEWLINE> l = A [ mid1 ] + A [ mid2 ] <NEWLINE> print ( r - l + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> k = N % 9 <NEWLINE> <NL> if k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if k != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> for d in range ( 61 ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ( a >> d ) & 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> ans += x * ( n - x ) * 2 ** d <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> b = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> bi = b ** 5 <NEWLINE> ai = x + bi <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( int ( ( ai ** ( 1 / 5 ) ) % 1.0 ) == 0 ) : <NEWLINE> <NL> <INDENT> aj = int ( ( ai ** ( 1 / 5 ) ) // 1 ) <NEWLINE> <COMMENT> <NL> if ( ( aj ** 5 ) == ai ) : <NEWLINE> <INDENT> print ( aj , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> b *= - 1 <NEWLINE> <NL> bi = b ** 5 <NEWLINE> ai = x + bi <NEWLINE> <NL> if ( ai >= 0 and int ( ( ai ** ( 1 / 5 ) ) % 1.0 ) == 0 ) : <NEWLINE> <INDENT> aj = int ( ( ai ** ( 1 / 5 ) ) // 1 ) <NEWLINE> <COMMENT> <NL> if ( ( aj ** 5 ) == ai ) : <NEWLINE> <INDENT> print ( aj , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> b *= - 1 <NEWLINE> <NL> b += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> plus = dict ( ) <NEWLINE> minus = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = i + 1 <NEWLINE> p = a [ i ] + num <NEWLINE> m = num - a [ i ] <NEWLINE> if p in plus : <NEWLINE> <INDENT> plus [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus [ p ] = 1 <NEWLINE> <DEDENT> if ( m ) in minus : <NEWLINE> <INDENT> minus [ m ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus [ m ] = 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for v in plus . keys ( ) : <NEWLINE> <INDENT> if v in minus : <NEWLINE> <INDENT> c += plus [ v ] * minus [ v ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> a = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = set ( ) <NEWLINE> <NL> maxv = - 9999999999 <NEWLINE> minv = a [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ( a [ i ] - minv ) > maxv : <NEWLINE> <INDENT> maxv = a [ i ] - minv <NEWLINE> <DEDENT> if a [ i ] < minv : <NEWLINE> <INDENT> minv = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = 1000000000000000000 <NEWLINE> res = 1 <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for val in A : <NEWLINE> <INDENT> res = res * val <NEWLINE> if res > x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> out = 0 <NEWLINE> Count = [ 0 ] * K <NEWLINE> gcds = [ [ 0 ] * K for i in range ( K ) ] <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , + K + 1 ) : <NEWLINE> <INDENT> value = gcd ( i , j ) <NEWLINE> gcds [ i - 1 ] [ j - 1 ] = value <NEWLINE> Count [ value - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> out += gcds [ i - 1 ] [ j - 1 ] * Count [ j - 1 ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] * ( 10 ** 6 + 3 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <NL> <DEDENT> pairwise = True <NEWLINE> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if sum ( c [ : : i ] ) > 1 : <NEWLINE> <INDENT> pairwise = False <NEWLINE> <NL> <DEDENT> <DEDENT> g = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> g = math . gcd ( g , i ) <NEWLINE> <DEDENT> if g == 1 : <NEWLINE> <INDENT> setwise = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> setwise = False <NEWLINE> <NL> <DEDENT> if pairwise == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif setwise == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import pprint <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> class Logger : <NEWLINE> <INDENT> def __init__ ( self , debug ) : <NEWLINE> <INDENT> self . debug = debug <NEWLINE> <DEDENT> def print ( self , * args ) : <NEWLINE> <INDENT> if self . debug : <NEWLINE> <INDENT> pprint . pprint ( args ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def upper_case ( lst , key ) : <NEWLINE> <INDENT> ng = - 1 <NEWLINE> ok = len ( lst ) <NEWLINE> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if lst [ mid ] > key : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> log = Logger ( 0 ) <NEWLINE> n , m , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <DEDENT> log . print ( a , b ) <NEWLINE> ans = upper_case ( b , k ) <NEWLINE> log . print ( ans , b , k ) <NEWLINE> for i in range ( - 1 , n ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = max ( ans , i + 1 + upper_case ( b , k - a [ i ] ) ) <NEWLINE> log . print ( i , k - a [ i ] , upper_case ( b , k - a [ i ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> zero = 0 <NEWLINE> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> elif a [ i ] > 0 : <NEWLINE> <INDENT> plus . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> P , M = len ( plus ) , len ( minus ) <NEWLINE> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( ) <NEWLINE> ans = 1 <NEWLINE> if n == k : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> elif P + M < k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif P == 0 and k % 2 == 1 : <NEWLINE> <INDENT> if zero >= 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= minus [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> q = 0 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> ans *= plus [ 0 ] <NEWLINE> q = 1 <NEWLINE> <DEDENT> judge = [ ] <NEWLINE> for i in range ( ( P - q ) // 2 ) : <NEWLINE> <INDENT> judge . append ( plus [ 2 * i + q ] * plus [ 2 * i + q + 1 ] ) <NEWLINE> <DEDENT> for i in range ( M // 2 ) : <NEWLINE> <INDENT> judge . append ( minus [ 2 * i ] * minus [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> judge . sort ( reverse = True ) <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> ans *= ( judge [ i ] % mod ) <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> d . setdefault ( S , 0 ) <NEWLINE> d [ S ] += 1 <NEWLINE> <NL> <DEDENT> max = max ( d . values ( ) ) <NEWLINE> for key in d . keys ( ) : <NEWLINE> <INDENT> if d [ key ] == max : <NEWLINE> <INDENT> ans . append ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sorted ( ans ) <NEWLINE> <NL> for word in ans : <NEWLINE> <INDENT> print ( word ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> h = [ int ( x ) for x in list ( S ) ] <NEWLINE> N = len ( h ) <NEWLINE> a = [ 0 ] * 2019 <NEWLINE> a [ 0 ] = 1 <NEWLINE> T = 0 <NEWLINE> r = 1 <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> T = ( T + h [ i ] * r ) % 2019 <NEWLINE> r = r * 10 <NEWLINE> r = r % 2019 <NEWLINE> c += a [ T ] <NEWLINE> a [ T ] += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import sys , math <NEWLINE> <NL> inputs = list ( ) <NEWLINE> <NL> for n in sys . stdin : <NEWLINE> <INDENT> inputs . append ( list ( map ( int , n . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for n in inputs : <NEWLINE> <INDENT> print ( math . floor ( math . log10 ( n [ 0 ] + n [ 1 ] ) ) + 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic_A = { 0 : 1 } <NEWLINE> direction = 0 <NEWLINE> flag = True <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> direction = A_list [ direction ] - 1 <NEWLINE> if direction in dic_A : <NEWLINE> <INDENT> dic_A [ direction ] += 1 <NEWLINE> if dic_A [ direction ] >= 3 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dic_A [ direction ] = 1 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( direction + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> dic_ans = { } <NEWLINE> for k , v in dic_A . items ( ) : <NEWLINE> <INDENT> if v >= 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> dic_ans [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = K - ( len ( dic_A ) - cnt ) <NEWLINE> ans %= cnt <NEWLINE> for k , v in dic_ans . items ( ) : <NEWLINE> <INDENT> if ans == 0 : <NEWLINE> <INDENT> true = k <NEWLINE> break <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> <DEDENT> print ( true + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> word = input ( ) <NEWLINE> a . append ( word ) <NEWLINE> <DEDENT> print ( len ( set ( a ) ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> S = sorted ( S ) <NEWLINE> count = 0 <NEWLINE> first = 0 <NEWLINE> removecount = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while first + count + 1 < len ( S ) : <NEWLINE> <INDENT> if S [ first ] == S [ first + 1 + j ] : <NEWLINE> <INDENT> S [ first + 1 + j ] = <STRING> <NEWLINE> count += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first += count + 1 <NEWLINE> removecount += count <NEWLINE> count = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( S ) - S . count ( <STRING> ) ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> <NL> N , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> deq = deque ( [ A [ 0 ] ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> for x in A [ 1 : ] : <NEWLINE> <INDENT> ans += deq . popleft ( ) <NEWLINE> deq . append ( x ) <NEWLINE> deq . append ( x ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> sin = input ( ) <NEWLINE> match = re . findall ( <STRING> , sin ) <NEWLINE> m_len = [ len ( m ) for m in match ] <NEWLINE> print ( max ( m_len if m_len else <STRING> ) ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> <NL> def expo ( x , i ) : <NEWLINE> <INDENT> while x % i == 0 : <NEWLINE> <INDENT> x = x // i <NEWLINE> <DEDENT> if x == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> if x > 4 : <NEWLINE> <INDENT> while x > 1 : <NEWLINE> <INDENT> for j in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if expo ( x , j ) == True : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if expo ( x , j ) == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
import queue <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for i in range ( N + 1 ) ] <COMMENT> <NEWLINE> parent = [ - 1 ] * ( N + 1 ) <COMMENT> <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ a ] . append ( b ) <COMMENT> <NEWLINE> adj [ b ] . append ( a ) <COMMENT> <NEWLINE> <DEDENT> q = queue . Queue ( ) <COMMENT> <NEWLINE> q . put ( ( 1 , 0 ) ) <COMMENT> <NEWLINE> while ( not q . empty ( ) ) : <COMMENT> <NEWLINE> <INDENT> x , p = q . get ( ) <COMMENT> <NEWLINE> if parent [ x ] != - 1 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ x ] = p <COMMENT> <NEWLINE> for next in adj [ x ] : <COMMENT> <NEWLINE> <INDENT> if parent [ next ] == - 1 : <COMMENT> <NEWLINE> <INDENT> q . put ( ( next , x ) ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <COMMENT> <NEWLINE> for p in parent [ 2 : ] : <COMMENT> <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def int1 ( x ) : <NEWLINE> <INDENT> return int ( x ) - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_map ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple_minus1 ( ) : <NEWLINE> <INDENT> return tuple ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = input_int ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> temp = n // j <NEWLINE> ans += temp * ( temp + 1 ) * j // 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def find ( x ) : <NEWLINE> <INDENT> if vertices [ x ] != x : <NEWLINE> <INDENT> vertices [ x ] = find ( vertices [ x ] ) <NEWLINE> <DEDENT> return vertices [ x ] <NEWLINE> <NL> <DEDENT> nv , ne = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> vertices = [ i for i in range ( nv ) ] <NEWLINE> edges = [ ] <NEWLINE> for i in range ( ne ) : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> edges . append ( ( s , t , w ) ) <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> forest = [ [ v ] for v in range ( nv ) ] <NEWLINE> edges . sort ( key = lambda tup : tup [ 2 ] ) <NEWLINE> for s , t , w in edges : <NEWLINE> <INDENT> u = find ( s ) <NEWLINE> v = find ( t ) <NEWLINE> if u != v : <NEWLINE> <INDENT> vertices [ u ] = v <NEWLINE> sum += w <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def solution ( X , N , P ) : <NEWLINE> <INDENT> if N <= 0 or X not in P : <NEWLINE> <INDENT> return X <NEWLINE> <NL> <DEDENT> P . sort ( ) <NEWLINE> diff = [ abs ( p - X ) for p in P ] <NEWLINE> X_idx = diff . index ( 0 ) <NEWLINE> left = sorted ( diff [ : X_idx ] ) <NEWLINE> right = sorted ( diff [ X_idx + 1 : ] ) <NEWLINE> <NL> for i in range ( 1 , len ( P ) + 1 ) : <NEWLINE> <INDENT> left = X - i <NEWLINE> right = X + i <NEWLINE> <NL> nearest_l = None <NEWLINE> nearest_r = None <NEWLINE> if left not in P : <NEWLINE> <INDENT> nearest_l = left <NEWLINE> break <NEWLINE> <DEDENT> if right not in P : <NEWLINE> <INDENT> nearest_r = right <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> nearest_r = len ( P ) + 1 <NEWLINE> <DEDENT> if nearest_l and nearest_r : <NEWLINE> <INDENT> nearest = min ( nearest_l , nearest_r ) <NEWLINE> <DEDENT> elif nearest_l is not None : <NEWLINE> <INDENT> nearest = nearest_l <NEWLINE> <DEDENT> elif nearest_r is not None : <NEWLINE> <INDENT> nearest = nearest_r <NEWLINE> <DEDENT> return nearest <NEWLINE> <NL> <DEDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( solution ( X , N , P ) ) <NEWLINE>
import sys <NEWLINE> str = sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> print ( str [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> ss = sorted ( s ) <NEWLINE> t = ss <NEWLINE> x = 0 <NEWLINE> maxx = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ss [ i ] == ss [ i + 1 ] : <NEWLINE> <INDENT> x += 1 <NEWLINE> if x == maxx : <NEWLINE> <INDENT> maxx = x <NEWLINE> t . append ( ss [ i ] ) <NEWLINE> <DEDENT> elif x > maxx : <NEWLINE> <INDENT> maxx = x <NEWLINE> t = [ ss [ i ] ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> <DEDENT> for j in t : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , k ) , j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
type_in = input ( ) <NEWLINE> s = type_in . split ( <STRING> ) <NEWLINE> D = int ( s [ 0 ] ) <NEWLINE> T = int ( s [ 1 ] ) <NEWLINE> S = int ( s [ 2 ] ) <NEWLINE> if ( D <= T * S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = min ( a_li ) + min ( b_li ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> price = a_li [ x - 1 ] + b_li [ y - 1 ] - c <NEWLINE> if price < cost : <NEWLINE> <INDENT> cost = price <NEWLINE> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> ar = np . zeros ( 10 ** 5 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> ar [ i ] += 1 <NEWLINE> <DEDENT> ans = np . sum ( A ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ans + ar [ b ] * ( c - b ) <NEWLINE> ar [ c ] += ar [ b ] <NEWLINE> ar [ b ] = 0 <NEWLINE> print ( int ( ans ) ) <NEWLINE> <DEDENT>
class D_Linked_List : <NEWLINE> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , next = None , prev = None ) : <NEWLINE> <INDENT> self . next = next <NEWLINE> self . prev = prev <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nil = D_Linked_List . Node ( None ) <NEWLINE> self . nil . next = self . nil <NEWLINE> self . nil . prev = self . nil <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> node_x = D_Linked_List . Node ( key , self . nil . next , self . nil ) <NEWLINE> self . nil . next . prev = node_x <NEWLINE> self . nil . next = node_x <NEWLINE> <NL> <DEDENT> def _listSearch ( self , key ) : <NEWLINE> <INDENT> cur_node = self . nil . next <NEWLINE> while ( cur_node != self . nil ) and ( cur_node . key != key ) : <NEWLINE> <INDENT> cur_node = cur_node . next <NEWLINE> <DEDENT> return cur_node <NEWLINE> <NL> <DEDENT> def _deleteNode ( self , node ) : <NEWLINE> <INDENT> if node == self . nil : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> node . prev . next = node . next <NEWLINE> node . next . prev = node . prev <NEWLINE> <NL> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . _deleteNode ( self . nil . next ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . _deleteNode ( self . nil . prev ) <NEWLINE> <NL> <DEDENT> def deleteKey ( self , key ) : <NEWLINE> <INDENT> node = self . _listSearch ( key ) <NEWLINE> self . _deleteNode ( node ) <NEWLINE> <NL> <DEDENT> def show_keys ( self ) : <NEWLINE> <INDENT> cur_node = self . nil . next <NEWLINE> keys = [ ] <NEWLINE> while cur_node != self . nil : <NEWLINE> <INDENT> keys . append ( cur_node . key ) <NEWLINE> cur_node = cur_node . next <NEWLINE> <DEDENT> print ( <STRING> . join ( keys ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> d_ll = D_Linked_List ( ) <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> x = i [ 7 : - 1 ] <NEWLINE> d_ll . insert ( x ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> d_ll . deleteFirst ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> d_ll . deleteLast ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> x = i [ 7 : - 1 ] <NEWLINE> d_ll . deleteKey ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> d_ll . show_keys ( ) <NEWLINE>
def primeq ( x ) : <NEWLINE> <INDENT> if x == 1 : return False <NEWLINE> for i in range ( 2 , int ( x ** .5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if primeq ( int ( input ( ) ) ) : c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( a ) - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> query = [ list ( input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> forward = 1 <NEWLINE> f = <STRING> <NEWLINE> b = <STRING> <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if query [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> forward *= - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if query [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> if forward == 1 : <NEWLINE> <INDENT> f += query [ i ] [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += query [ i ] [ 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if forward == 1 : <NEWLINE> <INDENT> b += query [ i ] [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += query [ i ] [ 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> S = <STRING> . join ( list ( reversed ( f ) ) ) + S + b <NEWLINE> <NL> if forward == - 1 : <NEWLINE> <INDENT> ans = <STRING> . join ( list ( reversed ( S ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = S <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left <NEWLINE> N = int ( input ( ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> tmp = y [ i ] + y [ j ] <NEWLINE> ans += bisect_left ( y , tmp ) - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if C > 0 : <NEWLINE> <INDENT> A -= D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> @ njit ( ( i8 , i8 , i8 [ : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( H , N , A , B ) : <NEWLINE> <INDENT> INF = 1 << 30 <NEWLINE> dp = np . full ( H + 1 , INF , np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for h in range ( A [ i ] , H ) : <NEWLINE> <INDENT> dp [ h ] = min ( dp [ h ] , dp [ h - A [ i ] ] + B [ i ] ) <NEWLINE> <DEDENT> dp [ H ] = min ( dp [ H ] , min ( dp [ H - A [ i ] : H ] + B [ i ] ) ) <NEWLINE> <DEDENT> ans = dp [ - 1 ] <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . zeros ( N , np . int64 ) <NEWLINE> B = np . zeros ( N , np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( main ( H , N , A , B ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = set ( a ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in c : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ab = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a , b = ab [ i ] [ 0 ] , ab [ i ] [ 1 ] <NEWLINE> num = a + cnt <NEWLINE> if num % b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari = num % b <NEWLINE> cnt += b - amari <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ [ 0 ] * 3 for xxx in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> ans [ 0 ] [ 0 ] = a <NEWLINE> ans [ 0 ] [ 1 ] = b <NEWLINE> ans [ 0 ] [ 2 ] = c <NEWLINE> continue <NEWLINE> <DEDENT> ans [ i ] [ 0 ] += max ( ans [ i - 1 ] [ 1 ] , ans [ i - 1 ] [ 2 ] ) + a <NEWLINE> ans [ i ] [ 1 ] += max ( ans [ i - 1 ] [ 2 ] , ans [ i - 1 ] [ 0 ] ) + b <NEWLINE> ans [ i ] [ 2 ] += max ( ans [ i - 1 ] [ 0 ] , ans [ i - 1 ] [ 1 ] ) + c <NEWLINE> <DEDENT> ans = ans [ - 1 ] <NEWLINE> print ( max ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> numList = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> res = sum ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> numList [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> dev = B [ i ] [ 1 ] - B [ i ] [ 0 ] <NEWLINE> res += numList [ B [ i ] [ 0 ] ] * dev <NEWLINE> numList [ B [ i ] [ 1 ] ] += numList [ B [ i ] [ 0 ] ] <NEWLINE> numList [ B [ i ] [ 0 ] ] = 0 <NEWLINE> print ( res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 for i in range ( 200010 ) ] <NEWLINE> R = [ 0 for i in range ( 200010 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] + i < 200010 : <NEWLINE> <INDENT> L [ A [ i ] + i ] += 1 <NEWLINE> <DEDENT> if - A [ i ] + i > 0 : <NEWLINE> <INDENT> R [ - A [ i ] + i ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 200010 ) : <NEWLINE> <INDENT> ans += L [ i ] * R [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 26 <NEWLINE> counter = 1 <NEWLINE> while a < N : <NEWLINE> <INDENT> N -= a <NEWLINE> counter += 1 <NEWLINE> a *= 26 <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> N -= 1 <NEWLINE> while N >= 26 : <NEWLINE> <INDENT> ans . append ( N % 26 ) <NEWLINE> N = N // 26 <NEWLINE> <DEDENT> ans . append ( N ) <NEWLINE> dic = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ans = [ dic [ i ] for i in ans [ : : - 1 ] ] <NEWLINE> n = len ( ans ) <NEWLINE> print ( <STRING> * ( counter - n ) + <STRING> . join ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 2020202020 <NEWLINE> a = 0 <NEWLINE> b = sum ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += s [ i ] <NEWLINE> b -= s [ i ] <NEWLINE> ans = min ( ans , abs ( a - b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> P . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ad = { } <NEWLINE> for _ in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ad [ _ ] = set ( ) <NEWLINE> <NL> <DEDENT> for p in P : <NEWLINE> <INDENT> ad [ p [ 0 ] ] . add ( p [ 1 ] ) <NEWLINE> ad [ p [ 1 ] ] . add ( p [ 0 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for p in permutations ( range ( 2 , N + 1 ) , N - 1 ) : <NEWLINE> <INDENT> ans_flag = True <NEWLINE> start = 1 <NEWLINE> for p_ in p : <NEWLINE> <INDENT> end = p_ <NEWLINE> <COMMENT> <NL> if end not in ad [ start ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans_flag = False <NEWLINE> break <NEWLINE> <DEDENT> start = p_ <NEWLINE> <NL> <DEDENT> if ans_flag == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x , mod = divmod ( n , a + b ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> print ( min ( a , n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * x + min ( mod , a ) ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Q = int ( input ( ) ) <NEWLINE> K = Counter ( A ) <NEWLINE> S = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C in K : <NEWLINE> <INDENT> K [ C ] += K [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K [ C ] = K [ B ] <NEWLINE> <DEDENT> S += ( ( C - B ) * K [ B ] ) <NEWLINE> print ( S ) <NEWLINE> K [ B ] = 0 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> largest = N // i * i <NEWLINE> ans += ( ( largest + i ) * ( N // i ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> data = input ( ) <NEWLINE> n = [ 0 ] * 5 <NEWLINE> n [ 0 ] , n [ 1 ] , n [ 2 ] , n [ 3 ] , n [ 4 ] = map ( int , data . split ( <STRING> ) ) <NEWLINE> <NL> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( len ( n ) - 1 ) : <NEWLINE> <INDENT> if n [ i ] < n [ i + 1 ] : <NEWLINE> <INDENT> tmp = n [ i ] <NEWLINE> n [ i ] = n [ i + 1 ] <NEWLINE> n [ i + 1 ] = tmp <NEWLINE> <DEDENT> <DEDENT> count += 1 <NEWLINE> if count == 5 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( n ) - 1 ) : <NEWLINE> <INDENT> print ( n [ i ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( n [ len ( n ) - 1 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> result = N % K <NEWLINE> if result <= abs ( result - K ) : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> elif result > abs ( result - K ) : <NEWLINE> <INDENT> result = abs ( result - K ) <NEWLINE> print ( result ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> ruiseki = [ a [ 0 ] ] <NEWLINE> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> plus_bracket = [ ] <NEWLINE> minus_bracket = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> mini = 0 <NEWLINE> cur = 0 <NEWLINE> for bracket in input ( ) : <NEWLINE> <INDENT> if bracket == <STRING> : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur -= 1 <NEWLINE> <DEDENT> if cur < mini : <NEWLINE> <INDENT> mini = cur <NEWLINE> <DEDENT> <DEDENT> if cur > 0 : <NEWLINE> <INDENT> plus_bracket . append ( [ - mini , cur ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus_bracket . append ( [ cur - mini , - cur ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> success = True <NEWLINE> cur = 0 <NEWLINE> plus_bracket . sort ( ) <NEWLINE> minus_bracket . sort ( ) <NEWLINE> for bracket in plus_bracket : <NEWLINE> <INDENT> if cur < bracket [ 0 ] : <NEWLINE> <INDENT> success = False <NEWLINE> break <NEWLINE> <DEDENT> cur += bracket [ 1 ] <NEWLINE> <DEDENT> back_cur = 0 <NEWLINE> for bracket in minus_bracket : <NEWLINE> <INDENT> if back_cur < bracket [ 0 ] : <NEWLINE> <INDENT> success = False <NEWLINE> break <NEWLINE> <DEDENT> back_cur += bracket [ 1 ] <NEWLINE> <DEDENT> if cur != back_cur : <NEWLINE> <INDENT> success = False <NEWLINE> <NL> <DEDENT> if success : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = collections . Counter ( A_list ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( g [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = [ l for l in input ( ) ] <NEWLINE> ideal = [ <STRING> ] * ( c . count ( <STRING> ) ) + [ <STRING> ] * ( c . count ( <STRING> ) ) <NEWLINE> <NL> w_to_r = 0 <NEWLINE> r_to_w = 0 <NEWLINE> for i_ , c_ in zip ( ideal , c ) : <NEWLINE> <INDENT> if ( i_ == <STRING> ) and ( c_ == <STRING> ) : <NEWLINE> <INDENT> w_to_r += 1 <NEWLINE> <DEDENT> if ( i_ == <STRING> ) and ( c_ == <STRING> ) : <NEWLINE> <INDENT> r_to_w += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( w_to_r , r_to_w ) ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s1 = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( k , s1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> tmp = input ( ) <NEWLINE> <COMMENT> <NL> N , K = tmp . split ( ) <NEWLINE> que = input ( ) <NEWLINE> <COMMENT> <NL> try : <NEWLINE> <INDENT> N = int ( N ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> K = int ( K ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <NL> <DEDENT> que = [ int ( x ) for x in que . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> min_val = 999999999 <NEWLINE> <NL> que = sorted ( que ) <NEWLINE> <NL> <COMMENT> <NL> <NL> x = [ que [ i ] for i in range ( K ) ] <NEWLINE> min_val = np . sum ( x ) <NEWLINE> <NL> print ( min_val ) <NEWLINE>
from math import sqrt , floor <NEWLINE> <NL> p = [ 2 ] <NEWLINE> for i in range ( 3 , 50000 , 2 ) : <NEWLINE> <INDENT> for j in range ( 3 , floor ( sqrt ( i ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if not i % j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <DEDENT> <DEDENT> sp = set ( p ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n & 1 : <NEWLINE> <INDENT> print ( int ( n - 2 in sp ) ) <NEWLINE> continue <NEWLINE> <DEDENT> n2 = n // 2 <NEWLINE> cnt = 0 <NEWLINE> for i in p : <NEWLINE> <INDENT> if n2 < i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n - i in sp : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> def f ( nums ) : <NEWLINE> <INDENT> out = 0 <NEWLINE> for samp in abcd : <NEWLINE> <INDENT> if nums [ samp [ 1 ] - 1 ] - nums [ samp [ 0 ] - 1 ] == samp [ 2 ] : <NEWLINE> <INDENT> out += samp [ 3 ] <NEWLINE> <DEDENT> <DEDENT> return out <NEWLINE> <NL> <DEDENT> def g ( nums ) : <NEWLINE> <INDENT> if nums [ - 1 ] < M : <NEWLINE> <INDENT> nums [ - 1 ] += 1 <NEWLINE> return nums , False <NEWLINE> <NL> <DEDENT> i = N - 1 <NEWLINE> while i >= 0 and nums [ i ] == M : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <DEDENT> if i < 0 : <NEWLINE> <INDENT> return None , True <NEWLINE> <NL> <DEDENT> nums = nums [ : i ] + [ nums [ i ] + 1 for _ in range ( N - i ) ] <NEWLINE> return nums , False <NEWLINE> <NL> <DEDENT> nums = [ 1 ] * N <NEWLINE> fi = False <NEWLINE> ans = 0 <NEWLINE> <NL> while fi == False : <NEWLINE> <INDENT> p = f ( nums ) <NEWLINE> if ans < p : <NEWLINE> <INDENT> ans = p <NEWLINE> <DEDENT> nums , fi = g ( nums ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> MAX = int ( N ** 0.5 ) <NEWLINE> <NL> res = [ 0 ] * 10008 <NEWLINE> <NL> ans = 0 <NEWLINE> li = [ ] <NEWLINE> for x in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> tmp = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if tmp <= 10000 : <NEWLINE> <INDENT> res [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( res [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list . sort ( reverse = True ) <NEWLINE> n = 1 <NEWLINE> for i in A_list : <NEWLINE> <INDENT> if A_list [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> n = n * i <NEWLINE> if n > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> answer = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> answer = answer * i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> answer = N * ( N - 1 ) // 2 <NEWLINE> <NL> print ( int ( answer ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> t = N % K <NEWLINE> if t > abs ( t - K ) : <NEWLINE> <INDENT> t = abs ( t - K ) <NEWLINE> <NL> <DEDENT> print ( t ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> <COMMENT> <NL> max_A = 0 <NEWLINE> min_A = float ( <STRING> ) <NEWLINE> for num in A : <NEWLINE> <INDENT> max_A += num <NEWLINE> if num < min_A : <NEWLINE> <INDENT> min_A = num <NEWLINE> <NL> <DEDENT> <DEDENT> def rec ( i , m ) : <NEWLINE> <INDENT> if m < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> rst = rec ( i + 1 , m - A [ i ] ) or rec ( i + 1 , m ) <NEWLINE> return rst <NEWLINE> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if m < min_A or max_A < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif rec ( 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> def solve ( N , A ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> total = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> total -= A [ i ] <NEWLINE> ans += A [ i ] * total <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = solve ( N , A ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( len ( h ) - k + 1 ) : <NEWLINE> <INDENT> ma = h [ i + k - 1 ] <NEWLINE> mi = h [ i ] <NEWLINE> ans = min ( ans , ma - mi ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> n = 0 <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> X , Y , A , B , C = MAP ( ) <NEWLINE> p = deque ( sorted ( LIST ( ) , reverse = True ) + [ 0 ] ) <NEWLINE> q = deque ( sorted ( LIST ( ) , reverse = True ) + [ 0 ] ) <NEWLINE> r = deque ( sorted ( LIST ( ) , reverse = True ) + [ 0 ] ) <NEWLINE> <NL> x = 0 <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> ans = 0 <NEWLINE> while x + y + z < X + Y : <NEWLINE> <INDENT> compare = ( p [ 0 ] , q [ 0 ] , r [ 0 ] ) <NEWLINE> <NL> if p [ 0 ] == max ( compare ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> ans += p . popleft ( ) <NEWLINE> if x == X : <NEWLINE> <INDENT> p = [ 0 ] <NEWLINE> <DEDENT> <DEDENT> elif q [ 0 ] == max ( compare ) : <NEWLINE> <INDENT> y += 1 <NEWLINE> ans += q . popleft ( ) <NEWLINE> if y == Y : <NEWLINE> <INDENT> q = [ 0 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> z += 1 <NEWLINE> ans += r . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> count_h = [ 0 for i in range ( h ) ] <NEWLINE> count_w = [ 0 for i in range ( w ) ] <NEWLINE> <NL> for j , k in l : <NEWLINE> <INDENT> count_h [ j - 1 ] += 1 <NEWLINE> count_w [ k - 1 ] += 1 <NEWLINE> <NL> <DEDENT> h_max = max ( count_h ) <NEWLINE> w_max = max ( count_w ) <NEWLINE> h_kouho = [ ] <NEWLINE> ko_hh = [ 0 for _ in range ( h ) ] <NEWLINE> ko_ww = [ 0 for _ in range ( w ) ] <NEWLINE> w_kouho = [ ] <NEWLINE> ans = h_max + w_max - 1 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if count_h [ i ] == h_max : <NEWLINE> <INDENT> h_kouho . append ( i ) <NEWLINE> ko_hh [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if count_w [ j ] == w_max : <NEWLINE> <INDENT> w_kouho . append ( j ) <NEWLINE> ko_ww [ j ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans_kouho = len ( h_kouho ) * len ( w_kouho ) <NEWLINE> su = 0 <NEWLINE> for j , k in l : <NEWLINE> <INDENT> if ko_hh [ j - 1 ] == 1 and ko_ww [ k - 1 ] == 1 : <NEWLINE> <INDENT> su += 1 <NEWLINE> <DEDENT> <DEDENT> if su == ans_kouho : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> m , n = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> print ( pow ( m , n , 1000000007 ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> import bisect <NEWLINE> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> negA = [ ] <NEWLINE> idx_negA = [ ] <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> negA . append ( i - a ) <NEWLINE> idx_negA . append ( i ) <NEWLINE> <NL> <DEDENT> cnt_negA = Counter ( negA ) <NEWLINE> negA_keys = sorted ( cnt_negA . keys ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + A [ i ] in cnt_negA : <NEWLINE> <INDENT> ans += cnt_negA [ i + A [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Ss = input ( ) . split ( ) <NEWLINE> res = 1 <NEWLINE> for t in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( N % t != 0 ) : continue <NEWLINE> f = False <NEWLINE> for i in range ( N - t ) : <NEWLINE> <INDENT> if ( Ss [ i ] == Ss [ i + t ] ) : continue <NEWLINE> f = True <NEWLINE> break <NEWLINE> <DEDENT> if ( f ) : continue <NEWLINE> res = N // t <NEWLINE> break <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x1 , y1 = map ( int , input ( ) . split ( ) ) <NEWLINE> x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if x1 + y1 > x2 + y2 : <NEWLINE> <INDENT> max1 = x1 + y1 <NEWLINE> min1 = x2 + y2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max1 = x2 + y2 <NEWLINE> min1 = x1 + y1 <NEWLINE> <NL> <DEDENT> if x1 - y1 > x2 - y2 : <NEWLINE> <INDENT> max2 = x1 - y1 <NEWLINE> min2 = x2 - y2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max2 = x2 - y2 <NEWLINE> min2 = x1 - y1 <NEWLINE> <NL> <DEDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x + y > max1 : <NEWLINE> <INDENT> max1 = x + y <NEWLINE> <DEDENT> elif x + y < min1 : <NEWLINE> <INDENT> min1 = x + y <NEWLINE> <NL> <DEDENT> if x - y > max2 : <NEWLINE> <INDENT> max2 = x - y <NEWLINE> <DEDENT> elif x - y < min2 : <NEWLINE> <INDENT> min2 = x - y <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = print ( max ( ( max1 - min1 ) , ( max2 - min2 ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> crawler = 7 <NEWLINE> found = False <NEWLINE> i = 1 <NEWLINE> <NL> if ( K % 2 == 0 ) or ( K % 5 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ 0 for i in range ( K + 1 ) ] <NEWLINE> a [ 0 ] = 7 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 1 ] * 10 + 7 ) % K <NEWLINE> <DEDENT> a [ 0 ] = a [ 0 ] % K <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( a . index ( i ) + 1 ) <NEWLINE> found = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not found : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> print ( * solve ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for b in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> return a , b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> BOARD_SIZE_W = 8 <NEWLINE> BOARD_SIZE_H = 8 <NEWLINE> <NL> <NL> def set_queen ( board , queen_point ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return filter ( create_queen_filter ( queen_point ) , board ) <NEWLINE> <NL> <NL> <DEDENT> def create_queen_filter ( queen_point ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def queen_filter ( new_point ) : <NEWLINE> <INDENT> return new_point [ 1 ] != queen_point [ 1 ] and new_point [ 0 ] != queen_point [ 0 ] and new_point [ 0 ] != new_point [ 1 ] + queen_point [ 0 ] - queen_point [ 1 ] and new_point [ 0 ] != - new_point [ 1 ] + queen_point [ 0 ] + queen_point [ 1 ] <NEWLINE> <DEDENT> return queen_filter <NEWLINE> <NL> <NL> <DEDENT> def get_board_string ( queen_points ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> queen_points_set = set ( list ( map ( lambda point : <STRING> . format ( point [ 1 ] , point [ 0 ] ) , queen_points ) ) ) <NEWLINE> board_string_lines = [ ] <NEWLINE> for y in range ( BOARD_SIZE_H ) : <NEWLINE> <INDENT> line = <STRING> <NEWLINE> for x in range ( BOARD_SIZE_W ) : <NEWLINE> <INDENT> if <STRING> . format ( x , y ) in queen_points_set : <NEWLINE> <INDENT> line += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> line += <STRING> <NEWLINE> <DEDENT> <DEDENT> board_string_lines . append ( line ) <NEWLINE> <DEDENT> return <STRING> . join ( board_string_lines ) <NEWLINE> <NL> <NL> <DEDENT> def get_all_queen_points ( board , queen_points ) : <NEWLINE> <INDENT> if len ( queen_points ) >= 8 : <NEWLINE> <INDENT> return queen_points <NEWLINE> <DEDENT> elif not board : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> for empty_point in board : <NEWLINE> <INDENT> new_queen_points = [ empty_point ] <NEWLINE> new_queen_points . extend ( queen_points ) <NEWLINE> new_queen_points = get_all_queen_points ( list ( set_queen ( board , empty_point ) ) , new_queen_points ) <NEWLINE> if new_queen_points : <NEWLINE> <INDENT> return get_all_queen_points ( list ( set_queen ( board , empty_point ) ) , new_queen_points ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> inputStr = sys . stdin . read ( ) <NEWLINE> lines = inputStr . split ( <STRING> ) <NEWLINE> lines = list ( filter ( lambda line : line , lines ) ) <NEWLINE> if len ( lines ) <= 1 : <NEWLINE> <INDENT> lines = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines = lines [ 1 : ] <NEWLINE> <DEDENT> queen_points = list ( map ( lambda line : list ( map ( int , line . split ( <STRING> ) ) ) , lines ) ) <NEWLINE> board = [ [ i % BOARD_SIZE_W , i // BOARD_SIZE_H ] for i in range ( BOARD_SIZE_H * BOARD_SIZE_W ) ] <NEWLINE> for queen_point in queen_points : <NEWLINE> <INDENT> board = list ( set_queen ( board , queen_point ) ) <NEWLINE> <DEDENT> sys . stdout . write ( get_board_string ( get_all_queen_points ( board , queen_points ) ) + <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( k + 1 ) : <NEWLINE> <INDENT> z = s - ( x + y ) <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <COMMENT> <NL> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> from heapq import heapify , heappop , heappush , heappushpop <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> already = [ False ] * N <NEWLINE> step = 0 <NEWLINE> now = 1 <NEWLINE> count = 0 <NEWLINE> while ( already [ now - 1 ] != True ) : <NEWLINE> <INDENT> already [ now - 1 ] = True <NEWLINE> now = A [ now - 1 ] <NEWLINE> count += 1 <NEWLINE> if count == K : <NEWLINE> <INDENT> print ( now ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> loop = 0 <NEWLINE> cycle = 0 <NEWLINE> if ( now == 1 ) : <NEWLINE> <INDENT> step = 0 <NEWLINE> cycle = count <NEWLINE> loop = K % cycle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step = 0 <NEWLINE> temp = 1 <NEWLINE> while ( temp != now ) : <NEWLINE> <INDENT> temp = A [ temp - 1 ] <NEWLINE> step += 1 <NEWLINE> <DEDENT> cycle = count - step <NEWLINE> loop = ( K - step ) % cycle <NEWLINE> <NL> <DEDENT> temp = 1 <NEWLINE> for i in range ( step + loop ) : <NEWLINE> <INDENT> temp = A [ temp - 1 ] <NEWLINE> <DEDENT> print ( temp ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> no_good = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( t [ 0 ] ) <NEWLINE> B . append ( t [ 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if H [ A [ i ] - 1 ] > H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> no_good . append ( B [ i ] ) <NEWLINE> <DEDENT> elif H [ A [ i ] - 1 ] < H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> no_good . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> no_good . append ( A [ i ] ) <NEWLINE> no_good . append ( B [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = N - len ( set ( no_good ) ) <NEWLINE> print ( result ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> price , exp , rst = [ ] , [ [ ] for i in range ( N ) ] , - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> price . append ( ls [ 0 ] ) <NEWLINE> exp [ i ] = ls [ 1 : ] <NEWLINE> <DEDENT> for i in range ( 1 << N ) : <NEWLINE> <INDENT> price_combi , exp_combi , exp_sum , cnt_ls = [ ] , [ ] , [ 0 ] * M , [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> price_combi . append ( price [ j ] ) <NEWLINE> exp_combi . append ( exp [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for s in exp_combi : <NEWLINE> <INDENT> for t in range ( M ) : <NEWLINE> <INDENT> exp_sum [ t ] += s [ t ] <NEWLINE> <DEDENT> <DEDENT> [ cnt_ls . append ( x ) for x in exp_sum if x >= X ] <NEWLINE> if len ( cnt_ls ) == M : <NEWLINE> <INDENT> if rst == - 1 : <NEWLINE> <INDENT> rst = sum ( price_combi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rst = min ( rst , sum ( price_combi ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( rst ) <NEWLINE>
from math import gcd <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> import decimal <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import sys <NEWLINE> import random <NEWLINE> <COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ - 1 for i in range ( self . n ) ] <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> p = self . find ( x ) <NEWLINE> q = self . find ( y ) <NEWLINE> if p == q : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if p > q : <NEWLINE> <INDENT> p , q = q , p <NEWLINE> <DEDENT> self . par [ p ] += self . par [ q ] <NEWLINE> self . par [ q ] = p <NEWLINE> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . par [ self . find ( x ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def prime_numbers ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> prime_numbers = [ i for i in range ( x ) ] <NEWLINE> prime_numbers [ 1 ] = 0 <NEWLINE> for prime_number in prime_numbers : <NEWLINE> <INDENT> if prime_number > math . sqrt ( x ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if prime_number == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for composite_number in range ( 2 * prime_number , x , prime_number ) : <NEWLINE> <INDENT> prime_numbers [ composite_number ] = 0 <NEWLINE> <DEDENT> <DEDENT> return [ prime_number for prime_number in prime_numbers if prime_number != 0 ] <NEWLINE> <DEDENT> def is_prime ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if x == 2 or x == 3 or x == 5 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x % 2 == 0 or x % 3 == 0 or x % 5 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> prime_number = 7 <NEWLINE> difference = 4 <NEWLINE> while prime_number <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % prime_number == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> prime_number += difference <NEWLINE> difference = 6 - difference <NEWLINE> <DEDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> def prime_factorize ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f ** 2 <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> res . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> res . append ( n ) <NEWLINE> <DEDENT> return res <NEWLINE> <COMMENT> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> class nCr ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . fa = [ 1 ] * ( self . n + 1 ) <NEWLINE> self . fi = [ 1 ] * ( self . n + 1 ) <NEWLINE> for i in range ( 1 , self . n + 1 ) : <NEWLINE> <INDENT> self . fa [ i ] = self . fa [ i - 1 ] * i % mod <NEWLINE> self . fi [ i ] = pow ( self . fa [ i ] , mod - 2 , mod ) <NEWLINE> <DEDENT> <DEDENT> def comb ( self , n , r ) : <NEWLINE> <INDENT> if n < r : return 0 <NEWLINE> if n < 0 or r < 0 : return 0 <NEWLINE> return self . fa [ n ] * self . fi [ r ] % mod * self . fi [ n - r ] % mod <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def extgcd ( a , b , d = 0 ) : <NEWLINE> <INDENT> g = a <NEWLINE> if b == 0 : <NEWLINE> <INDENT> x , y = 1 , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y , g = extgcd ( b , a % b ) <NEWLINE> x , y = y , x - a // b * y <NEWLINE> <DEDENT> return x , y , g <NEWLINE> <COMMENT> <NL> <DEDENT> class BinaryIndexedTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . BIT = [ 0 ] * ( self . n + 1 ) <NEWLINE> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . n : <NEWLINE> <INDENT> self . BIT [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <DEDENT> <DEDENT> def query ( self , i ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> res += self . BIT [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return res <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> class AssociativeArray ( ) : <NEWLINE> <INDENT> def __init__ ( self , q ) : <NEWLINE> <INDENT> self . dic = dict ( ) <NEWLINE> self . q = q <NEWLINE> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> for i in range ( self . q ) : <NEWLINE> <INDENT> Query = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if Query [ 0 ] == 0 : <NEWLINE> <INDENT> x , y , z = Query <NEWLINE> self . dic [ y ] = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = Query <NEWLINE> if y in self . dic : <NEWLINE> <INDENT> print ( self . dic [ y ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def floor_sum ( n , m , a , b ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> if a >= m : <NEWLINE> <INDENT> res += ( n - 1 ) * n * ( a // m ) // 2 <NEWLINE> a %= m <NEWLINE> <DEDENT> if b >= m : <NEWLINE> <INDENT> res += n * ( b // m ) <NEWLINE> b %= m <NEWLINE> <DEDENT> y_max = ( a * n + b ) // m <NEWLINE> x_max = y_max * m - b <NEWLINE> if y_max == 0 : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> res += y_max * ( n + ( - x_max // a ) ) <NEWLINE> res += floor_sum ( y_max , a , m , ( a - x_max % a ) % a ) <NEWLINE> return res <NEWLINE> <COMMENT> <NL> <DEDENT> def z_algorithm ( s ) : <NEWLINE> <INDENT> str_len = len ( s ) <NEWLINE> res = [ 0 ] * str_len <NEWLINE> res [ str_len - 1 ] = str_len <NEWLINE> i , j = 1 , 0 <NEWLINE> while i < str_len : <NEWLINE> <INDENT> while i + j < str_len and s [ i + j ] == s [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> res [ i ] = j <NEWLINE> if j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> k = 1 <NEWLINE> while i + k < str_len and j > res [ k ] + k : <NEWLINE> <INDENT> res [ i + k ] = res [ k ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> i += k <NEWLINE> j -= k <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> class Manacher ( ) : <NEWLINE> <INDENT> def __init__ ( self , s ) : <NEWLINE> <INDENT> self . s = s <NEWLINE> <DEDENT> def coustruct ( self ) : <NEWLINE> <INDENT> i , j = 0 , 0 <NEWLINE> s_len = len ( self . s ) <NEWLINE> res = [ 0 ] * s_len <NEWLINE> while i < s_len : <NEWLINE> <INDENT> while i - j >= 0 and i + j < s_len and self . s [ i - j ] == self . s [ i + j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> res [ i ] = j <NEWLINE> k = 1 <NEWLINE> while i - k >= 0 and k + res [ i - k ] < j : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> i += k <NEWLINE> j -= k <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def mod_sqrt ( a , p ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if p == 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> k = ( p - 1 ) // 2 <NEWLINE> if pow ( a , k , p ) != 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> n = random . randint ( 2 , p - 1 ) <NEWLINE> r = ( n ** 2 - a ) % p <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> if pow ( r , k , p ) == p - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> k += 1 <NEWLINE> w , x , y , z = n , 1 , 1 , 0 <NEWLINE> while k : <NEWLINE> <INDENT> if k % 2 : <NEWLINE> <INDENT> y , z = w * y + r * x * z , x * y + w * z <NEWLINE> <DEDENT> w , x = w * w + r * x * x , 2 * w * x <NEWLINE> w %= p <NEWLINE> x %= p <NEWLINE> y %= p <NEWLINE> z %= p <NEWLINE> k >>= 1 <NEWLINE> <DEDENT> return y <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> zeros = 0 <NEWLINE> count = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a , b ) == ( 0 , 0 ) : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> continue <NEWLINE> <DEDENT> g = gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> cnt = 0 <NEWLINE> while a < 0 or b <= 0 : <NEWLINE> <INDENT> a , b = - 1 * b , a <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if not ( a , b ) in count : <NEWLINE> <INDENT> count [ ( a , b ) ] = [ 0 , 0 ] <NEWLINE> <DEDENT> count [ ( a , b ) ] [ cnt % 2 ] += 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in count : <NEWLINE> <INDENT> a , b = count [ i ] <NEWLINE> ans *= ( pow ( 2 , a , mod ) + pow ( 2 , b , mod ) - 1 ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ( ans + zeros - 1 ) % mod ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = [ list ( input ( ) ) for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n - m + 1 ) : <NEWLINE> <INDENT> for j in range ( n - m + 1 ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> for l in range ( m ) : <NEWLINE> <INDENT> if a [ i + k ] [ j + l ] != b [ k ] [ l ] : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> if len ( make_divisors ( i ) ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import functools <NEWLINE> import operator <NEWLINE> prod = functools . partial ( functools . reduce , operator . mul ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> def cal ( n , li ) : <NEWLINE> <INDENT> lis = [ True ] * ( n + 1 ) <NEWLINE> for item in li : <NEWLINE> <INDENT> if lis [ item ] : <NEWLINE> <INDENT> for i in range ( item * 2 , n + 1 , item ) : <NEWLINE> <INDENT> lis [ i ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return lis <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> l = cal ( a [ - 1 ] , a ) <NEWLINE> ll = Counter ( a ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ll [ a [ i ] ] == 1 : <NEWLINE> <INDENT> if l [ a [ i ] ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from math import sqrt <NEWLINE> <COMMENT> <NL> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( <STRING> ) <NEWLINE> <NL> a , b , c = [ ( float ( tmp [ i ] ) , float ( tmp [ i + 1 ] ) ) for i in range ( 0 , len ( tmp ) , 2 ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A_tmp1 = 1 / ( a [ 0 ] * b [ 1 ] + a [ 1 ] * c [ 0 ] + b [ 0 ] * c [ 1 ] - b [ 1 ] * c [ 0 ] - a [ 1 ] * b [ 0 ] - a [ 0 ] * c [ 1 ] ) <NEWLINE> A_tmp2 = [ [ b [ 1 ] - c [ 1 ] , - ( a [ 1 ] - c [ 1 ] ) , a [ 1 ] - b [ 1 ] ] , <NEWLINE> <INDENT> [ - ( b [ 0 ] - c [ 0 ] ) , ( a [ 0 ] - c [ 0 ] ) , - ( a [ 0 ] - b [ 0 ] ) ] , <NEWLINE> [ b [ 0 ] * c [ 1 ] - b [ 1 ] * c [ 0 ] , - ( a [ 0 ] * c [ 1 ] - a [ 1 ] * c [ 0 ] ) , a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] ] ] <NEWLINE> <DEDENT> A = [ list ( map ( lambda x : A_tmp1 * x , A_tmp2 [ i ] ) ) for i in range ( 3 ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> B = [ [ - ( a [ 0 ] ** 2 + a [ 1 ] ** 2 ) ] , <NEWLINE> <INDENT> [ - ( b [ 0 ] ** 2 + b [ 1 ] ** 2 ) ] , <NEWLINE> [ - ( c [ 0 ] ** 2 + c [ 1 ] ** 2 ) ] ] <NEWLINE> <NL> <NL> <DEDENT> tmp = [ sum ( [ A [ i ] [ j ] * B [ j ] [ 0 ] for j in range ( 3 ) ] ) for i in range ( 3 ) ] <NEWLINE> <COMMENT> <NL> <NL> x = - tmp [ 0 ] / 2 <NEWLINE> y = - tmp [ 1 ] / 2 <NEWLINE> r = sqrt ( ( tmp [ 0 ] ** 2 + tmp [ 1 ] ** 2 - 4 * tmp [ 2 ] ) / 4 ) <NEWLINE> <NL> print ( <STRING> . format ( x , y , r ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> def f ( k ) : <NEWLINE> <INDENT> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> val = 7 <NEWLINE> cnt = 1 <NEWLINE> while cnt < 10 ** 6 : <NEWLINE> <INDENT> val %= k <NEWLINE> if val % k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> val = val * 10 + 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> print ( f ( k ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a - k >= 0 : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a + b ) > k : <NEWLINE> <INDENT> print ( 0 , b - ( k - a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = set ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> m = max ( l ) <NEWLINE> mc = l . count ( m ) <NEWLINE> tin = set ( l ) <NEWLINE> if len ( tin ) == 1 : <NEWLINE> <INDENT> s = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = sorted ( tin ) [ - 2 ] <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> if i == m : <NEWLINE> <INDENT> if mc > 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_ = 10 ** 6 + 1 <NEWLINE> b = [ True ] * ( max_ + 1 ) <NEWLINE> data . sort ( ) <NEWLINE> c = Counter ( data ) <NEWLINE> <NL> ans = 0 <NEWLINE> for d in data : <NEWLINE> <INDENT> if b [ d ] : <NEWLINE> <INDENT> for j in range ( d , max_ , d ) : <NEWLINE> <INDENT> b [ j ] = False <NEWLINE> <COMMENT> <NL> <DEDENT> if c [ d ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if a * b < n : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> key = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> key . insert ( 0 , 0 ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> k = i + 1 <NEWLINE> lk = 2 * k <NEWLINE> rk = 2 * k + 1 <NEWLINE> pk = int ( 0.5 * k ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( k , key [ k ] , key [ lk ] , key [ rk ] ) ) <NEWLINE> <DEDENT> elif lk > h : <NEWLINE> <INDENT> print ( <STRING> . format ( k , key [ k ] , key [ pk ] ) ) <NEWLINE> <DEDENT> elif rk > h : <NEWLINE> <INDENT> print ( <STRING> . format ( k , key [ k ] , key [ pk ] , key [ lk ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( k , key [ k ] , key [ pk ] , key [ lk ] , key [ rk ] ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S = <STRING> + S + <STRING> <NEWLINE> ans = 0 <NEWLINE> E = 0 <NEWLINE> W = S . count ( <STRING> ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> E += 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> W -= 1 <NEWLINE> <DEDENT> tmp = E + W <NEWLINE> if tmp > ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> ans = N - 1 - ans <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ball = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> ans = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> p , q = ball [ i ] [ 0 ] - ball [ j ] [ 0 ] , ball [ i ] [ 1 ] - ball [ j ] [ 1 ] <NEWLINE> par = [ - 1 ] * n <NEWLINE> node = [ [ ] for i in range ( n ) ] <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> for t in range ( n ) : <NEWLINE> <INDENT> x , y = ball [ s ] [ 0 ] - ball [ t ] [ 0 ] , ball [ s ] [ 1 ] - ball [ t ] [ 1 ] <NEWLINE> if x == p and y == q : <NEWLINE> <INDENT> node [ s ] . append ( t ) <NEWLINE> node [ t ] . append ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> already = [ False ] * n <NEWLINE> count = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if already [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count += 1 <NEWLINE> already [ k ] = True <NEWLINE> not_yet = deque ( [ k ] ) <NEWLINE> while not_yet : <NEWLINE> <INDENT> key = not_yet . pop ( ) <NEWLINE> for v in node [ key ] : <NEWLINE> <INDENT> if already [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> already [ v ] = True <NEWLINE> not_yet . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans > count : <NEWLINE> <INDENT> ans = count <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> <NL> x , y , X , Y = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( math . sqrt ( ( x - X ) ** 2 + abs ( y - Y ) ** 2 ) ) <NEWLINE>
def f ( n ) : <NEWLINE> <INDENT> a , b = 1 , 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = a + b , a <NEWLINE> <DEDENT> return b <NEWLINE> <DEDENT> print ( f ( int ( input ( ) ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> cnt = Counter ( S ) <NEWLINE> <NL> ans = cnt [ <STRING> ] * cnt [ <STRING> ] * cnt [ <STRING> ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if ( S [ i ] == S [ j ] ) or ( S [ j ] == S [ k ] ) or ( S [ k ] == S [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> tower = defaultdict ( lambda : defaultdict ( list ) ) <NEWLINE> for x in range ( 1 , 5 ) : <NEWLINE> <INDENT> for y in range ( 1 , 4 ) : <NEWLINE> <INDENT> for z in range ( 1 , 11 ) : <NEWLINE> <INDENT> tower [ x ] [ y ] . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = int ( input ( ) ) <NEWLINE> <NL> for x in range ( count ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if v > 0 : <NEWLINE> <INDENT> tower [ b ] [ f ] [ r - 1 ] += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tower [ b ] [ f ] [ r - 1 ] -= - v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for key , value in tower . items ( ) : <NEWLINE> <INDENT> for layer , value in value . items ( ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , value ) ) ) <NEWLINE> <DEDENT> if key != 4 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> def bs ( A , n ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = len ( A ) <NEWLINE> while l < r : <NEWLINE> <INDENT> mid = int ( ( l + r ) / 2 ) <NEWLINE> if A [ mid ] == n : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n < A [ mid ] : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> S = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> T = int ( input ( ) ) <NEWLINE> B = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> x = bs ( A , B [ i ] ) <NEWLINE> if x != ( - 1 ) : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
data = input ( ) . split ( ) <NEWLINE> N = int ( data [ 0 ] ) <NEWLINE> K = int ( data [ 1 ] ) <NEWLINE> S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> s [ K - 1 ] = S [ K - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
memo = [ 1 ] * ( 10 ** 5 + 1 ) <NEWLINE> memo [ 0 ] = 0 <NEWLINE> memo [ 1 ] = 0 <NEWLINE> for i in range ( 2 , len ( memo ) ) : <NEWLINE> <INDENT> if memo [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i * 2 , len ( memo ) , i ) : <NEWLINE> <INDENT> memo [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> memo_like2017 = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 3 , len ( memo ) , 2 ) : <NEWLINE> <INDENT> if memo [ i ] == 1 and memo [ ( i + 1 ) // 2 ] == 1 : <NEWLINE> <INDENT> memo_like2017 [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> sum_memo = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( 1 , len ( memo ) ) : <NEWLINE> <INDENT> sum_memo [ i ] = sum_memo [ i - 1 ] + memo_like2017 [ i ] <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum_memo [ r ] - sum_memo [ l - 1 ] ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ [ ] for i in range ( n ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ a - 1 ] . append ( b - 1 ) <NEWLINE> lst [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ s - 1 ] += t <NEWLINE> <NL> <DEDENT> Q = [ 0 ] <NEWLINE> <NL> flag = [ True ] + [ False ] * ( n - 1 ) <NEWLINE> <NL> <NL> while Q : <NEWLINE> <INDENT> v = Q . pop ( ) <NEWLINE> flag [ v ] = True <NEWLINE> for i in lst [ v ] : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag [ i ] = True <NEWLINE> ans [ i ] += ans [ v ] <NEWLINE> Q . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( i ) for i in ans ] ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if x == i ** 5 - j ** 5 : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> t = len ( s ) <NEWLINE> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> b = set ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <DEDENT> <DEDENT> d = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for ri in r : <NEWLINE> <INDENT> for gi in g : <NEWLINE> <INDENT> rg = gi - ri <NEWLINE> if rg + gi in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> if ri - rg in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> if ( gi + ri ) / 2 in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
def solve ( way , height , n ) : <NEWLINE> <INDENT> ss = [ ] <NEWLINE> for a , b in way : <NEWLINE> <INDENT> if height [ a - 1 ] <= height [ b - 1 ] : <NEWLINE> <INDENT> ss . append ( a ) <NEWLINE> <DEDENT> if height [ a - 1 ] >= height [ b - 1 ] : <NEWLINE> <INDENT> ss . append ( b ) <NEWLINE> <DEDENT> <DEDENT> return n - len ( set ( ss ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> height = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> way = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> print ( solve ( way , height , n ) ) <NEWLINE> <DEDENT>
cnt = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( cnt , a ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> B = [ ] <NEWLINE> W = [ ] <NEWLINE> i = 0 <NEWLINE> fin = None <NEWLINE> while i < N : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> B . append ( 1 ) <NEWLINE> fin = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> i += 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> fin = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> B . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> W . append ( 1 ) <NEWLINE> fin = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> i += 1 <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> fin = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> W . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = sum ( B ) <NEWLINE> L = len ( B ) + len ( W ) <NEWLINE> B = B [ : : - 1 ] <NEWLINE> W = W [ : : - 1 ] <NEWLINE> now = ans <NEWLINE> if fin : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> now -= B [ i // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += W [ i // 2 ] <NEWLINE> <DEDENT> ans = min ( ans , now ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( L ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> now -= B [ i // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now += W [ i // 2 ] <NEWLINE> <DEDENT> ans = min ( ans , now ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> L = 10 ** 18 <NEWLINE> <NL> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > L : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> sevens_mod = 7 % K <NEWLINE> flag = False <NEWLINE> ans = - 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if sevens_mod == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> sevens_mod = ( sevens_mod * 10 + 7 ) % K <NEWLINE> <DEDENT> print ( ans if flag else - 1 ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> countS = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> countS [ i + 1 ] = countS [ i ] <NEWLINE> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> countS [ i + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( countS [ r - 1 ] - countS [ l - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> step = [ ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] < h [ i + 1 ] : <NEWLINE> <INDENT> step . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step . append ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ i for i , x in enumerate ( step ) if x == 0 ] <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> d = a [ 0 ] <NEWLINE> ans . append ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a [ i ] - a [ i - 1 ] <NEWLINE> ans . append ( b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if not a : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ( n - 1 ) - a [ - 1 ] ) <NEWLINE> print ( max ( ans ) - 1 ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) + 1 <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( 1 , K ) : <NEWLINE> <INDENT> for k in range ( 1 , K ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> maks = 10 ** 18 <NEWLINE> mnozenje = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> mnozenje *= i <NEWLINE> <NL> if mnozenje > maks : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mnozenje ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = 1 <NEWLINE> B = [ 0 ] * N <NEWLINE> state = 0 <NEWLINE> for i in range ( 2 * N + 1 ) : <NEWLINE> <INDENT> if i == K : <NEWLINE> <INDENT> state = 1 <NEWLINE> break <NEWLINE> <DEDENT> B [ n - 1 ] = i + 1 <NEWLINE> n = A [ n - 1 ] <NEWLINE> if B [ n - 1 ] != 0 : <NEWLINE> <INDENT> t = i + 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if state : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = t - B [ n - 1 ] <NEWLINE> s = ( K + 1 - t ) % c <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> n = A [ n - 1 ] <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> count = 0 <NEWLINE> R_1 = [ - 1 for i in range ( 26 ) ] <NEWLINE> R_2 = [ - 1 for i in range ( 26 ) ] <NEWLINE> <NL> answer = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> r1 = ord ( S [ i ] ) - 97 <NEWLINE> r2 = ord ( T [ i ] ) - 97 <NEWLINE> if R_1 [ r1 ] >= 0 : <NEWLINE> <INDENT> if r2 != R_1 [ r1 ] : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if R_2 [ r2 ] >= 0 : <NEWLINE> <INDENT> if r1 != R_2 [ r2 ] : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if R_1 [ r1 ] < 0 : <NEWLINE> <INDENT> R_1 [ r1 ] = r2 <NEWLINE> <DEDENT> if R_2 [ r2 ] < 0 : <NEWLINE> <INDENT> R_2 [ r2 ] = r1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
<COMMENT> <NL> <NL> l = input ( ) <NEWLINE> S1 , S2 = [ ] , [ ] <NEWLINE> <NL> sum = 0 <NEWLINE> n = len ( l ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> S1 . append ( i ) <NEWLINE> <DEDENT> elif l [ i ] == <STRING> and S1 : <NEWLINE> <INDENT> j = S1 . pop ( ) <NEWLINE> a = i - j <NEWLINE> sum += a <NEWLINE> <NL> while S2 and S2 [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> a += S2 . pop ( ) [ 1 ] <NEWLINE> <DEDENT> S2 . append ( [ j , a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> print ( len ( S2 ) , * ( a for j , a in S2 ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def judge ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 2 <NEWLINE> while i <= math . sqrt ( n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> count = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if judge ( int ( input ( ) ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += ( ( n // i ) + 1 ) * ( n // i ) * i // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> ab = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> for a , b in ab : <NEWLINE> <INDENT> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = - 1 <NEWLINE> for i in uf . parents : <NEWLINE> <INDENT> ans = min ( i , ans ) <NEWLINE> <NL> <DEDENT> print ( - ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> idx = 0 <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if ( A [ idx ] < A [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> idx += 1 <NEWLINE> <DEDENT>
h = [ [ [ 0 for x in range ( 0 , 10 ) ] for y in range ( 0 , 3 ) ] for z in range ( 0 , 4 ) ] <NEWLINE> for i in range ( 0 , int ( input ( ) ) ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> h [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> c = 1 <NEWLINE> for x in h : <NEWLINE> <INDENT> for y in x : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , y ) ) ) <NEWLINE> <DEDENT> if c < 4 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT>
class NullNode ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . id = None <NEWLINE> <NL> <DEDENT> <DEDENT> null_node = NullNode ( ) <NEWLINE> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> global null_node <NEWLINE> self . id = id <NEWLINE> self . parent = null_node <NEWLINE> self . left = null_node <NEWLINE> self . right = null_node <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( node , out_list = [ ] ) : <NEWLINE> <INDENT> if node . id is not None : <NEWLINE> <INDENT> out_list . append ( str ( node . id ) ) <NEWLINE> out_list = preorder ( node . left , out_list ) <NEWLINE> out_list = preorder ( node . right , out_list ) <NEWLINE> <DEDENT> return out_list <NEWLINE> <NL> <DEDENT> def inorder ( node , out_list = [ ] ) : <NEWLINE> <INDENT> if node . id is not None : <NEWLINE> <INDENT> out_list = inorder ( node . left , out_list ) <NEWLINE> out_list . append ( str ( node . id ) ) <NEWLINE> out_list = inorder ( node . right , out_list ) <NEWLINE> <DEDENT> return out_list <NEWLINE> <NL> <DEDENT> def insert ( node , root_node ) : <NEWLINE> <INDENT> temp_node_parent = root_node . parent <NEWLINE> temp_node = root_node <NEWLINE> <NL> while temp_node . id is not None : <NEWLINE> <INDENT> temp_node_parent = temp_node <NEWLINE> if node . id < temp_node . id : <NEWLINE> <INDENT> temp_node = temp_node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp_node = temp_node . right <NEWLINE> <NL> <DEDENT> <DEDENT> node . parent = temp_node_parent <NEWLINE> if node . id < temp_node_parent . id : <NEWLINE> <INDENT> temp_node_parent . left = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp_node_parent . right = node <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( id , root_node ) : <NEWLINE> <INDENT> node = root_node <NEWLINE> while node . id is not None : <NEWLINE> <INDENT> if id < node . id : <NEWLINE> <INDENT> node = node . left <NEWLINE> <DEDENT> elif id > node . id : <NEWLINE> <INDENT> node = node . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete ( id , root_node ) : <NEWLINE> <COMMENT> <NL> <INDENT> global null_node <NEWLINE> type = <STRING> <NEWLINE> node = root_node <NEWLINE> node_parent = null_node <NEWLINE> while node . id != id : <NEWLINE> <INDENT> node_parent = node <NEWLINE> if id < node . id : <NEWLINE> <INDENT> node = node . left <NEWLINE> type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = node . right <NEWLINE> type = <STRING> <NEWLINE> <DEDENT> <DEDENT> if node . right is not None : <NEWLINE> <INDENT> node . right . parent = node_parent <NEWLINE> <DEDENT> elif node . left is not None : <NEWLINE> <INDENT> node . left . parent = node_parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . parent = null_node <NEWLINE> <NL> <DEDENT> if type == <STRING> : <NEWLINE> <INDENT> node_parent . left = null_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node_parent . right = null_node <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> input_lines = sys . stdin . readlines ( ) <NEWLINE> root_node = NullNode ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> input_line = input_lines [ i ] . split ( ) <NEWLINE> command = input_line [ 0 ] <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> id = int ( input_line [ 1 ] ) <NEWLINE> id_node = Node ( id ) <NEWLINE> if root_node . id is None : <NEWLINE> <INDENT> root_node = id_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( id_node , root_node ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> id = int ( input_line [ 1 ] ) <NEWLINE> find ( id , root_node ) <NEWLINE> <NL> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> id = int ( input_line [ 1 ] ) <NEWLINE> delete ( id , root_node ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inorder_list = inorder ( root_node , [ ] ) <NEWLINE> preorder_list = preorder ( root_node , [ ] ) <NEWLINE> out = <STRING> + <STRING> . join ( inorder_list ) <NEWLINE> print ( out ) <NEWLINE> out = <STRING> + <STRING> . join ( preorder_list ) <NEWLINE> print ( out ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sn = input ( ) <NEWLINE> sr = <STRING> . join ( list ( reversed ( sn ) ) ) <NEWLINE> sint = int ( sn , 2 ) <NEWLINE> spop = sn . count ( <STRING> ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> pop = bin ( x ) . count ( <STRING> ) <NEWLINE> x %= pop <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <NL> <NL> <DEDENT> m1 = sint % ( spop + 1 ) <NEWLINE> m2 = 0 if spop <= 1 else sint % ( spop - 1 ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sr [ i ] == <STRING> : <NEWLINE> <INDENT> d = pow ( 2 , i , spop + 1 ) <NEWLINE> m = ( m1 + d ) % ( spop + 1 ) <NEWLINE> a [ i ] = f ( m ) + 1 <NEWLINE> <DEDENT> elif spop != 1 : <NEWLINE> <INDENT> d = pow ( 2 , i , spop - 1 ) <NEWLINE> m = ( m2 - d + spop - 1 ) % ( spop - 1 ) <NEWLINE> a [ i ] = f ( m ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for ans in reversed ( a ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def zeroTrim ( s ) : <NEWLINE> <INDENT> while s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = s [ 1 : ] <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def calc ( N , K ) : <NEWLINE> <INDENT> digit = len ( N ) <NEWLINE> res = 0 <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> if digit > 1 : <NEWLINE> <INDENT> res += ( digit - 1 ) * 9 <NEWLINE> <DEDENT> res += int ( N [ 0 ] ) <NEWLINE> <DEDENT> elif K == 2 : <NEWLINE> <INDENT> if digit <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if digit > 2 : <NEWLINE> <INDENT> res += 9 * 9 * ( digit - 1 ) * ( digit - 2 ) // 2 <NEWLINE> <DEDENT> for i in range ( int ( N [ 0 ] ) - 1 ) : <NEWLINE> <INDENT> res += calc ( <STRING> * ( digit - 1 ) , 1 ) <NEWLINE> <DEDENT> res += calc ( zeroTrim ( N [ 1 : ] ) , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if digit <= 2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if digit > 3 : <NEWLINE> <INDENT> res += 9 * 9 * 9 * ( digit - 1 ) * ( digit - 2 ) * ( digit - 3 ) // 6 <NEWLINE> <NL> <DEDENT> for i in range ( int ( N [ 0 ] ) - 1 ) : <NEWLINE> <INDENT> res += calc ( <STRING> * ( digit - 1 ) , 2 ) <NEWLINE> <DEDENT> res += calc ( zeroTrim ( N [ 1 : ] ) , 2 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> print ( calc ( N , K ) ) <NEWLINE>
from collections import * <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> c = Counter ( S ) <NEWLINE> <NL> ans = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> <NL> for i in range ( 1 , N // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N - i ) : <NEWLINE> <INDENT> if S [ j - i ] != S [ j ] and S [ j ] != S [ j + i ] and S [ j + i ] != S [ j - i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def solve ( S : str ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = len ( S ) <NEWLINE> c = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> c [ i ] = ( c [ i + 1 ] + int ( S [ i ] ) * pow ( 10 , n - 1 - i , 2019 ) ) % 2019 <NEWLINE> <DEDENT> print ( sum ( v * ( v - 1 ) // 2 for v in Counter ( c ) . values ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> S = next ( tokens ) <COMMENT> <NEWLINE> solve ( S ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> s = int ( input ( ) ) <NEWLINE> deq = collections . deque ( ) <NEWLINE> <NL> for i in range ( s ) : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> if n [ 0 ] == <STRING> : <NEWLINE> <INDENT> deq . appendleft ( n [ 1 ] ) <NEWLINE> <DEDENT> elif n [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> deq . remove ( n [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif n [ 0 ] == <STRING> : <NEWLINE> <INDENT> deq . popleft ( ) <NEWLINE> <DEDENT> elif n [ 0 ] == <STRING> : <NEWLINE> <INDENT> deq . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( deq ) ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> str = [ input ( ) for i in range ( n ) ] <NEWLINE> str . sort ( ) <NEWLINE> k = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if ( str [ i ] != str [ i + 1 ] ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = [ 0 for i in range ( 10 ** 7 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> D [ a - 1 ] += 1 <NEWLINE> D [ a ] += 1 <NEWLINE> D [ a + 1 ] += 1 <NEWLINE> <DEDENT> print ( max ( D ) ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> return <NEWLINE> <DEDENT> P = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x not in P : <NEWLINE> <INDENT> print ( x ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> P_not = np . array ( list ( set ( list ( range ( - 1 , 102 ) ) ) - P ) ) <NEWLINE> diff = np . abs ( P_not - x ) <NEWLINE> print ( P_not [ diff . argmin ( ) ] ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter_list = [ 0 ] * N <NEWLINE> for i in a_list : <NEWLINE> <INDENT> counter_list [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> counter_list . sort ( reverse = True ) <NEWLINE> <NL> ans = N - sum ( counter_list [ : K ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( - 118 , 119 ) : <NEWLINE> <INDENT> for j in range ( - 119 , 118 ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 == X and flag == 0 ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> flag += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> h , w = map ( int , readline ( ) . split ( ) ) <NEWLINE> w += 1 <NEWLINE> dp = [ list ( map ( int , readline ( ) . split ( ) ) ) + [ 1 ] for _ in range ( h ) ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> dp [ i ] [ j ] ^= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] : <NEWLINE> <INDENT> dp [ i ] [ j ] += dp [ i - 1 ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> max_s = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if ( stack [ - 1 ] [ 0 ] if stack else 0 ) < dp [ i ] [ j ] : <NEWLINE> <INDENT> stack . append ( ( dp [ i ] [ j ] , j ) ) <NEWLINE> <DEDENT> elif stack and stack [ - 1 ] [ 0 ] > dp [ i ] [ j ] : <NEWLINE> <INDENT> while stack and stack [ - 1 ] [ 0 ] > dp [ i ] [ j ] : <NEWLINE> <INDENT> height , l = stack . pop ( ) <NEWLINE> s = height * ( j - l ) <NEWLINE> if max_s < s : <NEWLINE> <INDENT> max_s = s <NEWLINE> <DEDENT> <DEDENT> if dp [ i ] [ j ] : <NEWLINE> <INDENT> stack . append ( ( dp [ i ] [ j ] , l ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max_s ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( n ) - 1 for n in input ( ) . split ( ) ] <COMMENT> <NEWLINE> v = [ - 1 ] * n <COMMENT> <NEWLINE> <NL> D = [ 0 ] <COMMENT> <NEWLINE> v [ 0 ] = 0 <COMMENT> <NEWLINE> <NL> cur = a [ 0 ] <COMMENT> <NEWLINE> i = 1 <NEWLINE> <NL> while v [ cur ] == - 1 : <NEWLINE> <INDENT> D . append ( cur ) <NEWLINE> v [ cur ] = i <COMMENT> <NEWLINE> if k == i : <COMMENT> <NEWLINE> <INDENT> print ( cur + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> cur = a [ cur ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> k -= v [ cur ] <COMMENT> <NEWLINE> k %= ( i - v [ cur ] ) <COMMENT> <NEWLINE> <NL> print ( D [ v [ cur ] + k ] + 1 ) <COMMENT> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while True : <NEWLINE> <INDENT> e = int ( input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> min_e = e <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if ( e - i ** 3 ) < 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> z = i <NEWLINE> y = math . floor ( math . sqrt ( e - i ** 3 ) ) <NEWLINE> x = e - y ** 2 - z ** 3 <NEWLINE> if ( ( x + y + z ) < min_e ) : <NEWLINE> <INDENT> min_e = x + y + z <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_e ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ 1 ] * N <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans [ i ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 1 ] * a <NEWLINE> <NL> <DEDENT> if ans [ i ] > 10 ** 18 : <NEWLINE> <INDENT> ans [ - 1 ] = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ar = { i : 0 for i in range ( 1 , 10 ** 5 + 1 ) } <NEWLINE> s = sum ( r ) <NEWLINE> for a in r : <NEWLINE> <INDENT> ar [ a ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> s += ( y - x ) * ar [ x ] <NEWLINE> ar [ y ] += ar [ x ] <NEWLINE> ar [ x ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 0 ] == S [ 1 ] and S [ 2 ] == S [ 3 ] and len ( set ( S ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S [ 0 ] == S [ 2 ] and S [ 1 ] == S [ 3 ] and len ( set ( S ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S [ 0 ] == S [ 3 ] and S [ 1 ] == S [ 2 ] and len ( set ( S ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( ( ( y2 - y1 ) ** 2 + ( x2 - x1 ) ** 2 ) ** ( 1 / 2 ) ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> nlist = list ( map ( int , N ) ) <NEWLINE> if sum ( nlist ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( a ) + sum ( b ) < k : <NEWLINE> <INDENT> ans = m + n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numa = [ 0 ] <NEWLINE> numb = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numa . append ( numa [ - 1 ] + a [ i ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> numb . append ( numb [ - 1 ] + b [ j ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if numa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while numb [ m ] > k - numa [ i ] : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + m ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def exist_or_not ( list , value ) : <NEWLINE> <INDENT> for i in range ( len ( list ) ) : <NEWLINE> <INDENT> if list [ i ] < value : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif list [ i ] == value : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 100001 <NEWLINE> numbers = input ( ) . split ( <STRING> ) <NEWLINE> sum = 0 <NEWLINE> for x in numbers : <NEWLINE> <INDENT> int_x = int ( x ) <NEWLINE> a [ int_x ] += 1 <NEWLINE> sum += int_x <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> <NL> r = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> <NL> <NL> <NL> for i in range ( q ) : <NEWLINE> <INDENT> numbers = input ( ) . split ( <STRING> ) <NEWLINE> b . append ( int ( numbers [ 0 ] ) ) <NEWLINE> c . append ( int ( numbers [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b_count = a [ b [ i ] ] <NEWLINE> a [ c [ i ] ] += b_count <NEWLINE> a [ b [ i ] ] = 0 <NEWLINE> sum += ( c [ i ] - b [ i ] ) * b_count <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> num = [ 0 ] * ( 10 ** 5 ) <NEWLINE> tot = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num [ a [ i ] - 1 ] += 1 <NEWLINE> tot += a [ i ] <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tot += ( num [ b - 1 ] * ( c - b ) ) <NEWLINE> num [ c - 1 ] += num [ b - 1 ] <NEWLINE> num [ b - 1 ] = 0 <NEWLINE> print ( tot ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , 1000000007 ) ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> max = a [ 1 ] - a [ 0 ] <NEWLINE> min = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if max < ( a [ i ] - min ) : <NEWLINE> <INDENT> max = ( a [ i ] - min ) <NEWLINE> <DEDENT> if min > a [ i ] : <NEWLINE> <INDENT> min = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> low = 1 <NEWLINE> high = max ( A ) <NEWLINE> <NL> while low != high : <NEWLINE> <INDENT> mid = ( low + high ) // 2 <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += math . ceil ( A [ i ] / mid ) - 1 <NEWLINE> <DEDENT> if s > k : <NEWLINE> <INDENT> low = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high = mid <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( low ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> n = len ( t ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ x ] <NEWLINE> where = { x : 0 } <NEWLINE> a = x <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = A [ - 1 ] ** 2 % m <NEWLINE> if a in where : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> where [ a ] = i <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> perstart = where [ a ] <NEWLINE> res = sum ( A ) <NEWLINE> rem = n - len ( A ) <NEWLINE> per = len ( A ) - perstart <NEWLINE> res += rem // per * sum ( A [ perstart : perstart + per ] ) <NEWLINE> res += sum ( A [ perstart : perstart + ( rem % per ) ] ) <NEWLINE> <NL> print ( res ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S % 3600 ) // 60 <NEWLINE> s = S - ( ( h * 3600 ) + ( m * 60 ) ) <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE> <NL> <NL>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> def gcds ( x , y , z ) : <NEWLINE> <INDENT> n1 = math . gcd ( x , y ) <NEWLINE> n2 = math . gcd ( n1 , z ) <NEWLINE> return n2 <NEWLINE> <DEDENT> total = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if math . gcd ( i , j ) == 1 : <NEWLINE> <INDENT> total += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for t in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += gcds ( i , j , t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
def checkCapacity ( W , k , P ) : <NEWLINE> <INDENT> ws = 0 <NEWLINE> cnt = 1 <NEWLINE> for wi in W : <NEWLINE> <INDENT> if wi > P : return False <NEWLINE> ws += wi <NEWLINE> if ws > P : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ws = wi <NEWLINE> <DEDENT> if cnt > k : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> W = list ( map ( int , [ input ( ) for _ in range ( n ) ] ) ) <NEWLINE> Pmax = sum ( W ) <NEWLINE> Pmin = 0 <NEWLINE> while Pmin < Pmax : <NEWLINE> <INDENT> P = ( Pmax + Pmin ) // 2 <NEWLINE> if checkCapacity ( W , k , P ) : <NEWLINE> <INDENT> Pmax = P <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Pmin = P + 1 <NEWLINE> <DEDENT> <DEDENT> print ( Pmax ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> minv = int ( input ( ) ) <NEWLINE> maxv = ( 10 ** 9 ) * ( - 1 ) <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> if maxv < ( r - minv ) : <NEWLINE> <INDENT> maxv = r - minv <NEWLINE> <DEDENT> if minv > r : <NEWLINE> <INDENT> minv = r <NEWLINE> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
mat = [ [ [ 0 , 0 ] ] * 10 for _ in range ( 10 ) ] <NEWLINE> def dsr ( i ) : <NEWLINE> <INDENT> x , cnt = 0 , 0 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> w = x + i <NEWLINE> if w > 9 : <NEWLINE> <INDENT> x = w - 9 <NEWLINE> cnt += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = w <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> mat [ i ] [ j ] = [ x , cnt - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> x0 = mat [ i ] [ 9 ] [ 1 ] - mat [ i ] [ 8 ] [ 1 ] <COMMENT> <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> mat [ i ] [ j ] [ 1 ] += x0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> dsr ( i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> cnt = 0 ; x0 = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> d , c = map ( int , input ( ) . split ( ) ) <NEWLINE> q , r = divmod ( c - 1 , 9 ) <NEWLINE> cnt += mat [ d ] [ 8 ] [ 1 ] * q + mat [ d ] [ r ] [ 1 ] - mat [ d ] [ 0 ] [ 1 ] <NEWLINE> x = mat [ d ] [ r ] [ 0 ] <NEWLINE> <COMMENT> <NL> w = x0 + x <NEWLINE> if w > 9 : <NEWLINE> <INDENT> x0 = w - 9 <NEWLINE> cnt += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x0 = w <NEWLINE> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( cnt - 1 ) <NEWLINE> <NL>
mod_673 = [ 1 ] * 672 <NEWLINE> for i in range ( 1 , 672 ) : <NEWLINE> <INDENT> mod_673 [ i ] = ( mod_673 [ i - 1 ] * 10 ) % 673 <NEWLINE> <NL> <DEDENT> S = input ( ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> A = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> B = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> x = 0 <NEWLINE> Ans = [ [ 0 ] * 3 for i in range ( 673 ) ] <NEWLINE> for i in range ( 1 , len ( S ) + 1 ) : <NEWLINE> <INDENT> A [ i ] = ( A [ i - 1 ] + int ( S [ i - 1 ] ) * mod_673 [ ( i - 1 ) % 672 ] ) % 673 <NEWLINE> B [ i ] = ( B [ i - 1 ] + int ( S [ i - 1 ] ) ) % 3 <NEWLINE> <NL> <DEDENT> for i in range ( len ( S ) + 1 ) : <NEWLINE> <INDENT> Ans [ A [ i ] ] [ B [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 673 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> y = Ans [ i ] [ j ] <NEWLINE> x += y * ( y - 1 ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = collections . Counter ( A ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> mono = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> mono . append ( S ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( mono ) ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> x = 7 % k <NEWLINE> cnt = 0 <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> elif cnt == k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( x * 10 + 7 ) % k <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def prime_judge ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sqrt_num = int ( n ** 0.5 ) + 1 <NEWLINE> for i in range ( 3 , sqrt_num , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> prime = [ 0 ] <NEWLINE> for i in range ( 1 , 1000000 ) : <NEWLINE> <INDENT> if prime_judge ( i ) : <NEWLINE> <INDENT> prime . append ( prime [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prime . append ( prime [ - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( prime [ int ( input ( ) ) ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> @ jit <NEWLINE> def loop ( a , k ) : <NEWLINE> <INDENT> if k > 41 : <NEWLINE> <INDENT> ans = np . ones ( N , dtype = np . int64 ) * N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> B = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ max ( 0 , i - int ( ans [ i ] ) ) ] += 1 <NEWLINE> B [ min ( N , i + int ( ans [ i ] ) + 1 ) ] -= 1 <NEWLINE> <DEDENT> ans = np . cumsum ( B ) [ : N ] <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in loop ( A , K ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = np . array ( list ( range ( 1 , N + 1 ) ) ) <NEWLINE> B = np . array ( sorted ( A - r ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( max ( N // 2 - 1 , 0 ) , min ( N // 2 + 2 , N ) ) : <NEWLINE> <INDENT> c = list ( map ( abs , ( B - B [ i ] ) ) ) <NEWLINE> ans = min ( ans , sum ( c ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sd = set ( D ) <NEWLINE> st = set ( T ) <NEWLINE> cntd = Counter ( D ) <NEWLINE> cntt = Counter ( T ) <NEWLINE> ok = True <NEWLINE> for t in T : <NEWLINE> <INDENT> if t not in sd : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> elif cntt [ t ] > cntd [ t ] : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , N = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> def f ( x : int ) -> int : <NEWLINE> <INDENT> return ( A * x ) // B - A * ( x // B ) <NEWLINE> <NL> <DEDENT> x = min ( N , B - 1 ) <NEWLINE> print ( f ( x ) ) <NEWLINE>
import math <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : return False <NEWLINE> <NL> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> b = 1 <NEWLINE> tmp_ans = 0 <NEWLINE> ans = 10 ** 12 <NEWLINE> <NL> if is_prime ( n ) == True : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> elif is_prime ( n ) == False : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> j = n // i <NEWLINE> if n == i * j : <NEWLINE> <INDENT> tmp_ans = ( i - a ) + ( j - b ) <NEWLINE> if tmp_ans < ans : <NEWLINE> <INDENT> ans = tmp_ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( str , input ( ) ) ) <NEWLINE> li = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> answer = [ ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( len ( li ) ) : <NEWLINE> <INDENT> if S [ i ] == li [ j ] and j < len ( li ) - N : <NEWLINE> <INDENT> answer . append ( li [ j + N ] ) <NEWLINE> <DEDENT> elif S [ i ] == li [ j ] and j >= len ( li ) - N : <NEWLINE> <INDENT> answer . append ( li [ j + N - len ( li ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( answer ) ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> route = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> route [ a ] . append ( b ) <NEWLINE> route [ b ] . append ( a ) <NEWLINE> <DEDENT> visited = [ 0 for i in range ( n + 1 ) ] <NEWLINE> visited [ 1 ] = 1 <NEWLINE> ans = [ 0 for i in range ( n + 1 ) ] <NEWLINE> D = deque ( ) <NEWLINE> D . append ( 1 ) <NEWLINE> while D : <NEWLINE> <INDENT> visit = D . popleft ( ) <NEWLINE> for i in route [ visit ] : <NEWLINE> <INDENT> if visited [ i ] == 0 : <NEWLINE> <INDENT> D . append ( i ) <NEWLINE> visited [ i ] = 1 <NEWLINE> ans [ i ] = visit <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> now = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 or s [ i - 1 ] == <STRING> or s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> if i + 1 < len ( s ) and ( s [ i + 1 ] == <STRING> or s [ i + 1 ] == <STRING> ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> rev_edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> edges [ i ] . append ( ( i + alst [ i ] ) % n ) <NEWLINE> rev_edges [ ( i + alst [ i ] ) % n ] . append ( i ) <NEWLINE> <NL> <DEDENT> def dfs ( x , ret , edges , visited ) : <NEWLINE> <INDENT> visited [ x ] = True <NEWLINE> for e in edges [ x ] : <NEWLINE> <INDENT> if not visited [ e ] : <NEWLINE> <INDENT> dfs ( e , ret , edges , visited ) <NEWLINE> <DEDENT> <DEDENT> ret . append ( x ) <NEWLINE> <NL> <DEDENT> def dfs_rev ( x , cycles , rev_edges , visited ) : <NEWLINE> <INDENT> visited [ x ] = True <NEWLINE> flag = False <NEWLINE> for e in rev_edges [ x ] : <NEWLINE> <INDENT> if not visited [ e ] : <NEWLINE> <INDENT> cycles . add ( e ) <NEWLINE> dfs_rev ( e , cycles , rev_edges , visited ) <NEWLINE> flag = True <NEWLINE> <DEDENT> elif x == e : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> cycles . add ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> order = [ ] <NEWLINE> visited = [ False ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> dfs ( i , order , edges , visited ) <NEWLINE> <DEDENT> <DEDENT> order . reverse ( ) <NEWLINE> <NL> visited = [ False ] * n <NEWLINE> cycles = set ( ) <NEWLINE> for i in order : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> dfs_rev ( i , cycles , rev_edges , visited ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( cycles ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> import heapq <NEWLINE> <NL> def dijkstra ( s , edge ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ float ( <STRING> ) ] * n <NEWLINE> used = [ True ] * n <COMMENT> <NEWLINE> d [ s ] = 0 <NEWLINE> used [ s ] = False <NEWLINE> edgelist = [ ] <NEWLINE> for e in edge [ s ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , e ) <NEWLINE> <DEDENT> while len ( edgelist ) : <NEWLINE> <INDENT> minedge = heapq . heappop ( edgelist ) <NEWLINE> <COMMENT> <NL> if not used [ minedge [ 1 ] ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = minedge [ 1 ] <NEWLINE> d [ v ] = minedge [ 0 ] <NEWLINE> used [ v ] = False <NEWLINE> for e in edge [ v ] : <NEWLINE> <INDENT> if used [ e [ 1 ] ] : <NEWLINE> <INDENT> heapq . heappush ( edgelist , [ e [ 0 ] + d [ v ] , e [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> n , m , s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s , t = s - 1 , t - 1 <NEWLINE> edge1 = [ [ ] for _ in range ( n ) ] <NEWLINE> edge2 = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edge1 [ u - 1 ] . append ( [ a , v - 1 ] ) <NEWLINE> edge1 [ v - 1 ] . append ( [ a , u - 1 ] ) <NEWLINE> edge2 [ u - 1 ] . append ( [ b , v - 1 ] ) <NEWLINE> edge2 [ v - 1 ] . append ( [ b , u - 1 ] ) <NEWLINE> <DEDENT> d1 = dijkstra ( s , edge1 ) <NEWLINE> d2 = dijkstra ( t , edge2 ) <NEWLINE> INF = 10 ** 15 <NEWLINE> ans = [ INF ] * n <NEWLINE> ans [ n - 1 ] = int ( d1 [ n - 1 ] + d2 [ n - 1 ] ) <NEWLINE> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = int ( d1 [ i ] + d2 [ i ] ) <NEWLINE> ans [ i ] = min ( tmp , ans [ i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( INF - ans [ i ] ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> from bisect import bisect_right <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def ruiseki ( lst ) : <NEWLINE> <INDENT> return [ 0 ] + list ( accumulate ( lst ) ) <NEWLINE> <NL> <DEDENT> ar = ruiseki ( A ) <NEWLINE> br = ruiseki ( B ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 + N ) : <NEWLINE> <INDENT> left = K - ar [ i ] <NEWLINE> if left < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> bidx = bisect_right ( br , left ) - 1 <NEWLINE> ans = max ( ans , i + bidx ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> left = 0 <NEWLINE> right = len ( s ) - 1 <NEWLINE> x_cnt = 0 <NEWLINE> <NL> while left < right : <NEWLINE> <INDENT> if s [ left ] == s [ right ] : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ left ] == <STRING> : <NEWLINE> <INDENT> x_cnt += 1 <NEWLINE> left += 1 <NEWLINE> <DEDENT> elif s [ right ] == <STRING> : <NEWLINE> <INDENT> x_cnt += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x_cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> from bisect import bisect_left , bisect_right <NEWLINE> <NL> n , d , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> xh = dict ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> xi , hi = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( xi ) <NEWLINE> xh [ xi ] = hi <NEWLINE> <DEDENT> x . sort ( ) <NEWLINE> <NL> l = 0 <NEWLINE> ret = 0 <NEWLINE> ai = [ 0 ] * ( n + 1 ) <NEWLINE> anow = 0 <NEWLINE> while l < n : <NEWLINE> <INDENT> xl = x [ l ] <NEWLINE> hl = xh [ xl ] <NEWLINE> anow += ai [ l ] <NEWLINE> hl -= a * anow <NEWLINE> if hl > 0 : <NEWLINE> <INDENT> r = bisect_right ( x , xl + 2 * d ) <NEWLINE> k = ( hl + ( a - 1 ) ) // a <NEWLINE> ret += k <NEWLINE> anow += k <NEWLINE> ai [ r ] -= k <NEWLINE> <DEDENT> l += 1 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> sth , stw = 0 , 0 <NEWLINE> glh , glw = H - 1 , W - 1 <NEWLINE> <NL> INF = 10000 <NEWLINE> Gmap = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> Dist = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> direc = { ( 1 , 0 ) , ( 0 , 1 ) } <NEWLINE> <NL> if Gmap [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> Dist [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Dist [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> nw = Gmap [ h ] [ w ] <NEWLINE> for d in direc : <NEWLINE> <INDENT> hs , ws = h + d [ 0 ] , w + d [ 1 ] <NEWLINE> if 0 <= hs < H and 0 <= ws < W : <NEWLINE> <INDENT> cr = Gmap [ hs ] [ ws ] <NEWLINE> Dist [ hs ] [ ws ] = min ( Dist [ hs ] [ ws ] , Dist [ h ] [ w ] + ( cr == <STRING> and nw == <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( Dist [ glh ] [ glw ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
F = [ 1 , 1 ] + [ 0 for i in range ( 44 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> F [ i ] = F [ i - 1 ] + F [ i - 2 ] <NEWLINE> <NL> <DEDENT> print ( F [ n ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> from collections import deque <NEWLINE> <NL> pot = deque ( [ A . pop ( ) ] ) <NEWLINE> com = 0 <NEWLINE> while A : <NEWLINE> <INDENT> com += pot . pop ( ) <NEWLINE> new = A . pop ( ) <NEWLINE> pot . appendleft ( new ) <NEWLINE> pot . appendleft ( new ) <NEWLINE> <NL> <DEDENT> print ( com ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( 1 , K ) : <NEWLINE> <INDENT> for k in range ( 1 , K ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> avg = round ( sum ( a ) / N ) <NEWLINE> sums = [ ] <NEWLINE> for i in range ( min ( a ) , avg + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> s += ( i - a [ j ] ) ** 2 <NEWLINE> <DEDENT> sums . append ( s ) <NEWLINE> <DEDENT> print ( min ( sums ) ) <NEWLINE>
from networkx import * <NEWLINE> _ , * t = map ( str . split , open ( 0 ) ) <NEWLINE> print ( max ( 1 , 1 , * map ( len , connected_components ( Graph ( t ) ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i ** 2 >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if i * j >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 2 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import itertools <NEWLINE> <NL> def _get_distance ( p1 , p2 ) : <NEWLINE> <INDENT> return ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> <NL> <DEDENT> def _get_min_distance ( points ) : <NEWLINE> <INDENT> min_d = 400 <NEWLINE> for p1 , p2 in itertools . combinations ( points , 2 ) : <NEWLINE> <INDENT> min_d = min ( min_d , _get_distance ( p1 , p2 ) ) <NEWLINE> <DEDENT> return min_d <NEWLINE> <NL> <DEDENT> def closest_pair_distance ( points , axis ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = len ( points ) <NEWLINE> if n <= 3 : <NEWLINE> <INDENT> return _get_min_distance ( points ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mid = n // 2 <NEWLINE> px , py = zip ( * points ) <NEWLINE> if len ( set ( px ) ) > len ( set ( py ) ) : <NEWLINE> <INDENT> if axis : <NEWLINE> <INDENT> points . sort ( key = lambda p : p [ 0 ] ) <NEWLINE> <DEDENT> axis1 = 0 <NEWLINE> axis2 = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not axis : <NEWLINE> <INDENT> points . sort ( key = lambda p : p [ 1 ] ) <NEWLINE> <DEDENT> axis1 = 1 <NEWLINE> axis2 = 0 <NEWLINE> <DEDENT> A_points = points [ : mid ] <NEWLINE> B_points = points [ mid : ] <NEWLINE> d_Amin = closest_pair_distance ( A_points . copy ( ) , axis1 ) <NEWLINE> d_Bmin = closest_pair_distance ( B_points . copy ( ) , axis1 ) <NEWLINE> dist = min ( d_Amin , d_Bmin ) <NEWLINE> min_d = dist <NEWLINE> for ap in A_points [ : : - 1 ] : <NEWLINE> <INDENT> if B_points [ 0 ] [ axis1 ] - ap [ axis1 ] >= dist : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for bp in B_points : <NEWLINE> <INDENT> if bp [ axis1 ] - ap [ axis1 ] >= dist : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ap [ axis2 ] - dist < bp [ axis2 ] < ap [ axis2 ] + dist : <NEWLINE> <INDENT> min_d = min ( min_d , _get_distance ( ap , bp ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return min_d <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> file_input = sys . stdin <NEWLINE> <NL> n = int ( file_input . readline ( ) ) <NEWLINE> <NL> P = [ tuple ( map ( float , line . split ( ) ) ) for line in file_input ] <NEWLINE> <NL> <COMMENT> <NL> P . sort ( key = lambda p : p [ 0 ] ) <NEWLINE> ans = closest_pair_distance ( P , 0 ) <NEWLINE> <NL> print ( <STRING> . format ( ans ) ) <NEWLINE>
<COMMENT> <NL> from itertools import combinations_with_replacement as cw <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a_candidates = cw ( [ i + 1 for i in range ( m ) ] , n ) <NEWLINE> fs = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> def calc ( fs , As ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for a , b , c , d in fs : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if As [ b ] - As [ a ] == c : cnt += d <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for As in list ( a_candidates ) : <NEWLINE> <INDENT> ans = max ( ans , calc ( fs , As ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if 400 <= x <= 599 : ans = 8 <NEWLINE> elif 600 <= x <= 799 : ans = 7 <NEWLINE> elif 800 <= x <= 999 : ans = 6 <NEWLINE> elif 1000 <= x <= 1199 : ans = 5 <NEWLINE> elif 1200 <= x <= 1399 : ans = 4 <NEWLINE> elif 1400 <= x <= 1599 : ans = 3 <NEWLINE> elif 1600 <= x <= 1799 : ans = 2 <NEWLINE> elif 1800 <= x <= 1999 : ans = 1 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> g [ a ] . append ( ( b , c ) ) <NEWLINE> g [ b ] . append ( ( a , c ) ) <NEWLINE> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> dist = [ - 1 ] * n <NEWLINE> <NL> def dfs ( st , depth = 0 ) : <NEWLINE> <INDENT> dist [ st ] = depth <NEWLINE> for to , c in g [ st ] : <NEWLINE> <INDENT> if dist [ to ] >= 0 : continue <NEWLINE> dfs ( to , depth + c ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( k - 1 , 0 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 ; y -= 1 <NEWLINE> print ( dist [ x ] + dist [ y ] ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a_list . sort ( ) <NEWLINE> ans = 1 <NEWLINE> if k % 2 == 1 and a_list [ - 1 ] < 0 : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans *= a_list [ n - 1 - i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = - 1 <NEWLINE> mlt1 = a_list [ 0 ] * a_list [ 1 ] <NEWLINE> mlt2 = a_list [ - 2 ] * a_list [ - 1 ] <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if count == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif count == k - 1 : <NEWLINE> <INDENT> ans *= a_list [ r ] % mod <NEWLINE> ans %= mod <NEWLINE> break <NEWLINE> <DEDENT> if mlt1 >= mlt2 : <NEWLINE> <INDENT> ans *= mlt1 % mod <NEWLINE> l += 2 <NEWLINE> count += 2 <NEWLINE> if l <= n - 2 : <NEWLINE> <INDENT> mlt1 = a_list [ l + 1 ] * a_list [ l ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans *= a_list [ r ] % mod <NEWLINE> r -= 1 <NEWLINE> count += 1 <NEWLINE> if r >= - n + 1 : <NEWLINE> <INDENT> mlt2 = a_list [ r - 1 ] * a_list [ r ] <NEWLINE> <DEDENT> <DEDENT> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> st = deque ( ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> num = ( n - 1 ) % 26 <NEWLINE> n = ( n - 1 ) // 26 <NEWLINE> st . appendleft ( chr ( num + 97 ) ) <NEWLINE> <DEDENT> print ( * st , sep = <STRING> ) <NEWLINE>
import time <NEWLINE> <NL> start_time = time . time ( ) <NEWLINE> <NL> <COMMENT> <NL> D = int ( input ( ) ) <NEWLINE> c_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s_grid = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> array = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> s_grid . append ( array ) <NEWLINE> <NL> <DEDENT> t_list = [ ( i % 26 ) for i in range ( D ) ] <COMMENT> <NEWLINE> <NL> def calculate_score ( t_list , score_list , last_grid , change_query_number ) : <NEWLINE> <INDENT> score_list = score_list [ : change_query_number ] <NEWLINE> last_grid = last_grid [ : change_query_number ] <NEWLINE> <NL> if len ( score_list ) > 1 : <NEWLINE> <INDENT> score = score_list [ change_query_number - 1 ] <NEWLINE> last_list = last_grid [ change_query_number - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = 0 <NEWLINE> last_list = [ 0 for i in range ( 26 ) ] <NEWLINE> <NL> <DEDENT> for d in range ( change_query_number , D ) : <NEWLINE> <INDENT> score += s_grid [ d ] [ t_list [ d ] ] <NEWLINE> last_list = [ n + 1 for n in last_list ] <NEWLINE> last_list [ t_list [ d ] ] = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> score -= c_list [ i ] * last_list [ i ] <NEWLINE> <DEDENT> score_list . append ( score ) <NEWLINE> last_grid . append ( last_list ) <NEWLINE> <DEDENT> return score_list , last_grid <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> previous_s , previous_l = calculate_score ( t_list , [ ] , [ [ 0 for i in range ( 26 ) ] ] , 0 ) <NEWLINE> score = previous_s [ - 1 ] <NEWLINE> <NL> for k in range ( D - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> X = - 1 <COMMENT> <NEWLINE> t_list_loop = t_list <NEWLINE> for i in range ( 26 ) : <COMMENT> <NEWLINE> <INDENT> t_list_loop [ k ] = i <NEWLINE> score_list_k , last_grid_k = calculate_score ( t_list_loop , previous_s , previous_l , k ) <NEWLINE> if score_list_k [ - 1 ] > score : <NEWLINE> <INDENT> X = i <NEWLINE> score = score_list_k [ - 1 ] <NEWLINE> score_list_t = score_list_k <NEWLINE> last_grid_t = last_grid_k <NEWLINE> <NL> <DEDENT> <DEDENT> if X != - 1 : <NEWLINE> <INDENT> t_list [ k ] = X <NEWLINE> previous_s = score_list_t <NEWLINE> previous_l = last_grid_t <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if time . time ( ) - start_time > 1.9 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( len ( t_list ) ) : <NEWLINE> <INDENT> print ( int ( t_list [ j ] ) + 1 ) <NEWLINE> <DEDENT>
